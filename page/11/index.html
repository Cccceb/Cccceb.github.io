<!DOCTYPE html>


<html lang="en" >


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Hexo
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

  <script type="text/javascript"
	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-与非门电路" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E4%B8%8E%E9%9D%9E%E9%97%A8%E7%94%B5%E8%B7%AF/"
    >与非门电路</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E4%B8%8E%E9%9D%9E%E9%97%A8%E7%94%B5%E8%B7%AF/" class="article-date">
  <time datetime="2020-03-30T02:15:00.732Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="UVA-1607-与非门电路"><a href="#UVA-1607-与非门电路" class="headerlink" title="UVA 1607 与非门电路"></a>UVA 1607 与非门电路</h1><p>可以用与非门（NAND）来设计逻辑电路，每个NAND门有两个输入端，输出为两个输入端与非运算的结果。也就是说 两个输入都是1是输出是0，其他输入输出都是1，给出一个由m（m&lt;=200000）个NAND组成的无环电路，电路的所有n个输入（n&lt;=100000）全部连接到一个相同的输入x,请把其中的一些输入设置为常数，用最少的x完成相同功能。输出任意方案即可。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>因为只有一个输入x，所以输出只有四种可能，0,1,x,x’</li>
<li>首先令输出全0和全1，比较二者结果，如果相等，那么说明输出与x无关 ，整个电路肯定是常数。</li>
<li>否则说明与x有关。不妨设x=0时输出0，x=1时输出1。假设现在把输入从00000改成10000，如果输出为1，那么可以得到一个解x0000，否则继续尝试11000，如果输出为1，则得到一个解1x000…直到输入全1时输出为1。</li>
<li>由于m很大，所以采用二分法，二分1的个数，再计算输出。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="output-计算0-k出入为0时的输出"><a href="#output-计算0-k出入为0时的输出" class="headerlink" title="output 计算0~k出入为0时的输出"></a>output 计算0~k出入为0时的输出</h2><ol>
<li>注 输入格式中，负数代表从门输入，正数代表从其他门的输出来输入。数字绝对值代表门或输入的编号。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int output(int k) &#123;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">		int a &#x3D; gate[i].a;</span><br><span class="line">		int b &#x3D; gate[i].b;</span><br><span class="line">		int va &#x3D; a&lt;0 ? -a&gt;k:gate[a].o; </span><br><span class="line">		int vb &#x3D; b&lt;0 ? -b&gt;k:gate[b].o;</span><br><span class="line"></span><br><span class="line">		gate[i].o &#x3D; !(va&amp;&amp;vb);</span><br><span class="line">	&#125;</span><br><span class="line">	return gate[m].o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sovle-二分查找过程"><a href="#sovle-二分查找过程" class="headerlink" title="sovle 二分查找过程"></a>sovle 二分查找过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int solve(int vn) &#123;</span><br><span class="line">	int L &#x3D; 1, R &#x3D; n;</span><br><span class="line">	while (L&lt;R)</span><br><span class="line">	&#123;</span><br><span class="line">		int m &#x3D; L + (R - L) &#x2F; 2;</span><br><span class="line">		if (output(m) &#x3D;&#x3D; vn) R &#x3D; m;</span><br><span class="line">		else L &#x3D; m+1;</span><br><span class="line">	&#125;</span><br><span class="line">	return L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxm &#x3D; 200000 + 5;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line">struct Gates &#123;</span><br><span class="line">	int a, b, o;</span><br><span class="line">&#125; gate[maxm];</span><br><span class="line"></span><br><span class="line">inline int output(int k);</span><br><span class="line">inline int solve(int);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d  %d&quot;, &amp;n, &amp;m);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">			scanf(&quot;%d  %d&quot;, &amp;gate[i].a, &amp;gate[i].b);</span><br><span class="line">		int v0, vn;</span><br><span class="line">		v0 &#x3D; output(0);</span><br><span class="line">		vn &#x3D; output(n);</span><br><span class="line">		if (v0 &#x3D;&#x3D; vn) &#123;</span><br><span class="line">			for (int i &#x3D; 1; i &lt;&#x3D; n; i++) printf(&quot;0&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			int ix &#x3D; solve(vn);</span><br><span class="line">			for (int i &#x3D; 1; i &lt; ix; i++) printf(&quot;0&quot;);</span><br><span class="line">			printf(&quot;x&quot;);</span><br><span class="line">			for (int i &#x3D; ix + 1; i &lt;&#x3D; n; i++) printf(&quot;1&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-在Web中搜索" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%9C%A8Web%E4%B8%AD%E6%90%9C%E7%B4%A2/"
    >在Web中搜索</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%9C%A8Web%E4%B8%AD%E6%90%9C%E7%B4%A2/" class="article-date">
  <time datetime="2020-03-30T02:15:00.732Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-1597-在web中搜索"><a href="#uva-1597-在web中搜索" class="headerlink" title="uva 1597 在web中搜索"></a>uva 1597 在web中搜索</h1><p>输入nnn篇文章和mmm个请求（n&lt;100，m≤50000n &lt; 100\text{，}m \leq 50000n&lt;100，m≤50000），每个请求都是444种格式之一。</p>
<p>A: 找包含关键字A的文章。</p>
<p>A AND B 找同时包含关键字A和B的文章。</p>
<p>A OR B 找包含关键字A或B的文章。</p>
<p>NOT A 找不包含关键字A的文章。</p>
<p>处理询问时需要对每篇文章输出证据。前3种询问输出所有至少包含一个关键字的行。第4种询问输出不包含A的整篇文章。关键字只由小写字母组成，查找时忽略大小写。每行不超过不超过80字符，一共不超过1500行。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>主要的STL是一个map&lt;string,set<Node>&gt; 用来存储每个单词出现的段号和行号。vector<string> txt[i]来存储第i段的若干句子，一句一句的存。</li>
<li>对于AND指令，需要n2次查找两个单词出现的段落和行号，只有当两个单词出现的段落一致的时候，才输出</li>
<li>OR指令同理</li>
<li>NOT需要循环所有的段落，对于A出现的段落集合中不包括的段，将它防在答案集合中<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line"># pragma warning(disable:4996)</span><br><span class="line"># define LOCAL</span><br><span class="line"># ifdef LOCAL</span><br><span class="line">FILE *fin &#x3D; freopen(&quot;习题5-10in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">FILE *fout &#x3D; freopen(&quot;习题5-10out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line"># endif </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; txt[105];</span><br><span class="line">map&lt;string, set&lt;int&gt;&gt; which_pa;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int p;</span><br><span class="line">	int r;</span><br><span class="line">	node(int p, int r) :p(p), r(r) &#123;&#125;</span><br><span class="line">	bool operator &lt;(const node&amp;a) const &#123;</span><br><span class="line">		return p &lt; a.p || p &#x3D;&#x3D; a.p&amp;&amp;r &lt; a.r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, set&lt;node&gt;&gt; words_in_where;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	string s;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n); getchar();</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">		while (getline(cin, s) &amp;&amp; s !&#x3D; &quot;**********&quot;) &#123;</span><br><span class="line">			txt[i].push_back(s);</span><br><span class="line">			string r;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; s.length(); j++) &#123;</span><br><span class="line">				if (isalpha(s[j])) r +&#x3D; tolower(s[j]);</span><br><span class="line">				else &#123;</span><br><span class="line">					if (!r.empty()) &#123;</span><br><span class="line">						words_in_where[r].insert(node(i, txt[i].size() - 1));</span><br><span class="line">						which_pa[r].insert(i);</span><br><span class="line">					&#125;</span><br><span class="line">					r.clear();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	scanf(&quot;%d&quot;, &amp;m); getchar();</span><br><span class="line">	for (int ff &#x3D; 0; ff &lt; m; ff++) &#123;</span><br><span class="line">		getline(cin, s);</span><br><span class="line">		int orx;</span><br><span class="line">		&#x2F;&#x2F;cout &lt;&lt; endl &lt;&lt; s &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">		if ((orx &#x3D; s.find(&quot; AND &quot;)) !&#x3D; string::npos) &#123;</span><br><span class="line">			string a &#x3D; s.substr(0, orx);</span><br><span class="line">			string b &#x3D; s.substr(orx + 5);</span><br><span class="line">			&#x2F;&#x2F;	cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">			set&lt;node&gt; aw &#x3D; words_in_where[a];</span><br><span class="line">			set&lt;node&gt; bw &#x3D; words_in_where[b];</span><br><span class="line">			set&lt;node&gt; ans;</span><br><span class="line">			ans.clear();</span><br><span class="line">			if (a &#x3D;&#x3D; b) &#123;</span><br><span class="line">				for (set&lt;node&gt;::iterator it &#x3D; aw.begin(); it !&#x3D; aw.end(); it++)</span><br><span class="line">					ans.insert(*it);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				for (set&lt;node&gt;::iterator it &#x3D; aw.begin(); it !&#x3D; aw.end(); it++)</span><br><span class="line">					for (set&lt;node&gt;::iterator id &#x3D; bw.begin(); id !&#x3D; bw.end(); id++)</span><br><span class="line">						if ((*it).p &#x3D;&#x3D; (*id).p) &#123;</span><br><span class="line">							ans.insert(*it);</span><br><span class="line">							ans.insert(*id);</span><br><span class="line">						&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (ans.empty()) &#123;</span><br><span class="line">				cout &lt;&lt; &quot;Sorry, I found nothing.&quot; &lt;&lt; endl &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			int k &#x3D; ans.begin()-&gt;p;</span><br><span class="line">			for (set&lt;node&gt;::iterator it &#x3D; ans.begin(); it !&#x3D; ans.end(); it++)</span><br><span class="line">			&#123;</span><br><span class="line">				int p &#x3D; (*it).p;</span><br><span class="line">				int r &#x3D; (*it).r;</span><br><span class="line">				if (k !&#x3D; p) &#123;</span><br><span class="line">					cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;</span><br><span class="line">					k &#x3D; p;</span><br><span class="line">				&#125;</span><br><span class="line">				cout &lt;&lt; txt[p][r] &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else if ((orx &#x3D; s.find(&quot; OR &quot;)) !&#x3D; string::npos) &#123;</span><br><span class="line">			string a &#x3D; s.substr(0, orx);</span><br><span class="line">			string b &#x3D; s.substr(orx + 4);</span><br><span class="line">			&#x2F;&#x2F;cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">			set&lt;node&gt; aw &#x3D; words_in_where[a];</span><br><span class="line">			set&lt;node&gt; bw &#x3D; words_in_where[b];</span><br><span class="line">			set&lt;node&gt; ans;</span><br><span class="line">			ans.clear();</span><br><span class="line">			if (a &#x3D;&#x3D; b) &#123;</span><br><span class="line">				for (set&lt;node&gt;::iterator it &#x3D; aw.begin(); it !&#x3D; aw.end(); it++) &#123;</span><br><span class="line">					ans.insert(*it);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				for (set&lt;node&gt;::iterator it &#x3D; aw.begin(); it !&#x3D; aw.end(); it++)</span><br><span class="line">					ans.insert(*it);</span><br><span class="line">				for (set&lt;node&gt;::iterator id &#x3D; bw.begin(); id !&#x3D; bw.end(); id++)</span><br><span class="line">					ans.insert(*id);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (ans.empty()) &#123;</span><br><span class="line">				cout &lt;&lt; &quot;Sorry, I found nothing.&quot; &lt;&lt; endl &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			int k &#x3D; ans.begin()-&gt;p;</span><br><span class="line">			for (set&lt;node&gt;::iterator it &#x3D; ans.begin(); it !&#x3D; ans.end(); it++)</span><br><span class="line">			&#123;</span><br><span class="line">				int p &#x3D; (*it).p;</span><br><span class="line">				int r &#x3D; (*it).r;</span><br><span class="line">				if (k !&#x3D; p) &#123;</span><br><span class="line">					cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;</span><br><span class="line">					k &#x3D; p;</span><br><span class="line">				&#125;</span><br><span class="line">				cout &lt;&lt; txt[p][r] &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (s[0]&#x3D;&#x3D;&#39;N&#39;) &#123;</span><br><span class="line">			string no &#x3D; s.substr(4);</span><br><span class="line">			&#x2F;&#x2F;cout &lt;&lt; no &lt;&lt; endl;</span><br><span class="line">			bool flag &#x3D; false;</span><br><span class="line">			bool first &#x3D; true;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">				if (!which_pa[no].count(i)) &#123;</span><br><span class="line">					if (first) first &#x3D; false; else cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;</span><br><span class="line">					for (int j &#x3D; 0; j &lt; txt[i].size(); j++)</span><br><span class="line">						cout &lt;&lt; txt[i][j] &lt;&lt; endl;</span><br><span class="line">					flag &#x3D; true;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (flag) cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">			else cout &lt;&lt; &quot;Sorry, I found nothing.&quot; &lt;&lt; endl &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			&#x2F;&#x2F;cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">			if (!words_in_where.count(s)) &#123;</span><br><span class="line">				cout &lt;&lt; &quot;Sorry, I found nothing.&quot; &lt;&lt; endl &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;##    ##  </span><br><span class="line">			int k &#x3D; words_in_where[s].begin()-&gt;p;</span><br><span class="line">			for (set&lt;node&gt;::iterator it &#x3D; words_in_where[s].begin(); it !&#x3D; words_in_where[s].end(); it++) &#123;</span><br><span class="line">				int p &#x3D; (*it).p;</span><br><span class="line">				int r &#x3D; (*it).r;</span><br><span class="line">				if (k !&#x3D; p) &#123;</span><br><span class="line">					cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;</span><br><span class="line">					k &#x3D; p;</span><br><span class="line">				&#125;</span><br><span class="line">				cout &lt;&lt; txt[p][r] &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;if (first) cout &lt;&lt; &quot;Sorry, I found nothing.&quot; &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-循环小数" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%BE%AA%E7%8E%AF%E5%B0%8F%E6%95%B0/"
    >循环小数</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%BE%AA%E7%8E%AF%E5%B0%8F%E6%95%B0/" class="article-date">
  <time datetime="2020-03-30T02:15:00.732Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-202-循环小数"><a href="#uva-202-循环小数" class="headerlink" title="uva 202 循环小数"></a>uva 202 循环小数</h1><p>输入整数aaa 和bbb （0≤aaa ≤3000,1≤bbb ≤3000），输出a/b的循环小数表示以及循环节的长度。例如aaa =5，bbb =43 小数表示为0.(116279069767441860465)，循环节长度为21。 补充： 如果循环节超过50位，就在第50位后打省略号（三个点，就像“…”）</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   #include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;习题3-8in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;习题3-8out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   &#x2F;&#x2F;被除数出现重复，那么出现了循环节</span><br><span class="line">   const int maxn &#x3D; 100000 + 5;</span><br><span class="line">   </span><br><span class="line">   int a, b;</span><br><span class="line">   int vis[maxn], res[maxn];</span><br><span class="line">   </span><br><span class="line">   int main() &#123;</span><br><span class="line">while (scanf(&quot;%d%d&quot;, &amp;a, &amp;b) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">	memset(vis, -1, sizeof(vis));</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;※这样做可以得到所有小数</span><br><span class="line">	&#x2F;&#x2F;vis用来确定是否出现循环，res存小数部分</span><br><span class="line">	&#x2F;&#x2F;本题特殊在于一但出现一个数字重复，那么可以认为出现循环节</span><br><span class="line">	int c &#x3D; a % b, cnt &#x3D; 0;</span><br><span class="line">	c *&#x3D; 10;</span><br><span class="line">	while (vis[c] &#x3D;&#x3D; -1) &#123;</span><br><span class="line">		res[cnt] &#x3D; c &#x2F; b;</span><br><span class="line">		vis[c] &#x3D; cnt++;</span><br><span class="line">		c %&#x3D; b;</span><br><span class="line">		c *&#x3D; 10;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; repeating cycle start-position</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	int sta_pos &#x3D; vis[c];</span><br><span class="line">	printf(&quot;%d&#x2F;%d &#x3D; %d.&quot;, a, b, a &#x2F; b);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; sta_pos; i++) &#123;</span><br><span class="line">		printf(&quot;%d&quot;, res[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;(&quot;);</span><br><span class="line">	if (cnt - sta_pos &lt;&#x3D; 50) &#123;</span><br><span class="line">		for (int i &#x3D; sta_pos; i &lt; cnt; i++) &#123;</span><br><span class="line">			printf(&quot;%d&quot;, res[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		for (int i &#x3D; sta_pos; i &lt; sta_pos + 50; i++) &#123;</span><br><span class="line">			printf(&quot;%d&quot;, res[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;...&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;)\n&quot;);</span><br><span class="line">	printf(&quot;   %d &#x3D; number of digits in repeating cycle\n\n&quot;, cnt - sta_pos);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-移动木块" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E7%A7%BB%E5%8A%A8%E6%9C%A8%E5%9D%97/"
    >移动木块</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E7%A7%BB%E5%8A%A8%E6%9C%A8%E5%9D%97/" class="article-date">
  <time datetime="2020-03-30T02:15:00.732Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-12657-移动盒子"><a href="#uva-12657-移动盒子" class="headerlink" title="uva 12657 移动盒子"></a>uva 12657 移动盒子</h1><p>你有n个盒子在桌子上的一条线上从左到右编号为1……n。你的任务是模拟四种操作</p>
<p>1 X Y 移动盒子编号X到盒子编号Y的左边（如果X已经在Y的左边了就忽略）</p>
<p>2 X Y 移动盒子编号X到盒子编号Y的右边（如果X已经在Y的右边了就忽略）</p>
<p>3 X Y 交换盒子编号X与盒子编号Y的位置</p>
<p>4 将整条线反转</p>
<p>操作保证合法，X不等于Y</p>
<p>举一个例子，如果n=6，操作 1 1 4然后就变成了2 3 1 4 5 6；再操作 2 3 5就变成了 2 1 4 5 3 6；再操作 3 1 6 就变成 2 6 4 5 3 1；最后操作4，就变成了 1 3 5 4 6 2</p>
<p>输入</p>
<p>最多有10组数据，每个数据会包含两个整数n,m（1≤n,m&lt;100,000）, 接下来是m行数据，表示操作。</p>
<p>输出</p>
<p>对于每组数据，输出他们奇数位置的编号的和。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题中操作使得插入可以在任意位置进行（看起来双端队列好像可以，但是光标移动到HOME之后，就不是在头部插入了）</p>
<ol>
<li>考虑用双向链表，因为用数组会超时，用单向链表又不够</li>
<li>定义辅助函数link来连接链表</li>
<li>定义inv来标识4号反转指令执行了几次，如果是奇数次，那么op=3-op（即放左边变成放右边），如果是偶数次，那么不变。</li>
<li>对于指令三，需要注意当XY相邻的时候，情况不一样。代码中对于此处用了技巧，比如X在Y的相邻右侧，并且交换XY之后Y在X的右侧，则XY相邻。<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    #include&lt;iostream&gt;</span><br><span class="line">    #include&lt;cstring&gt;</span><br><span class="line">    #include&lt;algorithm&gt;</span><br><span class="line">    # pragma warning(disable:4996)</span><br><span class="line">    # define LOCAL</span><br><span class="line">    # ifdef LOCAL</span><br><span class="line">    FILE *fin &#x3D; freopen(&quot;移动盒子in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    FILE *fout &#x3D; freopen(&quot;移动盒子out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    # endif </span><br><span class="line">    # define maxn 100005</span><br><span class="line">    int left[maxn], right[maxn];</span><br><span class="line">    void link(int l, int r) &#123;</span><br><span class="line">    	left[r] &#x3D; l;</span><br><span class="line">    	right[l] &#x3D; r;</span><br><span class="line">    &#125;</span><br><span class="line">    int main() &#123;</span><br><span class="line">    	int n, m;</span><br><span class="line">	int kase &#x3D; 0;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			left[i] &#x3D; i - 1;</span><br><span class="line">			right[i] &#x3D; (i + 1) % (n + 1);</span><br><span class="line">		&#125;</span><br><span class="line">		right[0] &#x3D; 1;</span><br><span class="line">		left[0] &#x3D; n;</span><br><span class="line">		int op, x, y, inv &#x3D; 0;</span><br><span class="line"></span><br><span class="line">		while (m--) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			scanf(&quot;%d&quot;, &amp;op);</span><br><span class="line">			if (op &#x3D;&#x3D; 4) inv &#x3D; !inv;</span><br><span class="line">			else &#123;</span><br><span class="line">				scanf(&quot;%d%d&quot;, &amp;x, &amp;y);</span><br><span class="line">				if (op &#x3D;&#x3D; 3 &amp;&amp; right[y] &#x3D;&#x3D; x) std::swap(x, y);</span><br><span class="line">				if (op !&#x3D; 3 &amp;&amp; inv) op &#x3D; 3 - op;</span><br><span class="line">				if (op &#x3D;&#x3D; 1 &amp;&amp; x &#x3D;&#x3D; left[y]) continue;</span><br><span class="line">				if (op &#x3D;&#x3D; 2 &amp;&amp; x &#x3D;&#x3D; right[y]) continue;</span><br><span class="line"></span><br><span class="line">				int lx &#x3D; left[x], rx &#x3D; right[x], ly &#x3D; left[y], ry &#x3D; right[y];</span><br><span class="line">				if (op &#x3D;&#x3D; 1) &#123;</span><br><span class="line">					link(lx, rx); link(ly, x); link(x, y);</span><br><span class="line">				&#125;</span><br><span class="line">				else if (op &#x3D;&#x3D; 2) &#123;</span><br><span class="line">					link(lx, rx); link(y, x); link(x, ry);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				&#x2F;*else if (op &#x3D;&#x3D; 3) &#123;</span><br><span class="line">					if (right[y] &#x3D;&#x3D; x) &#123;</span><br><span class="line">						link(y, rx); link(ly, x); link(x, y);</span><br><span class="line">					&#125;</span><br><span class="line">					else if (left[y] &#x3D;&#x3D; x) &#123;</span><br><span class="line">						link(lx, y); link(y, x); link(x, ry);</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123;</span><br><span class="line">						link(ly, x); link(x, ry);</span><br><span class="line">						link(lx, y); link(y, rx);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;*&#x2F;</span><br><span class="line">&lt;注释部分与下面这段等价</span><br><span class="line">				else if (op &#x3D;&#x3D; 3) &#123;</span><br><span class="line">					if (right[x] &#x3D;&#x3D; y) &#123;</span><br><span class="line">						link(lx, y); link(y, x); link(x, ry);</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123; link(lx, y); link(y, rx); link(ly, x); link(x, ry); &#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int b &#x3D; 0;</span><br><span class="line">		</span><br><span class="line">		long long ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			b &#x3D; right[b];</span><br><span class="line">			&#x2F;&#x2F;std::cout &lt;&lt; i&lt;&lt;&quot;: &quot;&lt;&lt;right[b] &lt;&lt; std::endl;</span><br><span class="line">			if (i % 2 &#x3D;&#x3D; 1) ans +&#x3D; b;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;*using namespace std;</span><br><span class="line">		cout &lt;&lt; endl;*&#x2F;</span><br><span class="line">		if (inv &amp;&amp; n % 2 &#x3D;&#x3D; 0) ans &#x3D; (long long)n*(n + 1) &#x2F; 2 - ans;</span><br><span class="line"></span><br><span class="line">&gt;由于处理的时候，对于反转，只对1.2操作处理了。所以在输出的时候还要考虑：如果总数为偶数，并且反转了奇数次，那么奇数位的盒子编号才会改变</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">		printf(&quot;Case %d: %lld\n&quot;, ++kase, ans);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li>学习代码中处理相邻的简化方法</li>
<li>学习双向链表的辅助函数</li>
<li>如果某一操作非常费时，那么不必每一步都真的执行他</li>
<li>编号不是位置了</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-邮件传输代理的交互" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E4%BB%A3%E7%90%86%E7%9A%84%E4%BA%A4%E4%BA%92/"
    >邮件传输代理的交互</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E4%BB%A3%E7%90%86%E7%9A%84%E4%BA%A4%E4%BA%92/" class="article-date">
  <time datetime="2020-03-30T02:15:00.732Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-814-邮件传输代理的交互"><a href="#uva-814-邮件传输代理的交互" class="headerlink" title="uva 814 邮件传输代理的交互"></a>uva 814 邮件传输代理的交互</h1><p>&ensp;本题的任务为模拟发送邮件时MTA（邮件传输代理）之间的交互。所谓MTA，就是email地址格式user@mtaname的“后面部分”。当某人从user1@mta1发送给另一个人user2@mta2时，这两个MTA将会通信。如果两个收件人属于同一个MTA，发送者的MTA只需与这个 MTA通信一次就可以把邮件发送给这两个人。</p>
<p>&ensp;输入每个MTA里的用户列表，对于每个发送请求（输入发送者和接收者列表），按顺序 输出所有MTA之间的SMTP（简单邮件协议）交互。协议细节参见原题。</p>
<p>&ensp;发送人MTA连接收件人MTA的顺序应该与在输入中第一次出现的顺序一致。例如，若 发件人是Hamdy@Cairo，收件人列表为Conrado@MexicoCity、Shariff@SanFrancisco、 Lisa@MexicoCity，则Cairo应当依次连接MexicoCity和SanFrancisco。 如果连接某个MTA之后发现所有收件人都不存在，则不应该发送DATA。所有用户名均由不超过15个字母和数字组成。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>首先考虑输入过程，可以选择用map&lt;string,vector<string>&gt;来存用户列表；也可以选择用set<string>来存，值就是邮件地址。</li>
<li>对于每个请求，首先读入发件人，分离出MTA和用户名，然后读取收件人，根据MTA出现的先后顺序进行保存，并且去掉重复。</li>
<li>接下来读入邮件正文，最后按顺序依次连接每个MTA，检查并输出每个收件人是否存在，如果至少有一个存在，则输出邮件正文。<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   #include&lt;iostream&gt;</span><br><span class="line">   #include&lt;string&gt;</span><br><span class="line">   #include&lt;map&gt;</span><br><span class="line">   #include&lt;set&gt;</span><br><span class="line">   #include&lt;vector&gt;</span><br><span class="line">   using namespace std;</span><br><span class="line"></span><br><span class="line">   void pare_address(const string s, string &amp;user, string &amp;mta) &#123;</span><br><span class="line">   	int k &#x3D; s.find(&#39;@&#39;);</span><br><span class="line">   	user &#x3D; s.substr(0, k);</span><br><span class="line">   	mta &#x3D; s.substr(k + 1);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">string s;</span><br><span class="line">set&lt;string&gt; addr;&#x2F;&#x2F;存每个mta对应用户的列表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string user1, mta1;</span><br><span class="line">while (cin &gt;&gt; s &amp;&amp; s !&#x3D; &quot;*&quot;) &#123;</span><br><span class="line">	int k;</span><br><span class="line">	string loc;</span><br><span class="line">	cin &gt;&gt; s &gt;&gt; k;</span><br><span class="line">	while (k--) &#123;</span><br><span class="line">		cin &gt;&gt; loc;</span><br><span class="line">		addr.insert(loc + &quot;@&quot; + s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;输入完成</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;处理发送地址和接收地址</span><br><span class="line">string sender;</span><br><span class="line">while (cin &gt;&gt; sender &amp;&amp; sender !&#x3D; &quot;*&quot;) &#123;</span><br><span class="line"></span><br><span class="line">	pare_address(sender, user1, mta1);</span><br><span class="line">	vector&lt;string&gt; mta;&#x2F;&#x2F;按序存需要连接的mta</span><br><span class="line">	map&lt;string, vector&lt;string&gt;&gt; dest;&#x2F;&#x2F;存每个mta要发送的用户</span><br><span class="line">	set&lt;string&gt; vis;&#x2F;&#x2F;用来去除重复收件人</span><br><span class="line"></span><br><span class="line">	while (cin &gt;&gt; s &amp;&amp; s !&#x3D; &quot;*&quot;) &#123;</span><br><span class="line">		string user2, mta2;</span><br><span class="line">		pare_address(s, user2, mta2);</span><br><span class="line"></span><br><span class="line">		if (vis.count(s)) continue;&#x2F;&#x2F;重复收件人</span><br><span class="line">		vis.insert(s);</span><br><span class="line">		if (!dest.count(mta2)) &#123;&#x2F;&#x2F;如果不是重复的要连接的mta</span><br><span class="line">			mta.push_back(mta2);</span><br><span class="line">			dest[mta2] &#x3D; vector&lt;string&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">		dest[mta2].push_back(s);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	getline(cin, s);&#x2F;&#x2F;把“*”这一行的回车吃掉</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;输入正文</span><br><span class="line">	string data;</span><br><span class="line">	while (getline(cin, s) &amp;&amp; s[0] !&#x3D; &#39;*&#39;)	data +&#x3D; &quot;     &quot; + s + &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; mta.size(); i++) &#123;</span><br><span class="line">		string mta2 &#x3D; mta[i];&#x2F;&#x2F;mta2遍历要连接的mta</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; &quot;Connection between &quot; &lt;&lt; mta1 &lt;&lt; &quot; and &quot; 	&lt;&lt; mta2 &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;     HELO &quot; &lt;&lt; mta1 &lt;&lt; endl &lt;&lt; &quot;     250\n&quot;;</span><br><span class="line">		cout &lt;&lt; &quot;     MAIL FROM:&lt;&quot; &lt;&lt; sender &lt;&lt; &quot;&gt;&quot; &lt;&lt; endl &lt;&lt; &quot;     250&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		vector&lt;string&gt; users &#x3D; dest[mta2];</span><br><span class="line">		</span><br><span class="line">		bool ok &#x3D; false;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; users.size(); j++) &#123;</span><br><span class="line">		&#x2F;&#x2F;遍历当前连接的mta2下要发送的用户列表</span><br><span class="line">			cout &lt;&lt; &quot;     RCPT TO:&lt;&quot; &lt;&lt; users[j] &lt;&lt; &quot;&gt;&quot; &lt;&lt; endl;</span><br><span class="line">			if (addr.count(users[j])) &#123;</span><br><span class="line">				ok &#x3D; true;</span><br><span class="line">				cout &lt;&lt; &quot;     250&quot; &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				cout &lt;&lt; &quot;     550&quot; &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (ok) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;     DATA&quot; &lt;&lt; endl &lt;&lt; &quot;     354&quot; &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; data &lt;&lt; &quot;     .&quot; &lt;&lt; endl &lt;&lt; &quot;     250&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; &quot;     QUIT&quot; &lt;&lt; endl &lt;&lt; &quot;     221&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li>学习拆分用户和地址时的引用传递</li>
<li>存一对多关系的时候可以用map+vector</li>
<li>去重时可以考虑多加一个容器，不要仅仅因为不能重复，就断定用set存一些数据</li>
<li>向量能保持原序，set能避免重复，map能得到对应关系</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-颜色的长度" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E9%A2%9C%E8%89%B2%E7%9A%84%E9%95%BF%E5%BA%A6/"
    >颜色的长度</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E9%A2%9C%E8%89%B2%E7%9A%84%E9%95%BF%E5%BA%A6/" class="article-date">
  <time datetime="2020-03-30T02:15:00.732Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="UVA-1625-颜色的长度"><a href="#UVA-1625-颜色的长度" class="headerlink" title="UVA 1625 颜色的长度"></a>UVA 1625 颜色的长度</h1><p>输入两个长度分别是n和m(n,m&lt;=5000)的颜色序列，要求按顺序合并成同一个序列，即每次可以把一个序列开头的颜色放到新序列的尾部。</p>
<p>例如，两个颜色序列GBBY和YRRGB，至少有两种合并结果：GBYBRYRGB和YRRGGBBYB。对于每种颜色来说其跨度L(c)等于最大位置和最小位置之差。例如，对于上面两种合并结果，每种颜色的L(c)和所有L(c)的总和如图</p>
<p><img src="/UVA_img/9.png" alt=""></p>
<p>你的任务是找一种合并方式，使得所有L(c)的总和最小</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>收到lcs的启发，考虑使用d[i][j]来表示第一个序列使用了前i个字符，第j个序列使用了前j个字符时的最小花费。问题在于，如果每次更新的时候屈计算l(c)会导致时间复杂度过高。</li>
<li>关于L(c)的计算：需要知道的刚刚移入最终序列的字符是否已经全部用完，并且要知道他最早在最终序列中出现的位置。如果记录每个颜色第一次出现的位置，状态会变得很复杂。所以尝试转换思路，不是等一个颜色全部移完再计算。而是每次累加。即，当把一个颜色移动到最终序列前，需要把所有已经出现但是还没结束的颜色的L(c)+1。也就是说，并不关心每种颜色的L(c)，只需要知道有多少种颜色已经开始但尚未结束</li>
<li>欲实现上述操作，则需要记录每种元素(26个大写字母)第一次和最后一次出现的位置</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000;</span><br><span class="line">#define inf 1000000</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line">int much[maxn][maxn];&#x2F;&#x2F;记录[i][j]状态下总的L(c)</span><br><span class="line">char ts[2][maxn];	&#x2F;&#x2F;输入字符串</span><br><span class="line">int s[2][maxn];		&#x2F;&#x2F;输入字符串-&#39;A&#39;</span><br><span class="line">int first[2][26];	&#x2F;&#x2F;每个颜色第一次出现的位置</span><br><span class="line">int last[2][26];	&#x2F;&#x2F;每个颜色最后一次出现的位置</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d\n&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%s\n%s\n&quot;, ts[0] + 1, ts[1] + 1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		int len1 &#x3D; strlen(ts[0] + 1);</span><br><span class="line">		int len2 &#x3D; strlen(ts[1] + 1);</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; len1; i++) s[0][i] &#x3D; ts[0][i] - &#39;A&#39;;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; len2; i++) s[1][i] &#x3D; ts[1][i] - &#39;A&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; 2; i++)</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 26; j++) &#123;</span><br><span class="line">				first[i][j] &#x3D; inf;</span><br><span class="line">				last[i][j] &#x3D; -1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; 2; i++) &#123;</span><br><span class="line">			int len &#x3D; strlen(ts[i] + 1);</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 26; j++) &#123;</span><br><span class="line"></span><br><span class="line">				for (int k &#x3D; 1; k &lt;&#x3D; len; k++)</span><br><span class="line">					if (s[i][k] &#x3D;&#x3D; j) &#123;</span><br><span class="line">						first[i][j] &#x3D; k;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				for (int k &#x3D; len; k &gt;&#x3D; 1; k--)</span><br><span class="line">					if (s[i][k] &#x3D;&#x3D; j) &#123;</span><br><span class="line">						last[i][j] &#x3D; k;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dp过程"><a href="#dp过程" class="headerlink" title="dp过程"></a>dp过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">much[0][0] &#x3D; 0;</span><br><span class="line">		dp[0][0] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt;&#x3D; len1; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt;&#x3D; len2; j++) &#123;</span><br><span class="line">				if (!i &amp;&amp; !j) continue;</span><br><span class="line">				dp[i][j] &#x3D; inf;</span><br><span class="line">				if (i) &#123;&#x2F;&#x2F;d[i][j]可能是由d[i-1][j]从第一个串中取一个元素而来</span><br><span class="line">					dp[i][j] &#x3D; min(dp[i][j], dp[i - 1][j] + much[i - 1][j]);</span><br><span class="line"></span><br><span class="line">					&#x2F;&#x2F;判断s1[i]是否是已经出现但尚未用完的元素</span><br><span class="line">					much[i][j] &#x3D; much[i - 1][j];</span><br><span class="line">					int c &#x3D; s[0][i];</span><br><span class="line">					if (i &#x3D;&#x3D; first[0][c] &amp;&amp; j &lt; first[1][c])&#x2F;&#x2F;是第一次出现，则+1</span><br><span class="line">						much[i][j]++;</span><br><span class="line">					if (i &#x3D;&#x3D; last[0][c] &amp;&amp; j &gt;&#x3D; last[1][c])&#x2F;&#x2F;是最后一次出现，则-1</span><br><span class="line">						much[i][j]--;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">				if (j) &#123;&#x2F;&#x2F;与上述对称</span><br><span class="line">					dp[i][j] &#x3D; min(dp[i][j], dp[i][j - 1] + much[i][j - 1]);</span><br><span class="line">					much[i][j] &#x3D; much[i][j - 1];</span><br><span class="line">					int c &#x3D; s[1][j];</span><br><span class="line"></span><br><span class="line">					if (i &lt; first[0][c] &amp;&amp; j &#x3D;&#x3D; first[1][c])</span><br><span class="line">						much[i][j]++;</span><br><span class="line">					if (i &gt;&#x3D; last[0][c] &amp;&amp; j &#x3D;&#x3D; last[1][c])</span><br><span class="line">						much[i][j]--;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;%d\n&quot;, dp[len1][len2]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-修改天平" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E4%BF%AE%E6%94%B9%E5%A4%A9%E5%B9%B3/"
    >修改天平</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E4%BF%AE%E6%94%B9%E5%A4%A9%E5%B9%B3/" class="article-date">
  <time datetime="2020-03-30T02:15:00.717Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva12166-修改天平-括号表示法给出树"><a href="#uva12166-修改天平-括号表示法给出树" class="headerlink" title="uva12166 修改天平    (括号表示法给出树)"></a>uva12166 修改天平    (括号表示法给出树)</h1><p>给出一个深度不超过16的二叉树，代表一个天平。每根杆都悬挂在中间，每个秤砣的重量已知。至少修改多少个秤砣的重量才能让天平平衡？</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>思考如何使得修改的天平最少：保证让总重量最多的秤砣不变。</li>
<li>用sum记录总的秤砣个数，用base记录每个对应重量的秤砣数。注意秤砣重量与所在高度有关，重w的秤砣在depth深处的总重量为w&lt;&lt;depth</li>
<li>括号表示法给出树的结构可以参考本题</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>```<br>    #include&lt;bits/stdc++.h&gt;<br>    # pragma warning(disable:4996)<br>    # define LOCAL<br>    # ifdef LOCAL<br>    FILE *fin = freopen(“习题6-6in.txt”, “r”, stdin);<br>    FILE *fout = freopen(“习题6-6out.txt”, “w”, stdout);<br>    # endif<br>    using namespace std;<br>    int T;<br>    string s;<br>    int sum;<br>    map&lt;long long, int&gt; base;<br>    void dfs(int depth, int p, int e) {<br>        if (s[p] == ‘[‘) {<br>        int not_ok = 0;<br>        for (int i = p + 1; i != e; i++) {<br>            if (s[i] == ‘[‘) not_ok++;<br>            if (s[i] == ‘]’) not_ok–;<br>            //注意此处脱括号的方法非常灵性<br>            if (!not_ok&amp;&amp;s[i] == ‘,’) {<br>                dfs(depth + 1, p + 1, i - 1);<br>                dfs(depth + 1, i + 1, e - 1);<br>            }<br>        }<br>    }<br>    else {<br>        long long w = 0;<br>        for (int i = p; i &lt;= e; i++)<br>            w = w * 10 + s[i] - ‘0’;<br>        ++sum;<br>        ++base[w &lt;&lt; depth];//sum统计砝码总数量，base[w&lt;&lt;depth]统计该总重量对应的砝码个数</p>
<pre><code>}
}
int main() {
cin &gt;&gt; T;
while (T--)
{
    cin &gt;&gt; s;
    sum = 0;
    base.clear();
    dfs(0, 0, s.length() - 1);
    int maxn = 0;
    for (auto it = base.begin(); it != base.end(); it++)
        maxn = max(maxn, it-&gt;second);
    cout &lt;&lt; sum - maxn &lt;&lt; endl;
}
}</code></pre>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-唯一的雪花" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%94%AF%E4%B8%80%E7%9A%84%E9%9B%AA%E8%8A%B1/"
    >唯一的雪花</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%94%AF%E4%B8%80%E7%9A%84%E9%9B%AA%E8%8A%B1/" class="article-date">
  <time datetime="2020-03-30T02:15:00.717Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="UVA-11572-唯一的雪花"><a href="#UVA-11572-唯一的雪花" class="headerlink" title="UVA 11572 唯一的雪花"></a>UVA 11572 唯一的雪花</h1><p>求最长连续无重复子序列。输入：第一行给出样例数，对于每组数据，第一行给出序列长度n，之后n行给出每个元素的值。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>滑动窗口：优先向右扩展，如果A[R+1]已存在，那么增大L。这是因为L-R是解的情况下，增大L也必然是解，所以R不必动。</li>
<li>判断是否出现过，可以使用set(240ms),map(270ms),数组(1140ms)<ol>
<li>set的查询，插入，删除的复杂度都是O(nlogn)</li>
<li>map[i]来记录元素i上次出现的下标，并更新到数组last。后面，如果上一次出现的下标不在目前的搜索范围内，那么可以扩展。</li>
<li>数组法可能是因为数组太大，所以速度太慢。</li>
</ol>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000000 + 5;</span><br><span class="line">int A[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int T, n;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">  while(T--) &#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;A[i]);</span><br><span class="line"></span><br><span class="line">    set&lt;int&gt; s;</span><br><span class="line">    int L &#x3D; 0, R &#x3D; 0, ans &#x3D; 0;</span><br><span class="line">    while(R &lt; n) &#123;</span><br><span class="line">      while(R &lt; n &amp;&amp; !s.count(A[R])) s.insert(A[R++]);</span><br><span class="line">      ans &#x3D; max(ans, R - L);</span><br><span class="line">      s.erase(A[L++]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000000 + 5;</span><br><span class="line">int A[maxn], last[maxn];</span><br><span class="line">map&lt;int, int&gt; cur;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int T, n;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">  while(T--) &#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    cur.clear();</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">      scanf(&quot;%d&quot;, &amp;A[i]);</span><br><span class="line">      if(!cur.count(A[i])) last[i] &#x3D; -1;</span><br><span class="line">      else last[i] &#x3D; cur[A[i]];</span><br><span class="line">      cur[A[i]] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int L &#x3D; 0, R &#x3D; 0, ans &#x3D; 0;</span><br><span class="line">    while(R &lt; n) &#123;</span><br><span class="line">      while(R &lt; n &amp;&amp; last[R] &lt; L) R++;</span><br><span class="line">      ans &#x3D; max(ans, R - L);</span><br><span class="line">      L++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1e9 + 5;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int in[1000005];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		int n;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;in[i]);</span><br><span class="line">		int L &#x3D; 0, R &#x3D; 0, ans &#x3D; 0;</span><br><span class="line">		while (L &lt;&#x3D; R &amp;&amp; R &lt; n)</span><br><span class="line">		&#123;</span><br><span class="line">			if (!vis[in[R]]) &#123; vis[in[R]] &#x3D; 1; R++; &#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				ans &#x3D; max(ans, R - L);</span><br><span class="line">				vis[in[L]] &#x3D; 0; L++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, max(ans, R - L));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-小球下落" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%B0%8F%E7%90%83%E4%B8%8B%E8%90%BD/"
    >小球下落</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%B0%8F%E7%90%83%E4%B8%8B%E8%90%BD/" class="article-date">
  <time datetime="2020-03-30T02:15:00.717Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-679-小球下落"><a href="#uva-679-小球下落" class="headerlink" title="uva 679 小球下落"></a>uva 679 小球下落</h1><p>&ensp;许多的小球一个一个的从一棵满二叉树上掉下来组成一个新满二叉树，每一时间，一个正在下降的球第一个访问的是非叶子节点。然后继续下降时，或者走右子树，或者走左子树，直到访问到叶子节点。<br>决定球运动方向的是每个节点的布尔值。最初，所有的节点都是 FALSE，当访问到一个节点时，如果这个节点是 FALSE，则这个球把它变成 TRUE，然后从左子树走，继续它的旅程。如果节点是TRUE，则球也会改变它为 FALSE，而接下来从右子树走。满二叉树的标记方法如下图。<br>因为所有的节点最初为 FALSE，所以第一个球将会访问节点 1，节点 2 和节点 4，转变节点的布尔值后在在节点 8 停止。第二个球将会访问节点 1、3、6，在节点 12 停止。；明显地，第三个球在它停止之前，会访问节点 1、2、5，在节点 10 停止。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>对于二叉树，有结论编号为i的节点的左子树编号为2i,右子树为2i+1</li>
<li>如果用一个数组存二叉树，并进行遍历，会TEL，并且数组占很大空间</li>
<li>发现只要知道是第几个通过该节点的小球，那么就可以知道这一步他落到左子树还是右子树</li>
<li>如果I为奇数，那么他是第（I+1）/2个向左走的小球，如果I为偶数，那么他是第I/2个向右走的小球。<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   #include&lt;iostream&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;小球下落in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;小球下落out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   int main() &#123;</span><br><span class="line">int T;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">while (T--) &#123;</span><br><span class="line">	int num, depth;</span><br><span class="line">	cin &gt;&gt; depth &gt;&gt; num;</span><br><span class="line">	int No &#x3D; 1;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; depth-1; i++) &#123;</span><br><span class="line">		if (num % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">			No &#x3D; 2 * No;</span><br><span class="line">			num &#x3D; (num + 1) &#x2F; 2;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			No &#x3D; 2 * No + 1;</span><br><span class="line">			num &#x3D; num &#x2F; 2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; No &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1></li>
<li>关注该关注的，并找规律很重要</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-巡逻机器人" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%B7%A1%E9%80%BB%E6%9C%BA%E5%99%A8%E4%BA%BA/"
    >巡逻机器人</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%B7%A1%E9%80%BB%E6%9C%BA%E5%99%A8%E4%BA%BA/" class="article-date">
  <time datetime="2020-03-30T02:15:00.717Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva1600-巡逻机器人"><a href="#uva1600-巡逻机器人" class="headerlink" title="uva1600 巡逻机器人"></a>uva1600 巡逻机器人</h1><p>本题有t组数据，每组数据包含一个m*n的01矩阵，0表示能走，1表示有一个障碍物。机器人能往上下左右四个方向走动.它要从(1,1)到(m,n),可以连续翻越k个障碍物,求它从(1,1)到(m,n)的最短路径.如果不能到达输出”-1”.</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>本题基础是一个bfs，附加可以跳跃0的条件。</p>
</li>
<li><p>对无权图进行bfs的时候，走到每一个点时的步数都是一定的，所以对于每个点，应该让能够跨越障碍的机会越多越好，所以Node节点中应该包含(r,c,k,step)其中k为到达(r,c)位置时剩余的跨越障碍的机会，step为最小步数。(※如果只需要知道步数而不需要路径，则将其包在结构体里即可)</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p> #include&lt;bits/stdc++.h&gt;</p>
<h1 id="pragma-warning-disable-4996"><a href="#pragma-warning-disable-4996" class="headerlink" title="pragma warning(disable:4996)"></a>pragma warning(disable:4996)</h1><h1 id="define-LOCAL"><a href="#define-LOCAL" class="headerlink" title="define LOCAL"></a>define LOCAL</h1><h1 id="ifdef-LOCAL"><a href="#ifdef-LOCAL" class="headerlink" title="ifdef LOCAL"></a>ifdef LOCAL</h1><p> FILE *fin = freopen(“习题6-5in.txt”, “r”, stdin);<br> FILE *fout = freopen(“习题6-5out.txt”, “w”, stdout);</p>
<h1 id="endif"><a href="#endif" class="headerlink" title="endif"></a>endif</h1><p> using namespace std;<br> int n, x, y, k;<br> int g[20][20];<br> struct node {</p>
<pre><code>int r, c, k, step;

node(int r, int c, int k, int step = 0) :r(r), c(c), k(k), step(step) {}</code></pre><p> };<br> int step[20][20];<br> int dr[] = { 1, 0, -1, 0 };<br> int dc[] = { 0, 1, 0, -1 };<br> int min_step;<br> void bfs() {</p>
<pre><code>queue&lt;node&gt;q;
q.push(node(0, 0, k));
int block = 0;
while (!q.empty()) {
    node u = q.front(); q.pop();

    if (u.r == x - 1 &amp;&amp; u.c == y - 1) {
        min_step = u.step;
        break;
    }
    for (int i = 0; i &lt; 4; i++) {
        int r = u.r + dr[i], c = u.c + dc[i];
        if (r &gt;= 0 &amp;&amp; r &lt; x&amp;&amp;c &gt;= 0 &amp;&amp; c &lt; y) {
            if (step[r][c] &lt; u.k) {//u.k是走到step[r][c]处，还剩余的跳过障碍的机会，所以要保留大的
                step[r][c] = u.k;
            }
            else continue;//如果step[r][c]更大，说明目前正在走的路不是最好的(因为bfs走到每个节点的步数是一定的
                          //所以剩余的跨越障碍的次数越多越好),不需要再走下去，所以不入队)
            if (g[r][c] == 0) q.push(node(r, c, k, u.step + 1));
            else if(u.k) q.push(node(r, c, u.k - 1, u.step + 1));
        }
    }
}</code></pre><p> }<br> int main() {<br> cin &gt;&gt; n;<br> while (n–) {</p>
<pre><code>memset(g, 0, sizeof(g));
memset(step, -1, sizeof(step));
cin &gt;&gt; x &gt;&gt; y;
cin &gt;&gt; k;
for (int i = 0; i &lt; x; i++)
    for (int j = 0; j &lt; y; j++)
        cin &gt;&gt; g[i][j];
min_step = 999;
bfs();
min_step == 999 ? cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl:cout &lt;&lt; min_step &lt;&lt; endl;</code></pre><p> }<br> }</p>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/10/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/12/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        John Doe
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>