<!DOCTYPE html>


<html lang="cn" >


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

  <script type="text/javascript"
	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/Bg.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/"></a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-计安导第2章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC2%E7%AB%A0/"
    >计安导第2章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC2%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.494Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="物理保护与攻击"><a class="markdownIt-Anchor" href="#物理保护与攻击"></a> 物理保护与攻击</h1>
<h2 id="物理安全"><a class="markdownIt-Anchor" href="#物理安全"></a> 物理安全</h2>
<ol>
<li>物理安全：泛指保护贵重物品、信息或访问受限资源 所使用的物理措施，物理安全直接影响完整性、计算 机硬件和数字信息保护。包括
<ol>
<li>位置保护</li>
<li>物理入侵检测</li>
<li>硬件攻击</li>
<li>窃听</li>
<li>物理接口攻击</li>
</ol>
</li>
</ol>
<h2 id="钥匙与锁"><a class="markdownIt-Anchor" href="#钥匙与锁"></a> 钥匙与锁</h2>
<ol>
<li>包括TSA锁，凸块锁，万能钥匙，弹子锁</li>
<li>非破坏性开锁：选取，旁路</li>
<li>40种不同的钥匙坯，7个顶部锁鞘，8个不同高度的底部锁鞘，则可能的钥匙数量是40*8<sup>7</sup></li>
</ol>
<h2 id="特权升级"><a class="markdownIt-Anchor" href="#特权升级"></a> 特权升级</h2>
<p>攻击者将地权限的密钥提升为高权限的密钥</p>
<h2 id="指纹锁相关问题"><a class="markdownIt-Anchor" href="#指纹锁相关问题"></a> 指纹锁相关问题</h2>
<ol>
<li>识别率不够高</li>
<li>电池寿命问题</li>
<li>指纹锁的稳定性不高</li>
</ol>
<h2 id="测信道攻击"><a class="markdownIt-Anchor" href="#测信道攻击"></a> 测信道攻击</h2>
<p>攻击者不是试图直接绕过 安全措施，而是通过利用 其他不受安全机制保护的 漏洞绕过安全措施</p>
<h1 id="身份认证技术"><a class="markdownIt-Anchor" href="#身份认证技术"></a> 身份认证技术</h1>
<ol>
<li>包括条形码，二维码，磁条卡，智能卡，SIM卡,RFID</li>
</ol>
<h2 id="磁条卡安全"><a class="markdownIt-Anchor" href="#磁条卡安全"></a> 磁条卡安全</h2>
<ol>
<li>问题：易于读取和复制。词条阅读器成本相对较低</li>
<li>解决：要求输入PIN</li>
</ol>
<h2 id="智能卡安全"><a class="markdownIt-Anchor" href="#智能卡安全"></a> 智能卡安全</h2>
<ol>
<li>可以提供保护所有者信息的安全认证机制，并且极难复制</li>
<li>使用加密技术加强认证的手段</li>
</ol>
<h2 id="sim卡安全"><a class="markdownIt-Anchor" href="#sim卡安全"></a> SIM卡安全</h2>
<ol>
<li>SIM卡：用于识别所有者并对相应的蜂窝网络进行身份验证</li>
<li>18位，用于硬件识别</li>
<li>128位密钥</li>
</ol>
<h2 id="gsm挑战-相应协议"><a class="markdownIt-Anchor" href="#gsm挑战-相应协议"></a> GSM挑战-相应协议</h2>
<p><img src="/%E8%AE%A1%E5%AE%89%E5%AF%BC_img/36.png" alt="" /></p>
<ol>
<li>当手机希望加入蜂窝网络时，它连接并发送其IMSI到网络提供商拥有的 本地基站。</li>
<li>如果IMSI匹配网络提供商的数据库中的用户记录正确，则基站将128位 随机数发送到蜂窝电话。</li>
<li>然后，该随机数由蜂窝电话编码存储在SIM卡中，用户的密钥使用A3的 专有加密算法，从而产生发送回基站的密文</li>
<li>然后，基站使用其存储的用于用户密钥的值来执行相同的计算。 如果两 个密文匹配，则手机被认证到网络并被允许拨打和接听电话。</li>
</ol>
<h2 id="rfid"><a class="markdownIt-Anchor" href="#rfid"></a> RFID</h2>
<ol>
<li>必须与单独的读取器或写入器一起使用</li>
<li>所有RFID都使用密钥加密</li>
</ol>
<h2 id="生物识别技术"><a class="markdownIt-Anchor" href="#生物识别技术"></a> 生物识别技术</h2>
<ol>
<li>
<p>生物特征：指用于基于生物或生理特 征唯一识别信息进行的任何身份度 量。</p>
</li>
<li>
<p>生物识别的要求</p>
<ol>
<li>普遍性</li>
<li>独特性</li>
<li>持久性</li>
<li>可回收性：该特征应具有有效确定和量化的能力</li>
</ol>
</li>
<li>
<p>如指纹，虹膜，步态</p>
</li>
</ol>
<h1 id="针对计算设备的攻击"><a class="markdownIt-Anchor" href="#针对计算设备的攻击"></a> 针对计算设备的攻击</h1>
<h2 id="环境攻击"><a class="markdownIt-Anchor" href="#环境攻击"></a> 环境攻击</h2>
<ol>
<li>电力，温度，有限的传导</li>
</ol>
<h2 id="窃听"><a class="markdownIt-Anchor" href="#窃听"></a> 窃听</h2>
<p>搭线窃听同轴电缆的电脉冲</p>
<h2 id="信号发射"><a class="markdownIt-Anchor" href="#信号发射"></a> 信号发射</h2>
<p>通过计算机屏幕发出的射频信号来检测正在显示的内容</p>
<h2 id="键盘记录"><a class="markdownIt-Anchor" href="#键盘记录"></a> 键盘记录</h2>
<h2 id="防御"><a class="markdownIt-Anchor" href="#防御"></a> 防御</h2>
<ol>
<li>三级：1米；20米，100米</li>
<li>放射阻隔(阻隔光,音)</li>
<li>法拉第笼：阻挡电磁辐射</li>
</ol>
<h1 id="计算机取证"><a class="markdownIt-Anchor" href="#计算机取证"></a> 计算机取证</h1>
<p>计算机取证是一种获取包含在电子媒介上的信息的方 法，如计算机系统、硬盘和光盘，通常用于收集用于 法律诉讼的证据</p>
<h2 id="过程"><a class="markdownIt-Anchor" href="#过程"></a> 过程</h2>
<ol>
<li>鉴定</li>
<li>收集：注意不要修改数据</li>
<li>分析和评估</li>
<li>报告</li>
</ol>
<h2 id="取证约束"><a class="markdownIt-Anchor" href="#取证约束"></a> 取证约束</h2>
<ol>
<li>监管链</li>
<li>优先级RAM &gt; swap &gt; disk &gt; CDs/DVDs。第一时间捕获更易失的</li>
<li>犯罪现场的计算机应该被视为完全敌对的</li>
</ol>
<h2 id="隐藏数据的方法"><a class="markdownIt-Anchor" href="#隐藏数据的方法"></a> 隐藏数据的方法</h2>
<ol>
<li>密码学</li>
<li>隐写术</li>
<li>更改文件名或者扩展名</li>
<li>隐藏分区</li>
<li>删除文件</li>
</ol>
<h2 id="反取证技术"><a class="markdownIt-Anchor" href="#反取证技术"></a> 反取证技术</h2>
<ol>
<li>反取证技术试图阻止调查员及其取证技术</li>
<li>安全删除数据，以便无法使用取证方法进行恢复</li>
<li>首先防止创建某些数据</li>
<li>从未出现的数据显然无法通过取证方法恢复。</li>
</ol>
<h2 id="磁盘擦出"><a class="markdownIt-Anchor" href="#磁盘擦出"></a> 磁盘擦出</h2>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导第5章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC5%E7%AB%A0/"
    >计安导第5章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC5%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.494Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="网络基本概念"><a class="markdownIt-Anchor" href="#网络基本概念"></a> 网络基本概念</h1>
<h2 id="网络协议"><a class="markdownIt-Anchor" href="#网络协议"></a> 网络协议</h2>
<ol>
<li>OSI七层模型：应用层；表示层；会话层；传输层；网络层；链路层；物理层</li>
<li>TCP/IP五层模型：应用层；传输层；网络层；数据链路层；物理层</li>
</ol>
<h2 id="tcpip"><a class="markdownIt-Anchor" href="#tcpip"></a> TCP/IP</h2>
<ol>
<li>
<p>物理层</p>
<ol>
<li>其任务是以尽力服务为基础，在网络节点之间传输实际的比特位。</li>
<li>规定通信设备的机械的、电气的、功能的和过程的特性，用以建 立、维护和拆除物理链路连接。</li>
</ol>
</li>
<li>
<p>链路层</p>
<ol>
<li>其任务是在网络节点对间或局域网节点间传输数据并检测物理层出现的差错。</li>
<li>该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据 的检错、重发等。</li>
</ol>
</li>
<li>
<p>网络层</p>
<ol>
<li>其任务是以尽力服务为基础，在任意两台主机之间传送数据包。就是选择合适的网间路由和交换结点， 确保数据及 时传送。</li>
<li>网络层将数据链路层提供的帧组成数据包，包中封装有网络层包 头，其中含有逻辑地址信息：源站点和目的站点地址的网络地址。</li>
</ol>
</li>
<li>
<p>传输层</p>
<ol>
<li>其任务是基于IP地址和端口，支持应用程序之间的通信与连接。</li>
<li>传输层为上层提供端到端（最终用户到最终用户）的透明的、可 靠的数据传输服务。所谓透明的传输是指在通信过程中传输层对 上层屏蔽了通信传输系统的具体细节。</li>
</ol>
</li>
<li>
<p>应用层</p>
<ol>
<li>其任务是以传输层提供的服务为基础，提供协议来支持互联网上的有用的功能。</li>
<li>常用协议有FTP、TELNET、DNS、SMTP、POP3。</li>
</ol>
</li>
</ol>
<h2 id="网络与安全"><a class="markdownIt-Anchor" href="#网络与安全"></a> 网络与安全</h2>
<h3 id="与计算机安全目标-cia"><a class="markdownIt-Anchor" href="#与计算机安全目标-cia"></a> 与计算机安全目标 CIA</h3>
<ol>
<li>机密性：网络协议的任何分层中，都没有要求传输数据的机密性。 需要修订相关协议来完成机密性。可以在应用层进行加密协议的 设计，也可以在网络层。</li>
<li>完整性：封装的数据包中的头和尾部都有简单的校验和，以检查 传输数据是否有改变。但这些校验和不是密码学意义下安全的， 因此不能提供计算机安全层面的完整性。</li>
<li>可用性：网络协议设计之初主要考虑的是节点发生故障时如何保 证可用性，并未考虑攻击者存在时的情形。如拒绝服务攻击会影 响系统可用性。</li>
</ol>
<h3 id="与计算机安全目标-3a"><a class="markdownIt-Anchor" href="#与计算机安全目标-3a"></a> 与计算机安全目标 3A</h3>
<ol>
<li>保证：默认情况下网络中数据包可以在任何两个节点间阐述。如 果需要引入权限和策略来控制网络中的数据流，必须通过显式得 的措施来实现。</li>
<li>真实性：网络协议的数据格式中没有存储数字签名的字段，也没 有用户身份的概念。如果需要引入身份证明和数字签名，必须在 应用层完成。</li>
<li>匿名：网络协议没有用户身份的概念，因此具有内在的匿名性。 对于匿名攻击，可以通过确定用户正在使用网络中的哪台计算机 来确定。</li>
</ol>
<h1 id="链路层"><a class="markdownIt-Anchor" href="#链路层"></a> 链路层</h1>
<h2 id="以太网"><a class="markdownIt-Anchor" href="#以太网"></a> 以太网</h2>
<ol>
<li>定义：以太网包括通信所使用的物理介质以及链路层的协议 标准IEEE 802.3。</li>
<li>不同帧 在以太网电缆上同时传输时会产生冲突，需要丢弃并重传冲突帧。</li>
<li>冲突处理：以太网协议使用CSMA/CD（载波监听多路访问及冲突 检测）技术来避免冲突。</li>
</ol>
<h2 id="集线器"><a class="markdownIt-Anchor" href="#集线器"></a> 集线器：</h2>
<ol>
<li>工作与物理层，将所有帧广播给与之相连的所有设备。</li>
<li>缺点是与集线器相连的所有设备共享带宽，传输效率低下。由于 是广播，所以数据容易被窃听。</li>
</ol>
<h2 id="交换机"><a class="markdownIt-Anchor" href="#交换机"></a> 交换机</h2>
<ol>
<li>交换机会记录连接到自己各个接口的计算机地址。之后交换机会 将接收到的帧发送到特定的接收端，而不是广播出去。</li>
</ol>
<h2 id="mac地址"><a class="markdownIt-Anchor" href="#mac地址"></a> MAC地址</h2>
<ol>
<li>MAC（Medium/Media Access Control）地址，用来表示互联网 上每一个站点的标识符，采用十六进制数表示，共六个字节。</li>
<li>MAC地址是网卡决定的，一般是固定的。但可以通过网卡的驱动 程序软件来修改MAC地址。因此，<strong>从安全角度考虑，不能使用MAC地址作为识别网络流源头的依据。</strong></li>
</ol>
<h2 id="arp欺骗"><a class="markdownIt-Anchor" href="#arp欺骗"></a> ARP欺骗</h2>
<ol>
<li>ARP:是一种链路层协议，其主要功能是将给定主机的网络层地址解析为主机 的硬件地址。</li>
<li>过程：主机通过发送包含目标IP地址的AARP请求到网络上所有主机，并接受返回消息，以此确定目标的物理地址。同时将映射存入ARP缓存。</li>
<li><strong>ARP欺骗</strong>：攻击者可以向某 一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主 机或到达错误的主机，这就构成了一个<strong>ARP欺骗</strong>。
<ol>
<li>问题在于ARP缺乏身份认证</li>
<li><strong>解决</strong> ：
<ol>
<li>检查相同的MAC是否在局域网中多次出现，以作为ARP欺骗的标志。</li>
<li>静态ARP表：通过手动指定路由器的ARP缓存来将具体的MAC地址与特定的IP地址进行绑定。问题是不够灵活。</li>
<li>更加复杂和灵活的措施：anti-arpsroof、XArp、Arpwatch，这些 程序会仔细检查所有的ARP数据包，并将数据包的内容与所存储 的ARP表项纪录做比较，以检测并防止ARP欺骗。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="网络层"><a class="markdownIt-Anchor" href="#网络层"></a> 网络层</h1>
<h2 id="网际协议基本概念"><a class="markdownIt-Anchor" href="#网际协议基本概念"></a> 网际协议基本概念</h2>
<ol>
<li>IP：网络层协议，尽最大努力将一个数据包从源节点路由到目的 节点。节点由IP地址标识，IPv4地址为32位，IPv6地址为128位。</li>
<li>IP包路由：如果数据包的源和目的在同一个局域网内，则通过ARP进行。否则，将包传送至网关，由网关根据路由表来确定如何转发。</li>
<li>IP地址与子网掩码：例如IP地址为192.168.1.100,子网掩码为 255.255.255.0。则该地址的网络部分为192.168.1.0,主机部分为 0.0.0.100.</li>
<li>IPv4地址耗尽解决：IPv6；网络地址转换</li>
</ol>
<h2 id="路由"><a class="markdownIt-Anchor" href="#路由"></a> 路由</h2>
<ol start="3">
<li>路由器：为数据包寻找一条最佳的传输路径。路由器中维护一张路由表，以提高效率。</li>
<li>路由操作：包括发送、丢弃、转发</li>
<li><strong>TTL</strong>:数据包的<strong>生存周期</strong>，由跳数决定，一般最大条数为255。</li>
<li>路由协议
<ol>
<li>OSPF决定了如何在自治系统内路由数据包。</li>
<li>BGP决定了如何在自治系统之间路由数据包。</li>
</ol>
</li>
</ol>
<h2 id="icmp-网际控制消息协议"><a class="markdownIt-Anchor" href="#icmp-网际控制消息协议"></a> ICMP 网际控制消息协议</h2>
<ol>
<li>ICMP:用于在主机、路由器之间传递控制消息。
<ol>
<li>包括：回显请求；回显响应；超时；目的地不可达</li>
</ol>
</li>
<li>Ping 命令：Ping发送一个ICMP<strong>回声请求</strong> 消息给目的地并报告是否收到ICMP<strong>回声应答</strong>消息。</li>
<li>traceroute命令：利用ICMP 协议定位您的计算机和目标计算机之间的所有路由器。<strong>利用ICMP超时报文，依次等增TTL，以确定路径上有哪些路由</strong></li>
</ol>
<h2 id="ip地址欺骗"><a class="markdownIt-Anchor" href="#ip地址欺骗"></a> IP地址欺骗</h2>
<ol>
<li><strong>方法</strong> 恶意用户产生的IP数据包中的源IP地址是伪造的， 以便冒充其他系统或发件人的身份。源IP地址修改后， IP数据包 头部校验和也需重新计算。</li>
<li>攻击者不会收到服务器响应，因为服务器会将数据包返回给具有假冒IP地址的主机。因此，攻击者不在乎响应，故可以用来Dos攻击。</li>
<li><strong>应对</strong>
<ol>
<li>通过边缘路由器禁止那些源地址在域内，但实际地址在域外的数据包或源地址在域外，但是从域内向域外发的送的数据包。</li>
<li>可以通过IP追踪计数追踪数据包返回到实际源地址的路径。</li>
</ol>
</li>
</ol>
<h2 id="数据包嗅探"><a class="markdownIt-Anchor" href="#数据包嗅探"></a> 数据包嗅探</h2>
<ol>
<li>Wireshark：网络数据包分析软件。使用WinpCAP作为接口，直接与网卡进行数据报文交换。此时网卡需要设置为混杂模式。
<ol>
<li><strong>问题</strong> 可能泄露敏感信息。</li>
</ol>
</li>
<li><strong>解决</strong>
<ol>
<li>对于有线网，使用以太网交换机而不是集线器，降低数据包包嗅探的可能性。</li>
<li>检查网卡是否被设置为混杂模式。</li>
<li>利用高层协议进行加密，比如HTTPS</li>
</ol>
</li>
</ol>
<h1 id="传输层"><a class="markdownIt-Anchor" href="#传输层"></a> 传输层</h1>
<h2 id="基础概念"><a class="markdownIt-Anchor" href="#基础概念"></a> 基础概念</h2>
<ol>
<li>
<p>端口号：16位，用来标识应用层不同服务。</p>
<ol>
<li>FTP:21</li>
<li>Telnet:23</li>
<li>SSMTP:25</li>
<li>HTTP:80</li>
</ol>
</li>
<li>
<p><strong>TCP</strong>:面向连接的、可靠的。面向 连接意味着实现会比较复杂，可靠的是指信息会完整、有序地到 达。如果数据包丢失，TCP会保证重传。 TCP是传输文件、网页 和电子邮件的首选协议。</p>
</li>
<li>
<p><strong>UDP</strong>：无连接的、不可靠但速度快。基于IP的语音会话(VoIP)适合于使用UDP协议。</p>
</li>
</ol>
<h2 id="tcp-协议"><a class="markdownIt-Anchor" href="#tcp-协议"></a> TCP 协议</h2>
<ol>
<li>
<p>三次握手建立连接，每个数据包都有编号。</p>
</li>
<li>
<p>采用<strong>累计确认</strong></p>
</li>
<li>
<p>流量控制使用滑动窗口协议</p>
</li>
<li>
<p>校验和：使用循环冗余校验(CRC)，可以检测由网络错误引发的数据不一致，但不能检测恶意篡改。</p>
</li>
<li>
<p>拥塞控制：拥塞会导致传输速率急剧下降和数据包的丢弃。拥塞 控制是防止流量淹没网络的一种技术，通过收集确认数据包等信 息来调整数据的传输速率，防止拥塞。</p>
<ol>
<li>慢开始与拥塞避免</li>
<li>快重传与快恢复</li>
</ol>
</li>
<li>
<p>TCP三次握手</p>
 <img src="/计安导_img/1.png" style="zoom:80%">
<ol>
<li>初始序列号是随机的，以<strong>防止针对预测初始序列号的攻击</strong>。</li>
</ol>
</li>
</ol>
<h2 id="udp-协议"><a class="markdownIt-Anchor" href="#udp-协议"></a> UDP 协议</h2>
<ol>
<li>无需三次握手，允许直接发送数据包。</li>
<li>UPD提供无连接、不可靠的服务。将数据报序列中丢失数据报的工作交给应用层。</li>
<li>使用16位校验和验证数据包完整性。</li>
<li>速度远远快于TCP,用于DNS和VoIP。</li>
</ol>
<h2 id="nat-网络地址转换"><a class="markdownIt-Anchor" href="#nat-网络地址转换"></a> NAT 网络地址转换</h2>
<ol>
<li>NAT允许局域网内的主机共享一个公共IP，以接入因特网。
<ol>
<li>解决了IP地址不足的问题。</li>
<li>有效的避免了来自网络外部的攻击，隐藏并保护网络内部的计算机。</li>
<li>NAT路由器：公网和私网之间的网关，负责管理流入和流出的数据包。</li>
<li>NAT路由器通过维护一个查找表来实现私有IP和公有IP的地址转换。</li>
<li>使用NAT设备时，互联网的流入流量不能到达内部网络，能够阻 止来自外部网络的威胁。</li>
</ol>
</li>
</ol>
<h2 id="tcp会话劫持"><a class="markdownIt-Anchor" href="#tcp会话劫持"></a> TCP会话劫持</h2>
<ol>
<li>
<p><strong>TCP序列号预测攻击</strong> 通过预测TCP会话的初始序列号，以建立伪造的TCP会话。之后</p>
<ol>
<li>发动拒绝服务攻击</li>
<li>向服务器发送SYN，将源IP地址伪造成受害者客户端IP。</li>
<li>在等待服务器向客户端发送响应之后，攻击者通过发送一个 ACK数据包来结束TCP握手，该数据包的序列号是预测的下一个序列号；</li>
<li>攻击者以受害客户端名义向服务器发送请求。</li>
</ol>
</li>
<li>
<p><strong>盲注入</strong>：在TCP序列预测攻击中使用了IP欺骗，所以攻击者无法从服务器收到任何响应。盲注入允许攻击者使用请求者的源IP地址来执行某些命令，从而破坏系统。</p>
</li>
<li>
<p><strong>ACK风暴</strong>：盲注入后客户端不会向服务器发送同步消息，导致不同步。此时，客户端和服务端都会向对方发送ACK消息，来告知对方需要开始使用正确的序列号。这种反复的通信称为ACK风暴。</p>
</li>
<li>
<p><strong>完全会话劫持</strong>：当攻击者与目标服务器或客户端在同一网段时，攻击者可以通过数据包嗅探攻击，直到建立会话时的数据包序列号，从而完全劫持会话。</p>
</li>
<li>
<p><strong>防范会话劫持</strong>：</p>
<ol>
<li>在IP层或者应用层使用认证和加密，如IPSec或者应用层安全协议。</li>
<li>网站应避免创建以安全身份验证措施开始，但后来切换到未加密交 换的会话，这样会产生TCP会话劫持攻击的风险。</li>
</ol>
</li>
</ol>
<h1 id="dos攻击"><a class="markdownIt-Anchor" href="#dos攻击"></a> Dos攻击</h1>
<ol>
<li><strong>拒绝服务攻击</strong>亦称洪水攻击，其目的在于使目标电脑的网络或系统 资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</li>
<li><strong>分布式拒绝服务攻击</strong>：使用多台僵尸机发起攻击。</li>
<li>症状：网络异常缓慢(打开文件或访问网站)、特定网站无法访 问、无法访问任何网站、垃圾邮件的数量急剧增加、无线或有线网 络连接异常断开、长时间尝试访问网站或任何互联网服务时被拒绝、 服务器容易断线、卡顿等。</li>
</ol>
<h2 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h2>
<ol>
<li>
<p>带宽消耗：</p>
<ol>
<li>ICMP洪水攻击：通过向未良好设置的路由器发送广播信息以占用系统资源 。</li>
<li>UDP洪水攻击：大量UDP数据包发送给受害系统，可能会导致带宽。</li>
<li>死亡之ping：产生超过IP协议能容忍的数据包数，可能会导致死机。</li>
<li>泪滴攻击：数据在发送前都会经过切割，每个小切割都会记录位移的信息，以 便重组。此攻击模式就是捏造位移信息，导致重组时发生问题，造成错误。</li>
</ol>
</li>
<li>
<p>资源消耗型</p>
<ol>
<li>SYN 洪水攻击：大量TCP SYN请求反复发送，导致系统资源耗尽。</li>
<li>LAND攻击：与SYN floods类似，会导致被攻击的机器死循环。</li>
<li>分布式HTTP洪水攻击：使用代理服务器向受害服务器发送大量貌似合法的请 求，通常使用HTTP GET。</li>
<li>僵尸网络攻击：大量被命令与控制服务器所控制的互联网主机群协同攻击。</li>
</ol>
</li>
</ol>
<h2 id="icmp-攻击"><a class="markdownIt-Anchor" href="#icmp-攻击"></a> ICMP 攻击</h2>
<ol>
<li><strong>ping洪水攻击</strong>：通过功能强大的计算机向单个受害服务器发送大量 回显请求命令。这样受害服务器会被这些网络流量 淹没，无法响应合法的请求。</li>
<li><strong>Smurf攻击</strong>：攻击者向网络广播地址发送ICMP包，并将回复地址 设置成受害网络的广播地址，通过使用ICMP应答请求数据包来淹 没受害主机的方式进行。</li>
<li><strong>阻止Smurf攻击</strong>：
<ol>
<li>管理员应该将网络中的主机和路由器配置 为忽略广播请求；</li>
<li>避免直接向广播地址转发数据包；</li>
<li>忽略 ping请求。</li>
</ol>
</li>
</ol>
<h2 id="syn洪水攻击"><a class="markdownIt-Anchor" href="#syn洪水攻击"></a> SYN洪水攻击</h2>
<ol>
<li>
<p>攻击者故意延迟或不发送握手确认。</p>
</li>
<li>
<p><strong>过程</strong>：</p>
<ol>
<li>假设连接发起方是A，接受方是B。A发送SYN消息给B，B反馈 SYN-ACK消息给A，使连接进入半开状态。此时B会给每个半开连 接都设一个Timer，如果超过时间还没有收到A的ACK消息，则重 新发送一次SYN-ACK消息给A，直到重试超过一定次数时才会放弃。</li>
<li>攻击方A可以控制肉鸡向B发送大量SYN消息但不响应ACK消息， 或者干脆伪造SYN消息中的Source IP，使B反馈的SYN-ACK消息 石沉大海，导致B被大量注定不能完成的半开连接占据，直到资源 耗尽，停止响应正常的连接请求。</li>
</ol>
</li>
<li>
<p><strong>防范</strong></p>
<ol>
<li><strong>SYN Cookie机制</strong>：在TCP服务器接收到TCP SYN包并返回TCP SYN+ACK包时，不分配专门的数据区，而是根据SYN包计算一个 cookie值。 这个cookie作为将要返回的SYN-ACK包的初始序列号。</li>
</ol>
</li>
<li>
<p>SYN + ACK包的32比特结构如下：</p>
<ol>
<li>前5比特是时间戳，由每分 钟按模32递增的计数器实现</li>
<li>中间3比特是编码值，表示传输段 的最大值</li>
<li>最后24比特是基于密钥k，由服务器和客户端IP地址，端口号和前面使用的时间戳计算出来的MAC值。</li>
</ol>
</li>
<li>
<p>当客户端返回一个ACK包时</p>
<ol>
<li>服务器首先根据其前5比特判断是否 过期；</li>
<li>服务器根据包头信息重新计算24比特的MAC值，与返回的确认序列号(初始序列号 + 1)进行对比；</li>
<li>服务器对中间3 比特进行解码，完成对SYN队列项的重构。如果验证通过，则服务 器发起TCP会话。</li>
</ol>
</li>
<li>
<p>Optimistic TCP ACK攻击</p>
<ol>
<li>利用TCP的拥塞控制机制。在TCP的华东窗口协议中，虽则接收ACK的增多，窗口大小增大。</li>
<li><strong>攻击</strong> 恶意客户端在没有收到SYN-ACK时，就提前发送ACK，使得服务 器增加其传输速度。如果同时针对多台服务器进行TCP ACK攻击，它会通过淹 没网络带宽资源，导致互联网范围内的拥塞。</li>
<li><strong>防御</strong> 设置对每个客户端最大流量的限制。</li>
</ol>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导第4章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC4%E7%AB%A0/"
    >计安导第4章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC4%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.494Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="内部攻击"><a class="markdownIt-Anchor" href="#内部攻击"></a> 内部攻击</h1>
<ol start="2">
<li>内部攻击：指控制和保护资产的内部人员利用安全漏洞进行的攻击</li>
</ol>
<h2 id="后门"><a class="markdownIt-Anchor" href="#后门"></a> 后门</h2>
<ol start="3">
<li>后门：是程序中隐藏的功能或命令，有时也称为活门，它允许用户执行一些正常情况下不允许用户执行的操作。通常这些操作会违反安全策略，如执行特权升级。
<ol>
<li>为调试有时也会插入后门</li>
<li>为了紧急情况也可能留后门</li>
<li>恶意的后门：直接留后门；在程序中引入脆弱性，如缓冲区溢出。</li>
<li>彩蛋</li>
</ol>
</li>
</ol>
<h2 id="逻辑炸弹"><a class="markdownIt-Anchor" href="#逻辑炸弹"></a> 逻辑炸弹</h2>
<ol start="4">
<li>逻辑炸弹：是一种程序，它根据一定的逻辑条件执行恶意操作。</li>
<li>千年虫问题：具有和逻辑炸弹类似的效果，但是不视为逻辑炸弹</li>
</ol>
<h2 id="内部攻击的防御"><a class="markdownIt-Anchor" href="#内部攻击的防御"></a> 内部攻击的防御</h2>
<ol>
<li>避免单点故障：不能只让一个人创建备份或管理重要系统。</li>
<li>使用代码走查</li>
<li>使用归档和报告工具</li>
<li>限制授权和权限：使用最小权限原则；在保证每个员工能正常工作的情况下，授予他们最小权限。</li>
<li>重要系统的物理安全</li>
<li>监控员工行为</li>
<li>控制软件的安装</li>
</ol>
<h1 id="计算机病毒"><a class="markdownIt-Anchor" href="#计算机病毒"></a> 计算机病毒</h1>
<ol>
<li>计算机病毒：是一种能自我复制的计算机指令或程序代码，它通过修改其他文件与程序来插入代码，且能进一步自我复制；
<ol>
<li>这种自我复制的特性是计算机病毒与其他类型恶意软件（如逻辑炸弹）的不同之处；</li>
<li>病毒的另一个特性是其复制需要某种类型的用户协助，如打开电子邮件附件或共享USB驱动器；</li>
</ol>
</li>
<li>恶意软件分类：
<ol>
<li>按传播特性分：
<ol>
<li>病毒：人工辅助传播</li>
<li>蠕虫：自动传播</li>
</ol>
</li>
<li>按隐藏特性分：
<ol>
<li>Rootkit：修改操作系统以隐藏其存在</li>
<li>特洛伊木马：提供理想的功能但是隐藏恶意操作。</li>
</ol>
</li>
</ol>
</li>
<li>隐藏方式
<ol>
<li>加密病毒：
<ol>
<li>病毒包括解密引擎+病毒代码主体，随机生成加密密钥</li>
<li>检测：通过查找解密引擎</li>
</ol>
</li>
<li>多态病毒
<ol>
<li>具有随机变体的解密引擎的加密病毒</li>
<li>检测：使用CPU仿真器</li>
</ol>
</li>
<li>变形病毒
<ol>
<li>不同的病毒体；方法包括代码排列和指令替换</li>
<li>具有挑战性的检测</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="病毒的分类"><a class="markdownIt-Anchor" href="#病毒的分类"></a> 病毒的分类</h2>
<ol start="3">
<li>病毒执行的四个阶段
<ol>
<li>潜伏阶段</li>
<li>繁殖阶段：病毒进行自我复制，归纳然新系统中的新文件。</li>
<li>触发阶段</li>
<li>行动阶段：此阶段，病毒会执行恶意操作。</li>
</ol>
</li>
<li>病毒的类型
<ol>
<li>程序病毒（文件病毒）：通过修改文件包含的对象代码感染文件。</li>
<li>宏病毒（文档病毒）：打开文档时，启动病毒，此时，病毒搜索其他要感染的文件。此外，宏病毒还可以将自己插入到模板中，使得每次新建的文档都含有此病毒。另外，还可以通过电子邮件传播。</li>
<li>引导区病毒：感染驱动器引导区的代码，每次启动计算机或重启时，都会运行引导区的代码。</li>
</ol>
</li>
<li>病毒的特征
<ol>
<li>传染性</li>
<li>隐蔽性</li>
<li>潜伏性：只有当触发条件满足时才破坏，否则只传染</li>
<li>多态性：不断变种</li>
<li>破坏性</li>
</ol>
</li>
<li>病毒注入：（1）在程序开始处简单注入（2）将病毒代码分成两部分，并将这两部分分别注入到程序的不同位置，使用跳转指令来执行。</li>
</ol>
<h2 id="病毒的防御"><a class="markdownIt-Anchor" href="#病毒的防御"></a> 病毒的防御</h2>
<ol>
<li>病毒的特征码：
<ol>
<li>通过病毒样本找到病毒的特征指令集，产检唯一标识这类病毒的特征字符串。<strong>一般将特征字符串称为病毒的特征码</strong>。它是病毒的一种数字指纹</li>
</ol>
</li>
<li>病毒的检测与隔离
<ol>
<li>可以定期扫描整个文件系统</li>
<li>可以实时的分析每个新创建的文件，每个修改的文件和收到的电子邮件。一旦文件中有一部分包含与病毒特征码匹配的代码，就会被放入隔离区。</li>
</ol>
</li>
</ol>
<h2 id="加密病毒"><a class="markdownIt-Anchor" href="#加密病毒"></a> 加密病毒</h2>
<ol>
<li>加密病毒：通过加密病毒代码的主体，以隐藏其自身的特征码。
<ol>
<li>包括解密代码、密钥和加密病毒代码（解密代码一般用暴力破解代替）。</li>
<li>对病毒主体的解密代码本身时未加密的代码，此结构本身就构成了一种病毒的特征码。</li>
</ol>
</li>
</ol>
<h2 id="多变体病毒和变形病毒"><a class="markdownIt-Anchor" href="#多变体病毒和变形病毒"></a> 多变体病毒和变形病毒</h2>
<ol>
<li>
<p>多变体：变异的病毒。</p>
<ol>
<li>一方面，多变体病毒通过加密使自身呈现出多种形式。</li>
<li>另一方面，多变体病毒采用非加密的混淆技术，如指令重排和包含无用指令技术。</li>
</ol>
</li>
<li>
<p>检测多变体病毒：单个字符串不可能检测变形病毒的特征码，可以采用</p>
<ol>
<li>联合特征码：由在被感染文件中必须出现的字符串集组成。</li>
<li>序列特征码：由在被感染文件中必须出现的有序字符串列表组成</li>
<li>概率特征码：由阈值和字符串-评分对组成。如果文件中存在的字符串的评分总和大于阈值，则认为被感染。</li>
</ol>
</li>
</ol>
<h1 id="恶意软件攻击"><a class="markdownIt-Anchor" href="#恶意软件攻击"></a> 恶意软件攻击</h1>
<h2 id="特洛伊木马"><a class="markdownIt-Anchor" href="#特洛伊木马"></a> 特洛伊木马</h2>
<ol start="2">
<li>
<p>特洛伊木马：是一种恶意程序，表面上，它会执行一些有用的任务，但同时会隐形的执行具有负面后果的任务。</p>
<ol>
<li>
<p>组成：</p>
<ol>
<li>硬件部分：包括控制端、服务端、因特网；</li>
<li>软件部分：控制端程序、木马程序、木马配置程序；</li>
<li>具体连接部分：控制端IP、服务端IP、控制端端口、木马端口；</li>
</ol>
</li>
<li>
<p>木马入侵步骤：</p>
<p>1.配置木马  2.传播木马  3.运行木马</p>
<p>4.信息反馈  5.建立连接  6.远程控制</p>
</li>
</ol>
</li>
<li>
<p>计算机蠕虫：是一种恶意程序，不需要将自己注入其他程序就能传播自己的副本，并且不需要与人交互。</p>
<ol>
<li>
<p>蠕虫可以自我复制传播，但它不属于计算机病毒，因为他们不会感染其他程序。</p>
</li>
<li>
<p>大多数情况下，蠕虫用来删除文件或者安装后门</p>
</li>
<li>
<p>蠕虫的结构<br />
<img src="/计安导_img/第四章1.png" style="zoom:30%"/></p>
</li>
<li>
<p>设计蠕虫<br />
<img src="/计安导_img/第四章2.png" style="zoom:70%"/></p>
</li>
<li>
<p>蠕虫传播</p>
<ol>
<li>传播理论</li>
</ol>
<p>经典的传播病模型<br />
<img src="/计安导_img/第四章3.png" style="zoom:70%"/></p>
</li>
</ol>
<p>N: 易受感染的主机总数; I(t)：在t时刻被感染的主机数<br />
S(t)：在t时刻，易被感染的主机数;I(t)+S(t)=N;β：感染率;I(t)的微分方程 ：dI/dt=βI(t)S(t);	<br />
2. 蠕虫可以利用正在运行应用程序的脆弱性（如缓冲区溢出）来进行自我传播。<br />
3. 一般通过修改注册表来隐藏自身。(同时杀毒软件也会观察一些注册表项)</p>
</li>
<li>
<p>Rootkits</p>
<ol>
<li>Rootkits最早是一组用于UNIX操作系统的工具集，黑客使用它们隐藏入侵活 动的痕迹，它能在操作系统中隐藏恶意程序。这些程序在植入系统后，rootkits 会将它们 隐藏起来，它能隐藏任何恶意程序过程、文件夹、注册码。</li>
<li>一般通过修改系统是实用程序或操作系统本身来防止检测。</li>
<li>通常使用Rootkits来隐藏其他恶意软件的恶意行为（在进程控制器中删除进程的显示，删除文件浏览器中文件的显示）</li>
</ol>
</li>
<li>
<p>恶意软件僵尸</p>
<ol>
<li>僵尸是一种外部控制以执行恶意攻击的计算机，通常作为僵尸网络的一部分。</li>
</ol>
</li>
</ol>
<h2 id="入侵隐私软件"><a class="markdownIt-Anchor" href="#入侵隐私软件"></a> 入侵隐私软件</h2>
<ol>
<li>包括广告软件、间谍软件</li>
</ol>
<h2 id="对策"><a class="markdownIt-Anchor" href="#对策"></a> 对策</h2>
<ol>
<li>
<p>病毒签名：一个签名是一个病毒指纹</p>
<ol>
<li>扫描将分析的对象与签名数据库进行比较。如果文件中包含签名，则文件被感染。</li>
</ol>
</li>
<li>
<p>黑/白名单</p>
<ol>
<li>维护加密哈希数据库<br />
（1）操作系统文件 （2）热门应用程序<br />
（3）已知被感染的文件</li>
<li>需要保护数据库的完整性</li>
</ol>
</li>
<li>
<p>启发式分析</p>
<ol>
<li>用于识别新的和“零日”恶意软件</li>
<li>步骤
<ol>
<li>代码分析：根据说明防病毒软件可以确定该程序是否是恶意的。</li>
<li>执行仿真：在隔离的仿真环境中执行代码，并监控目标文件所采取的操作，如果操作有害，则认为其为病毒。</li>
<li>启发式方法可以触发错误警报</li>
</ol>
</li>
</ol>
</li>
<li>
<p>隔离：将可疑文件隔离在隔离文件夹中。</p>
<ol>
<li>可疑文件未被删除，最终可以由用户决定何使删除</li>
<li>只能通过防病毒程序与隔离区中的文件交互。</li>
<li>隔离区的文件是无害的，因为它是加密的</li>
<li>隔离技术的细节是保密的</li>
</ol>
</li>
<li>
<p>静态分析与动态分析</p>
 <img src="/计安导_img/第四章4.png" style="zoom:70%"/>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导第6章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC6%E7%AB%A0/"
    >计安导第6章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC6%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.494Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="dns-域名系统"><a class="markdownIt-Anchor" href="#dns-域名系统"></a> DNS 域名系统</h1>
<ol>
<li>DNS是应用层协议，负责将域名映射到IP地址。</li>
<li>DNS数据库包括
<ol>
<li>地址记录：与主机名相关链的IP地址。</li>
<li>邮件交换记录：域的邮件服务器。</li>
<li>名称服务器记录：域的权威服务器。</li>
</ol>
</li>
</ol>
<h2 id="应用层协议"><a class="markdownIt-Anchor" href="#应用层协议"></a> 应用层协议</h2>
<ol>
<li>DNS：建立IP和域名间的映射</li>
<li>HTTP:用来浏览网页</li>
<li>SSL/TLS: 以安全的、加密的方式浏览网页的协议(<strong>HTTPS</strong>)</li>
<li>IMAP/POP/SMAP:用于互联网电子邮件</li>
<li>SOAP：用于交换作为网络服务模式部分的结构化数据</li>
<li>talent：远程访问协议(与FTP一样，不提供加密)</li>
<li>SSH:较新的安全远程访问和管理协议</li>
</ol>
<h2 id="域名服务器"><a class="markdownIt-Anchor" href="#域名服务器"></a> 域名服务器</h2>
<ol>
<li>域名：最右为顶级域名(TLD)</li>
<li>域名服务器从上至下依次为
<ol>
<li>根域名服务器：管理顶级域名.</li>
<li>顶级域名服务器:如.com。其中保存的每条记录都对应一个权威域名服务器</li>
<li>权威域名服务器</li>
</ol>
</li>
</ol>
<h2 id="域名解析"><a class="markdownIt-Anchor" href="#域名解析"></a> 域名解析</h2>
<ol>
<li>
<p>区域：具有相同权威DNS服务器的已连接节点的集合。</p>
</li>
<li>
<p>域名解析：</p>
<ol>
<li>迭代解析</li>
</ol>
 <img src="/计安导_img/2.png"  />
<ol start="2">
<li>递归解析</li>
</ol>
 <img src="/计安导_img/3.png"  />	
</li>
</ol>
<h2 id="权威域名服务器"><a class="markdownIt-Anchor" href="#权威域名服务器"></a> 权威域名服务器</h2>
<ol>
<li>权威域名服务器层次结构：权威域名服务器也是分层的，每个域名服务器都存储着记录的集合，每个记录提供域名地址或者对该域权威域名服务器的引用。</li>
<li>作用：控制在权威域名服务器(ANS)之间分配
<ol>
<li>负责特定域</li>
<li>可以为子域指定其他ANS</li>
</ol>
</li>
</ol>
<h2 id="dns数据包"><a class="markdownIt-Anchor" href="#dns数据包"></a> DNS数据包</h2>
<ol>
<li>DNS查询和应答是通过UDP实现的，但当请求超过512时，会采用TCP。</li>
<li>DNS查询通常通过端口53上的UDP发出。</li>
</ol>
<h3 id="组成"><a class="markdownIt-Anchor" href="#组成"></a> 组成：</h3>
<ol>
<li>头：包含16为查询标识符，用于标识查询和响应</li>
<li>查询部分：由问题序列组成，每个问题由所查询域名和查询记录的类型组成。</li>
<li>应答部分包括
<ol>
<li>NAME 包含一个全域名</li>
<li>2B的TYPE 标识DNS记录的类型</li>
<li>2B的CLASS域 标识更广泛的类型</li>
<li>4B的TTL 标识有效时间</li>
<li>2B的RDLENGTH 标识数据段的长度</li>
<li>可变长RDATA段 包括实际的记录数据</li>
</ol>
</li>
</ol>
<h2 id="dns缓存"><a class="markdownIt-Anchor" href="#dns缓存"></a> DNS缓存</h2>
<ol>
<li>目的：如果每个查询都遍历DNS树会导致根区域过载</li>
<li>缓存有效期：由ANS回复的TTL指定。</li>
<li>由操作系统和浏览器维护缓存</li>
</ol>
<h2 id="dns-攻击-网络嫁接与网络钓鱼"><a class="markdownIt-Anchor" href="#dns-攻击-网络嫁接与网络钓鱼"></a> DNS 攻击： 网络嫁接与网络钓鱼</h2>
<ol>
<li><strong>过程</strong> 攻击者把网站发送请求解析成子集恶意服务器的伪装IP地址，导致受害人浏览或下载伪造的内容。</li>
<li><strong>用途</strong> 伪造王章</li>
</ol>
<h2 id="dns-缓存中毒"><a class="markdownIt-Anchor" href="#dns-缓存中毒"></a> DNS 缓存中毒</h2>
<ol>
<li>
<p><strong>思想</strong> 攻击者欺骗DNS服务器缓存保存虚假的DNS记录。</p>
 <img src="/计安导_img/4.png"  />
 <img src="/计安导_img/5.png"  />
 <img src="/计安导_img/6.png"  />
</li>
<li>
<p><strong>检测</strong> DNS使用16位请求标识符将查询ID与响应ID配对。当服务器</p>
<ol>
<li>忽略标识符</li>
<li>具有可预测的ID</li>
<li>接受未经请求的DNS记录</li>
</ol>
<p>说明可能中毒了</p>
</li>
<li>
<p>防御DNS缓存中毒</p>
<ol>
<li>对查询使用随机标识符</li>
<li>始终检查标识符</li>
<li>DNS请求的端口随机化</li>
<li>部署DNSSEC（DNS协议的安全扩展集）</li>
</ol>
</li>
</ol>
<h2 id="dns缓存中毒和生日悖论"><a class="markdownIt-Anchor" href="#dns缓存中毒和生日悖论"></a> DNS缓存中毒和生日悖论</h2>
<blockquote>
<p>DNS 协议交换不验证对递归迭代查询的响应。验证查询只会检查 16 位事务 ID 以及响应数据包的源 IP 地址和目标端口。在 2008 年之前，所有 DNS 使用固定端口53 解析.因此，除了事务 ID 之外，欺骗 DNS 回复所需的所有信息都是可预测的。用这种弱点攻击 DNS 被称为“生日悖论”，平均需要 256 次来猜测事务 ID。为了使攻击成功，伪造的 DNS 回复必须在合法权威响应之前到达目标解析器。如果合法响应首先到达，它将由解析器缓存，并且直到其生存时间（TTL）到期，解析器将不会要求权威服务器解析相同的域名，从而防止攻击者中毒映射该域，直到 TTL 到期。</p>
</blockquote>
<h2 id="dnssec"><a class="markdownIt-Anchor" href="#dnssec"></a> DNSSEC</h2>
<blockquote>
<p>DNSSEC 采用基于公共密钥加密的数字签名，从而增强 DNS 验证强度。DNSSEC 并非对 DNS 查询和响应本身进行加密签名，而是由数据所有者对 DNS 数据自身进行签名。</p>
</blockquote>
<blockquote>
<p>每一个 DNS 区均包含一个公私秘钥对。DNS 区所有者使用该区域的私钥对区域内的 DNS 数据进行签名，为这些数据生成数字签名。顾名思义，&quot;私钥&quot;是指 DNS 区所有者会对这些密钥材料保密。但是，该区域的公钥则在区域内公开发布，供全体用户检索。凡在区域内查找数据的递归解析器，还必需检索区域公钥，从而使用公钥验证 DNS 数据的真实性。解析器确认检索到的 DNS 数据的数字签名是否有效。如果有效，证明 DNS 数据合法，则将 DNS 数据返回给用户。如果签名未通过验证，解析器会假设发生攻击，丢弃数据并向用户返回错误。</p>
</blockquote>
<ol>
<li>
<p>目的：验证</p>
<ol>
<li>DNS回答来源的真实性</li>
<li>回复的完整性</li>
<li>拒绝存在的真实性</li>
</ol>
</li>
<li>
<p>通过在每一步中对DNS回复签名来实现这一点</p>
</li>
<li>
<p>使用公钥加密对所有DNS应答进行数字签名</p>
</li>
<li>
<p>通常使用信任锚，操作系统中的条目来引导进程</p>
</li>
<li>
<p>现状：加入安全机制后，数据包会远大于512B的UDP数据包。</p>
</li>
</ol>
<h1 id="防火墙"><a class="markdownIt-Anchor" href="#防火墙"></a> 防火墙</h1>
<ol>
<li>
<p>定义：防火墙是一种集成的安全措施集合，旨在防止对网络计算机 系统未经授权的访问。</p>
</li>
<li>
<p>防火墙策略：</p>
<ol>
<li>接收</li>
<li>拒绝</li>
<li>丢弃</li>
</ol>
</li>
<li>
<p>数据包匹配：基于数据包的一些特性。</p>
</li>
</ol>
<h2 id="黑名单与白名单"><a class="markdownIt-Anchor" href="#黑名单与白名单"></a> 黑名单与白名单</h2>
<h3 id="黑名单"><a class="markdownIt-Anchor" href="#黑名单"></a> 黑名单</h3>
<ol>
<li>默认规则为接收，只拒绝/丢弃黑名单定义的规则匹配到的数据包。</li>
</ol>
<h3 id="白名单"><a class="markdownIt-Anchor" href="#白名单"></a> 白名单</h3>
<ol>
<li>默认规则拒绝，只接收白名单规则匹配到的数据包。</li>
</ol>
<h2 id="防火墙分类"><a class="markdownIt-Anchor" href="#防火墙分类"></a> 防火墙分类</h2>
<ol>
<li>数据包过滤器(无状态防火墙)：如果数据包与数据包过滤器的规则集匹配，则数据包过滤器将丢弃或者接受他。</li>
<li>状态过滤器(状态防火墙)：一种能够提供状态数据包检查或状态查看功能的防火墙，能够持续追踪穿过这个防火墙的各种网络连接（例如TCP与UDP连接）的状态。这种防火墙被设计来区分不同连接种类下的合法数据包。只有匹配主动连接的数据包才能够被允许穿过防火墙，其他的数据包都会被拒绝。</li>
<li>应用层防火墙：当内部计算机与外部主机连结时，将由代理服务器（Proxy Server）担任内部计算机与外部主机的连结中继者。使用ALG的好处是隐藏内部主机的地址和防止外部不正常的连接，如果代理服务器上未安装针对该应用程序设计的代理程序时，任何属于这个网络服务的封包将完全无法通过防火墙。</li>
</ol>
<h3 id="无状态防火墙"><a class="markdownIt-Anchor" href="#无状态防火墙"></a> 无状态防火墙</h3>
<ol>
<li>将每个尝试通过它的数据包视为独立的，而不考虑前后数据包间的关系。</li>
<li>因此必须具有严格的限制性</li>
</ol>
<h3 id="状态防火墙"><a class="markdownIt-Anchor" href="#状态防火墙"></a> 状态防火墙</h3>
<ol>
<li>可以区分数据包是否是<strong>受信任网络</strong>内发起的<strong>合法会话</strong>的一部分。</li>
<li>状态防火墙维护一些表，表中包含每个活动<strong>连接的信息</strong>， 包括<strong>IP地址、端口和数据包的序列号</strong>。通过这些表，可以只允许响应内部网发起连接的TCP数据包流入。</li>
<li><strong>对于TCP</strong> 一旦完成初始的握手，且也允许数据包通过防火墙，则该连接的所有后续通信都允许通过防火墙，直到连接终止。</li>
<li><strong>对于UDP</strong> 由于UDP没有握手过程，所以一般情况下，当防火墙允许合法UDP通过</li>
</ol>
<h3 id="应用层防火墙"><a class="markdownIt-Anchor" href="#应用层防火墙"></a> 应用层防火墙</h3>
<ol>
<li>基于进入或流出网络数据包的实际内容来管理流量，而不是仅仅分析源和目的。</li>
</ol>
<h3 id="现状基于深度数据包检测技术"><a class="markdownIt-Anchor" href="#现状基于深度数据包检测技术"></a> 现状：基于深度数据包检测技术</h3>
<h1 id="隧道-tcp"><a class="markdownIt-Anchor" href="#隧道-tcp"></a> 隧道----&gt;TCP</h1>
<ol>
<li><strong>问题</strong> 由于TCP本身是不加密的，如果有人窃听TCP连接，就可以知道有效载荷中的全部内容。</li>
<li><strong>解决</strong> 使用隧道协议，无需改变软件的执行就能防止窃听，并且加密是自动的。</li>
<li><strong>缺点</strong> 需要在传输层或网络层协议中使用应用层概念，增加了协议栈的开销。</li>
</ol>
<h2 id="安全的shell-ssh-telnetftprlogin等早期远程管理协议"><a class="markdownIt-Anchor" href="#安全的shell-ssh-telnetftprlogin等早期远程管理协议"></a> 安全的Shell (SSH) -&gt;Telnet,FTP,rlogin等早期远程管理协议</h2>
<ol>
<li>使用对称和公钥密码技术加密通信。</li>
<li>常用于<strong>安全隧道</strong>，目的是使窃听者无法推断出SSH流量的内容，使用SSH建立的隧道能防止许多基于数据包嗅探的攻击。</li>
<li><strong>安全的交互式命令会话</strong>过程：
<ol>
<li>客户端通过一个TCP会话连接到服务器</li>
<li>客户端与服务器交换管理细节的信息，如支持的加密方法、各 自协议的版本，每一方都要选择另一方支持的一组协议</li>
<li>客户端和服务器进行密钥交换，创建共享的秘密会话密钥，用 会话密钥加密双方的通信（但不用于身份验证）。这个会话密 钥配合选择的块加密（通常是AES、3DES、Blowfish或IDEA） 来加密所有后续的通信</li>
<li>服务器向客户端发送可以接受身份验证列表，客户端将按顺序尝 试。最常见的机制是使用密码或以下的公共密钥身份验证方法：
<ol>
<li>如果选定的机制是<strong>公共密钥身份验证</strong>，则客户端向服务器发送<strong>自己的</strong>公钥；</li>
<li>然后服务器检查是否这密钥已存储在其授权的密钥列表之中。如果在， 服务器使用客户的<strong>公钥加密挑战</strong>，并将其发送给客户端；</li>
<li>客户用自己的私钥解密挑战，并向服务器发回响应，证明自己的身份；</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="ipsecip"><a class="markdownIt-Anchor" href="#ipsecip"></a> IPSec–&gt;IP</h2>
<p>IPSec协议族在网络层保证应用程序的安全，为数据包提供机密性和真实性。且协议族中每个协议都能运行在<strong>传输模式</strong>或<strong>隧道模式</strong>下</p>
<ol>
<li><strong>传输模式</strong>：在原数据包的数据之前，插入额外的IPSec的头信息，只对数据包的有效载荷继续加密或身份验证。</li>
<li><strong>隧道模式</strong>：构造一个新的数据包，将IPSec头信息和整个原数据包一起封装进新数据包的有效载荷中。</li>
</ol>
<h2 id="vpn-虚拟专用网"><a class="markdownIt-Anchor" href="#vpn-虚拟专用网"></a> VPN 虚拟专用网</h2>
<p>分为 <strong>远程访问VPN</strong>和<strong>站点到站点的VPN</strong></p>
<h3 id="远程访问vpn"><a class="markdownIt-Anchor" href="#远程访问vpn"></a> 远程访问VPN</h3>
<p>允许授权的用户通过安装在自己电脑上的客户端通过NAS访问私有网络，即内网。</p>
<ol>
<li><strong>网路接入服务器(NAS)</strong>：VPN服务端</li>
</ol>
<h3 id="站点到站点的vpn"><a class="markdownIt-Anchor" href="#站点到站点的vpn"></a> 站点到站点的VPN</h3>
<p>旨在为<strong>两个或更多</strong>远程网络提供安全的桥梁。两个网络各有一个独立的VPN端点，两端点之间相互通信。</p>
<h3 id="安全问题"><a class="markdownIt-Anchor" href="#安全问题"></a> 安全问题</h3>
<ol>
<li>
<p>使用点对点的隧道协议 PPTP</p>
<p>首先使用PPP建立连接，然后封装PPP帧，然后用MPPE对其加密，最后通过互联网发送数据包。</p>
</li>
</ol>
<h2 id="隧道存在的安全风险"><a class="markdownIt-Anchor" href="#隧道存在的安全风险"></a> 隧道存在的安全风险</h2>
<ol>
<li>会规避防火墙的策略。当使用隧道技术时，会不同的传输协议对一系列网络数据包的有效载荷进行封装。同时，在隧道协议中也对有效载荷进行了加密，所以深度数据包检测也毫无用处。</li>
<li>如果内部用户通过隧道直接和外部服务器连接，并代表该用户向禁止访问的网站路由HTTP流量，同样通过隧道，将响应返回给该用户。相应的，攻击者也可以通过隧道规避防火墙。</li>
</ol>
<h1 id="入侵检测"><a class="markdownIt-Anchor" href="#入侵检测"></a> 入侵检测</h1>
<h2 id="入侵检测系统-ids"><a class="markdownIt-Anchor" href="#入侵检测系统-ids"></a> 入侵检测系统 IDS</h2>
<p>IDS 是一个软件或硬件系统，用于检测网络或个人计算机上恶意活动的迹象。</p>
<ol>
<li>
<p>分类： 按功能分</p>
<ol>
<li>
<p>IDS传感器，用于收集网络组件或计算机的实时数据</p>
</li>
<li>
<p>IDS管理器，用于接收来自传感器的报告</p>
</li>
<li>
<p><strong>关系</strong>：IDS管理器编译来自IDS传感器的数据，以确定是否发生了入侵。以此确定基于一组站点策略，这些策略是定义可能入侵的规则和条件。如果 IDS管理员检测到入侵，则会发出警报。</p>
</li>
</ol>
</li>
<li>
<p>IDS所检测的威胁包括</p>
<ol>
<li>伪装者：冒用合法用户的身份或凭据来获得对计算机系统或网络的访问的攻击者</li>
<li>违反者：执行了未经授权的操作的合法的用户</li>
<li>秘密用户：通过删除审计文件或系统日志，试图组织或掩盖自己行为的用户</li>
</ol>
</li>
<li>
<p>IDS所检测的攻击包括</p>
<ol>
<li><strong>端口扫描</strong>：是指某些别有用心的人发送一组端口扫描消息，试图以此侵入某台计算机，并了解其提供的计算机网络服务类型。攻击者可以通过它了解到从哪里可探寻到攻击弱点。</li>
<li><strong>拒绝服务攻击</strong>：网络攻击淹没主机，并将合法访问拒之门外</li>
<li><strong>恶意软件攻击</strong>：复制恶意软件的攻击，特洛伊木马、计算机蠕虫和病毒等</li>
<li>ARP欺骗：试图重定向局域网中的IP流量</li>
<li><strong>DNS缓存中毒</strong>：网络嫁接攻击旨在改变主机的DNS缓存，以创建伪造的域名/IP 地址的关联</li>
</ol>
</li>
</ol>
<h2 id="入侵检测技术"><a class="markdownIt-Anchor" href="#入侵检测技术"></a> 入侵检测技术</h2>
<ol>
<li>
<p>传统的网络入侵检测系统（NIDS）</p>
<p>– 位于网络边界，基于<strong>流量模式和内容</strong>检测恶意的行为；</p>
</li>
<li>
<p>基于入侵检测系统的协议（PIDS）</p>
<p>– <strong>专门检测特定协议中的恶意行为</strong>，通常部署在特定的网络主机中。如 Web服务器可以运行PIDS来分析流入的HTTP流量，丢弃恶意的或包含错误的请求</p>
</li>
<li>
<p>基于主机的IDS（HIDS）</p>
<p>– 驻留在单个系统之中，<strong>监控这台计算机上的活动</strong>。如系统调用，进程间 的通信和资源使用模式</p>
</li>
</ol>
<h2 id="ids攻击"><a class="markdownIt-Anchor" href="#ids攻击"></a> IDS攻击</h2>
<p>通过对IDS本身发动Dos攻击，故意触发大量入侵警报。直到淹没IDS，使他无法记录每个事件，或让管理员很难确定哪些日志代表攻击。</p>
<h2 id="入侵检测错误"><a class="markdownIt-Anchor" href="#入侵检测错误"></a> 入侵检测错误</h2>
<p>包括：</p>
<ol>
<li>误报：当事件是良性活动而不是入侵时就发出警报，导致时间和资源的浪费。</li>
<li>漏报：当事件是入侵的恶意事件，却未发出警报。</li>
</ol>
<h3 id="基率谬误"><a class="markdownIt-Anchor" href="#基率谬误"></a> 基率谬误</h3>
<p>由于基率谬误的存在，可能使某些IDS的有效性被误解。所以，当评估某些条件事件的概率而不考虑该事件的“基本概率”时，会发生此类错误。例如：</p>
<ol>
<li>
<p>假设IDS准确度为99％，假阳性或假阴性的概率为1％。</p>
</li>
<li>
<p>假设入侵检测系统生成1,000,100个日志条目。 1,000,100个条目中只有100个对应于实际的恶意事件。</p>
</li>
<li>
<p>由于IDS的成功率，在100个恶意事件中，99个将被检测为恶意，这意 味着我们有1个假阴性。</p>
</li>
<li>
<p>然而，在1,000,000个良性事件中，10,000个将被错误地识别为恶意事件。</p>
</li>
<li>
<p>因此，将共有10,099个警报响起，其中10,000个是误报警。也就是说，大约99％的警报都是误报警。</p>
</li>
</ol>
<h2 id="ids数据收集和审计记录"><a class="markdownIt-Anchor" href="#ids数据收集和审计记录"></a> IDS数据收集和审计记录</h2>
<ol>
<li>
<p>入侵检测的输入是确定网络或主机操作基本的记录流</p>
</li>
<li>
<p>记录流中操作的类型包括：</p>
<ol>
<li>基于网的IDS，包括每次HTTP会话尝试、每次登录尝试、每 次TCP绘画的初始化等；</li>
<li>基于主机的IDS，包括对文件的读、写或执行</li>
</ol>
</li>
<li>
<p>IDS传感器检测这些操作，创建这些操作的特征。将这 些记录报告给IDS管理器或者将它们写入审计日志</p>
</li>
<li>
<p>IDS事件记录包括：主体，对象，操作，异常条件，占用的资源，时间戳。</p>
</li>
</ol>
<h2 id="入侵检测系统的类型"><a class="markdownIt-Anchor" href="#入侵检测系统的类型"></a> 入侵检测系统的类型</h2>
<h3 id="基于规则的入侵检测"><a class="markdownIt-Anchor" href="#基于规则的入侵检测"></a> 基于规则的入侵检测</h3>
<ol>
<li>
<p><strong>规则</strong>标识与入侵攻击的某些已知<strong>配置文件匹配的操作类型</strong>，在这种情况下， 规则将编码此类攻击的<strong>签名</strong>。因此，如果IDS管理器看到与该规则的签名匹配的事件，它将立即发出警报，甚至可能指示怀疑的类型。</p>
</li>
<li>
<p><strong>优点</strong>：减少了误报，因为决策者已经明确了规则列表。</p>
</li>
<li>
<p><strong>缺点</strong>：存在局限性，因为它需要IDS具有每一个攻击类型的特征。</p>
</li>
</ol>
<h3 id="基于统计的入侵检测"><a class="markdownIt-Anchor" href="#基于统计的入侵检测"></a> 基于统计的入侵检测</h3>
<ol>
<li>构建了一个配置文件，它是用户行为或主机使用的<strong>典型方式</strong>的统计表示； 因此，它可用于确定用户或主机何时以非常不寻常的<strong>异常方式</strong>运行。</li>
</ol>
<h3 id="端口扫描"><a class="markdownIt-Anchor" href="#端口扫描"></a> 端口扫描</h3>
<ol>
<li>允许用户列举计算机的哪个端口正在接受连接的技术。端口的状态包括：开放的，关闭的，阻塞的。</li>
<li>端口扫描的方法：
<ol>
<li>
<p>TCP扫描/连接扫描：向目标主机的每个端口发起TCP连接。完成连接的端口是开放的，否则要么是关闭的，要么是阻塞的。</p>
</li>
<li>
<p>SYN扫描：向目标主机端口发起SYN标志的数据包，看是否有SYN-ACK返回。(如果收到，则发出一个RST数据包终止连接而非完成握手)</p>
</li>
<li>
<p>空闲扫描：它允许进行端口完全欺骗扫描。使得攻击者能够不使用自己的IP向目标主机发送数据包。它的巧妙之处在于，利用不活跃的“僵尸主机”反弹给攻击者一个旁通信道，从而使得攻击者可以进行端口扫描。入侵检测系统也就会把无辜的僵尸主机当成攻击者。利用僵尸可预测的TCP序列号实现。其过程如下：</p>
<ol>
<li>探测僵尸主机的IP ID 并记录。</li>
<li>向需要扫描的目标主机端口发送一个伪造成来自僵尸主机的SYN包。根据目标主机端口状态的不同，目标主机返回的数据包会使得僵尸主机的IP ID递增或否。</li>
<li>再次探测僵尸主机的IP ID。并对比第一步记录的IP ID就可以确定目标主机端口的状态。如果序列号递增了，则表示目标端口是开放的。否则，目标端口是关闭或阻塞的。</li>
</ol>
</li>
<li>
<p>UDP扫描：向目标主机端口发送UDP数据包。</p>
</li>
</ol>
</li>
</ol>
<h2 id="蜜罐"><a class="markdownIt-Anchor" href="#蜜罐"></a> 蜜罐</h2>
<p>使用一台计算机作为诱饵的入侵检测技术。其优点包括</p>
<ol>
<li>
<p>入侵检测：因为连接到蜜罐的尝试不会来自合法用户，所以 对蜜罐的任何连接都被安全地确定为入侵。</p>
</li>
<li>
<p>证据：蜜罐计算机中有吸引力的文件使入侵者逗留并留下证据，从而识别出入侵者或者确定他的位置。</p>
</li>
<li>
<p>导流：与合法计算机相比，蜜罐对入侵者更有吸引力，从而分散入侵者对敏感信息和服务的注意力。</p>
</li>
</ol>
<h1 id="无线网"><a class="markdownIt-Anchor" href="#无线网"></a> 无线网</h1>
<p>无线网引入安全问题包括：</p>
<ol>
<li>使得<strong>数据包嗅探</strong>更加容易。因为同一个网段的所有计算机都共享一个无线接入点。</li>
<li>使得<strong>会话劫持</strong>更加容易。因为配有无线适配器的计算机都可以嗅探出数据包并模拟无线接入点。</li>
<li>存在<strong>入侵</strong>问题。入侵指未授权用户通过其他人的无限接入点连接到互联网。</li>
<li>验证<strong>合法用户</strong>的难度增加。通过在局域网中主机的位置来验证合法主机再不可能，需要其他的身份验证或授权方法。</li>
</ol>
<h2 id="无线网结构"><a class="markdownIt-Anchor" href="#无线网结构"></a> 无线网结构</h2>
<img src="/计安导_img/7.png"  />	
<ol>
<li>基于802.11标准。大多数的TCP/IP实现会根据不同的接收者重新定义数据包，即802.11帧和以太网帧的相互转换。</li>
<li>结构
<ol>
<li>客户端计算机与接入点建立无线连接。</li>
<li>无线接入点连接到有线网络的接入点提供到互联网的网关。</li>
</ol>
</li>
</ol>
<h2 id="ssid-服务集id"><a class="markdownIt-Anchor" href="#ssid-服务集id"></a> SSID (服务集ID)</h2>
<ol>
<li>SSID 32个字符组成的网络标识，使得多个无线网络可以共存。
<ol>
<li>制造商的名称是接入点的典型默认SSID。</li>
<li>经常广播SSID可以使潜在用户能够发现网络</li>
</ol>
</li>
<li><strong>问题</strong> ：由于SSID未被签名，所以可以进行欺骗攻击
<ol>
<li>将恶意接入点放置在公共场所（例如，咖啡馆，机场）；</li>
<li>使用ISP的SSID</li>
<li>设置类似于ISP的登录页面；</li>
<li>等待客户端连接到恶意接入点并进行身份验证；</li>
<li>可能会转发到ISP网络的会话；</li>
<li>由自动连接默认值促成</li>
</ol>
</li>
</ol>
<h2 id="强制网络门户"><a class="markdownIt-Anchor" href="#强制网络门户"></a> 强制网络门户</h2>
<ol>
<li>
<p><strong>定义</strong>：是公共接入网络的用户在授予访问权限之前必须查看和交互的网页。通常 用于商业中心、机场、酒店大堂、咖啡店等为用户提供免费Wi-Fi的场所</p>
</li>
<li>
<p><strong>协议</strong></p>
<ol>
<li>
<p>通过MAC地址定位客户端。</p>
</li>
<li>
<p>认证完成之前，任何URL都会被重定向到身份验证界面。</p>
<ol>
<li>防火墙会阻止其他流量。</li>
<li>名称服务器会将一切映射到认证服务器。</li>
</ol>
</li>
<li>
<p>身份验证之后，恢复常规网络服务。由DHCP提供IP地址。</p>
</li>
</ol>
</li>
<li>
<p><strong>问题</strong></p>
<ol>
<li>如果客户端没有主动断开连接，则可以执行MAC欺骗和会话窃取。</li>
<li>如果身份验证之前未阻止防火墙之外的DNS流量，则隧道攻击可以绕过强制网络门户。</li>
</ol>
</li>
</ol>
<h2 id="wardriving-and-warchalking"><a class="markdownIt-Anchor" href="#wardriving-and-warchalking"></a> Wardriving and Warchalking</h2>
<ol>
<li>Wardriving在移动的汽车中，使用移动设备四处寻找无线网。</li>
<li>Warchalking（开战标记）：在公共场所绘制引导公共Wi-Fi网 络的一种绘画符号（源自流浪汉符号）</li>
</ol>
<h2 id="wep-有线等效保密协议"><a class="markdownIt-Anchor" href="#wep-有线等效保密协议"></a> WEP 有线等效保密协议</h2>
<p>###<strong>目标</strong> ：</p>
<ol>
<li>机密性:防止窃听。</li>
<li>数据完整性：保证数据包不被篡改。</li>
<li>访问控制：仅路由正确加密的数据包。<br />
###<strong>限制</strong></li>
<li>在数据链路层加密每个帧的主体。</li>
<li>避免传统的802.11标准。</li>
</ol>
<h3 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h3>
<p>接入点和客户端共享40b的密钥。密钥在WEP会话期间不被更改。</p>
<h3 id="流密码"><a class="markdownIt-Anchor" href="#流密码"></a> 流密码</h3>
<ol>
<li>流密码是一种对称加密系统，密文C由明文消息M异或密钥流生成，而密钥流是密钥产生的伪随机数二进制向量S。</li>
<li><strong>流密码是安全的</strong> 因为相同的密钥流永远不会被重用，否则攻击者会得到两个明文消息的异或值，统计攻击就能同时恢复明文和密钥流。</li>
</ol>
<h3 id="加密"><a class="markdownIt-Anchor" href="#加密"></a> 加密</h3>
<ol>
<li>计算消息M(有效载荷部分)的CRC校验和。</li>
<li>选择24b的初始化向量V</li>
<li>使用RC4流密码生成密钥流S(K,V)</li>
<li>计算密文 C=(M||CRC(m))⊕S(K,V)</li>
</ol>
<h3 id="wep-认证方法"><a class="markdownIt-Anchor" href="#wep-认证方法"></a> WEP 认证方法</h3>
<p>包括开放系统和共享密钥两种。</p>
<ol>
<li>
<p><strong>开放系统</strong>身份验证</p>
<p>客户端无需任何凭证就可以连接接入点。且只能使用正确的密钥发送和接收信息，否则接入点会忽略请求。</p>
</li>
<li>
<p><strong>共享密钥</strong>身份验证</p>
<p>在连入接入点之前要先证明自己拥有接入点的WEP密钥。</p>
<ol start="2">
<li>接入点向客户端发起明文挑战，客户端用拥有的密钥加密该明文，并将生成的密文发给接入点。</li>
<li>如果接入点能正确解密，则可连接接入点。</li>
</ol>
</li>
</ol>
<h2 id="消息篡改攻击"><a class="markdownIt-Anchor" href="#消息篡改攻击"></a> 消息篡改攻击</h2>
<h3 id="消息篡改"><a class="markdownIt-Anchor" href="#消息篡改"></a> 消息篡改</h3>
<p>对于给定一个任意字符串 ，我们想用M’=M⊕▲替换消息M</p>
<p>可以在中途用C’=C⊕(▲||CRC(▲))来替换C。</p>
<ol>
<li>需要直到消息中文本的位置即可</li>
<li><strong>脆弱性原因</strong> CRC检验和是通过XOR</li>
<li><strong>解决</strong> 改用哈希函数</li>
</ol>
<h2 id="ip重定向攻击"><a class="markdownIt-Anchor" href="#ip重定向攻击"></a> IP重定向攻击</h2>
<p>指攻击者利用物理接入点解密数据包，将目的地址修改为恶意主机地址。</p>
<ol>
<li>
<p>过程为：</p>
<ol>
<li>窃听入站的IP数据包。</li>
<li>将数据包重新发送到由攻击者控制的外部计算机。</li>
<li>接收由接入点解密的数据包。</li>
<li>重复出站数据包。</li>
</ol>
</li>
<li>
<p>需要修改数据包校验和。校验和的差为：x’-x=(D’H+D’L)-(DH-DL)</p>
</li>
</ol>
<h2 id="重用初始化向量iv"><a class="markdownIt-Anchor" href="#重用初始化向量iv"></a> 重用初始化向量IV</h2>
<h3 id="初始化向量iv"><a class="markdownIt-Anchor" href="#初始化向量iv"></a> 初始化向量IV</h3>
<ol>
<li>每个数据包一个，24位。</li>
<li>以邮件的明文部分发送。</li>
<li>初始化向量空间过小会导致重用相同的密钥流。</li>
</ol>
<h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h3>
<ol>
<li><strong>问题</strong> 重用初始化向量意味着重用密钥流，攻击者获得两条消息的XOR，可以恢复出消息和密钥流。</li>
<li><strong>默认IV存在上述问题</strong></li>
<li><strong>解决</strong> 使用随机IV，且长度要足够长。</li>
</ol>
<h3 id="注入方法"><a class="markdownIt-Anchor" href="#注入方法"></a> 注入方法</h3>
<ol>
<li>假设攻击者知道一个加密消息的一个明文。</li>
<li>利用RC4(X )⊕X⊕Y=RC4(Y),来构造计算CRC32的新消息。</li>
</ol>
<h2 id="身份验证欺骗"><a class="markdownIt-Anchor" href="#身份验证欺骗"></a> 身份验证欺骗</h2>
<ol>
<li>不知道密钥的非法用户可以通过窃听身份验证消息。</li>
<li><strong>攻击</strong>
<ol>
<li>生成挑战R和加密挑战C =(R||CRC®)⊕S(K,V)</li>
<li>计算密钥流S(K,V)=(R||CRC®)⊕C</li>
<li>从接入点挑战时重用密钥流S(K,V)</li>
</ol>
</li>
</ol>
<h2 id="慢攻击wep嗅探"><a class="markdownIt-Anchor" href="#慢攻击wep嗅探"></a> 慢攻击：WEP嗅探</h2>
<p>通过大量数据包去计算初始化向量IV</p>
<h2 id="快攻击数据包注入"><a class="markdownIt-Anchor" href="#快攻击数据包注入"></a> 快攻击：数据包注入</h2>
<h2 id="wpa-wi-fi访问保护"><a class="markdownIt-Anchor" href="#wpa-wi-fi访问保护"></a> WPA Wi-fi访问保护</h2>
<p>目的是为了改进WEP</p>
<h3 id="区别wep"><a class="markdownIt-Anchor" href="#区别wep"></a> 区别WEP</h3>
<ol>
<li>采用128位密钥和48位IV</li>
<li>支持除共享密钥外各种类型的身份验证。</li>
<li>会话期间动态修改密钥。</li>
<li>支持检查完整性的加密。</li>
<li>增加帧计数器防止重放攻击</li>
</ol>
<h3 id="wpa2"><a class="markdownIt-Anchor" href="#wpa2"></a> WPA2</h3>
<ol>
<li>使用AES而不是RC4</li>
<li>处理加密，密钥管理和完整性</li>
<li>由反模式提供的MAC与密码块链接（CCMP）一起使用</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导第3章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC3%E7%AB%A0/"
    >计安导第3章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC3%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.494Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="计算机系统"><a class="markdownIt-Anchor" href="#计算机系统"></a> 计算机系统</h1>
<ol>
<li>包括计算机硬件系统和计算机软件系统。
<ol>
<li>硬件系统包括：运算器，控制器，存储器，输入设备，输出设备。</li>
<li>软件系统：操作系统</li>
</ol>
</li>
<li>操作系统：提供计算机用户和该计算机硬件之间的接口，管理应用程序访问计算机资源的方式。
<ol>
<li>内核：操作系统的核心组件，处理对底层硬件资源的管理。</li>
</ol>
</li>
<li>系统调用：是一种机制，通过这种机制，应用程序可以委托内核来执行与硬件相关的操作。</li>
</ol>
<h1 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程：</h1>
<ol>
<li>进程进程是正在执行的程序的一个实例。</li>
<li>进程树：新的进程由其父进程产生，构成一颗进程树。树的根是init进程，在加载和运行内核后开始执行，并创建登陆会话和系统任务等其他子进程。</li>
<li>进程ID：每个进程都通过唯一的非负整数进行标识。</li>
<li>进程间通信
<ol>
<li>读写文件进行方式
<ol>
<li>通过硬盘，速度较慢。</li>
<li>不便于进行私密通信。</li>
</ol>
</li>
<li>共享内存方式
<ol>
<li>只有内核能管理共享内存区。</li>
</ol>
</li>
<li>管道和套接字：提供进程与进程间通信的通道，通信双方共享管道和套接字。</li>
<li>信号量机制</li>
</ol>
</li>
<li>远程过程调用RPC：允许一个进程调用另一个进程中的子例程。</li>
<li>守护进程和服务
<ol>
<li>守护进程（后台进程）（Windows下称为服务）：运行权限高于任何用户，并在登陆会话结束前就一直存在。如Web服务器，远程登陆等</li>
</ol>
</li>
</ol>
<h1 id="文件系统"><a class="markdownIt-Anchor" href="#文件系统"></a> 文件系统</h1>
<ol>
<li>
<p>文件系统是如何组织计算机的外部、非易失性存储的一种抽象。</p>
</li>
<li>
<p>文件权限</p>
<p>关键在于界定哪些用户可以访问哪些资源。</p>
</li>
<li>
<p>Unix文件权限</p>
<ol>
<li>包括三类用户：
<ol>
<li>owner类</li>
<li>group类：决定了相同组中的用户的文件权限。</li>
<li>others类</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="内存管理"><a class="markdownIt-Anchor" href="#内存管理"></a> 内存管理</h1>
<ol>
<li>内存管理是指如何组织和分配计算机的内存。</li>
<li>进程的地址空间
<ol>
<li>代码段</li>
<li>数据段</li>
<li>BSS：符号起始区块，包含未初始化的静态变量。</li>
<li>堆：动态段，存储运行时产生的数据。</li>
<li>栈：记录函数调用和他们的参数。</li>
</ol>
</li>
<li>内存访问权限
<ol>
<li>五段都有各自的访问权限。通常代码段只读，其他段可以写入</li>
<li><strong>不允许进程访问其他进程的地址空间</strong></li>
</ol>
</li>
<li>虚拟内存
<ol>
<li>每个进程都有一个虚拟地址空间，虚拟内存系统将每个虚拟地址映射为实际内存地址。</li>
<li>由MMU来进行地址转换。</li>
<li>在进程看来，它的虚拟地址空间是连续的，但是实际内存却未必。</li>
<li>优点：允许进程的地址空间大于内存。</li>
<li>缺点：访问硬盘速度慢。</li>
<li><strong>问题</strong>：不正常关机的时候，虚拟页面可能未被删除。攻击者可以通过外部介质引导另一个操作系统，查看并重建部分内存，导致信息泄漏。</li>
<li><strong>解决</strong>：对硬盘内容进行加密。</li>
</ol>
</li>
<li>缺页</li>
<li>虚拟机
<ol>
<li>不直接接触底层硬件就允许操作系统的运行。</li>
<li>在虚拟机中运行的操作系统称为客户机，本地的操作系统称为主机。</li>
<li>虚拟机的实现：
<ol>
<li>模拟：主机系统翻译接口的通信，传给硬件。其优点是增加了硬件的灵活性，缺点是使性能下降。</li>
<li>虚拟化：失去硬件灵活性，但是性能提升了。</li>
</ol>
</li>
<li>虚拟机的优点
<ol>
<li>提高了硬件效率：在一台机器上托管多个操作系统。</li>
<li>可移植性</li>
<li>安全：沙箱</li>
<li>便于管理</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="进程安全"><a class="markdownIt-Anchor" href="#进程安全"></a> 进程安全</h1>
<h2 id="引导顺序及安全"><a class="markdownIt-Anchor" href="#引导顺序及安全"></a> 引导顺序及安全</h2>
<ol>
<li>引导：从关机状态到将操作系统加载到内存。</li>
<li>加载分两阶段：首先加载BIOS固件中的代码，然后这程序会假爱国操作系统其余部分加载到内存，然后将控制权交给操作系统。</li>
<li><strong>问题</strong>：恶意用户可以利用引导过程的一些脆弱点来控制计算机的执行。</li>
<li><strong>解决</strong>：设置BIOS密码。</li>
</ol>
<h2 id="引导设备的层次"><a class="markdownIt-Anchor" href="#引导设备的层次"></a> 引导设备的层次</h2>
<ol>
<li>第二阶段引导程序允许用户指定使用哪个设备来加载操作系统。</li>
<li><strong>问题</strong>：攻击者可以绕过运行的计算机上的安全机制，从外部介质引导其他操作系统。</li>
<li><strong>解决</strong>：对第二阶段引导程序启动密码保护。</li>
</ol>
<h2 id="休眠"><a class="markdownIt-Anchor" href="#休眠"></a> 休眠</h2>
<ol>
<li>休眠：电源关闭的状态。当进入休眠时，操作系统将计算机内存的全部内容存储到硬盘中的休眠文件中；系统通电后，再迅速恢复计算机状态。</li>
<li><strong>问题</strong>：
<ol>
<li>攻击者可以从休眠文件中获取一些敏感信息。Windows的休眠文件目录C:/hiberfil.sys</li>
<li>攻击者可以修改休眠文件，改变计算机上执行的程序。</li>
<li>即使计算机重启后，也不会删除休眠文件。</li>
</ol>
</li>
<li><strong>解决</strong>：使用硬盘加密来保护休眠文件。</li>
</ol>
<h2 id="监控-管理和日志"><a class="markdownIt-Anchor" href="#监控-管理和日志"></a> 监控、管理和日志</h2>
<p>操作系统可以根据留下的线索解决常见的问题，还能确定出现安全漏洞的原因。</p>
<ol>
<li>事件日志：
<ol>
<li>由操作系统进行管理</li>
<li>Windows中定义了三种日记 源：系统、应用程序和安全。其中系统日志只有操作系统才能写入；应用程序日志只由应用程序写入；安全日志由操作系统提供的本地安全授予子系统服务才能写入。</li>
</ol>
</li>
<li>进程监控：查看正在运行的进程</li>
<li>进程查看器：提供进程监控和管理的大量信息。
<ol>
<li>提高进程的映像，即运行进程的代码所在的磁盘位置。</li>
<li><strong>问题</strong>：攻击者可以通过替换合法程序的映像来掩饰自身。</li>
<li><strong>解决</strong>：可以对映像使用数字签名来保证磁盘上存储的应用程序不被替换。</li>
</ol>
</li>
</ol>
<h1 id="基于密码的身份认证"><a class="markdownIt-Anchor" href="#基于密码的身份认证"></a> 基于密码的身份认证</h1>
<ol>
<li>密码盐—反字典攻击：是一种加密技术，使用随机位作为散列函数的输入或加密算法的部分输入，从而增加随机性。<br />
(U,S,h(S||P))其中S为U的盐，h是散列函数。</li>
<li>加盐的原理：增大字典攻击的搜索空间。2<sup>B×D，其中B是随机数位数，D是字典攻击单词列表。</li>
</ol>
<h1 id="访问控制"><a class="markdownIt-Anchor" href="#访问控制"></a> 访问控制</h1>
<h2 id="linux的权限"><a class="markdownIt-Anchor" href="#linux的权限"></a> Linux的权限</h2>
<ol>
<li>使用文件权限矩阵</li>
<li>对于未明确授权的都默认拒绝</li>
<li>为了访问文件，在文件系统树中的每个祖先文件夹都必须有执行权限。</li>
<li>文件所有者具有自主访问控制权，可以修改文件权限。</li>
<li>可以使用chattr设置权限，lsattr查看。</li>
<li>目前开始支持ACL方案</li>
<li>对owner, group和other主体，每个文件都有基本的ACE(<strong>访问控制项</strong>)；对于命名用户和命名组可创建额外的ACE；还有掩码ACE,即规定主体允许的最大权限</li>
</ol>
<h2 id="linux的acl权限方案"><a class="markdownIt-Anchor" href="#linux的acl权限方案"></a> Linux的ACL权限方案</h2>
<ol>
<li>设U是进程的euid，具有一定的请求权限，视图访问文件或文件夹</li>
<li>为确定是否授权，操作系统将进行匹配：
<ol>
<li>U是文件所有者的ID</li>
<li>U是命名组之一</li>
<li>U的一个组是所有组，该组的ACE包含请求权限。</li>
<li>U的一个组是命名组，该组的ACE包含请求权限。</li>
<li>对于U所在的每个组，该组的ACE都不包含请求权限。</li>
<li>检查other的ACE</li>
</ol>
</li>
</ol>
<h2 id="windows权限基础"><a class="markdownIt-Anchor" href="#windows权限基础"></a> Windows权限基础</h2>
<ol>
<li>Windows使用访问控制列表，允许用户创建访问控制规则。</li>
<li>默认是拒绝</li>
<li>标准权限包裹：读、写、修改、读和执行、完全控制。</li>
<li>读相关的高级属性：读取数据、读取属性、读取扩展属性和读取权限。</li>
<li>文件夹权限包括
<ol>
<li>读权限：可以列出文件夹内容。</li>
<li>写权限：允许用户创建新文件夹。</li>
<li>Windows下可以禁止用户访问文件夹，但允许用户访问该文件夹下的特定文件。</li>
</ol>
</li>
<li>ACE
<ol>
<li>继承ACE：文件夹的任何ACE可用于该文件夹内的子文件夹和文件。</li>
<li>显式ACE：针对文件或者文件夹专门设置的ACE。</li>
<li>ACE优先级：拒绝ACE&gt;允许ACE、显示ACE&gt;继承ACE、继承ACE优先级 由祖先与对象之间的距离决定，越近优先级越高。</li>
</ol>
</li>
</ol>
<h2 id="windows文件权限"><a class="markdownIt-Anchor" href="#windows文件权限"></a> Windows文件权限</h2>
<ol>
<li>
<p>SetUID操作：程序由普通用户运行，但期望允许程序改变普通用户无法改变的文件。</p>
<p>例如：在早期UNIX系统中，用户登录信息存储在/etc/passwd中。普通用户 不能编辑这个文件，但允许该用户更改自己的密码是合理的要求</p>
<ol>
<li>设置了setuid位，使得程序以其所有者的有效ID来运行，而不是以正在执行程序的进程ID。</li>
<li><strong>问题</strong>
<ol>
<li>攻击者可以强制setuid程序执行任意代码，如缓冲区溢出攻击。</li>
<li>权限升级：攻击者可以通过setuid机制来运用程序的所有者权限。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>文件描述符：存储在文件描述符表中的索引值，用来索引特定文件</p>
<ol>
<li>当程序需要访问文件时，访问open系统调用，该调用使内核创建一个文件 描述符表中的新项并将其返回给程序，该项映射到文件的磁盘位置。程序可以使用文件描述符发送读或者写命令。内核在接到读、写系统调用时， 在文件描述符表中查找相关的表项，并在磁盘适当位置执行读、写操作。完成操作后，要用close系统调用删除打开的文件描述符。</li>
<li><strong>漏洞</strong> 当进程创建子进程时，子进程会集成父进程打开的所有文 件描述符副本。当程序以高权限打开文件描述符，但未关闭，然后又创建了 低权限的进程，那么新进程就能够读写相关文件，但子进程本身不具有打开 该文件的权限。</li>
<li><strong>原因</strong> 在创建文件描述符项的时刻，操作 系统只检查进程是否具有读写权限；在实际读写文件操作时，只根据文件描 述符被打开时的权限来确认是否允许请求的操作。</li>
</ol>
</li>
<li>
<p>符号链接与快捷方式</p>
<ol>
<li><strong>问题</strong> 攻击者可以利用符号链接来诱使应用程序执行不良操作。</li>
<li><strong>解决</strong> 程序检查文件名是否指向符号链接，以确定打开的实际文件名。</li>
<li>Windows的快捷方式&amp;Linux的符号链接：符号链接由操作系统处 理，使用透明；而快捷方式是普通文件。</li>
</ol>
</li>
</ol>
<h1 id="应用程序安全"><a class="markdownIt-Anchor" href="#应用程序安全"></a> 应用程序安全</h1>
<h2 id="编译和链接"><a class="markdownIt-Anchor" href="#编译和链接"></a> 编译和链接</h2>
<ol>
<li>编译：将源代码转换为处理器能够执行的机器代码的过程</li>
<li>静态链接：程序执行时所需的共享库需要复制到编译程序中。一般比较安全， 但重复代码会占用额外的空间。</li>
<li>动态链接：程序真正运行时，才会加载共享库。加载程序确定待运行程序需 要哪些共享库，然后在磁盘上找到这些库，并将它们导入进程的地址空间。
<ol>
<li><strong>DDL注入</strong>：通过共享库向程序注入任意代码的过程。<strong>优点</strong> 是便于调试，<strong>缺点</strong> 是潜在的安全风险，恶意用户能向合法程序注入自己的代码。</li>
</ol>
</li>
</ol>
<h2 id="简单的缓冲区溢出攻击"><a class="markdownIt-Anchor" href="#简单的缓冲区溢出攻击"></a> 简单的缓冲区溢出攻击</h2>
<ol>
<li>缓冲区：进程为程序在内存中分配固定大小的存储空间。</li>
<li>缓冲区溢出：如果不进行边界检查，攻击者提供的输入数据可能会超出缓冲 区的大小。此时，内存缓冲区之外的数据可能会被覆盖。</li>
<li><strong>问题</strong> 攻击者利用缓冲区溢出获得进程的控制权，执行任意恶意代码。</li>
</ol>
<h2 id="基于栈的缓冲区溢出"><a class="markdownIt-Anchor" href="#基于栈的缓冲区溢出"></a> 基于栈的缓冲区溢出</h2>
<ol>
<li>进程地址空间中栈由帧组成，每一帧存储局部变量、调用参数和返回地址。</li>
<li><strong>问题</strong> 如果攻击者提供的输入大于调用函数中缓冲区的大小，会导致溢出，从而导致栈缓冲区之外 的内存空间被覆盖。</li>
<li>缓冲区溢出攻击：当缓冲区是局部变量 或帧的参数时，用户的输入 可能覆盖返回地址，改变程 序的执行。
<ol>
<li><strong>问题</strong> 攻击者利用栈缓冲区的脆弱 性，在栈中注入恶意代码， 覆盖当前调用的返回地址， 从而将执行权限传递给攻击 者的恶意代码。</li>
<li>实际攻击中，攻击者需要猜测缓冲区返回地址的位置，并确定用什么地址覆盖返回地址。难点在于：
<ol>
<li>进程不能访问其他进程的地址空间，因此恶意代码必须驻留在被攻击进 程的地址空间内。一般驻留在缓冲区中或者在用户的Shell环境中。</li>
<li>给定进程的地址空间是不可预测的，程序在不同计算机上执行时，地址 空间可能发生改变。</li>
<li>为了克服以上困难，攻击者可以采取的相关技术有：NOP指令滑动(NOP sledding)、返回到libc(return-to-libc)、跳转到寄存器(jump-to-register)或蹦 床(Trampolining)技术</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="缓冲区溢出攻击相关技术"><a class="markdownIt-Anchor" href="#缓冲区溢出攻击相关技术"></a> 缓冲区溢出攻击相关技术</h2>
<ol>
<li>
<p>NOP指令滑动:通过命中一串连续的NOP指令，从而使CPU指令执行流一直滑动到特定位 置来执行恶意代码。</p>
<ol>
<li>由于进程地址空间难以预测，所以通过一连串的NOP指令，只要有一个命中就能执行恶意代码。</li>
</ol>
</li>
<li>
<p>跳转到寄存器：在初始化时，大多数进程需要将外部库的内容加载到自己的地址空间。操作 系统一般将这些外部库加载到内存预留段的进程地址空间中。因此，外部库 在内存中的位置是可预测的。攻击者利用这些外部库的知识进行跳转攻击：</p>
<ol>
<li>攻击者找到特定代码集中 的跳转指令，如jump ESP；</li>
<li>攻击者设法把恶意代码放在ESP寄存器指定 的内存地址上；</li>
<li>攻击者将当前函数的返回地址重写为jump指令的地址；</li>
<li>函数返回时将执行jump指令，并跳转执行恶意代码；</li>
</ol>
</li>
<li>
<p>返回到libc攻击：攻击者确定脆弱进程的地址空间内C库函数的地址，如system()或execv的 地址，并使用这些信息强制进程调用该函数。</p>
<ol>
<li>攻击者首先让缓冲区溢出，并用所需库函数的地址覆盖返回地址，并传递重 新设定好的参数使其能够按攻击者的期望运行。</li>
<li>这种攻击方式在实现攻击的同时，也避开了数据执行保护策略中对攻击代码 的注入和执行所采取的的防护措施。Return-to-libc 攻击不需要注入新的恶意代码，而是重用漏洞程序中已有的 函数完成攻击，让漏洞程序跳转到已有的代码序列。</li>
</ol>
</li>
</ol>
<h2 id="防止基于栈的缓冲区溢出攻击"><a class="markdownIt-Anchor" href="#防止基于栈的缓冲区溢出攻击"></a> 防止基于栈的缓冲区溢出攻击</h2>
<ol>
<li>规范C语言编程</li>
<li>使用更安全的函数</li>
<li>操作系统也提供保护措施，如防止攻击者覆盖返回地址；使用金丝雀技术。</li>
</ol>
<h3 id="防止攻击者覆盖返回值地址"><a class="markdownIt-Anchor" href="#防止攻击者覆盖返回值地址"></a> 防止攻击者覆盖返回值地址</h3>
<ol>
<li>在所有指针使用前后都进行异或编码</li>
<li>将内存的栈空间设置为非执行权限</li>
<li>地址空间布局随机化，随机地重新安排地址空间的数据，使得攻击者难以预测。</li>
</ol>
<h3 id="金丝雀预警技术"><a class="markdownIt-Anchor" href="#金丝雀预警技术"></a> 金丝雀预警技术</h3>
<p>重新组织分配程序的堆栈数据，使用一个canary值，并将此值放在缓冲区和 控制数据之间。系统定期检查canary值的完整性。如果此值被更改，表明缓 冲区溢出，就要防止恶意代码的执行。</p>
<h2 id="基于堆的缓冲区溢出"><a class="markdownIt-Anchor" href="#基于堆的缓冲区溢出"></a> 基于堆的缓冲区溢出</h2>
<p><strong>问题</strong> 如果在堆上显示分配了内存，但没有释放，会导致内存泄漏问题。</p>
<p><strong>攻击</strong> 攻击者一般通过修改堆中的数据 或者滥用管理堆内存的函数和宏 来执行恶意代码。</p>
<ol>
<li>如果攻击者向程序提供输入，而程序以不安全的方式将其复制到堆中的内存 块中。那么攻击者可以使数据溢出块的边界，并覆盖下一个内存块。通过精心设计，攻击者会覆盖下一个内存块的链表指针，并将该内存块标记 为空闲。此时，unlink例程可以向内存地址空间中的任意地址写入数据。如 果写入的数据是恶意代码的存储位置，会导致程序跳转并执行恶意代码。</li>
</ol>
<h2 id="防御基于堆的缓冲区溢出"><a class="markdownIt-Anchor" href="#防御基于堆的缓冲区溢出"></a> 防御基于堆的缓冲区溢出</h2>
<p>如安全编程、地址空间随机化、设置堆数据不可执 行、将存储堆内存的指针数据和存储堆中的实际数据相分离。</p>
<h1 id="格式化字符串攻击"><a class="markdownIt-Anchor" href="#格式化字符串攻击"></a> 格式化字符串攻击</h1>
<p><strong>攻击</strong> 攻击者可以精心指定所使用的格式化字符串作为输入，并可以将输入写入内 存的任意位置。如果写入的位置正好覆盖了返回地址、函数指针等，则攻击 者能够取得控制权，并在程序的上下文中执行任意代码。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导第10章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC10%E7%AB%A0/"
    >计安导第10章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC10%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.478Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="数据库安全"><a class="markdownIt-Anchor" href="#数据库安全"></a> 数据库安全</h1>
<h2 id="两阶段协议实现完整性和可用性"><a class="markdownIt-Anchor" href="#两阶段协议实现完整性和可用性"></a> 两阶段协议–实现完整性和可用性</h2>
<ol>
<li>第一阶段是请求阶段：
<ol>
<li>该阶段，确定所要修改的部分，并标记。</li>
<li>结果是成功或终止。在成功时，每个修改请求都是可 用的，标记被修改；在中止时，由于别人早已对其进行了标记，或者 由于网络或系统出现了故障，所以不能标记所有需要修改的部分。</li>
<li>如果第一阶段被中止，则重置所有修改的请求，这样做是完全可行 的，因为并未进行任何永久性的修改。如果第一阶段成功完成，则协议继续第二个阶段。</li>
</ol>
</li>
<li>第二阶段是提交阶段
<ol>
<li>在这个阶段，对于其他 修改而言，数据库是锁定的，只执行在请求阶段确定的修改序列。</li>
<li>如果更新成功完成，则清除所有确定请求修改的标志，并释放对数据库的锁定。</li>
<li>如果更新操作失败，则回滚，使数据库回到完成第一 阶段后的状态。</li>
</ol>
</li>
</ol>
<h2 id="数据库访问控制"><a class="markdownIt-Anchor" href="#数据库访问控制"></a> 数据库访问控制</h2>
<ol>
<li>
<p><strong>最小特权原则</strong>：实现适当的访问控制应遵 循最小特权原则，使每个用户都拥有完成自己任务所必需的权限，但 除此之外，不再拥有其他的权限</p>
</li>
<li>
<p><strong>特权分离原则</strong>：实现适当的访问控 制还应遵循特权分离原则，以便不同的用户具有不同的权限，这取决 于他们需要执行的不同任务</p>
</li>
<li>
<p>数据库允许SQL实现权限委托</p>
</li>
<li>
<p>权限委托：除了能向其他用户授予具体的权限外，表的所有者还允许其他用户来授予 这些表的权限，这称为策略授权委托</p>
</li>
<li>
<p>权限撤销：级联撤销</p>
</li>
</ol>
<h2 id="敏感信息"><a class="markdownIt-Anchor" href="#敏感信息"></a> 敏感信息</h2>
<p>1.要保护用户因素，满足机密性要求<br />
2. 方法：使用加密，存储密文。授权用户直到解密密钥，但不能将解密密钥存储在数据库中。<br />
3. 隐私保护：如果数据库是公开的，比如说是出于研究的目的，则应删除姓名、地址、 社会安全码、员工人数和学生人数等身份信息，或改用掩码值 ，从而不提供任何身份信息。</p>
<h2 id="推理攻击"><a class="markdownIt-Anchor" href="#推理攻击"></a> 推理攻击</h2>
<ol>
<li>
<p>推理攻击：即使删除或屏蔽掉身份信息，攻击者仍能将其他的信息与数据库结合，得到底层的数据。</p>
</li>
<li>
<p>推理攻击的防御：</p>
<ol>
<li>单元抑制：在使用这种技术时，会删除数据库 中的一些单元，在公开版本中只留下空白。</li>
<li>推广：在使用这种技术时，公开数据库中的一些 值被更常用的值所替代。</li>
<li>加噪：在使用这种技术时，在公开数据库中添加 了随机值，使具有相同属性的所有记录的平均噪声为零。</li>
</ol>
 <img src="/计安导_img/27.png">
</li>
</ol>
<h1 id="垃圾邮件和网络犯罪"><a class="markdownIt-Anchor" href="#垃圾邮件和网络犯罪"></a> 垃圾邮件和网络犯罪</h1>
<h2 id="smtp"><a class="markdownIt-Anchor" href="#smtp"></a> SMTP</h2>
<ol>
<li>使用25端口建立TCP连接</li>
<li>客户端向服务器发送命令，服务器确认或通知错误</li>
<li><strong>问题</strong>
<ol>
<li>发件人未经过身份验证</li>
<li>消息和消息头使用明文传输</li>
<li>消息和消息头完整性没有得到保护</li>
</ol>
</li>
</ol>
<h2 id="垃圾邮件"><a class="markdownIt-Anchor" href="#垃圾邮件"></a> 垃圾邮件</h2>
<ol>
<li>垃圾邮件：不清自来的批量电子邮件</li>
</ol>
<h2 id="黑名单"><a class="markdownIt-Anchor" href="#黑名单"></a> 黑名单</h2>
<img src="/计安导_img/28.png">
<h2 id="灰名单"><a class="markdownIt-Anchor" href="#灰名单"></a> 灰名单</h2>
<ol>
<li>灰名单：是一种垃圾邮件过滤技术，接收邮件服务器拒绝来自未知发 件人的邮件。当接收来自未知发件人的邮件时，接收服务器会发送一 个“临时拒绝”消息给发送方，并记录相应的信息。</li>
<li>维护一个可信发件服务器的数据库</li>
<li>简单易行高效</li>
</ol>
<h2 id="发件人id和发件人策略框架"><a class="markdownIt-Anchor" href="#发件人id和发件人策略框架"></a> 发件人ID和发件人策略框架</h2>
<ol>
<li>发件人策略框架(SPF)可对发件人的发送邮 件代理进行身份验证，其中不使用加密 技术。接收方MTA会检查发送方MTA的IP是否在发件人域的授权IP 地址列表中。</li>
</ol>
<h2 id="发件人的mta身份验证dkim"><a class="markdownIt-Anchor" href="#发件人的mta身份验证dkim"></a> 发件人的MTA身份验证：DKIM</h2>
<ol>
<li>域密钥标识邮件DKIM：是一种用于验证发送邮件传输代理的方法</li>
<li>签名实体(通常是发件人的MTA) 向消息中增加签名， 表明消息的签名实体所在的域</li>
<li>公钥存储在DNS的文本记录中</li>
</ol>
<h2 id="spf-vs-dkim"><a class="markdownIt-Anchor" href="#spf-vs-dkim"></a> SPF vs DKIM</h2>
<img src="/计安导_img/29.png">
<h2 id="网络犯罪"><a class="markdownIt-Anchor" href="#网络犯罪"></a> 网络犯罪</h2>
<ol>
<li>网络犯罪：是使用计算机、网络或硬件设备犯下的任何罪行。 计算机或 设备可以是犯罪的代理人，犯罪的促进者或犯罪的目标。 犯罪可以 单独在计算机上进行，也可以在其他地方进行</li>
</ol>
<h2 id="信用卡"><a class="markdownIt-Anchor" href="#信用卡"></a> 信用卡</h2>
<ol>
<li>
<p>特点</p>
<ol>
<li>支持保密</li>
<li>可与多个商家共享</li>
<li>经常被不安全的传送</li>
<li>熵值较低</li>
</ol>
</li>
<li>
<p>优点：简单易行</p>
</li>
<li>
<p>缺点：易发生欺诈</p>
</li>
<li>
<p>防范：</p>
<ol>
<li>一次性信用卡号码</li>
<li>监控交易</li>
<li>交易时启动密码输入</li>
</ol>
</li>
</ol>
<h2 id="常见银行欺诈"><a class="markdownIt-Anchor" href="#常见银行欺诈"></a> 常见银行欺诈</h2>
<ol>
<li>伪造支票</li>
<li>电子汇款</li>
<li>创建恶意账户</li>
<li>多重身份认证</li>
<li>账户所有权验证</li>
<li>账户限制</li>
<li>监控银行交易</li>
<li>取消网银</li>
</ol>
<h1 id="支付系统"><a class="markdownIt-Anchor" href="#支付系统"></a> 支付系统</h1>
<h2 id="电子支付方案"><a class="markdownIt-Anchor" href="#电子支付方案"></a> 电子支付方案</h2>
<ol>
<li>是一种多方协议</li>
<li>目标：
<ol>
<li>完整性：电子货币不能伪造或复制；合法交易能够兑现</li>
<li>问责制：交易后不可否认</li>
<li>隐私</li>
</ol>
</li>
</ol>
<h2 id="私密支付方案"><a class="markdownIt-Anchor" href="#私密支付方案"></a> 私密支付方案</h2>
<h3 id="盲签名"><a class="markdownIt-Anchor" href="#盲签名"></a> 盲签名</h3>
<ol>
<li>
<p>允许签名者在不知道消息本身的情况下对消息进行签名</p>
</li>
<li>
<p>基本过程</p>
<ol>
<li>银行对客户提取的货币进行盲签名</li>
<li>商家验证签名并存入货币</li>
<li>银行无法将货币与客户关联起来</li>
</ol>
</li>
<li>
<p>RSA 盲签名</p>
 <img src="/计安导_img/30.png">
 <img src="/计安导_img/31.png">
</li>
<li>
<p>对钱币进行盲签名</p>
 <img src="/计安导_img/32.png">
</li>
</ol>
<h2 id="防止双重支付"><a class="markdownIt-Anchor" href="#防止双重支付"></a> 防止双重支付</h2>
<ol>
<li>联机系统：在支付过程中，银行保持在线，实时撤销已使用的钱币</li>
<li>离线系统：
<ol>
<li>每个提款的钱币都包含客户身份的加密信息</li>
<li>每个存款的钱币都包含商家身份的加密信息</li>
<li>双重支付将导致欺骗者的身份被披露出来</li>
</ol>
</li>
</ol>
<h2 id="秘密分享"><a class="markdownIt-Anchor" href="#秘密分享"></a> 秘密分享</h2>
<p>步骤</p>
<ol>
<li>一个秘密字符串 x 可以被划分为以下的随机值 y 和 z。选择一个随机数 y ；z = y⊕x</li>
<li>通过x = y⊕z重构字符串x</li>
<li>其中y和z都是随机值，成为x的秘密份额，任一秘密份额都不会揭示关于秘密值 x 的任何信息</li>
</ol>
<h2 id="钱币保护匿名性"><a class="markdownIt-Anchor" href="#钱币保护匿名性"></a> 钱币–保护匿名性</h2>
<ol>
<li>给定一个秘密值x和关于x的承诺(a,b)</li>
<li>a=h(y) b=h(z) y,z是x的秘密份额</li>
</ol>
<h2 id="取款"><a class="markdownIt-Anchor" href="#取款"></a> 取款</h2>
<ol>
<li>客户生成并向银行提交 k 个钱币</li>
<li>银行随机选择 k-1 枚钱币</li>
<li>银行要求客户向其披露所选定的 k-1 个钱币的承诺的秘密份额</li>
<li>银行在剩余的硬币上创建一个盲签名</li>
<li>银行签名的钱币是有效的概率是 1 - 1/k</li>
</ol>
<h2 id="支付"><a class="markdownIt-Anchor" href="#支付"></a> 支付</h2>
<ol>
<li>
<p>客户向商家提交钱币 {x, [(a1, b2) , … , (an, bn)]}</p>
</li>
<li>
<p>商家验证钱币上的签名</p>
</li>
<li>
<p>商家发送给客户一个随机的二进制向量 s1, … , sn, 称为选择器。</p>
</li>
<li>
<p>客户向商家揭示由选择器所选定的秘密份额，即客户向商家发送 一组字符串 P1, … , Pn</p>
<p>h(Pi) = ai if si = 0</p>
<p>h(Pi) = bi if si= 1</p>
</li>
</ol>
<h2 id="存款及其安全性分析"><a class="markdownIt-Anchor" href="#存款及其安全性分析"></a> 存款及其安全性分析</h2>
<ol>
<li>
<p>存款</p>
<ol>
<li>商人将钱币和字符串 P1, … , Pn提交给银行进行存款</li>
<li>银行验证签名并且记录钱币和相应字符串的对应关系</li>
</ol>
</li>
<li>
<p>安全性分析</p>
<ol>
<li>两个商家提供的选择器相同的概率是 1/2<sup>n</sup></li>
<li>因此，如果客户将1个钱币进行双重支付，那么银行发现该客户 身份的概率为 1/2<sup>n</sup></li>
<li>客户想要在不被银行发现的情况进行双重支付的唯一办法是找到 一个Hash函数的碰撞。</li>
</ol>
</li>
</ol>
<h1 id="数字版权管理"><a class="markdownIt-Anchor" href="#数字版权管理"></a> 数字版权管理</h1>
<ol>
<li>数字版权管理：是指能限制用户 使用数字内容的做法，常用于数字媒体，如DVD、下载的音乐和 许可的软件</li>
</ol>
<h2 id="复制保护方法"><a class="markdownIt-Anchor" href="#复制保护方法"></a> 复制保护方法</h2>
<ol>
<li>加密狗</li>
<li>产品密钥</li>
<li>手机激活</li>
</ol>
<h2 id="用于媒体文件的drm方案"><a class="markdownIt-Anchor" href="#用于媒体文件的drm方案"></a> 用于媒体文件的DRM方案</h2>
<p>步骤</p>
<ol>
<li>媒体服务器向播放器发送用文件密钥加密的媒体文件和用播放器密钥加密的文件密钥</li>
<li>播放器先用播放器密 钥解密文件密钥，然 后使用文件密钥解密 媒体文件</li>
</ol>
<h2 id="叛徒识别"><a class="markdownIt-Anchor" href="#叛徒识别"></a> 叛徒识别</h2>
<p><img src="/%E8%AE%A1%E5%AE%89%E5%AF%BC_img/33.png" alt="" /></p>
<h2 id="逻辑密钥对"><a class="markdownIt-Anchor" href="#逻辑密钥对"></a> 逻辑密钥对</h2>
<p><img src="/%E8%AE%A1%E5%AE%89%E5%AF%BC_img/34.png" alt="" /></p>
<ol>
<li>是平衡二叉树，树的每个节点都与一个对称加密密钥相关联</li>
<li>将设备与叶子节点关联，每个设备上存储着从叶子到根路径上的所有密钥</li>
<li>用节点 v 的密钥加密的内容可以被 v 的子树中的所有设备解密</li>
<li>撤销设备：如果设备需要被撤销，则必须更改此设备已知的密钥，并分发新的密钥。新密钥的分发可以通过广播对数级数量的加密消息来完成</li>
</ol>
<h2 id="加密广播"><a class="markdownIt-Anchor" href="#加密广播"></a> 加密广播</h2>
<ol>
<li>广播之前，每个内容都用单一的对称密钥进行加密。被授权产看内容项的订阅者应该拥有解密该项的密钥</li>
<li>每个节点的密钥可以被用来计算子孙节点的密钥</li>
<li>存在密钥分配问题</li>
</ol>
<h2 id="可信设备"><a class="markdownIt-Anchor" href="#可信设备"></a> 可信设备</h2>
<ol>
<li>由可信制造商加工，被分配一个保密的播放器密钥</li>
</ol>
<h2 id="内容扰乱系统css"><a class="markdownIt-Anchor" href="#内容扰乱系统css"></a> 内容扰乱系统CSS</h2>
<p><img src="/%E8%AE%A1%E5%AE%89%E5%AF%BC_img/35.png" alt="" /></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导第8章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC8%E7%AB%A0/"
    >计安导第8章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC8%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.478Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="密码学基础"><a class="markdownIt-Anchor" href="#密码学基础"></a> 密码学基础</h1>
<h2 id="基本符号"><a class="markdownIt-Anchor" href="#基本符号"></a> 基本符号</h2>
<ol>
<li>密钥 K</li>
<li>加密算法 E<sub>K</sub>§ = C</li>
<li>解密算法 D<sub>K</sub>©	= M</li>
</ol>
<h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2>
<ol>
<li>密文长度通常和明文长度相同</li>
<li>加密/解密是所有n位二进制序列构成的集合上的 (双射)置换函数。加密算法EK§和解密算法DK©必须是高效的。</li>
<li>对密文解密后可恢复出明文，即D<sub>K</sub>(E<sub>K</sub>§)=P</li>
</ol>
<h1 id="对称加密"><a class="markdownIt-Anchor" href="#对称加密"></a> 对称加密</h1>
<p>加密和解密使用同一个密钥</p>
<h2 id="攻击者主要类型"><a class="markdownIt-Anchor" href="#攻击者主要类型"></a> 攻击者主要类型</h2>
<ol>
<li>唯密文攻击：攻击者收集一个或多个消息的密文。且这些消息都使用相同的密钥K加密。攻击者的目标是根据一个或多个密文来确定明文，或者找到密钥K。</li>
<li>已知明文攻击：攻击者收集一个或多个明文-密文对。且每个这样的对都使用相同的密钥K加密。攻击者目标是确定密钥K。</li>
<li>选择明文攻击: 攻击者可收集指定的明文对应的密文信息。且这些明文都使用相同的密钥K。 目的在于破解密钥K。</li>
<li>选择密文攻击：攻击者可收集指定的密文 对应的明文信息。且这些明文都使用相同的密钥K。 目的在于破解密钥K。</li>
<li>穷举攻击：穷举可能的密钥，直到能把密文转换称有意义的明文。需要了解明文结构且密钥不长。</li>
</ol>
<h2 id="英文文本的唯一解距离计算"><a class="markdownIt-Anchor" href="#英文文本的唯一解距离计算"></a> 英文文本的唯一解距离计算</h2>
<p>已知英文文本的信息熵为1.25bits，共t个字符，每个字符由8位二进制数的ASCII码表示。</p>
<img src="/计安导_img/9.png">
<img src="/计安导_img/10.png">
<h2 id="替换密码"><a class="markdownIt-Anchor" href="#替换密码"></a> 替换密码</h2>
<p>每个字母用不同的独一无二的其他字符替代。存在26!个可能的替换密码。存在4.03×1026个可能的密文。</p>
<h3 id="主要弱点"><a class="markdownIt-Anchor" href="#主要弱点"></a> 主要弱点</h3>
<p>他们不隐藏明文中不同字母的基本频率。</p>
<h3 id="多字母替换密码和替换盒"><a class="markdownIt-Anchor" href="#多字母替换密码和替换盒"></a> 多字母替换密码和替换盒</h3>
<ol>
<li>
<p>多字母替换密码：对字母组进行替换。由26<sup>2</sup> = 676种可能的组合。会产生676!个可能的密钥</p>
</li>
<li>
<p>问题 导致密钥太长，需要保存所有替换组合密码。</p>
</li>
<li>
<p>替换盒(S-盒)：一张二维表，交叉处为相应的替换。</p>
 <img src="/计安导_img/11.png">
</li>
</ol>
<h3 id="频率分析"><a class="markdownIt-Anchor" href="#频率分析"></a> 频率分析</h3>
<p>对字母频率的分析是针对替换密码的有效攻击手段</p>
<h3 id="一次一密"><a class="markdownIt-Anchor" href="#一次一密"></a> 一次一密</h3>
<p>绝对牢不可破的替换密码</p>
<ol>
<li>使用密钥块(k1, k2, . . . , kn)来加密长度为n的明文M，每个密钥ki都是均匀随机生成的。由于每次都是完全随机地选择移动量，在密文中字母表的每 个字母出现的概率几乎相同</li>
<li>弱点：
<ol>
<li>密钥块的长度m必须和明文的 长度n相同</li>
<li>密钥不可以被重用。而事实是密钥很可能被用完，当重用密钥时，安全性会大大降低。</li>
</ol>
</li>
</ol>
<h2 id="分组密码"><a class="markdownIt-Anchor" href="#分组密码"></a> 分组密码</h2>
<p>每条消息被划分成一系列的块，基于这些数据块来进行加密或解密。</p>
<h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3>
<ol>
<li>明文和密文具有固定的长度b</li>
<li>长度为 n 的明文被划分为 m 个序列块 P[0], …, P[m-1]（n ≤ bm＜ n + b）</li>
</ol>
<h3 id="填充要求"><a class="markdownIt-Anchor" href="#填充要求"></a> 填充要求</h3>
<p>分组密码要求明文长度n应该为块长度b的倍数，所以最后一个块特殊。对最后一个数据块的填充必须是明确的（不能只是填充0）。要求</p>
<ol>
<li>当块大小和明文长度是8的倍数时，一种常用的填充方法（PKCS5） 是一组相同的字节，每个字节都表示填充的长度（以字节为单位）</li>
</ol>
<img src="/计安导_img/12.png"> 
<p>意思貌似是要填充9个字节，所以用9来填充。</p>
<h2 id="实际使用的分组密码"><a class="markdownIt-Anchor" href="#实际使用的分组密码"></a> 实际使用的分组密码</h2>
<h3 id="aes-高级加密标准"><a class="markdownIt-Anchor" href="#aes-高级加密标准"></a> AES 高级加密标准</h3>
<ol>
<li>每组128位，所采用的密钥长度为128、192或者256 位，所得到的密码称为AES-128、AES-192和AES-256。</li>
<li>AES轮结构</li>
</ol>
<img src="/计安导_img/13.png"> 
<p>10轮异或之后得到密文。</p>
<ol>
<li>SubBytes步骤：S-盒替换步骤</li>
<li>ShiftRows步骤：置换步骤</li>
<li>MixColumns步骤：矩阵乘法（希尔密码）步骤</li>
<li>AddRoundKey步骤：使用从128位密钥派生的轮密钥的XOR步骤</li>
</ol>
<h3 id="数据加密标准des"><a class="markdownIt-Anchor" href="#数据加密标准des"></a> 数据加密标准（DES）</h3>
<h3 id="三重des-3des"><a class="markdownIt-Anchor" href="#三重des-3des"></a> 三重DES （3DES）</h3>
<h2 id="分组密码的操作模式"><a class="markdownIt-Anchor" href="#分组密码的操作模式"></a> 分组密码的操作模式</h2>
<h3 id="电子密码本模式-ecb"><a class="markdownIt-Anchor" href="#电子密码本模式-ecb"></a> 电子密码本模式 	ECB</h3>
<ol>
<li>明文块 P[i] 加密成密文块 C[i] = EK( P[i] )；密文块 C[i] 解密成明文块 M[i] = DK( C[i] )</li>
<li>优点 可以容忍分组丢失。因为解密i分组与i-1分组无关。</li>
<li>缺点
<ol>
<li>如果加密算法是完全确定的，比如使用AES，那么每个明文都与唯一的密文相关联。对于很长的消息，ECB模式可能会解释分组流中出现的模式。</li>
<li>适用于短报文，如<strong>密钥和初始向量的加密</strong></li>
</ol>
</li>
</ol>
<h3 id="密码分组链接模式cbc"><a class="markdownIt-Anchor" href="#密码分组链接模式cbc"></a> 密码分组链接模式	CBC</h3>
<p>是最常用的模式之一</p>
<img src="/计安导_img/14.png"> 
<ol>
<li>
<p>加密 C[i] = EK(C[i-1] ⊕ P[i])</p>
<p>C[-1] = V， 一个单独传输的随机加密数据块将作为初始化向量</p>
</li>
<li>
<p>解密 P[i] = C[i-1] ⊕DK(C[i])</p>
</li>
<li>
<p>优点</p>
<ol>
<li>没有在明文中泄露明文的模式</li>
<li>快速而简单</li>
</ol>
</li>
<li>
<p>缺点</p>
<ol>
<li>需要所有数据进行有序可靠的传输</li>
<li>不适用于允许丢包的应用，如音频流、视频流</li>
</ol>
</li>
</ol>
<h3 id="密码反馈模式-cfb"><a class="markdownIt-Anchor" href="#密码反馈模式-cfb"></a> 密码反馈模式 CFB</h3>
<h3 id="输出反馈模式-ofb"><a class="markdownIt-Anchor" href="#输出反馈模式-ofb"></a> 输出反馈模式 OFB</h3>
<h2 id="流密码"><a class="markdownIt-Anchor" href="#流密码"></a> 流密码</h2>
<h3 id="密钥流"><a class="markdownIt-Anchor" href="#密钥流"></a> 密钥流</h3>
<p>是一组伪随机序列S = S[0], S[1], S[2], …… ；每次生成1位或者1个字节。</p>
<h3 id="流密码-2"><a class="markdownIt-Anchor" href="#流密码-2"></a> 流密码</h3>
<p>密钥流和明文流进行对位异或操作 C[i] = S[i]⊕P[i]</p>
<h3 id="同步流密码"><a class="markdownIt-Anchor" href="#同步流密码"></a> 同步流密码</h3>
<ol>
<li>密钥流的生成只依靠密钥K</li>
<li>如果明文是带有序列号的包，同步流密码可在不可靠信道下工作。</li>
</ol>
<h3 id="自同步流密码"><a class="markdownIt-Anchor" href="#自同步流密码"></a> 自同步流密码</h3>
<ol>
<li>使用密钥K和前q个密文来生成密钥流</li>
<li>在接收到q个密文后自动与密钥流生成器同步，如果数字被丢弃或添加到明文流中，更容易恢复。</li>
<li>自同步：因解码当前文字只依赖于固定个数的之前的密文字。所以仅有确定数量的明文字符不可被恢复。</li>
</ol>
<h3 id="rc4-流密码与密钥流生成器"><a class="markdownIt-Anchor" href="#rc4-流密码与密钥流生成器"></a> RC4 流密码与密钥流生成器</h3>
<ol>
<li>最多可以使用2048位的密钥</li>
<li>使用块大小为b的数据块</li>
<li>使用一个密钥对(K, t), K为密钥，计数器t是一个b位的值</li>
<li>密钥流由下列密文块连接而成: E<sub>K</sub>(t), E<sub>K</sub>(t+1), E<sub>K</sub>(t+2), ……</li>
</ol>
<h2 id="针对流密码的攻击"><a class="markdownIt-Anchor" href="#针对流密码的攻击"></a> 针对流密码的攻击</h2>
<h3 id="重试攻击"><a class="markdownIt-Anchor" href="#重试攻击"></a> 重试攻击</h3>
<p>如果密钥流被重用，那么攻击者可获得两个明文的异或值</p>
<h3 id="插入攻击"><a class="markdownIt-Anchor" href="#插入攻击"></a> 插入攻击</h3>
<p>将由攻击者选定的字节插入到消息流中，并使用相同的密钥流进行加密</p>
<h1 id="公钥加密"><a class="markdownIt-Anchor" href="#公钥加密"></a> 公钥加密</h1>
<h2 id="数论基础"><a class="markdownIt-Anchor" href="#数论基础"></a> 数论基础</h2>
<h3 id="素数-只能被1和他自身整除"><a class="markdownIt-Anchor" href="#素数-只能被1和他自身整除"></a> 素数 只能被1和他自身整除。</h3>
<ol>
<li>正整数n可以写成若干个素数的某次幂的乘积。如200=2<sup>3</sup>×5<sup>2</sup></li>
<li>算术基本定理：一个正整数的素数分解是唯一的</li>
</ol>
<h3 id="互质-两个数的最大公约数为1"><a class="markdownIt-Anchor" href="#互质-两个数的最大公约数为1"></a> 互质 两个数的最大公约数为1</h3>
<h3 id="辗转相除法-用于计算两个正整数的最大公约数"><a class="markdownIt-Anchor" href="#辗转相除法-用于计算两个正整数的最大公约数"></a> 辗转相除法 用于计算两个正整数的最大公约数</h3>
<ol>
<li>
<p>gcd(a, b) = gcd(b, a mod b)</p>
</li>
<li>
<p>算法最大迭代次数为1+2log max(a,b)</p>
<p>复杂度 O(log min(a,b))</p>
<p>gcd(412,260)=4</p>
 <img src="/计安导_img/15.png">
</li>
</ol>
<h3 id="乘法逆元"><a class="markdownIt-Anchor" href="#乘法逆元"></a> 乘法逆元</h3>
<ol>
<li>
<p>xy mod n = 1, 则称 y 是 x 在 Zn的乘法逆元，记作 y = x - 1</p>
 <img src="/计安导_img/16.png">
</li>
<li>
<p>定理：Zn中的元素 x 有乘法逆元当且仅当 x 和 n 互素。</p>
</li>
<li>
<p>定理：a存在模b的乘法逆元的充要条件是gcd（a,b）= 1</p>
</li>
<li>
<p>定理：如果p是素数，那么Zp上的非0剩余类都有乘法逆元</p>
</li>
<li>
<p>定理：欧几里得算法可以用来计算 Zn 中元素 x 的乘法逆元或者确定该元素是否存在乘法逆元</p>
</li>
</ol>
<h3 id="费马小定理"><a class="markdownIt-Anchor" href="#费马小定理"></a> 费马小定理</h3>
<ol>
<li>
<p>若 p 是素数，x 是正整数且不能被 p 整除，则 x<sup>p-1</sup> mod p = 1</p>
 <img src="/计安导_img/17.png">
</li>
<li>
<p>若 p 是素数，x 是正整数且不能被 p 整除，x的乘法逆元是 xp<sup>p-2</sup> mod p</p>
</li>
</ol>
<h3 id="欧拉定理"><a class="markdownIt-Anchor" href="#欧拉定理"></a> 欧拉定理</h3>
<ol>
<li>欧拉函数  Φ(n)指的是小于n且与n互素的正整数个数。Φ(1) = 1。 当p为素数时，Φ(p - 1) = p</li>
<li>欧拉定理：对任意互素的x和n，有 x<sup>Φ(n)</sup> mod n = 1</li>
</ol>
<img src="/计安导_img/18.png">
<h2 id="rsa-密码系统"><a class="markdownIt-Anchor" href="#rsa-密码系统"></a> RSA 密码系统</h2>
<img src="/计安导_img/19.png">
<img src="/计安导_img/20.png">
<h3 id="rsa-安全性"><a class="markdownIt-Anchor" href="#rsa-安全性"></a> RSA 安全性</h3>
<p>基于给定e和n，找到d是困难的</p>
<h1 id="密码学哈希函数"><a class="markdownIt-Anchor" href="#密码学哈希函数"></a> 密码学哈希函数</h1>
<h2 id="哈希函数"><a class="markdownIt-Anchor" href="#哈希函数"></a> 哈希函数</h2>
<ol>
<li>哈希函数 指将可变长度的消息P 作为输入，产生固定 长度的Hash值 x = h§，称函数值h§为P的哈希值或消息摘要。</li>
<li>哈希表 是根据关键码值(Key value)而直接进行访问的数据结构。也就是说， 它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。</li>
<li>性质：
<ol>
<li>单向性</li>
<li>抗弱碰撞性 想穷举出明文是困难的</li>
<li>抗强碰撞性 想伪造哈希签名是困难的</li>
<li>一个函数如果是抗强碰撞的，那么也同时是抗弱碰撞的，但反之则不 一定成立</li>
</ol>
</li>
</ol>
<h2 id="随机预言机"><a class="markdownIt-Anchor" href="#随机预言机"></a> 随机预言机</h2>
<p>把随机预言机理解为<strong>完美</strong>的散列函数，具有</p>
<ol>
<li>一致性：对于相同的输入，其输出必然相同</li>
<li>可计算性：输出的计算可以在多项式时间内完成</li>
<li>均匀分布性：预言机的输出在取值空间内均匀分布，<strong>无碰撞</strong></li>
</ol>
<h2 id="生日攻击"><a class="markdownIt-Anchor" href="#生日攻击"></a> 生日攻击</h2>
<p>暴力破解哈希，危害其抗碰撞性</p>
<h3 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h3>
<ol>
<li>随机产生消息序列X1，X2，X3，…</li>
<li>对于每个Xi计算Hash值 yi = h(Xi) 并且检测yi是否等于yj ( j &lt; i )</li>
<li>直至找到碰撞即停止</li>
</ol>
<h3 id="概率分析"><a class="markdownIt-Anchor" href="#概率分析"></a> 概率分析</h3>
<ol>
<li>对于b位的Hash函数，则有2<sup>b</sup>个Hash值数目</li>
<li>攻击者 生成的第 i 个消息与前面 i-1 个消息中任意一个产生冲突的概率为 1 - (i - 1)/m</li>
<li>在k轮的失败概率(即攻击者在生成 k个消息后没有找到冲突的概率)为Fk = (1 - 1/m) (1 - 2/m) (1 - 3/m) … (1 - (k - 1)/m)</li>
<li>用1- x ≈ e<sup>-x</sup>逼近,Fk ≈ e <sup>-(1/m + 2/m + 3/m + … + (k - 1)/m) </sup>= e <sup>-k ( k-1) / 2m</sup></li>
<li>当Fk = 1/2时，攻击成功/失败的概率为50%，即e <sup>-k ( k-1) / 2m</sup> = 1/2</li>
<li>进一步得到k=1.17√m , 其中√m 的位数是b/2，m位数的一半</li>
<li>所以通常根据输出大小的一半来考虑加密散列函数的安全, 比如256位抗冲突Hash函数的安全是128位。</li>
</ol>
<h2 id="md5消息签名算法"><a class="markdownIt-Anchor" href="#md5消息签名算法"></a> MD5消息签名算法</h2>
<p>对于任意两个密文Ｐ和Ｑ，通过250次MD5哈希运算可以找出两个前 缀S1和S2使得 P||S1 和 Q||S2 发生碰撞.</p>
<h1 id="数据完整性"><a class="markdownIt-Anchor" href="#数据完整性"></a> 数据完整性</h1>
<h2 id="消息认证码-mac"><a class="markdownIt-Anchor" href="#消息认证码-mac"></a> 消息认证码 MAC</h2>
<ol>
<li>发送方计算MAC值 c = h(K, M) 并且将c连同消息M一起传输。接收方从收到的消息中重新计算MAC值并将其与接收到的MAC进行比较。</li>
<li>密钥可以以单独加密并签名的方式发送</li>
</ol>
<h2 id="基于hash函数的mac-hmac"><a class="markdownIt-Anchor" href="#基于hash函数的mac-hmac"></a> 基于Hash函数的MAC HMAC</h2>
<ol>
<li>密码学Hash函数不能直接用作消息认证函数。因为Hash函数内部迭代结构，所以标准Hash并不安全。</li>
<li>HMAC构造方法
<ol>
<li>h(K⊕A||h(K⊕B||M)) A和B为常数</li>
</ol>
</li>
</ol>
<h2 id="安全信道"><a class="markdownIt-Anchor" href="#安全信道"></a> 安全信道</h2>
<p>确保不安全信道所传输的消息的完整性和机密性。包括</p>
<ol>
<li>签名配合加密：对(message, signature)加密后再进行传输</li>
<li>MAC配合加密：对(message, MAC)加密后再进行传输。
<ol>
<li>比签名配合加密的方法更加高效：计算消息的MAC比对消息进行签名 和验证更快，且开销更低。</li>
</ol>
</li>
</ol>
<h2 id="hash链"><a class="markdownIt-Anchor" href="#hash链"></a> Hash链</h2>
<img src="/计安导_img/21.png">
<ol>
<li>
<p>计算Hash链</p>
<p>xn = r</p>
<p>xi = h(x<sub>i+1</sub>) for i = n-1, …, 1</p>
</li>
<li>
<p>验证Hash链</p>
<p>xn+1 = 0</p>
<p>xi = h(Pi || x<sub>i+1</sub>) ) for i = n, …, 1</p>
</li>
</ol>
<h2 id="hash-树"><a class="markdownIt-Anchor" href="#hash-树"></a> Hash 树</h2>
<p>是一种树 形数据结构，每个叶节点均以 数据块的Hash作为标签，而 除了叶节点以外的节点则以其 子节点标签的Hash作为标签</p>
<h2 id="哈希认证树"><a class="markdownIt-Anchor" href="#哈希认证树"></a> 哈希认证树</h2>
<img src="/计安导_img/22.png">
<ol>
<li>g = h(h(a, h(x3, x4)), d)</li>
<li>proof(x4) = [(x3, L), (a, L), (d, R)]</li>
<li>具有对数级的存储和计算复杂度</li>
</ol>
<h2 id="允许丢包的数据流检验"><a class="markdownIt-Anchor" href="#允许丢包的数据流检验"></a> 允许丢包的数据流检验</h2>
<img src="/计安导_img/23.png">
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导第7章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC7%E7%AB%A0/"
    >计安导第7章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC7%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.478Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="万维网"><a class="markdownIt-Anchor" href="#万维网"></a> 万维网</h1>
<h2 id="html-超文本标记语言"><a class="markdownIt-Anchor" href="#html-超文本标记语言"></a> HTML 超文本标记语言</h2>
<h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3>
<ol>
<li>静态文档描述语言</li>
<li>支持链接到其他页面或者嵌入图像</li>
<li>通过表单（Forms）将用户输入发送到服务器</li>
</ol>
<h2 id="超文本传输协议http"><a class="markdownIt-Anchor" href="#超文本传输协议http"></a> 超文本传输协议HTTP</h2>
<ol>
<li>先检索本地DNS，如果没有找到则查询DNS服务器</li>
<li>解析IP地址之后，建立TCP连接</li>
<li>HTTP请求和响应<strong>通过TCP的端口80</strong>传输</li>
<li>不提供数据加密，以明文发送</li>
</ol>
<h2 id="安全套接字层超文本传输协议https"><a class="markdownIt-Anchor" href="#安全套接字层超文本传输协议https"></a> 安全套接字层超文本传输协议HTTPS</h2>
<ol>
<li>
<p>与HTTP语法相同，但使用了安全套接字层SSL或传输层安全TLS</p>
</li>
<li>
<p>SSL和TLS都依靠证书来验 证服务器的身份，并建立加 密的通信信道</p>
 <img src="/计安导_img/8.png">
</li>
</ol>
<h1 id="网络钓鱼"><a class="markdownIt-Anchor" href="#网络钓鱼"></a> 网络钓鱼</h1>
<p>通过伪造网页以欺诈的方式获取敏感资料</p>
<h2 id="url混淆同源攻击"><a class="markdownIt-Anchor" href="#url混淆同源攻击"></a> URL混淆	同源攻击</h2>
<p>注册带有unicode字符的域名，针对相似的字母进行注册。称为<strong>同源攻击</strong></p>
<h2 id="移除或伪造地址栏"><a class="markdownIt-Anchor" href="#移除或伪造地址栏"></a> 移除或伪造地址栏</h2>
<h1 id="图像崩溃"><a class="markdownIt-Anchor" href="#图像崩溃"></a> 图像崩溃</h1>
<p>由于浏览器的缺陷导致。通过HTML代码创建一个非常大比例的简单图像，可以使IE 崩溃，有时还会使电脑宕机。</p>
<h1 id="可移动代码"><a class="markdownIt-Anchor" href="#可移动代码"></a> 可移动代码</h1>
<p><strong>可移动代码</strong> 指可执行、通过网络发送、在目标 电脑上执行的代码程序。包括</p>
<h2 id="javascript"><a class="markdownIt-Anchor" href="#javascript"></a> JavaScript</h2>
<h2 id="activex控件"><a class="markdownIt-Anchor" href="#activex控件"></a> ActiveX控件</h2>
<h3 id="支持签名"><a class="markdownIt-Anchor" href="#支持签名"></a> 支持签名</h3>
<p>此签名的ActiveX控件要求 用户运行权限。如果获得批准，控件将以与用户相同的权限运行</p>
<h3 id="受信任不受信任的activex控件"><a class="markdownIt-Anchor" href="#受信任不受信任的activex控件"></a> 受信任/不受信任的ActiveX控件</h3>
<ol>
<li>
<p>可行的发布者：</p>
<ol>
<li>存储在Windows注册表中的列表</li>
<li>恶意ActiveX控件可以修改注册表，使其发行者可信</li>
<li>运行该发布者今后所有的插件不需要提示用户</li>
</ol>
</li>
<li>
<p>未签名的控件</p>
<ol>
<li>浏览器对于未签名的控件会给出一个接受/拒绝的选项</li>
<li>但即使你拒绝该控件，它也已被下载到一个临时文件夹中</li>
<li>如果拒绝，它不会被执行，但也不会被删除</li>
</ol>
</li>
</ol>
<p>###<strong>可以访问用户文件</strong></p>
<h2 id="java插件"><a class="markdownIt-Anchor" href="#java插件"></a> Java插件</h2>
<h3 id="支持签名-2"><a class="markdownIt-Anchor" href="#支持签名-2"></a> 支持签名</h3>
<p>###<strong>沙箱执行</strong></p>
<ol>
<li>沙箱：应用程序或脚本在另一个应用程序中首先的运行权限。沙箱只能访问某些文件和设备。</li>
</ol>
<h1 id="cookies"><a class="markdownIt-Anchor" href="#cookies"></a> Cookies</h1>
<p>cookie是指存储在计算机上、与特定服务器关联的 一小部分信息。用于在会话中保存状态信息。</p>
<h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2>
<p>可能包含敏感信息</p>
<h2 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h2>
<ol>
<li><strong>会话型cookie</strong>：是浏览器的处理过程中保留的，是暂时性的，当 浏览器关闭时则消除。</li>
<li><strong>持久性cookie</strong>：而持久性的是保存在客户端的硬盘上的，浏览器 关闭也不会消除。</li>
</ol>
<h1 id="跨站脚本-xss"><a class="markdownIt-Anchor" href="#跨站脚本-xss"></a> 跨站脚本 XSS</h1>
<p>用于攻击者将脚本代码注入Web应用程序生成的页面。攻击者通常在有漏洞的程序中插入Javascript， VBScript，ActiveX或Flash以欺骗用户。</p>
<h2 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例</h2>
<p>2005 年 Samy 在社交网站Myspace的个人资料中加入 Javascript ，打开该页面 的浏览器将执行该脚本 ― 首先把攻击者加为好友，其次把这段 XSS 复制到被 攻击者的个人资料中。</p>
<p>这算是一种<strong>蠕虫</strong></p>
<h2 id="xss的发起条件"><a class="markdownIt-Anchor" href="#xss的发起条件"></a> XSS的发起条件</h2>
<ol>
<li>Web服务器没有对用户输入进行有效性验证或者验证强度不够 ，而又轻易地将它们返回到客户端</li>
<li>允许用户在表格或编辑框中输入不相关字符</li>
<li>存储并允许把用户输入显示在返回给终端的页面上，而没有去 除非法字符或者重新进行编码</li>
</ol>
<h2 id="xss盗取cookie"><a class="markdownIt-Anchor" href="#xss盗取cookie"></a> XSS盗取cookie</h2>
<ol>
<li>首先编写获取cokie的php脚本</li>
<li>向被攻击者服务器页面上注入一段JS代码，用于将被攻击者的cookie传送到我们的服务器。</li>
</ol>
<h2 id="xss的防御"><a class="markdownIt-Anchor" href="#xss的防御"></a> XSS的防御</h2>
<h3 id="基于代理"><a class="markdownIt-Anchor" href="#基于代理"></a> 基于代理</h3>
<ol>
<li>分析浏览器和Web服务器之间的HTTP通信量</li>
<li>寻找HTML中的特殊字符</li>
<li>执行Web页面之前对它们进行编码</li>
</ol>
<h3 id="使用应用层防火墙"><a class="markdownIt-Anchor" href="#使用应用层防火墙"></a> 使用应用层防火墙</h3>
<ol>
<li>分析HTML页面中可能导致敏感信息泄漏的超链接</li>
<li>对于使用不良请求的一系列链接进行停止操作</li>
</ol>
<h3 id="审计制度"><a class="markdownIt-Anchor" href="#审计制度"></a> 审计制度</h3>
<p>监视JavaScript代码的执行，并将操作与高级策略进行比较，以 检测恶意行为</p>
<h1 id="sql注入攻击"><a class="markdownIt-Anchor" href="#sql注入攻击"></a> SQL注入攻击</h1>
<p>SQL注入：就是通过把SQL命令插入到Web表单提交或输入 域名或页面请求的查询字符串，最终达到欺骗服务器执行恶 意的SQL命令</p>
<h2 id="条件"><a class="markdownIt-Anchor" href="#条件"></a> 条件</h2>
<ol>
<li>web应用程序从表单中获取用户输入</li>
<li>用户提交的信息用于构建查询</li>
<li>SQL注入攻击涉及在用户输入中放置SQL语句。</li>
</ol>
<h2 id="万能语句-1-or-1"><a class="markdownIt-Anchor" href="#万能语句-1-or-1"></a> 万能语句 1 or 1</h2>
<h2 id="防范"><a class="markdownIt-Anchor" href="#防范"></a> 防范</h2>
<ol>
<li>使用预编译语句，绑定变量。</li>
<li>对用户提交的数据和输入参数进行严格过滤。</li>
<li>使用安全函数</li>
<li>摒弃动态SQL语句，改用存储过程来访问和操作数据。</li>
<li>最小权限原则：避免Web直接使用root</li>
</ol>
<h1 id="dos-拒绝服务攻击"><a class="markdownIt-Anchor" href="#dos-拒绝服务攻击"></a> DoS 拒绝服务攻击</h1>
<p>任何旨在 使计算机或系统不可用或无法执行基本功能的攻击。如TCP 泛滥攻击，DNS放大攻击。</p>
<h2 id="分布式拒绝服务攻击-ddos"><a class="markdownIt-Anchor" href="#分布式拒绝服务攻击-ddos"></a> 分布式拒绝服务攻击 DDoS</h2>
<ol>
<li>利用控制的大量僵尸计算机同时攻击目标。使得传统DoS攻击不了的高性能服务器也变得不安全。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导第9章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC9%E7%AB%A0/"
    >计安导第9章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC9%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.478Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="策略-模型与信任"><a class="markdownIt-Anchor" href="#策略-模型与信任"></a> 策略、模型与信任</h1>
<h2 id="安全策略"><a class="markdownIt-Anchor" href="#安全策略"></a> 安全策略</h2>
<h3 id="主体"><a class="markdownIt-Anchor" href="#主体"></a> 主体</h3>
<p>是与系统交互的代理</p>
<h3 id="客体"><a class="markdownIt-Anchor" href="#客体"></a> 客体</h3>
<p>是安全策略要保护和管理的信息与计算资源</p>
<h3 id="动作"><a class="markdownIt-Anchor" href="#动作"></a> 动作</h3>
<p>主体对客体可能(或不可能)执行的操作</p>
<h3 id="权限"><a class="markdownIt-Anchor" href="#权限"></a> 权限</h3>
<p>主体、操作与客体之间的映射，权限明确规定允许或禁止哪些操作</p>
<h3 id="保护"><a class="markdownIt-Anchor" href="#保护"></a> 保护</h3>
<p>策略中包含的特定安全特性或规则，以 帮助实现特定的安全目标，如保密性、完整性、可用性或匿 名性。</p>
<h2 id="安全模型"><a class="markdownIt-Anchor" href="#安全模型"></a> 安全模型</h2>
<p>是一种抽象的、为管理员指定安全策略提供 概念语言。</p>
<p>通常定义了</p>
<ol>
<li>组织成员所拥有的访问或修改权限的层次结构</li>
</ol>
<h2 id="自主访问控制-dac"><a class="markdownIt-Anchor" href="#自主访问控制-dac"></a> 自主访问控制 DAC</h2>
<p>指的是赋予用户能力确定文件访 问权限的一种方案。</p>
<ol>
<li>允许用户根据用户和组设置访问控制措施。</li>
<li>允许用户将资源特权授予同一系统上的其他用户。</li>
</ol>
<h2 id="强制访问控制-mac"><a class="markdownIt-Anchor" href="#强制访问控制-mac"></a> 强制访问控制 MAC</h2>
<ol>
<li>不允许用户定义文件的权限.</li>
<li>而是由中央策略管理员制定安全策略。</li>
<li>每个安全规则都由主体、客体和一系列的权限组成。其中主体是获得权限的的一方，客体是被访问的资源。</li>
</ol>
<h2 id="信任管理系统"><a class="markdownIt-Anchor" href="#信任管理系统"></a> 信任管理系统</h2>
<h2 id="组成包括"><a class="markdownIt-Anchor" href="#组成包括"></a> 组成包括</h2>
<ol>
<li><strong>策略语言</strong></li>
<li><strong>一致性检查器</strong></li>
<li>策略规则由策略语言指定，并由一致性检查器执行</li>
</ol>
<h2 id="规则包括"><a class="markdownIt-Anchor" href="#规则包括"></a> 规则包括</h2>
<ol>
<li>操作 与系统安全相关的结果</li>
<li>主题 可以在系统 上执行操作的用户、进程或其他实体</li>
<li>策略 就是制定的规 则，制定赋予主体哪些权限，能执行那些操作</li>
<li>凭证 数字签名 的文件，将主体身份与允许的行 为绑定，包括允许主体将权限委 托给其他主体的权限</li>
</ol>
<h1 id="访问控制模型"><a class="markdownIt-Anchor" href="#访问控制模型"></a> 访问控制模型</h1>
<h2 id="bell-la-padula模型"><a class="markdownIt-Anchor" href="#bell-la-padula模型"></a> Bell-La Padula模型</h2>
<p>强制访问控制模型，保护机密性</p>
<h3 id="全序和偏序"><a class="markdownIt-Anchor" href="#全序和偏序"></a> 全序和偏序</h3>
<ol>
<li>全序：自反，反对称，传递，完全性(如果x和y在U中，则x ≤ y 或 y ≤ x)</li>
<li>偏序：去掉完全性</li>
</ol>
<h3 id="blp-工作原理"><a class="markdownIt-Anchor" href="#blp-工作原理"></a> BLP 工作原理</h3>
<ol>
<li>原则：信息只能从低安全级别流向高安全级别。</li>
<li>安全级别是偏序的</li>
<li>每个对象x被分配到一个安全级别L(X)。同样，每个用户u被分配到 安全级别L(U)。用户对象的访问受以下两条规则控制：
<ol>
<li>简单安全性质：只有满足L(x) ≼ L(u)，用户u才能读取对象x：即<strong>不可向上读</strong></li>
<li>性质只有满足L(u) ≼ L(x)，用户u才能写入（创建、编 辑或追加）对象x：即<strong>不可向下写</strong></li>
</ol>
</li>
</ol>
<h2 id="biba模型"><a class="markdownIt-Anchor" href="#biba模型"></a> Biba模型</h2>
<ol>
<li>Biba模型的完整性级别表明对象和用户的可信度或准确度。</li>
<li>Biba 不允许从下一级阅读，也不允许写到上层。</li>
</ol>
<h3 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h3>
<p>如果让I(u)表示用户u的完整性级别，I(x)表示对象x的完整性级别， 则Biba模型中有以下规则：</p>
<ol>
<li>原则：信息只能从较高的完整性级别下降 到较低的完整性级别</li>
<li>用户u只能在I(u) ≼ I(x)情况下读取对象x：</li>
<li>用户u只能在I(x) ≼ I(u)情况下才能写入(创建、编辑或追加)一个对象x</li>
</ol>
<h2 id="低水印模型"><a class="markdownIt-Anchor" href="#低水印模型"></a> 低水印模型</h2>
<p>扩展的Biba模型，放宽了不可想下读的限制。</p>
<ol>
<li>原则 具有较高完整性级别的用户可以读取完整性级别较低 的对象。</li>
<li>在这样的读取之后，对执行读取的用户进行降级，使其完整性级别 与所读取对象的完整性级别相匹配。</li>
</ol>
<h2 id="克拉克-威尔逊模型"><a class="markdownIt-Anchor" href="#克拉克-威尔逊模型"></a> 克拉克-威尔逊模型</h2>
<p>用于处理执行事务的系统。关键组件包括</p>
<ol>
<li>完整性约束：表明为了保证系统的状态有效，各对象之间必须满足的关系。</li>
<li>认证方法：验证事务给定的完整性约束。一旦认证了事务的程序，每 次执行事务时，则不必再次进行完整性约束验证。</li>
<li>职责分离原则：防止执行事务的用户验证事务。通常，每个事务都被 分配给可以分别验证和执行事务的不相交的用户集。</li>
</ol>
<h2 id="中国墙模型"><a class="markdownIt-Anchor" href="#中国墙模型"></a> 中国墙模型</h2>
<p>被设计用于商业领域， 以消除利益冲突的可能性。</p>
<ol>
<li>讲资源分组为利益冲突类</li>
<li>每个用户只能从每个利益冲突类访问一个资源。</li>
</ol>
<h2 id="基于角色的访问控制-rbac"><a class="markdownIt-Anchor" href="#基于角色的访问控制-rbac"></a> 基于角色的访问控制 RBAC</h2>
<h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3>
<ol>
<li>便于组织授权管理</li>
<li>支持继承</li>
<li>便于实现最小特权原则</li>
<li>可实现指责隔离原则</li>
<li>支持客体抽象</li>
<li>策略中立，通过不同配置能够实现特殊策略</li>
</ol>
<h3 id="核心概念"><a class="markdownIt-Anchor" href="#核心概念"></a> 核心概念</h3>
<ol>
<li>用户：需要访问组织的资源以执行任务的实体</li>
<li>角色：组织中具有类似功能和职责的用户的集合</li>
<li>权限：权限描述了允许访问资源的方法。</li>
<li>会话：由为执行特定任务而激活用户角色的子集组成。</li>
</ol>
<h3 id="分级rbac"><a class="markdownIt-Anchor" href="#分级rbac"></a> 分级RBAC</h3>
<ol>
<li>定义：色R1继承（inherits）R2，如果R1包含R2的所有权限，R2包括 R1的所有用户，可以表示为R1 ≽ R2。称R1为R2的上一层。</li>
</ol>
<h1 id="渗透测试"><a class="markdownIt-Anchor" href="#渗透测试"></a> 渗透测试</h1>
<h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2>
<ol>
<li>
<p>渗透测试：从攻击者(黑客)的角度测试系统和体系结构的安全性，在 固定时间内必须获得的具有预定目标的“模拟攻击”</p>
<ol>
<li>组我欸其他安全措施的补充</li>
<li>花销大</li>
</ol>
</li>
<li>
<p>流程：</p>
<ol>
<li>收集信息
<ol>
<li>IP地址信息</li>
<li>个人信息</li>
</ol>
</li>
<li>扫描IP：给定一组IP地址，确定每个服务和操作系统都在运行</li>
<li>识别系统：通过扫描开放电脑的网络连接端，确定哪些服务运行在哪些连接端，并且推断计算机运行哪个操作系统</li>
<li>识别易受攻击的服务：给定特定的IP地址和端口，尝试获得对机器 的访问权限。报告此目标的所有已知漏洞</li>
<li>利用漏洞</li>
</ol>
</li>
</ol>
<h1 id="kerberos"><a class="markdownIt-Anchor" href="#kerberos"></a> Kerberos</h1>
<ol>
<li>Kerberos：基于可信第三方（Trusted Third Party， TTP）的身份认证协议；</li>
<li>旨在对整个网络进行集中身份验证，而不是在每个用户计算机上存储敏感的身份验证信息。</li>
</ol>
<h2 id="身份验证"><a class="markdownIt-Anchor" href="#身份验证"></a> 身份验证</h2>
<ol>
<li>
<p>在身份验证过程中，客户端收到两个票据</p>
<ol>
<li>票据授予票据（TGT）：用户和会话密钥的全局标识符。</li>
<li>服务票据（service ticket）：对用户进行身份验证，确定用户能否 使用特殊服务。</li>
<li>票据都有时间戳，用于标明数据的有效期限</li>
</ol>
</li>
<li>
<p>密钥分发中心 KDC 组成</p>
<p>为了实现安全的身份验证</p>
<ol>
<li>身份验证服务器(AS):用于执行用户身份验证。维护存储用户和服务密钥的数据库。对用户提供的密码执行单向散列来生成用户的密钥。</li>
<li>票据授予服务器(TGS):用于向用户授予票据</li>
</ol>
</li>
</ol>
<h3 id="身份认证过程"><a class="markdownIt-Anchor" href="#身份认证过程"></a> 身份认证过程</h3>
<p>概括的说</p>
<ol>
<li>客户端与AS互相进行身份验证</li>
<li>客户端与TGS互相进行身份验证</li>
<li>客户端与服务S互相进行身份验证，为客户端提供服务</li>
</ol>
<p>具体</p>
<ol>
<li>用户输入的密码经过哈希散列形成客户端密钥Kc</li>
<li>客户端与AS联系，AS执行
<ol>
<li>
<p>使用客户端密钥Kc加密客户端-TGS的会话密钥K<sub>CT</sub></p>
</li>
<li>
<p>使用TGS的密钥K<sub>T</sub>加密票据授予票据TGT。TGT中包含K<sub>CT</sub>和有效期。</p>
</li>
<li>
<p>客户端使用Kc解密TGS会话密钥K<sub>CT</sub>。之后，客户端向TGS发送如下两个消息：</p>
<ol>
<li>TGT 和 所请求服务名称S</li>
<li>验证令牌 有用户ID和时间戳组成，使用客户端TGS会话密钥K<sub>CT</sub>进行加密</li>
</ol>
</li>
<li>
<p>.TGS使KT解密TGS，从而得到客户端TGS的会话密钥K<sub>CT</sub>和TGT的 有效期。在有效期之内，TGS使用密钥K<sub>CT</sub>解密身份验证令牌，向客 户端发送如下两个消息：</p>
<ol>
<li>使用K<sub>CT</sub>加密的新的客户端-服务器会话密K<sub>CS</sub>。</li>
<li>使用具体服务的密钥KS加密客户端-服务器票据（client-server ticket），其中 TGS已知密钥KS 。票据包含客户端ID、网络地址、有效期、密钥K<sub>CS</sub>。</li>
</ol>
</li>
<li>
<p>在对客户端-服务器会话密钥K<sub>CS</sub>解密后，为了使服务对客户端进行身份验证，客户端发送以下两个消息：</p>
<ol>
<li>在上个步骤中，TGS发送的客户端-服务器的票据。</li>
<li>使用K<sub>CS</sub>加密的客户端ID和时间戳。</li>
</ol>
</li>
<li>
<p>服务使用自己的密钥KS解密客户端-服务器的票据，得到客户端-服 务器的会话密钥K<sub>CS</sub> 。使用K<sub>CS</sub>解密客户端ID和时间戳。最后，为了向客户端证码自己的身份，它使用时间戳加1，并用K<sub>CS</sub>重新加密送回客户端。</p>
</li>
<li>
<p>客户端使用KCS解密并验证这个响应，如果验证成功，就可以开始 客户端-服务器的会话了。</p>
</li>
<li>
<p>票据有效期内，客户端为了访问多个服务，可以一直重复3-7步。</p>
</li>
</ol>
</li>
</ol>
<h3 id="优点-2"><a class="markdownIt-Anchor" href="#优点-2"></a> 优点</h3>
<ol>
<li>分布式体系结构，可以在不安全的网络中使用。</li>
<li>由于每次传输都使用适当的密钥进行加密，攻击者在不能破解密 钥或底层的加密算法的情况下，无法伪造有效的票据来获得对未 授权服务的访问。</li>
<li>可防止重放攻击，因为不接受未授权方重传的消息。</li>
<li>使用对称加密，所以比较高效</li>
</ol>
<h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3>
<ol>
<li>存在单点故障问题：密钥分发中心不可用</li>
<li>如果KDC被破坏，在每个客户端和服务器的身法验证信息都被泄漏</li>
<li>需要所有参与方都有同步的时钟</li>
</ol>
<h1 id="安全存储"><a class="markdownIt-Anchor" href="#安全存储"></a> 安全存储</h1>
<h2 id="安全保护措施"><a class="markdownIt-Anchor" href="#安全保护措施"></a> 安全保护措施</h2>
<ol>
<li>保存好U盘手机</li>
<li>防范窃取数据的恶意软件</li>
<li>合理处置废旧设备</li>
<li>备份</li>
<li>云存储</li>
</ol>
<h2 id="文件密码保护"><a class="markdownIt-Anchor" href="#文件密码保护"></a> 文件密码保护</h2>
<p>保护信息的一种方法就是对文件进行加密，在密码算法没有在理论破解或密钥泄露的情况下，即使文件被盗，也不用担心信息会泄露。</p>
<ol>
<li>
<p>常见密码算法</p>
 <img src="/计安导_img/25.png">
</li>
</ol>
<h3 id="加密文件系统-efs"><a class="markdownIt-Anchor" href="#加密文件系统-efs"></a> 加密文件系统 EFS</h3>
<ol>
<li>
<p>特点</p>
<ol>
<li>自动加密解密</li>
<li>保护文件内容，而不保护文件名和其他元数据</li>
<li>支持共享加密文件</li>
</ol>
</li>
<li>
<p>缺点</p>
<ol>
<li>只保护本地文件系统，所以传送到其他文件系统会被破解</li>
<li>临时文件不受保护</li>
<li>密钥管理很麻烦</li>
</ol>
</li>
<li>
<p>加密技术：同时使用对称和非对称加密</p>
 <img src="/计安导_img/26.png">
<ol>
<li>加密时首先使用AES(对称)单独的加密密钥FEK加密每个文件</li>
<li>然后使用FEK加密数据</li>
<li>再用用户的RSA(非对称)的公钥加密FEK，并保存文件的元数据。</li>
<li>解密时首先用用户的私钥解密FEK</li>
<li>然后再用FEK解密数据</li>
<li>注：每个用户对应一个经过公钥加密的FEK</li>
</ol>
</li>
</ol>
<h2 id="磁盘加密"><a class="markdownIt-Anchor" href="#磁盘加密"></a> 磁盘加密</h2>
<h3 id="truecrypt"><a class="markdownIt-Anchor" href="#truecrypt"></a> TrueCrypt</h3>
<ol>
<li>以分区为基础</li>
<li>所有加密数据都是经过AES等加密算法，难以破解</li>
<li>加密过程自动透明</li>
<li>提供两级方案</li>
</ol>
<h3 id="bitlocker"><a class="markdownIt-Anchor" href="#bitlocker"></a> BitLocker</h3>
<ol>
<li>使用AES对扇区进行加密</li>
<li>使用NTFS格式的卷</li>
<li>可以通过冷启动攻击：属于一种边信道攻击方法，可 以物理接触到计算机的攻击者能够运用这种攻击手段 在冷启动或硬盘重启之后，比如计算机没经历正常的 关机过程就突然重启时，从计算机的内存(RAM)中获 取加密密钥、口令和其他数据。断电后内存中的数据 能维持几十秒或数分钟，但通过液氮或压缩空气冷冻 ，这一数据衰减过程可被攻击者拉长至数小时之久。</li>
</ol>
<h2 id="可信平台模块-tpm"><a class="markdownIt-Anchor" href="#可信平台模块-tpm"></a> 可信平台模块 TPM</h2>
<p>是设计安装在主板上的芯片 ，作为安全密码处理器，它能安全地生成和存储密 钥。在生产时，将一个唯一地RSA私钥铸入到每一 个TPM芯片中。TPM的设计是防篡改的，所以，能 进行物理访问的攻击者也很难恢复这个密钥。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导目录" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%9B%AE%E5%BD%95/"
    >计安导目录</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%9B%AE%E5%BD%95/" class="article-date">
  <time datetime="2020-03-30T02:25:27.697Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="计安导第2章"><a class="markdownIt-Anchor" href="#计安导第2章"></a> <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC2%E7%AB%A0/">计安导第2章</a></h2>
<h2 id="计安导第3章"><a class="markdownIt-Anchor" href="#计安导第3章"></a> <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC3%E7%AB%A0/">计安导第3章</a></h2>
<h2 id="计安导第4章"><a class="markdownIt-Anchor" href="#计安导第4章"></a> <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC4%E7%AB%A0/">计安导第4章</a></h2>
<h2 id="计安导第5章"><a class="markdownIt-Anchor" href="#计安导第5章"></a> <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC5%E7%AB%A0/">计安导第5章</a></h2>
<h2 id="计安导第6章"><a class="markdownIt-Anchor" href="#计安导第6章"></a> <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC6%E7%AB%A0/">计安导第6章</a></h2>
<h2 id="计安导第7章"><a class="markdownIt-Anchor" href="#计安导第7章"></a> <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC7%E7%AB%A0/">计安导第7章</a></h2>
<h2 id="计安导第8章"><a class="markdownIt-Anchor" href="#计安导第8章"></a> <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC8%E7%AB%A0/">计安导第8章</a></h2>
<h2 id="计安导第9章"><a class="markdownIt-Anchor" href="#计安导第9章"></a> <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC9%E7%AB%A0/">计安导第9章</a></h2>
<h2 id="计安导第10章"><a class="markdownIt-Anchor" href="#计安导第10章"></a> <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC10%E7%AB%A0/">计安导第10章</a></h2>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/10/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/12/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        CuiEnbo
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt=""></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['', '', ''],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: false
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>