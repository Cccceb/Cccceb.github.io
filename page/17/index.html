<!DOCTYPE html>


<html lang="cn" >


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

  <script type="text/javascript"
	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/Bg.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/"></a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-快速幂计算" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%A1%E7%AE%97/"
    >快速幂计算</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%A1%E7%AE%97/" class="article-date">
  <time datetime="2020-03-30T02:15:00.638Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-1374-快速幂计算"><a class="markdownIt-Anchor" href="#uva-1374-快速幂计算"></a> UVA 1374 快速幂计算</h1>
<p>初始有x，问经过多少次乘除可以得到目标值n。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>
<p>与埃及积分有相似之处，可以采用迭代加深搜的方法。</p>
</li>
<li>
<p>通过迭代得出可以得到的幂次，通过深度搜素来凑</p>
</li>
<li>
<p>关于剪枝</p>
<ol>
<li>根据题意，幂次不允许小于0，幂次=0也没用</li>
<li>如果当前序列的最大数乘以2<sup>maxd-d</sup>&lt;n，则应该剪枝。因为即使剩余的maxd-d层都是乘以当前序列的最大值(即最大的幂次乘以2，即左移一位)仍然小于n，则说明这一支不可能达到n了，故需要剪掉。</li>
</ol>
</li>
<li>
<p>关于节点排序：为了更快的接近目标，应该优先扩展较大的数，优先加法再试减法。这样可以在最后一次迭代中，无需等待整个解答树扩展完成即可找到解。</p>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> maxd;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> maxn)</span></span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (maxd = <span class="number">0</span>;; maxd++)</span><br><span class="line">            <span class="keyword">if</span> (dfs(<span class="number">0</span>, <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, maxd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> maxn)</span> </span>&#123;<span class="comment">//当前的步数d，当前的最大值maxn</span></span><br><span class="line">    <span class="keyword">if</span> (d == maxd)</span><br><span class="line">        <span class="keyword">if</span> (maxn == n || maxn &lt;&lt; (maxd - d) == n) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxn &lt;= <span class="number">0</span> || maxn &lt;&lt; (maxd - d) &lt; n) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    res[d] = maxn;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= d; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfs(d + <span class="number">1</span>, maxn + res[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (dfs(d + <span class="number">1</span>, maxn - res[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-括号序列" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/"
    >括号序列</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/" class="article-date">
  <time datetime="2020-03-30T02:15:00.638Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-1626-括号序列"><a class="markdownIt-Anchor" href="#uva-1626-括号序列"></a> UVA 1626 括号序列</h1>
<p>我们将正规括号序列定义如下：</p>
<ol>
<li>空序列是正规括号序列。</li>
<li>如果S是一个正规括号序列，那么(S)和[S]都是正规括号序列。</li>
<li>如果A和B都是正规括号序列，那么AB是一个正规括号序列。</li>
</ol>
<p>例如，下面这些序列都是正规括号序列：</p>
<p>(),[],(()),([]),()[],()[()]</p>
<p>而下面这些不是正规括号序列：</p>
<p>(,[,),)(,([)],([]</p>
<p>给你一些含有字符’(’,’)’,’[‘和’]'的括号序列。你需要找一个最短的正规括号序列，使给定括号序列作为一个子序列包含在其中。</p>
<p>输入描述：<br />
输入第一行为一个正整数，代表数据组数。每组数据内容见下文。这一行之后跟着一个空行，每两组数据中间也有一个空行。<br />
每组输入都为一行，最多包含100个括号（字符’(’,’)’,’[‘和’]’），每两个括号之间没有空格。</p>
<p>输出描述：<br />
对于每一组数据，格式必须符合如下：<br />
输出最短的括号序列，满足题目描述，并且每两个输出之间必须有一个空行分开（最后一行没有）。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>对于一个序列是否是正规序列，要考虑其中的所有字串，想到了递归。</li>
<li>设d(i,j)表示[i,j]构成正规序列至少需要增加多少括号，则
<ol>
<li>已知的边界时d(i,i)=1,d(i+1,i) = 0</li>
<li>对于每个状态d(i,j)，来源于字串的状态。当S[i]与S[j]能匹配时，d(i,j)=d(i+1,j-1)即字串的最少增加的序列数目；或者来自于字串分割之后总共至少需要的括号数。</li>
<li>真正的d(i,j)要取他们的最小值</li>
</ol>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="init-初始化边界"><a class="markdownIt-Anchor" href="#init-初始化边界"></a> init 初始化边界</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void init() &#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">		d[i+1][i] &#x3D; 0;</span><br><span class="line">		d[i][i] &#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="match-判断是否匹配"><a class="markdownIt-Anchor" href="#match-判断是否匹配"></a> match 判断是否匹配</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline bool match(char c, char c2) &#123;</span><br><span class="line">	if (c &#x3D;&#x3D; &#39;(&#39;&amp;&amp;c2 &#x3D;&#x3D; &#39;)&#39;) return true;</span><br><span class="line">	if (c &#x3D;&#x3D; &#39;[&#39;&amp;&amp;c2 &#x3D;&#x3D; &#39;]&#39;) return true;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dp-采用记忆化搜索"><a class="markdownIt-Anchor" href="#dp-采用记忆化搜索"></a> dp 采用记忆化搜索</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int dp(int i, int j) &#123;</span><br><span class="line">	if (i &gt; j) return 0;</span><br><span class="line">	if (i &#x3D;&#x3D; j) return 1;</span><br><span class="line">	if (vis[i][j]) return d[i][j];</span><br><span class="line">	vis[i][j] &#x3D; 1;</span><br><span class="line">	int&amp; ans &#x3D; d[i][j];</span><br><span class="line">	ans &#x3D; inf;</span><br><span class="line">	if (match(s[i], s[j]))</span><br><span class="line">		ans &#x3D; min(ans, dp(i + 1, j - 1));</span><br><span class="line"></span><br><span class="line">	for (int k &#x3D; i; k &lt;&#x3D; j - 1; k++)</span><br><span class="line">		ans &#x3D; min(ans, dp(i, k) + dp(k + 1, j));</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="print-打印思路与dp类似注意及时return"><a class="markdownIt-Anchor" href="#print-打印思路与dp类似注意及时return"></a> print 打印，思路与dp类似，注意及时return</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">int dp(int i, int j) &#123;</span><br><span class="line">	if (i &gt; j) return 0;</span><br><span class="line">	if (i &#x3D;&#x3D; j) return 1;</span><br><span class="line">	if (vis[i][j]) return d[i][j];</span><br><span class="line">	vis[i][j] &#x3D; 1;</span><br><span class="line">	int&amp; ans &#x3D; d[i][j];</span><br><span class="line">	ans &#x3D; inf;</span><br><span class="line">	if (match(s[i], s[j]))</span><br><span class="line">		ans &#x3D; min(ans, dp(i + 1, j - 1));</span><br><span class="line"></span><br><span class="line">	for (int k &#x3D; i; k &lt;&#x3D; j - 1; k++)</span><br><span class="line">		ans &#x3D; min(ans, dp(i, k) + dp(k + 1, j));</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">void print(int i, int j) &#123;</span><br><span class="line">	if (i &gt; j) return;</span><br><span class="line">	if (i &#x3D;&#x3D; j) &#123;</span><br><span class="line">		if (s[i] &#x3D;&#x3D; &#39;(&#39; || s[i] &#x3D;&#x3D; &#39;)&#39;) printf(&quot;()&quot;);</span><br><span class="line">		if (s[i] &#x3D;&#x3D; &#39;[&#39; || s[i] &#x3D;&#x3D; &#39;]&#39;) printf(&quot;[]&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	int ans &#x3D; d[i][j];</span><br><span class="line">	if (match(s[i], s[j])) &#123;</span><br><span class="line">		if (ans &#x3D;&#x3D; d[i + 1][j - 1])</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;%c&quot;, s[i]);</span><br><span class="line">			print(i + 1, j - 1);</span><br><span class="line">			printf(&quot;%c&quot;, s[j]);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int k &#x3D; i; k &lt; j; k++)</span><br><span class="line">		if (ans &#x3D;&#x3D; d[i][k] + d[k + 1][j]) &#123;</span><br><span class="line">			print(i, k), print(k + 1, j);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d\n&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		memset(d, -1, sizeof(d));</span><br><span class="line">		fgets(s, maxn, stdin);</span><br><span class="line">		n &#x3D; strlen(s)-1;</span><br><span class="line">		init();</span><br><span class="line">		&#x2F;&#x2F;printf(&quot;%d\n&quot;, dp(0, n - 1));</span><br><span class="line">		dp(0, n-1);</span><br><span class="line">		print(0, n-1);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">		if (T) printf(&quot;\n&quot;);</span><br><span class="line">		getchar();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="刘老师代码-比我快好多qaq"><a class="markdownIt-Anchor" href="#刘老师代码-比我快好多qaq"></a> 刘老师代码 比我快好多QAQ</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">char S[maxn];</span><br><span class="line">int n, d[maxn][maxn];</span><br><span class="line"></span><br><span class="line">bool match(char a, char b) &#123;</span><br><span class="line">  return (a &#x3D;&#x3D; &#39;(&#39; &amp;&amp; b &#x3D;&#x3D; &#39;)&#39;) || (a &#x3D;&#x3D; &#39;[&#39; &amp;&amp; b &#x3D;&#x3D; &#39;]&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dp() &#123;</span><br><span class="line">  for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">    d[i+1][i] &#x3D; 0;</span><br><span class="line">    d[i][i] &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i &#x3D; n-2; i &gt;&#x3D; 0; i--)</span><br><span class="line">    for(int j &#x3D; i+1; j &lt; n; j++) &#123;</span><br><span class="line">      d[i][j] &#x3D; n;</span><br><span class="line">      if(match(S[i], S[j])) d[i][j] &#x3D; min(d[i][j], d[i+1][j-1]);</span><br><span class="line">      for(int k &#x3D; i; k &lt; j; k++)</span><br><span class="line">        d[i][j] &#x3D; min(d[i][j], d[i][k] + d[k+1][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(int i, int j) &#123;</span><br><span class="line">  if(i &gt; j) return ;</span><br><span class="line">  if(i &#x3D;&#x3D; j) &#123;</span><br><span class="line">    if(S[i] &#x3D;&#x3D; &#39;(&#39; || S[i] &#x3D;&#x3D; &#39;)&#39;) printf(&quot;()&quot;);</span><br><span class="line">    else printf(&quot;[]&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  int ans &#x3D; d[i][j];</span><br><span class="line">  if(match(S[i], S[j]) &amp;&amp; ans &#x3D;&#x3D; d[i+1][j-1]) &#123;</span><br><span class="line">    printf(&quot;%c&quot;, S[i]); print(i+1, j-1); printf(&quot;%c&quot;, S[j]);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int k &#x3D; i; k &lt; j; k++)</span><br><span class="line">    if(ans &#x3D;&#x3D; d[i][k] + d[k+1][j]) &#123;</span><br><span class="line">      print(i, k); print(k+1, j);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void readline(char* S) &#123;</span><br><span class="line">  fgets(S, maxn, stdin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int T;</span><br><span class="line"></span><br><span class="line">  readline(S);</span><br><span class="line">  sscanf(S, &quot;%d&quot;, &amp;T);</span><br><span class="line">  readline(S);</span><br><span class="line"></span><br><span class="line">  while(T--) &#123;</span><br><span class="line">    readline(S);</span><br><span class="line">    n &#x3D; strlen(S) - 1;</span><br><span class="line">    memset(d, -1, sizeof(d));</span><br><span class="line">    dp();</span><br><span class="line">    print(0, n-1);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    if(T) printf(&quot;\n&quot;);</span><br><span class="line">    readline(S);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-煎饼" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E7%85%8E%E9%A5%BC/"
    >煎饼</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E7%85%8E%E9%A5%BC/" class="article-date">
  <time datetime="2020-03-30T02:15:00.638Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-120-煎饼"><a class="markdownIt-Anchor" href="#uva-120-煎饼"></a> UVA 120 煎饼</h1>
<p>给你一迭薄煎饼，请你写一个程式来指出要如何安排才能使这些薄煎饼由上到下依薄煎饼的半径由小到大排好。所有的薄煎饼半径均不相同。</p>
<p>要把薄煎饼排好序需要对这些薄煎饼做翻面（flip）的动作。方法是以一抹刀插入一迭薄煎饼中，然后做翻面的动作（也就是说在抹刀上面的薄煎饼经翻面后，会依相反的次序排列）。若一迭共有n个薄煎饼，我们定义最底下的薄煎饼的位置为1，最上面的薄煎饼位置为n。当抹刀插入位置为k时，代表从位置k到位置n的薄煎饼要做翻面的动作。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>题意是要进行排序，只不过基本操作是颠倒一个连续的子序列</li>
<li>借鉴选择排序的思想，从大到小依次将每个数排到正确的位置。</li>
<li>实现时先翻到最上面，再翻到正确位置。因为大的在下面，并且按照从大到小的顺序处理，所以当处理第i大的煎饼时，不会影响到1，2，3，···，i-1大的煎饼。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="filp-从p处开始翻"><a class="markdownIt-Anchor" href="#filp-从p处开始翻"></a> filp 从p处开始翻</h2>
<ol>
<li>使用swap函数更好理解，并且省下了辅助数组所耗费的时间和空间</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	void filp(int p) &#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; p - i; i++) </span><br><span class="line">		swap(in[i], in[p - i]);</span><br><span class="line">	printf(&quot;%d &quot;, n - p);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">## main </span><br><span class="line">1. 由于规模较小，所以使用order数组来确定大小关系，也可以使用max_element函数</span><br></pre></td></tr></table></figure>
<pre><code>const int maxn = 35;
int in[maxn];
int order[maxn];
int ans[maxn];
int n;
int main() {
string line;
while (getline(cin, line))
{
	cout &lt;&lt; line &lt;&lt; endl;
	stringstream ss(line);
	n = 0;
	while (ss &gt;&gt; in[n]) n++;
	memcpy(order, in, sizeof(in));
	sort(order, order + n);
	int now;
	for (int i = n - 1; i &gt;= 0;i--) {
		int now = order[i];
		for (int j = 0; j &lt; n; j++) {
			if (in[j] == now) {
				if (j == i ) break;
				if (j != 0)  filp(j);
				filp(i);
				break;
			}
		}
	}
	cout &lt;&lt;&quot;0&quot;&lt;&lt; endl;
}

}
</code></pre>
<pre class="highlight"><code class=""></code></pre>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-空间结构" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84/"
    >空间结构</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2020-03-30T02:15:00.638Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-806-空间结构"><a class="markdownIt-Anchor" href="#uva-806-空间结构"></a> UVA 806 空间结构</h1>
<p>一个四分树是由一个方格的结构组成的，如图：（就是上面的三个图）。</p>
<p>那些像素点可以构成一个四分树，如图：（就是上面的那个树）。</p>
<p>我们规定，NW=1,NE=2,SW=3,SE=4，而一个节点所构成的数字串可以认为是一个五进制数，将它们排序后输出。</p>
<p>例如：上图中地四号节点的路径为NE,SW，所以是32532_5325​ （五进制数）=171017_{10}1710​（十进制数）</p>
<p>那么上树所对应的一传数列为：（在十进制下）</p>
<p>9 14 17 22 23 44 63 69 88 94 113\text{9 14 17 22 23 44 63 69 88 94 113} 9 14 17 22 23 44 63 69 88 94 113</p>
<p>你的任务是在这两者之间转换。</p>
<p>注意，数串中的数字顺序是从叶子到根的，别搞错了。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>
<p>对于n&gt;0的情况，需要将矩阵转化为四分树。</p>
<p>采用递归算法，每次递归四分之一块，如果遇到范围内纯黑或纯白，则返回。并且在遇到纯黑时，将序列存入向量中。</p>
<p>注意：要先判断整个图是否为纯黑或者纯白。</p>
<p>然后将五进制转化为十进制</p>
</li>
<li>
<p>对于n&lt;0的情况，将四分树转化为矩阵<br />
先将十进制转化为五进制，并在字符串尾部添加*，以标识叶子节点<br />
采用递归算法，每次根据当前字符，来选择下一步递归的范围。当遇到叶子节点时，将当前层的范围内的点涂黑</p>
<p>注意：pre向量中的每个元素，代表一条从根到叶子的路径，所以要用循环配合递归。</p>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;string.h&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
# pragma warning(disable:4996)
# define LOCAL
# ifdef LOCAL
FILE *fin = freopen(&quot;空间结构in.txt&quot;, &quot;r&quot;, stdin);
FILE *fout = freopen(&quot;空间结构out.txt&quot;, &quot;w&quot;, stdout);
# endif 
using namespace std;

vector&lt;int&gt; number;
vector&lt;string&gt; pre;
char g[64][64];
int n;
void five() {
	for (int i = 0; i &lt; number.size(); i++) {
		int temp = 0;
		while (number[i]) {
			temp *= 10;		//注意此处要先乘10
			temp += number[i] % 5;
			number[i] = number[i] / 5;
		}

		pre.push_back(to_string(temp) + '*');
		//加*以标识叶子
	}
}
void draw(const string s, int &amp;p, int r, int c, int w) {

	if (p == s.length()) return;
	char ch = s[p++];
	switch (ch - '0')
	{

	case 1:	draw(s, p, r, c, w / 2); break;
	case 2: draw(s, p, r, c + w / 2, w / 2); break;
	case 3:	draw(s, p, r + w / 2, c, w / 2); break;
	case 4:	draw(s, p, r + w / 2, c + w / 2, w / 2); break;
	default:
		break;
	}
	if (ch == '*') {
		for (int i = r; i &lt; r + w; i++)
			for (int j = c; j &lt; c + w; j++) {
				
					g[i][j] = '*';
				
			}
	}
}
bool judge(int r, int c, int w,char ch) {
	// ch为0代表是否纯黑，为1代表是否纯白
	for (int i = r; i &lt; r + w; i++)
		for (int j = c; j &lt; c + w; j++)
			if (g[i][j] == ch)
				return false;
	return true;	//任何情况下都要有return否则会RE
}
void matrix(string str, int r, int c, int w) {
	
	if (judge(r, c, w,'0')) {
		pre.push_back(str);	//纯黑则递归到头，将序列保存
		return;
	}
	else if (judge(r, c, w,'1')) return;
	else {
		matrix(str + &quot;1&quot;, r, c, w / 2);
		matrix(str + &quot;2&quot;, r, c + w / 2, w / 2);
		matrix(str + &quot;3&quot;, r + w / 2, c, w / 2);
		matrix(str + &quot;4&quot;, r + w / 2, c + w / 2, w / 2);
	}
}
void ten() {

	for (int i = 0; i &lt; pre.size(); i++) {
		int temp = 0;
		for (int j = pre[i].size() - 1; j &gt;= 0; j--)
			temp += (pre[i][j] - '0')*pow(5, j);
		number.push_back(temp);

	}
}
int main() {
	int first = 1;
	int kase = 0;
	while (cin &gt;&gt; n &amp;&amp; n) {
		if (first) first = 0; else cout &lt;&lt; endl;
		cout &lt;&lt; &quot;Image &quot; &lt;&lt; ++kase &lt;&lt; endl;

		number.clear();
		pre.clear();
		memset(g, '.', sizeof(g));
		getchar();
		if (n &gt; 0) {
			for (int i = 0; i &lt; n; i++)
				for (int j = 0; j &lt; n; j++)
					cin &gt;&gt; g[i][j];
		
		
			if (judge(0, 0, n,'0')) number.push_back(0);
			//纯黑的情况
			else if (judge(0, 0, n,'1'));//纯白
			
			else {
				matrix(&quot;1&quot;, 0, 0, n / 2);
				matrix(&quot;2&quot;, 0, n / 2, n / 2);
				matrix(&quot;3&quot;, n / 2, 0, n / 2);
				matrix(&quot;4&quot;, n / 2, n / 2, n / 2);
				ten();
			}
			
			
			sort(number.begin(), number.end());
			if (!number.empty()) {
				for (int i = 0; i &lt; number.size(); i++)
				{
					cout &lt;&lt; number[i];
					if ((i + 1) % 12 == 0||i==number.size()-1) cout &lt;&lt; endl;
					else cout &lt;&lt; &quot; &quot;;
				}
			}

			cout &lt;&lt; &quot;Total number of black nodes = &quot; &lt;&lt; number.size() &lt;&lt; endl;
			
		}
		if (n &lt; 0) {

			string s;
			bool flag = false;
			bool zero = false;
			for (;;) {
				int a;
				//由于输入的结束标志-1不一定出现在哪里，所以
				//要设置标志
				for (int i = 0; i &lt; 12; i++) {
					cin &gt;&gt; a;
					if (a == -1) {
						flag = true;
						break;
					}
					if (a == 0)zero = true;
					number.push_back(a);
				}
				if (flag) break;
			}	
			if (zero) {
			//如果包含0，代表它是一个只有一个节点的树
				memset(g, '*', sizeof(g));
			}
			else {
				five();
				for (int i = 0; i &lt; pre.size(); i++) {
					int p = 0;
					draw(pre[i], p, 0, 0, abs(n));
				}
			}
			


			for (int i = 0; i &lt; abs(n); i++) {
				for (int j = 0; j &lt; abs(n); j++)
					cout &lt;&lt; g[i][j];
				cout &lt;&lt; endl;
			}
		}


	}
}
</code></pre>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<ol>
<li>本题加深了对递归问题的理解，使用递归算法也不是仅仅用递归实现，要搭配循环，减小递归代码的编写难度。</li>
<li>理清思路再写递归，注意认清递归结束条件，不要模糊。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-划分成回文串" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%88%92%E5%88%86%E6%88%90%E5%9B%9E%E6%96%87%E4%B8%B2/"
    >划分成回文串</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%88%92%E5%88%86%E6%88%90%E5%9B%9E%E6%96%87%E4%B8%B2/" class="article-date">
  <time datetime="2020-03-30T02:15:00.623Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-11584-划分成回文串"><a class="markdownIt-Anchor" href="#uva-11584-划分成回文串"></a> UVA 11584 划分成回文串</h1>
<p>当一个字符串正序和反序是完全相同时，我们称之为“回文串”。例如“racecar”就是一个回文串，而“fastcar”就不是。现在给一个字符串s，把它分割成若干个互不相交的回文子串，求分割的回文子串的最少个数。</p>
<p>第一行为正整数t(≤10)，表示数据组数；接下来t行，每行一个完全由小写字母组成的字符串，长度不超过1000。</p>
<p>对于每组数据，输出最少回文子串数。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>设d[i]表示在i之前最少能构成多少回文串</li>
<li>要做的是对于每个i，在0-i中寻找j，使得[j+1,i]是个回文串。对于合法的j，更新d[i]，d[i] = min(d[i], d[j] + 1)。</li>
<li>判断回文串可以采用递归的方法</li>
<li>注意一些初值的选择</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000+5;</span><br><span class="line">char s[maxn];</span><br><span class="line">int vis[maxn][maxn];</span><br><span class="line">int p[maxn][maxn];</span><br><span class="line">int d[maxn];</span><br><span class="line">bool is_pali(int l, int r) &#123;</span><br><span class="line">	if (l &gt;&#x3D; r) return true;</span><br><span class="line">	if (s[l] !&#x3D; s[r]) return false;</span><br><span class="line">	if (vis[l][r]) return p[l][r];</span><br><span class="line"></span><br><span class="line">	vis[l][r] &#x3D; 1;</span><br><span class="line"></span><br><span class="line">	p[l][r] &#x3D; is_pali(l + 1, r - 1);</span><br><span class="line">	return p[l][r];</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%s&quot;, s + 1);</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		d[0] &#x3D; 0;</span><br><span class="line">		int n &#x3D; strlen(s + 1);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			d[i] &#x3D; i + 1; &#x2F;&#x2F;至多就是前面每个字符自己是一个回文串</span><br><span class="line">			for (int j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">				if (is_pali(j+1, i))</span><br><span class="line">					d[i] &#x3D; min(d[i], d[j] + 1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, d[n]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-滑动窗口最小问题" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%B0%8F%E9%97%AE%E9%A2%98/"
    >滑动窗口最小问题</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%B0%8F%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-03-30T02:15:00.623Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="p1886-滑动窗口最小问题"><a class="markdownIt-Anchor" href="#p1886-滑动窗口最小问题"></a> P1886 滑动窗口最小问题</h1>
<p>有一个长为 nnn 的序列 aaa，以及一个大小为 kkk 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。</p>
<p><img src="/%E8%AE%A1%E5%AE%89%E5%AF%BC_img/5.png" alt="" /></p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>窗口滑动的过程，相当于删除一个元素，再插入一个元素，同时获得最大值或者最小值。相当于一个<strong>优先级队列</strong>，可以使用set来模拟一个优先级队列实现,时间复杂度O((n-k)logk)，其中插入，删除，取极值都是logk,一共需要滑动n-k次。规模大时TLE。</li>
<li>使用<strong>单调队列</strong>：队列中元素顺序与输入相同，而元素的值是有序的。因为每个元素至多被删除依次，所以总的时间复杂度在O(n)。以单调增队列为例
<ol>
<li>如果当前正在扫描的元素比队列队尾元素大，那么直接插入。如果比队尾元素小，则将元素从<strong>队尾出队</strong>，直到队尾元素小于当前元素。</li>
<li>如果插入元素后，有的元素滑动到窗口外，则应该从<strong>队头出队</strong></li>
</ol>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="单调队列"><a class="markdownIt-Anchor" href="#单调队列"></a> 单调队列</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct monotone_queue &#123;</span><br><span class="line">	static const int maxn &#x3D; 1e6+5;</span><br><span class="line">	int n, k, a[maxn];</span><br><span class="line">	int q[maxn], head, tail, p[maxn];&#x2F;&#x2F;q是值的队列,q是编号的队列</span><br><span class="line"></span><br><span class="line">	void read_in() &#123;</span><br><span class="line">		scanf(&quot;%d %d&quot;, &amp;n, &amp;k);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void monotone_min() &#123;</span><br><span class="line">		int head &#x3D; 1;</span><br><span class="line">		int tail &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			while (head &lt;&#x3D; tail &amp;&amp; q[tail] &gt;&#x3D; a[i]) tail--;&#x2F;&#x2F;比当前元素大的全部从队尾出队</span><br><span class="line">			q[++tail] &#x3D; a[i];</span><br><span class="line">			p[tail] &#x3D; i;&#x2F;&#x2F;插入当前元素</span><br><span class="line">			while (p[head] &lt;&#x3D; i - k) head++;&#x2F;&#x2F;窗口外元素从队头出队</span><br><span class="line">			if (i &gt;&#x3D; k) printf(&quot;%d &quot;, q[head]);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void monotone_max() &#123;</span><br><span class="line">		int head &#x3D; 1;</span><br><span class="line">		int tail &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			while (head &lt;&#x3D; tail &amp;&amp; q[tail] &lt;&#x3D; a[i]) tail--;&#x2F;&#x2F;比当前元素小的全部从队尾出队</span><br><span class="line">			q[++tail] &#x3D; a[i];</span><br><span class="line">			p[tail] &#x3D; i;</span><br><span class="line">			while (p[head] &lt;&#x3D; i - k) head++;</span><br><span class="line">			if (i &gt;&#x3D; k) printf(&quot;%d &quot;, q[head]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">monotone_queue mq;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	mq.read_in();</span><br><span class="line">	mq.monotone_min();</span><br><span class="line">	mq.monotone_max();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模拟优先队列"><a class="markdownIt-Anchor" href="#模拟优先队列"></a> 模拟优先队列</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1e6 + 5;</span><br><span class="line"> </span><br><span class="line">set&lt;int, less&lt;int&gt; &gt; s;</span><br><span class="line">int big[maxn], small[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, k;</span><br><span class="line">	scanf(&quot;%d %d&quot;, &amp;n, &amp;k);</span><br><span class="line"></span><br><span class="line">	int a;</span><br><span class="line">	int p1 &#x3D; 0, p2 &#x3D; 0;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">		q.push(a);</span><br><span class="line">		s.insert(a);</span><br><span class="line">		if (q.size() &#x3D;&#x3D; k) &#123;</span><br><span class="line">			int tmp &#x3D; q.front(); q.pop();</span><br><span class="line">			small[p1++] &#x3D; *(s.begin());</span><br><span class="line">			big[p2++] &#x3D; *(s.rbegin());</span><br><span class="line">			s.erase(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; p1; i++)</span><br><span class="line">		printf(&quot;%d &quot;, small[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; p2; i++)</span><br><span class="line">		printf(&quot;%d &quot;, big[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-环形跑道" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E7%8E%AF%E5%BD%A2%E8%B7%91%E9%81%93/"
    >环形跑道</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E7%8E%AF%E5%BD%A2%E8%B7%91%E9%81%93/" class="article-date">
  <time datetime="2020-03-30T02:15:00.623Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-11093-环形跑道"><a class="markdownIt-Anchor" href="#uva-11093-环形跑道"></a> UVA 11093 环形跑道</h1>
<p>环形跑道上有n(1 &lt;= n &lt;= 100000)个加油站，编号为1~n。第i个加油站可以加油pi加仑。从加油站i开到下 一站需要qi加仑汽油。你可以选择一个加油站作为起点，起始油箱为空（但可以立即加油）。你的任务是选 择一个起点，使得可以走完一圈后回到起点。假定油箱中的油量没有上限。如果无解，输出Not possible，否则 输出可以作为起点的最小加油站编号。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>贪心法：从小编号加油站开始尝试，如果能转一圈，那么直接输出。否则，以油量不够的加油站的下一站为起点再进行尝试。</li>
<li>假设尝试从1号加油站开始走，到i号加油站加完油也到不了i+1号加油站。那么从2~i-1号加油站开始也肯定不能到，这是因为从1到2时，油箱中的油量c&gt;=0</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100000 + 5;</span><br><span class="line">int p[maxn], q[maxn];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">void solve();</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	int kase &#x3D; 0;</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Case %d: &quot;, ++kase);</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;p[i]);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;q[i]);</span><br><span class="line">		solve();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="solve-贪心过程"><a class="markdownIt-Anchor" href="#solve-贪心过程"></a> solve 贪心过程</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line"></span><br><span class="line">	int beg &#x3D; 0;&#x2F;&#x2F;beg为起点编号</span><br><span class="line"></span><br><span class="line">	int used[maxn]&#123;&#125;;</span><br><span class="line">	bool flag;</span><br><span class="line"></span><br><span class="line">	do</span><br><span class="line">	&#123;&#x2F;&#x2F;如果试图使用已经尝试过的起点，说明尝试了一圈了</span><br><span class="line"></span><br><span class="line">		while (beg &lt; n&amp;&amp;p[beg] &lt; q[beg]) &#123;&#x2F;&#x2F;掠过若干不可能的起点并标记</span><br><span class="line">			used[beg] &#x3D; 1;</span><br><span class="line">			beg++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		if (beg &gt;&#x3D; n) break;</span><br><span class="line">		int next &#x3D; beg;&#x2F;&#x2F;到下一站耗油量q[next]</span><br><span class="line">		used[beg] &#x3D; 1;</span><br><span class="line"></span><br><span class="line">		int c &#x3D; 0;</span><br><span class="line">		flag &#x3D; true;</span><br><span class="line">		int cnt &#x3D; 0;</span><br><span class="line">		do &#123;</span><br><span class="line">			c +&#x3D; p[next];	&#x2F;&#x2F;加油</span><br><span class="line">			if (c &lt; q[next]) &#123;&#x2F;&#x2F;开不到下一站</span><br><span class="line">				next++;</span><br><span class="line">				flag &#x3D; false;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			else c -&#x3D; q[next];</span><br><span class="line">			next &#x3D; (next + 1) % n;</span><br><span class="line">		&#125; while (next !&#x3D; beg);&#x2F;&#x2F;转一圈结束</span><br><span class="line"></span><br><span class="line">		if (!flag) &#123;</span><br><span class="line">			beg &#x3D; next;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">			break;</span><br><span class="line">	&#125; while (!used[beg]);</span><br><span class="line"></span><br><span class="line">	if (!flag)</span><br><span class="line">		printf(&quot;Not possible\n&quot;);</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;Possible from station %d\n&quot;, beg + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-集合栈计算机" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E9%9B%86%E5%90%88%E6%A0%88%E8%AE%A1%E7%AE%97%E6%9C%BA/"
    >集合栈计算机</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E9%9B%86%E5%90%88%E6%A0%88%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="article-date">
  <time datetime="2020-03-30T02:15:00.623Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva12096-集合栈计算机"><a class="markdownIt-Anchor" href="#uva12096-集合栈计算机"></a> uva12096 ※集合栈计算机※</h1>
<pre><code>Sample Input
2
9
PUSH
DUP
ADD
PUSH
ADD
DUP
ADD
DUP
UNION
5
PUSH
PUSH
ADD
PUSH
INTERSECT

Sample Output
0
0
1
0
1
1
2
***
0
0
1
0
0
</code></pre>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<ol>
<li>首先考虑集合的存储问题：由于有集合作为元素插入到另一个集合的情况，所以不能直接定义集合类型的栈。考虑将集合映射到值(map)，另用一个向量存集合本身。</li>
<li>按照题干输入输出判断操作即可。注意后三种操作可以合并简化代码</li>
</ol>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;iterator&gt;
#include&lt;algorithm&gt;
# define ALL(x) x.begin(),x.end()
# define INS(x) inserter(x,x.begin())
</code></pre>
<blockquote>
<p>INS(x)插入迭代器，插入而非覆盖<br />
<a href="https://blog.csdn.net/m0_37456764/article/details/83019250" target="_blank" rel="noopener">inserter</a>.</p>
</blockquote>
<pre><code>using namespace std;
typedef set&lt;int&gt; Set;
map&lt;Set, int&gt; id;//将每个集合对应一个编号，编号是在向量中的下标
vector&lt;Set&gt; Setcache;
int ID(Set x) {//既是插入又是查询！！
	if (id.count(x)) return id[x];//存在则返回id

	//不存在则添加
	Setcache.push_back(x);
	return id[x] = Setcache.size() - 1;
}
</code></pre>
<p>插入和查询合并简化代码</p>
<pre><code>int main() {
int n;

cin &gt;&gt; n;
while (n--) {
	int m;
	cin &gt;&gt; m;
	stack&lt;int&gt; s;
	while (m--) {
		string op;
		cin &gt;&gt; op;
		if (op[0] == 'P') s.push(ID(Set()));
		//空集入栈，注意此处空集的写法
		else if (op[0] == 'D') s.push(s.top());
		else {
			Set x1 = Setcache[s.top()]; s.pop();
			//不同直接用pop赋值，因为pop的返回值为void
			Set x2 = Setcache[s.top()]; s.pop();
			Set x;
			if (op[0] == 'U') set_union(ALL(x1), ALL(x2), INS(x));
			if (op[0] == 'I') set_intersection(ALL(x1), ALL(x2), INS(x));
			if (op[0] == 'A') { x = x2; x.insert(ID(x1)); }
			s.push(ID(x));
		}
		cout &lt;&lt; Setcache[s.top()].size() &lt;&lt; endl;
	}
	cout &lt;&lt; &quot;***&quot; &lt;&lt; endl;
}
}
</code></pre>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<ol>
<li>本题主要注重多种STL的结合使用，尤其是集合映射为整型的处理方式</li>
<li>记住题中交并集的函数，set_union(参数为5个迭代器),set_intersection(参数为5个迭代器);要配合两处define使用</li>
<li>注意模拟多种操作时提取相同部分简化代码，也降低出错的可能性和调试难度。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-黄金图形" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E9%BB%84%E9%87%91%E5%9B%BE%E5%BD%A2/"
    >黄金图形</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E9%BB%84%E9%87%91%E5%9B%BE%E5%BD%A2/" class="article-date">
  <time datetime="2020-03-30T02:15:00.623Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-225-黄金图形"><a class="markdownIt-Anchor" href="#uva-225-黄金图形"></a> UVA 225 黄金图形</h1>
<p>平面上有k个障碍点。 从(0,0)点出发，第一次走1个单位，第二次走2个单位，……， 第n次走n个单位，恰好回到(0,0)。 要求只能沿着东南西北方向走，且每次必须转弯90°（不能沿着同一个方向继续走，也不能后退）。 走出的图形可以自交，但不能经过障碍点，如图 7-25所示。每个转折点只能走一次。 输入n、k（1≤n≤20，0≤k≤50）和所有障碍点的坐标，输出所有满足要求的移动序列（用 news表示北、东、西、南），按照字典序从小到大排列，最后输出移动序列的总数。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>又要输出所有的路径，所以直观的想到用dfs。dfs中处理好可以移动的方向即可。</li>
<li>本题的特殊之处在于，障碍格可能出现负坐标。由于本题中最长边长n小于等于20，所以采用给(0,0)点以及障碍物点加一个比较大的值来消负号。我是假设n=20，那么一共也就能走1+2+…20/2=105，所以我加了一个120.</li>
<li>注意：卡了很久的原因主要是题干中要求最长边等于n，这条件不仅是限定搜索深度的。他还要求必须包含长度为n的边。</li>
<li>注意每个转折点只能走一次的条件。这个转折点是指每一步走完之后的终点。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<pre><code>#include&lt;bits/stdc++.h&gt;
# pragma warning(disable:4996)
FILE *fin = freopen(&quot;习题7-2in.txt&quot;, &quot;r&quot;, stdin);
FILE *fout = freopen(&quot;习题7-2out.txt&quot;, &quot;w&quot;, stdout);
using namespace std;
const int maxn = 20;
void dfs(int r, int c, int dir, int step);
int dx[] = { 1,0,0,-1 };//东北南西
int dy[] = { 0,1,-1,0 };
int cnt, n;
bool g[maxn * maxn + 1][maxn * maxn + 1];
char direction[] = { 'e','n','s','w' };
int path[maxn*maxn];
bool vis[maxn*maxn + 1][maxn*maxn+ 1];
int stax, stay;
int main() {
int T;
scanf(&quot;%d&quot;, &amp;T);
int k;
while (T--)
{
	int x, y;
	memset(g, 1, sizeof(g));
	memset(path, 0, sizeof(path));
	
	scanf(&quot;%d\n%d&quot;, &amp;n, &amp;k);
	vector&lt;int&gt; tmpx;
	vector&lt;int&gt; tmpy;
	stax = stay = 120;
	cnt = 0;
	while (k--)
	{
		scanf(&quot;%d %d&quot;, &amp;x, &amp;y);
		g[x + stax][y + stay] = 0;
	}

	for (int i = 0; i &lt; 4; i++) {
		memset(vis, 0, sizeof(vis));
		dfs(stax, stay, i, 1);


	}
	printf(&quot;Found %d golygon(s).\n\n&quot;, cnt);
}
}
void dfs(int r, int c, int dir, int step) {
path[step] = dir;
for (int i = 0; i &lt; step; i++) {
	r += dx[dir];
	c += dy[dir];
	if (!g[r][c] || r &lt; 0 || c &lt; 0 ) {
		return;
	}
}
if (vis[r][c]) return;
if (step &gt;= n) {
	if (r == (stax) &amp;&amp; c == (stay)) {
		for (int i = 1; i &lt;= step; i++)
			printf(&quot;%c&quot;, direction[path[i]]);
		printf(&quot;\n&quot;);
		cnt++;
	}
	return;
}

vis[r][c] = 1;
if (dir == 0 || dir == 3) {
	dfs(r, c, 1, step + 1);
	dfs(r, c, 2, step + 1);
}
else {
	dfs(r, c, 0, step + 1);
	dfs(r, c, 3, step + 1);
}
vis[r][c] = 0;
}</code></pre>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-二叉树的重建" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%87%8D%E5%BB%BA/"
    >二叉树的重建</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%87%8D%E5%BB%BA/" class="article-date">
  <time datetime="2020-03-30T02:15:00.607Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-536-二叉树的重建-先中造树"><a class="markdownIt-Anchor" href="#uva-536-二叉树的重建-先中造树"></a> UVA 536 二叉树的重建 (先中造树)</h1>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">   #include&lt;string&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;习题6-3in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;习题6-3out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   typedef struct node &#123;</span><br><span class="line">   	struct node *lchild, *rchild;</span><br><span class="line">   	char data;</span><br><span class="line">   &#125;node, *ptr;</span><br><span class="line">   ptr Create(char *pre, char *in, int n)</span><br><span class="line">   &#123;</span><br><span class="line">   	ptr s;</span><br><span class="line">   </span><br><span class="line">   	if (n &#x3D;&#x3D; 1)</span><br><span class="line">   	&#123;</span><br><span class="line">   		s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">   		s-&gt;data &#x3D; *pre;</span><br><span class="line">   		s-&gt;lchild &#x3D; s-&gt;rchild &#x3D; NULL;</span><br><span class="line">   		return s;</span><br><span class="line">   	&#125;</span><br><span class="line">   	char *p;</span><br><span class="line">   	for (p &#x3D; in; p &lt; in + n; p++)</span><br><span class="line">   		if (*p &#x3D;&#x3D; *pre) break;</span><br><span class="line">   	int k &#x3D; p - in;</span><br><span class="line">   	s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">   	s-&gt;data &#x3D; *p;</span><br><span class="line">   	s-&gt;lchild &#x3D; s-&gt;rchild &#x3D; NULL;</span><br><span class="line">   	if (k) s-&gt;lchild &#x3D; Create(pre + 1, in, k);</span><br><span class="line">   	if (n - k - 1) s-&gt;rchild &#x3D; Create(pre + k + 1, p + 1, n - k - 1);</span><br><span class="line">   	return s;</span><br><span class="line">   &#125;</span><br><span class="line">   int lastorder(ptr T)</span><br><span class="line">   &#123;</span><br><span class="line">   	if (!T) return 0;</span><br><span class="line">   	lastorder(T-&gt;lchild);</span><br><span class="line">   	lastorder(T-&gt;rchild);</span><br><span class="line">   	printf(&quot;%c&quot;, T-&gt;data);</span><br><span class="line">   	return 1;</span><br><span class="line">   &#125;</span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">   </span><br><span class="line">   	string pre, in;</span><br><span class="line">   	while (cin &gt;&gt; pre &gt;&gt; in) &#123;</span><br><span class="line">   		int n &#x3D; pre.length();</span><br><span class="line">   		ptr T &#x3D; Create(&amp;pre[0], &amp;in[0], n);</span><br><span class="line">   		lastorder(T);</span><br><span class="line">   		cout &lt;&lt; endl;</span><br><span class="line">   	&#125;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/16/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><a class="page-number" href="/page/19/">19</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/18/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        CuiEnbo
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt=""></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['', '', ''],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: false
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>