<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://github.com/Cccceb/Cccceb.github.io').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Ceb">
<meta property="og:url" content="https://github.com/Cccceb/Cccceb.github.io/page/14/index.html">
<meta property="og:site_name" content="Ceb">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Cuienbo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://github.com/Cccceb/Cccceb.github.io/page/14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Ceb</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a href="https://github.com/you"><img style="position:absolute;" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_left_gray_6d6d6d.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>  
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ceb</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E7%BD%91%E6%A0%BC%E5%8A%A8%E7%89%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E7%BD%91%E6%A0%BC%E5%8A%A8%E7%89%A9/" class="post-title-link" itemprop="url">网格动物</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-20 11:48:55" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-01 10:43:00" itemprop="dateModified" datetime="2020-02-01T10:43:00+08:00">2020-02-01</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVA-1602-网格动物"><a href="#UVA-1602-网格动物" class="headerlink" title="UVA 1602 网格动物"></a>UVA 1602 网格动物</h1><p>输入n,w,h(1&lt;=n&lt;=10,1&lt;=w,h&lt;=n).求能放在w*h网格里的不同的n连块的个数(平移,旋转,翻转算一种)</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>如果对于每次的输入计算结果，会超时，所以先打表。</p>
</li>
<li><p>题目问有多少种连通块，所以直观的想到不断的在格子周围扩展格子，然后判断是否重复   ，不重复则加入到集合中。</p>
</li>
<li><p>主要的数据结构为set(set(node))[maxn]，点的集合构成一种连通格，相同连通数的图构成i连通块的动物集合。i格连通的动物存在数组下标为i的集合中。使用点集来存图，一方面可以节省空间，另一方面便于实现平移旋转翻转</p>
</li>
<li><p>还需要实现平移，旋转，翻转</p>
<ol>
<li>平移：统一平移到原点</li>
<li>旋转：顺时针旋转90度，画个图就明白了</li>
<li>翻转：实现是关于x轴翻转</li>
</ol>
</li>
<li><p>打表：打表是一个迭代枚举的过程，后代是对前一代节点周围区域的扩展。由于normal的过程，所以不需要判断越界问题，即使出现负坐标，normal也会将他平移到原点。之后，在循环n,w,h将对应结果存在一个三维数组中即可。</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="打表"><a href="#打表" class="headerlink" title="打表"></a>打表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void get_ans() &#123;</span><br><span class="line">g start;</span><br><span class="line">start.insert(node(0, 0));</span><br><span class="line">animals[1].insert(start);</span><br><span class="line">for (int i &#x3D; 2; i &lt;&#x3D; maxn; i++)</span><br><span class="line">	for (set&lt;g&gt;::iterator j &#x3D; animals[i - 1].begin(); j !&#x3D; animals[i - 1].end(); j++)</span><br><span class="line">		for (g::iterator k &#x3D; (*j).begin(); k !&#x3D; (*j).end(); k++) &#123;</span><br><span class="line">			int r &#x3D; k-&gt;r, c &#x3D; k-&gt;c;</span><br><span class="line">			for (int w &#x3D; 0; w &lt; 4; w++) &#123;</span><br><span class="line">				node nd(r + dx[w], c + dy[w]);</span><br><span class="line">				if (!(*j).count(nd))</span><br><span class="line">					insert(*j, nd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (int n &#x3D; 1; n &lt;&#x3D; maxn; n++)</span><br><span class="line">	for (int w &#x3D; 1; w &lt;&#x3D; maxn; w++)</span><br><span class="line">		for (int h &#x3D; 1; h &lt;&#x3D; maxn; h++) &#123;</span><br><span class="line">			int sum &#x3D; 0;</span><br><span class="line">			for (set&lt;g&gt;::iterator p &#x3D; animals[n].begin(); p !&#x3D; animals[n].end(); p++) &#123;</span><br><span class="line">				int maxx &#x3D; 0, maxy &#x3D; 0;</span><br><span class="line">				for (g::iterator q &#x3D; (*p).begin(); q !&#x3D; (*p).end(); q++) &#123;</span><br><span class="line">					maxx &#x3D; max(maxx, q-&gt;r);</span><br><span class="line">					maxy &#x3D; max(maxy, q-&gt;c);</span><br><span class="line">				&#125;</span><br><span class="line">				if (max(maxx, maxy) &lt; max(w, h) &amp;&amp; min(maxx, maxy) &lt; min(w, h)) sum++;</span><br><span class="line">			&#125;</span><br><span class="line">			ans[n][w][h] &#x3D; sum;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判重及旋转-平移，翻转"><a href="#判重及旋转-平移，翻转" class="headerlink" title="判重及旋转,平移，翻转"></a>判重及旋转,平移，翻转</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">g normal(const g&amp; p) &#123;</span><br><span class="line">int minx &#x3D; p.begin()-&gt;r, miny &#x3D; p.begin()-&gt;c;</span><br><span class="line">for (g::iterator i &#x3D; p.begin(); i !&#x3D; p.end(); i++) &#123;</span><br><span class="line">	minx &#x3D; min(minx, i-&gt;r);</span><br><span class="line">	miny &#x3D; min(miny, i-&gt;c);</span><br><span class="line">&#125;</span><br><span class="line">g p2;</span><br><span class="line">for (g::iterator i &#x3D; p.begin(); i !&#x3D; p.end(); i++)</span><br><span class="line">	p2.insert(node(i-&gt;r - minx, i-&gt;c - miny));</span><br><span class="line">return p2;</span><br><span class="line">&#125;</span><br><span class="line">g turn(const g&amp;p) &#123;</span><br><span class="line">g p2;</span><br><span class="line">for (g::iterator i &#x3D; p.begin(); i !&#x3D; p.end(); i++)</span><br><span class="line">	p2.insert(node(i-&gt;c, -i-&gt;r));</span><br><span class="line">return normal(p2);</span><br><span class="line">&#125;</span><br><span class="line">g filp(const g&amp;p) &#123;</span><br><span class="line">g p2;</span><br><span class="line">for (g::iterator i &#x3D; p.begin(); i !&#x3D; p.end(); i++)</span><br><span class="line">	p2.insert(node(i-&gt;r, -i-&gt;c));</span><br><span class="line">return normal(p2);</span><br><span class="line">&#125;</span><br><span class="line">void insert(const g&amp; p, node nd) &#123;</span><br><span class="line">g p2 &#x3D; p;</span><br><span class="line">p2.insert(nd);</span><br><span class="line">p2 &#x3D; normal(p2);</span><br><span class="line">int n &#x3D; p2.size();</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">	if (animals[n].count(p2)) return;</span><br><span class="line">	p2 &#x3D; turn(p2);</span><br><span class="line">&#125;</span><br><span class="line">p2 &#x3D; filp(p2);</span><br><span class="line">for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">	if (animals[n].count(p2)) return;</span><br><span class="line">	p2 &#x3D; turn(p2);</span><br><span class="line">&#125;</span><br><span class="line">animals[n].insert(p2);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">int r, c;</span><br><span class="line">node(int r &#x3D; 0, int c &#x3D; 0) :r(r), c(c) &#123;&#125;</span><br><span class="line">bool operator &lt; (const node &amp;a) const &#123; return r &lt; a.r || r &#x3D;&#x3D; a.r &amp;&amp; c &lt; a.c; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">typedef set&lt;node&gt; g;</span><br><span class="line">const int maxn &#x3D; 10;</span><br><span class="line">int dx[] &#x3D; &#123; 1,-1,0,0 &#125;;</span><br><span class="line">int dy[] &#x3D; &#123; 0,0,1,-1 &#125;;</span><br><span class="line">g normal(const g&amp; p);</span><br><span class="line">g turn(const g&amp; p);</span><br><span class="line">g filp(const g&amp; p);</span><br><span class="line">void insert(const g&amp; p, node nd);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, h, w;</span><br><span class="line">get_ans();</span><br><span class="line">while (cin &gt;&gt; n &gt;&gt; w &gt;&gt; h)</span><br><span class="line">	cout &lt;&lt; ans[n][w][h] &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%A1%E7%AE%97/" class="post-title-link" itemprop="url">快速幂计算</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-20 11:48:55" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-09 11:54:08" itemprop="dateModified" datetime="2020-02-09T11:54:08+08:00">2020-02-09</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVA-1374-快速幂计算"><a href="#UVA-1374-快速幂计算" class="headerlink" title="UVA 1374 快速幂计算"></a>UVA 1374 快速幂计算</h1><p>初始有x，问经过多少次乘除可以得到目标值n。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>与埃及积分有相似之处，可以采用迭代加深搜的方法。由于题干要求每次都是两项的积，所以不能用二分求幂。</p>
</li>
<li><p>关于剪枝</p>
<ol start="2">
<li>如果当前序列的最大数乘以2<sup>maxd-d</sup>&lt;n，则应该剪枝。因为即使剩余的maxd-d层都是乘以当前序列的最大值(即最大的幂次乘以2，即左移一位)仍然小于n，则说明这一支不可能达到n了，故需要剪掉。</li>
</ol>
</li>
<li><p>关于节点排序：为了更快的接近目标，应该优先扩展较大的数，优先加法再试减法。这样可以在最后一次迭代中，无需等待整个解答树扩展完成即可找到解。</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int res[50];</span><br><span class="line">int maxd;</span><br><span class="line">bool dfs(int d, int maxn);</span><br><span class="line">int n;</span><br><span class="line">int main() &#123;</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">	for (maxd &#x3D; 0;; maxd++)</span><br><span class="line">		if (dfs(0, 1)) break;</span><br><span class="line">	printf(&quot;%d\n&quot;, maxd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool dfs(int d, int maxn) &#123;&#x2F;&#x2F;当前的步数d，当前的最大值maxn</span><br><span class="line">if (d &#x3D;&#x3D; maxd)</span><br><span class="line">	if (maxn &#x3D;&#x3D; n || maxn &lt;&lt; (maxd - d) &#x3D;&#x3D; n) return true;</span><br><span class="line">if (maxn &lt;&#x3D; 0 || maxn &lt;&lt; (maxd - d) &lt; n) return false;</span><br><span class="line">res[d] &#x3D; maxn;</span><br><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; d; i++) &#123;</span><br><span class="line">	if (dfs(d + 1, maxn + res[i])) return true;</span><br><span class="line">	if (dfs(d + 1, maxn - res[i])) return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">数据库</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-20 11:48:55" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-22 13:24:06" itemprop="dateModified" datetime="2020-01-22T13:24:06+08:00">2020-01-22</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uva-1592-数据库"><a href="#uva-1592-数据库" class="headerlink" title="uva 1592 数据库"></a>uva 1592 数据库</h1><p>输入一个n行m列的数据库，是否存在两个不同行r1，r2和两个不同列c1，c2，使得这两行和两列相同。（即（r1,c1）和（r2,c1）相同，（r1,c2）和（r2,c2）相同）</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>由于最终要判断是否相同，所以可以将字符串映射为一个值，以减少比较的时间</li>
<li>主循环中，在c1,c2下循环r，并将（r,c1）,(r,c2)存成一个二元组，将二元组映射为当前的行号，如果图中已存在这样的二元组，那么对应的值即为r2，当前行为r1。</li>
<li>由于有以二元组为键类型的图，所以结构体中要重写“&lt;”，否则会报错<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    #include&lt;iostream&gt;</span><br><span class="line">    #include&lt;string&gt;</span><br><span class="line">    #include&lt;set&gt;</span><br><span class="line">    #include&lt;map&gt;</span><br><span class="line">    #include&lt;vector&gt;</span><br><span class="line">    using namespace std;</span><br><span class="line">    map&lt;string, int&gt; location;</span><br><span class="line">    set&lt;string&gt; same;</span><br><span class="line">    vector&lt;int&gt; str[100000];</span><br><span class="line">    typedef struct point &#123;</span><br><span class="line">    	int x;</span><br><span class="line">    	int y;</span><br><span class="line">    	point(int x, int y) :x(x), y(y) &#123;&#125;</span><br><span class="line">    	bool operator &lt; (const point&amp; r) const &#123; return x &lt; r.x || x &#x3D;&#x3D; r.x&amp;&amp;y &lt; r.y; &#125;</span><br><span class="line">    &#125;point;</span><br><span class="line">※※注意此处重写“&lt;”的方法</span><br><span class="line"></span><br><span class="line">	int main() &#123;</span><br><span class="line">	int r, c;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;r, &amp;c) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">		getchar();</span><br><span class="line">		same.clear();</span><br><span class="line">		location.clear();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) str[i].clear();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; c; j++) &#123;</span><br><span class="line">				string s;</span><br><span class="line">				char cs &#x3D; getchar();</span><br><span class="line">				while (cs !&#x3D; &#39;,&#39;&amp;&amp;cs !&#x3D; &#39;\n&#39;) &#123;</span><br><span class="line">					s +&#x3D; cs;</span><br><span class="line">					cs &#x3D; getchar();</span><br><span class="line">				&#125;</span><br><span class="line">				if (!same.count(s)) &#123;</span><br><span class="line">					location[s] &#x3D; i * r + j;</span><br><span class="line">					same.insert(s);</span><br><span class="line">				&#125;</span><br><span class="line">				str[i].push_back(location[s]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">**利用set和map，将每种字符串映射为唯一的值**</span><br><span class="line"></span><br><span class="line">		map&lt;point, int&gt; data;</span><br><span class="line">		for (int c1 &#x3D; 0; c1 &lt; c; c1++) &#123;</span><br><span class="line">			for (int c2 &#x3D; c1 + 1; c2 &lt; c; c2++) &#123;</span><br><span class="line">				data.clear();</span><br><span class="line">				for (int r1 &#x3D; 0; r1 &lt; r; r1++) &#123;</span><br><span class="line">					int x &#x3D; str[r1][c1];</span><br><span class="line">					int y &#x3D; str[r1][c2];</span><br><span class="line">					point p(x, y);</span><br><span class="line">					if (!data.count(p)) data[p] &#x3D; r1;</span><br><span class="line">					else &#123;</span><br><span class="line">						cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl &lt;&lt; data[p] + 1 &lt;&lt; &quot; &quot; &lt;&lt; r1 + 1 &lt;&lt; endl</span><br><span class="line">							&lt;&lt; c1 + 1 &lt;&lt;&quot; &quot;&lt;&lt; c2 + 1 &lt;&lt; endl;</span><br><span class="line">						goto here;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">		here:;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1></li>
<li>本题在循环前的映射与集合栈计算机类似，本题中目的是减少比较时的时间</li>
<li>本题应把两列最为一个整体，否则需要四重循环，会TEL</li>
<li>学习结构体初始化和重写操作符的方法。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E6%9C%A8%E5%9D%97%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E6%9C%A8%E5%9D%97%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">木块问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-20 11:48:55" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-22 13:23:13" itemprop="dateModified" datetime="2020-01-22T13:23:13+08:00">2020-01-22</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVa101-木块游戏"><a href="#UVa101-木块游戏" class="headerlink" title="UVa101 木块游戏"></a>UVa101 木块游戏</h1><h3 id="输入n，得到编号为0n-1的木块，分别摆放在顺序排列编号为0n-1的位置。现对这些木块进行操作，操作分为四种"><a href="#输入n，得到编号为0n-1的木块，分别摆放在顺序排列编号为0n-1的位置。现对这些木块进行操作，操作分为四种" class="headerlink" title="输入n，得到编号为0n-1的木块，分别摆放在顺序排列编号为0n-1的位置。现对这些木块进行操作，操作分为四种:"></a>输入n，得到编号为0<del>n-1的木块，分别摆放在顺序排列编号为0</del>n-1的位置。现对这些木块进行操作，操作分为四种:</h3><h3 id="1、move-a-onto-b：把木块a、b上的木块放回各自的原位，再把a放到b上；"><a href="#1、move-a-onto-b：把木块a、b上的木块放回各自的原位，再把a放到b上；" class="headerlink" title="1、move a onto b：把木块a、b上的木块放回各自的原位，再把a放到b上；"></a>1、move a onto b：把木块a、b上的木块放回各自的原位，再把a放到b上；</h3><h3 id="2、move-a-over-b：把a上的木块放回各自的原位，再把a发到含b的堆上；"><a href="#2、move-a-over-b：把a上的木块放回各自的原位，再把a发到含b的堆上；" class="headerlink" title="2、move a over b：把a上的木块放回各自的原位，再把a发到含b的堆上；"></a>2、move a over b：把a上的木块放回各自的原位，再把a发到含b的堆上；</h3><h3 id="3、pile-a-onto-b：把b上的木块放回各自的原位，再把a连同a上的木块移到b上；"><a href="#3、pile-a-onto-b：把b上的木块放回各自的原位，再把a连同a上的木块移到b上；" class="headerlink" title="3、pile a onto b：把b上的木块放回各自的原位，再把a连同a上的木块移到b上；"></a>3、pile a onto b：把b上的木块放回各自的原位，再把a连同a上的木块移到b上；</h3><h3 id="4、pile-a-over-b：把a连同a上木块移到含b的堆上。"><a href="#4、pile-a-over-b：把a连同a上木块移到含b的堆上。" class="headerlink" title="4、pile a over b：把a连同a上木块移到含b的堆上。"></a>4、pile a over b：把a连同a上木块移到含b的堆上。</h3><h3 id="当输入quit时，结束操作并输出0-n-1的位置上的木块情况"><a href="#当输入quit时，结束操作并输出0-n-1的位置上的木块情况" class="headerlink" title="当输入quit时，结束操作并输出0~n-1的位置上的木块情况"></a>当输入quit时，结束操作并输出0~n-1的位置上的木块情况</h3><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>10</p>
<p>move 9 onto 1</p>
<p>move 8 over 1</p>
<p>move 7 over 1</p>
<p>move 6 over 1</p>
<p>pile 8 over 6</p>
<p>pile 8 over 5</p>
<p>move 2 over 1</p>
<p>move 4 over 9</p>
<p>quit</p>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p> 0: 0</p>
<p> 1: 1 9 2 4</p>
<p> 2:</p>
<p> 3: 3</p>
<p> 4:</p>
<p> 5: 5 8 7 6</p>
<p> 6:</p>
<p> 7:</p>
<p> 8:</p>
<p> 9:</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h3 id="通过四种指令的描述，可以注意到，move指令与把a上的木块全部归位相联系；onto指令与把b上方的木块归位相联系；并且每条指令都包含把a-或a的上方的木块-移动到b上方的部分；因此，应该对应以上三点来写各模块；"><a href="#通过四种指令的描述，可以注意到，move指令与把a上的木块全部归位相联系；onto指令与把b上方的木块归位相联系；并且每条指令都包含把a-或a的上方的木块-移动到b上方的部分；因此，应该对应以上三点来写各模块；" class="headerlink" title="通过四种指令的描述，可以注意到，move指令与把a上的木块全部归位相联系；onto指令与把b上方的木块归位相联系；并且每条指令都包含把a(或a的上方的木块)移动到b上方的部分；因此，应该对应以上三点来写各模块；"></a>通过四种指令的描述，可以注意到，move指令与把a上的木块全部归位相联系；onto指令与把b上方的木块归位相联系；并且每条指令都包含把a(或a的上方的木块)移动到b上方的部分；因此，应该对应以上三点来写各模块；</h3><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="模块一"><a href="#模块一" class="headerlink" title="模块一"></a>模块一</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">查找编号为a的木块所在堆和高度，用引用传递</span><br><span class="line"></span><br><span class="line">    void find(int a, int &amp;pa, int &amp;h) &#123;</span><br><span class="line">    	for (pa &#x3D; 0; pa &lt; n; pa++) &#123;</span><br><span class="line">    		for (h &#x3D; 0; h &lt; p[pa].size(); h++) &#123;</span><br><span class="line">    			if (p[pa][h] &#x3D;&#x3D; a) return;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="模块二"><a href="#模块二" class="headerlink" title="模块二"></a>模块二</h2><p>把a堆高度为h的木块的所有木块归位。注意，本题中的归位是把a放回初始的堆里即可，不考虑初始高度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> void clear_above(int a, int h) &#123;</span><br><span class="line">    	for (int i &#x3D; h + 1; i &lt; p[a].size(); i++) &#123;</span><br><span class="line">    		p[p[a][i]].push_back(p[a][i]);</span><br><span class="line">    	&#125;</span><br><span class="line">    	p[a].resize(h + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模块三"><a href="#模块三" class="headerlink" title="模块三"></a>模块三</h2><p>把p堆高度为h及其上方的木块整体移动到p2堆顶:1.移动2.截断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   void pile_onto(int p1, int h, int p2) &#123;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; h; i &lt; p[p1].size(); i++) &#123;</span><br><span class="line">	p[p2].push_back(p[p1][i]);</span><br><span class="line">&#125;</span><br><span class="line">p[p1].resize(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模块四"><a href="#模块四" class="headerlink" title="模块四"></a>模块四</h2><p>输出各堆的序列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void print()&#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt; &quot;:&quot;;</span><br><span class="line">	for (int j &#x3D; 0; j &lt; p[i].size(); j++) &#123;</span><br><span class="line">		cout &lt;&lt; &quot; &quot; &lt;&lt; p[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) p[i].push_back(i);</span><br><span class="line">string s1, s2;</span><br><span class="line">int a, b;</span><br><span class="line">while (cin &gt;&gt; s1 &gt;&gt; a &gt;&gt; s2 &gt;&gt; b) &#123;</span><br><span class="line">	int pa, pb, ha, hb;</span><br><span class="line">	find(a, pa, ha);</span><br><span class="line">	find(b, pb, hb);</span><br><span class="line">	if (pa &#x3D;&#x3D; pb) continue;&#x2F;&#x2F;非法指令</span><br><span class="line">	</span><br><span class="line">	if (s1 &#x3D;&#x3D; &quot;move&quot;) clear_above(pa, ha);</span><br><span class="line">	if (s2 &#x3D;&#x3D; &quot;onto&quot;) clear_above(pb, hb);</span><br><span class="line">	pile_onto(pa, ha, pb);</span><br><span class="line">&#125;</span><br><span class="line">print();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><ol>
<li>本题应主要学习他的拆分思路,以及引用传递的运用。</li>
<li>学习vector类，vector<typename> xname;</li>
<li>学习vector的基本方法，push_back(要插入的元素) 和 resize(元素个数);</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E6%A0%91/" class="post-title-link" itemprop="url">树</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-20 11:48:55" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-22 13:23:56" itemprop="dateModified" datetime="2020-01-22T13:23:56+08:00">2020-01-22</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uva-548-树"><a href="#uva-548-树" class="headerlink" title="uva 548 树"></a>uva 548 树</h1><p>&ensp;输入一个二叉树的中序和后序遍历，请你输出一个叶子节点，该叶子节点到根的数值总和最小，且这个叶子是编号最小的那个。 输入： 您的程序将从输入文件中读取两行(直到文件结尾)。第一行是树的中序遍历值序列,第二行是树的后序遍历值序列。所有值将不同，大于零且小于或等于10000.二叉树的节1&lt;=N&lt;=10000。 输出： 对于每个树描述，您应该输出最小值路径的叶节点的值。存在多路径最小的情况下，您应该选择终端叶子节点上具有最小值的那条路径，且输出那个最小值的终端叶子。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>根据中序和后序序列构造二叉树</p>
</li>
<li><p>递归遍历二叉树，每一步走左右子树中权值较小的一个</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    #include&lt;iostream&gt;</span><br><span class="line">    #include&lt;string&gt;</span><br><span class="line">    #include&lt;sstream&gt;</span><br><span class="line">    # pragma warning(disable:4996)</span><br><span class="line">    # define LOCAL</span><br><span class="line">    # ifdef LOCAL</span><br><span class="line">    FILE *fin &#x3D; freopen(&quot;树in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    FILE *fout &#x3D; freopen(&quot;树out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    # endif </span><br><span class="line">    using namespace std;</span><br><span class="line">    # define maxn 10000</span><br><span class="line">    int n &#x3D; 0;</span><br><span class="line">    bool read(int *a) &#123;</span><br><span class="line">&gt;数组为参数的时候可以用指针，传首地址</span><br><span class="line"></span><br><span class="line">    	string s;</span><br><span class="line">    	getline(cin, s);</span><br><span class="line">    	stringstream ss(s);</span><br><span class="line">&gt;注意此处，用ss来读取一行不定数量的以空格分隔的数字</span><br><span class="line"></span><br><span class="line">    	n &#x3D; 0;</span><br><span class="line">    	int x;</span><br><span class="line">    	while (ss &gt;&gt; x) a[n++] &#x3D; x;</span><br><span class="line">    	return n &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int post_order[maxn], in_order[maxn],lch[maxn],rch[maxn];</span><br><span class="line">    </span><br><span class="line">&gt;其中rch[i]表示编号为i的节点的右孩子</span><br><span class="line">&#96;</span><br><span class="line">    int build(int l1, int r1, int l2, int r2) &#123;</span><br><span class="line">    	if (l1 &gt; r1) return 0;&#x2F;&#x2F;空树</span><br><span class="line">&gt;本题中以权值代表编号，为0表示节点不存在</span><br><span class="line"></span><br><span class="line">    	int root &#x3D; post_order[r2];&#x2F;&#x2F;后序序列的最后一个</span><br><span class="line">    	int p &#x3D; l1;</span><br><span class="line">    	while (in_order[p] !&#x3D; root) p++;</span><br><span class="line">    	int cnt &#x3D; p-l1;&#x2F;&#x2F;左子树中节点个数</span><br><span class="line">    	</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;分别在左右子树中递归遍历</span><br><span class="line">    	lch[root] &#x3D; build(l1, p - 1, l2 , l2 + cnt - 1);</span><br><span class="line">    	rch[root] &#x3D; build(p + 1, r1, l2 + cnt, r2 - 1);</span><br><span class="line">    	return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int best, best_sum;</span><br><span class="line">    void dfs(int u, int sum) &#123;</span><br><span class="line">    	sum +&#x3D; u;</span><br><span class="line">    	if (!lch[u] &amp;&amp; !rch[u]) &#123;&#x2F;&#x2F;如果u是叶子节点</span><br><span class="line">    		if (sum &lt; best_sum || (best_sum &#x3D;&#x3D; sum &amp;&amp; u &lt; best)) </span><br><span class="line">			&#123;</span><br><span class="line">    			best &#x3D; u;</span><br><span class="line">    			best_sum &#x3D; sum;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    </span><br><span class="line">    	if (lch[u]) dfs(lch[u], sum);</span><br><span class="line">    	if (rch[u]) dfs(rch[u], sum);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    int main() &#123;</span><br><span class="line">    	while (read(in_order)) &#123;</span><br><span class="line">    		read(post_order);</span><br><span class="line">    		build(0, n - 1, 0, n - 1);</span><br><span class="line">    		best_sum &#x3D; 1e9;&#x2F;&#x2F;</span><br><span class="line">    		dfs(post_order[n - 1], 0);</span><br><span class="line">    		cout &lt;&lt; best &lt;&lt; endl;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1></li>
<li><p>输入也可以写成子函数的形式</p>
</li>
<li><p>学习中后造树和递归遍历二叉树的方法</p>
<pre><code>void dfs(树根指针){
if(左子树为空（为0）&amp;&amp;右子树为空（为0）)
    {

        return 0;
    }
if(左孩子不为空) dfs（左孩子）
if(右孩子不为空) dfs（右孩子）
}</code></pre></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E7%A0%B4%E5%9D%8F%E6%AD%A3%E6%96%B9%E5%BD%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E7%A0%B4%E5%9D%8F%E6%AD%A3%E6%96%B9%E5%BD%A2/" class="post-title-link" itemprop="url">破坏正方形</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-20 11:48:55" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-22 13:23:44" itemprop="dateModified" datetime="2020-01-22T13:23:44+08:00">2020-01-22</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVA-1603-破坏正方形"><a href="#UVA-1603-破坏正方形" class="headerlink" title="UVA 1603 破坏正方形"></a>UVA 1603 破坏正方形</h1><p>一个 n×n的网格,共 2×n×(n+1)条边,现在已经删除了一些边,问至 少还需删去多少边,可以使得剩下的边不能构成正方形。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>可以采用迭代加深度深搜，或者回溯法解决</p>
</li>
<li><p>搜索对象可以是木棍或者正方形，对应不同的剪枝</p>
<ol>
<li>如果搜索对象是木棍，那么可以将每个木棍影响的正方形数量记录下来，从大到小排序。当最大影响数量为1时，可以停止搜索，结果为当前层数+剩余正方形数。这是因为如果最大影响数为1，说明剩余正方形之间没有耦合，删除任一木棍，至多减少1个正方形。</li>
<li>如果搜索对象是正方形，那么应该从小正方形开始破坏。本题中采用这种方法。</li>
</ol>
</li>
<li><p>此外，还需要找规律，寻找各行各列，竖线横线的标号关系。以标记构成正方形的边。</p>
</li>
<li><p>本题中判断是否为正方形，<strong>通过size数组和full数组，分别记录第cnt个正方形实际有的边和应该有的边，如果二者相等，那么是一个完整的正方形</strong></p>
</li>
<li><p>本题中使用了回溯法，因为搜素深度有明显的上界2<em>n</em>(n+1)，其中n为边长。</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void dfs(int d) &#123;</span><br><span class="line">if (d &gt;&#x3D; maxd) return;</span><br><span class="line">int next &#x3D; getNext();</span><br><span class="line">if (next &#x3D;&#x3D; 0) &#123;</span><br><span class="line">	maxd &#x3D; d;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">for (int j &#x3D; 1; j &lt;&#x3D; sum; j++) &#123;</span><br><span class="line">	if (in[next][j])</span><br><span class="line">	&#123;</span><br><span class="line">		for (int k &#x3D; 1; k &lt;&#x3D; cnt; k++)&#x2F;&#x2F;删掉火柴棍</span><br><span class="line">			if (in[k][j]) Size[k]--;</span><br><span class="line">		dfs(d + 1);</span><br><span class="line">		for (int k &#x3D; 1; k &lt;&#x3D; cnt; k++)&#x2F;&#x2F;复原</span><br><span class="line">			if (in[k][j]) Size[k]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在删除木棍和回溯的部分，由于判断是才用size[i]==full[i]，所以in[k][j]处必有火柴。</li>
</ol>
<h2 id="getr-getc-求横竖线编号"><a href="#getr-getc-求横竖线编号" class="headerlink" title="getr,getc 求横竖线编号"></a>getr,getc 求横竖线编号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">inline int getr(int r, int c) &#123;</span><br><span class="line">return r * (2 * n + 1) + c + 1;</span><br><span class="line">&#125;</span><br><span class="line">inline int getc(int r, int c) &#123;</span><br><span class="line">return r * (2 * n + 1) + c + n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="get-cnt-填充size数组和full数组"><a href="#get-cnt-填充size数组和full数组" class="headerlink" title="get_cnt 填充size数组和full数组"></a>get_cnt 填充size数组和full数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">inline void get_cnt() &#123;</span><br><span class="line">int a, b, e, f;</span><br><span class="line">cnt &#x3D; 0;</span><br><span class="line">for (int len &#x3D; 1; len &lt;&#x3D; n; len++) &#123;</span><br><span class="line">	for (int r &#x3D; 0; r + len &lt;&#x3D; n; r++) &#123;</span><br><span class="line">		for (int c &#x3D; 0; c + len &lt;&#x3D; n; c++) &#123;</span><br><span class="line">			++cnt;</span><br><span class="line">			full[cnt] &#x3D; len * 4;</span><br><span class="line">			Size[cnt] &#x3D; 0;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				a &#x3D; getr(r, c + i);</span><br><span class="line">				b &#x3D; getr(r + len, c + i);</span><br><span class="line">				e &#x3D; getc(r + i, c);</span><br><span class="line">				f &#x3D; getc(r + i, c + len);</span><br><span class="line">				in[cnt][a] &#x3D; true;</span><br><span class="line">				in[cnt][b] &#x3D; true;</span><br><span class="line">				in[cnt][e] &#x3D; true;</span><br><span class="line">				in[cnt][f] &#x3D; true;</span><br><span class="line">				Size[cnt] +&#x3D; sticks[a] + sticks[b] + sticks[e] + sticks[f];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>注意这种判断的思维。</li>
</ol>
<h2 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int n, maxd, cnt, sum;</span><br><span class="line">bool sticks[2 * maxn*(maxn + 1) + 1];</span><br><span class="line">int Size[625];</span><br><span class="line">int full[625];</span><br><span class="line">int in[625][2 * maxn*(maxn + 1) + 1];</span><br><span class="line">int main() &#123;</span><br><span class="line">int T, k, tmp;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">while (T--) &#123;</span><br><span class="line">	scanf(&quot;%d\n%d&quot;, &amp;n, &amp;k);</span><br><span class="line">	memset(sticks, 1, sizeof(sticks));</span><br><span class="line">	memset(in, 0, sizeof(in));</span><br><span class="line">	while (k--) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;tmp);</span><br><span class="line">		sticks[tmp] &#x3D; false;</span><br><span class="line">	&#125;</span><br><span class="line">	sum &#x3D; 2 * n*(n + 1);</span><br><span class="line">	maxd &#x3D; sum;</span><br><span class="line">	get_cnt();</span><br><span class="line">	dfs(0);</span><br><span class="line">	printf(&quot;%d\n&quot;, maxd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">空间结构</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-20 11:48:55" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-01 12:23:48" itemprop="dateModified" datetime="2020-02-01T12:23:48+08:00">2020-02-01</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVA-806-空间结构"><a href="#UVA-806-空间结构" class="headerlink" title="UVA 806 空间结构"></a>UVA 806 空间结构</h1><p><img src="/img_UVA%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/6.png" alt=""></p>
<p><img src="/img_UVA%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/7.png" alt=""></p>
<p>一个四分树是由一个方格的结构组成的，如图：（就是上面的三个图）。</p>
<p>那些像素点可以构成一个四分树，如图：（就是上面的那个树）。</p>
<p>我们规定，NW=1,NE=2,SW=3,SE=4，而一个节点所构成的数字串可以认为是一个五进制数，将它们排序后输出。</p>
<p>例如：上图中地四号节点的路径为NE,SW，所以是32532_5325​ （五进制数）=171017_{10}1710​（十进制数）</p>
<p>那么上树所对应的一传数列为：（在十进制下）</p>
<p>9 14 17 22 23 44 63 69 88 94 113\text{9 14 17 22 23 44 63 69 88 94 113} 9 14 17 22 23 44 63 69 88 94 113</p>
<p>你的任务是在这两者之间转换。</p>
<p>注意，数串中的数字顺序是从叶子到根的，别搞错了。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>对于n&gt;0的情况，需要将矩阵转化为四分树。</p>
<p> 采用递归算法，每次递归四分之一块，如果遇到范围内纯黑或纯白，则返回。并且在遇到纯黑时，将序列存入向量中。</p>
<p> 注意：要先判断整个图是否为纯黑或者纯白。</p>
<p> 然后将五进制转化为十进制</p>
</li>
<li><p>对于n&lt;0的情况，将四分树转化为矩阵<br> 先将十进制转化为五进制，并在字符串尾部添加*，以标识叶子节点<br> 采用递归算法，每次根据当前字符，来选择下一步递归的范围。当遇到叶子节点时，将当前层的范围内的点涂黑</p>
<p> 注意：pre向量中的每个元素，代表一条从根到叶子的路径，所以要用循环配合递归。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   using namespace std;</span><br><span class="line">   </span><br><span class="line">   vector&lt;int&gt; number;</span><br><span class="line">   vector&lt;string&gt; pre;</span><br><span class="line">   char g[64][64];</span><br><span class="line">   int n;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">   	int first &#x3D; 1;</span><br><span class="line">   	int kase &#x3D; 0;</span><br><span class="line">   	while (cin &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">   		if (first) first &#x3D; 0; else cout &lt;&lt; endl;</span><br><span class="line">   		cout &lt;&lt; &quot;Image &quot; &lt;&lt; ++kase &lt;&lt; endl;</span><br><span class="line">   		number.clear();</span><br><span class="line">   		pre.clear();</span><br><span class="line">   		memset(g, &#39;.&#39;, sizeof(g));</span><br><span class="line">   		getchar();</span><br><span class="line"></span><br><span class="line">   		if (n &gt; 0) &#123;</span><br><span class="line">   			for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">   				for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">   					cin &gt;&gt; g[i][j];</span><br><span class="line">   		</span><br><span class="line">   		</span><br><span class="line">   			if (judge(0, 0, n,&#39;0&#39;)) number.push_back(0);</span><br><span class="line">			&#x2F;&#x2F;纯黑的情况</span><br><span class="line">   			else if (judge(0, 0, n,&#39;1&#39;));&#x2F;&#x2F;纯白</span><br><span class="line">   			</span><br><span class="line">   			else &#123;</span><br><span class="line">   				matrix(&quot;1&quot;, 0, 0, n &#x2F; 2);</span><br><span class="line">   				matrix(&quot;2&quot;, 0, n &#x2F; 2, n &#x2F; 2);</span><br><span class="line">   				matrix(&quot;3&quot;, n &#x2F; 2, 0, n &#x2F; 2);</span><br><span class="line">   				matrix(&quot;4&quot;, n &#x2F; 2, n &#x2F; 2, n &#x2F; 2);</span><br><span class="line">   				ten();</span><br><span class="line">   			&#125;</span><br><span class="line">   			</span><br><span class="line">   			</span><br><span class="line">   			sort(number.begin(), number.end());</span><br><span class="line">   			if (!number.empty()) &#123;</span><br><span class="line">   				for (int i &#x3D; 0; i &lt; number.size(); i++)</span><br><span class="line">   				&#123;</span><br><span class="line">   					cout &lt;&lt; number[i];</span><br><span class="line">   					if ((i + 1) % 12 &#x3D;&#x3D; 0||i&#x3D;&#x3D;number.size()-1) cout &lt;&lt; endl;</span><br><span class="line">   					else cout &lt;&lt; &quot; &quot;;</span><br><span class="line">   				&#125;</span><br><span class="line">   			&#125;</span><br><span class="line">   </span><br><span class="line">   			cout &lt;&lt; &quot;Total number of black nodes &#x3D; &quot; &lt;&lt; number.size() &lt;&lt; endl;    			</span><br><span class="line">   		&#125;</span><br><span class="line"></span><br><span class="line">   		if (n &lt; 0) &#123;</span><br><span class="line">   </span><br><span class="line">   			string s;</span><br><span class="line">   			bool flag &#x3D; false;</span><br><span class="line">   			bool zero &#x3D; false;</span><br><span class="line">   			for (;;) &#123;</span><br><span class="line">   				int a;</span><br><span class="line">   				&#x2F;&#x2F;由于输入的结束标志-1不一定出现在哪里，所以</span><br><span class="line">				&#x2F;&#x2F;要设置标志</span><br><span class="line">   				for (int i &#x3D; 0; i &lt; 12; i++) &#123;</span><br><span class="line">   					cin &gt;&gt; a;</span><br><span class="line">   					if (a &#x3D;&#x3D; -1) &#123;</span><br><span class="line">   						flag &#x3D; true;</span><br><span class="line">   						break;</span><br><span class="line">   					&#125;</span><br><span class="line">   					if (a &#x3D;&#x3D; 0)zero &#x3D; true;</span><br><span class="line">   					number.push_back(a);</span><br><span class="line">   				&#125;</span><br><span class="line">   				if (flag) break;</span><br><span class="line">   			&#125;	</span><br><span class="line">   			if (zero) &#123;</span><br><span class="line">			&#x2F;&#x2F;如果包含0，代表它是一个只有一个节点的树</span><br><span class="line">   				memset(g, &#39;*&#39;, sizeof(g));</span><br><span class="line">   			&#125;</span><br><span class="line">   			else &#123;</span><br><span class="line">   				five();</span><br><span class="line">   				for (int i &#x3D; 0; i &lt; pre.size(); i++) &#123;</span><br><span class="line">   					int p &#x3D; 0;</span><br><span class="line">   					draw(pre[i], p, 0, 0, abs(n));</span><br><span class="line">   				&#125;</span><br><span class="line">   			&#125;</span><br><span class="line">   			</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   			for (int i &#x3D; 0; i &lt; abs(n); i++) &#123;</span><br><span class="line">   				for (int j &#x3D; 0; j &lt; abs(n); j++)</span><br><span class="line">   					cout &lt;&lt; g[i][j];</span><br><span class="line">   				cout &lt;&lt; endl;</span><br><span class="line">   			&#125;</span><br><span class="line">   		&#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="judge-判断r，c为起点的边长为w的正方形中是否权威ch色"><a href="#judge-判断r，c为起点的边长为w的正方形中是否权威ch色" class="headerlink" title="judge 判断r，c为起点的边长为w的正方形中是否权威ch色"></a>judge 判断r，c为起点的边长为w的正方形中是否权威ch色</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  bool judge(int r, int c, int w,char ch) &#123;</span><br><span class="line">&#x2F;&#x2F; ch为0代表是否纯黑，为1代表是否纯白</span><br><span class="line">  	for (int i &#x3D; r; i &lt; r + w; i++)</span><br><span class="line">  		for (int j &#x3D; c; j &lt; c + w; j++)</span><br><span class="line">  			if (g[i][j] &#x3D;&#x3D; ch)</span><br><span class="line">  				return false;</span><br><span class="line">  	return true;	&#x2F;&#x2F;任何情况下都要有return否则会RE</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="matrix-递归记录路径信息，当遇到纯黑的块时，递归返回"><a href="#matrix-递归记录路径信息，当遇到纯黑的块时，递归返回" class="headerlink" title="matrix 递归记录路径信息，当遇到纯黑的块时，递归返回"></a>matrix 递归记录路径信息，当遇到纯黑的块时，递归返回</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void matrix(string str, int r, int c, int w) &#123;</span><br><span class="line">	</span><br><span class="line">	if (judge(r, c, w,&#39;0&#39;)) &#123;</span><br><span class="line">		pre.push_back(str);	&#x2F;&#x2F;纯黑则递归到头，将序列保存</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (judge(r, c, w,&#39;1&#39;)) return;</span><br><span class="line">	else &#123;</span><br><span class="line">		matrix(str + &quot;1&quot;, r, c, w &#x2F; 2);</span><br><span class="line">		matrix(str + &quot;2&quot;, r, c + w &#x2F; 2, w &#x2F; 2);</span><br><span class="line">		matrix(str + &quot;3&quot;, r + w &#x2F; 2, c, w &#x2F; 2);</span><br><span class="line">		matrix(str + &quot;4&quot;, r + w &#x2F; 2, c + w &#x2F; 2, w &#x2F; 2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ten-将五进制的路径信息转成转十进制数"><a href="#ten-将五进制的路径信息转成转十进制数" class="headerlink" title="ten 将五进制的路径信息转成转十进制数"></a>ten 将五进制的路径信息转成转十进制数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void ten() &#123;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; pre.size(); i++) &#123;</span><br><span class="line">		int temp &#x3D; 0;</span><br><span class="line">		for (int j &#x3D; pre[i].size() - 1; j &gt;&#x3D; 0; j--)</span><br><span class="line">			temp +&#x3D; (pre[i][j] - &#39;0&#39;)*pow(5, j);</span><br><span class="line">		number.push_back(temp);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="draw-在r-c开始边长为w范围内填充s-p-开始的颜色"><a href="#draw-在r-c开始边长为w范围内填充s-p-开始的颜色" class="headerlink" title="draw 在r,c开始边长为w范围内填充s[p]开始的颜色"></a>draw 在r,c开始边长为w范围内填充s[p]开始的颜色</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void draw(const string s, int &amp;p, int r, int c, int w) &#123;</span><br><span class="line"></span><br><span class="line">	if (p &#x3D;&#x3D; s.length()) return;</span><br><span class="line">	char ch &#x3D; s[p++];</span><br><span class="line">	switch (ch - &#39;0&#39;)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	case 1:	draw(s, p, r, c, w &#x2F; 2); break;</span><br><span class="line">	case 2: draw(s, p, r, c + w &#x2F; 2, w &#x2F; 2); break;</span><br><span class="line">	case 3:	draw(s, p, r + w &#x2F; 2, c, w &#x2F; 2); break;</span><br><span class="line">	case 4:	draw(s, p, r + w &#x2F; 2, c + w &#x2F; 2, w &#x2F; 2); break;</span><br><span class="line">	default:</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	if (ch &#x3D;&#x3D; &#39;*&#39;) &#123;</span><br><span class="line">		for (int i &#x3D; r; i &lt; r + w; i++)</span><br><span class="line">			for (int j &#x3D; c; j &lt; c + w; j++) &#123;</span><br><span class="line">				</span><br><span class="line">					g[i][j] &#x3D; &#39;*&#39;;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="five-将10进制数转成五进制路径信息"><a href="#five-将10进制数转成五进制路径信息" class="headerlink" title="five 将10进制数转成五进制路径信息"></a>five 将10进制数转成五进制路径信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> void five() &#123;</span><br><span class="line"> 	for (int i &#x3D; 0; i &lt; number.size(); i++) &#123;</span><br><span class="line"> 		int temp &#x3D; 0;</span><br><span class="line"> 		while (number[i]) &#123;</span><br><span class="line"> 			temp *&#x3D; 10;		&#x2F;&#x2F;注意此处要先乘10</span><br><span class="line"> 			temp +&#x3D; number[i] % 5;</span><br><span class="line"> 			number[i] &#x3D; number[i] &#x2F; 5;</span><br><span class="line"> 		&#125;</span><br><span class="line"> </span><br><span class="line"> 		pre.push_back(to_string(temp) + &#39;*&#39;);</span><br><span class="line">&#x2F;&#x2F;加*以标识叶子</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li>本题加深了对递归问题的理解，使用递归算法也不是仅仅用递归实现，要搭配循环，减小递归代码的编写难度。</li>
<li>理清思路再写递归，注意认清递归结束条件，不要模糊。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E9%9B%86%E5%90%88%E6%A0%88%E8%AE%A1%E7%AE%97%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E9%9B%86%E5%90%88%E6%A0%88%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="post-title-link" itemprop="url">集合栈计算机</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-20 11:48:55" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-01 10:22:31" itemprop="dateModified" datetime="2020-02-01T10:22:31+08:00">2020-02-01</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVA-12096-※集合栈计算机※"><a href="#UVA-12096-※集合栈计算机※" class="headerlink" title="UVA 12096 ※集合栈计算机※"></a>UVA 12096 ※集合栈计算机※</h1><p> 输入的命令有如下几种： PUSH：将空集{}压栈 DUP：将栈顶元素复制一份压入栈中 UNION：先进行两次弹栈，将获得的集合A和B取并集，将结果压栈 INTERSECTION：先进行两次弹栈，将获得的集合A和B取交集，将结果压栈 ADD：先进行两次弹栈，将获得的集合A和B中，先出栈的集合（如A先）加入到后出栈的集合，将结果压栈 输出每一步操作后栈顶集合的元素的个数。<br>（输入：先输入测试次数，再输入操作次数，再输入具体操作）</p>
<pre><code>Sample Input
2
9
PUSH
DUP
ADD
PUSH
ADD
DUP
ADD
DUP
UNION
5
PUSH
PUSH
ADD
PUSH
INTERSECT

Sample Output
0
0
1
0
1
1
2
***
0
0
1
0
0</code></pre><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>首先考虑集合的存储问题：由于有集合作为元素插入到另一个集合的情况，所以不能直接定义集合类型的栈。考虑将集合映射到值(map)，另用一个向量存集合本身。</li>
<li>按照题干输入输出判断操作即可。注意后三种操作可以合并简化代码</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><ol>
<li>set_union(A.begin(),A.end(),B.begin(),B.end(),inserter( C1 , C1.begin() ) );前四个参数依次是第一的集合的头尾，第二个集合的头尾。第五个参数的意思是将集合A、B取合集后的结果存入集合C中。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    # define ALL(x) x.begin(),x.end()</span><br><span class="line">    # define INS(x) inserter(x,x.begin())</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;INS(x)插入迭代器，插入而非覆盖</span><br><span class="line">[inserter](https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_37456764&#x2F;article&#x2F;details&#x2F;83019250).</span><br><span class="line"></span><br><span class="line">    using namespace std;</span><br><span class="line">    typedef set&lt;int&gt; Set;</span><br><span class="line">    map&lt;Set, int&gt; id;&#x2F;&#x2F;将每个集合对应一个编号，编号是在向量中的下标</span><br><span class="line">    vector&lt;Set&gt; Setcache;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	while (n--) &#123;</span><br><span class="line">		int m;</span><br><span class="line">		cin &gt;&gt; m;</span><br><span class="line">		stack&lt;int&gt; s;</span><br><span class="line">		while (m--) &#123;</span><br><span class="line">			string op;</span><br><span class="line">			cin &gt;&gt; op;</span><br><span class="line">			if (op[0] &#x3D;&#x3D; &#39;P&#39;) s.push(ID(Set()));</span><br><span class="line">			&#x2F;&#x2F;空集入栈，注意此处空集的写法</span><br><span class="line">			else if (op[0] &#x3D;&#x3D; &#39;D&#39;) s.push(s.top());</span><br><span class="line">			else &#123;</span><br><span class="line">				Set x1 &#x3D; Setcache[s.top()]; s.pop();</span><br><span class="line">				&#x2F;&#x2F;不同直接用pop赋值，因为pop的返回值为void</span><br><span class="line">				Set x2 &#x3D; Setcache[s.top()]; s.pop();</span><br><span class="line">				Set x;</span><br><span class="line">				if (op[0] &#x3D;&#x3D; &#39;U&#39;) set_union(ALL(x1), ALL(x2), INS(x));</span><br><span class="line">				if (op[0] &#x3D;&#x3D; &#39;I&#39;) set_intersection(ALL(x1), ALL(x2), INS(x));</span><br><span class="line">				if (op[0] &#x3D;&#x3D; &#39;A&#39;) &#123; x &#x3D; x2; x.insert(ID(x1)); &#125;</span><br><span class="line">				s.push(ID(x));</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; Setcache[s.top()].size() &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;***&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ID-既是插入又是查询"><a href="#ID-既是插入又是查询" class="headerlink" title="ID  既是插入又是查询"></a>ID  既是插入又是查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int ID(Set x) &#123;</span><br><span class="line">	if (id.count(x)) return id[x];&#x2F;&#x2F;存在则返回id</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;不存在则添加</span><br><span class="line">	Setcache.push_back(x);</span><br><span class="line">	return id[x] &#x3D; Setcache.size() - 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li>本题主要注重多种STL的结合使用，尤其是集合映射为整型的处理方式</li>
<li>记住题中交并集的函数，set_union(参数为5个迭代器),set_intersection(参数为5个迭代器);要配合两处define使用</li>
<li>注意模拟多种操作时提取相同部分简化代码，也降低出错的可能性和调试难度。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E9%BB%84%E9%87%91%E5%9B%BE%E5%BD%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E9%BB%84%E9%87%91%E5%9B%BE%E5%BD%A2/" class="post-title-link" itemprop="url">黄金图形</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-20 11:48:55" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-02 23:35:02" itemprop="dateModified" datetime="2020-02-02T23:35:02+08:00">2020-02-02</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVA-225-黄金图形"><a href="#UVA-225-黄金图形" class="headerlink" title="UVA 225 黄金图形"></a>UVA 225 黄金图形</h1><p>平面上有k个障碍点。 从(0,0)点出发，第一次走1个单位，第二次走2个单位，……， 第n次走n个单位，恰好回到(0,0)。 要求只能沿着东南西北方向走，且每次必须转弯90°（不能沿着同一个方向继续走，也不能后退）。 走出的图形可以自交，但不能经过障碍点，如图 7-25所示。每个转折点只能走一次。 输入n、k（1≤n≤20，0≤k≤50）和所有障碍点的坐标，输出所有满足要求的移动序列（用 news表示北、东、西、南），按照字典序从小到大排列，最后输出移动序列的总数。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>又要输出所有的路径，所以直观的想到用dfs。dfs中处理好可以移动的方向即可。</li>
<li>本题的特殊之处在于，障碍格可能出现负坐标。由于本题中最长边长n小于等于20，所以采用给(0,0)点以及障碍物点加一个比较大的值来消负号。我是假设n=20，那么一共也就能走1+2+…20/2=105，所以我加了一个120.</li>
<li>注意：卡了很久的原因主要是题干中要求最长边等于n，这条件不仅是限定搜索深度的。他还要求必须包含长度为n的边。</li>
<li>注意每个转折点只能走一次的条件。这个转折点是指每一步走完之后的终点。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 20;</span><br><span class="line">void dfs(int r, int c, int dir, int step);</span><br><span class="line">int dx[] &#x3D; &#123; 1,0,0,-1 &#125;;&#x2F;&#x2F;东北南西</span><br><span class="line">int dy[] &#x3D; &#123; 0,1,-1,0 &#125;;</span><br><span class="line">int cnt, n;</span><br><span class="line">bool g[maxn * maxn + 1][maxn * maxn + 1];</span><br><span class="line">char direction[] &#x3D; &#123; &#39;e&#39;,&#39;n&#39;,&#39;s&#39;,&#39;w&#39; &#125;;&#x2F;&#x2F;此处元素顺序是为了按字典序进行搜索,注意dx和dy要与此处配合</span><br><span class="line">int path[maxn*maxn];</span><br><span class="line">bool vis[maxn*maxn + 1][maxn*maxn+ 1];</span><br><span class="line">int stax, stay;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int T;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">int k;</span><br><span class="line">while (T--)</span><br><span class="line">&#123;</span><br><span class="line">	int x, y;</span><br><span class="line">	memset(g, 1, sizeof(g));</span><br><span class="line">	memset(path, 0, sizeof(path));</span><br><span class="line">	</span><br><span class="line">	scanf(&quot;%d\n%d&quot;, &amp;n, &amp;k);</span><br><span class="line">	vector&lt;int&gt; tmpx;</span><br><span class="line">	vector&lt;int&gt; tmpy;</span><br><span class="line">	stax &#x3D; stay &#x3D; 120;</span><br><span class="line">	cnt &#x3D; 0;</span><br><span class="line">	while (k--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d %d&quot;, &amp;x, &amp;y);</span><br><span class="line">		g[x + stax][y + stay] &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		dfs(stax, stay, i, 1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;Found %d golygon(s).\n\n&quot;, cnt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dfs-从-r-c-处开始沿着dir方向走step步，注意要先走再判断"><a href="#dfs-从-r-c-处开始沿着dir方向走step步，注意要先走再判断" class="headerlink" title="dfs 从(r,c)处开始沿着dir方向走step步，注意要先走再判断"></a>dfs 从(r,c)处开始沿着dir方向走step步，注意要先走再判断</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void dfs(int r, int c, int dir, int step) &#123;</span><br><span class="line">path[step] &#x3D; dir;</span><br><span class="line">for (int i &#x3D; 0; i &lt; step; i++) &#123;</span><br><span class="line">	r +&#x3D; dx[dir];</span><br><span class="line">	c +&#x3D; dy[dir];</span><br><span class="line">	if (!g[r][c] || r &lt; 0 || c &lt; 0 ) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (vis[r][c]) return;</span><br><span class="line">if (step &gt;&#x3D; n) &#123;</span><br><span class="line">	if (r &#x3D;&#x3D; (stax) &amp;&amp; c &#x3D;&#x3D; (stay)) &#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; step; i++)</span><br><span class="line">			printf(&quot;%c&quot;, direction[path[i]]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vis[r][c] &#x3D; 1;</span><br><span class="line">if (dir &#x3D;&#x3D; 0 || dir &#x3D;&#x3D; 3) &#123;</span><br><span class="line">	dfs(r, c, 1, step + 1);</span><br><span class="line">	dfs(r, c, 2, step + 1);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">	dfs(r, c, 0, step + 1);</span><br><span class="line">	dfs(r, c, 3, step + 1);</span><br><span class="line">&#125;</span><br><span class="line">vis[r][c] &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%87%8D%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%87%8D%E5%BB%BA/" class="post-title-link" itemprop="url">二叉树的重建</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:47:08" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uva-536-二叉树的重建-先中造树"><a href="#uva-536-二叉树的重建-先中造树" class="headerlink" title="uva 536 二叉树的重建 (先中造树)"></a>uva 536 二叉树的重建 (先中造树)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">   #include&lt;string&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;习题6-3in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;习题6-3out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   typedef struct node &#123;</span><br><span class="line">   	struct node *lchild, *rchild;</span><br><span class="line">   	char data;</span><br><span class="line">   &#125;node, *ptr;</span><br><span class="line">   ptr Create(char *pre, char *in, int n)</span><br><span class="line">   &#123;</span><br><span class="line">   	ptr s;</span><br><span class="line">   </span><br><span class="line">   	if (n &#x3D;&#x3D; 1)</span><br><span class="line">   	&#123;</span><br><span class="line">   		s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">   		s-&gt;data &#x3D; *pre;</span><br><span class="line">   		s-&gt;lchild &#x3D; s-&gt;rchild &#x3D; NULL;</span><br><span class="line">   		return s;</span><br><span class="line">   	&#125;</span><br><span class="line">   	char *p;</span><br><span class="line">   	for (p &#x3D; in; p &lt; in + n; p++)</span><br><span class="line">   		if (*p &#x3D;&#x3D; *pre) break;</span><br><span class="line">   	int k &#x3D; p - in;</span><br><span class="line">   	s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">   	s-&gt;data &#x3D; *p;</span><br><span class="line">   	s-&gt;lchild &#x3D; s-&gt;rchild &#x3D; NULL;</span><br><span class="line">   	if (k) s-&gt;lchild &#x3D; Create(pre + 1, in, k);</span><br><span class="line">   	if (n - k - 1) s-&gt;rchild &#x3D; Create(pre + k + 1, p + 1, n - k - 1);</span><br><span class="line">   	return s;</span><br><span class="line">   &#125;</span><br><span class="line">   int lastorder(ptr T)</span><br><span class="line">   &#123;</span><br><span class="line">   	if (!T) return 0;</span><br><span class="line">   	lastorder(T-&gt;lchild);</span><br><span class="line">   	lastorder(T-&gt;rchild);</span><br><span class="line">   	printf(&quot;%c&quot;, T-&gt;data);</span><br><span class="line">   	return 1;</span><br><span class="line">   &#125;</span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">   </span><br><span class="line">   	string pre, in;</span><br><span class="line">   	while (cin &gt;&gt; pre &gt;&gt; in) &#123;</span><br><span class="line">   		int n &#x3D; pre.length();</span><br><span class="line">   		ptr T &#x3D; Create(&amp;pre[0], &amp;in[0], n);</span><br><span class="line">   		lastorder(T);</span><br><span class="line">   		cout &lt;&lt; endl;</span><br><span class="line">   	&#125;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cuienbo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">159</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cuienbo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.0
  </div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
  
</body>
</html>
