<!DOCTYPE html>


<html lang="en" >


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Hexo
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

  <script type="text/javascript"
	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-木块问题" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E6%9C%A8%E5%9D%97%E9%97%AE%E9%A2%98/"
    >木块问题</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E6%9C%A8%E5%9D%97%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-03-30T02:15:00.654Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="UVa101-木块游戏"><a href="#UVa101-木块游戏" class="headerlink" title="UVa101 木块游戏"></a>UVa101 木块游戏</h1><h3 id="输入n，得到编号为0n-1的木块，分别摆放在顺序排列编号为0n-1的位置。现对这些木块进行操作，操作分为四种"><a href="#输入n，得到编号为0n-1的木块，分别摆放在顺序排列编号为0n-1的位置。现对这些木块进行操作，操作分为四种" class="headerlink" title="输入n，得到编号为0n-1的木块，分别摆放在顺序排列编号为0n-1的位置。现对这些木块进行操作，操作分为四种:"></a>输入n，得到编号为0<del>n-1的木块，分别摆放在顺序排列编号为0</del>n-1的位置。现对这些木块进行操作，操作分为四种:</h3><h3 id="1、move-a-onto-b：把木块a、b上的木块放回各自的原位，再把a放到b上；"><a href="#1、move-a-onto-b：把木块a、b上的木块放回各自的原位，再把a放到b上；" class="headerlink" title="1、move a onto b：把木块a、b上的木块放回各自的原位，再把a放到b上；"></a>1、move a onto b：把木块a、b上的木块放回各自的原位，再把a放到b上；</h3><h3 id="2、move-a-over-b：把a上的木块放回各自的原位，再把a发到含b的堆上；"><a href="#2、move-a-over-b：把a上的木块放回各自的原位，再把a发到含b的堆上；" class="headerlink" title="2、move a over b：把a上的木块放回各自的原位，再把a发到含b的堆上；"></a>2、move a over b：把a上的木块放回各自的原位，再把a发到含b的堆上；</h3><h3 id="3、pile-a-onto-b：把b上的木块放回各自的原位，再把a连同a上的木块移到b上；"><a href="#3、pile-a-onto-b：把b上的木块放回各自的原位，再把a连同a上的木块移到b上；" class="headerlink" title="3、pile a onto b：把b上的木块放回各自的原位，再把a连同a上的木块移到b上；"></a>3、pile a onto b：把b上的木块放回各自的原位，再把a连同a上的木块移到b上；</h3><h3 id="4、pile-a-over-b：把a连同a上木块移到含b的堆上。"><a href="#4、pile-a-over-b：把a连同a上木块移到含b的堆上。" class="headerlink" title="4、pile a over b：把a连同a上木块移到含b的堆上。"></a>4、pile a over b：把a连同a上木块移到含b的堆上。</h3><h3 id="当输入quit时，结束操作并输出0-n-1的位置上的木块情况"><a href="#当输入quit时，结束操作并输出0-n-1的位置上的木块情况" class="headerlink" title="当输入quit时，结束操作并输出0~n-1的位置上的木块情况"></a>当输入quit时，结束操作并输出0~n-1的位置上的木块情况</h3><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>10</p>
<p>move 9 onto 1</p>
<p>move 8 over 1</p>
<p>move 7 over 1</p>
<p>move 6 over 1</p>
<p>pile 8 over 6</p>
<p>pile 8 over 5</p>
<p>move 2 over 1</p>
<p>move 4 over 9</p>
<p>quit</p>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p> 0: 0</p>
<p> 1: 1 9 2 4</p>
<p> 2:</p>
<p> 3: 3</p>
<p> 4:</p>
<p> 5: 5 8 7 6</p>
<p> 6:</p>
<p> 7:</p>
<p> 8:</p>
<p> 9:</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h3 id="通过四种指令的描述，可以注意到，move指令与把a上的木块全部归位相联系；onto指令与把b上方的木块归位相联系；并且每条指令都包含把a-或a的上方的木块-移动到b上方的部分；因此，应该对应以上三点来写各模块；"><a href="#通过四种指令的描述，可以注意到，move指令与把a上的木块全部归位相联系；onto指令与把b上方的木块归位相联系；并且每条指令都包含把a-或a的上方的木块-移动到b上方的部分；因此，应该对应以上三点来写各模块；" class="headerlink" title="通过四种指令的描述，可以注意到，move指令与把a上的木块全部归位相联系；onto指令与把b上方的木块归位相联系；并且每条指令都包含把a(或a的上方的木块)移动到b上方的部分；因此，应该对应以上三点来写各模块；"></a>通过四种指令的描述，可以注意到，move指令与把a上的木块全部归位相联系；onto指令与把b上方的木块归位相联系；并且每条指令都包含把a(或a的上方的木块)移动到b上方的部分；因此，应该对应以上三点来写各模块；</h3><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="模块一"><a href="#模块一" class="headerlink" title="模块一"></a>模块一</h2><p>查找编号为a的木块所在堆和高度，用引用传递</p>
<pre><code>void find(int a, int &amp;pa, int &amp;h) {
    for (pa = 0; pa &lt; n; pa++) {
        for (h = 0; h &lt; p[pa].size(); h++) {
            if (p[pa][h] == a) return;
        }
    }
}</code></pre><h2 id="模块二"><a href="#模块二" class="headerlink" title="模块二"></a>模块二</h2><p>把a堆高度为h的木块的所有木块归位。注意，本题中的归位是把a放回初始的堆里即可，不考虑初始高度。</p>
<pre><code> void clear_above(int a, int h) {
        for (int i = h + 1; i &lt; p[a].size(); i++) {
            p[p[a][i]].push_back(p[a][i]);
        }
        p[a].resize(h + 1);
}</code></pre><h2 id="模块三"><a href="#模块三" class="headerlink" title="模块三"></a>模块三</h2><p>把p堆高度为h及其上方的木块整体移动到p2堆顶:1.移动2.截断</p>
<pre><code>void pile_onto(int p1, int h, int p2) {

for (int i = h; i &lt; p[p1].size(); i++) {
    p[p2].push_back(p[p1][i]);
}
p[p1].resize(h);
}</code></pre><h2 id="模块四"><a href="#模块四" class="headerlink" title="模块四"></a>模块四</h2><p>输出各堆的序列</p>
<pre><code>void print(){
for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; i &lt;&lt; &quot;:&quot;;
    for (int j = 0; j &lt; p[i].size(); j++) {
        cout &lt;&lt; &quot; &quot; &lt;&lt; p[i][j];
    }
    cout &lt;&lt; endl;
}
}</code></pre><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><pre><code>int main() {
cin &gt;&gt; n;
for (int i = 0; i &lt; n; i++) p[i].push_back(i);
string s1, s2;
int a, b;
while (cin &gt;&gt; s1 &gt;&gt; a &gt;&gt; s2 &gt;&gt; b) {
    int pa, pb, ha, hb;
    find(a, pa, ha);
    find(b, pb, hb);
    if (pa == pb) continue;//非法指令

    if (s1 == &quot;move&quot;) clear_above(pa, ha);
    if (s2 == &quot;onto&quot;) clear_above(pb, hb);
    pile_onto(pa, ha, pb);
}
print();
return 0;
}</code></pre><h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><ol>
<li>本题应主要学习他的拆分思路,以及引用传递的运用。</li>
<li>学习vector类，vector<typename> xname;</li>
<li>学习vector的基本方法，push_back(要插入的元素) 和 resize(元素个数);</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-流水线调度" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%B0%83%E5%BA%A6/"
    >流水线调度</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%B0%83%E5%BA%A6/" class="article-date">
  <time datetime="2020-03-30T02:15:00.654Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="UVA-690-流水线调度"><a href="#UVA-690-流水线调度" class="headerlink" title="UVA 690 流水线调度"></a>UVA 690 流水线调度</h1><p>题目大意：有10个任务，5个管道，每个任务需要占用不同时间的管道，给出任务所占用管道的时间，求最短需要多少时间。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>框架是dfs，且存在明显的深度上限10*n。通过枚举每个程序的起始点选择出最优解</p>
</li>
<li><p>如果不适用二进制法，那么循环遍历状态，判断每个段是否正被占用会消耗大量的时间，导致TLE</p>
</li>
<li><p>关于剪枝：</p>
<ol>
<li>即使剩余的程序都按照最好的情况执行也比目前的最优解慢，那么直接剪掉</li>
</ol>
</li>
<li><p>剪枝依然TLE，所以不能从头开始枚举起始点。故进行预处理。循环枚举相邻两个程序起始点间的间隔，判断有无段冲突，若没有，则记录这个间隔。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">c &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; n; i++)&#x2F;&#x2F;枚举两个程序起始点的间隔</span><br><span class="line">	if (judge(w, i)) &#123;</span><br><span class="line">		jump[c++] &#x3D; i;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="judge-判断在状态s下，相邻两个程序起始点间隔为k是否会导致冲突"><a href="#judge-判断在状态s下，相邻两个程序起始点间隔为k是否会导致冲突" class="headerlink" title="judge 判断在状态s下，相邻两个程序起始点间隔为k是否会导致冲突"></a>judge 判断在状态s下，相邻两个程序起始点间隔为k是否会导致冲突</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool judge(const int *s, int k) &#123;&#x2F;&#x2F;判断相邻的两个程序间隔k的时间片时</span><br><span class="line">							&#x2F;&#x2F;是否会冲突</span><br><span class="line">for (int i &#x3D; 0; i &lt; 5; i++)</span><br><span class="line">	if ((s[i] &gt;&gt; k)&amp;w[i]) return false;</span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void dfs(int d, int time, const int *s) &#123;</span><br><span class="line">if (time + (10 - d) *jump[0] &gt;&#x3D; ans) return;</span><br><span class="line">if (d &#x3D;&#x3D; 10) &#123;</span><br><span class="line">	ans &#x3D; min(ans, time);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 0; i &lt; c; i++) &#123;</span><br><span class="line">	if (judge(s, jump[i])) &#123;</span><br><span class="line">		int p[5];</span><br><span class="line">		for (int j &#x3D; 0; j &lt; 5; j++)</span><br><span class="line">			p[j] &#x3D; (s[j] &gt;&gt; jump[i]) ^ w[j];</span><br><span class="line"></span><br><span class="line">&gt; 尝试每一种间隔，如果不冲突，那么更新状态到p，p的二进制形式相当于s的二进制形式中1复制到右一位处 </span><br><span class="line"></span><br><span class="line">		dfs(d + 1, jump[i] + time, p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="init-初始化"><a href="#init-初始化" class="headerlink" title="init 初始化"></a>init 初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">ans &#x3D; 10 * n;</span><br><span class="line">memset(w, 0, sizeof(w));</span><br><span class="line">char s[maxn];</span><br><span class="line">for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">	scanf(&quot;%s&quot;, s);</span><br><span class="line">	for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">		if (s[j] &#x3D;&#x3D; &#39;X&#39;) &#123;</span><br><span class="line">			w[i] |&#x3D; (1 &lt;&lt; j);&#x2F;&#x2F;记录初始状态</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">c &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; n; i++)&#x2F;&#x2F;枚举两个程序起始点的间隔</span><br><span class="line">	if (judge(w, i)) &#123;</span><br><span class="line">		jump[c++] &#x3D; i;</span><br><span class="line">	&#125;</span><br><span class="line">dfs(1, n, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int M &#x3D; 100;</span><br><span class="line">const int maxn &#x3D; 20;</span><br><span class="line">int n, c, ans, w[5], jump[M];</span><br><span class="line"></span><br><span class="line">inline bool judge(const int *s, int k);</span><br><span class="line">void dfs(int d, int time, const int *s);</span><br><span class="line">inline void init();</span><br><span class="line">int main() &#123;</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)</span><br><span class="line">&#123;</span><br><span class="line">	init();</span><br><span class="line">	printf(&quot;%d\n&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-理想路径" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E7%90%86%E6%83%B3%E8%B7%AF%E5%BE%84/"
    >理想路径</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E7%90%86%E6%83%B3%E8%B7%AF%E5%BE%84/" class="article-date">
  <time datetime="2020-03-30T02:15:00.654Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="UVA-1599-理想路径"><a href="#UVA-1599-理想路径" class="headerlink" title="UVA 1599 理想路径"></a>UVA 1599 理想路径</h1><p>给定一个n个点m条边的无向图，每条边上都涂有1种颜色。求11到点n的一条路径，使得经过的边数最少，在此前提下，经过边的颜色序列最小。可能有自环与重边。输入保证至少存在一条连接1和n的道路。</p>
<p>输入共m+1行：</p>
<p>第一行2个空格整数：n和m</p>
<p>以后m行，每行空格隔开的3个整数ai,bi,ci表示在ai,bi之间有一条颜色为ci的道路。</p>
<p>输出路径序列</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>整体来说，还是无向图最短路问题，使用bfs求解。</li>
<li>问题在于路径选择需要选择字典序最小的序列，而bfs过程中并不能知道哪条路是最短的，所以无法一次性求解。</li>
<li>解决方法是从n点开始bfs，记录到其余各点的最小距离。之后再从头进行一次bfs，每次只走距离n点距离恰好减一的点走，并在其中选择字典序最小的走，这样一定走的是最短路，并且路径字典序最小。</li>
<li>为了减少队列占用的空间，实现是队列中存的是边的序号，应该关注这种写法</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="addEdge-给新加入的边一个序号"><a href="#addEdge-给新加入的边一个序号" class="headerlink" title="addEdge 给新加入的边一个序号"></a>addEdge 给新加入的边一个序号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;edge&gt; E;</span><br><span class="line">vector&lt;int&gt; g[maxn];</span><br><span class="line">void addEdge(int u, int v, int w) &#123;</span><br><span class="line">	E.push_back(edge(u, v, w));</span><br><span class="line">	int size &#x3D; E.size() - 1;</span><br><span class="line">	g[u].push_back(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bfs-end-从尾部开始的bfs，常规"><a href="#bfs-end-从尾部开始的bfs，常规" class="headerlink" title="bfs_end 从尾部开始的bfs，常规"></a>bfs_end 从尾部开始的bfs，常规</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bool vis[maxn];</span><br><span class="line">int d[maxn];</span><br><span class="line">void bfs_end() &#123;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	d[n] &#x3D; 0;</span><br><span class="line">	vis[n] &#x3D; 1;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	q.push(n);</span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		int u &#x3D; q.front(); q.pop();</span><br><span class="line">		for (int i : g[u]) &#123;</span><br><span class="line">			int v &#x3D; E[i].b;</span><br><span class="line">			if (!vis[v])</span><br><span class="line">			&#123;</span><br><span class="line">				vis[v] &#x3D; 1;</span><br><span class="line">				d[v] &#x3D; d[u] + 1;</span><br><span class="line">				q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bfs-sta-从正向开始bfs"><a href="#bfs-sta-从正向开始bfs" class="headerlink" title="bfs_sta 从正向开始bfs"></a>bfs_sta 从正向开始bfs</h2><p>此处tmp中包含了字典序最小的点，只有当真正走出这一步时，vis[i]才置1(即入队的时候)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; ans;</span><br><span class="line">void bfs_sta() &#123;</span><br><span class="line">	ans.clear();</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	vis[1] &#x3D; 1;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	q.push(1);</span><br><span class="line">	vector&lt;int&gt; tmp;</span><br><span class="line">	int minn;</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		minn &#x3D; inf;</span><br><span class="line">		tmp.clear();</span><br><span class="line">		while (!q.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			int u &#x3D; q.front(); q.pop();</span><br><span class="line">			if (u &#x3D;&#x3D; n) return;</span><br><span class="line">			for (int i : g[u]) &#123;</span><br><span class="line">				int v &#x3D; E[i].b;</span><br><span class="line">				if (d[v] &#x3D;&#x3D; d[u] - 1) &#123;</span><br><span class="line">					if (E[i].w &lt;&#x3D; minn) &#123;</span><br><span class="line">						minn &#x3D; E[i].w;</span><br><span class="line">						tmp.push_back(i);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ans.push_back(minn);</span><br><span class="line"></span><br><span class="line">		for (int i : tmp) &#123;</span><br><span class="line">			int v &#x3D; E[i].b;</span><br><span class="line">			if (!vis[v] &amp;&amp; E[i].w &#x3D;&#x3D; minn) &#123;</span><br><span class="line">				q.push(v);</span><br><span class="line">				vis[v] &#x3D; 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100000 + 5;</span><br><span class="line">#define inf 1000000000</span><br><span class="line">int n, m;</span><br><span class="line">struct edge &#123;</span><br><span class="line">	int a;</span><br><span class="line">	int b;</span><br><span class="line">	int w;</span><br><span class="line">	edge(int a, int b, int w) :a(a), b(b), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &#x3D;&#x3D; 2) &#123;</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) g[i].clear();</span><br><span class="line">		E.clear();</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			int u, v, w;</span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">			addEdge(u, v, w);</span><br><span class="line">			addEdge(v, u, w);</span><br><span class="line">		&#125;</span><br><span class="line">		bfs_end();</span><br><span class="line">		bfs_sta();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		printf(&quot;%d\n%d&quot;, ans.size(), ans[0]);</span><br><span class="line">		for (int i &#x3D; 1; i &lt; ans.size(); i++)</span><br><span class="line">			printf(&quot; %d&quot;, ans[i]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-联合国大楼" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%81%94%E5%90%88%E5%9B%BD%E5%A4%A7%E6%A5%BC/"
    >联合国大楼</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%81%94%E5%90%88%E5%9B%BD%E5%A4%A7%E6%A5%BC/" class="article-date">
  <time datetime="2020-03-30T02:15:00.654Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="UVA-1605-联合国大楼"><a href="#UVA-1605-联合国大楼" class="headerlink" title="UVA 1605 联合国大楼"></a>UVA 1605 联合国大楼</h1><p>给出有多少个国家 nnn （ n&lt;= 50），需要给每个国家安排办公室。大楼的每一层有着相同的行列数，请你构造一种安排（输出层数，行数和列数），使得每两个国家之间都有一间挨着的办公室，且办公室总数不超过 1000000 ，用不同字母表示不同国家，输出每层楼的安排方法。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>最简单的，一共键两层，每层都是n*n,令第一层全是国家i，第二层第j列全是国家j。这样任何一个国家(行)必能与另一层的所有列相交，所以设计方案一定正确。</li>
<li>使用中途相遇法，从两个不同的方向来解决问题</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 50 + 5;</span><br><span class="line">int f1[maxn][maxn];</span><br><span class="line">int f2[maxn][maxn];</span><br><span class="line">inline char to_alp(int x) &#123; return x &lt; 26 ? x + &#39;A&#39; : &#39;a&#39; + x - 26; &#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int n;</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1) &#123;</span><br><span class="line"></span><br><span class="line">	printf(&quot;2 %d %d\n&quot;, n, n);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">			f1[i][j] &#x3D; i;</span><br><span class="line">			f2[i][j] &#x3D; j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">			printf(&quot;%c&quot;, to_alp(f1[i][j]));</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">			printf(&quot;%c&quot;, to_alp(f2[i][j]));</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-劲歌金曲" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%8A%B2%E6%AD%8C%E9%87%91%E6%9B%B2/"
    >劲歌金曲</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%8A%B2%E6%AD%8C%E9%87%91%E6%9B%B2/" class="article-date">
  <time datetime="2020-03-30T02:15:00.638Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="UVA-12563-劲歌金曲"><a href="#UVA-12563-劲歌金曲" class="headerlink" title="UVA 12563 劲歌金曲"></a>UVA 12563 劲歌金曲</h1><p>(如果当你看到这个标题的时候笑了，那么这个问题是为你准备的ヽ(￣▽￣)ﾉ)<br>如果问一个麦霸：“你在KTV里必唱的曲目有哪些？”得到的答案通常都会包含一首“神曲”：古巨基的《劲歌金曲》。为什么呢？一般来说，KTV不会在“时间到”的时候鲁莽地把正在唱的歌切掉，而是会等它放完。例如：在还有15秒时再唱一首2分钟的歌，则实际上多唱了105秒。但是融合了37首歌曲的《劲歌金曲》长达11分18秒，如果唱这首，则相当于多长了663秒！<br>假设你正在唱KTV，还剩t秒时间。你决定接下来只唱你最爱的n首歌（不含《劲歌金曲》）中的一些，在时间结束之前再唱一个《劲歌金曲》，使得唱的总曲目尽量多（包含《劲歌金曲》），在此前提下尽量晚的离开KTV。<br>输入n(n&lt;=50)，t(t&lt;=10的9次方)和每首歌的长度(保证不超过3分钟)，输出唱的总曲目以及时间总长度。输入保证所有n+1首曲子的总长度严格大于t。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>0-1背包问题</li>
<li>设f[i]表示t容量的包内(时间内)总体积为i时，物品的数量(歌的数量),可以在每次输入新的歌曲时，更新那些能够“装下”这首歌的状态。</li>
<li>注意最后要留一秒来唱劲歌金曲</li>
<li>做的时候蒙住了。f[t-1]不一定是所有状态下的最大值，因为可能达不到刚好装满t-1的状态</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 50 + 5;</span><br><span class="line">const int INF &#x3D; 1000000000;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; d[i][j]: maximal number of songs from first i songs, whose total length is exactly j</span><br><span class="line">int f[maxn * 180 + 678];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	int n, t, ti;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	for (int kase &#x3D; 1; kase &lt;&#x3D; T; kase++) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;n, &amp;t);</span><br><span class="line">		memset(f, -1, sizeof(f));</span><br><span class="line">		f[0] &#x3D; 0;</span><br><span class="line">		for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;ti);</span><br><span class="line">			for (int j &#x3D; t - 1; j &gt;&#x3D; ti; j--)</span><br><span class="line">				f[j] &#x3D; max(f[j], f[j - ti] + 1);</span><br><span class="line">		&#125;</span><br><span class="line">		int ans &#x3D; t - 1;</span><br><span class="line">		for (int i &#x3D; t - 1; i &gt;&#x3D; 0; i--)&#123;</span><br><span class="line">			if (f[i] &gt; f[ans])</span><br><span class="line">				ans &#x3D; i;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line">		printf(&quot;Case %d: %d %d\n&quot;, kase, f[ans] + 1, ans + 678);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="附上刘老师的代码"><a href="#附上刘老师的代码" class="headerlink" title="附上刘老师的代码"></a>附上刘老师的代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const int maxn &#x3D; 50 + 5;</span><br><span class="line">const int INF &#x3D; 1000000000;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; d[i][j]: maximal number of songs from first i songs, whose total length is exactly j</span><br><span class="line">int n, t, len[maxn], d[2][maxn*180+678]; </span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int T;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">  for(int kase &#x3D; 1; kase &lt;&#x3D; T; kase++) &#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;t);</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;len[i]);</span><br><span class="line"></span><br><span class="line">    for(int i &#x3D; 0; i &lt; t; i++) d[0][i] &#x3D; -1;</span><br><span class="line">    d[0][0] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    int p &#x3D; 1, ans &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">      for(int j &#x3D; 0; j &lt; t; j++) &#123;</span><br><span class="line">        d[p][j] &#x3D; d[p^1][j];</span><br><span class="line">        if(j &gt;&#x3D; len[i] &amp;&amp; d[p^1][j - len[i]] &gt;&#x3D; 0)</span><br><span class="line">          d[p][j] &#x3D; max(d[p][j], d[p^1][j - len[i]] + 1);</span><br><span class="line">        ans &#x3D; max(ans, d[p][j]);</span><br><span class="line">      &#125;</span><br><span class="line">      p ^&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i &#x3D; t-1; i &gt;&#x3D; 0; i--)</span><br><span class="line">      if(d[p^1][i] &#x3D;&#x3D; ans) &#123;</span><br><span class="line">        printf(&quot;Case %d: %d %d\n&quot;, kase, ans + 1, i + 678);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-困难的串" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%9B%B0%E9%9A%BE%E7%9A%84%E4%B8%B2/"
    >困难的串</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%9B%B0%E9%9A%BE%E7%9A%84%E4%B8%B2/" class="article-date">
  <time datetime="2020-03-30T02:15:00.638Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="UVA-129-困难的串"><a href="#UVA-129-困难的串" class="headerlink" title="UVA 129 困难的串"></a>UVA 129 困难的串</h1><p>将一个包含两个相邻的重复子串的子串，称为“容易的串”，其他为“困难的串”。 输入正整数n和l,输出由前l个字符组成的，字典序第k小的困难的串。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>输出完整的串，即这条路要走到头，想到用dfs。枚举每个位置处的字符，并判断当前局面的合法性。</li>
<li>合法性：如果扩展到当前处没有导致重复子串的出现即为合法。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	int dfs(int cur) &#123;</span><br><span class="line">	if (cnt++ &#x3D;&#x3D; n) &#123;</span><br><span class="line">		int len &#x3D; 1;</span><br><span class="line">		cout &lt;&lt; char(&#39;A&#39; + S[0]);</span><br><span class="line">		for (int i &#x3D; 1; i &lt; cur; i++) &#123;</span><br><span class="line">			if (i&amp;&amp;i % 4 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				cout &lt;&lt; &quot; &quot;;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; char(&#39;A&#39; + S[i]);</span><br><span class="line">			if (i + 1 &lt; cur) &#123;</span><br><span class="line">				if ((i + 1) % 64 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">					cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">					cout &lt;&lt; char(&#39;A&#39; + S[++i]);</span><br><span class="line">					len++;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			len++;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; l; i++) &#123;</span><br><span class="line">		S[cur] &#x3D; i;</span><br><span class="line">		int ok &#x3D; 1;</span><br><span class="line">		for (int j &#x3D; 1; j * 2 &lt;&#x3D; cur + 1; j++) &#123;</span><br><span class="line">	&gt; 相当于在枚举循环节,关注循环条件</span><br><span class="line">			int equal &#x3D; 1;</span><br><span class="line">			for (int k &#x3D; 0; k &lt; j; k++)</span><br><span class="line">				if (S[cur - k] !&#x3D; S[cur - k - j]) &#123;</span><br><span class="line">					equal &#x3D; 0;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			if (equal) &#123;</span><br><span class="line">	&gt; 如果后一半等于前一半，则不合法</span><br><span class="line">				ok &#x3D; 0;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (ok) if (!dfs(cur + 1)) return 0;</span><br><span class="line">	&gt; 递归的搜索剩余位置</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 80;</span><br><span class="line">int cnt, n, l;</span><br><span class="line">int S[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">while (cin &gt;&gt; n &gt;&gt; l &amp;&amp; n&amp;&amp;l) &#123;</span><br><span class="line">	cnt &#x3D; 0;</span><br><span class="line">	memset(S, 0,sizeof(S));</span><br><span class="line">	dfs(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-快速幂计算" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%A1%E7%AE%97/"
    >快速幂计算</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%A1%E7%AE%97/" class="article-date">
  <time datetime="2020-03-30T02:15:00.638Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="UVA-1374-快速幂计算"><a href="#UVA-1374-快速幂计算" class="headerlink" title="UVA 1374 快速幂计算"></a>UVA 1374 快速幂计算</h1><p>初始有x，问经过多少次乘除可以得到目标值n。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>与埃及积分有相似之处，可以采用迭代加深搜的方法。</p>
</li>
<li><p>通过迭代得出可以得到的幂次，通过深度搜素来凑</p>
</li>
<li><p>关于剪枝</p>
<ol>
<li>根据题意，幂次不允许小于0，幂次=0也没用</li>
<li>如果当前序列的最大数乘以2<sup>maxd-d</sup>&lt;n，则应该剪枝。因为即使剩余的maxd-d层都是乘以当前序列的最大值(即最大的幂次乘以2，即左移一位)仍然小于n，则说明这一支不可能达到n了，故需要剪掉。</li>
</ol>
</li>
<li><p>关于节点排序：为了更快的接近目标，应该优先扩展较大的数，优先加法再试减法。这样可以在最后一次迭代中，无需等待整个解答树扩展完成即可找到解。</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int res[50];</span><br><span class="line">int maxd;</span><br><span class="line">bool dfs(int d, int maxn);</span><br><span class="line">int n;</span><br><span class="line">int main() &#123;</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">	for (maxd &#x3D; 0;; maxd++)</span><br><span class="line">		if (dfs(0, 1)) break;</span><br><span class="line">	printf(&quot;%d\n&quot;, maxd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool dfs(int d, int maxn) &#123;&#x2F;&#x2F;当前的步数d，当前的最大值maxn</span><br><span class="line">if (d &#x3D;&#x3D; maxd)</span><br><span class="line">	if (maxn &#x3D;&#x3D; n || maxn &lt;&lt; (maxd - d) &#x3D;&#x3D; n) return true;</span><br><span class="line">if (maxn &lt;&#x3D; 0 || maxn &lt;&lt; (maxd - d) &lt; n) return false;</span><br><span class="line">res[d] &#x3D; maxn;</span><br><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; d; i++) &#123;</span><br><span class="line">	if (dfs(d + 1, maxn + res[i])) return true;</span><br><span class="line">	if (dfs(d + 1, maxn - res[i])) return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-括号序列" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/"
    >括号序列</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/" class="article-date">
  <time datetime="2020-03-30T02:15:00.638Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="UVA-1626-括号序列"><a href="#UVA-1626-括号序列" class="headerlink" title="UVA 1626 括号序列"></a>UVA 1626 括号序列</h1><p>我们将正规括号序列定义如下：</p>
<ol>
<li>空序列是正规括号序列。</li>
<li>如果S是一个正规括号序列，那么(S)和[S]都是正规括号序列。</li>
<li>如果A和B都是正规括号序列，那么AB是一个正规括号序列。</li>
</ol>
<p>例如，下面这些序列都是正规括号序列：</p>
<p>(),[],(()),([]),()[],()[()]</p>
<p>而下面这些不是正规括号序列：</p>
<p>(,[,),)(,([)],([]</p>
<p>给你一些含有字符’(‘,’)’,’[‘和’]’的括号序列。你需要找一个最短的正规括号序列，使给定括号序列作为一个子序列包含在其中。</p>
<p>输入描述：<br>输入第一行为一个正整数，代表数据组数。每组数据内容见下文。这一行之后跟着一个空行，每两组数据中间也有一个空行。<br>每组输入都为一行，最多包含100个括号（字符’(‘,’)’,’[‘和’]’），每两个括号之间没有空格。</p>
<p>输出描述：<br>对于每一组数据，格式必须符合如下：<br>输出最短的括号序列，满足题目描述，并且每两个输出之间必须有一个空行分开（最后一行没有）。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>对于一个序列是否是正规序列，要考虑其中的所有字串，想到了递归。</li>
<li>设d(i,j)表示[i,j]构成正规序列至少需要增加多少括号，则<ol>
<li>已知的边界时d(i,i)=1,d(i+1,i) = 0</li>
<li>对于每个状态d(i,j)，来源于字串的状态。当S[i]与S[j]能匹配时，d(i,j)=d(i+1,j-1)即字串的最少增加的序列数目；或者来自于字串分割之后总共至少需要的括号数。</li>
<li>真正的d(i,j)要取他们的最小值</li>
</ol>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="init-初始化边界"><a href="#init-初始化边界" class="headerlink" title="init 初始化边界"></a>init 初始化边界</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void init() &#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">		d[i+1][i] &#x3D; 0;</span><br><span class="line">		d[i][i] &#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="match-判断是否匹配"><a href="#match-判断是否匹配" class="headerlink" title="match 判断是否匹配"></a>match 判断是否匹配</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline bool match(char c, char c2) &#123;</span><br><span class="line">	if (c &#x3D;&#x3D; &#39;(&#39;&amp;&amp;c2 &#x3D;&#x3D; &#39;)&#39;) return true;</span><br><span class="line">	if (c &#x3D;&#x3D; &#39;[&#39;&amp;&amp;c2 &#x3D;&#x3D; &#39;]&#39;) return true;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dp-采用记忆化搜索"><a href="#dp-采用记忆化搜索" class="headerlink" title="dp 采用记忆化搜索"></a>dp 采用记忆化搜索</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int dp(int i, int j) &#123;</span><br><span class="line">	if (i &gt; j) return 0;</span><br><span class="line">	if (i &#x3D;&#x3D; j) return 1;</span><br><span class="line">	if (vis[i][j]) return d[i][j];</span><br><span class="line">	vis[i][j] &#x3D; 1;</span><br><span class="line">	int&amp; ans &#x3D; d[i][j];</span><br><span class="line">	ans &#x3D; inf;</span><br><span class="line">	if (match(s[i], s[j]))</span><br><span class="line">		ans &#x3D; min(ans, dp(i + 1, j - 1));</span><br><span class="line"></span><br><span class="line">	for (int k &#x3D; i; k &lt;&#x3D; j - 1; k++)</span><br><span class="line">		ans &#x3D; min(ans, dp(i, k) + dp(k + 1, j));</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="print-打印，思路与dp类似，注意及时return"><a href="#print-打印，思路与dp类似，注意及时return" class="headerlink" title="print 打印，思路与dp类似，注意及时return"></a>print 打印，思路与dp类似，注意及时return</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">int dp(int i, int j) &#123;</span><br><span class="line">	if (i &gt; j) return 0;</span><br><span class="line">	if (i &#x3D;&#x3D; j) return 1;</span><br><span class="line">	if (vis[i][j]) return d[i][j];</span><br><span class="line">	vis[i][j] &#x3D; 1;</span><br><span class="line">	int&amp; ans &#x3D; d[i][j];</span><br><span class="line">	ans &#x3D; inf;</span><br><span class="line">	if (match(s[i], s[j]))</span><br><span class="line">		ans &#x3D; min(ans, dp(i + 1, j - 1));</span><br><span class="line"></span><br><span class="line">	for (int k &#x3D; i; k &lt;&#x3D; j - 1; k++)</span><br><span class="line">		ans &#x3D; min(ans, dp(i, k) + dp(k + 1, j));</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">void print(int i, int j) &#123;</span><br><span class="line">	if (i &gt; j) return;</span><br><span class="line">	if (i &#x3D;&#x3D; j) &#123;</span><br><span class="line">		if (s[i] &#x3D;&#x3D; &#39;(&#39; || s[i] &#x3D;&#x3D; &#39;)&#39;) printf(&quot;()&quot;);</span><br><span class="line">		if (s[i] &#x3D;&#x3D; &#39;[&#39; || s[i] &#x3D;&#x3D; &#39;]&#39;) printf(&quot;[]&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	int ans &#x3D; d[i][j];</span><br><span class="line">	if (match(s[i], s[j])) &#123;</span><br><span class="line">		if (ans &#x3D;&#x3D; d[i + 1][j - 1])</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;%c&quot;, s[i]);</span><br><span class="line">			print(i + 1, j - 1);</span><br><span class="line">			printf(&quot;%c&quot;, s[j]);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int k &#x3D; i; k &lt; j; k++)</span><br><span class="line">		if (ans &#x3D;&#x3D; d[i][k] + d[k + 1][j]) &#123;</span><br><span class="line">			print(i, k), print(k + 1, j);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d\n&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		memset(d, -1, sizeof(d));</span><br><span class="line">		fgets(s, maxn, stdin);</span><br><span class="line">		n &#x3D; strlen(s)-1;</span><br><span class="line">		init();</span><br><span class="line">		&#x2F;&#x2F;printf(&quot;%d\n&quot;, dp(0, n - 1));</span><br><span class="line">		dp(0, n-1);</span><br><span class="line">		print(0, n-1);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">		if (T) printf(&quot;\n&quot;);</span><br><span class="line">		getchar();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="刘老师代码-比我快好多QAQ"><a href="#刘老师代码-比我快好多QAQ" class="headerlink" title="刘老师代码 比我快好多QAQ"></a>刘老师代码 比我快好多QAQ</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">char S[maxn];</span><br><span class="line">int n, d[maxn][maxn];</span><br><span class="line"></span><br><span class="line">bool match(char a, char b) &#123;</span><br><span class="line">  return (a &#x3D;&#x3D; &#39;(&#39; &amp;&amp; b &#x3D;&#x3D; &#39;)&#39;) || (a &#x3D;&#x3D; &#39;[&#39; &amp;&amp; b &#x3D;&#x3D; &#39;]&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dp() &#123;</span><br><span class="line">  for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">    d[i+1][i] &#x3D; 0;</span><br><span class="line">    d[i][i] &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i &#x3D; n-2; i &gt;&#x3D; 0; i--)</span><br><span class="line">    for(int j &#x3D; i+1; j &lt; n; j++) &#123;</span><br><span class="line">      d[i][j] &#x3D; n;</span><br><span class="line">      if(match(S[i], S[j])) d[i][j] &#x3D; min(d[i][j], d[i+1][j-1]);</span><br><span class="line">      for(int k &#x3D; i; k &lt; j; k++)</span><br><span class="line">        d[i][j] &#x3D; min(d[i][j], d[i][k] + d[k+1][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(int i, int j) &#123;</span><br><span class="line">  if(i &gt; j) return ;</span><br><span class="line">  if(i &#x3D;&#x3D; j) &#123;</span><br><span class="line">    if(S[i] &#x3D;&#x3D; &#39;(&#39; || S[i] &#x3D;&#x3D; &#39;)&#39;) printf(&quot;()&quot;);</span><br><span class="line">    else printf(&quot;[]&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  int ans &#x3D; d[i][j];</span><br><span class="line">  if(match(S[i], S[j]) &amp;&amp; ans &#x3D;&#x3D; d[i+1][j-1]) &#123;</span><br><span class="line">    printf(&quot;%c&quot;, S[i]); print(i+1, j-1); printf(&quot;%c&quot;, S[j]);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int k &#x3D; i; k &lt; j; k++)</span><br><span class="line">    if(ans &#x3D;&#x3D; d[i][k] + d[k+1][j]) &#123;</span><br><span class="line">      print(i, k); print(k+1, j);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void readline(char* S) &#123;</span><br><span class="line">  fgets(S, maxn, stdin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int T;</span><br><span class="line"></span><br><span class="line">  readline(S);</span><br><span class="line">  sscanf(S, &quot;%d&quot;, &amp;T);</span><br><span class="line">  readline(S);</span><br><span class="line"></span><br><span class="line">  while(T--) &#123;</span><br><span class="line">    readline(S);</span><br><span class="line">    n &#x3D; strlen(S) - 1;</span><br><span class="line">    memset(d, -1, sizeof(d));</span><br><span class="line">    dp();</span><br><span class="line">    print(0, n-1);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    if(T) printf(&quot;\n&quot;);</span><br><span class="line">    readline(S);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-煎饼" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E7%85%8E%E9%A5%BC/"
    >煎饼</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E7%85%8E%E9%A5%BC/" class="article-date">
  <time datetime="2020-03-30T02:15:00.638Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="UVA-120-煎饼"><a href="#UVA-120-煎饼" class="headerlink" title="UVA 120 煎饼"></a>UVA 120 煎饼</h1><p>给你一迭薄煎饼，请你写一个程式来指出要如何安排才能使这些薄煎饼由上到下依薄煎饼的半径由小到大排好。所有的薄煎饼半径均不相同。</p>
<p>要把薄煎饼排好序需要对这些薄煎饼做翻面（flip）的动作。方法是以一抹刀插入一迭薄煎饼中，然后做翻面的动作（也就是说在抹刀上面的薄煎饼经翻面后，会依相反的次序排列）。若一迭共有n个薄煎饼，我们定义最底下的薄煎饼的位置为1，最上面的薄煎饼位置为n。当抹刀插入位置为k时，代表从位置k到位置n的薄煎饼要做翻面的动作。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>题意是要进行排序，只不过基本操作是颠倒一个连续的子序列</li>
<li>借鉴选择排序的思想，从大到小依次将每个数排到正确的位置。</li>
<li>实现时先翻到最上面，再翻到正确位置。因为大的在下面，并且按照从大到小的顺序处理，所以当处理第i大的煎饼时，不会影响到1，2，3，···，i-1大的煎饼。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="filp-从p处开始翻"><a href="#filp-从p处开始翻" class="headerlink" title="filp 从p处开始翻"></a>filp 从p处开始翻</h2><ol>
<li>使用swap函数更好理解，并且省下了辅助数组所耗费的时间和空间</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	void filp(int p) &#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; p - i; i++) </span><br><span class="line">		swap(in[i], in[p - i]);</span><br><span class="line">	printf(&quot;%d &quot;, n - p);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">## main </span><br><span class="line">1. 由于规模较小，所以使用order数组来确定大小关系，也可以使用max_element函数</span><br></pre></td></tr></table></figure>

<pre><code>const int maxn = 35;
int in[maxn];
int order[maxn];
int ans[maxn];
int n;
int main() {
string line;
while (getline(cin, line))
{
    cout &lt;&lt; line &lt;&lt; endl;
    stringstream ss(line);
    n = 0;
    while (ss &gt;&gt; in[n]) n++;
    memcpy(order, in, sizeof(in));
    sort(order, order + n);
    int now;
    for (int i = n - 1; i &gt;= 0;i--) {
        int now = order[i];
        for (int j = 0; j &lt; n; j++) {
            if (in[j] == now) {
                if (j == i ) break;
                if (j != 0)  filp(j);
                filp(i);
                break;
            }
        }
    }
    cout &lt;&lt;&quot;0&quot;&lt;&lt; endl;
}

}</code></pre><p>```</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-空间结构" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84/"
    >空间结构</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2020-03-30T02:15:00.638Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="UVA-806-空间结构"><a href="#UVA-806-空间结构" class="headerlink" title="UVA 806 空间结构"></a>UVA 806 空间结构</h1><p>一个四分树是由一个方格的结构组成的，如图：（就是上面的三个图）。</p>
<p>那些像素点可以构成一个四分树，如图：（就是上面的那个树）。</p>
<p>我们规定，NW=1,NE=2,SW=3,SE=4，而一个节点所构成的数字串可以认为是一个五进制数，将它们排序后输出。</p>
<p>例如：上图中地四号节点的路径为NE,SW，所以是32532_5325​ （五进制数）=171017_{10}1710​（十进制数）</p>
<p>那么上树所对应的一传数列为：（在十进制下）</p>
<p>9 14 17 22 23 44 63 69 88 94 113\text{9 14 17 22 23 44 63 69 88 94 113} 9 14 17 22 23 44 63 69 88 94 113</p>
<p>你的任务是在这两者之间转换。</p>
<p>注意，数串中的数字顺序是从叶子到根的，别搞错了。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>对于n&gt;0的情况，需要将矩阵转化为四分树。</p>
<p> 采用递归算法，每次递归四分之一块，如果遇到范围内纯黑或纯白，则返回。并且在遇到纯黑时，将序列存入向量中。</p>
<p> 注意：要先判断整个图是否为纯黑或者纯白。</p>
<p> 然后将五进制转化为十进制</p>
</li>
<li><p>对于n&lt;0的情况，将四分树转化为矩阵<br> 先将十进制转化为五进制，并在字符串尾部添加*，以标识叶子节点<br> 采用递归算法，每次根据当前字符，来选择下一步递归的范围。当遇到叶子节点时，将当前层的范围内的点涂黑</p>
<p> 注意：pre向量中的每个元素，代表一条从根到叶子的路径，所以要用循环配合递归。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p> #include<iostream><br> #include<string><br> #include&lt;string.h&gt;<br> #include<vector><br> #include<algorithm><br> #include<cmath></p>
<h1 id="pragma-warning-disable-4996"><a href="#pragma-warning-disable-4996" class="headerlink" title="pragma warning(disable:4996)"></a>pragma warning(disable:4996)</h1><h1 id="define-LOCAL"><a href="#define-LOCAL" class="headerlink" title="define LOCAL"></a>define LOCAL</h1><h1 id="ifdef-LOCAL"><a href="#ifdef-LOCAL" class="headerlink" title="ifdef LOCAL"></a>ifdef LOCAL</h1><p> FILE *fin = freopen(“空间结构in.txt”, “r”, stdin);<br> FILE *fout = freopen(“空间结构out.txt”, “w”, stdout);</p>
<h1 id="endif"><a href="#endif" class="headerlink" title="endif"></a>endif</h1><p> using namespace std;</p>
<p> vector<int> number;<br> vector<string> pre;<br> char g[64][64];<br> int n;<br> void five() {</p>
<pre><code>for (int i = 0; i &lt; number.size(); i++) {
    int temp = 0;
    while (number[i]) {
        temp *= 10;        //注意此处要先乘10
        temp += number[i] % 5;
        number[i] = number[i] / 5;
    }

    pre.push_back(to_string(temp) + &apos;*&apos;);
    //加*以标识叶子
}</code></pre><p> }<br> void draw(const string s, int &amp;p, int r, int c, int w) {</p>
<pre><code>if (p == s.length()) return;
char ch = s[p++];
switch (ch - &apos;0&apos;)
{

case 1:    draw(s, p, r, c, w / 2); break;
case 2: draw(s, p, r, c + w / 2, w / 2); break;
case 3:    draw(s, p, r + w / 2, c, w / 2); break;
case 4:    draw(s, p, r + w / 2, c + w / 2, w / 2); break;
default:
    break;
}
if (ch == &apos;*&apos;) {
    for (int i = r; i &lt; r + w; i++)
        for (int j = c; j &lt; c + w; j++) {

                g[i][j] = &apos;*&apos;;

        }
}</code></pre><p> }<br> bool judge(int r, int c, int w,char ch) {</p>
<pre><code>// ch为0代表是否纯黑，为1代表是否纯白
for (int i = r; i &lt; r + w; i++)
    for (int j = c; j &lt; c + w; j++)
        if (g[i][j] == ch)
            return false;
return true;    //任何情况下都要有return否则会RE</code></pre><p> }<br> void matrix(string str, int r, int c, int w) {</p>
<pre><code>if (judge(r, c, w,&apos;0&apos;)) {
    pre.push_back(str);    //纯黑则递归到头，将序列保存
    return;
}
else if (judge(r, c, w,&apos;1&apos;)) return;
else {
    matrix(str + &quot;1&quot;, r, c, w / 2);
    matrix(str + &quot;2&quot;, r, c + w / 2, w / 2);
    matrix(str + &quot;3&quot;, r + w / 2, c, w / 2);
    matrix(str + &quot;4&quot;, r + w / 2, c + w / 2, w / 2);
}</code></pre><p> }<br> void ten() {</p>
<pre><code>for (int i = 0; i &lt; pre.size(); i++) {
    int temp = 0;
    for (int j = pre[i].size() - 1; j &gt;= 0; j--)
        temp += (pre[i][j] - &apos;0&apos;)*pow(5, j);
    number.push_back(temp);

}</code></pre><p> }<br> int main() {</p>
<pre><code>int first = 1;
int kase = 0;
while (cin &gt;&gt; n &amp;&amp; n) {
    if (first) first = 0; else cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Image &quot; &lt;&lt; ++kase &lt;&lt; endl;

    number.clear();
    pre.clear();
    memset(g, &apos;.&apos;, sizeof(g));
    getchar();
    if (n &gt; 0) {
        for (int i = 0; i &lt; n; i++)
            for (int j = 0; j &lt; n; j++)
                cin &gt;&gt; g[i][j];</code></pre></li>
</ol>
<pre><code>            if (judge(0, 0, n,&apos;0&apos;)) number.push_back(0);
            //纯黑的情况
            else if (judge(0, 0, n,&apos;1&apos;));//纯白

            else {
                matrix(&quot;1&quot;, 0, 0, n / 2);
                matrix(&quot;2&quot;, 0, n / 2, n / 2);
                matrix(&quot;3&quot;, n / 2, 0, n / 2);
                matrix(&quot;4&quot;, n / 2, n / 2, n / 2);
                ten();
            }


            sort(number.begin(), number.end());
            if (!number.empty()) {
                for (int i = 0; i &lt; number.size(); i++)
                {
                    cout &lt;&lt; number[i];
                    if ((i + 1) % 12 == 0||i==number.size()-1) cout &lt;&lt; endl;
                    else cout &lt;&lt; &quot; &quot;;
                }
            }

            cout &lt;&lt; &quot;Total number of black nodes = &quot; &lt;&lt; number.size() &lt;&lt; endl;

        }
        if (n &lt; 0) {

            string s;
            bool flag = false;
            bool zero = false;
            for (;;) {
                int a;
                //由于输入的结束标志-1不一定出现在哪里，所以
                //要设置标志
                for (int i = 0; i &lt; 12; i++) {
                    cin &gt;&gt; a;
                    if (a == -1) {
                        flag = true;
                        break;
                    }
                    if (a == 0)zero = true;
                    number.push_back(a);
                }
                if (flag) break;
            }    
            if (zero) {
            //如果包含0，代表它是一个只有一个节点的树
                memset(g, &apos;*&apos;, sizeof(g));
            }
            else {
                five();
                for (int i = 0; i &lt; pre.size(); i++) {
                    int p = 0;
                    draw(pre[i], p, 0, 0, abs(n));
                }
            }



            for (int i = 0; i &lt; abs(n); i++) {
                for (int j = 0; j &lt; abs(n); j++)
                    cout &lt;&lt; g[i][j];
                cout &lt;&lt; endl;
            }
        }


    }
}</code></pre><h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li>本题加深了对递归问题的理解，使用递归算法也不是仅仅用递归实现，要搭配循环，减小递归代码的编写难度。</li>
<li>理清思路再写递归，注意认清递归结束条件，不要模糊。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/13/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/15/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        John Doe
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>