<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://github.com/Cccceb/Cccceb.github.io').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://github.com/Cccceb/Cccceb.github.io/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Ceb">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://github.com/Cccceb/Cccceb.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a href="https://github.com/you"><img style="position:absolute;" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_left_gray_6d6d6d.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>  
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E5%9B%A2%E4%BD%93%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ceb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E5%9B%A2%E4%BD%93%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">团体队列</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:47:49" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVA540-团体队列"><a href="#UVA540-团体队列" class="headerlink" title="UVA540 团体队列"></a>UVA540 团体队列</h1><p>有t个团队的人正在排一个长队。每次新来一个人时，如果他有队友在排队，那么这个新人会插队到最后一个队友的身后。如果没有任何一个队友排队，则他会排到长队的队尾。输入每个团队中所有队员的编号，要求支持如下3种指令（前两种指令可以穿插进行）。</p>
<p>ENQUEUEx：编号为x的人进入长队。</p>
<p>DEQUEUE：长队的队首出队。</p>
<p>STOP：停止模拟。</p>
<p>对于每个DEQUEUE指令，输出出队的人的编号。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>本题中涉及两种队列，一个是每个团队的队列，一个是整体的长队。所以用两个整型队列来存储。</li>
<li>由于一个团队的人一定站在一起，所以在整体的长队里，我们不关心每个人的具体位置。所以用给每个团队映射为一个编号，长队中是元素是队伍的编号<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1> /*<br> p117 例5-6 UVA540<br> */<br> #include<iostream><br> #include<string><br> #include<map><br> #include<queue><br> using namespace std;<br> int main() {<br> int kase = 0;<br> for (;;) {<pre><code>map&lt;int, int&gt; belong;
queue&lt;int&gt; total,team[1100];
int n;
cin &gt;&gt; n;
if (!n) return 0;
cout &lt;&lt; &quot;Scenario # &quot; &lt;&lt; ++kase &lt;&lt; endl;
for(int i=0;i&lt;n;i++) {
    int m;
    cin &gt;&gt; m;
    while(m--) {
        int x;
        cin &gt;&gt; x;
        belong[x] = i;
    }
}</code></pre></li>
</ol>
<p><strong>完成输入，并给每个队伍的成员都映射一个编号</strong></p>
<pre><code>    for (;;) {
        string cmd;
        cin &gt;&gt; cmd;
        if (cmd[0] == &apos;S&apos;) break;
        else {
            if (cmd[0] == &apos;D&apos;) {
                int t = total.front();
                cout &lt;&lt; team[t].front() &lt;&lt; endl;
                team[t].pop();
                if (team[t].empty()) total.pop();

            }
            if (cmd[0] == &apos;E&apos;) {
                int num;
                cin &gt;&gt; num;
                int t = belong[num];
                if (team[t].empty()) total.push(t);
                team[t].push(num);
            }
        }
    }
    cout &lt;&lt; endl;
}
}</code></pre><h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li>因为队伍数量不定，所以一开始想用vector，但是会出现越界，所以使用vector时，最好用push_back，不要随机访问。</li>
<li>两个指令，一个有操作数，一个没有，注意分情况输入！！</li>
<li>学习映射的方法，注意需要什么，应该关注什么。本题中，长队里只需关注各队伍的相对顺序，无需在长队中注意每个人的相对位置。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ceb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">图书管理系统</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:47:45" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uva230-图书管理系统"><a href="#uva230-图书管理系统" class="headerlink" title="uva230 图书管理系统"></a>uva230 图书管理系统</h1><p>&ensp;你的任务是模拟一个图书管理系统。首先输入若干图书的标题和作者（标题各不相同，以END结束），然后是若干指令：BORROW指令表示借书，RETURN指令表示还书，SHELVE指令表示把所有已归还但还没有上架的图书排序后依次插入书架并输出图书标题和插入位置（可能是第一本书或者某本书的后面）。<br>&ensp;图书排序的方法是先按作者从小到大排，再按标题从小到大排。在处理第一条指令之前，你应当现将所有图书按照这种方式排序。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>涉及排序，想到用一个集合来存，其中元素既要包含作者名，又要包含书名，并且要先按作者名排序，再按书名排序。所以要写一个结构体，并冲写&lt;号。</li>
<li>由于指令后面只跟书名，所以还要用一个map来存储每本书的作者，以便在处理指令的时候，补全字段，从而在集合中查找    </li>
<li>SHELVE是在所有return结束后一起进行，所以还要用一个容器来存归还过的书，并且也要按要求排序，所以用了一个after这个set。</li>
<li>BORROW即在集合中找到对应元素，然后擦除(要判断是否为结束迭代器，否则re)</li>
<li>RETURN即插入图书集合以及after集合</li>
<li>SHELVE时，按after中顺序结合作者名查找对应书，输出前一个迭代器指向的对象，注意first的判断即可</li>
<li>别的都十分正常，主要是注意以下erase时，要判断是否为end<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">   #include&lt;iostream&gt;</span><br><span class="line">   #include&lt;string&gt;</span><br><span class="line">   #include&lt;algorithm&gt;</span><br><span class="line">   #include&lt;vector&gt;</span><br><span class="line">   #include&lt;iterator&gt;</span><br><span class="line">   #include&lt;set&gt;</span><br><span class="line">   #include&lt;map&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;习题5-8in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;习题5-8out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   string s;</span><br><span class="line">   struct node &#123;</span><br><span class="line">   	string book;</span><br><span class="line">   	string auth;</span><br><span class="line">   	node() &#123; &#125;</span><br><span class="line">   	node(string book, string auth) : book(book), auth(auth) &#123;&#125;</span><br><span class="line">   	bool operator &lt; (const node &amp;a)const &#123;</span><br><span class="line">   		return auth &lt; a.auth || (auth &#x3D;&#x3D; a.auth &amp;&amp; book &lt; a.book);</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   int main() &#123;</span><br><span class="line">set&lt;node&gt; library;</span><br><span class="line">map&lt;string, string&gt; who;</span><br><span class="line">set&lt;node&gt; after;</span><br><span class="line">while (getline(cin, s) &amp;&amp; s !&#x3D; &quot;END&quot;) &#123;</span><br><span class="line">	int f1 &#x3D; s.find(&quot;\&quot;&quot;);</span><br><span class="line">	int f2 &#x3D; s.substr(f1+1).find(&#39;&quot;&#39;);&#x2F;&#x2F;+1!!!!</span><br><span class="line">	node b(s.substr(f1 + 1, f2), s.substr(f2 + 5));</span><br><span class="line">	library.insert(b);</span><br><span class="line">	who[b.book] &#x3D; b.auth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while (getline(cin, s) &amp;&amp; s !&#x3D; &quot;END&quot;) &#123;</span><br><span class="line">	set&lt;node&gt;::iterator it;</span><br><span class="line">	int f1 &#x3D; s.find(&quot;\&quot;&quot;);</span><br><span class="line">	int f2 &#x3D; s.substr(f1 + 1).find(&#39;&quot;&#39;);</span><br><span class="line">	string bookname &#x3D; s.substr(f1 + 1,f2);</span><br><span class="line">	</span><br><span class="line">	if (s[0] &#x3D;&#x3D; &#39;B&#39;) &#123;</span><br><span class="line">		</span><br><span class="line">		it &#x3D; library.find(node(bookname, who[bookname]));</span><br><span class="line">		</span><br><span class="line">		if (it !&#x3D; library.end())	library.erase(it);</span><br><span class="line">	&#125;</span><br><span class="line">	if (s[0] &#x3D;&#x3D; &#39;R&#39;) &#123;</span><br><span class="line">		library.insert(node(bookname, who[bookname]));</span><br><span class="line">		after.insert(node(bookname, who[bookname]));</span><br><span class="line">	&#125;</span><br><span class="line">	if (s[0] &#x3D;&#x3D; &#39;S&#39;) &#123;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		for (set&lt;node&gt;::iterator i &#x3D; after.begin(); i !&#x3D; after.end();i++) &#123;&#x2F;&#x2F;输出也是先按作者名排序再按书名排序</span><br><span class="line">			bookname &#x3D; i-&gt;book;</span><br><span class="line">			it &#x3D; library.find(node(bookname, who[bookname]));</span><br><span class="line">			cout &lt;&lt; &quot;Put \&quot;&quot; &lt;&lt; bookname &lt;&lt;&quot;\&quot;&quot;;</span><br><span class="line">			if (it !&#x3D; library.begin()) cout &lt;&lt; &quot; after \&quot;&quot; &lt;&lt; (--it)-&gt;book &lt;&lt; &quot;\&quot;&quot;&lt;&lt;endl;</span><br><span class="line">			else cout &lt;&lt; &quot; first&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;END&quot; &lt;&lt; endl;</span><br><span class="line">		after.clear();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><p>存储重复的数据有时候也是必要的，不要为了那点空间，花太多力气</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E5%A4%A9%E5%B9%B3%E9%9A%BE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ceb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E5%A4%A9%E5%B9%B3%E9%9A%BE%E9%A2%98/" class="post-title-link" itemprop="url">天平难题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:47:42" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVA-1354-天平难题"><a href="#UVA-1354-天平难题" class="headerlink" title="UVA 1354 天平难题"></a>UVA 1354 <a href=""https://www.luogu.com.cn/problem/UVA1354"">天平难题</a></h1><p>给出房间宽度r和s个吊坠的重量wi。设计一个尽量宽（不超过r)的天平，挂着所有挂坠。 天平由一些长度为1的木棍组成。木棍的每一端要么挂一个挂坠，要么挂另外一个木棍。设n和m分别是两端挂的总重量，a和b为两端长度，要让天平平衡，必须满足na=mb。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>回溯法加暴搜，通过枚举二叉树来求解，<strong>其中天平力矩平衡的条件用来计算偏移量</strong>。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="DFS函数"><a href="#DFS函数" class="headerlink" title="DFS函数"></a>DFS函数</h2><p>用来遍历解答树，同时进行剪枝。只有当可扩展位置和剩余挂坠全部刚好同时用尽，才说明是一个可能的解，对于其他的情况需要进行剪枝。对于枚举二叉树中的每个节点，可能的情况又分成两种，一种是在该节点(step)处放一个木棍，那么可放置挂坠的节点数+1(别忘了回溯);另一种是在该节点处放置一个挂坠，那么可放置挂坠的位置-1，同时剩余挂坠-1(也要回溯)</p>
<pre><code>void dfs(int step, int leaf, int node) {
if (!node &amp;&amp; !leaf) {
    update(step - 1);
    return;
}
if ((!node&amp;&amp;leaf) || (node &amp;&amp; !leaf)) {
    return;
}
if (tree[step / 2] != -1) {
    dfs(step + 1, leaf, node);
    return;
}
if (leaf &lt; node) {
    tree[step] = -1;
    dfs(step + 1, leaf + 1, node);
    tree[step] = 0;
}
for (int i = 1; i &lt;= s; i++) {
    if (!vis[i]) {
        vis[i] = 1;
        tree[step] = i;

        dfs(step + 1, leaf - 1, node - 1);

        vis[i] = 0;
        tree[step] = 0;
    }
}

}</code></pre><h2 id="update函数"><a href="#update函数" class="headerlink" title="update函数"></a>update函数</h2><p>在枚举出一种二叉树之后，要计算他的宽度并和目前的最优解比较。这里首先使用一个val数组来记录各个节点处的权重：</p>
<ol>
<li>如果是木棍，那么他的重量等于他的两个子节点之和；</li>
<li>如果是挂坠，那么重量就是该挂坠的重量。</li>
</ol>
<p>之后使用findedge函数计算宽度。</p>
<pre><code>void update(int num) {
memset(val, 0, sizeof(val));
for (int i = num; i &gt;= 1; i--) {
    if (tree[i] &lt; 0) val[i] = val[i * 2] + val[i * 2 + 1];
    else if(tree[i]&gt;0) val[i] = w[tree[i]];
}
left = DBL_MAX;
right = DBL_MIN;

findedge(double(0), 1);
double fin = right - left;
if (fin &lt; r) {
    ans = max(ans, fin);
}

}</code></pre><h2 id="findedge函数"><a href="#findedge函数" class="headerlink" title="findedge函数"></a>findedge函数</h2><p>利用天平平衡，力矩为0计算宽度。nl * a = nr * b。如果该节点是一个木棍，那么需要计算他的子节点的偏移量，过程与前面一样，所以整体上构成了一个递归的结构。</p>
<pre><code>void findedge(double mid, int cur) {
int a = cur * 2;
int b = cur * 2 + 1;
double nl = mid - ((double)val[b] / (val[a] + val[b]));
double nr = mid + ((double)val[a] / (val[a] + val[b]));

left = min(left, nl);
right = max(right, nr);

if (tree[cur] &lt; 0) {
    findedge(nl, a);
    findedge(nr, b);
}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E5%B0%8F%E7%90%83%E4%B8%8B%E8%90%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ceb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E5%B0%8F%E7%90%83%E4%B8%8B%E8%90%BD/" class="post-title-link" itemprop="url">小球下落</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:48:00" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uva-679-小球下落"><a href="#uva-679-小球下落" class="headerlink" title="uva 679 小球下落"></a>uva 679 小球下落</h1><p>&ensp;许多的小球一个一个的从一棵满二叉树上掉下来组成一个新满二叉树，每一时间，一个正在下降的球第一个访问的是非叶子节点。然后继续下降时，或者走右子树，或者走左子树，直到访问到叶子节点。<br>决定球运动方向的是每个节点的布尔值。最初，所有的节点都是 FALSE，当访问到一个节点时，如果这个节点是 FALSE，则这个球把它变成 TRUE，然后从左子树走，继续它的旅程。如果节点是TRUE，则球也会改变它为 FALSE，而接下来从右子树走。满二叉树的标记方法如下图。<br>因为所有的节点最初为 FALSE，所以第一个球将会访问节点 1，节点 2 和节点 4，转变节点的布尔值后在在节点 8 停止。第二个球将会访问节点 1、3、6，在节点 12 停止。；明显地，第三个球在它停止之前，会访问节点 1、2、5，在节点 10 停止。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>对于二叉树，有结论编号为i的节点的左子树编号为2i,右子树为2i+1</li>
<li>如果用一个数组存二叉树，并进行遍历，会TEL，并且数组占很大空间</li>
<li>发现只要知道是第几个通过该节点的小球，那么就可以知道这一步他落到左子树还是右子树</li>
<li>如果I为奇数，那么他是第（I+1）/2个向左走的小球，如果I为偶数，那么他是第I/2个向右走的小球。<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   #include&lt;iostream&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;小球下落in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;小球下落out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   int main() &#123;</span><br><span class="line">int T;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">while (T--) &#123;</span><br><span class="line">	int num, depth;</span><br><span class="line">	cin &gt;&gt; depth &gt;&gt; num;</span><br><span class="line">	int No &#x3D; 1;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; depth-1; i++) &#123;</span><br><span class="line">		if (num % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">			No &#x3D; 2 * No;</span><br><span class="line">			num &#x3D; (num + 1) &#x2F; 2;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			No &#x3D; 2 * No + 1;</span><br><span class="line">			num &#x3D; num &#x2F; 2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; No &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1></li>
<li>关注该关注的，并找规律很重要</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E6%B6%88%E9%98%B2%E8%BD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ceb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E6%B6%88%E9%98%B2%E8%BD%A6/" class="post-title-link" itemprop="url">消防车</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:47:57" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVA-208-消防车"><a href="#UVA-208-消防车" class="headerlink" title="UVA 208 消防车"></a>UVA 208 消防车</h1><p>给你一张图，输入x，y表示xy见有一条边。输出从1到z所有的遍历方案（字典序）。每个节点从1到N标号。 有多组数据，每组数据以0 0结束。 （注意，刚开始的输入不是节点或边的数目） 输入输出格式可以参考样例. 数据范围（节点总数N&lt;21）</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>本题要求输出所有的完整的路径，即要沿着一条路走到头，所以使用dfs</li>
<li>辅助用bfs判断依次是否存在路径，否则会超时</li>
<li>本题中各层的path之间不会影响，因为递归是走到头再返回的。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>#include&lt;bits/stdc++.h&gt;
# pragma warning(disable:4996)
FILE *fin = freopen(&quot;习题7-1in.txt&quot;, &quot;r&quot;, stdin);
FILE *fout = freopen(&quot;习题7-1out.txt&quot;, &quot;w&quot;, stdout);
using namespace std;
const int maxn = 20+5;
map&lt;int, vector&lt;int&gt;&gt; g;
bool bfs();
void dfs(int u,int step);
int goal, cnt,kase = 0;
bool vis[maxn];
int path[maxn];
struct edge {
int x, y;
edge(int x, int y) :x(x), y(y) {}
bool operator &lt; (const edge&amp;a) const { return x &lt; a.x; }
};
int main() {
int a, b;
while (scanf(&quot;%d&quot;, &amp;goal) == 1) {
    g.clear();
    printf(&quot;CASE %d:\n&quot;, ++kase);
    while (scanf(&quot;%d %d&quot;, &amp;a, &amp;b) &amp;&amp; a) {
        g[a].push_back(b);
        g[b].push_back(a);
    }
    for (int i = 0; i &lt; maxn; i++)
        sort(g[i].begin(), g[i].end());
    cnt = 0;
    memset(vis, 0, sizeof(0));
    if (!bfs()) {//优化，否则会T
        cnt = 0;
    }
    else {
        vis[1] = 1;
        dfs(1,0);
    }
    printf(&quot;There are %d routes from the firestation to streetcorner %d.\n&quot;, cnt,goal);
}
}
bool bfs() {
queue&lt;int&gt; q;
q.push(1);
while (!q.empty()) {
    int u = q.front(); q.pop();
    if (u == goal) {
        memset(vis, 0, sizeof(vis));
        return true;
    }
    for (int i = 0; i &lt; g[u].size(); i++) {
        int v = g[u][i];
        if (!vis[v])
        {
            vis[v] = 1;
            q.push(v);
        }
    }
}
memset(vis, 0, sizeof(vis));
return false;
}
void dfs(int u,int step) {
path[step] = u;
if (u == goal) {
    printf(&quot;%d&quot;, path[0]);
    for (int i =1; i &lt;= step; i++)
        printf(&quot; %d&quot;, path[i]);
    printf(&quot;\n&quot;);
    cnt++;
}
for (int i = 0; i &lt; g[u].size(); i++) {
    int v = g[u][i];
    if (vis[v]) continue;
    vis[v] = 1;
    dfs(v,step+1);
    vis[v] = 0;
}
}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E7%BD%91%E6%A0%BC%E5%8A%A8%E7%89%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ceb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E7%BD%91%E6%A0%BC%E5%8A%A8%E7%89%A9/" class="post-title-link" itemprop="url">网格动物</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:47:55" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVA-1602-网格动物"><a href="#UVA-1602-网格动物" class="headerlink" title="UVA 1602 网格动物"></a>UVA 1602 网格动物</h1><p>输入n,w,h(1&lt;=n&lt;=10,1&lt;=w,h&lt;=n).求能放在w*h网格里的不同的n连块的个数(平移,旋转,翻转算一种)</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>如果对于每次的输入计算结果，会超时，所以先打表。</p>
</li>
<li><p>题目问有多少种连通块，所以直观的想到不断的在格子周围扩展各自，然后判断是否重复，不重复则加入到集合中。</p>
</li>
<li><p>主要的数据结构为set(set(node))[maxn]，点的集合构成一种连通格，相同连通数的图构成i连通块的动物集合。i格连通的动物存在数组下标为i的集合中。使用点集来存图，一方面可以节省空间，另一方面便于实现平移旋转翻转</p>
</li>
<li><p>还需要实现平移，旋转，翻转</p>
<ol>
<li>平移：统一平移到原点</li>
<li>旋转：顺时针旋转90度，画个图就明白了</li>
<li>翻转：实现是关于x轴翻转</li>
</ol>
</li>
<li><p>打表：打表是一个迭代枚举的过程，后代是对前一代节点周围区域的扩展。由于normal的过程，所以不需要判断越界问题，即使出现负坐标，normal也会将他平移到原点。之后，在循环n,w,h将对应结果存在一个三维数组中即可。</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="打表"><a href="#打表" class="headerlink" title="打表"></a>打表</h2><pre><code>void get_ans() {
g start;
start.insert(node(0, 0));
animals[1].insert(start);
for (int i = 2; i &lt;= maxn; i++)
    for (set&lt;g&gt;::iterator j = animals[i - 1].begin(); j != animals[i - 1].end(); j++)
        for (g::iterator k = (*j).begin(); k != (*j).end(); k++) {
            int r = k-&gt;r, c = k-&gt;c;
            for (int w = 0; w &lt; 4; w++) {
                node nd(r + dx[w], c + dy[w]);
                if (!(*j).count(nd))
                    insert(*j, nd);
            }
        }


for (int n = 1; n &lt;= maxn; n++)
    for (int w = 1; w &lt;= maxn; w++)
        for (int h = 1; h &lt;= maxn; h++) {
            int sum = 0;
            for (set&lt;g&gt;::iterator p = animals[n].begin(); p != animals[n].end(); p++) {
                int maxx = 0, maxy = 0;
                for (g::iterator q = (*p).begin(); q != (*p).end(); q++) {
                    maxx = max(maxx, q-&gt;r);
                    maxy = max(maxy, q-&gt;c);
                }
                if (max(maxx, maxy) &lt; max(w, h) &amp;&amp; min(maxx, maxy) &lt; min(w, h)) sum++;
            }
            ans[n][w][h] = sum;
        }
}</code></pre><h2 id="判重及旋转-平移，翻转"><a href="#判重及旋转-平移，翻转" class="headerlink" title="判重及旋转,平移，翻转"></a>判重及旋转,平移，翻转</h2><pre><code>g normal(const g&amp; p) {
int minx = p.begin()-&gt;r, miny = p.begin()-&gt;c;
for (g::iterator i = p.begin(); i != p.end(); i++) {
    minx = min(minx, i-&gt;r);
    miny = min(miny, i-&gt;c);
}
g p2;
for (g::iterator i = p.begin(); i != p.end(); i++)
    p2.insert(node(i-&gt;r - minx, i-&gt;c - miny));
return p2;
}
g turn(const g&amp;p) {
g p2;
for (g::iterator i = p.begin(); i != p.end(); i++)
    p2.insert(node(i-&gt;c, -i-&gt;r));
return normal(p2);
}
g filp(const g&amp;p) {
g p2;
for (g::iterator i = p.begin(); i != p.end(); i++)
    p2.insert(node(i-&gt;r, -i-&gt;c));
return normal(p2);
}
void insert(const g&amp; p, node nd) {
g p2 = p;
p2.insert(nd);
p2 = normal(p2);
int n = p2.size();

for (int i = 0; i &lt; 4; i++) {
    if (animals[n].count(p2)) return;
    p2 = turn(p2);
}
p2 = filp(p2);
for (int i = 0; i &lt; 4; i++) {
    if (animals[n].count(p2)) return;
    p2 = turn(p2);
}
animals[n].insert(p2);    
}</code></pre><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><pre><code>struct node {
int r, c;
node(int r = 0, int c = 0) :r(r), c(c) {}
bool operator &lt; (const node &amp;a) const { return r &lt; a.r || r == a.r &amp;&amp; c &lt; a.c; }
};
typedef set&lt;node&gt; g;
const int maxn = 10;
int dx[] = { 1,-1,0,0 };
int dy[] = { 0,0,1,-1 };
g normal(const g&amp; p);
g turn(const g&amp; p);
g filp(const g&amp; p);
void insert(const g&amp; p, node nd);
int main()
{
int n, h, w;
get_ans();
while (cin &gt;&gt; n &gt;&gt; w &gt;&gt; h)
    cout &lt;&lt; ans[n][w][h] &lt;&lt; endl;
return 0;
}    </code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ceb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%A1%E7%AE%97/" class="post-title-link" itemprop="url">快速幂计算</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:47:26" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVA-1374-快速幂计算"><a href="#UVA-1374-快速幂计算" class="headerlink" title="UVA 1374 快速幂计算"></a>UVA 1374 快速幂计算</h1><p>初始有x，问经过多少次乘除可以得到目标值n。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>与埃及积分有相似之处，可以采用迭代加深搜的方法。</p>
</li>
<li><p>通过迭代得出可以得到的幂次，通过深度搜素来凑</p>
</li>
<li><p>关于剪枝</p>
<ol>
<li>根据题意，幂次不允许小于0，幂次=0也没用</li>
<li>如果当前序列的最大数乘以2<sup>maxd-d</sup>&lt;n，则应该剪枝。因为即使剩余的maxd-d层都是乘以当前序列的最大值(即最大的幂次乘以2，即左移一位)仍然小于n，则说明这一支不可能达到n了，故需要剪掉。</li>
</ol>
</li>
<li><p>关于节点排序：为了更快的接近目标，应该优先扩展较大的数，优先加法再试减法。这样可以在最后一次迭代中，无需等待整个解答树扩展完成即可找到解。</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int res[50];</span><br><span class="line">int maxd;</span><br><span class="line">bool dfs(int d, int maxn);</span><br><span class="line">int n;</span><br><span class="line">int main() &#123;</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">	for (maxd &#x3D; 0;; maxd++)</span><br><span class="line">		if (dfs(0, 1)) break;</span><br><span class="line">	printf(&quot;%d\n&quot;, maxd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool dfs(int d, int maxn) &#123;&#x2F;&#x2F;当前的步数d，当前的最大值maxn</span><br><span class="line">if (d &#x3D;&#x3D; maxd)</span><br><span class="line">	if (maxn &#x3D;&#x3D; n || maxn &lt;&lt; (maxd - d) &#x3D;&#x3D; n) return true;</span><br><span class="line">if (maxn &lt;&#x3D; 0 || maxn &lt;&lt; (maxd - d) &lt; n) return false;</span><br><span class="line">res[d] &#x3D; maxn;</span><br><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; d; i++) &#123;</span><br><span class="line">	if (dfs(d + 1, maxn + res[i])) return true;</span><br><span class="line">	if (dfs(d + 1, maxn - res[i])) return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ceb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="post-title-link" itemprop="url">数据库</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:47:39" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uva-1592-数据库"><a href="#uva-1592-数据库" class="headerlink" title="uva 1592 数据库"></a>uva 1592 数据库</h1><p>输入一个n行m列的数据库，是否存在两个不同行r1，r2和两个不同列c1，c2，使得这两行和两列相同。（即（r1,c1）和（r2,c1）相同，（r1,c2）和（r2,c2）相同）</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>由于最终要判断是否相同，所以可以将字符串映射为一个值，以减少比较的时间</p>
</li>
<li><p>主循环中，在c1,c2下循环r，并将（r,c1）,(r,c2)存成一个二元组，将二元组映射为当前的行号，如果图中已存在这样的二元组，那么对应的值即为r2，当前行为r1。</p>
</li>
<li><p>由于有以二元组为键类型的图，所以结构体中要重写“&lt;”，否则会报错</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p> #include<iostream><br> #include<string><br> #include<set><br> #include<map><br> #include<vector><br> using namespace std;<br> map&lt;string, int&gt; location;<br> set<string> same;<br> vector<int> str[100000];<br> typedef struct point {</p>
<pre><code>int x;
int y;
point(int x, int y) :x(x), y(y) {}
bool operator &lt; (const point&amp; r) const { return x &lt; r.x || x == r.x&amp;&amp;y &lt; r.y; }</code></pre><p> }point;<br>※※注意此处重写“&lt;”的方法</p>
<p> int main() {<br> int r, c;<br> while (scanf(“%d%d”, &amp;r, &amp;c) == 2) {</p>
<pre><code>getchar();
same.clear();
location.clear();
for (int i = 0; i &lt; r; i++) str[i].clear();
for (int i = 0; i &lt; r; i++) {
    for (int j = 0; j &lt; c; j++) {
        string s;
        char cs = getchar();
        while (cs != &apos;,&apos;&amp;&amp;cs != &apos;\n&apos;) {
            s += cs;
            cs = getchar();
        }
        if (!same.count(s)) {
            location[s] = i * r + j;
            same.insert(s);
        }
        str[i].push_back(location[s]);
    }
}</code></pre></li>
</ol>
<p><strong>利用set和map，将每种字符串映射为唯一的值</strong></p>
<pre><code>    map&lt;point, int&gt; data;
    for (int c1 = 0; c1 &lt; c; c1++) {
        for (int c2 = c1 + 1; c2 &lt; c; c2++) {
            data.clear();
            for (int r1 = 0; r1 &lt; r; r1++) {
                int x = str[r1][c1];
                int y = str[r1][c2];
                point p(x, y);
                if (!data.count(p)) data[p] = r1;
                else {
                    cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl &lt;&lt; data[p] + 1 &lt;&lt; &quot; &quot; &lt;&lt; r1 + 1 &lt;&lt; endl
                        &lt;&lt; c1 + 1 &lt;&lt;&quot; &quot;&lt;&lt; c2 + 1 &lt;&lt; endl;
                    goto here;
                }
            }
        }
    }
    cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
    here:;
}
}</code></pre><h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li>本题在循环前的映射与集合栈计算机类似，本题中目的是减少比较时的时间</li>
<li>本题应把两列最为一个整体，否则需要四重循环，会TEL</li>
<li>学习结构体初始化和重写操作符的方法。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E6%9C%A8%E5%9D%97%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ceb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E6%9C%A8%E5%9D%97%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">木块问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:47:30" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVa101-木块游戏"><a href="#UVa101-木块游戏" class="headerlink" title="UVa101 木块游戏"></a>UVa101 木块游戏</h1><h3 id="输入n，得到编号为0n-1的木块，分别摆放在顺序排列编号为0n-1的位置。现对这些木块进行操作，操作分为四种"><a href="#输入n，得到编号为0n-1的木块，分别摆放在顺序排列编号为0n-1的位置。现对这些木块进行操作，操作分为四种" class="headerlink" title="输入n，得到编号为0n-1的木块，分别摆放在顺序排列编号为0n-1的位置。现对这些木块进行操作，操作分为四种:"></a>输入n，得到编号为0<del>n-1的木块，分别摆放在顺序排列编号为0</del>n-1的位置。现对这些木块进行操作，操作分为四种:</h3><h3 id="1、move-a-onto-b：把木块a、b上的木块放回各自的原位，再把a放到b上；"><a href="#1、move-a-onto-b：把木块a、b上的木块放回各自的原位，再把a放到b上；" class="headerlink" title="1、move a onto b：把木块a、b上的木块放回各自的原位，再把a放到b上；"></a>1、move a onto b：把木块a、b上的木块放回各自的原位，再把a放到b上；</h3><h3 id="2、move-a-over-b：把a上的木块放回各自的原位，再把a发到含b的堆上；"><a href="#2、move-a-over-b：把a上的木块放回各自的原位，再把a发到含b的堆上；" class="headerlink" title="2、move a over b：把a上的木块放回各自的原位，再把a发到含b的堆上；"></a>2、move a over b：把a上的木块放回各自的原位，再把a发到含b的堆上；</h3><h3 id="3、pile-a-onto-b：把b上的木块放回各自的原位，再把a连同a上的木块移到b上；"><a href="#3、pile-a-onto-b：把b上的木块放回各自的原位，再把a连同a上的木块移到b上；" class="headerlink" title="3、pile a onto b：把b上的木块放回各自的原位，再把a连同a上的木块移到b上；"></a>3、pile a onto b：把b上的木块放回各自的原位，再把a连同a上的木块移到b上；</h3><h3 id="4、pile-a-over-b：把a连同a上木块移到含b的堆上。"><a href="#4、pile-a-over-b：把a连同a上木块移到含b的堆上。" class="headerlink" title="4、pile a over b：把a连同a上木块移到含b的堆上。"></a>4、pile a over b：把a连同a上木块移到含b的堆上。</h3><h3 id="当输入quit时，结束操作并输出0-n-1的位置上的木块情况"><a href="#当输入quit时，结束操作并输出0-n-1的位置上的木块情况" class="headerlink" title="当输入quit时，结束操作并输出0~n-1的位置上的木块情况"></a>当输入quit时，结束操作并输出0~n-1的位置上的木块情况</h3><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>10</p>
<p>move 9 onto 1</p>
<p>move 8 over 1</p>
<p>move 7 over 1</p>
<p>move 6 over 1</p>
<p>pile 8 over 6</p>
<p>pile 8 over 5</p>
<p>move 2 over 1</p>
<p>move 4 over 9</p>
<p>quit</p>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p> 0: 0</p>
<p> 1: 1 9 2 4</p>
<p> 2:</p>
<p> 3: 3</p>
<p> 4:</p>
<p> 5: 5 8 7 6</p>
<p> 6:</p>
<p> 7:</p>
<p> 8:</p>
<p> 9:</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h3 id="通过四种指令的描述，可以注意到，move指令与把a上的木块全部归位相联系；onto指令与把b上方的木块归位相联系；并且每条指令都包含把a-或a的上方的木块-移动到b上方的部分；因此，应该对应以上三点来写各模块；"><a href="#通过四种指令的描述，可以注意到，move指令与把a上的木块全部归位相联系；onto指令与把b上方的木块归位相联系；并且每条指令都包含把a-或a的上方的木块-移动到b上方的部分；因此，应该对应以上三点来写各模块；" class="headerlink" title="通过四种指令的描述，可以注意到，move指令与把a上的木块全部归位相联系；onto指令与把b上方的木块归位相联系；并且每条指令都包含把a(或a的上方的木块)移动到b上方的部分；因此，应该对应以上三点来写各模块；"></a>通过四种指令的描述，可以注意到，move指令与把a上的木块全部归位相联系；onto指令与把b上方的木块归位相联系；并且每条指令都包含把a(或a的上方的木块)移动到b上方的部分；因此，应该对应以上三点来写各模块；</h3><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="模块一"><a href="#模块一" class="headerlink" title="模块一"></a>模块一</h2><p>查找编号为a的木块所在堆和高度，用引用传递</p>
<pre><code>void find(int a, int &amp;pa, int &amp;h) {
    for (pa = 0; pa &lt; n; pa++) {
        for (h = 0; h &lt; p[pa].size(); h++) {
            if (p[pa][h] == a) return;
        }
    }
}</code></pre><h2 id="模块二"><a href="#模块二" class="headerlink" title="模块二"></a>模块二</h2><p>把a堆高度为h的木块的所有木块归位。注意，本题中的归位是把a放回初始的堆里即可，不考虑初始高度。</p>
<pre><code> void clear_above(int a, int h) {
        for (int i = h + 1; i &lt; p[a].size(); i++) {
            p[p[a][i]].push_back(p[a][i]);
        }
        p[a].resize(h + 1);
}</code></pre><h2 id="模块三"><a href="#模块三" class="headerlink" title="模块三"></a>模块三</h2><p>把p堆高度为h及其上方的木块整体移动到p2堆顶:1.移动2.截断</p>
<pre><code>void pile_onto(int p1, int h, int p2) {

for (int i = h; i &lt; p[p1].size(); i++) {
    p[p2].push_back(p[p1][i]);
}
p[p1].resize(h);
}</code></pre><h2 id="模块四"><a href="#模块四" class="headerlink" title="模块四"></a>模块四</h2><p>输出各堆的序列</p>
<pre><code>void print(){
for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; i &lt;&lt; &quot;:&quot;;
    for (int j = 0; j &lt; p[i].size(); j++) {
        cout &lt;&lt; &quot; &quot; &lt;&lt; p[i][j];
    }
    cout &lt;&lt; endl;
}
}</code></pre><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><pre><code>int main() {
cin &gt;&gt; n;
for (int i = 0; i &lt; n; i++) p[i].push_back(i);
string s1, s2;
int a, b;
while (cin &gt;&gt; s1 &gt;&gt; a &gt;&gt; s2 &gt;&gt; b) {
    int pa, pb, ha, hb;
    find(a, pa, ha);
    find(b, pb, hb);
    if (pa == pb) continue;//非法指令

    if (s1 == &quot;move&quot;) clear_above(pa, ha);
    if (s2 == &quot;onto&quot;) clear_above(pb, hb);
    pile_onto(pa, ha, pb);
}
print();
return 0;
}</code></pre><h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><ol>
<li>本题应主要学习他的拆分思路,以及引用传递的运用。</li>
<li>学习vector类，vector<typename> xname;</li>
<li>学习vector的基本方法，push_back(要插入的元素) 和 resize(元素个数);</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ceb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E6%A0%91/" class="post-title-link" itemprop="url">树</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:47:36" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uva-548-树"><a href="#uva-548-树" class="headerlink" title="uva 548 树"></a>uva 548 树</h1><p>&ensp;输入一个二叉树的中序和后序遍历，请你输出一个叶子节点，该叶子节点到根的数值总和最小，且这个叶子是编号最小的那个。 输入： 您的程序将从输入文件中读取两行(直到文件结尾)。第一行是树的中序遍历值序列,第二行是树的后序遍历值序列。所有值将不同，大于零且小于或等于10000.二叉树的节1&lt;=N&lt;=10000。 输出： 对于每个树描述，您应该输出最小值路径的叶节点的值。存在多路径最小的情况下，您应该选择终端叶子节点上具有最小值的那条路径，且输出那个最小值的终端叶子。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>根据中序和后序序列构造二叉树</p>
</li>
<li><p>递归遍历二叉树，每一步走左右子树中权值较小的一个</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p> #include<iostream><br> #include<string><br> #include<sstream></p>
<h1 id="pragma-warning-disable-4996"><a href="#pragma-warning-disable-4996" class="headerlink" title="pragma warning(disable:4996)"></a>pragma warning(disable:4996)</h1><h1 id="define-LOCAL"><a href="#define-LOCAL" class="headerlink" title="define LOCAL"></a>define LOCAL</h1><h1 id="ifdef-LOCAL"><a href="#ifdef-LOCAL" class="headerlink" title="ifdef LOCAL"></a>ifdef LOCAL</h1><p> FILE *fin = freopen(“树in.txt”, “r”, stdin);<br> FILE *fout = freopen(“树out.txt”, “w”, stdout);</p>
<h1 id="endif"><a href="#endif" class="headerlink" title="endif"></a>endif</h1><p> using namespace std;</p>
<h1 id="define-maxn-10000"><a href="#define-maxn-10000" class="headerlink" title="define maxn 10000"></a>define maxn 10000</h1><p> int n = 0;<br> bool read(int *a) {</p>
<blockquote>
<p>数组为参数的时候可以用指针，传首地址</p>
</blockquote>
<pre><code>string s;
getline(cin, s);
stringstream ss(s);</code></pre><blockquote>
<p>注意此处，用ss来读取一行不定数量的以空格分隔的数字</p>
</blockquote>
<pre><code>n = 0;
int x;
while (ss &gt;&gt; x) a[n++] = x;
return n &gt; 0;</code></pre><p> }</p>
<p> int post_order[maxn], in_order[maxn],lch[maxn],rch[maxn];</p>
</li>
</ol>
<blockquote>
<p>其中rch[i]表示编号为i的节点的右孩子<br>`<br>    int build(int l1, int r1, int l2, int r2) {<br>        if (l1 &gt; r1) return 0;//空树<br>本题中以权值代表编号，为0表示节点不存在</p>
</blockquote>
<pre><code>    int root = post_order[r2];//后序序列的最后一个
    int p = l1;
    while (in_order[p] != root) p++;
    int cnt = p-l1;//左子树中节点个数


    //分别在左右子树中递归遍历
    lch[root] = build(l1, p - 1, l2 , l2 + cnt - 1);
    rch[root] = build(p + 1, r1, l2 + cnt, r2 - 1);
    return root;
}

int best, best_sum;
void dfs(int u, int sum) {
    sum += u;
    if (!lch[u] &amp;&amp; !rch[u]) {//如果u是叶子节点
        if (sum &lt; best_sum || (best_sum == sum &amp;&amp; u &lt; best)) 
        {
            best = u;
            best_sum = sum;
        }
    }

    if (lch[u]) dfs(lch[u], sum);
    if (rch[u]) dfs(rch[u], sum);

}
int main() {
    while (read(in_order)) {
        read(post_order);
        build(0, n - 1, 0, n - 1);
        best_sum = 1e9;//
        dfs(post_order[n - 1], 0);
        cout &lt;&lt; best &lt;&lt; endl;
    }
}</code></pre><h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li><p>输入也可以写成子函数的形式</p>
</li>
<li><p>学习中后造树和递归遍历二叉树的方法</p>
<pre><code>void dfs(树根指针){
if(左子树为空（为0）&amp;&amp;右子树为空（为0）)
    {

        return 0;
    }
if(左孩子不为空) dfs（左孩子）
if(右孩子不为空) dfs（右孩子）
}</code></pre></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ceb</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ceb</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
  
</body>
</html>
