<!DOCTYPE html>


<html lang="en" >


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Hexo
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

  <script type="text/javascript"
	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-视觉第10讲" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC10%E8%AE%B2/"
    >视觉第10讲</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC10%E8%AE%B2/" class="article-date">
  <time datetime="2020-03-30T03:17:13.887Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="相机成像原理"><a class="markdownIt-Anchor" href="#相机成像原理"></a> 相机成像原理</h1>
<ol>
<li>为什么不使光圈尽可能小?<br />
（1）使光线减少 （2）衍射影响</li>
<li>人的眼睛：瞳孔相当于光圈；视网膜上的感光细胞相当于胶片。</li>
</ol>
<h2 id="相机模型"><a class="markdownIt-Anchor" href="#相机模型"></a> 相机模型</h2>
<ol>
<li>
<p>投影建模</p>
 <img src="/视觉_img/10_1.png" style="zoom:80%">
 1. 将相机近似为针孔模型
 2. 把小孔的位置设在原点
 3. 将图像平面放在投影中心COP的前面(为了得到正立的相)
 4. 相机向负z轴看去(右手坐标系下)
</li>
<li>
<p>投影方程</p>
 <img src="/视觉_img/10_2.png" style="zoom:80%">
<ol>
<li>
<p>不是线性变换----&gt;采用3D齐次坐标。</p>
 <img src="/视觉_img/10_3.png" style="zoom:80%">
</li>
</ol>
</li>
<li>
<p>透视投影</p>
<ol>
<li>
<p>投影是使用齐次坐标的矩阵乘法：</p>
 <img src="/视觉_img/10_4.png" style="zoom:80%">
</li>
<li>
<p>改变投影变换的吃尺度对变换没有影响</p>
 <img src="/视觉_img/10_5.png" style="zoom:80%">
</li>
</ol>
</li>
<li>
<p>正交投影（平行投影）</p>
<ol>
<li>
<p>是透视投影的特殊情况：当光学中心COP到投影平面PP的距离是无限的时候。（1/d = 0）</p>
 <img src="/视觉_img/10_6.png" style="zoom:80%">
</li>
</ol>
</li>
</ol>
<h2 id="正交投影的变体"><a class="markdownIt-Anchor" href="#正交投影的变体"></a> 正交投影的变体</h2>
<ol start="5">
<li>
<p>缩放正交（弱透视）</p>
<p>相当于在物体聚焦到角点前就将图像截获。</p>
 <img src="/视觉_img/10_7.png" style="zoom:80%">
<p>分两步:</p>
<ol>
<li>第一步：整个物体按平行于光轴的方向正交投影到经过物体质心并与图像平面平行的平面上。</li>
<li>第二步：再按透视模型投影到图像平面上，这一步实际是全局的缩放。</li>
</ol>
</li>
<li>
<p>仿射投影</p>
 <img src="/视觉_img/10_8.png" style="zoom:80%">
<p>分两步：</p>
<ol>
<li>仍把物体平行投影到过质心且与图象平面平行的平面上，不过这次的投影线不是平行于光轴，而是平行于光心C和物体质心G的连线CG；</li>
<li>再按透视模型投影到图象平面上。</li>
</ol>
</li>
<li>
<p>总结</p>
</li>
</ol>
<img src="/视觉_img/10_9.png" style="zoom:80%">
<h2 id="降维"><a class="markdownIt-Anchor" href="#降维"></a> 降维</h2>
<ol>
<li>
<p>投影属性</p>
<ol>
<li>多对一：同一光线上的所有点映射到图像中的同一点。</li>
<li>点-&gt;点，线-&gt;线（通过角点的线变成一个点）</li>
<li>平面-&gt;平面（通过角点的平面变成一条线）</li>
<li>平行线在消失点汇合
<ol>
<li>每个方向在空间中都有他自己的消失点，但平行于图像平面的平行线保持平行。</li>
</ol>
</li>
</ol>
 <img src="/视觉_img/10_10.png" style="zoom:80%">
</li>
</ol>
<h2 id="相机参数"><a class="markdownIt-Anchor" href="#相机参数"></a> 相机参数</h2>
<p>现在我们要将世界坐标系中的一个点投影到相机坐标系中。我们需要知道相机在世界坐标系中的位置和方向。然后透视投影到图像平面上以获得像素坐标。</p>
<ol>
<li>
<p>相机内参数</p>
<ol>
<li>从世界坐标系原点到光心COP的平移变换T</li>
<li>描述相机方向的旋转变换R</li>
<li>焦距f、主点(x,y)、像素大小（sx,sy）</li>
</ol>
</li>
<li>
 <img src="/视觉_img/10_11.png" style="zoom:80%">
<p>·</p>
<p>·</p>
 <img src="/视觉_img/10_12.png" style="zoom:80%">
<p>这个公式要从右向左看</p>
<ol>
<li>平移矩阵即是将相机原点与世界原点重合。</li>
<li>第二步旋转，是将相机坐标系的三个轴旋转到与世界坐标系坐标轴平行。</li>
<li>第三步是将世界坐标系中的三维点透过光心进行投影。</li>
<li>第四步是使用相机内参数将图像变成离散的坐标。</li>
<li><strong>注意</strong> 该公式中对投影变换进行了拆分，，一部分与内参数乘在了一起。</li>
</ol>
</li>
</ol>
<h2 id="外参数让相机规范化"><a class="markdownIt-Anchor" href="#外参数让相机规范化"></a> 外参数—让相机规范化</h2>
<ol>
<li>
<p>第一步 平移-c，将相机坐标系原点与世界坐标系原点重合。<br />
<img src="/视觉_img/10_15.png" style="zoom:80%"></p>
<p>其中c为相机坐标原点在世界坐标系中的坐标[[tx,ty,tz]].T</p>
</li>
<li>
<p>第二步 旋转R， 将相机坐标系的轴旋转到与世界坐标系轴平行。</p>
 <img src="/视觉_img/10_16.png" style="zoom:80%">
</li>
</ol>
<h2 id="透视投影"><a class="markdownIt-Anchor" href="#透视投影"></a> 透视投影</h2>
<img src="/视觉_img/10_17.png" style="zoom:80%">
<h2 id="投影矩阵"><a class="markdownIt-Anchor" href="#投影矩阵"></a> 投影矩阵</h2>
<img src="/视觉_img/10_18.png" style="zoom:80%">
<p><strong>注：</strong></p>
<ol>
<li>
<p>平移的三个参数是相机原点在世界坐标系中的坐标。</p>
</li>
<li>
<p>旋转的三个参数是相机坐标系的坐标轴在用世界坐标系的方向向量来表达的向量坐标的转置。</p>
</li>
<li>
<p><strong>将投影矩阵乘开</strong></p>
</li>
</ol>
<img src="/视觉_img/10_19.png" style="zoom:80%">
<img src="/视觉_img/10_13.png" style="zoom:80%">
<h2 id="透视失真"><a class="markdownIt-Anchor" href="#透视失真"></a> 透视失真</h2>
<ol>
<li>梯形失真</li>
<li>仰拍导致。解决：移轴镜头</li>
<li>外侧列更大</li>
<li>镜头失真：枕型，桶型–&gt;由不完美镜头引起</li>
<li><strong>修正径向畸变</strong><br />
<img src="/视觉_img/10_14.png" style="zoom:80%"></li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-视觉第9讲" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC9%E8%AE%B2/"
    >视觉第9讲</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC9%E8%AE%B2/" class="article-date">
  <time datetime="2020-03-30T03:17:13.883Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="随机抽样一致"><a class="markdownIt-Anchor" href="#随机抽样一致"></a> 随机抽样一致</h1>
<p>针对最小二乘法出现的离群点问题</p>
<ol>
<li>思路
<ol>
<li>先求得一条候选直线</li>
<li>计算与该直线的内群点</li>
<li>对于所有候选直线，选择内群点最多的那一条。</li>
</ol>
</li>
<li>RANSAC算法
<ol>
<li>
<p>思想：所有的内点将在平移向量上达成一致；少部分离群点彼此矛盾。</p>
</li>
<li>
<p>RANSAC只能在离群点少于50%时才能保证正确解。</p>
</li>
<li>
<p>衡量内点：通过阈值过滤</p>
<p>阈值与噪声量有关，通常噪声建模为高斯噪声，标准差为3个像素。</p>
<p>通过设置阈值，使高斯分布中95%的比例位于半径内。</p>
</li>
<li>
<p>算法完整过程</p>
<ol>
<li>
<p>随机选择s个样本点</p>
<p>通常s=可求解模型的最少样本点数</p>
</li>
<li>
<p>根据样本得到一个解</p>
</li>
<li>
<p>计算内点数</p>
</li>
<li>
<p>重复N次</p>
</li>
<li>
<p>选择具有最多内点的模型。</p>
</li>
<li>
<p>计算所有内点的平均平移向量。</p>
</li>
</ol>
</li>
<li>
<p>实验轮数</p>
 <img src="/视觉_img/9_1.png " style="zoom:80%">
<p>其中p为内点概率；s是每次实验使用的样本点数目；P为能最终找到正确解的概率；R为实验轮次</p>
</li>
<li>
<p>s的取值<br />
为自由度/2下取整</p>
 <img src="/视觉_img/9_2.png " style="zoom:80%">
</li>
<li>
<p>优点</p>
<ol>
<li>简单，通用</li>
<li>适用于许多不同的问题</li>
<li>实践中表现良好，通常比蛮力取样要好</li>
</ol>
</li>
<li>
<p>缺点：</p>
<ol>
<li>需要调整参数</li>
<li>有时需要大量迭代，耗费时间</li>
<li>内点概率极低时可能失败</li>
</ol>
</li>
</ol>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-视觉第8讲" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC8%E8%AE%B2/"
    >视觉第8讲</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC8%E8%AE%B2/" class="article-date">
  <time datetime="2020-03-30T03:17:13.881Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="图像配准"><a class="markdownIt-Anchor" href="#图像配准"></a> 图像配准</h1>
<p>问题：给定图像A和B之间的一组匹配项，如何计算从A到B的变换T？</p>
<ol>
<li>
<p>对于平移</p>
<ol>
<li>最简单的取n对匹配的移动平均值值<br />
<img src="/视觉_img/8_1.png" style = "zoom:80%" /></li>
<li>通过线性方程组求解
<ol>
<li>问题：对于n对匹配点，有2两个未知数和2n个方程–&gt;最小二乘法。</li>
<li>最小二乘法
<ol>
<li>
<p>最小二乘法公式</p>
 <img src="/视觉_img/8_2.png" style = "zoom:80%"/>
</li>
<li>
<p>矩阵形式</p>
 <img src="/视觉_img/8_3.png" style = "zoom:80%"/>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>对于仿射变化</p>
<ol>
<li>
<p>有6个未知数</p>
 <img src="/视觉_img/8_4.png" style = "zoom:80%"/>
</li>
</ol>
</li>
<li>
<p>对于同态映射（单应映射）</p>
<ol>
<li>有8个未知数，至少需要4个匹配对。</li>
</ol>
 <img src="/视觉_img/8_5.png" style = "zoom:80%"/>
 <img src="/视觉_img/8_6.png" style = "zoom:80%"/>
 <img src="/视觉_img/8_7.png" style = "zoom:80%"/>
</li>
<li>
<p>图像配准过程</p>
<ol>
<li>计算A和B的特征</li>
<li>匹配A和B之间的特征</li>
<li>使用匹配集计算A到B单应映射矩阵的最小二乘解。</li>
</ol>
</li>
<li>
<p>离群点（外点）</p>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-视觉第7讲" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC7%E8%AE%B2/"
    >视觉第7讲</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC7%E8%AE%B2/" class="article-date">
  <time datetime="2020-03-30T03:17:13.877Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="图像卷绕"><a class="markdownIt-Anchor" href="#图像卷绕"></a> 图像卷绕</h1>
<p>卷绕&amp;滤波：</p>
<p>滤波改变图像的值域</p>
<p>&lt;img src=&quot;/视觉_img/7-1.png&quot;style=“zoom:1%”&gt;</p>
<p>卷绕改变图像的定义域</p>
<p>&lt;img src=&quot;/视觉_img/7-2.png&quot;style=“zoom:1%”&gt;</p>
<h2 id="线性变换"><a class="markdownIt-Anchor" href="#线性变换"></a> 线性变换</h2>
<ol>
<li>
<p>缩放</p>
<p>&lt;img src=&quot;/视觉_img/7-3.png&quot;style=“zoom:1%”&gt;</p>
</li>
<li>
<p>旋转</p>
<p>&lt;img src=&quot;/视觉_img/7-4.png&quot;style=“zoom:1%”&gt;</p>
<ol>
<li>R<sup>-1</sup>=R<sup>T</sup></li>
</ol>
</li>
<li>
<p>镜像</p>
<ol>
<li>
<p>关于Y轴镜像</p>
<p>&lt;img src=&quot;/视觉_img/7-5.png&quot;style=“zoom:1%”&gt;</p>
</li>
<li>
<p>关于y=x镜像</p>
<p>&lt;img src=&quot;/视觉_img/7-6.png&quot;style=“zoom:1%”&gt;</p>
</li>
</ol>
</li>
<li>
<p>剪切</p>
</li>
<li>
<p>性质：</p>
<ol>
<li>原点映射到原点</li>
<li>直线映射到直线</li>
<li>平行线保持平行</li>
<li>保持比率</li>
<li>线性变换的组合仍然是线性变换。</li>
</ol>
</li>
</ol>
<h2 id="非线性变换仿射变换"><a class="markdownIt-Anchor" href="#非线性变换仿射变换"></a> 非线性变换–仿射变换</h2>
<p>&lt;img src=&quot;/视觉_img/7-8.png&quot;style=“zoom:1%”&gt;</p>
<p>方式变换是线性变换和平移变换的组合</p>
<ol>
<li>
<p>基本仿射变换</p>
<p>&lt;img src=&quot;/视觉_img/7-7.png&quot;style=“zoom:1%”&gt;</p>
</li>
<li>
<p>仿射变换的性质</p>
<ol>
<li>原点不一定映射到原点</li>
<li>直线映射到直线</li>
<li>平行线保持平行</li>
<li>保持比率</li>
<li>仿射变换的组合仍然是仿射变换</li>
</ol>
</li>
</ol>
<h2 id="投影变换透视变换单应映射"><a class="markdownIt-Anchor" href="#投影变换透视变换单应映射"></a> 投影变换(透视变换/单应映射)</h2>
<p>&lt;img src=&quot;/视觉_img/7-9.png&quot;style=“zoom:1%”&gt;</p>
<ol>
<li>8个自由度</li>
<li>投影变换的属性
<ol start="2">
<li>
<p>保直线</p>
</li>
<li>
<p>原点不一定映射到原点</p>
</li>
<li>
<p>不保平行</p>
</li>
<li>
<p>不保比率</p>
</li>
<li>
<p>投影的组合仍然是投影变换</p>
</li>
</ol>
</li>
</ol>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>&lt;img src=&quot;/视觉_img/7-10.png&quot;style=“zoom:1%”&gt;</p>
<h1 id="实现图像卷绕"><a class="markdownIt-Anchor" href="#实现图像卷绕"></a> 实现图像卷绕</h1>
<h2 id="前向卷绕"><a class="markdownIt-Anchor" href="#前向卷绕"></a> 前向卷绕</h2>
<p>将每个像素f (x,y)复制到g图中对应位置(x’,y’) = T(x,y)</p>
<ol>
<li>如果(x’,y’)不是整数，则将像素值分配给四个最近邻，记录每个点的权重并在最后归一化。</li>
<li><strong>问题</strong> 可能有空洞，效果是混叠与模糊</li>
</ol>
<h2 id="反向卷绕"><a class="markdownIt-Anchor" href="#反向卷绕"></a> 反向卷绕</h2>
<p>获取每个像素g(x’, y’) 在原图像中对应的位 置 (x, y) = T<sup>-1</sup>(x’<br />
, y’) 处的像素值f(x, y)</p>
<ol>
<li>如果(x,y)不是整数，则f(x,y)的颜色值通过原图像中邻域的插值获得，且可以使用滤波器来控制混叠。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-视觉第6讲" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC6%E8%AE%B2/"
    >视觉第6讲</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC6%E8%AE%B2/" class="article-date">
  <time datetime="2020-03-30T03:17:13.874Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="特征描述符"><a class="markdownIt-Anchor" href="#特征描述符"></a> 特征描述符</h1>
<ol>
<li>性质：
<ol>
<li>不变性：图像被变换，描述符应该不变</li>
<li>区分力：每个点的描述符是高度唯一的</li>
</ol>
</li>
</ol>
<h2 id="实现不变性"><a class="markdownIt-Anchor" href="#实现不变性"></a> 实现不变性</h2>
<ol>
<li>确保检测器是不变的</li>
<li>设计不变的特征描述符</li>
</ol>
<h2 id="旋转不变性"><a class="markdownIt-Anchor" href="#旋转不变性"></a> 旋转不变性</h2>
<p>通过寻找图像块的主导方向实现，主导方向为<br />
1. H的特征向量Xmax对应的λmax<br />
2. 梯度方向</p>
<h2 id="mops"><a class="markdownIt-Anchor" href="#mops"></a> MOPS</h2>
<ol>
<li><strong>步骤</strong>：
<ol>
<li>选出特征点周围40×40的窗口</li>
<li>缩放到1/5大小</li>
<li>旋转至水平</li>
<li>在以特征为中心的8×8窗口内采样</li>
<li>规格化：强度减去平均值除以标准差，使之均值为0，方差为1。</li>
</ol>
</li>
</ol>
<h2 id="sift"><a class="markdownIt-Anchor" href="#sift"></a> SIFT</h2>
<ol>
<li>
<p><strong>步骤</strong></p>
<ol>
<li>取特征周围16×16的窗口，划分为4×4单元格</li>
<li>为每个像素计算边缘方向(梯度方向-90°)</li>
<li>通过梯度幅值阈值去除弱的边缘</li>
<li>为剩余边缘<strong>方向</strong>建立直方图，得到16个单元格×8方向=128维描述符</li>
<li>将该128维描述符归一化到单位长度</li>
</ol>
</li>
<li>
<p>性质：</p>
<ol>
<li>可以处理视角变化</li>
<li>适应光照变化</li>
<li>快速高效</li>
</ol>
</li>
</ol>
<h1 id="特征匹配"><a class="markdownIt-Anchor" href="#特征匹配"></a> 特征匹配</h1>
<p>想找到最佳匹配</p>
<ol>
<li>定义距离函数来比较两个描述符</li>
<li>测试I2中所有的特征，找出距离最小的一个。</li>
</ol>
<h2 id="特征距离"><a class="markdownIt-Anchor" href="#特征距离"></a> 特征距离</h2>
<ol>
<li>定义为||f1-f2||
<ol>
<li><strong>问题</strong> 可能对不正确匹配给出小的距离。</li>
<li><strong>解决</strong> 定义距离比= ||f1-f2||/||f1-f2’||
<ol>
<li>f2是f1在I2中最好的SSD匹配</li>
<li>f2’是f1在I2中次好的SSD匹配</li>
<li>距离比可以对不正确的匹配给出较大的值，用阈值过滤即可。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="结果评估"><a class="markdownIt-Anchor" href="#结果评估"></a> 结果评估</h1>
<ol>
<li>最大化真阳性，最小化假阳性</li>
</ol>
<h2 id="roc-曲线"><a class="markdownIt-Anchor" href="#roc-曲线"></a> Roc 曲线</h2>
<img src="/视觉_img/6-1.png" style="zoom:1%">
<img src="/视觉_img/6-2.png" style="zoom:1%">
1. AUC:一个正例，一个负例，预测为正的概率值比负的概率值还要大的可能性。

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-视觉第5讲" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC5%E8%AE%B2/"
    >视觉第5讲</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC5%E8%AE%B2/" class="article-date">
  <time datetime="2020-03-30T03:17:13.871Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="特征不变性"><a class="markdownIt-Anchor" href="#特征不变性"></a> 特征不变性</h1>
<ol>
<li>
<p>不变性与协变性</p>
<ol>
<li>
<p>不变性：图像变换后，角点位置不变。</p>
<p>我们希望角点的位置对光照变换有不</p>
</li>
<li>
<p>协变性：如果有两张同一图像的变换版本，则应在相应的位置检测到同一特征。</p>
<p>我们希望角点对几何变换具有协变性。</p>
</li>
</ol>
</li>
<li>
<p>Harris检测器</p>
<ol>
<li>平移：
<ol>
<li>导数和窗口函数是平移不变的。</li>
<li>角点位置是平移协变的。</li>
</ol>
</li>
<li>图像旋转
<ol>
<li>形状是旋转不变的</li>
<li>角点位置是旋转协变的。</li>
</ol>
</li>
<li>仿射强度变化
<ol>
<li>
<p>对仿射强度变化部分具有不变性。</p>
 <img src="/视觉_img/5_1.png" style="zoom:80%">
</li>
</ol>
</li>
<li>缩放
<ol>
<li>对缩放不具有不变性。</li>
<li>实现尺度不变性：寻找使f具有局部最大值的尺度。
<ol>
<li>同时在位置和尺度上查找。</li>
</ol>
</li>
<li>自动尺度选择：规格化到固定尺度。
<ol>
<li>是在高斯金字塔中使用固定大小的窗口。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>高斯-拉布普拉斯算子(LoG)</p>
<p><a href="%22https://blog.csdn.net/touch_dream/article/details/62237018%22/a">高斯-拉普拉斯算子</a></p>
<ol>
<li>
<p>LoG是高斯函数的二阶导数</p>
</li>
<li>
<p>为了减少计算量，可以用高斯差分算子(DoG)来近似</p>
 <img src="/视觉_img/5_2.png" style="zoom:80%">
<p>该函数逼近是因为发现高斯二阶导和原高斯函数对sigma参数求导之后函数模型的关系如上述的公式，然后约等于右边的导数表达式（严格的话需要加上极限的）！模型逼近如下：好处是可以提高算法的效率减少计算量</p>
</li>
<li>
<p>LoG和DoG都是旋转不变的。</p>
</li>
</ol>
</li>
<li>
<p>Blob斑点检测器</p>
<ol>
<li>在空间和尺度上查找LoG算子的极大值和极小值。
<ol>
<li>
<p>将一个点与周围26个点比较，以求得极大值。</p>
 <img src="/视觉_img/5_3.png" style="zoom:80%">
</li>
</ol>
</li>
<li>特征尺度：产生拉普拉斯响应峰值的尺度。</li>
</ol>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-视觉第4讲" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC4%E8%AE%B2/"
    >视觉第4讲</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC4%E8%AE%B2/" class="article-date">
  <time datetime="2020-03-30T03:17:13.868Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="harris角点检测"><a class="markdownIt-Anchor" href="#harris角点检测"></a> Harris角点检测</h1>
<ol>
<li>不变的局部特征
<ol>
<li>几何不变性：平移、旋转、缩放</li>
<li>光度不变性：亮度、曝光率</li>
<li>局部特征的优点
<ol>
<li>局部性：由于特征是局部的，所以对遮挡和噪声鲁棒。</li>
<li>数量：一张图片中成百上千。</li>
<li>独特性：可以区分大量对象</li>
<li>效率：可实现实时性能。</li>
</ol>
</li>
</ol>
</li>
<li>好的特征
<ol>
<li>需要具有唯一性</li>
<li>在任何方向上移动窗口都导致大的变化–&gt;角点。</li>
</ol>
</li>
<li>Harris角点检测
<ol>
<li>
<p>通过比较平移前后窗口w内每个像素的差异平方和(SSD)</p>
</li>
<li>
<p>SSD:<br />
<img src="/视觉_img/4_1.png" style="zoom:80%"></p>
<ol>
<li>SSD越大越好</li>
<li>问题：计算每个点的SSD很慢。</li>
<li>对平移量进行泰勒级数展开。</li>
</ol>
</li>
<li>
<p>近似SSD</p>
 <img src="/视觉_img/4_2.png" style="zoom:80%">
 <img src="/视觉_img/4_3.png" style="zoom:80%">
 1. 对于水平边缘Ix=0;垂直边缘Iy=0;
 2. 对于矩阵H可以看作一个椭圆
<pre><code> &lt;img src=&quot;/视觉_img/4_4.png&quot; style=&quot;zoom:80%&quot;&gt;
 
 可以通过查看H的特征向量来找到导致最大和最小的E的方向。
 1. &lt;img src=&quot;/视觉_img/4_4.png&quot; style=&quot;zoom:80%&quot;&gt;
 2. 特征值与特征检测的关系：我们希望E(u,v)的最小值对于小的平移量(u,v)都大，此最小值由H的较小的特征值λ&lt;sub&gt;min&lt;/sub&gt;给出
</code></pre>
</li>
</ol>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-视觉第3讲" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC3%E8%AE%B2/"
    >视觉第3讲</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC3%E8%AE%B2/" class="article-date">
  <time datetime="2020-03-30T03:17:13.865Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="子采样"><a class="markdownIt-Anchor" href="#子采样"></a> 子采样</h1>
<ol>
<li>每隔一行一列丢弃一行一列</li>
<li>问题：导致噪声变多</li>
<li>解决：先滤波，再子采样</li>
</ol>
<h2 id="混叠"><a class="markdownIt-Anchor" href="#混叠"></a> 混叠</h2>
<ol>
<li>定义：当采样频率不够高时，无法捕捉图像中的细节。</li>
<li>解决：采样率≥2 * 图像中的最大频率&lt;=&gt;每周期至少两个样本</li>
<li>若原始图像频率太高，则先做高斯预处理，然后子采样。（高斯金字塔）</li>
</ol>
<h1 id="上采样"><a class="markdownIt-Anchor" href="#上采样"></a> 上采样</h1>
<h2 id="最简单方法"><a class="markdownIt-Anchor" href="#最简单方法"></a> 最简单方法</h2>
<p>重复每行每列n次</p>
<h2 id="图像插值"><a class="markdownIt-Anchor" href="#图像插值"></a> 图像插值</h2>
<img src="/视觉_img/3-1.png" style="zoom:80%">
### 重建滤波器
1. 目的是重建连续图像f
2. 步骤
	1. 将F转换成连续函数：
		f<sub>F</sub>(x)=F(x/d) 当x/d是整数，否则为0
	2. 用重建滤波器H来卷积
		f = h*f<sub>F</sub>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-视觉第2讲" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC2%E8%AE%B2/"
    >视觉第2讲</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC2%E8%AE%B2/" class="article-date">
  <time datetime="2020-03-30T03:17:13.862Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="边缘"><a class="markdownIt-Anchor" href="#边缘"></a> 边缘</h1>
<ol>
<li>
<p>来源：</p>
<ol>
<li>表面法线不连续</li>
<li>深度不连续</li>
<li>颜色不连续</li>
<li>光照不连续</li>
</ol>
</li>
<li>
<p>特征是图像强度函数中快速变化的地方：</p>
<ol>
<li>一阶导数的极值点</li>
<li>二阶导数为0的点</li>
</ol>
</li>
</ol>
<h2 id="图像导数求解"><a class="markdownIt-Anchor" href="#图像导数求解"></a> 图像导数求解</h2>
<img src="/视觉_img/1-6.png" style="zoom:1%">
<h2 id="图像梯度求解"><a class="markdownIt-Anchor" href="#图像梯度求解"></a> 图像梯度求解</h2>
<img src="/视觉_img/1-7.png" style="zoom:1%">
<ol>
<li>梯度点在强度增大最快的方向上</li>
<li>边缘方向与梯度方向垂直</li>
</ol>
<h2 id="去噪"><a class="markdownIt-Anchor" href="#去噪"></a> 去噪</h2>
<ol>
<li>
<p>问题</p>
 <img src="/视觉_img/1-8.png" style="zoom:1%">
</li>
<li>
<p>解决:先做平滑</p>
 <img src="/视觉_img/1-9.png" style="zoom:1%">
<ol>
<li>核一般不变，可以先求h的导数，以简化计算。</li>
</ol>
</li>
</ol>
<h1 id="边缘检测"><a class="markdownIt-Anchor" href="#边缘检测"></a> 边缘检测</h1>
<h2 id="高斯一阶导"><a class="markdownIt-Anchor" href="#高斯一阶导"></a> 高斯一阶导</h2>
<img src="/视觉_img/1-10.png" style="zoom:1%">
<h2 id="sobel算子"><a class="markdownIt-Anchor" href="#sobel算子"></a> Sobel算子</h2>
<img src="/视觉_img/1-11.png" style="zoom:1%">
<ol>
<li>是高斯导数的一般近似</li>
<li>标准定义中没有1/8，不会影响边缘检测</li>
<li>如果要得到正确的梯度值，1/8是必须的。</li>
</ol>
<h2 id="非最大抑制"><a class="markdownIt-Anchor" href="#非最大抑制"></a> 非最大抑制</h2>
<p>检测像素是否是梯度方向上的局部最大值，一般需要插值。</p>
<img src="/视觉_img/1-12.png" style="zoom:1%">
<h2 id="canny-边缘检测器"><a class="markdownIt-Anchor" href="#canny-边缘检测器"></a> Canny 边缘检测器</h2>
<p><strong>步骤</strong></p>
<ol>
<li>用高斯导数做滤波
<ol>
<li>大σ检测大尺度边缘</li>
<li>小σ检测细微边缘</li>
</ol>
</li>
<li>获得梯度的赋值和方向</li>
<li>非最大抑制</li>
<li>连接与滞后 阈值化（两个阈值）
<ol>
<li>高阈值寻找边缘曲线的起点</li>
<li>低阈值确定后继点</li>
</ol>
</li>
</ol>
<h1 id="尺度空间"><a class="markdownIt-Anchor" href="#尺度空间"></a> 尺度空间</h1>
<p><strong>性质</strong></p>
<ol>
<li>边缘位置随尺度(σ) 的增大而变化</li>
<li>随尺度增加，两条边缘有可能合并</li>
<li>随尺度增加，边缘不可能分成两个</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-区块链小论文" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B0%8F%E8%AE%BA%E6%96%87/"
    >区块链小论文</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B0%8F%E8%AE%BA%E6%96%87/" class="article-date">
  <time datetime="2020-03-30T03:09:41.423Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="摘-要"><a class="markdownIt-Anchor" href="#摘-要"></a> 摘    要</h1>
<p>区块链技术在电子加密货币、存证鉴伪、供应链溯源、选举投票、物联网等场景中有广泛应用。从最初的比特币，到后来代表区块链技术2.0的以太坊，再到现在的石墨烯技术上建立的去中心化应用，区块链技术在不断的完善着。本文将针对区块链技术及其发展，从数据结构、共识机制等角度探讨自己关于这几代区块链技术的认识和理解，最后再结合一个实例来讨论区块链3.0之后的去中心化应用及发展。</p>
<p>关键词：区块链；比特币； 数据结构； 共识机制；去中心化应用</p>
<h1 id="第1章-绪-论"><a class="markdownIt-Anchor" href="#第1章-绪-论"></a> 第1章  绪 论</h1>
<h2 id="11-区块链起源"><a class="markdownIt-Anchor" href="#11-区块链起源"></a> 1.1  区块链起源</h2>
<p>2008年中本聪综合前人在加密货币上的成果提出了比特币的概念，并于2009年1月3日挖出了创世区块，实现了数字世界的价值表示与价值转移，也引发了人们对其底层技术–区块链技术的探索。在比特币之前就有很多专家进行过加密货币的研究，并给出了自己方案，如亚当·贝克的哈希现金，哈尔·芬妮的比特黄金，戴伟的B-Money等。他们的方案存在着一个共同点，就是要通过计算机的计算来创造电子现金。在这种思想的基础上，中本聪融合前人观点，设计了基于工作量证明的共识机制，使得去中心化成为可能，最终解决了数字现金的问题。</p>
<h2 id="12-以太坊"><a class="markdownIt-Anchor" href="#12-以太坊"></a> 1.2  以太坊</h2>
<p>以太坊创始人维塔利克分析了比特币系统，在比特币系统的四点不足上建立以太坊。其目标是建立一个新的区块链，内设有成熟的图灵完备的语言，可以利用这种语言来编写代码，创建合约，实现任意的状态转换。</p>
<p>以太坊的突出贡献在于实现了智能合约，使区块链技术从数字货币向数字资产转变。对于由智能合约来控制的实体资产，引用萨博的例子来说明：&quot;例如，为了防止一部车被偷窃，除非确定拥有者完成正确的&quot;挑战响应协议&quot;，否则车是不会启动激活的。例如，如果车是贷款买的，当拥有者无法偿还贷款时，智能合约将会自动启动扣押令，并将车钥匙的控制权交给银行。一旦拥有者还清贷款，智能合约就移除扣押令。&quot;总而言之，以太坊的出现使得创造通证变得简单。随着物联网技术的发展，越来越多的机器需要通证，基于区块链技术，为机器设计专用的钱包和通证将成为未来物联网发展的又一可能。</p>
<h2 id="13-eos"><a class="markdownIt-Anchor" href="#13-eos"></a> 1.3  EOS</h2>
<p>在《区块链革命》中，商业思想家唐·塔普斯科特这样写道：&quot;区块链上运行的所有计算资源可以在整体上视为一台计算机。&quot;。仔细考虑使用一条区块链所需要的资源，包括带宽资源（相当于硬盘）、计算资源（相当于CPU）、        状态资源（相当于RAM），确实和一台计算机十分相似。以太坊曾把自己定位为一台&quot;全球分布式计算机&quot;，那么EOS就是建立在这台计算机上的软件系统，他代表了区块链应用的一种发展方向，即开发一条通用的基础公链，实现一切去中心化。通过相关资料，我发现EOS已经在许多方面大异于比特币和以太坊，比如他的共识机制、        区块产生方式，账户等，并且开创性的提出了基于角色的权限系统。目前来说，区块链技术想要落地应用还有很多问题没有解决，哪条路才是切实有效的也没有定论，未来等着我们去探索。</p>
<h2 id="14-结构安排"><a class="markdownIt-Anchor" href="#14-结构安排"></a> 1.4  结构安排</h2>
<p>本文共分为三大部分，首先从比特币说起，讲述我学习到的比特币系统，阐述其数据结构、共识机制，分析安全性等。之后，讨论代表区块链2.0的以太坊，由于他的共识机制基本与比特币相同，所以主要阐述了以太坊的三种主要的数据结构。第三部分，阐述了区块链应用的可能方向以及一款基于功能类公链的应用实例–Steemit。</p>
<h1 id="第2章-比特币系统的技术原理及安全分析"><a class="markdownIt-Anchor" href="#第2章-比特币系统的技术原理及安全分析"></a> 第2章 比特币系统的技术原理及安全分析</h1>
<p>在比特币系统中第一次给出了区块链技术的定义：&quot;区块链是数字世界中进行价值表示和价值转移的技术。&quot;而比特币作为区块链硬币，他的一面是表示价值的加密数字货币或通证，另一面是进行价值转移的分布式账本与去中心网络。本章将从分布式账本与去中心网络及数据结构的角度讨论比特币系统，并分析其安全性。</p>
<h2 id="21分布式账本与去中心网络"><a class="markdownIt-Anchor" href="#21分布式账本与去中心网络"></a> 2.1分布式账本与去中心网络</h2>
<p>威廉·穆贾雅在《商业区块链》中将比特币总结为四个要点分别是：点对点电子交易；不需要金融机构；加密证据而不是中心化信用；信用存在于网络，而不是某个中心机构。</p>
<p>现如今的数字世界中的货币有三种存在形式，包括中心化的在线支付，如微信、支付宝等；中心化互联网积分，如Q币等；去中心化的电子现金。在中心化的在线支付系统中流转的货币是各种法币的映射，这些映射来的&quot;数字货币&quot;本身没有价值，其价值依赖于法币本身的购买力。同样中心化的互联网积分，其价值不与任何法币想关联，        完全由发行公司决定，且只能用于购买这家公司的服务和产品。对于比特币系统的去中心网络比特币的价值由其算法保证，即使整体的算力出现波动，算法也能在至多2016个区块后通过调整目标阈值来调整挖矿难度，从而使得比特币系统的平均出块间隔维持在10分钟左右，以此保证了比特币系统内部比特币的价值稳定（与法币的汇率不是由比特币系统决定的）。比特币的以上优点很大程度上是得益于其分布式账本和去中心网络。</p>
<p>比特币的去中心网络由由众多轻节点和全结点组成，其中全节点包含所有比特币区块链的区块数据，轻节点仅包含自己相关的数据。并且比特币网络是开放的，任何服务器都可以加入成为全结点，共同维护这个去中心网络。由于网络没有一个类似于&quot;央行&quot;的中心化组织存储信息，所以所有用户持有的比特币信息都存在一个分布式账本中，可以认为同时存储在所有全结点中。</p>
<h2 id="22比特币系统的加密体制"><a class="markdownIt-Anchor" href="#22比特币系统的加密体制"></a> 2.2比特币系统的加密体制</h2>
<p>比特币与密码学是密不可分的，从比特币&quot;账户&quot;（实际是地址）产生就使用了非对称密码体制，到每次交易签名，再到区块链内部的梅克尔树，以及区块链间的哈希指针都反应了密码学原理。</p>
<p>首先，在生成一个比特币账户时，实际上我们得到的一对公私钥对，其中公钥的哈希值即为比特币地址，作为转账交易的收付款地址；而私钥用于对我支付的每一笔交易进行签名。当我发起一笔交易时，我将用我的私钥对这笔交易记录进行签名， 同时广播出我的公钥以便其他的节点能够验证这笔交易的合法性，同时我还要为这笔交易付一点&quot;小费&quot;。这样操作下来，再等上一段时间，我的交易就会被写入区块链中成为不可逆的交易。</p>
<p>比特币系统使用的哈希函数是 SHA-256。除了哈希函数本身的抗碰撞性和单向性外，应用于比特币系统的哈希值还有puzzle friendly的性质，即要求块头的哈希值小于某个目标阈值。以及难于计算，但易于验证的性质。这些性质一方面保证了区块链上数据的不可篡改性，另一方面也为各个节点达成共识提供了基础保障。</p>
<p>此外，这种密码体制的安全性还建立在一个好的随机源上，这样才能确保有足够大的搜索空间来保证安全性。</p>
<h2 id="23比特币区块链的数据结构"><a class="markdownIt-Anchor" href="#23比特币区块链的数据结构"></a> 2.3比特币区块链的数据结构</h2>
<p>比特币区块链是一条通过哈希指针连接起来的链表。后一的区块的哈希指针是通过前一区块的全部内容(包括前一区块的哈希指针)计算出来的。这样从最后一个区块就能知道前面的区块是否被修改，使得系统中的某些节点不需要保存全部区块信息。</p>
<p>每个区块中的数据是被打包进这个区块的一系列交易，这些交易按规则形成一颗梅克尔树。梅克尔树是一颗由哈希指针连接起来的哈希树，其中叶子节点是要打包进区块的交易信息，非叶子节点是由叶子节点计算而来的哈希值。这样设计有很多好处，比如一个轻节点如果想知道自己的交易(位于第n层)是否已经被打包进区块链中，那么他只需要向全节点请求他不在的那条路径上非叶子节点的哈希值。之后，它就可以先计算要验证交易的哈希值（这一定是已知的），再将这个哈希与全节点给出的第（n-1）层的哈希值共同计算(n-2)层的哈希值，如此迭代下去，最终可以求得这笔交易所在的梅克尔树的根哈希值。将这个根哈希值与全节点给出的根哈希值比较即可验证交易。这样设计使得更多的节点能够低门槛的连入比特币系统，增加了比特币系统的活跃程度。</p>
<p>此外，区块头部中也包含着很多的重要信息，比如比特币版本协议信息，指向前一个区块的指针，梅克尔树的根哈希值，挖矿的难度目标阈值，随机数等。这些信息对于比特币系统达成共识有着至关重要的作用。</p>
<h2 id="24比特币系统的共识机制"><a class="markdownIt-Anchor" href="#24比特币系统的共识机制"></a> 2.4比特币系统的共识机制</h2>
<p>所谓共识机制，指的是众多互不相识、互不信任的节点之间就交易的合法性达成一致意见。这对于比特币这样一个去中心化的网络十分重要，只有确保了共识机制，才能保证不同账本节点上数据的一致性和正确性。</p>
<p>比特币系统所采用的策略是工作量证明。简单来说就是通过求解一个随机数来使得块头的哈希值小于一个给定的目标阈值，这个过程也称为挖矿。从概率学的角度来说，每次实验都可以看作是一次伯努利实验。当试验次数很多，而成功概率很小的时候，我们就可以用泊松分布来近似。也就是说，在比特币系统中，想要得到记账权没有任何捷径可走，只能单纯的通过反复尝试不同的随机数来求解。这也就保证了每个挖出区块的节点都是做了大量的工作来维护这条区块链，从而保证了区块链上数据的一致性。</p>
<p>比特币系统在共识机制做出了两点创新。其一是引入了奖励机制，通过比特币奖励使得区块链上节点愿意打包交易，主动维护账本，加快了一致性的达成。其二是引入了随机性的概念，尽管比特币系统不是完全可靠的，但是一般来说经过6个区块后，出问题的概率会呈指数级下降。</p>
<p>实际上，共识机制的形成过程是一个投票过程，只不过比特币系统是通过算力进行投票。拥有较大算力的节点能够优先把自己认为合法的交易打包进区块中，即通过算力给这些交易投票。</p>
<h2 id="25-比特币系统的安全分析"><a class="markdownIt-Anchor" href="#25-比特币系统的安全分析"></a> 2.5 比特币系统的安全分析</h2>
<p>首先通过一个例子来简单的说一下比特币的转账过程。假设现在甲要向乙进行转账，那么甲会发起一个转账交易，并用自己的私钥进行签名，同时将收款人的姓名写为乙的地址，并发布出去。听到这个交易的节点，首先验证nbits域的设置是否符合难度要求；验证头的哈希是否小于等于目标阈值。然后验证body中的交易是否有甲的合法签名，这笔钱以前是否被花过。第三要验证这个区块是否是连在最长合法链上。假设这个区块已经被打包进了区块链中，那么沿着这个区块继续挖的区块也会来验证这笔交易。一般来说，经过6个区块后这笔交易就可以认为是这笔交易不可篡改。针对比特币的转账过程，我探究了以下几种安全问题。</p>
<h3 id="251-伪造转账交易"><a class="markdownIt-Anchor" href="#251-伪造转账交易"></a> 2.5.1 伪造转账交易</h3>
<p>首先，考虑攻击者能否转走别人账户上的比特币。这是不可能的。第一，因为比特币系统中合法交易需要交易发起方用自己的私钥进行签名，而私钥无法伪造，所以不能成功。第二，如果恶意节点强行将交易写入区块中，那么诚实的节点也不会认可这笔交易，同时攻击者也损失了一笔出块奖励，同样说明这种攻击难以实现。</p>
<p>一般情况下，发起交易的一方要广播自己公钥来让其他节点可以验证自己的签名合法性。假设现在有一个攻击者想要转走A账户上的比特币，那么他先伪造一笔A转出的转账交易，并用自己的私钥进行签名，同时广播自己的公钥说成是A的公钥。这样能否转走A账户上的比特币呢？也是不可能的，因为A账户上的比特币一定来自之前的某一笔交易，而之前交易的收款人地址正是A的公钥的哈希。由于攻击者的公钥哈希与这个收款地址哈希对不上，其他节点就不把他作为合法交易，也不会写进区块链中。</p>
<h3 id="252回滚交易数据"><a class="markdownIt-Anchor" href="#252回滚交易数据"></a> 2.5.2回滚交易数据</h3>
<p>假设现在A要向B转账5个比特币，A签名了这个交易并发布到网络上，表面看起来B已经得到这笔交易的输出。但是如果攻击者立即发布一笔交易将这5个比特币转给自己，由于两笔交易都有A的合法签名，所以两者都会被作为合法交易打包进区块链中。同时如果攻击者具有足够多的算力将回滚交易所在的链拓展成最长链，那么交易就会被回滚。这种通过向区块链中间插入某个区块来回滚某个已经发生的交易，又称为分叉攻击。防范这种攻击的简单方式是等待六个区块的确认，这样拓展回滚交易所在的链的难度就会大大增加。</p>
<p>分叉的原因有很多，实际上，即使完全正常运作的比特币系统中也会存在分叉。可能有两个节点几乎同时挖出了新的区块，并把它广播出去。由于网络延迟和节点间距离的差异最终导致不同的节点收到了不同的合法区块。按照比特币协议，一个节点只会接受第一个收到的合法区块，所以最终会导致区块链出现分叉。但这种分叉只是暂时的，随着时间的推移，两条分叉上的算力互相竞争，最终会以一方称为绝对的最长合法链而告终。</p>
<h3 id="253掌控最长合法链"><a class="markdownIt-Anchor" href="#253掌控最长合法链"></a> 2.5.3掌控最长合法链</h3>
<p>我们知道，新的区块的内容中包含前一区块的哈希值。也就是说，在正常情况下没有前一个区块就不能产生新的区块。并且比特币系统中，合法的区块应该是位于最长合法链上。现在如果有一个恶意节点想要掌握最长合法链，当他挖出一个区块后，先不广播，而是在这个区块的基础上接着挖下一个。直到自己手里这条链变成绝对的最长合法链再一起发布出去，从而使得其中的非法交易合法化。这种攻击很难奏效，因为比特币系统是基于算力进行投票的，所以攻击者想要将自己的链变成最长合法链有很大难度。</p>
<p>挖出区块而不广播的理由可能还包括盈利目的。假设某个节点挖出了第n+1个区块，但是不立即广播，然后接着这个区块继续挖第n+2块。当有其他节点挖出第n+1块时，他立即广播第n+1和n+2块。那么由他记账的区块链就变成了最长合法链，同时得到这两个区块的出块奖励，看起来就像是一步领先，步步领先。</p>
<p>但实际上，在比特币系统中，这种行为很难成功。这样做的成功前提是在别的节点挖出一个区块的时间里，他能保证挖出两个以上区块。这样做存在很大风险，有可能一个出块奖励也得不到。</p>
<h3 id="254比特币的匿名性"><a class="markdownIt-Anchor" href="#254比特币的匿名性"></a> 2.5.4比特币的匿名性</h3>
<p>比特币系统的匿名性是很难以维护的，因为区块链是公开的，并且区块链具有不可修改性。一旦有一次交易暴露了身份，那么这个影响将是永久性的。并且比特币作为一种虚拟货币，最终会和法币相关联，一旦与实体世界发生关系，那么就可能在用比特币支付和进行资金转入转出时发生隐私的泄漏。如果先不考虑与实体世界的联系，我们可以每次转账交易都生成一个新的地址，采用多路径转发的方式，使得从交易推理出身份的难度增大，从而加强匿名性。此外，市面上还出现了牺牲性能而增强匿名性的货币，如零币零钞等基于零知识证明的加密货币。但是由于普通用户对匿名性的要求并不高，所以并未被广泛使用。</p>
<h2 id="26-总结"><a class="markdownIt-Anchor" href="#26-总结"></a> 2.6 总结</h2>
<p>以上就是我对一些感兴趣的攻击比特币系统的手段分析。上述分析基础是比特币网络中大部分节点都是诚实的，恶意节点只是少数，不会占据51%以上的算力。然而近些年出现的矿场使得算力更加聚集，历史上就曾经出现过大型矿场占据51%以上的算力的情况(他们为了防止引起恐慌，自行分解了算力)。这说明比特币系统的安全性是相对的，想要持久的维护比特币系统的安全性就要维持比特币社区的活跃度，使得诚实的节点永远占据大多数。</p>
<h1 id="第3章-以太坊"><a class="markdownIt-Anchor" href="#第3章-以太坊"></a> 第3章 以太坊</h1>
<p>维塔利克在分析了比特币系统的缺陷的基础上提出了以太坊。目标是提供一个区块链，内置有成熟的图灵完备的编程语言，用这种语言可以创建合约来编码，实现任意状态转换功能。通过这种语言，按照ERC标准，我们可以编写出自己的智能合约，进行区块链上的状态转换，进行链上数字资产的转移。其开创性的智能合约使得区块链技术从数字现金向数字资产转移，为日后的应用奠定了基础。接下来的一部分主要描述一些关于以太坊的数据结构。</p>
<h2 id="31以太坊的数据结构"><a class="markdownIt-Anchor" href="#31以太坊的数据结构"></a> 3.1以太坊的数据结构</h2>
<p>首先，以太坊区别于比特币系统，设置了账户系统。在比特币系统中，每次交易都会把余额转到另一个零钱地址中。而以太坊中为了支持智能合约，就需要参与方有相对稳定的身份，所以改用账户系统，每次交易直接增删余额。以太坊被看作是由交易驱动的状态机，所以在以太坊中要保存状态和交易。因此，以太坊设置了三种树，分别是状态树，交易树，和收据树。</p>
<h3 id="331状态树-交易树-收据树"><a class="markdownIt-Anchor" href="#331状态树-交易树-收据树"></a> 3.3.1状态树、交易树、收据树</h3>
<p>建立状态树的目的是要建立一个从账户到状态的映射。其中以太坊账户为40位十六进制数，状态中包括余额，交易次数，如果是合约账户还包括代码和存储的变量。同时，要求这颗树上的数据不可篡改，便于查找，增加，删除，同时节省存储空间。此外，应该令轻节点易于验证某个键值对是否存在。于是以太坊在传统的Trie树的基础上，压缩路径，增加哈希指针得到了Modified Merkle Partricia Tree。</p>
<p>首先说Trie树，它常被用来存储单词，进行多模式串的模式匹配。在以太坊中，由于账户是由40位十六进制数构成，所以每个节点的分支最多有17种可能（加一个结束标志）。Trie树的优点是无需排序，即使插入顺序不一样，得到的结构也是一样的；同时它还具有很好的更新局部性，由于每个区块中涉及发生的交易是少数的，采用这种结构不需要去管其他的分支，增强了修改的性能。</p>
<p>Trie树的缺点也很明显，它有很大的存储浪费，并且实际的查找效率与树的深度有关。于是进一步的考虑Partricia tree，一种路径压缩的trie树。对于基数树的每个节点，如果该节点是唯一的儿子的话，就和父节点合并。当键值分布较为稀疏的时候，更新时需要打开压缩部分的概率就比较低，性能也就更好。而以太坊的地址就恰好是这种结构。</p>
<p>借鉴比特币系统的思想，将树中指针全部换成哈希指针得到了Merkle Partricia Tree(MPT)树。而以太坊系统中使用的是略作修改的MPT树，本质上没有改变。</p>
<p>以太坊的结构是一颗大的MPT树中包含很多小的MPT树，每个小的MPT就是一个合约账户。对于全节点来说，他维护的也不是一颗MPT，而是每产生一个新的区块就新建一颗MPT，这些树中大部分节点是共享的，只有少数更新的节点可能要新建分支。</p>
<p>我通过与比特币系统的对比，发现比特币系统中不需要保存历史状态，而是通过UTXO的输入输出计算得来。但是以太坊不同，由于账户的设计，智能合约的出现，每个交易被打包进区块链的时候，其账户余额也被改变。这样设计的优点是天然的防范了双花攻击。但是如果某个交易所在区块不在最长合法链上，为了保持账户余额和合法链上得到的交易的结果是一致的，就需要对分叉部分进行回滚。我认为这就是需要保存历史状态的原因。</p>
<p>至于交易树和收据树，他们本身也是一颗MPT树。每个交易执行完，会形成一颗收据树，记录这个交易的相关信息。交易树和收据树上的节点是一一对应的。但每个区块的交易树和收据树又是相互独立的。他们发布的交易本身也被认为是相互独立的。</p>
<h3 id="332bloom-filter"><a class="markdownIt-Anchor" href="#332bloom-filter"></a> 3.3.2bloom filter</h3>
<p>以太坊为了支持一些复杂的查询的查询操作，比如查询近十天里和某个智能合约相关的交易而设计了这个数据结构。对于这个问题，可能最开始的想法就是遍历这个链将符合规则的区块挑出来，但是对于轻节点来说，他不能保存所有区块的信息，同时也存在查找效率低下的问题。</p>
<p>而bloom filter结构可以理解为一个大的向量，称为摘要。是将每个元素取一个哈希，形成的一个向量，其中某位为1代表对应该哈希值的元素存在。假如现在要查找过去十天发生的和某个智能合约相关的交易。首先，查找区块块头的bloom filter，看看哪个块头的bloom fikter里有我要的交易类型。如果某个块头里有，再去相应的收据树的bloom filter中查找。每一步轻节点都可以向全节点请求少量的信息就可以查询下去，很好的解决了问题。即使考虑哈希碰撞，那么也只会出现误报，而不会出现漏报。而误报情况可以在逐渐细化的查询中被发现。</p>
<h3 id="333cache与dag"><a class="markdownIt-Anchor" href="#333cache与dag"></a> 3.3.3cache与DAG</h3>
<p>比特币的挖矿设备从最初的CPU，转向GPU，再到现在的ASIC芯片挖矿，设备趋向于专业化，挖矿门槛越来越高。这样不利于比特币系统的安全稳定，只有当算力足够分散的时候，发动51%以上算力的攻击才很困难。为了做到杜绝ASIC芯片，以太坊在莱特币的基础上改进了挖矿算法，使得求解从纯粹的算力竞争上转向内存竞争。</p>
<p>莱特币曾经是市值仅次于比特币的一种加密货币。他首先将内存引入了挖矿算法。他基于Scrypt加密算法，需要用大的内存来保存这个数组，否则每次都要重新计算。简单来说，Scrypt算法是先通过一个种子取哈希得到数组中的第一个元素，之后再将这个元素取哈希得到第二个，反复迭代得到后面的元素。但是对于轻节点来说，他只是想验证某个区块的合法性，却需要和矿工等量的计算。这与区块链的基本理念:难于计算，易于验证相悖。考虑到这个原因，莱特币只将这个数组设置为128K，这显然太小了，对于矿机来说，完全可以通过计算来弥补内存的薄弱。</p>
<p>以太坊在莱特币的基础上进行了改进。他规定了两个数据集，16M的cache和1G的DAG，其中DAG是通过cache计算得来。轻节点只需要保存cache即可验证区块，矿工通过DAG来计算随机数使最后的哈希值低于目标阈值。</p>
<p>Cache的形成与莱特币类似，也是从一个种子节点开始依次取哈希来填充数组。对于DAG，他首先从cache里随机读一个数，然后进行哈希计算，得到下一个要读取的数的位置。然后用cache中这个位置的数和当前的哈希值再计算出一个哈希。反复迭代256次，将最终得到的数填充到DAG的第一个位置。</p>
<p>对于矿工来说，在挖矿的时候，先根据块头和nonce值计算一个哈希，这个哈希映射到数组中的某一个位置。通过这个位置和其相邻位置的元素进行运算得到下一个要计算哈希的位置。反复迭代64次，最后得到的哈希值与目标阈值比较，看一下是否满足要求，不成功则换下一个nonce尝试。</p>
<p>对于轻节点，想要验证一个区块是否符合要求，他需要这个区块的nonce以及cache数组。验证的过程与挖矿类似，只是轻节点没有保存DAG中的元素，所以用到的部分需要从cache中重新计算生成。</p>
<h2 id="32智能合约"><a class="markdownIt-Anchor" href="#32智能合约"></a> 3.2智能合约</h2>
<p>关于智能合约，其智能可以理解为是一段自动执行的代码，无需外界干预，自动自治进行，运行在以太坊虚拟机中；合约可以看作一个管家，一个&quot;自治代理&quot;，它拥有自己的账户，交易发生时自动执行一段代码。借用V神的话就是&quot;他们收到交易信息后就相当于被捅了一下，然后自动执行一段代码&quot;。</p>
<p>如果说区块链存储的是状态，那么智能合约就是用于状态转换的方式。它像是一个特别的时钟，把世界从同步转向异步。</p>
<p>智能合约的出现使得创建通证变得简单。Komhar公司曾给出过ERC20通证发行过程，大体可以表述为：一个项目通过智能合约创建通证，这个通证是实体资产或线上资产的价值表示物。投资者（用户）发起交易，向智能合约转入以太币（ETH），智能合约自动运转，在满足一定规则后，它向投资者账户转入相应数量的通证。这里的通证大多对应以太坊区块链之外的资产。因此，以太坊的出现对区块链技术转向数字资产做出了巨大贡献。</p>
<h2 id="33以太坊共识机制与ghost协议"><a class="markdownIt-Anchor" href="#33以太坊共识机制与ghost协议"></a> 3.3以太坊共识机制与GHOST协议</h2>
<p>在比特币系统中，只有在最长合法链上挖出来的区块才有出块奖励。这使得挖出分叉的节点不甘心放弃自己链，对于大的矿池来说，他很有可能不顾一切的去挖自己的链使他成为最长链。这样做的优点是便于确认区块的合法性，也在一定程度上避免了双花。但是对于以太坊来说，这样做并不合适。以太坊设有账户系统，可以杜绝双花，而且以太坊的平均出块时间设定为15秒，分叉也会成为常态。因此，以太坊引入了GHOST协议，目的是在出现分叉后及时合并。</p>
<p>GHOST协议的核心思想是对没有竞争成为最长合法链的区块也发放一定的出块奖励。同时下一&quot;代&quot;区块要包含所有的叔父区块，并得到1/32个出块奖励的额外报酬。为了防止在挖矿难度较低的时候产生叔父而不当获利，以太坊规定叔父必须是7代以内。并且叔父区块中的交易不执行，因此也不检查交易合法性，只检查这个区块是否符合挖矿难度。</p>
<p>GHOST协议一方面保证了分叉及时被合并，另一方面也减少了ASIC矿机挖矿的必要性，有利于维持分布式账本和区中心化的稳定。在回避ASIC的问题的问题上，以太坊另一个做法是每年都宣称自己即将从工作量证明转为权益证明，从而有效的将以太坊挖矿限制在GPU挖矿的级别。</p>
<h1 id="第四章-区块链的应用与steemit博客"><a class="markdownIt-Anchor" href="#第四章-区块链的应用与steemit博客"></a> 第四章 区块链的应用与Steemit博客</h1>
<h2 id="41-区块链的性质"><a class="markdownIt-Anchor" href="#41-区块链的性质"></a> 4.1 区块链的性质</h2>
<p>想要将区块链投入应用，首先要明确区块链有什么用。有人总结区块链的性质总结为以下四条。</p>
<ol>
<li>
<p>第一，是不可篡改性。要修改一个区块中的数据，那么就要修改后面所有的所有区块。而共识机制的存在使得修改大量区块的成本极高，因此篡改几乎不可能实现。2018 年3 月，在网络零售集团京东发布的《区块链技术实践白皮书》中，京东认为，&quot;区块链技术（分布式账本）的三种应用场景是：跨主体协作，需要低成本信任，存在长周期交易链条。这三个应用场景所利用的都是区块链的不可篡改特性。多主体在一个不可篡改的账本上协作，降低了信任成本。区块链账本中存储的是状态，未被涉及的数据的状态不会发生变化，且越早前的数据越难被篡改，这使得它适用于长周期交易。&quot;</p>
</li>
<li>
<p>第二，是表示价值所需要的唯一性。比特币的出现使得数字世界中出现了一种不可复制的&quot;文件&quot;。腾讯CEO马化腾说&quot;区块链确实是一项具有创新性的技术，用数字化表达唯一性，区块链可以模拟现实中的实物唯一性。&quot;百度CEO 李彦宏说：&quot;区块链到来之后，可以真正使虚拟物品变得唯一，这样的互联网跟以前的互联网会是非常不一样的。&quot;</p>
</li>
<li>
<p>第三，是智能合约。智能合约的出现使区块链上可以进行更加复杂的交易，并且交易本身也不可篡改。在以太坊白皮书中，维塔利克写道：&quot;（合约）应被看成存在于以太坊执行环境中的&quot;自治代理&quot;，它拥有自己的以太坊账户，收到交易信息，它们就相当于被捅了一下，然后它就自动执行一段代码。&quot;</p>
</li>
<li>
<p>第四，是去中心自组织。在《去中心化应用》一书中，作者西拉杰·拉瓦尔（Siraj Raval）从两个维度看现有的互联网技术产品：一个维度是，在组织上是中心化的，还是去中心化的；另一个维度是，在逻辑上是中心化的，还是去中心化的。在他看来比特币在组织上是去中心化的，在逻辑上是集中的。</p>
</li>
</ol>
<p>根据这些性质，有人总结了五条区块链通向应用平台的可能路径。分别是通用类基础公链，功能类基础公链，行业类基础公链，联盟类基础公链，基础服务。在我看来，开发专用于某个功能的基础公链更可行，接下来通过Steemit来谈一谈区块链的应用。</p>
<h2 id="42-steemit"><a class="markdownIt-Anchor" href="#42-steemit"></a> 4.2 Steemit</h2>
<p>Steemit是基于steem公链平台的社交软件，类似于博客。可以通过发文章，写评论来赚钱，但没人直接付钱。这个平台促进内容生产者发布更加优质的内容，同时屏蔽掉劣质内容。</p>
<p>Steem链中有三种代币，分别是steem，steem power,steem dollar。其中，Steem币是Steem链的基础代币。Steem Power 相当于股权，只能持有不能买卖。Steem Dollar是公链中稳定代币，无论何时，SBD只能兑换成价值一美元的Steem币，维持内部代币价格稳定。</p>
<p>当作者发布一篇文章时，并不马上得到收益。其收益真正来源于持有SP用户的点赞，这点类似于EOS的权益证明。拥有SP越多的用户点赞带来的收益也越多，同时点赞用户也会得到一部分收益，类似于矿工打包交易时的得到的手续费。此外，SP用户还可点踩，当点踩的人足够多时，Steemit会隐藏这些内容。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>总的来说，区块链很有可能成为互联网上的新层次，专门用于进行价值表示和价值转移。 在其上可以建立区块链应用，以利用区块链的价值表示和价值转移特性，在链上进行数字资产的转移。同时这些数字资产被映射成链上原生资产，线上资产或线下资产，从而改变目前人类的生成生活方式，影响金融、军事、教育乃至生活的方方面面。</p>
<p>通过本次大作业的机会，我充分学习了关于区块链的内容。区块链的诸多性质中，去中心化的性质尤其吸引我。在中心化的网络中，我们的数据是不安全的，每天倡导安全的组织却能轻易掌握我们的数据；我们的思想可能是被蓄意引导的；努力工作得到的货币也未必是保值的；同时，离开中心我们也是生存不下去的。也许去中心化的系统中存在着混乱，比如区块链中的分叉，但是我认为混乱也是一种自治，或许目前的去中心化的结构还不完善，性能还不够强大，但我相信在不远的将来，我们就可以在生活的方方面面感受到去中心后的便利。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/8/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/10/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        John Doe
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>