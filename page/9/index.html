<!DOCTYPE html>


<html lang="en" >


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Hexo
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

  <script type="text/javascript"
	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-北大网课" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%8C%97%E5%A4%A7%E7%BD%91%E8%AF%BE/"
    >北大网课</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%8C%97%E5%A4%A7%E7%BD%91%E8%AF%BE/" class="article-date">
  <time datetime="2020-03-30T03:00:53.091Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="哈希函数与加密体制"><a href="#哈希函数与加密体制" class="headerlink" title="哈希函数与加密体制"></a>哈希函数与加密体制</h1><ol>
<li>性质：<ol>
<li>抗碰撞性：难以人为制造哈希碰撞。</li>
<li>单向性：前提是输入空间足够大并且输入的分布比较均匀。(如果输入空间不够大，那么把输入后面拼接一个随机数再哈希)</li>
<li>puzzle friendly:比特币特有的性质。比特币区块要求计算出来的哈希值小于等于某一个阈值。</li>
<li>难以计算，但是易于验证。</li>
</ol>
</li>
<li>比特币中用的哈希函数:SHA-256</li>
<li>账户：在本地创建一个公私钥对就是一个账户。</li>
<li>非对称加密体系：公私钥。加密用公钥，解密用私钥，且加密和解密用的是用一个人的公钥和私钥。<ol>
<li>私钥保存在本地就行，公钥可以公开。</li>
<li>公钥相当于你的银行账号，私钥相当于银行密码。</li>
</ol>
</li>
<li>对称加密体系：加密解密使用同一个密钥，假设前提是存在一种安全的渠道把密钥分发给通信双方。</li>
<li>比特币系统中的公钥和私钥<ol>
<li>比特币系统中的信息都是公开的</li>
<li>所以私钥用来对交易做签名。我发起一个交易，那么我拿我的私钥进行签名，发布到区块链上，别人再用我的公钥进行验证。 </li>
</ol>
</li>
<li>以上所述的公私钥体制建立在有一个好的随机源上，同时每次签名操作也需要一个好的随机源。</li>
</ol>
<h1 id="比特币中的数据结构"><a href="#比特币中的数据结构" class="headerlink" title="比特币中的数据结构"></a>比特币中的数据结构</h1><ol>
<li><p>哈希指针：比如一个哈希指针指向一个结构体，那么这个指针里不止存它的地址还存它的哈希值。</p>
</li>
<li><p>区块链&amp;普通链表</p>
<ol>
<li><p>以哈希指针代替普通指针。</p>
</li>
<li><p>后一块的哈希指针是通过前一区块的全部内容(包括前一区块的哈希指针)计算出来的。</p>
<p> <strong>这样从最后一个区块就能知道前面的区块是否被修改。</strong></p>
<p> <strong>这样系统中的某些节点就不需要保存全部区块信息</strong></p>
</li>
<li><p>梅克尔树</p>
<img src="/Iptables_img/2.png" style="zoom:80%">        
 1. 每个区块内部的交易组织成梅克尔树的形式
 2. 区块间通过哈希指针连接在一起。 </li>
<li><p>比特币网络由轻节点和全结点构成，其中</p>
<ol>
<li>轻节点只保存区块头；当轻节点想确认某笔交易是否已经被写进区块链中：轻节点向全节点请求红色的哈希值，轻节点自己计算绿色的哈希值。最终，可以将得到的根哈希值和头部中的根哈希值相比较。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="BTC协议：比特币的共识机制"><a href="#BTC协议：比特币的共识机制" class="headerlink" title="BTC协议：比特币的共识机制"></a>BTC协议：比特币的共识机制</h1><p>比特币需要解决问题：双花；发行</p>
<h2 id="双花问题"><a href="#双花问题" class="headerlink" title="双花问题"></a>双花问题</h2><ol>
<li><p>转账：假如A要向B和C转帐</p>
<ol>
<li><p>交易需要A的签名，证明是经过A统一 的。 </p>
</li>
<li><p>需要指明A的比特币从哪来</p>
</li>
<li><p>注：比特币系统中的交易包括输入和输出两部分，输入部分要指明币的来源，输出部分要给出收款人的公钥的哈希。</p>
<img src="/Iptables_img/8.png" style="zoom:80%">

<p>注意：其中包含两种哈希指针。一种用来构成链表，另一种用来指向前面某个交易，以说明币的来源。</p>
</li>
<li><p>A需要知道B的公钥，B乃至所有节点也需要知道A的公钥，用来验证A的签名。因为怀疑网络中存在恶意节点，所以每个节点都需要亲自验证。</p>
<p> <strong>问题</strong>：A的公钥需要A自己去公布；如果某个恶意节点伪造了转账记录，用自己的私钥去签名，再公开自己的公钥说是A的公钥，那么可以转走A上钱么？</p>
<p> <strong>不</strong>，因为每个交易要去追溯币的来源，最终会追溯到币基交易，而币基交易（前面的交易）的输出正是A的哈希地址，只有当转帐中用到的公钥和这个哈希能对上，才能认为合法。</p>
</li>
<li><p><strong>注</strong>：加密是用接收者的公钥加密，接收者用自己的私钥解密。 </p>
</li>
</ol>
</li>
<li><p>区块的头部，包括</p>
<ol>
<li>比特币协议版本信息</li>
<li>指向前一个区块的指针</li>
<li>梅克尔树的根哈希值</li>
<li>挖矿的难度目标阈值（整个块头的哈希要小于等于目标阈值）</li>
<li>随机数</li>
</ol>
</li>
<li><p>分布式共识</p>
<ol>
<li>比如分布式哈希表：需要取得共识的是哈希表中包含了哪些 键值对。</li>
</ol>
</li>
<li><p>比特币的共识协议：问题出现在比特币系统中部分节点是有恶意的。</p>
<ol>
<li>最简单的，想要通过投票来判断某个节点产生的区块是否正确（区块内部的交易是否都是合法的）。但是存在一个问题，就是如何判断谁有投票资格。<ol>
<li><strong>女巫攻击</strong>：产生大量的公私钥对，极端情况下超过半数，那么他就得到了控制权。  </li>
</ol>
</li>
<li>通过<strong>算力</strong>来投票，每个节点都可以在本地组装候选区块，把他认为合法的交易放进去。然后开始算能够使得头部的哈希值小于目标阈值的随机数的值，找到了这个随机数的节点就获得了记账权，向比特币网络中发布这个区块<ol>
<li>其他节点收到这个区块后，首先验证nbits域的设置是否符合难度要求；验证头的哈希是否小于等于目标阈值。</li>
<li>然后验证body中的交易<ol>
<li>是否是合法的签名</li>
<li>以前是否被花过</li>
</ol>
</li>
<li>即使通过了前面的检查，但是该区块不是连接在最长合法链的末尾，也不接受。因为验证交易合法性时候，只去验证他所在的分支。<ol>
<li><strong>分叉攻击</strong>：通过向区块链中间插入某个区块来回滚某个已经发生的交易。<img src="/Iptables_img/13.png" style="zoom:80%"></li>
</ol>
</li>
<li>接受一个区块意味着沿着这个区块继续往下扩展。如果产生的链不是基于最长的链，那么他在该链上通过币基交易得到的比特币也是不被认可的非法交易。</li>
</ol>
</li>
</ol>
</li>
<li><p>为什么要争夺记账权？为了币基交易的比特币奖励。 </p>
</li>
<li><p><strong>总结</strong>：比特币系统中的共识是针对分布式账本内容-&gt;只有获得记账权的节点才有权力向账本里写东西，有权决定账本中的内容-&gt;获得记账权需要算力支持-&gt;比特币的投票是基于算力的。</p>
<ol>
<li>比特币的性质：puzzle friendly，即想计算出结果，没有捷径，只有一个个试。</li>
</ol>
</li>
</ol>
<h1 id="比特币系统的实现"><a href="#比特币系统的实现" class="headerlink" title="比特币系统的实现"></a>比特币系统的实现</h1><ol>
<li>比特币使用基于交易的账本模式</li>
<li>比特币系统的全节点要维护一个UTXO的数据结构（所有没被花掉的交易输出组成的集合）以检查双花问题。  </li>
<li><strong>比特币激励机制2</strong>：交易费，激励争夺记账权的节点将他人的交易打包进区块。</li>
<li>想要使哈希值低于根哈希值，一个使太正nance，另一个使调整coinbase，这样搜索空间就达到了2<sup>96。</li>
<li>求解puzzle过程<img src="/Iptables_img/14.png" style="zoom:80%">

</li>
</ol>
<p>其中tx那一串在实际上只需要梅克尔树的根哈希值即可。</p>
<h2 id="挖矿的概率分析："><a href="#挖矿的概率分析：" class="headerlink" title="挖矿的概率分析："></a>挖矿的概率分析：</h2><ol>
<li>每次挖矿的过程可以看作是一个伯努利试验。大量的伯努利实验构成一个伯努利程序。<ol>
<li>性质1：无记忆性</li>
</ol>
</li>
<li>试验次数很多，但是实验成功的概率很小的时候，可以用泊松分布来近似。</li>
<li>整个系统的出块时间是服从指数分布的，平均是10分钟。这个指数分布也是无记忆的。所以将来还要挖多少时间和过去已经挖了多少时间是没有关系的。这也保证了算力强的矿工拥有成比例的优势。</li>
</ol>
<h2 id="比特币系统的总量"><a href="#比特币系统的总量" class="headerlink" title="比特币系统的总量"></a>比特币系统的总量</h2><ol>
<li>比特币区块奖励是固定的，每个四年减半一次，所以比特币的数量会构成一个几何序列。可以计算出一共只有2100万个比特币。  </li>
</ol>
<h2 id="挖矿的意义"><a href="#挖矿的意义" class="headerlink" title="挖矿的意义"></a>挖矿的意义</h2><ol>
<li>挖矿本身并不解决什么问题，但是其算力竞争对于维护比特币系统的安全性是至关重要的。只要大部分算力是掌握在诚实节点手里，那么安全性就得以保证。</li>
</ol>
<h2 id="安全性分析："><a href="#安全性分析：" class="headerlink" title="安全性分析："></a>安全性分析：</h2><ol>
<li>恶意节点能否将别人的比特币转走：<strong>不能</strong>，无法伪造签名。如果他把交易硬写到区块链里，那么诚实的节点不会认可这个交易，因为他包含了一个非法的交易</li>
<li>恶意节点能否双花（<strong>分叉攻击</strong>）<ol>
<li>简单的防范方法是多等待几个区块（几个确认）（比特币协议中是等待6个确认），这样写入了回滚交易的区块想要使自己所在的分支成为最长合法链的难度就大大增加。</li>
</ol>
</li>
<li>恶意节点故意不包含某些交易<ol>
<li>但是问题不大，总有诚实的节点愿意将交易写入区块。即使不在这个区块里写入，也会写在下一个区块里。</li>
<li>正常的情况下，也有可能出现这种情况，因为比特币协议要求每个区块不得大于1MB。</li>
</ol>
</li>
<li>selfish mining攻击：挖到区块先不发布，攒了一堆再去发布以争夺最长合法链<ol>
<li><strong>不行</strong>：这对算力要求很大，起码要占据51%以上的算力才有一定的成功的可能性。但是话说回来，如果恶意节点占据了如此大的算力，比特币系统就崩盘了。</li>
<li><strong>出于盈利目的</strong>：如果一个节点的算力特别强，他挖到n+1个区块，之后不发布并立即开始挖第n+2个区块。等到侦听到有人挖到第n+1个区块的时候，他立刻将n+1和n+2个区块同时发布，那么他所在的链就成为了最长合法链，他得到的币基交易才是真实有效的。<ol>
<li>存在很大的风险：我们只有在假设别人挖出一个的时间里，我可以挖出两个，才能获得更大的利益。如果别人挖完第一个而我没有挖出第二个，那么我只能去碰碰运气。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="比特币网络"><a href="#比特币网络" class="headerlink" title="比特币网络"></a>比特币网络</h1><ol>
<li>比特币工作在应用层，其底层运行的是一个P2P Overlay网络，且这里的P2P网路中所有节点都是对等的。网络存在一个种子节点，可以通过它直到网络中其他节点的信息。节点之间通过TCP连接（这样有利于穿透防火墙）</li>
<li>每个节点维护一个临近节点集合(临近节点的选取是随机的，而不考虑底层拓扑结构)，消息传播采用洪范方式</li>
</ol>
<h1 id="比特币系统的挖矿难度"><a href="#比特币系统的挖矿难度" class="headerlink" title="比特币系统的挖矿难度"></a>比特币系统的挖矿难度</h1><ol>
<li>通过调整目标空间占搜索空间的比例来调整挖矿难度。</li>
<li>挖矿难度和目标阈值是成反比的。</li>
<li>为什么要维护挖矿难度：<ol>
<li>如果不调整这个难度，那么随着挖矿的人数增多，设备的进步，那么相对于网路延迟来说，生成区块的速度过快，从而导致多分叉。分叉过多对系统达成共识没有帮助，也会危害到系统的安全性。</li>
<li>回顾分叉攻击：我们只有在假设大部分的算力都掌握在诚实的矿工手里的时候才能避免。如果出现多分叉，那么算力被分散，被分叉攻击的可能性大大增加。</li>
</ol>
</li>
<li>比特币系统规定每个2016个区块调整一次，大约14天一次。且增大和减小都有要求，增大不会一次性增大超过4倍，减少也不会一次减少到1/4以上。</li>
</ol>
<h1 id="比特币挖矿"><a href="#比特币挖矿" class="headerlink" title="比特币挖矿"></a>比特币挖矿</h1><ol>
<li><p>比特币系统包括全节点和轻节点</p>
 <img src="/Iptables_img/27.png" style="zoom:80%">

<p> 全节点：</p>
<ol>
<li><p>决定沿着那条链挖下去：缺省情况下，沿着最长合法链挖下去。</p>
</li>
<li><p>出现等长分叉：选择最先听到的分叉。</p>
<img src="/Iptables_img/28.png" style="zoom:80%">

<p>轻节点：</p>
</li>
<li><p>只能检测合法链，但是不知道哪个是最长合法链。</p>
</li>
<li><p>轻节点假设矿工是有理智的，不会沿着非法的链挖下去。</p>
</li>
<li><p>轻节点在挖矿过程中，如果监听到别的节点已经挖出了新的区块，那么它只能放弃已有的区块。因为梅克尔树的跟哈希值和组成链的哈希指针都发生了变化。尽管如此，这并不可惜，因为挖矿具有无记忆性，成功的概率是没区别的。</p>
</li>
</ol>
</li>
<li><p>比特币的安全性保障</p>
<ol>
<li>由密码学提供：无法伪造的私钥签名。这个的前提是比特币网络中大多数节点都是好的，不会接受不合法的交易。</li>
<li>由比特币的共识机制提供</li>
</ol>
</li>
<li><p>矿石：使得51%以上的攻击变得容易。</p>
</li>
<li><p>矿石可发动的攻击：</p>
<ol>
<li>分叉攻击：</li>
<li>Boycott：比如想封锁A账户，可以在任何包含A的交易的区块被发布之后，立刻组装新的不包含A 的交易的区块，并经可能是新区块所在链变为最长合法链。</li>
</ol>
</li>
</ol>
<h1 id="比特币分叉"><a href="#比特币分叉" class="headerlink" title="比特币分叉"></a>比特币分叉</h1><ol>
<li>state fork:两个节点几乎同时挖到了区块。</li>
<li>forking attack（deliberate fork）</li>
<li>protocal fork:由于比特币协议修改导致的分叉<ol>
<li>硬分叉：这样的分叉是永久的，只要有算力不更新软件就存在。</li>
<li>软分叉：临时性的分叉</li>
</ol>
</li>
</ol>
<h1 id="比特币的匿名性"><a href="#比特币的匿名性" class="headerlink" title="比特币的匿名性"></a>比特币的匿名性</h1><ol>
<li><p>假的匿名，类似于化名不是绝对的。而且比特币的账本是完全公开的，对匿名性一种挑战。</p>
</li>
<li><p>实际上不同的地址可能被关联在一起。通过推理出来。</p>
</li>
<li><p>如果交易只在区块链内，则不会泄漏。但是一旦和实体世界发生关联，那么就可能泄漏隐私，具体在：</p>
<ol>
<li>比特币支付</li>
<li>资金转入转出的时候</li>
</ol>
</li>
<li><p>提高匿名性的方法</p>
<ol>
<li>首先要实现网络层的匿名性：采用多路径转发的方法。</li>
<li>混合币</li>
</ol>
</li>
<li><p>保护匿名性很难的原因：（1）区块链是公开的（2）区块链具有不可修改性，一旦某一个交易暴露了身份，影响会是永久的。</p>
</li>
</ol>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><h2 id="哈希指针"><a href="#哈希指针" class="headerlink" title="哈希指针"></a>哈希指针</h2><ol>
<li>实际上比特币系统只有哈希没有指针。在全节点中,所有的区块是以levelDB这种键值对数据来存储,其中key为哈希值,value为区块内容。</li>
</ol>
<h2 id="区块恋"><a href="#区块恋" class="headerlink" title="区块恋"></a>区块恋</h2><ol>
<li>这样会严重影响私钥的安全性，因为私钥长度变短时，暴力破解的搜索空间大大降低。</li>
<li>所以应该用多重签名，其中每个私钥都是独立产生的。</li>
<li>如果两个人分手，那么所有的币都会被存在UTXO中。</li>
</ol>
<h2 id="分布式共识"><a href="#分布式共识" class="headerlink" title="分布式共识"></a>分布式共识</h2><ol>
<li>实际上比特币并没有达成真正意义的共识。随时可能被推翻。</li>
</ol>
<h2 id="比特币的稀缺性"><a href="#比特币的稀缺性" class="headerlink" title="比特币的稀缺性"></a>比特币的稀缺性</h2><ol>
<li>总量一定的东西并不适用于做货币。因为随着社会财富总值的增长，每单位该种货币就变得越来越值钱，先买的人就越来越富，后面的人就永远也赶不上。就像房地产。</li>
</ol>
<h1 id="以太坊概述"><a href="#以太坊概述" class="headerlink" title="以太坊概述"></a>以太坊概述</h1><ol>
<li>memory hard mining puzzle</li>
<li>以后想权益证明代替工作量证明，用类似于股权投票的方式。</li>
<li>智能合约：去中心化合约。加入参与方来自世界各地，那么手段维持合约的有效性就很困难，所以考虑写成程序，写进区块链。</li>
</ol>
<h1 id="以太坊中的账户"><a href="#以太坊中的账户" class="headerlink" title="以太坊中的账户"></a>以太坊中的账户</h1><ol>
<li>BTC中需要统计所有的UTXO。</li>
<li>账户天然的防护了双花问题。但是存在重放攻击。</li>
</ol>
<h2 id="重放攻击："><a href="#重放攻击：" class="headerlink" title="重放攻击："></a>重放攻击：</h2><ol>
<li>假设A给B转了一次帐，广播过一次，之后B又向网络广播这次交易。那么网络中的其他节点就会认为A又向B转账了一次。</li>
<li><strong>解决</strong>：多维护一个交易次数的属性，在签名的保护下一起发布出去。系统中的全节点维护这个交易次数值。假设A-&gt;B是第20次，那么全节点认为下次来的应该是第21，那么即使B重放，也不行。</li>
</ol>
<h2 id="外部账户"><a href="#外部账户" class="headerlink" title="外部账户"></a>外部账户</h2><ol>
<li>由公私钥控制，包括账户余额和交易次数。</li>
</ol>
<h2 id="合约账户"><a href="#合约账户" class="headerlink" title="合约账户"></a>合约账户</h2><ol>
<li>不是由公私钥对控制，也有nonce值，用来标识调用别的合约的次数。还有code，storage。但是合约账户不能主动发起交易。</li>
</ol>
<h2 id="为什么有合约"><a href="#为什么有合约" class="headerlink" title="为什么有合约"></a>为什么有合约</h2><ol>
<li>为了支持智能合约，要求参与者有相对稳定的身份。</li>
</ol>
<h1 id="以太坊状态树"><a href="#以太坊状态树" class="headerlink" title="以太坊状态树"></a>以太坊状态树</h1><p>目的是建立一个账户到状态的映射。以太坊的账户为160b，状态包括余额、交易次数（代码，存储）。</p>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><ol>
<li><p>优点：</p>
<ol>
<li>每个节点的分叉数目取决于取值范围。</li>
<li>查找效率取决于键的长度。</li>
<li>插入顺序不一样，得到的结构也一样。</li>
<li>更新局部性很好，每个区块对应的账户很少，伊这种结构不需要管别的分支</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>存储浪费</li>
<li>查找效率与深度有关</li>
</ol>
</li>
</ol>
<h2 id="Patricia-tree"><a href="#Patricia-tree" class="headerlink" title="Patricia tree"></a>Patricia tree</h2><ol>
<li>是路径压缩的trie树。键值分布稀疏的时候比较好。</li>
</ol>
<h2 id="MPT-Merkle-Partricia-Tree"><a href="#MPT-Merkle-Partricia-Tree" class="headerlink" title="MPT Merkle Partricia Tree"></a>MPT Merkle Partricia Tree</h2><ol>
<li>路径压缩加路径压缩</li>
<li>优点：<ol>
<li>放篡改</li>
<li>可以证明账户上的余额。 </li>
<li>还可以证明某个键值是不存在的。</li>
</ol>
</li>
</ol>
<h2 id="Modified-MPT"><a href="#Modified-MPT" class="headerlink" title="Modified MPT"></a>Modified MPT</h2><ol>
<li>以太坊的结构是一颗大的MPT包含很多小的MPT，每一个合约账户就是一颗小的MPT</li>
<li>系统中的全节点维护的不是一颗MPT，而是每产生一个新的区块就新建一颗MPT,这些树中大部分的节点是共享的，只有少数更新的节点要新建分支。</li>
<li>保留历史状态是因为可能需要回滚交易，比如分叉的时候。以太坊由于智能合约的出现，所以很难去反向推算前一个状态，所以要保存。</li>
<li>状态树中保存的是键值对，地址作为key。而value要首先经过序列化之后再存储，大致理解为变成字节数组。</li>
</ol>
<h1 id="以太坊数据结构"><a href="#以太坊数据结构" class="headerlink" title="以太坊数据结构"></a>以太坊数据结构</h1><h2 id="交易树–也是一种MPT"><a href="#交易树–也是一种MPT" class="headerlink" title="交易树–也是一种MPT"></a>交易树–也是一种MPT</h2><ol>
<li>区块中的交易形成一颗交易树</li>
</ol>
<h2 id="收据树–也是一种MPT"><a href="#收据树–也是一种MPT" class="headerlink" title="收据树–也是一种MPT"></a>收据树–也是一种MPT</h2><ol>
<li>每个交易执行完，会形成一颗收据树，记录这个交易的相关信息。交易树和收据树上的节点是一一对应的。利于快速查找执行的结果。</li>
<li>每个区块的交易树和收据树都是独立的。他们发布的交易本身我们也认为是独立的。</li>
</ol>
<h2 id="bloom-filter"><a href="#bloom-filter" class="headerlink" title="bloom filter"></a>bloom filter</h2><ol>
<li>为了在大的集合中进行查找，以支持复杂的查询操作。</li>
<li>一般的扫描存在存储问题和查找效率问题。</li>
<li>将每个元素取一个哈希，形成一个向量，其中某位为1代表该对应该哈希值的元素存在，这个向量称为摘要。</li>
<li>不支持删除操作。 </li>
<li>作用：加入要查找过去十天发生的和某个智能合约相关的交易。首先，查找区块块头的bloom filter，看哪个块头的bloom filter里有我要的类型。如果某个块头里有，在去找对应收据树里的bf,看看哪个有。有的再去仔细查看。</li>
</ol>
<h2 id="以太坊的运行过程"><a href="#以太坊的运行过程" class="headerlink" title="以太坊的运行过程"></a>以太坊的运行过程</h2><p>看成是交易驱动的状态机。状态是所有账户的状态；交易每次发布区块包含的交易，这些交易会驱动从当前的状态转移到下一个状态。 </p>
<h1 id="GHOST协议–利于出现分叉后及时合并"><a href="#GHOST协议–利于出现分叉后及时合并" class="headerlink" title="GHOST协议–利于出现分叉后及时合并"></a>GHOST协议–利于出现分叉后及时合并</h1><ol>
<li><p>没有竞争称为最长合法链上的区块也会发放一定的出块奖励（7/8）称为叔父区块。下一个区块要包含所有叔父区块，同时得到1/32个出块奖励的额外报酬。最多可以包含两个叔父区块。</p>
</li>
<li><p>不在最长合法链上的区块都是叔父区块，即使是爷爷啥的。  </p>
</li>
<li><p>为了防止在挖矿难度较低的时候产生叔父而不当获利，最多7代。叔父区块中的交易不执行，所以也不检查交易合法性，只检查是否符合挖矿难度。</p>
 <img src="/Iptables_img/52.png" style="zoom:80%">    </li>
<li><p>GHOST机制是为了解决临时性的分叉。</p>
</li>
</ol>
<h1 id="以太坊的挖矿算法"><a href="#以太坊的挖矿算法" class="headerlink" title="以太坊的挖矿算法"></a>以太坊的挖矿算法</h1><ol>
<li>求解很难，验证简单、</li>
<li>回避ASIC芯片。</li>
</ol>
<h2 id="Lite币"><a href="#Lite币" class="headerlink" title="Lite币"></a>Lite币</h2><ol>
<li>基于Scrypt加密，需要大内存来保存这个数组。</li>
<li>但是设定小了，只有128K。</li>
</ol>
<h2 id="以太币"><a href="#以太币" class="headerlink" title="以太币"></a>以太币</h2><ol>
<li>有两个数据集，初始一个是16M的cache，另一个是1G的DAG。DAG从cache中生成出来。轻节点只需要保存cache便于验证。</li>
<li>cache形成 ：首先从一个种子节点开始依次去哈希来填充数组。</li>
<li>DAG形成：从cache里随机读一个数，然后进行哈希计算，得到下一个要读取的数的位置。然后用cache中这个位置的数和当前的哈希值再计算出一个哈希值，反复迭代256次，将最终得到的数填充到数组的第一个位置。</li>
<li>挖矿的时候，先根据块头和nonce值计算一个哈希，这个哈希映射到数组中的某一个位置。通过这个位置和相邻位置的元素进行运算得到下一个位置，循环64次，最后得到的哈希值与目标阈值比较，看一下是否成功。不成功则换下一个nonce。</li>
<li>生成cache的seed每隔3w个区块会变一下。同时cache和DAG大小会增加1/128。 </li>
</ol>
<h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><ol>
<li>外部账户可以调用合约，一个合约可以调用另一个合约。只有外部账户可以调用。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-po/区块链" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/po/%E5%8C%BA%E5%9D%97%E9%93%BE/"
    >po/区块链</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/po/%E5%8C%BA%E5%9D%97%E9%93%BE/" class="article-date">
  <time datetime="2020-03-30T03:00:51.075Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="比特币的诞生"><a href="#比特币的诞生" class="headerlink" title="比特币的诞生"></a>比特币的诞生</h1><ol>
<li><p>比特币目的是在数字世界，创造一个具有现金特性的事物</p>
</li>
<li><p>比特币组成成分</p>
<p> 1）加密数字货币</p>
<p> 2）分布式账本</p>
<p> 3) 去中心网络</p>
</li>
<li><p>目前的电子现金系统：依靠中心化数据库和可信的第三方中介来避免双花问题</p>
</li>
<li><p>比特币同时做到了去中介化和去中心化</p>
<p> 1） 个人与个人之间的电子现金无需可信第三方中介的介入，这是去中介化</p>
<p> 2）这个电子现金的货币发行也不需要一个中心化的机构，而是由代码与社区共识完成，这是去中心化</p>
</li>
<li><p>比特币系统三层结构</p>
<p> 1）最上一层是比特币这种电子现金。是整个系统的应用层</p>
<p> 2）中间一层的功能是发行比特币与处理用户见的比特币转移。这一层也叫比特币协议，是整个系统的应用协议层。（相当于中央银行（发行货币）与银行（处理转账）等金融机构间的关系）</p>
<p> 3）最底层是比特币的分布式账本和去中心化网络。这一层也被称为比特币区块链，是整个系统的通用协议层。</p>
</li>
</ol>
<h1 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h1><ol>
<li>定义：区块链是数字世界中进行价值表示和价值转移的技术。区块链硬币一面是表示价值的加密数字货币或通证，另一面是进行价值转移的分布式账本与去中心网络。</li>
<li>通证：基于区块链的价值表示无都称为通证。</li>
</ol>
<h1 id="加密数字货币前传"><a href="#加密数字货币前传" class="headerlink" title="加密数字货币前传"></a>加密数字货币前传</h1><ol>
<li>大卫·乔姆：<ol>
<li>盲签：在一张纸条上， 你选择一个只有你知道的序列号，然后我在上面签名。由于我不知道这个序列号，所以我没法再复制一份这张纸条给另一个人。</li>
<li>这个方案的缺点是：必须有一个所有参与者都薪人的中心化服务器来进行这些“数字纸条”的验证。</li>
</ol>
</li>
<li>尼克·萨博<ol>
<li>提出智能合约。智能合约是区块链处理交易的核心方式，区块链应用的实质可被看成是一个个智能合约的组合。</li>
</ol>
</li>
<li>哈尔·芬妮<ol>
<li>著名的PGP加密中的”G”</li>
</ol>
</li>
<li>中本聪<ol>
<li>首次建立了一个去中心化，非基于信任的系统。</li>
<li>它通过已有的公钥加密方式来管理所有权，并用一个名为工作量证明的共识算法来记录谁拥有货币。</li>
</ol>
</li>
</ol>
<h1 id="中心化"><a href="#中心化" class="headerlink" title="中心化"></a>中心化</h1><h2 id="数字世界中的货币有三种形式"><a href="#数字世界中的货币有三种形式" class="headerlink" title="数字世界中的货币有三种形式"></a>数字世界中的货币有三种形式</h2><ol>
<li>中心化的在线支付：<ol>
<li>在这些支付系统中流转的是映射到数字世界的各国法定货币（也乘法币）</li>
<li>法定货币的价值来自拥有者相信货币将来能维持其购买力，本身并无内在价值。 </li>
</ol>
</li>
<li>中心化的计算机点数或互联网积分<ol>
<li>不与物理世界的法币对应，而是由商业公司中心化发行，仅可以在一家公司的体系中使用，称为虚拟货币。如Q币</li>
</ol>
</li>
<li>去中心化的电子现金：比特币</li>
</ol>
<h2 id="比特币实现了极致的去中心化"><a href="#比特币实现了极致的去中心化" class="headerlink" title="比特币实现了极致的去中心化"></a>比特币实现了极致的去中心化</h2><ol>
<li>威廉·穆贾雅在《商业区块链》一书中对比特币白皮书摘要进行了分析，他总结了四个要点：<ol>
<li>点对点电子交易；</li>
<li>不需要金融机构；</li>
<li>加密证据而不是中心化的信用；</li>
<li>信用存在于网络，而不是某个中心机构。</li>
</ol>
</li>
<li>在《去中心化应用》一书中，开发者西拉杰·拉瓦尔对去中心化应用的去中心化程度进行了一番讨论。他认为，区块链可能在四个过去集中化的方面完成去中心化： 数据；财富；身份；计算。</li>
</ol>
<h2 id="比特币系统设计的五个要点："><a href="#比特币系统设计的五个要点：" class="headerlink" title="比特币系统设计的五个要点："></a>比特币系统设计的五个要点：</h2><p>比特币的区块链系统是由分布式账本（即狭义的区块链）和去中心网络（点对点网络）组成的，形成链条的方式是工作量证明共识机制。最长链是由网络中的算力共同决定的，因而它是可信的，节点离开和加入依据的是最长链是可信的这一原则。这些组合起来形成了比特币系统。</p>
<ol>
<li><p>去中心化的点对点电子现金</p>
</li>
<li><p>分布式账本</p>
<p> 比特币的区块链是基于工作量证明形成的带时间戳、存储数据的数据块和由哈希指针连接成的链条。</p>
<p> 这个链条或者说账本以分布式的方式存储在比特币网络的各个节点上，因而也被称为分布式账本。</p>
</li>
<li><p>工作量证明</p>
</li>
<li><p>最长链原则</p>
</li>
<li><p>去中心网络</p>
</li>
</ol>
<h1 id="比特币是如何转账的"><a href="#比特币是如何转账的" class="headerlink" title="比特币是如何转账的"></a>比特币是如何转账的</h1><h2 id="分布式账本和去中心网络"><a href="#分布式账本和去中心网络" class="headerlink" title="分布式账本和去中心网络"></a>分布式账本和去中心网络</h2><ol>
<li><p>比特币网络由众多轻节点和全结点组成，这些结点形成一个去中心网络，其中：</p>
<ol>
<li>全节点包含所有比特币区块链的区块数据</li>
<li>轻节点仅包含自己相关的数据。</li>
<li>比特币网络是开放的，任何服务器都可以加入成为全结点</li>
</ol>
</li>
<li><p>分布式账本：所有用户持有的比特币信息都存在一个分布式账本中；比特币账本可被认为同时存储在所有全结点中。</p>
</li>
<li><p>中心化在线支付系统的交易流程：交易双方通过中心化的交易平台中开设的账户完成交易。中心化在线支付系统维护一个中心化的账本，用户在账本上开设账户，通过密码(私钥)来与之交互。</p>
</li>
<li><p>比特币系统的交易过程：</p>
<ol>
<li><p>每个人在比特币区块链上建立账户(地址)，获得一对公钥和私钥，地址是公钥的哈希值，我们通过私钥与地址进行交互。</p>
</li>
<li><p>每个人有一个钱包，钱包中装的是私钥，转账时，可以通过各自的钱包软件直接进行。</p>
</li>
<li><p>对比而言，对于中心化在线支付系统，它通常是由中心化的服务器来管理集中式账本。对于比特币系统，它背后的系统是一个去中心网络，网络节点共同维护一个分布式账本。</p>
<p> &nbsp;比特币是记录在账本中的，看起来还是有一个“中心”？</p>
<p> &nbsp;其实，这个账本是分布式地存储在去中心网络中的，因而从这个层面看，它可以看成是去中心化的。</p>
</li>
</ol>
</li>
</ol>
<h2 id="UTXO-未使用的交易输出"><a href="#UTXO-未使用的交易输出" class="headerlink" title="UTXO:未使用的交易输出"></a>UTXO:未使用的交易输出</h2><ol>
<li><p>比特币系统中的账户：没有账户，只有地址(是公钥的哈希值)。如果愿意可以开始无限多的钱包地址，但是系统不会汇总形成账户。</p>
</li>
<li><p>所以转账是从我的一个钱包地址转到你的一个钱包地址。</p>
</li>
<li><p>UTXO</p>
<ol>
<li><p>通证经济专家孟岩曾撰写一篇文章，标题是“其实没有什么比特币，只有UTXO”，这个标题指出了，对于计算机来说比特币是什么——比特币是区块链账本上的交易输出。</p>
</li>
<li><p>例子：假</p>
<ol>
<li>如我有8比特币，说明之前有一个交易把这些比特币转入我的地址，这个交易的输出未被使用，我拥有了8个比特币。</li>
<li>现在我发起一个转账交易，这个交易的输入是我拥有的这些比特币的上一个交易。我转账给你，假设对我拥有的这8毕业比的上一个交易进行签名，把这一新转账交易的输出地址设为你的钱包地址。</li>
<li>这样，这8比特币就属于你了，你拥有的是我这个交易的未使用的交易输出。等矿工把这一交易打包进新的区块，转账交易完成。</li>
<li>交易中涉及比特币的公钥和私钥的非对称加密机制。钱包地址理解为房间号和锁，私钥则相当于钥匙，钥匙可以打开对应的锁。</li>
<li>对于每一笔比特币的源头，都有一种特殊的交易–创币交易。对于矿工赢得25比特币的创币交易，它的输入是0，而输出是25个比特币进到矿工的钱包地址中。</li>
</ol>
</li>
<li><p>UTXO的优点（相比于账户）</p>
<ol>
<li><p>UTXO设计易于确认比特币的所有权。</p>
<p> 想要转账，只需要确认上一个交易时真实的，我就的确拥有这些比特币。而一个区块经过6次确认，其中的交易可被认为是真实无误的。</p>
</li>
<li><p>UTXO设计与区块链账本是完全融为一体的</p>
<p> 区块链账本存储的是状态。区块链中的交易都是一种状态转换函数。每一个新区快和它之前的所有区块一起形成了一个新的状态。在确认之后，之前的状态就不可篡改。</p>
</li>
</ol>
</li>
<li><p>深入理解UXTO</p>
<ol>
<li>比特币就是UTXO<ol>
<li>当甲要把一笔比特币转给乙时，这个过程是把甲的钱包地址中之前的一个UTXO，用私钥进行签名，发送给乙的地址，这个过程就是一个新的交易，而乙得到的是一个新的UTXO。</li>
<li>世界上根本没有比特币，只有UTXO，你的地址中的比特币是指没花掉的交易输出。</li>
</ol>
</li>
<li>详细阐述从甲向乙的转账过程。<ol>
<li>假设A之前通过币基交易挖矿获得了12.5个比特币，那么在它的钱包地址中，就有了相应的UTXO</li>
<li>Alice发起一个转账交易，输入是自己的上一个交易，输出是B的地址，数量是12.5比特币，A用自己的私钥进行签名。</li>
<li>当交易的区块链确认后，A的UTXO变成0.而B的地址中就多了一个UTXO，数量是12.5.</li>
<li>存在B的地址中的这些比特币只有用B的私钥进行签名才可以转账给其他人。</li>
<li>总的来说，比特币转账就是用这个地址对应的私钥打开，再加密发送到另一个地址的过程。这个私钥的打开和加密就是签名的过程。在这个过程中，接受比特币的一方不需要动用自己的私钥。</li>
</ol>
</li>
</ol>
</li>
<li><p>比特币存在哪儿</p>
<ol>
<li>一方面，你的比特币是一个物理存在的一一对应的一个数据文件。比特币以一个交易的UTXO的形式存在着，每个交易都被看成是一个数据文件。</li>
<li>另一方面，比特币是区块链这个账本上的记录。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="比特币区块的数据结构"><a href="#比特币区块的数据结构" class="headerlink" title="比特币区块的数据结构"></a>比特币区块的数据结构</h2><ol>
<li>每个区块由两个部分组成–区块头部和区块数据。</li>
<li>区块头部<ol>
<li>头部中有一个哈希指针指向上一个区块，这个哈希指针包含前一个数据块的哈希值。</li>
<li>如果前一个区块中的数据被篡改了，那么通过哈希指针就能够发现。所以，要修改一个区块中的数据，对其后的每个区块都必须相应的进行修改。</li>
</ol>
</li>
<li>区块数据：一个区块中的数据是被打包进这个区块的一系列交易。这些交易按规则打包最终形成梅克尔树。</li>
<li>区块链中的两种哈希指针：<ol>
<li>一个是形成”区块+链”的链状数据结构。</li>
<li>另一个是数据块内部用来形成梅克尔树的哈希指针</li>
</ol>
</li>
</ol>
<h2 id="工作量证明共识机制"><a href="#工作量证明共识机制" class="headerlink" title="工作量证明共识机制"></a>工作量证明共识机制</h2><ol>
<li><p>共识机制为什么存在：是因为这是一个非基于信任的网络，任何人无需许可都可以接入这个网络。并且，这些节点需要达成一致。共识机制即为这些节点达成一致的机制。</p>
</li>
<li><p>比特币的共识机制有两个与过去不同的特点</p>
<ol>
<li><p>引入了奖励机制</p>
<ol>
<li><p>通过比特币奖励使网络中的节点愿意打包交易，维护账本。</p>
<p> &nbsp;除了新区块相关奖励外，挖矿节点还可以的饿到区块中包含的所有交易付出的交易费。</p>
</li>
</ol>
</li>
<li><p>包含了随机性的概念</p>
<ol>
<li><p>比特币的共识系统并不是完全可靠的，但是经过约一小时(6个区块)后，出问题概率呈指数级下降，从实用角度来看，这个共识是可信的。</p>
 <img src="/Iptables_img/1.png" style="zoom:80%">

</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="比特币的挖矿机制"><a href="#比特币的挖矿机制" class="headerlink" title="比特币的挖矿机制"></a>比特币的挖矿机制</h2><ol start="5">
<li><p>挖矿结点计算机的两个任务</p>
<ol>
<li><p>第一个任务是把比特币网络中未确认的交易按梅克尔树组装成候选区块，未被纳入的交易则往下顺延。</p>
<p> 在创建候选区块时，除了普通的交易外，矿工在器中增加一个特殊的交易： 如果挖矿成功，则币基交易会凭空转出新区块的奖励比特币到矿工的钱包地址中，从而发行这些比特币出来。</p>
</li>
<li><p>第二个任务是进行加密哈希计算，解决一个计算难题，进行算力竞争。在众多争夺记账权的结点中，谁最先完成这个计算，它打包的区块就被加到了区块链的最后，称为最新的区块。刷先完成计算的矿工会赢得新区快对对挖矿奖励。</p>
</li>
</ol>
</li>
<li><p>比特币的工作量证明共识机制与它的挖矿机制</p>
<ol>
<li>向内看： 在候选区块的头部有一个32位的随机数区域，矿工需要反复调整随机数并计算，目标是让整个区块的哈希值小于一个目标值。如果尝试过所有的32位随机数可能性后，计算仍未成功，那么就要改变币基的一个随机数，接着反复计算。</li>
<li>向外看： 随着算力的增长，会调整目标值的难度使得挖出一个区块的时间始终是10分钟左右。</li>
<li>总之，比特币的经济系统是以竞争-记账-奖励循环为核心的。</li>
</ol>
</li>
</ol>
<h2 id="比特币转账过程"><a href="#比特币转账过程" class="headerlink" title="比特币转账过程"></a>比特币转账过程</h2><img src="/Iptables_img/3.png" style="zoom:80%">

<h1 id="区块链的应用"><a href="#区块链的应用" class="headerlink" title="区块链的应用"></a>区块链的应用</h1><ol>
<li><p>总的来说，区块链让我们从信息互联网跨越到价值互联网。</p>
</li>
<li><p>信息传递到价值传递</p>
<ol>
<li><p>区块链提供了数字世界中价值表示与价值转移</p>
 <img src="/Iptables_img/4.png" style = "zoom:80%"></li>
<li><p>目前的互联网实现的是信息传递，其特征是进行信息的复制。这一特征使得在数字空间中进行价值转移时，必须依赖可信的第三方</p>
</li>
<li><p>未来，我们不再需要这些“信用中介”。基于区块链技术，我们可能建立一个通过网络本身进行价值表示、价值转移的全新交易基础设施。</p>
</li>
</ol>
</li>
<li><p>数字世界中的价值转移和价值表示</p>
<ol>
<li>价值的转移依靠记录：比如进行房产交易，那么要做的是把记录中所有权人改为你。</li>
<li>数字世界中，可完美复制的数据文件和需要唯一性的价值表示形式形成冲突。为了防止双花问题，所以需要一个可信的第三方作为中介。所有与价值转移有关的事处于成本高，效率低的状态，互联网上的价值转移就局限在少数的价值类别上。</li>
</ol>
</li>
</ol>
<h2 id="价值表示"><a href="#价值表示" class="headerlink" title="价值表示"></a>价值表示</h2><ol>
<li>价值的表示是在交易中体现出来的，因此可以从价值转移来讨论价值表示。</li>
<li>传统的体系中：价值的表示需要一个中介来参与。中介维护一个集中的账本用以记录，协助完成价值转移。</li>
<li>比特币系统中，区块链的账本以分布式的方式存在于互联网上，由去中心网络的节点共同维护。只要掌握自己的私钥即可。即所有人共享一个云端账本。</li>
</ol>
<h2 id="价值转移"><a href="#价值转移" class="headerlink" title="价值转移"></a>价值转移</h2><ol>
<li>在基础层次上，区块链担任信用中介，协助进行价值表示和价值转移。</li>
<li>互联网的层次：<ol>
<li>最上层，是普通用户看到的网站与App等应用。</li>
<li>中间层，是协议层，这一层过去主要是信息传递的WWW等协议。</li>
<li>最底层，是网络传输硬件和网络传输协议如TCP/IP等。</li>
</ol>
</li>
<li>区块链给互联网带来了进行价值表示和价值转移的新协议。区块链信用层协议由一组协议组成，在现有硬件网络之上，形成了一个协助我们进行价值表示和价值转移的新层次。这组协议目前仍未定性，也尚未被广泛认可，在持续发展中。</li>
</ol>
<h2 id="价值表示物：数字世界中表示价值的通证"><a href="#价值表示物：数字世界中表示价值的通证" class="headerlink" title="价值表示物：数字世界中表示价值的通证"></a>价值表示物：数字世界中表示价值的通证</h2><ol>
<li>以太坊创始人维塔利克写道，常被提及的应用包括：<ol>
<li>使用链上数字资产来代表定制货币和金融工具。</li>
<li>某种基础物理设备的所有权。</li>
<li>如域名一样的不可互换的资产</li>
<li>以及复杂的应用来直接控制转移数字资产（<strong>智能合约</strong>）</li>
<li>甚至基于区块链的分布式自治组织。</li>
</ol>
</li>
<li><a href="http://c.biancheng.net/view/1908.html" target="_blank" rel="noopener">应用及以太坊简史</a></li>
<li>把数字世界中，基于区块链的各种价值表示物都称为通证。</li>
<li>总的来说，现在在数字世界中，类似于 HTML 的代表价值的语言（通证）已经准备好了。“怎么用通证，通证有什么用”等问题等待着创造性的回答。</li>
</ol>
<h2 id="区块链的第三第四定义"><a href="#区块链的第三第四定义" class="headerlink" title="区块链的第三第四定义"></a>区块链的第三第四定义</h2><img src="/Iptables_img/5.png" style = "zoom:80%">

<img src="/Iptables_img/6.png" style = "zoom:80%">

<img src="/Iptables_img/7.png" style = "zoom:80%">

<h1 id="区块链将成为互联网基础协议"><a href="#区块链将成为互联网基础协议" class="headerlink" title="区块链将成为互联网基础协议"></a>区块链将成为互联网基础协议</h1><ol>
<li><p>目前互联网通信用的协议是TCP/IP协议族。通常认为包括四层：    </p>
<ol>
<li>链路层：将一些数据放在电线上。</li>
<li>网络层：对数据进行路由</li>
<li>传输层：将数据持久化</li>
<li>应用层：以应用的形式提供数据的抽象。</li>
</ol>
</li>
<li><p>万维网协议包括三部分：</p>
<ol>
<li>文本标记语言HTML</li>
<li>文档传输协议HTTP</li>
<li>指定文档网络地址的统一资源定位符URL</li>
</ol>
</li>
<li><p>区块链技术作用于硬件网络之上、WWW协议旁边</p>
 <img src="/Iptables_img/9.png" style = "zoom:80%">

</li>
</ol>
<h1 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h1><ol>
<li><p>在软件层面加入智能合约，但在实际应用中，它真正带来巨变的是通证。</p>
<blockquote>
<p>当下，对于区块链的发展阶段划分，一个被普遍接受的分类来自区块链研究者梅兰妮·斯万，在《区块链：新经济蓝图》一书中，她将区块链分为：区块链1.0，货币；区块链2.0，合约；区块链3.0，应用。从货币到合约、再到应用是一种阶段分类，以太坊白皮书的题目即宣称，它试图成为智能合约和去中心化应用的平台。</p>
</blockquote>
</li>
<li><p>以太坊是区块链2.0，实现了从数字现金到数字资产的转换。</p>
</li>
</ol>
<h2 id="智能合约与去中心化的平台"><a href="#智能合约与去中心化的平台" class="headerlink" title="智能合约与去中心化的平台"></a>智能合约与去中心化的平台</h2><ol>
<li><p>维塔利克分析在比特币系统的基础上开发高级应用的三种可行路径：</p>
<ol>
<li>建立一个新的区块链</li>
<li>在比特币区块链上使用脚本。</li>
<li>在比特币区块链上建立元协议。</li>
</ol>
</li>
<li><p>维塔利克认为，比特币系统的主要设计UTXO和其对应的脚本语言有缺陷。他总结了四点不足：</p>
<ol>
<li><p>缺少图灵完备性。尽管比特币的脚本语言可以支持多种计算，但并非所有。</p>
</li>
<li><p>价值盲：UTXO脚本不能为账户的取款额度提供精细的控制。</p>
</li>
<li><p>缺少状态：UTXO只能是已花费或者未花费状态，这意味着UTXO只能用于建立简单的、一次性的合约。</p>
</li>
<li><p>区块链盲：UTXO看不到区块链的数据，比如区块头部的随机数、时间戳和上一个区块数据的哈希值。</p>
<img src="/Iptables_img/10.png" style = "zoom:80%">
</li>
</ol>
</li>
<li><p>以太坊的目标：提供一个区块链，内置有成熟的图灵完备的编程语言，用这种语言可以创建合约来编码，实现任意<strong>状态转换</strong>功能。（他认为比特币是一个状态转换系统）。</p>
<ol>
<li><p>要创建一个新的区块链。</p>
</li>
<li><p>这个区块链的特色是，有一个实现所有计算，即所谓的图灵完备的脚本编程语言。</p>
</li>
<li><p>这个脚本语言可以用来创建复杂的智能合约，用以控制区块链的状态转换，也即进行链上数字资产的转移。</p>
<blockquote>
<p>关于智能合约，在以太坊白皮书中，维塔利克用的词汇是“实现预先设定规则的一段代码”（implementing arbitrary rules）。在区块链上，这些代码的用途是控制链上的数字资产的转移。关于智能合约的更多介绍见相关冷知识专栏讨论</p>
</blockquote>
</li>
</ol>
</li>
<li><p>维塔利克认为在以太坊上可以开发的三大类应用</p>
<ol>
<li>金融应用：用他们的钱去管理和参与合约。这些应用包括子货币、金融衍生品、对冲合约、储蓄钱包、遗嘱，甚至雇用合约。</li>
<li>半金融应用：这里有钱的存在，但非金钱的方面所占的比例也很重。一个好例子是为了解决计算问题而设的自动执行的悬赏。</li>
<li>非金融应用：如在线投票和去中心化治理等。</li>
</ol>
</li>
</ol>
<h2 id="用智能合约管理数字资产与ERC20通证标准"><a href="#用智能合约管理数字资产与ERC20通证标准" class="headerlink" title="用智能合约管理数字资产与ERC20通证标准"></a>用智能合约管理数字资产与ERC20通证标准</h2><p>目前以太坊最常用的功能是通过编写智能合约来管理用通证表示的数字资产。</p>
<ol>
<li>比特币出现以后，出现了很多通过简单修改比特币开源代码的参数得到替代币。而以太坊的智能合约将创建通证的门槛降到了很低。</li>
</ol>
<img src="/Iptables_img/11.png" style = "zoom:80%">

<img src="/Iptables_img/10.png" style = "zoom:80%">
2. ERC721（不可互换通证标准）：比如我的一本专门题名给我的签名书和你的同一本书是不同的，二者不可互换。
3. ERC20（可互换通证）：指的是每一个通证都是一模一样的，比如任何两张100元的价值是完全相同的。符合ERC20的通证的重要用途是被用于首次代币发行的筹资。人们可以用以太币按照项目方案设定的兑换率来换取这些通证，而项目方获得以太币形式的资金。

<p><a href="http://c.biancheng.net/view/1915.html" target="_blank" rel="noopener">“V神简介”</a></p>
<h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><ol>
<li>其中智能可以理解为，按条件自动执行，无须人的干预，是自动的或者自治的。</li>
<li>其中合约应该看成是存在于以太坊执行环境中的”自治代理”，它拥有自己的以太坊账户，他们收到交易信息后就相当于被捅了一下，然后自动执行一段代码—–V神如是说。（类比有限状态机，自动售货机）</li>
<li>可以认为区块链存储的是状态，智能合约是它用于状态转换的方式。智能合约像是一个特别的时钟，把世界从同步转向异步。</li>
</ol>
<h2 id="智能资产：用智能合约来控制实体资产"><a href="#智能资产：用智能合约来控制实体资产" class="headerlink" title="智能资产：用智能合约来控制实体资产"></a>智能资产：用智能合约来控制实体资产</h2><ol>
<li><p>所谓智能财产，是智能合约程序按照设定的规则控制的财产。萨博举例说明如下：</p>
<p> 例如，为了防止一部车被偷窃，除非确定拥有者完成正确的“挑战响应协议”，否则车是不会启动激活的。<br> 例如，如果车是贷款买的，当拥有者无法偿还贷款时，智能合约将会自动启动扣押令，并将车钥匙的控制权交给银行。一旦拥有者还清贷款，智能合约就移除扣押令。</p>
</li>
</ol>
<p>目前来说：由比特币区块链上的智能合约控制的资产，不管是实体的还是数字的，都叫智能资产。</p>
<h2 id="以太坊的智能合约"><a href="#以太坊的智能合约" class="headerlink" title="以太坊的智能合约"></a>以太坊的智能合约</h2><ol>
<li>以太坊的智能合约是存在于区块链上，可以被触发执行的一段程序代码，这些代码实现了某种预定的规则，是存在于以太坊执行环境中的“自治代理”。</li>
</ol>
<img src="/Iptables_img/15.png" style = "zoom:80%">

<p>注：合约账户不能自己启动运行自己的智能合约。要运行一个智能合约，需要由外部账户对合约账户发起交易，从而启动其中的代码的执行。</p>
<h2 id="以太坊的智能合约有什么用"><a href="#以太坊的智能合约有什么用" class="headerlink" title="以太坊的智能合约有什么用"></a>以太坊的智能合约有什么用</h2><ol>
<li>创建通证，通证对应的多是以太坊区块链之外的资产。</li>
<li>图 2 是一个简明的图示，这是从 Komhar 咨询公司的一个图示重绘而来的。图示是一个典型的 ERC20 通证发行过程：一个项目通过智能合约创建通证，这个通证是实体资产或线上资产的价值表示物。投资者（用户）发起交易，向智能合约转入以太币（ETH），智能合约自动运转，在满足一定规则后，它向投资者账户转入相应数量的通证。</li>
</ol>
<img src="/Iptables_img/16.png" style = "zoom:80%">

<h1 id="令牌系统-token-systems"><a href="#令牌系统-token-systems" class="headerlink" title="令牌系统 token systems"></a>令牌系统 token systems</h1><p>令牌：用以表示资产的通证。</p>
<ol>
<li><p>所有的货币或者令牌系统从根本上来说都是带有如下操作的数据库：从A中减去X单位并把X单位加到B上。前提条件是</p>
<ol>
<li><p>A在交易之前至少有X单位</p>
</li>
<li><p>交易被A批准</p>
<p>实施令牌系统，即是把这样一个逻辑实例实施到一个合约之中。</p>
</li>
</ol>
</li>
<li><p>区块链能方便的承载Token系统，是因为它存储的是状态。</p>
</li>
<li><blockquote>
<p>在《商业区块链》一书中，区块链专家威廉·穆贾雅提出了一个可以用Token系统表示的事物的分类。他把区块链中可存储的事物的首字母组成了一个单词“ATOMIC”：</p>
</blockquote>
<p> 可编程的资产（assets）。</p>
<p> 可编程的信任（trust）。</p>
<p> 可编程的所有权（ownership）。</p>
<p> 可编程的货币（money）。</p>
<p> 可编程的身份（identity）。</p>
<p> 可编程的合同（contracts）。</p>
</li>
</ol>
<h1 id="通证有什么用：机器比人更需要通证"><a href="#通证有什么用：机器比人更需要通证" class="headerlink" title="通证有什么用：机器比人更需要通证"></a>通证有什么用：机器比人更需要通证</h1><img src="/Iptables_img/17.png" style = "zoom:80%">

<ol>
<li>要<strong>把其他象限的价值映射到链上</strong>，用通证来表示，主要有两个途径：<ol>
<li>路径之一是，把原本在互联网上通过中心化机构的数据库表示的价值和价值转移，切换到去中心化的区块链上来。比如常见的有网络零售的支付、社交网络的积分、游戏里的道具等，反映在图中就是从象限 ② 到象限 ③。</li>
<li>路径之二是，把实体中的资产映射到链上，通过区块链进行流通。比如常见的有：把线下的民宿、供应链金融、资产证券化（ABS）中的资产用通证进行表示，反映在图中就是从象限 ③ 到象限 ①。</li>
</ol>
</li>
</ol>
<p>但实际上，以上的路通过传统的方法已经做的够好了（我们总在考虑我们手中的加密货币能兑换多少法币，这恰恰说明了法币在价值表示上已经做的很好了）</p>
<h2 id="在机器视角看通证"><a href="#在机器视角看通证" class="headerlink" title="在机器视角看通证"></a>在机器视角看通证</h2><ol>
<li><p>令牌：初始用于通信网络，只有拥有两派的节点才能参与通信，令牌代表了权力。</p>
<blockquote>
<p>一个关于令牌的例子：假设，为了防止网络中的机器发出垃圾邮件，我们设定如下规则：个人电脑或手机在发出邮件时，需要消耗一个 token；发件邮件服务器也要消耗一个 token。如果这个邮件不被垃圾邮件规则拦截，或不被个人举报为垃圾邮件，那么在一定时间内，所消耗的 token 又会回到我们手中。</p>
</blockquote>
<p> 在这里实际发生了令牌抵押，以确保我们在实施正当行为。</p>
</li>
<li><p>随着物联网技术的发展，越来越多的机器需要通证，我们的做法也不应该是给每一个传感器开设一个和法币对应的账户。这时，我们应该设计机器专用的钱包和通证。</p>
</li>
</ol>
<h1 id="ERC20通证标准"><a href="#ERC20通证标准" class="headerlink" title="ERC20通证标准"></a>ERC20通证标准</h1><p>–是通过以太坊创建通证时得到一种规范。按照ERC20的规范可以编写一个智能合约。</p>
<p><a href="http://c.biancheng.net/view/1922.html" target="_blank" rel="noopener">详解ERC20W</a></p>
<h1 id="The-DAO众筹事件与以太坊分叉"><a href="#The-DAO众筹事件与以太坊分叉" class="headerlink" title="The DAO众筹事件与以太坊分叉"></a>The DAO众筹事件与以太坊分叉</h1><h2 id="分叉的存在：比特币共识机制"><a href="#分叉的存在：比特币共识机制" class="headerlink" title="分叉的存在：比特币共识机制"></a>分叉的存在：比特币共识机制</h2><ol>
<li>分叉方案：即从某个区块开始以太坊区块链不向前兼容，从而把 The DAO 众筹来的以太币夺回来，转移到一个恢复地址上，再还给参与众筹的人。<br>比特币的共识机制本质上是通过算力进行的投票。在去中心化的网络中，一定程度上来说我们不存在真币和假币。你相信他是真的，愿意在包含这个交易的区块后面继续追加区块，维护这一区块链分支，那么他就是真的。日后，如果还要和其他人进行交易，并且他也认为你的比特币的起源是真实可靠的，那么你们就可以完成交易；反之，则会出现分歧，如果多数人都不站在你那边，那么你所拥有的比特币就来自非法交易。</li>
</ol>
<h1 id="设计通证：用通证表示资产"><a href="#设计通证：用通证表示资产" class="headerlink" title="设计通证：用通证表示资产"></a>设计通证：用通证表示资产</h1><p>有了智能合约和通证之后，以太坊就有了新的用途—进行数字资产的表示与交易。这使得数字资产也有了相对统一的价值表示形式，所以以太坊超越作为数字现金系统的比特币，开始解决如何表示资产等问题。</p>
<img src="/Iptables_img/18.png" style = "zoom:80%">

<h2 id="用通证将资产表示为链上的“数字资产”"><a href="#用通证将资产表示为链上的“数字资产”" class="headerlink" title="用通证将资产表示为链上的“数字资产”"></a>用通证将资产表示为链上的“数字资产”</h2><ol>
<li><p>通证是资产在区块链上的价值表示物，涉及的资产包括：</p>
<ol>
<li>比特币，以太币等链上的原生资产、映射到链上的线上资产、映射到链上的线下资产。</li>
</ol>
</li>
<li><p>我们通过以太坊区块链和他的智能合约来创建与发行代表价值的通证，然后用它去关联资产。</p>
</li>
<li><p>以太坊上的通证包括两种：可互换的ERC20和不可互换的ERC721。可互换的通证可类比现金，不可互换的通证类比房契。</p>
 <img src="/Iptables_img/19.png" style = "zoom:80%">
</li>
<li><p>链上和链下的交互包括两大部分：</p>
<ol>
<li>将链下资产与通证关联，进行通证的发行与分配。</li>
<li>在链上进行通证交易后，对链下资产进行相应的变动，并将变动在链上确认。 </li>
</ol>
</li>
<li><p>将资产表示成通证的好处：</p>
<ol>
<li><p>帮助市场交易发现价格</p>
</li>
<li><p>在流动周转中增加资产价值。</p>
<blockquote>
<p>其中，关于流动增加总体价值的例子，我们在现实生活中也可以体验到：二手物品的流动让买方和卖方都收益，车辆与房屋的共享提升了资源的利用效率。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h2 id="数字资产系统的去中心化交易场景"><a href="#数字资产系统的去中心化交易场景" class="headerlink" title="数字资产系统的去中心化交易场景"></a>数字资产系统的去中心化交易场景</h2><p>—–以太坊的出现使得基于它的智能合约创建的各种通证都可以进行中心化或去中心化交易。</p>
<ol>
<li><p>通过智能合约进行链上数字资产交易：假设我们编写一个合约，售卖一种基于 ERC721 的不可互换通证，如性质类似于收藏卡的“加密猫”。每个加密猫通证各不相同，预先在智能合约中设定价格均为 10 个以太币，购买方式是先到先得。</p>
<p> 这时，去中心化的数字资产交易过程如下：</p>
<ol>
<li><p>买方向智能合约地址转入 10 个以太币，即为发起购买邀约，智能合约担任第三方保管的角色。</p>
</li>
<li><p>卖方把该收藏卡（基于 ERC721 的通证）转入买方地址。</p>
</li>
<li><p>智能合约自动将以太币款项转入卖家账户。</p>
<p>由于这里仅涉及以太坊区块链上的数字资产（加密猫通证和以太币）的转移，因此在链上可以完成全部过程。</p>
<p>对比 A、B 两种场景我们看到，原本中心化的中介（如淘宝与支付宝）被按预先设定规则自动执行的智能合约所取代。中心化中介被区块链（即分布式账本和去中心网络）所取代。 </p>
</li>
</ol>
</li>
<li><p>通过智能合约进行涉及线下资产的交易</p>
<ol>
<li><p>当交易的不是链上的数字资产时，智能合约和预言机是一对必备的组合。智能合约在链上，预言机在链下，它可以与链上的智能合约进行通信（见图4）。</p>
 <img src="/Iptables_img/20.png" style = "zoom:80%"></li>
<li><p>比如，当卖家把数字文件传递给买家，买家确认之后，连接链上和链下的预言机就发出消息通知智能合约。接到消息后，智能合约执行后续的步骤，把以太币转入卖家账户。</p>
</li>
</ol>
</li>
<li><p>对比两个场景，我们知道</p>
<ol>
<li>有了智能合约，用通证表示的数字资产就是可编程的；</li>
<li>它是可以由计算机自动处理的；</li>
<li>如果数字资产交易各方形成一定的规则与逻辑，那么这些交易方之间可以进行完全自治的交易。</li>
</ol>
<p> <strong>最终，可以大幅度降低资产流转交易的成本，提高效率，并实现智能化。</strong></p>
</li>
</ol>
<h2 id="通证的四个特征"><a href="#通证的四个特征" class="headerlink" title="通证的四个特征"></a>通证的四个特征</h2><ol>
<li>中关村区块链产业联盟理事长元道指出的通证的三个要素：<ol>
<li>第一是数字权益证明。通证必须代表一种权利，一种固有和内在的价值。</li>
<li>第二是加密。通证的真实性、防篡改性，保护隐私等特性由密码学给出。</li>
<li>第三是可流通。通证必须能够在一个网络中流通，从而随时随地都可以进行验证。<blockquote>
<p>事实上，通证可以代表一切权益证明，从身份证到学历文凭，从货币到票据，从钥匙、门票到积分、卡券，从股票到债券，人类社会的全部权益证明都可以用通证来代表。</p>
</blockquote>
</li>
</ol>
</li>
<li>第四个特点：通证是可编程的。</li>
</ol>
<p>在区块链上，可以通过智能合约自治或自动的处理通证。</p>
<img src="/Iptables_img/21.png" style = "zoom:80%">

<h2 id="通过经济系统设计和通证的发行与分配"><a href="#通过经济系统设计和通证的发行与分配" class="headerlink" title="通过经济系统设计和通证的发行与分配"></a>通过经济系统设计和通证的发行与分配</h2><ol>
<li><p>回以太坊的建立过程，他起初进行了一轮众筹，严格来说，以太币的发行时中心化的，由以太币基金会发起的。但是过程时自动化的，由预先确定规则，编写后不能修改的智能合约自动执行的。</p>
<ol>
<li>中心化的原因：用区块链上的通证来表示链上资产、线上资产、线下资产时，完全的去中心化，甚至完全无人介入的自动化通常是不可行的。资产的设计、发行的设计以及后续项目的运行，都需要有机构来发起。这个机构在一定程度上是区块链项目的中心。</li>
<li>然而中心化机构只需要在初期持续运行项目和社群，直到社区能够自行运转。随着项目的发展，社区的扩大，中心化开始弱化，甚至是最终达到去中心化的状态。</li>
</ol>
</li>
<li><p>通证经济体</p>
<ol>
<li><p>通证经济体：是一个产业生态圈或社区，用通证来表示一个生态或社区的广义资产；借助通证来进行分配、交易。</p>
</li>
<li><p>核心事务：</p>
<ol>
<li><p>链：区块链技术的落实。</p>
</li>
<li><p>通证：通证的建立、分配与管理。</p>
</li>
<li><p>社群：用户社区与投资社区等以价值共识形成的社群。</p>
<img src="/Iptables_img/22.png" style = "zoom:80%"></li>
</ol>
</li>
</ol>
</li>
<li><p>通证经济系统的设计：一方面是和通证的价值相关的设计，另一方面是和通证的数量相关的设计。</p>
</li>
</ol>
<img src="/Iptables_img/23.png" style = "zoom:80%">

<img src="/Iptables_img/24.png" style = "zoom:80%">
4. **一个例子**：假设用通证经济系统来改造一个线下社区，那么可能的初始分配包括：投资方、团队和顾问、社区成员、留存。其中社区成员按一定规则得到的通证就是将线上资产映射到链上，用通证表示出来。之后，还需要设定规则定义生态成员如何获得通证，如何使用通证，此外还需要定义相关的经济逻辑。都确定之后，就可以通过编写智能合约来用代码实现它。

<img src="/Iptables_img/25.png" style = "zoom:80%">

<ol start="5">
<li><strong>通证，参考元道的说法是一种权利，不要局限于资产。他可以对应某种线上或线下的资产，也可能是代表某种功能的使用权</strong></li>
</ol>
<img src="/Iptables_img/26.png" style = "zoom:80%">

<h2 id="以太坊：数字资产的基础设施"><a href="#以太坊：数字资产的基础设施" class="headerlink" title="以太坊：数字资产的基础设施"></a>以太坊：数字资产的基础设施</h2><p>之前，在以太坊的 ERC20 标准被广泛接纳之前，要发行一个原生数字资产需要自行开发一条链，而现在我们可以基于以太坊这条公链来创建一个数字资产的价值表示物。<br>#<a href=""http://c.biancheng.net/view/1931.html"">通证的分类</a></p>
<h1 id="以太坊只能合约的技术与组件"><a href="#以太坊只能合约的技术与组件" class="headerlink" title="以太坊只能合约的技术与组件"></a>以太坊只能合约的技术与组件</h1><img src="/Iptables_img/39.png" style = "zoom:80%">

<h1 id="ERC721标准与加密猫"><a href="#ERC721标准与加密猫" class="headerlink" title="ERC721标准与加密猫"></a>ERC721标准与加密猫</h1><p>加密猫—基于以太坊的ERC721标准发行的加密数字宠物，每一只猫咪<strong>各不相同</strong>。在此之前人们对以太坊的认识是，它的主要应用是用它的智能合约发行符合 ERC20 标准的可互换通证，同一种通证的一枚和另一枚是完全一样的。</p>
<h1 id="以太坊的账户"><a href="#以太坊的账户" class="headerlink" title="以太坊的账户"></a>以太坊的账户</h1><p>以太币账户可以查看余额（包括以太币和其他基于ERC20标准的通证）。以太坊账户分为外部账户和合约账户。外部账户由密钥控制，合约账户由只能合约控制</p>
<img src="/Iptables_img/40.png" style = "zoom:80%">

<ol>
<li>以太坊的账户包括：一个随机数、账户余额、[合约代码]，存储</li>
</ol>
<h2 id="合约账户"><a href="#合约账户" class="headerlink" title="合约账户"></a>合约账户</h2><ol>
<li>只有合约账户才有代码，存储的是这个账户的以太坊虚拟机代码的哈希值。生成后不可修改，即智能合约代码不能修改。</li>
<li>合约账户可以设置多重签名</li>
</ol>
<h2 id="外部账户"><a href="#外部账户" class="headerlink" title="外部账户"></a>外部账户</h2><ol>
<li>外部账户可以触发交易，而合约账户不能主动发起交易，只能在被触发后执行代码。</li>
</ol>
<h2 id="以太坊的区块"><a href="#以太坊的区块" class="headerlink" title="以太坊的区块"></a>以太坊的区块</h2><ol>
<li>区块中存交易，本质是状态转移函数。一个交易触发它的执行，它将相应的账户从一个状态转变成新状态，然后将新状态存储在区块链的数据区块中。</li>
<li>以梅克尔帕特丽夏树组织。<h1 id="区块链的四大特征—区块链有什么用"><a href="#区块链的四大特征—区块链有什么用" class="headerlink" title="区块链的四大特征—区块链有什么用"></a>区块链的四大特征—区块链有什么用</h1></li>
</ol>
<img src="/Iptables_img/41.png" style = "zoom:80%">

<h2 id="一-不可篡改"><a href="#一-不可篡改" class="headerlink" title="一 不可篡改"></a>一 不可篡改</h2><ol>
<li>要修改一个区块中的数据，那么就要生成后面所有的区块。</li>
<li>共识机制的重要作用之一是使得修改大量区块的成本极高，从而几乎不可能。</li>
<li><strong>应用</strong>：农产品或商品溯源的应用：将它们的流通记录在区块链上，以确保数据记录不被篡改，从而提供追溯的证据。</li>
</ol>
<blockquote>
<p>2018 年 3 月，在网络零售集团京东发布的《区块链技术实践白皮书》中，京东认为，区块链技术（分布式账本）的三种应用场景是：跨主体协作，需要低成本信任，存在长周期交易链条。这三个应用场景所利用的都是区块链的不可篡改特性。多主体在一个不可篡改的账本上协作，降低了信任成本。区块链账本中存储的是状态，未被涉及的数据的状态不会发生变化，且越早前的数据越难被篡改，这使得它适用于长周期交易。 </p>
</blockquote>
<h2 id="二-表示价值所需要的唯一性"><a href="#二-表示价值所需要的唯一性" class="headerlink" title="二 表示价值所需要的唯一性"></a>二 表示价值所需要的唯一性</h2><ol>
<li>中心化账本存在是因为在数字世界中，文件可以复制。<blockquote>
<p>2018 年年初，中国的两位科技互联网企业领袖不约而同地强调了区块链带来的“唯一性”。腾讯主要创始人、CEO 马化腾说：“区块链确实是一项具有创新性的技术，用数字化表达唯一性，区块链可以模拟现实中的实物唯一性。”</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>百度创始人、CEO 李彦宏说：“区块链到来之后，可以真正使虚拟物品变得唯一，这样的互联网跟以前的互联网会是非常不一样的。”</p>
</blockquote>
<h2 id="三-智能合约"><a href="#三-智能合约" class="headerlink" title="三 智能合约"></a>三 智能合约</h2><ol>
<li><p>智能合约的出现使得基于区块链的两个人不只是可以进行简单的价值转移，而是可以设置复杂的规则，由智能合约来进行自治，自动的管理。</p>
</li>
<li><p>智能合约的性质：相当于一种特殊的服务端后台程序。</p>
<blockquote>
<p>在以太坊白皮书中，维塔利克写道：（合约）应被看成是存在于以太坊执行环境中的“自治代理”（autonomous agents），它拥有自己的以太坊账户，收到交易信息，它们就相当于被捅了一下，然后它就自动执行一段代码。</p>
</blockquote>
</li>
<li><p>编写智能合约</p>
 <img src="/Iptables_img/42.png" style = "zoom:80%">
</li>
<li><p><strong>区块链的新认识</strong></p>
<ol>
<li>区块链：是分布式账本技术。各方共同维护一个共享、互通、互联的账本，在此账本上就价值的确认、交易、分配达成共识。</li>
<li>区块链：是基于分布式账本技术的自治执行机制，即把区块链等同于智能合约。<ol>
<li>在没有通证的情况下，通过智能合约的自动/自治执行，进行数字资产的交易。</li>
<li>在有通证的情况下，通过智能合约的自治执行，进行通证形式的数字资产的交易。<h2 id="四-去中心自组织"><a href="#四-去中心自组织" class="headerlink" title="四 去中心自组织"></a>四 去中心自组织</h2></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>—-可能会失控，但失控也是一种自治。</p>
<ol>
<li><blockquote>
<p>在《去中心化应用》一书中，作者西拉杰·拉瓦尔（Siraj Raval）还从另一个角度进行了区分，他的这个区分有助于我们更好地理解未来的应用与组织。他从两个维度看现有的互联网技术产品：一个维度是，在组织上是中心化的，还是去中心化的；另一个维度是，在逻辑上是中心化的，还是去中心化的。</p>
</blockquote>
</li>
</ol>
<pre><code>他认为：“比特币在组织上去中心化，在逻辑上集中。”而电子邮件系统在组织上和逻辑上都是去中心化的

&lt;img src=&quot;/Iptables_img/43.png&quot; style = &quot;zoom:80%&quot;&gt;</code></pre><ol start="2">
<li><strong>区块链在技术之外的意义</strong> 可能作为基础设施支持人类的生产组织和协同的变革。这正是区块链与互联网是完全同构的又一例证，互联网也不仅仅是一项技术，它改变了人们的组织和协同。</li>
<li><strong>再看以太坊</strong> 以太坊将区块链技术带入了新的阶段，带来了智能合约和通证。作为价值表示物的通证，它的角色类似于 HTML。在有了 HTML 之后，建什么样的网站完全取决于我们的想象力。</li>
</ol>
<h1 id="区块链3-0"><a href="#区块链3-0" class="headerlink" title="区块链3.0"></a>区块链3.0</h1><h2 id="类比理解"><a href="#类比理解" class="headerlink" title="类比理解"></a>类比理解</h2><ol>
<li><p>类比操作系统的市场</p>
<blockquote>
<p>在 2016 年出版的《商业区块链》一书中，区块链专家威廉·穆贾雅以“数以百万计的区块链”（Getting to millions of blockchains）作为一个小节的标题。从整体上，他展望的未来图景是：“随着公有、私有、半私有、特殊目的以及其他类型的区块链的增长扩散，数以百万计的区块链世界将会实现。”这个说法可能展现了最可能的区块链未来图景。</p>
</blockquote>
<p> 区块链的未来很可能不止是一条。</p>
</li>
<li><p>类比网站</p>
<blockquote>
<p>威廉·穆贾雅还做了一个虽然不甚准确但易懂的类比——“区块链将会成为新的网站”。在回顾了从 20 世纪 90 年代开始的网站发展史后，他类比指出：“每个公司一定会拥有或参与各种各样的区块链，无论它们是私有的、半私有的或公共的。”</p>
</blockquote>
</li>
<li><p>类比为云服务平台</p>
<ol>
<li>和现有的云不同，他们的核心功能是价值交易。</li>
</ol>
</li>
</ol>
<h2 id="作为云服务的区块链3-0"><a href="#作为云服务的区块链3-0" class="headerlink" title="作为云服务的区块链3.0"></a>作为云服务的区块链3.0</h2><ol>
<li>以太坊曾把自己定位为一台“全球分布式计算机”。在《区块链革命》中，商业思想家唐·塔普斯科特这样写道：“区块链上运行的所有计算资源可以在整体上视为一台计算机。”</li>
<li>区块链3.0从一个个的通证进化到一个个的应用，会使得它的基础模型可能与已知的以太坊模型有很大的不同。</li>
<li>目前，人们关注的焦点往往是性能问题，比如以太坊计划通过改用 POS 共识机制（casper）和分片技术（sharding）来提升性能，又比如人们关注 EOS 采用委托权益证明机制（DPOS）来提升性能。或许，架构也需要改变。</li>
<li>要看待这一个个应用（App），可以有两种方式：既可以把它们看成是区块链操作系统上的软件，它们用的是一条区块链的分布式账本和去中心网络；也可以把这些应用看成类似于一条条链，它们有着自己的分布式账本与去中心网络。<ol>
<li>类比地看，在云服务出现之前，要开发一个网站或应用，我们要自己架设和运维服务器；而有了云服务之后，我们可以在云服务上开发自己的应用。在采用云服务时，一个个应用就有自己的一组专用服务器，像之前一样。类似地，如果采用类似的架构来开发区块链的应用，则可以认为，一个个应用也像有着自己的一条条独立的区块链。</li>
<li>现在的各个作为基础公链的区块链项目，做的正是云服务：以开源软件系统、分布式账本、去中心网络为基础，提供一系列和价值有关的云计算服务。</li>
<li>现在，对试图在各个领域或产业中实际应用区域链的人来说，要在区块链上开发应用，需要的正是一个类似的云服务架构：区块链的软件系统、分布式账本与去中心网络，从及一系列云计算软件服务。</li>
<li>当然，区块链云服务与现有的云服务也有很多不同：<ol>
<li>它提供的云计算软件服务是基于分布式账本与去中心网络的。</li>
<li>软件系统通常不是由一家公司开发，而是由社区开发的，以开源方式发布。</li>
<li>去中心网络不是由一家公司运维，而是由不同主体出于经济激励而自主提供的。</li>
<li>一系列云计算软件服务也不是由一家公司提供，而是由社区提供的。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="走向应用的五条路径"><a href="#走向应用的五条路径" class="headerlink" title="走向应用的五条路径"></a>走向应用的五条路径</h2><img src="/Iptables_img/44.png" style = "zoom:80%">

<ol>
<li><p>以超级账本为代表的联盟链软件：</p>
<ol>
<li>与比特币，以太坊等公有链不同，联盟链需要经过许可才能加入。联盟链有其特定的用途，较为适合大型公司在自己的内部部署使用，或部署后在自己的产业链生态中邀请合作伙伴接入，也可以由产业联盟共同部署。</li>
<li>从互联网的发展经验来看，区块链的未来只要还是开辟一套基础公链。目标是开发一条有通用功能或专一功能的公有链，并同时做三件事：开发软件，运行系统，运行社区。</li>
</ol>
</li>
<li><p>基础公链：通用类</p>
<p> 开发一条通用类的基础公链。代表EOS（一个更快，更好，更适合应用开发的以太坊）</p>
</li>
<li><p>基础公链：功能类</p>
<p> 开发专用于某类功能的区块链，代表IOTA（专用于物联网等），Steem和Steemit（专用于数字内容），再比如比原链（专用于数字资产交换，按白皮书披露的信息它要做到的是，连通比特世界与原子世界，实现“比特资产”（原生的数字货币、数字资产）和“原子资产”（有传统物理世界对应物）的交互与流转。 ）</p>
</li>
<li><p>基础公链：行业类</p>
<p> 开发专用于某个行业的区块链，充分考虑该行业的特点提供相关的功能，比如保险、供应链金融、游戏、政务等。</p>
</li>
<li><p>基础设施 跨链的资产交易</p>
<p> 可以预见的是区块链世界中必然有着很多链，甚至是非常多的链的共存。链与链之间的功能或资产的连接就变得非常重要。</p>
<blockquote>
<p>2018 年年初，新区块链项目区块基石（ArcBlock）自称是区块链 3.0，它的核心是提供跨链的协议，并以云服务的形式为开发者提供便利。另一个新项目梵塔网络（Penta）则定位在做“区块链世界的连接器”，要实现三大连接——链与链的连接、链与中心化系统的连接、链下与链上价值的连接，即为了推进区块链的应用，不只是连接不同的链，连接链上与链下，更要在需要时连接链与中心化系统。<br>在鲸准研究院与节点资本研究中心的“侧链跨链研究报告”（2018年）中，它认为侧链与跨链在技术上大体相似，只有在谈到它们的服务对象时才需做细致的区分：一般来说，侧链服务于主链，而跨链试图改进的是链之间价值和功能的连通。其实，现在区块链领域的主要应用之一“币币交易所”实质上做的也是跨链资产的交易，只是目前采用的主要还是中心化的方式。目前，主要的交易所都推出了自己的通证（一般称平台币），并公布基础公链计划，也即准备用区块链技术来改进自身业务。</p>
</blockquote>
</li>
<li><p>基础设施 服务中心化应用</p>
<p> 随着去中心化应用的出现，各种基础性技术服务成为刚需。如星际文件系统，分布式文件存储等。</p>
</li>
<li><p>区块链3.0 类比云服务</p>
 <img src="/Iptables_img/45.png" style = "zoom:80%">

</li>
</ol>
<h2 id="从多个网到多条链"><a href="#从多个网到多条链" class="headerlink" title="从多个网到多条链"></a>从多个网到多条链</h2><p>雷纳特·卡桑辛（Renat Khasanshyn）曾展示他基于联盟链理解的区块链应用未来。现在的各类系统，比如相互连接在一起的金融系统，是由多个中心化的数据库组成的。用区块链技术来改造这些系统，他的设想是，在合适的地方用相应的区块链来取代原来的数据库（见图 6）。从图 6 中可以看到，中心化的数据库被去中心化的区块链所取代。</p>
<h1 id="EOS、比特币、以太坊"><a href="#EOS、比特币、以太坊" class="headerlink" title="EOS、比特币、以太坊"></a>EOS、比特币、以太坊</h1><ol>
<li><p>EOS 是一款企业操作系统（区块链软件系统）,其目的是将一切去中心化。</p>
<p> 从 2017 年年中开始，经过一年的代币众筹后，它于 2018 年 6 月 15 通过由数十个区块生产者（block producer，BP，又称超级节点）组成的社区上线了主网，EOS 主网这条主要的区块链开始正式运转。</p>
</li>
<li><p>EOS包括三个部分：</p>
<ol>
<li>EOSIO软件，一共社区开发 的开源软件，任何人都可以参与开发、提交代码。</li>
<li>EOS币（EOS通证）</li>
<li>EOS主网：通过竞选，一批区块生产者被选出来，它们启动EOS主网。</li>
</ol>
</li>
<li><p>EOS账户：</p>
<ol>
<li>外部账户：由私钥控制</li>
<li>合约账户</li>
<li>与账户相关的概念：<ol>
<li>钱包：保存密钥的客户端；</li>
<li>权限：包裹owner和active，用户可自定义各种权限。</li>
</ol>
</li>
</ol>
</li>
<li><p>EOS的智能合约：<br> 其含义非常接近与linux的后台应用，节点在启动时包括缺省合约。</p>
<ol>
<li>调用方法：用户命令调用；EOSIO的send方法调用</li>
</ol>
</li>
</ol>
<h2 id="EOS-VS-以太坊"><a href="#EOS-VS-以太坊" class="headerlink" title="EOS VS 以太坊"></a>EOS VS 以太坊</h2><img src="/Iptables_img/46.png" style="zoom:80%">

<ol>
<li>以太坊是比特币的改进，EOS是以太坊的改进（进化到应用）</li>
<li>以太坊的设计思路类似于高速公路。在这条收费高速公路上，车辆行驶需要付费。它早期募集资金，建设“高速公路”，早期投资者享有“高速公路”的主要权益。之后，一起建设与维护“高速公路”的挖矿节点也可以获得挖矿奖励与交易费收益。在以太坊网络中，由于各类项目已经基于它生成了大量的通证，以太坊网络的交易量相对较多，挖矿节点获得的交易费收益占比高于比特币。</li>
<li>EOS 的设计思路则类似于房地产开发。Block.one 公司在将土地售卖出去之后，逻辑上它用获得的资金进行基础的开发，此后每年再以类似填海造田的方式增加 5% 的土地出来。</li>
<li>EOS 网络要依靠超级节点（即区块生产者）来各自建设、共同运营，按现在的设计，这些节点共同获得每年 1% 新增发的 EOS 作为回报。其繁荣程度主要取决于超级节点能否建设号自己的地盘。</li>
<li>实际上，EOS的实际情况是：BlockOne公司募集资金开发一个名为EOSIO的开源软件。EOS社区通过这个软件运行EOS主网。EOS是对以太坊的改进，各中由EOSIO运行起来的区块链网络，也可以做以太坊能做的事。</li>
</ol>
<h2 id="EOS的超级节点竞选"><a href="#EOS的超级节点竞选" class="headerlink" title="EOS的超级节点竞选"></a>EOS的超级节点竞选</h2><ol>
<li>EOS采用的共识机制是DPOS（委托权益证明），即一些节点在获得足够多的投票后，成为见证人节点或EOS中所说的区块链生产者，<strong>负责区块的生成</strong>。</li>
<li>基于区块链的思路开发的软件系统的关键要求：<ol>
<li>一是性能：它的去中心化网络的整体性能能否支撑大量应用。</li>
<li>二是网络：它的共识机制、经济激励和社区运营能否吸引足够多的节点加入，形成安全可靠的去中心网络。</li>
<li>三是功能：无论目标是通用类，功能类还是行业类，它是否提供了应用开发所需要的必备功能。</li>
</ol>
</li>
<li>超级节点竞选（DPOS）是一种激励。通过DPOS来刺激形成一个活跃的去中心网络，并且，超级节点竞选时与其共识机制DPOS高度匹配的。区块生产则时动态的，时刻根据投票动态调整。<blockquote>
<p>EOS 的区块链生产者的收益分配机制是，区块生产者一共可获得每年新增出来的 1% 的 EOS 通证作为回报，其中 0.25% 按每个区块来进行奖励，0.75% 按所获投票来进行分配。可参见 2018 年 5 月 12 日项目发布的信息。</p>
</blockquote>
</li>
</ol>
<h2 id="EOS-的共识机制"><a href="#EOS-的共识机制" class="headerlink" title="EOS 的共识机制"></a>EOS 的共识机制</h2><p>所有的出块者都要对所有区块签名，以确保在同一时间戳或者同一区块高度上，没有区块生产者能够同时在两个区块上签名。一旦一个区块有了 15 个区块生产者的签名，该区块就被认为是不可逆的。任一区块生产者如果想在同一时间戳或者同一区块高度的两个区块上签名，就会留下密码学证据。在这一模式下，一秒之内就可以达成不可逆的共识。</p>
<ol>
<li>EOSIO 设定每0.5秒产生一个区块，每126个区块为一个周期（每个出块者6个区块，乘以21个出块者）。在每个出块周期开始时，软件会根据通证持有人投票选出21个区块生产者。每个生产的区块要获得15个以上的区块生产者的签名即变成不可逆的交易。</li>
<li>如果在计划的时间内没有成功出块，则跳过该块，产生0.5秒的空白。如果出块者错过了一个区块，并且在最近24小时内都没有产生任何区块，则这个出块者将被踢出考虑范围，直至他们通知区块链可以重新开始产生区块。这确保了网络的顺利运行。</li>
</ol>
<h1 id="区块链的不可能三角"><a href="#区块链的不可能三角" class="headerlink" title="区块链的不可能三角"></a>区块链的不可能三角</h1><img src="/Iptables_img/47.png" style="zoom:80%">


<p>对比一下比特币和 EOS：比特币系统看重的是去中心化和安全，而牺牲了可扩展性；EOS 在一定程度上牺牲了去中心化，而去追求可扩展性与安全。</p>
<h1 id="去中心化的应用"><a href="#去中心化的应用" class="headerlink" title="去中心化的应用"></a>去中心化的应用</h1><ol>
<li><p>EOS白皮书中给出了区块链应用的六个条件：</p>
<ol>
<li>支持百万级别的用户，需要能够处理数千万日活跃用户的区块链技术。</li>
<li>使用免费，应用开发人员需要具备灵活性，能够为用户提供免费服务；用户不必为了使用平台或从平台的服务中受益而付费。</li>
<li>轻松升级和故障修复，区块链平台必须对软件和智能合约的升级提供支持。</li>
<li>延迟低，及时地反馈是良好用户体验的基础。</li>
<li>串行性能，有些应用程序由于必须顺序执行命令，无法用并行算法进行实现。区块链需要提供强大的串行性能支持。</li>
<li>并行性能，大型应用程序需要在多个CPU和计算机之间分配工作负载。</li>
</ol>
</li>
<li><p>早期的应用:将会在区块链上出现原生的区块链应用或去中心化应用。</p>
</li>
<li><p>如果单独看一条区块链的应用，情形可能如图 2 所示。</p>
<ol>
<li>这条区块链是分布式账本与去中心网络，它提供着一系列与价值相关的数据和功能。</li>
<li>多个应用接入区块链网络。在这些应用中，有的可能是普通用户可以使用的，是网站/移动 App 与区块链应用的组合；有的可能是纯粹的区块链应用。<pre><code>&lt;img src=&quot;/Iptables_img/48.png&quot; style=&quot;zoom:80%&quot;&gt;</code></pre></li>
</ol>
</li>
<li><p>有的应用可能接入多个区块链，比如现在常见的应用交易所、钱包就接入多个区块链。</p>
</li>
<li><p>去中心化应用可以从去财富中心化和去计算中心化入手。</p>
</li>
<li><p>区块链3.0的先驱者EOS为应用而做的三件事：用户免费、账户与权限体系、存储系统。 </p>
</li>
</ol>
<h2 id="区块链应用实例—Steemit博客"><a href="#区块链应用实例—Steemit博客" class="headerlink" title="区块链应用实例—Steemit博客"></a>区块链应用实例—Steemit博客</h2><ol>
<li>基于Steem区块链上存储价值，并按照内容贡献进行分配。</li>
<li>基于这条区块链建有多个应用：普通用户可用的 Steemit 博客平台、视频平台 DTube 等；常备的应用如区块链浏览器 steemd.com 网站。它的社区算是较为活跃的，还有其他的很多应用。</li>
</ol>
<h2 id="用户免费"><a href="#用户免费" class="headerlink" title="用户免费"></a>用户免费</h2><p>—-用户不必为了使用平台或从平台的服务中收益而付费。</p>
<ol>
<li><p>使用一个区块链应用需要三种资源，均由维护这个去中心网络的计算机提供。分别是：</p>
<ol>
<li>带宽资源：带宽和日志存储。(磁盘)</li>
<li>计算资源：计算和计算积压。（CPU）</li>
<li>状态资源：状态存储。（RAM）</li>
</ol>
</li>
<li><p>关于状态：区块链账本中存储的是状态，比如交易账本、账户余额等，按其名字缩写为 RAM，它的性质大约相当于内存。EOS 还特别举例说明，什么应该存入状态，什么不应该存入状态。例如，一个区块链应用程序的逻辑不需要读取博客文章的内容和评论，因此它们不应该存储在区块链的状态中。但是，博客文章或评论是否存在、投票数以及其他属性，需要存在区块链的状态之中。</p>
<p> <strong>简单的说，区块链是用于交易的，区块链的状态是交易账本，那么，与交易相关的信息应该存入交易账本，而与交易无关的信息不应存入交易账本。</strong></p>
</li>
<li><p>EOS中的三种资源的消耗机制：区块生产者（BP）公布可用的带宽（bandwidth）、计算（computation）和状态（state）的容量。EOSIO 系统允许每个账户消耗一定比例的可用资源，这个比例是根据账户将自己持有的通证存入“三天抵押合约”的数量决定的。</p>
</li>
<li><p>关于交易费：</p>
<ol>
<li>以太币和比特币中都需要交易的发起方设定一个交易费，付给区块链网络，从而使网络能够处理这一交易。</li>
<li>EOS的逻辑是去中心化应用程序不应该强迫它的用户为使用区块链而支付费用。具体实现是由应用自己决定采用什么方式，通常为了用户使用，应用会自行解决，从而使得用户看上去是免费的。</li>
</ol>
</li>
<li><p>交易成本与通证价值分开</p>
<ol>
<li><p>在以太坊的网络中，我们交易支付以太币，随着以太币价格的涨跌，交易成本也随之变化。</p>
</li>
<li><p>EOS的逻辑是使交易成本与通证价值无关。EOS的做法是，一个应用拥有的带宽、计算、状态等资源，是与其持有的通证数量有关的，但由于不需要消耗，因此一定程度上与通证价值无关。</p>
</li>
<li><p>如果应用开发者不持有足够多的通证，则EOS网络还有一种“将资源能力授权出去”的机制，通证持有人可以不立刻消耗可用带宽或全部资源，可以将未消耗的带宽委托或租赁给其他人。</p>
<blockquote>
<p>根据 EOSIO 文档，这里的状态可认为指的是一个应用所占用的区块链网络的 RAM 存储空间。原文为：Storage of application state will require an application developer to hold tokens until that state is deleted.If state is never deleted,then the tokens are effectively removed from circulation.</p>
</blockquote>
<blockquote>
<p>对比以太坊和 EOS 我们可以看到，在以太坊中进行交易，个人用户需要支付交易费，而在 EOS 中进行交易，则是应用提供者需要承担成本，现在看来其中主要的成本是与 RAM 存储空间相关的。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h2 id="账户与权限体系"><a href="#账户与权限体系" class="headerlink" title="账户与权限体系"></a>账户与权限体系</h2><ol>
<li>比特币：没有账户，所有比特币交易都是地址见的交换。</li>
<li>以太坊：引入了账户。每个账户包括四个信息：一个随机数、账户的余额、合约代码（如果有的话）、存储（通常为空）。分为外部账户和合约账户。这里的合约代码相当于以太坊中的自治代理。</li>
</ol>
<h3 id="EOS账户"><a href="#EOS账户" class="headerlink" title="EOS账户"></a>EOS账户</h3><ol>
<li>一个EOS账户可以发送动作给另一个账户，而每个账户都可以设定一个处理器来自动处理发给自己的动作。动作与处理器的结合就是智能合约。</li>
<li>EOS系统提供了一个标准的基于角色的权限系统。允许每个用户持有者定义自己的权限层次结构以及动作的分组。</li>
<li>其账户系统包含两个缺省的权限组：最高级别的缺省是owner，第二个缺省权限组是active，其他的权限组都可以由active派生出来</li>
</ol>
<h2 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h2><p>—与交易相关的数据被存储在区块链中，那么应用相关数据放在哪呢？</p>
<ol>
<li>目前EOS的想法是存储在基于IPFS的EOS存储中。</li>
</ol>
<h2 id="总结-区块链的定义七-八"><a href="#总结-区块链的定义七-八" class="headerlink" title="总结 区块链的定义七 八"></a>总结 区块链的定义七 八</h2><img src="/Iptables_img/49.png" style="zoom:80%">

<img src="/Iptables_img/50.png" style="zoom:80%">

<h1 id="EOS账户的密钥被盗找回"><a href="#EOS账户的密钥被盗找回" class="headerlink" title="EOS账户的密钥被盗找回"></a>EOS账户的密钥被盗找回</h1><ol>
<li>基于它的用户权限机制</li>
<li>在这种情况下，你可以用过去 30 天中有效的 owner 权限对应的私钥，和你预先设定的账户恢复合作伙伴（account recovery partner）重置账户的私钥。这样你可能夺回了账户的所有权。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-po/北大网课" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/po/%E5%8C%97%E5%A4%A7%E7%BD%91%E8%AF%BE/"
    >po/北大网课</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/po/%E5%8C%97%E5%A4%A7%E7%BD%91%E8%AF%BE/" class="article-date">
  <time datetime="2020-03-30T03:00:51.072Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="哈希函数与加密体制"><a href="#哈希函数与加密体制" class="headerlink" title="哈希函数与加密体制"></a>哈希函数与加密体制</h1><ol>
<li>性质：<ol>
<li>抗碰撞性：难以人为制造哈希碰撞。</li>
<li>单向性：前提是输入空间足够大并且输入的分布比较均匀。(如果输入空间不够大，那么把输入后面拼接一个随机数再哈希)</li>
<li>puzzle friendly:比特币特有的性质。比特币区块要求计算出来的哈希值小于等于某一个阈值。</li>
<li>难以计算，但是易于验证。</li>
</ol>
</li>
<li>比特币中用的哈希函数:SHA-256</li>
<li>账户：在本地创建一个公私钥对就是一个账户。</li>
<li>非对称加密体系：公私钥。加密用公钥，解密用私钥，且加密和解密用的是用一个人的公钥和私钥。<ol>
<li>私钥保存在本地就行，公钥可以公开。</li>
<li>公钥相当于你的银行账号，私钥相当于银行密码。</li>
</ol>
</li>
<li>对称加密体系：加密解密使用同一个密钥，假设前提是存在一种安全的渠道把密钥分发给通信双方。</li>
<li>比特币系统中的公钥和私钥<ol>
<li>比特币系统中的信息都是公开的</li>
<li>所以私钥用来对交易做签名。我发起一个交易，那么我拿我的私钥进行签名，发布到区块链上，别人再用我的公钥进行验证。 </li>
</ol>
</li>
<li>以上所述的公私钥体制建立在有一个好的随机源上，同时每次签名操作也需要一个好的随机源。</li>
</ol>
<h1 id="比特币中的数据结构"><a href="#比特币中的数据结构" class="headerlink" title="比特币中的数据结构"></a>比特币中的数据结构</h1><ol>
<li><p>哈希指针：比如一个哈希指针指向一个结构体，那么这个指针里不止存它的地址还存它的哈希值。</p>
</li>
<li><p>区块链&amp;普通链表</p>
<ol>
<li><p>以哈希指针代替普通指针。</p>
</li>
<li><p>后一块的哈希指针是通过前一区块的全部内容(包括前一区块的哈希指针)计算出来的。</p>
<p> <strong>这样从最后一个区块就能知道前面的区块是否被修改。</strong></p>
<p> <strong>这样系统中的某些节点就不需要保存全部区块信息</strong></p>
</li>
<li><p>梅克尔树</p>
<img src="/Iptables_img/2.png" style="zoom:80%">        
 1. 每个区块内部的交易组织成梅克尔树的形式
 2. 区块间通过哈希指针连接在一起。 </li>
<li><p>比特币网络由轻节点和全结点构成，其中</p>
<ol>
<li>轻节点只保存区块头；当轻节点想确认某笔交易是否已经被写进区块链中：轻节点向全节点请求红色的哈希值，轻节点自己计算绿色的哈希值。最终，可以将得到的根哈希值和头部中的根哈希值相比较。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="BTC协议：比特币的共识机制"><a href="#BTC协议：比特币的共识机制" class="headerlink" title="BTC协议：比特币的共识机制"></a>BTC协议：比特币的共识机制</h1><p>比特币需要解决问题：双花；发行</p>
<h2 id="双花问题"><a href="#双花问题" class="headerlink" title="双花问题"></a>双花问题</h2><ol>
<li><p>转账：假如A要向B和C转帐</p>
<ol>
<li><p>交易需要A的签名，证明是经过A统一 的。 </p>
</li>
<li><p>需要指明A的比特币从哪来</p>
</li>
<li><p>注：比特币系统中的交易包括输入和输出两部分，输入部分要指明币的来源，输出部分要给出收款人的公钥的哈希。</p>
<img src="/Iptables_img/8.png" style="zoom:80%">

<p>注意：其中包含两种哈希指针。一种用来构成链表，另一种用来指向前面某个交易，以说明币的来源。</p>
</li>
<li><p>A需要知道B的公钥，B乃至所有节点也需要知道A的公钥，用来验证A的签名。因为怀疑网络中存在恶意节点，所以每个节点都需要亲自验证。</p>
<p> <strong>问题</strong>：A的公钥需要A自己去公布；如果某个恶意节点伪造了转账记录，用自己的私钥去签名，再公开自己的公钥说是A的公钥，那么可以转走A上钱么？</p>
<p> <strong>不</strong>，因为每个交易要去追溯币的来源，最终会追溯到币基交易，而币基交易（前面的交易）的输出正是A的哈希地址，只有当转帐中用到的公钥和这个哈希能对上，才能认为合法。</p>
</li>
<li><p><strong>注</strong>：加密是用接收者的公钥加密，接收者用自己的私钥解密。 </p>
</li>
</ol>
</li>
<li><p>区块的头部，包括</p>
<ol>
<li>比特币协议版本信息</li>
<li>指向前一个区块的指针</li>
<li>梅克尔树的根哈希值</li>
<li>挖矿的难度目标阈值（整个块头的哈希要小于等于目标阈值）</li>
<li>随机数</li>
</ol>
</li>
<li><p>分布式共识</p>
<ol>
<li>比如分布式哈希表：需要取得共识的是哈希表中包含了哪些 键值对。</li>
</ol>
</li>
<li><p>比特币的共识协议：问题出现在比特币系统中部分节点是有恶意的。</p>
<ol>
<li>最简单的，想要通过投票来判断某个节点产生的区块是否正确（区块内部的交易是否都是合法的）。但是存在一个问题，就是如何判断谁有投票资格。<ol>
<li><strong>女巫攻击</strong>：产生大量的公私钥对，极端情况下超过半数，那么他就得到了控制权。  </li>
</ol>
</li>
<li>通过<strong>算力</strong>来投票，每个节点都可以在本地组装候选区块，把他认为合法的交易放进去。然后开始算能够使得头部的哈希值小于目标阈值的随机数的值，找到了这个随机数的节点就获得了记账权，向比特币网络中发布这个区块<ol>
<li>其他节点收到这个区块后，首先验证nbits域的设置是否符合难度要求；验证头的哈希是否小于等于目标阈值。</li>
<li>然后验证body中的交易<ol>
<li>是否是合法的签名</li>
<li>以前是否被花过</li>
</ol>
</li>
<li>即使通过了前面的检查，但是该区块不是连接在最长合法链的末尾，也不接受。因为验证交易合法性时候，只去验证他所在的分支。<ol>
<li><strong>分叉攻击</strong>：通过向区块链中间插入某个区块来回滚某个已经发生的交易。<img src="/Iptables_img/13.png" style="zoom:80%"></li>
</ol>
</li>
<li>接受一个区块意味着沿着这个区块继续往下扩展。如果产生的链不是基于最长的链，那么他在该链上通过币基交易得到的比特币也是不被认可的非法交易。</li>
</ol>
</li>
</ol>
</li>
<li><p>为什么要争夺记账权？为了币基交易的比特币奖励。 </p>
</li>
<li><p><strong>总结</strong>：比特币系统中的共识是针对分布式账本内容-&gt;只有获得记账权的节点才有权力向账本里写东西，有权决定账本中的内容-&gt;获得记账权需要算力支持-&gt;比特币的投票是基于算力的。</p>
<ol>
<li>比特币的性质：puzzle friendly，即想计算出结果，没有捷径，只有一个个试。</li>
</ol>
</li>
</ol>
<h1 id="比特币系统的实现"><a href="#比特币系统的实现" class="headerlink" title="比特币系统的实现"></a>比特币系统的实现</h1><ol>
<li>比特币使用基于交易的账本模式</li>
<li>比特币系统的全节点要维护一个UTXO的数据结构（所有没被花掉的交易输出组成的集合）以检查双花问题。  </li>
<li><strong>比特币激励机制2</strong>：交易费，激励争夺记账权的节点将他人的交易打包进区块。</li>
<li>想要使哈希值低于根哈希值，一个使太正nance，另一个使调整coinbase，这样搜索空间就达到了2<sup>96。</li>
<li>求解puzzle过程<img src="/Iptables_img/14.png" style="zoom:80%">

</li>
</ol>
<p>其中tx那一串在实际上只需要梅克尔树的根哈希值即可。</p>
<h2 id="挖矿的概率分析："><a href="#挖矿的概率分析：" class="headerlink" title="挖矿的概率分析："></a>挖矿的概率分析：</h2><ol>
<li>每次挖矿的过程可以看作是一个伯努利试验。大量的伯努利实验构成一个伯努利程序。<ol>
<li>性质1：无记忆性</li>
</ol>
</li>
<li>试验次数很多，但是实验成功的概率很小的时候，可以用泊松分布来近似。</li>
<li>整个系统的出块时间是服从指数分布的，平均是10分钟。这个指数分布也是无记忆的。所以将来还要挖多少时间和过去已经挖了多少时间是没有关系的。这也保证了算力强的矿工拥有成比例的优势。</li>
</ol>
<h2 id="比特币系统的总量"><a href="#比特币系统的总量" class="headerlink" title="比特币系统的总量"></a>比特币系统的总量</h2><ol>
<li>比特币区块奖励是固定的，每个四年减半一次，所以比特币的数量会构成一个几何序列。可以计算出一共只有2100万个比特币。  </li>
</ol>
<h2 id="挖矿的意义"><a href="#挖矿的意义" class="headerlink" title="挖矿的意义"></a>挖矿的意义</h2><ol>
<li>挖矿本身并不解决什么问题，但是其算力竞争对于维护比特币系统的安全性是至关重要的。只要大部分算力是掌握在诚实节点手里，那么安全性就得以保证。</li>
</ol>
<h2 id="安全性分析："><a href="#安全性分析：" class="headerlink" title="安全性分析："></a>安全性分析：</h2><ol>
<li>恶意节点能否将别人的比特币转走：<strong>不能</strong>，无法伪造签名。如果他把交易硬写到区块链里，那么诚实的节点不会认可这个交易，因为他包含了一个非法的交易</li>
<li>恶意节点能否双花（<strong>分叉攻击</strong>）<ol>
<li>简单的防范方法是多等待几个区块（几个确认）（比特币协议中是等待6个确认），这样写入了回滚交易的区块想要使自己所在的分支成为最长合法链的难度就大大增加。</li>
</ol>
</li>
<li>恶意节点故意不包含某些交易<ol>
<li>但是问题不大，总有诚实的节点愿意将交易写入区块。即使不在这个区块里写入，也会写在下一个区块里。</li>
<li>正常的情况下，也有可能出现这种情况，因为比特币协议要求每个区块不得大于1MB。</li>
</ol>
</li>
<li>selfish mining攻击：挖到区块先不发布，攒了一堆再去发布以争夺最长合法链<ol>
<li><strong>不行</strong>：这对算力要求很大，起码要占据51%以上的算力才有一定的成功的可能性。但是话说回来，如果恶意节点占据了如此大的算力，比特币系统就崩盘了。</li>
<li><strong>出于盈利目的</strong>：如果一个节点的算力特别强，他挖到n+1个区块，之后不发布并立即开始挖第n+2个区块。等到侦听到有人挖到第n+1个区块的时候，他立刻将n+1和n+2个区块同时发布，那么他所在的链就成为了最长合法链，他得到的币基交易才是真实有效的。<ol>
<li>存在很大的风险：我们只有在假设别人挖出一个的时间里，我可以挖出两个，才能获得更大的利益。如果别人挖完第一个而我没有挖出第二个，那么我只能去碰碰运气。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="比特币网络"><a href="#比特币网络" class="headerlink" title="比特币网络"></a>比特币网络</h1><ol>
<li>比特币工作在应用层，其底层运行的是一个P2P Overlay网络，且这里的P2P网路中所有节点都是对等的。网络存在一个种子节点，可以通过它直到网络中其他节点的信息。节点之间通过TCP连接（这样有利于穿透防火墙）</li>
<li>每个节点维护一个临近节点集合(临近节点的选取是随机的，而不考虑底层拓扑结构)，消息传播采用洪范方式</li>
</ol>
<h1 id="比特币系统的挖矿难度"><a href="#比特币系统的挖矿难度" class="headerlink" title="比特币系统的挖矿难度"></a>比特币系统的挖矿难度</h1><ol>
<li>通过调整目标空间占搜索空间的比例来调整挖矿难度。</li>
<li>挖矿难度和目标阈值是成反比的。</li>
<li>为什么要维护挖矿难度：<ol>
<li>如果不调整这个难度，那么随着挖矿的人数增多，设备的进步，那么相对于网路延迟来说，生成区块的速度过快，从而导致多分叉。分叉过多对系统达成共识没有帮助，也会危害到系统的安全性。</li>
<li>回顾分叉攻击：我们只有在假设大部分的算力都掌握在诚实的矿工手里的时候才能避免。如果出现多分叉，那么算力被分散，被分叉攻击的可能性大大增加。</li>
</ol>
</li>
<li>比特币系统规定每个2016个区块调整一次，大约14天一次。且增大和减小都有要求，增大不会一次性增大超过4倍，减少也不会一次减少到1/4以上。</li>
</ol>
<h1 id="比特币挖矿"><a href="#比特币挖矿" class="headerlink" title="比特币挖矿"></a>比特币挖矿</h1><ol>
<li><p>比特币系统包括全节点和轻节点</p>
 <img src="/Iptables_img/27.png" style="zoom:80%">

<p> 全节点：</p>
<ol>
<li><p>决定沿着那条链挖下去：缺省情况下，沿着最长合法链挖下去。</p>
</li>
<li><p>出现等长分叉：选择最先听到的分叉。</p>
<img src="/Iptables_img/28.png" style="zoom:80%">

<p>轻节点：</p>
</li>
<li><p>只能检测合法链，但是不知道哪个是最长合法链。</p>
</li>
<li><p>轻节点假设矿工是有理智的，不会沿着非法的链挖下去。</p>
</li>
<li><p>轻节点在挖矿过程中，如果监听到别的节点已经挖出了新的区块，那么它只能放弃已有的区块。因为梅克尔树的跟哈希值和组成链的哈希指针都发生了变化。尽管如此，这并不可惜，因为挖矿具有无记忆性，成功的概率是没区别的。</p>
</li>
</ol>
</li>
<li><p>比特币的安全性保障</p>
<ol>
<li>由密码学提供：无法伪造的私钥签名。这个的前提是比特币网络中大多数节点都是好的，不会接受不合法的交易。</li>
<li>由比特币的共识机制提供</li>
</ol>
</li>
<li><p>矿石：使得51%以上的攻击变得容易。</p>
</li>
<li><p>矿石可发动的攻击：</p>
<ol>
<li>分叉攻击：</li>
<li>Boycott：比如想封锁A账户，可以在任何包含A的交易的区块被发布之后，立刻组装新的不包含A 的交易的区块，并经可能是新区块所在链变为最长合法链。</li>
</ol>
</li>
</ol>
<h1 id="比特币分叉"><a href="#比特币分叉" class="headerlink" title="比特币分叉"></a>比特币分叉</h1><ol>
<li>state fork:两个节点几乎同时挖到了区块。</li>
<li>forking attack（deliberate fork）</li>
<li>protocal fork:由于比特币协议修改导致的分叉<ol>
<li>硬分叉：这样的分叉是永久的，只要有算力不更新软件就存在。</li>
<li>软分叉：临时性的分叉</li>
</ol>
</li>
</ol>
<h1 id="比特币的匿名性"><a href="#比特币的匿名性" class="headerlink" title="比特币的匿名性"></a>比特币的匿名性</h1><ol>
<li><p>假的匿名，类似于化名不是绝对的。而且比特币的账本是完全公开的，对匿名性一种挑战。</p>
</li>
<li><p>实际上不同的地址可能被关联在一起。通过推理出来。</p>
</li>
<li><p>如果交易只在区块链内，则不会泄漏。但是一旦和实体世界发生关联，那么就可能泄漏隐私，具体在：</p>
<ol>
<li>比特币支付</li>
<li>资金转入转出的时候</li>
</ol>
</li>
<li><p>提高匿名性的方法</p>
<ol>
<li>首先要实现网络层的匿名性：采用多路径转发的方法。</li>
<li>混合币</li>
</ol>
</li>
<li><p>保护匿名性很难的原因：（1）区块链是公开的（2）区块链具有不可修改性，一旦某一个交易暴露了身份，影响会是永久的。</p>
</li>
</ol>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><h2 id="哈希指针"><a href="#哈希指针" class="headerlink" title="哈希指针"></a>哈希指针</h2><ol>
<li>实际上比特币系统只有哈希没有指针。在全节点中,所有的区块是以levelDB这种键值对数据来存储,其中key为哈希值,value为区块内容。</li>
</ol>
<h2 id="区块恋"><a href="#区块恋" class="headerlink" title="区块恋"></a>区块恋</h2><ol>
<li>这样会严重影响私钥的安全性，因为私钥长度变短时，暴力破解的搜索空间大大降低。</li>
<li>所以应该用多重签名，其中每个私钥都是独立产生的。</li>
<li>如果两个人分手，那么所有的币都会被存在UTXO中。</li>
</ol>
<h2 id="分布式共识"><a href="#分布式共识" class="headerlink" title="分布式共识"></a>分布式共识</h2><ol>
<li>实际上比特币并没有达成真正意义的共识。随时可能被推翻。</li>
</ol>
<h2 id="比特币的稀缺性"><a href="#比特币的稀缺性" class="headerlink" title="比特币的稀缺性"></a>比特币的稀缺性</h2><ol>
<li>总量一定的东西并不适用于做货币。因为随着社会财富总值的增长，每单位该种货币就变得越来越值钱，先买的人就越来越富，后面的人就永远也赶不上。就像房地产。</li>
</ol>
<h1 id="以太坊概述"><a href="#以太坊概述" class="headerlink" title="以太坊概述"></a>以太坊概述</h1><ol>
<li>memory hard mining puzzle</li>
<li>以后想权益证明代替工作量证明，用类似于股权投票的方式。</li>
<li>智能合约：去中心化合约。加入参与方来自世界各地，那么手段维持合约的有效性就很困难，所以考虑写成程序，写进区块链。</li>
</ol>
<h1 id="以太坊中的账户"><a href="#以太坊中的账户" class="headerlink" title="以太坊中的账户"></a>以太坊中的账户</h1><ol>
<li>BTC中需要统计所有的UTXO。</li>
<li>账户天然的防护了双花问题。但是存在重放攻击。</li>
</ol>
<h2 id="重放攻击："><a href="#重放攻击：" class="headerlink" title="重放攻击："></a>重放攻击：</h2><ol>
<li>假设A给B转了一次帐，广播过一次，之后B又向网络广播这次交易。那么网络中的其他节点就会认为A又向B转账了一次。</li>
<li><strong>解决</strong>：多维护一个交易次数的属性，在签名的保护下一起发布出去。系统中的全节点维护这个交易次数值。假设A-&gt;B是第20次，那么全节点认为下次来的应该是第21，那么即使B重放，也不行。</li>
</ol>
<h2 id="外部账户"><a href="#外部账户" class="headerlink" title="外部账户"></a>外部账户</h2><ol>
<li>由公私钥控制，包括账户余额和交易次数。</li>
</ol>
<h2 id="合约账户"><a href="#合约账户" class="headerlink" title="合约账户"></a>合约账户</h2><ol>
<li>不是由公私钥对控制，也有nonce值，用来标识调用别的合约的次数。还有code，storage。但是合约账户不能主动发起交易。</li>
</ol>
<h2 id="为什么有合约"><a href="#为什么有合约" class="headerlink" title="为什么有合约"></a>为什么有合约</h2><ol>
<li>为了支持智能合约，要求参与者有相对稳定的身份。</li>
</ol>
<h1 id="以太坊状态树"><a href="#以太坊状态树" class="headerlink" title="以太坊状态树"></a>以太坊状态树</h1><p>目的是建立一个账户到状态的映射。以太坊的账户为160b，状态包括余额、交易次数（代码，存储）。</p>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><ol>
<li><p>优点：</p>
<ol>
<li>每个节点的分叉数目取决于取值范围。</li>
<li>查找效率取决于键的长度。</li>
<li>插入顺序不一样，得到的结构也一样。</li>
<li>更新局部性很好，每个区块对应的账户很少，伊这种结构不需要管别的分支</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>存储浪费</li>
<li>查找效率与深度有关</li>
</ol>
</li>
</ol>
<h2 id="Patricia-tree"><a href="#Patricia-tree" class="headerlink" title="Patricia tree"></a>Patricia tree</h2><ol>
<li>是路径压缩的trie树。键值分布稀疏的时候比较好。</li>
</ol>
<h2 id="MPT-Merkle-Partricia-Tree"><a href="#MPT-Merkle-Partricia-Tree" class="headerlink" title="MPT Merkle Partricia Tree"></a>MPT Merkle Partricia Tree</h2><ol>
<li>路径压缩加路径压缩</li>
<li>优点：<ol>
<li>放篡改</li>
<li>可以证明账户上的余额。 </li>
<li>还可以证明某个键值是不存在的。</li>
</ol>
</li>
</ol>
<h2 id="Modified-MPT"><a href="#Modified-MPT" class="headerlink" title="Modified MPT"></a>Modified MPT</h2><ol>
<li>以太坊的结构是一颗大的MPT包含很多小的MPT，每一个合约账户就是一颗小的MPT</li>
<li>系统中的全节点维护的不是一颗MPT，而是每产生一个新的区块就新建一颗MPT,这些树中大部分的节点是共享的，只有少数更新的节点要新建分支。</li>
<li>保留历史状态是因为可能需要回滚交易，比如分叉的时候。以太坊由于智能合约的出现，所以很难去反向推算前一个状态，所以要保存。</li>
<li>状态树中保存的是键值对，地址作为key。而value要首先经过序列化之后再存储，大致理解为变成字节数组。</li>
</ol>
<h1 id="以太坊数据结构"><a href="#以太坊数据结构" class="headerlink" title="以太坊数据结构"></a>以太坊数据结构</h1><h2 id="交易树–也是一种MPT"><a href="#交易树–也是一种MPT" class="headerlink" title="交易树–也是一种MPT"></a>交易树–也是一种MPT</h2><ol>
<li>区块中的交易形成一颗交易树</li>
</ol>
<h2 id="收据树–也是一种MPT"><a href="#收据树–也是一种MPT" class="headerlink" title="收据树–也是一种MPT"></a>收据树–也是一种MPT</h2><ol>
<li>每个交易执行完，会形成一颗收据树，记录这个交易的相关信息。交易树和收据树上的节点是一一对应的。利于快速查找执行的结果。</li>
<li>每个区块的交易树和收据树都是独立的。他们发布的交易本身我们也认为是独立的。</li>
</ol>
<h2 id="bloom-filter"><a href="#bloom-filter" class="headerlink" title="bloom filter"></a>bloom filter</h2><ol>
<li>为了在大的集合中进行查找，以支持复杂的查询操作。</li>
<li>一般的扫描存在存储问题和查找效率问题。</li>
<li>将每个元素取一个哈希，形成一个向量，其中某位为1代表该对应该哈希值的元素存在，这个向量称为摘要。</li>
<li>不支持删除操作。 </li>
<li>作用：加入要查找过去十天发生的和某个智能合约相关的交易。首先，查找区块块头的bloom filter，看哪个块头的bloom filter里有我要的类型。如果某个块头里有，在去找对应收据树里的bf,看看哪个有。有的再去仔细查看。</li>
</ol>
<h2 id="以太坊的运行过程"><a href="#以太坊的运行过程" class="headerlink" title="以太坊的运行过程"></a>以太坊的运行过程</h2><p>看成是交易驱动的状态机。状态是所有账户的状态；交易每次发布区块包含的交易，这些交易会驱动从当前的状态转移到下一个状态。 </p>
<h1 id="GHOST协议–利于出现分叉后及时合并"><a href="#GHOST协议–利于出现分叉后及时合并" class="headerlink" title="GHOST协议–利于出现分叉后及时合并"></a>GHOST协议–利于出现分叉后及时合并</h1><ol>
<li><p>没有竞争称为最长合法链上的区块也会发放一定的出块奖励（7/8）称为叔父区块。下一个区块要包含所有叔父区块，同时得到1/32个出块奖励的额外报酬。最多可以包含两个叔父区块。</p>
</li>
<li><p>不在最长合法链上的区块都是叔父区块，即使是爷爷啥的。  </p>
</li>
<li><p>为了防止在挖矿难度较低的时候产生叔父而不当获利，最多7代。叔父区块中的交易不执行，所以也不检查交易合法性，只检查是否符合挖矿难度。</p>
 <img src="/Iptables_img/52.png" style="zoom:80%">    </li>
<li><p>GHOST机制是为了解决临时性的分叉。</p>
</li>
</ol>
<h1 id="以太坊的挖矿算法"><a href="#以太坊的挖矿算法" class="headerlink" title="以太坊的挖矿算法"></a>以太坊的挖矿算法</h1><ol>
<li>求解很难，验证简单、</li>
<li>回避ASIC芯片。</li>
</ol>
<h2 id="Lite币"><a href="#Lite币" class="headerlink" title="Lite币"></a>Lite币</h2><ol>
<li>基于Scrypt加密，需要大内存来保存这个数组。</li>
<li>但是设定小了，只有128K。</li>
</ol>
<h2 id="以太币"><a href="#以太币" class="headerlink" title="以太币"></a>以太币</h2><ol>
<li>有两个数据集，初始一个是16M的cache，另一个是1G的DAG。DAG从cache中生成出来。轻节点只需要保存cache便于验证。</li>
<li>cache形成 ：首先从一个种子节点开始依次去哈希来填充数组。</li>
<li>DAG形成：从cache里随机读一个数，然后进行哈希计算，得到下一个要读取的数的位置。然后用cache中这个位置的数和当前的哈希值再计算出一个哈希值，反复迭代256次，将最终得到的数填充到数组的第一个位置。</li>
<li>挖矿的时候，先根据块头和nonce值计算一个哈希，这个哈希映射到数组中的某一个位置。通过这个位置和相邻位置的元素进行运算得到下一个位置，循环64次，最后得到的哈希值与目标阈值比较，看一下是否成功。不成功则换下一个nonce。</li>
<li>生成cache的seed每隔3w个区块会变一下。同时cache和DAG大小会增加1/128。 </li>
</ol>
<h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><ol>
<li>外部账户可以调用合约，一个合约可以调用另一个合约。只有外部账户可以调用。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-区块链目录" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9B%AE%E5%BD%95/"
    >区块链目录</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9B%AE%E5%BD%95/" class="article-date">
  <time datetime="2020-03-30T03:00:51.066Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="北大网课"><a href="#北大网课" class="headerlink" title="北大网课"></a><a href="/2020/03/30/北大网课">北大网课</a></h2><h2 id="区块链自学"><a href="#区块链自学" class="headerlink" title="区块链自学"></a><a href="/2020/03/30/区块链">区块链自学</a></h2><h2 id="区块链小论文"><a href="#区块链小论文" class="headerlink" title="区块链小论文"></a><a href="/2020/03/30/区块链小论文">区块链小论文</a></h2>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-iptables" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/iptables/"
    >iptables</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/iptables/" class="article-date">
  <time datetime="2020-03-30T02:51:26.428Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="iptables-基础"><a href="#iptables-基础" class="headerlink" title="iptables 基础"></a>iptables 基础</h1><p>iptables本身不是防火墙，可以理解为一个客户端代理，通过iptables来设定规则，最终运行在netfilter框架下。</p>
<h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h2><p>当客户端访问服务器的时候，客户端发送报文到网卡，通过内核的TCP协议传输到用户空间的web服务器中，而此时，客户端报文的目标终点为web服务所监听的套接字。当web服务需要相应客户端请求时，web服务发出的响应报文的目标终点为客户端。netfilter作为内核的一部分，所有进出的报文都要通过这些关卡。于是，就有了input和output关卡，在iptables中，这些关卡称为链。除了通往本机的链，还有PREROURING(路由前)、FORWARD(转发)、POSTROUTING(路由后)。</p>
<img src="/Iptables_img/29.png" style="zoom:80%">

<h2 id="链"><a href="#链" class="headerlink" title="链"></a>链</h2><ol>
<li>防火墙的功能是对经过的报文匹配规则，然后执行对应的动作。对于每个关卡，都不止一条规则，故称为链。</li>
</ol>
<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><ol>
<li>表：我们把具有相同功能的规则的集合叫做表。</li>
<li>iptables预定义了四种表<ol>
<li>filter表：负责过滤功能，防火墙；内核模块：iptables_filter</li>
<li>nat表：负责网络地址转换功能。内核模块：iptable_nat</li>
<li>mangle表：拆解报文，做出修改，并重新封装的功能；iptables_mangle</li>
<li>raw表：关闭nat表上启用的连接追踪机制；iptable_raw<br>也就是说，我们自定义的所有规则都是这四种分类中的规则。</li>
</ol>
</li>
</ol>
<h2 id="表链关系"><a href="#表链关系" class="headerlink" title="表链关系"></a>表链关系</h2><ol>
<li>prerouting：规则存在于raw,mangle,nat.</li>
<li>INPUT:规则存在于mangle,filter.</li>
<li>FORWARD:规则存在于mangle,filter.</li>
<li>OUTPUT:规则存在于raw,mangle,nat,filter.</li>
<li>POSTROUTING:规则存在于mangle,nat.</li>
<li>实际使用中，往往以表为入口，对规则进行定义。</li>
<li>表链关系：<img src="/Iptables_img/31.png" style="zoom:80%"></li>
<li>表的优先级：raw&gt;mangle&gt;nat&gt;filter</li>
<li>我们也可以在某个表中创建自定义链，将针对某个应用程序所设置的规则放置在这个自定义链中，但是自定义链接不能直接使用，之恶能被某个默认的链当作动作去调用才能起作用。</li>
</ol>
<h2 id="数据经过防火墙的流程"><a href="#数据经过防火墙的流程" class="headerlink" title="数据经过防火墙的流程"></a>数据经过防火墙的流程</h2><img src="/Iptables_img/32.png" style="zoom:80%">

<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ol>
<li>规则：根据指定的匹配条件来尝试匹配每个流经此处的报文，一旦匹配成功，则由规则后面指定的处理动作进行处理。</li>
</ol>
<h1 id="iptables实际操作之规则查询"><a href="#iptables实际操作之规则查询" class="headerlink" title="iptables实际操作之规则查询"></a>iptables实际操作之规则查询</h1><ol>
<li><strong>命令</strong> iptables -t filter -L<ol>
<li>-t指定要操作的表</li>
<li>-L列出规则</li>
</ol>
</li>
<li>如果我们要定义过滤规则，那么我们会在filter中定义，但是具体在那条链上实现，取决于我们的工作场景。</li>
<li>举例：<ol>
<li>我们需要禁止某个IP地址访问我们的主机，我们则需要在INPUT链上定义规则</li>
</ol>
</li>
<li><strong>命令</strong> iptables -t filter -vL INPUT 查看详细信息<ol>
<li>pkts 对应规则匹配到的报文的个数</li>
<li>bytes 对应匹配到的报文包的大小总和。</li>
<li>target 往往表示规则对应的动作，即匹配成功后需要采取的措施。</li>
<li>prot 表示规则对应的协议，是否只针对某些协议应用次规则。</li>
<li>opt 表示规则对应的选项。</li>
<li>in 表示数据包由哪个接口流入，我们可以设置通过哪块网卡流入的报文需要匹配当前规则。</li>
<li>out 表示数据包由哪个接口流出，我们可以设置通过哪块网卡流出的报文需要匹配当前规则。</li>
<li>source 表示规则对应的源地址，可以时一个IP，也可以是一个网段。</li>
<li>destination 表示规则对应的目的地址。可以是一个IP也可以是一个网段。</li>
</ol>
</li>
<li><strong>命令</strong> iptables -nvl INPUT不进行名称反解。</li>
<li><strong>命令</strong> iptables –line-number -nvL INPUT</li>
<li>命令小节<img src="/Iptables_img/33.png" style="zoom:80%">

</li>
</ol>
<img src="/Iptables_img/34.png" style="zoom:80%">

<h1 id="iptables规则管理"><a href="#iptables规则管理" class="headerlink" title="iptables规则管理"></a>iptables规则管理</h1><ol>
<li><strong>命令</strong> iptables -F INPUT 清空规则</li>
<li><strong>如果报文已经被前面的规则匹配到，iptables则会对报文执行相应动作，即使后面的规则也能匹配到当前报文，也没有机会对报文执行修改</strong></li>
<li>使用修改指令的时候，如果我拒绝某个源地址发来的包，但是修改时又没有指定对应的源地址，那么源地址会自动编程0.0.0.0，如果是为远程服务器配置iptables，那么正在使用的链接也会和中断。</li>
<li>REGECT&amp;DROP<ol>
<li>DROP丢弃而不返回，ping命令所在机器永远得不到回应</li>
<li>REGECT 返回拒绝，通知目的端不可达。</li>
</ol>
</li>
<li><img src="/Iptables_img/35.png" style="zoom:80%">

</li>
</ol>
<img src="/Iptables_img/36.png" style="zoom:80%">

<img src="/Iptables_img/37.png" style="zoom:80%">

<img src="/Iptables_img/38.png" style="zoom:80%">

<h1 id="匹配条件总结"><a href="#匹配条件总结" class="headerlink" title="匹配条件总结"></a>匹配条件总结</h1><h2 id="s参数：匹配源地址"><a href="#s参数：匹配源地址" class="headerlink" title="-s参数：匹配源地址"></a>-s参数：匹配源地址</h2><ol>
<li>可以是由逗号隔开的多个参数</li>
<li>可以通过指定子网掩码来指定某个网段</li>
<li>可以对某个地址取反，达到白（黑）名单的目的。但是存在问题，比如链上规则设定为不是某个源即进行-j操作；如果是，则继续匹配其他条件（都不匹配，则执行默认操作）。</li>
</ol>
<h2 id="d参数：匹配目的地址"><a href="#d参数：匹配目的地址" class="headerlink" title="-d参数：匹配目的地址"></a>-d参数：匹配目的地址</h2><p><strong>取反操作与同时指定多个IP的操作不能同时使用</strong></p>
<h2 id="p参数：匹配协议类型"><a href="#p参数：匹配协议类型" class="headerlink" title="-p参数：匹配协议类型"></a>-p参数：匹配协议类型</h2><ol>
<li><p>例如拒绝tcp请求 </p>
<p> iptables -I INPUT -s 192.168.1.146 -d 192.168.1.156 -p tcp -j REJECT</p>
<p> 使用ssh链接测试</p>
</li>
<li><p>-p支持的协议类型：</p>
<ol>
<li>tcp,udp,udplite,icmp,icmpv6,esp,ah,sctp,mh</li>
<li>缺省形况下，默认为-p all</li>
</ol>
</li>
</ol>
<h2 id="i参数：匹配流入的网卡-o匹配流出的网卡"><a href="#i参数：匹配流入的网卡-o匹配流出的网卡" class="headerlink" title="-i参数：匹配流入的网卡 -o匹配流出的网卡"></a>-i参数：匹配流入的网卡 -o匹配流出的网卡</h2><ol>
<li>通过ifconfig查询</li>
<li>-i 网卡名 来指定匹配</li>
<li>只能用来判断流入的包，故用于<ol>
<li>ROUTING 链</li>
<li>INPUT 链</li>
<li><strong>FORWARD 链</strong></li>
</ol>
</li>
<li>-o 用于匹配报文从哪个网卡流出，用于<ol>
<li>OUTPUT 链</li>
<li><strong>FORWARD 链</strong></li>
<li>POSTROUTING 链</li>
</ol>
</li>
</ol>
<h2 id="dport-扩展目的端口"><a href="#dport-扩展目的端口" class="headerlink" title="-dport 扩展目的端口"></a>-dport 扩展目的端口</h2><ol>
<li>dport(destination-port)<ol>
<li><strong>使用dport之前必须先使用-p选项</strong></li>
<li>之后使用-m指定扩展模块，缺省情况下，默认为于-p指定的协议同名。</li>
<li>最后，使用-dport指定目标端口</li>
</ol>
</li>
</ol>
<h2 id="sport-匹配源端口"><a href="#sport-匹配源端口" class="headerlink" title="-sport:匹配源端口"></a>-sport:匹配源端口</h2><ol>
<li>不管是sport还是dport都可以指定端口范围，如22：25</li>
<li>multiport模块：<ol>
<li>若要指定离散的端口，需要借助multiport模块。端口号间以逗号隔开。并且，这些端口中可以包含连续端口号。</li>
<li><strong>只有tcp,udp可以使用</strong></li>
</ol>
</li>
</ol>
<p>##<a href=""http://www.zsythink.net/archives/1544"">基本匹配条件总结</a></p>
<p>#<a href=""http://www.zsythink.net/archives/1564"">常用扩展模块</a></p>
<h2 id="iprange-扩展模块"><a href="#iprange-扩展模块" class="headerlink" title="iprange 扩展模块"></a>iprange 扩展模块</h2><ol>
<li>用于指定一系列连续的ip。包括–src-range,–dst-range。</li>
</ol>
<h2 id="string-扩展模块"><a href="#string-扩展模块" class="headerlink" title="string 扩展模块"></a>string 扩展模块</h2><ol>
<li><p>用于匹配含有某一个字符串的报文。</p>
<p> iptables -t filter -I INPUT -m string –algo bm –string “OOXX” -j REJECT</p>
<ol>
<li>-m 用于指定模块</li>
<li>–algo bm 表示用bm算法匹配。</li>
</ol>
</li>
</ol>
<h2 id="time-扩展模块"><a href="#time-扩展模块" class="headerlink" title="time 扩展模块"></a>time 扩展模块</h2><ol>
<li><p>用于限制时间</p>
<p> iptables -t filter -I OUTPUT -p tcp -dport 80 -m time –timestart 09:00:00 –timestop 18:00:00 -j REJECT</p>
<ol>
<li>可以使用timestart 和timestop 来指定起止时间。也可以通过weekdays 来指定某一天,多个天之间通过逗号隔开。也可以结合使用。</li>
<li>此外还有monthdays,datestart和datestop</li>
</ol>
</li>
</ol>
<h2 id="connlimit-扩展模块"><a href="#connlimit-扩展模块" class="headerlink" title="connlimit 扩展模块"></a>connlimit 扩展模块</h2><ol>
<li><p>用于限制每个IP地址同时连接到server的数量。</p>
<p> iptables -I INPUT -p tcp –dport 803 -m connlimit –connlimit-above 2 -j REJECT</p>
<ol>
<li>限制每个IP最多只能让两个ssh连接到server。</li>
</ol>
</li>
<li><p>其实还可以配合–connlimit-mask去限制某类网段的链接数量</p>
<p> iptables -I INPUT -p tcp –dport 22 -m conlimit –connlimit-above 2 –connlimit-mask 24 -j REJECT</p>
</li>
</ol>
<h2 id="limit-扩展模块"><a href="#limit-扩展模块" class="headerlink" title="limit 扩展模块"></a>limit 扩展模块</h2><p>对报文到达速率进行限制，即限制单位时间内流入的包的数量。</p>
<ol>
<li>iptables -t filter -I INPUT -p icmp -m limit –limit 10/minute -j ACCEPT</li>
</ol>
<p>表示每分钟最多放10个包，相当于每6秒最多放一个包。<br>然而这样遂率并没有变，是因为第六秒的报文确实被策略匹配到了，于是执行了放行操作，但是6秒钱的报文没有被匹配到，于是自动执行默认策略，也是放行。<br><strong>修改</strong>：iptables -t filter -A INPUT -p icmp -j REJECT</p>
<ol start="2">
<li><p>–limit-burst 选项用于指明空闲时放行包的数量，默认为5.</p>
</li>
<li><p>limit模块工作原理：令牌桶算法<br> 想象有一个木桶，里面放了5块令牌，且目前这个桶中最多只能存放5个令牌。所有报文想要出关入关，都必须持有木桶中的令牌，这个木桶可以每6秒生成一个新的令牌。此时，如果桶已经满了，那么新生成的令牌就被丢弃。假设现在有五个报文想要进入，那么这5个报文就会去桶中找令牌，正好一人一个。此时，如果再有令牌想要进入，则没有对应的令牌可以使用。如果长时间没有人使用令牌，令牌桶中又出现了5枚令牌，也就是所谓的空闲。</p>
</li>
</ol>
<p>#<a href=""http://www.zsythink.net/archives/1578"">iptables 扩展匹配条件 -tcp-flags</a></p>
<p>用于匹配tcp头部的标志位，然后根据标识位的实时情况进行实时访问控制功能。</p>
<ol>
<li><p>iptables -t filter -I INPUT -p tcp -m tcp –dport 22 –tcp-flags SYN,ACK,FIN,RST,URG,PSH SYN -j REJECT</p>
<ol>
<li>SYN,ACK,FIN,RST,URG,PSH 表示需要匹配报文tcp头部的标志位列表</li>
<li>第二个SYN处表示，要求为1的标志位列表。不出现的标志位必须为0。</li>
<li>这条命令是拒绝tcp第一次链接。</li>
<li>可以使用-syn代替这一段。</li>
</ol>
</li>
<li><p>iptables -t filter -I INPUT -p tcp -m tcp –dport 22 –tcp-flags SYN,ACK,FIN,RST,URG,PSH SYN，ACK -j REJECT</p>
</li>
</ol>
<p>#<a href=""http://www.zsythink.net/archives/1588"">iptables udp扩展与icmp扩展</a></p>
<h2 id="udp-扩展"><a href="#udp-扩展" class="headerlink" title="udp 扩展"></a>udp 扩展</h2><ol>
<li>iptables -t filter -I INPUT -p udp -m udp –dport 137 -j ACCEPT<ol>
<li>137为端口号，samba服务的端口为137，138</li>
<li>可以指定连续的端口号 137:157</li>
</ol>
</li>
</ol>
<h2 id="icmp-扩展"><a href="#icmp-扩展" class="headerlink" title="icmp 扩展"></a>icmp 扩展</h2><img src="/Iptables_img/51.png" style="zoom:80%">

<ol>
<li><p>可以指定匹配的类型和code</p>
<p> iptables -t filter -I INPUT -p icmp -m icmp –icmp-type3/1 -j REJECT</p>
<p> 表示拒绝主机不可达报文</p>
</li>
<li><p>还可以用icmp报文的描述名称去匹配对应类型的报文</p>
<p> iptables -t filter -I INPUT -p icmp –icmp-type “echo-request” -j REJECT</p>
</li>
</ol>
<p>#<a href=""http://www.zsythink.net/archives/1597"">iptables 扩展模块 state</a></p>
<p>当我们访问http时，需要放行80端口以便能够与服务端进行通信。进行ssh链接时，需要打开22端口。然而，这样并不安全，攻击者可以利用这些端口主动和我建立链接。使用state可以实现链接追踪功能。</p>
<h2 id="state基本概念"><a href="#state基本概念" class="headerlink" title="state基本概念"></a>state基本概念</h2><ol>
<li>连接：在state模块中，认为两台机器在你来我往的通信就算建立了连接。</li>
<li>连接状态包括：NEW,ESTABLISHED,RELATED,INVALID,UNTRACKED</li>
</ol>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ol>
<li>iptables -t filter -I INPUT -m state –state RELATED,ESTABLISHED -j ACCEPT<ol>
<li>只有回应我们的报文能够通过防火墙。</li>
</ol>
</li>
</ol>
<p>#<a href=""http://www.zsythink.net/archives/1604"">iptables的黑白名单机制</a></p>
<ol>
<li>黑名单：链中设置规则的动作为drop或reject，默认动作是ACCEPT，那么匹配到规则的报文会被拒绝。</li>
<li>白名单：默认规则是DROP，链中规则的动作是ACCEPT，则被匹配到的报文才会放行，即白名单机制。<h2 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h2></li>
</ol>
<p>#iptables -P INPUT DROP</p>
<p>#iptables -I INPUT -p tcp –dport 22 -j ACCEPT</p>
<p>#iptables -I INPUT -p tcp<br>–dport 80 -j ACCEPT</p>
<ol>
<li>注意-F选项只是将链中规则情况，此处修改了默认规则，所以即使-F也会DROP；</li>
<li><strong>改进</strong>：将链的设置保持为ACCEPT，然后将拒绝所有请求的规则放在链尾，将放行规则放在签名，这样既实现了白名单，又保证规则清空时，管理员能够连接到主机。</li>
</ol>
<p>#iptables -I INPUT -p tcp –dport 22 -j ACCEPT</p>
<p>#iptables -I INPUT -p tcp –dport 80 -j ACCEPT</p>
<p># iptables -A INPUT -j REJECT</p>
<p>#<a href=""http://www.zsythink.net/archives/1625"">iptables 自定义链</a></p>
<p>由于默认链的规则非常 多，不便于管理，所以引入自定义链。</p>
<h2 id="创建自定义链"><a href="#创建自定义链" class="headerlink" title="创建自定义链"></a>创建自定义链</h2><ol>
<li>iptables -t filter -N IN_WEB<h2 id="使用自定义链"><a href="#使用自定义链" class="headerlink" title="使用自定义链"></a>使用自定义链</h2></li>
<li>必须被默认链引用</li>
<li>iptables -I INPUT -p tcp –dport 80 -j IN WEB</li>
<li>自定义链也可以引用其他的自定义链</li>
</ol>
<h2 id="自定义链重命名"><a href="#自定义链重命名" class="headerlink" title="自定义链重命名"></a>自定义链重命名</h2><p>iptables -E IN_WEB WEB</p>
<h2 id="删除自定义链"><a href="#删除自定义链" class="headerlink" title="删除自定义链"></a>删除自定义链</h2><ol>
<li>如果被引用，则要iptables -D INPUT 1</li>
<li>如果链种含有规则，则要Iptables -t filter -F WEB</li>
<li>iptables -X WEB</li>
</ol>
<p>#<a href=""http://www.zsythink.net/archives/1663"">网络防火墙</a></p>
<ol>
<li><p>定义：处于网络入口或边缘，针对于网络入口进行防护，服务于防火墙背后的本地局域网。主要任务时过滤并转发。</p>
</li>
<li><p>涉及：INPUT,OUTPUT,FORWARD</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2></li>
<li><p>PC1：</p>
<ol>
<li>192.18.33.33</li>
<li>route add -net 192.18.22.0/24 gw 192.18.33.251</li>
</ol>
</li>
<li><p>PC2:</p>
<ol>
<li>192.18.22.22</li>
<li>route add -net 192.18.33.0/24 gw 192.18.22.251</li>
</ol>
</li>
<li><p>r1:</p>
<ol>
<li>ens33:192.18.33.251</li>
<li>ens37:192.18.22.251    <ol start="3">
<li>cat /proc/sys/net/ipv4/ip_forward 来查看是否支持转发功能。</li>
<li>每次需要echo 1 &gt; /proc/sys/net/ipv4/ip_forward来开启转发功能</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>#<a href=""http://www.zsythink.net/archives/1684"">iptables 动作总结</a></p>
<h2 id="REJECT"><a href="#REJECT" class="headerlink" title="REJECT"></a>REJECT</h2><ol>
<li>–reject-with :提示拒绝原因。包括：<ol>
<li>icmp-net-unreachable</li>
<li>icmp-host-unreachable</li>
<li>icmp-port-unreachable</li>
<li>icmp-proto-unreachable(默认)</li>
<li>icmp-net-prohibited</li>
<li>icmp-host-pro-hibited</li>
<li>icmp-admin-prohibited</li>
</ol>
</li>
</ol>
<h2 id="LOG"><a href="#LOG" class="headerlink" title="LOG"></a>LOG</h2><ol>
<li><p>LOG 可以将符合条件的报文的相关信息记录到日志中。可以在后面设置具体规则对报文进一步处理。</p>
</li>
<li><p>可以通过tail -f /var/log/messages 来查看。</p>
</li>
<li><p>–log-level 来指定日志的日志级别。包括</p>
<ol>
<li>emerg</li>
<li>alert</li>
<li>crit</li>
<li>error</li>
<li>warning</li>
<li>notice</li>
<li>info</li>
<li>debug</li>
</ol>
</li>
<li><p>–log-prefix 来给记录到的相关信息添加标签之类的信息，以区分各种记录到的报文。</p>
</li>
</ol>
<p>iptables -I INPUT -p tcp –dport 80 -m state –state NEW -j LOG –log-prefix “want-in-from-22”<br>#<a href=""http://www.zsythink.net/archives/1764"">iptables 动作总结2</a></p>
<h2 id="SNAT"><a href="#SNAT" class="headerlink" title="SNAT"></a>SNAT</h2><p>iptables -t nat -A POSTROUTING -s 192.18.0.0/16 -j SNAT –to-source 192.18.33.251</p>
<ol>
<li>其中-A 标识将snat规则添加到POSTROUTING链的末尾。POSTROUTING可以认为是报文发出的最后一个关卡。</li>
<li>-j SNAT表示对匹配到的报文进行源地址转换。</li>
<li>–to-source表示转换成这个源</li>
</ol>
<h2 id="DNAT"><a href="#DNAT" class="headerlink" title="DNAT"></a>DNAT</h2><p>按端口进行转发</p>
<ol>
<li><p>iptables -t nat -I PREROUTING -d 192.18.33.251 -p tcp –dport 801 -j DNAT –to-destination 192.18.22.22:80</p>
</li>
<li><p>注：开启端口/sbin/iptables -I INPUT -p tcp –dport 80 -j ACCEPT</p>
</li>
</ol>
<h2 id="MASQUERADE"><a href="#MASQUERADE" class="headerlink" title="MASQUERADE"></a>MASQUERADE</h2><p>动态的将源地址转换为可用的IP地址。类似于SNAT而无需指明修改成哪个IP，可以适应动态变化。</p>
<ol>
<li>iptables -t nat -I POSTROUTING -s 192.18.0.0/16 -o ens33 -j MASQUERADE</li>
</ol>
<h2 id="REDIRECT"><a href="#REDIRECT" class="headerlink" title="REDIRECT"></a>REDIRECT</h2><p>可以将本机端口进行映射。</p>
<ol>
<li>iptables -t nat -A PREROUTING -p tcp –dport 80 -j REDIRECT –to-ports 801</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Iptables实验目录" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/Iptables%E5%AE%9E%E9%AA%8C%E7%9B%AE%E5%BD%95/"
    >Iptables实验目录</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/Iptables%E5%AE%9E%E9%AA%8C%E7%9B%AE%E5%BD%95/" class="article-date">
  <time datetime="2020-03-30T02:36:52.223Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="IptablesExp基础"><a href="#IptablesExp基础" class="headerlink" title="IptablesExp基础"></a><a href="/2020/03/30/iptables">IptablesExp基础</a></h2><h2 id="实验详情见代码仓库"><a href="#实验详情见代码仓库" class="headerlink" title="实验详情见代码仓库"></a><a href="https://github.com/Cccceb/BTF.git">实验详情见代码仓库</a></h2><p>​    本次实验通过设置 iptables 规则，来实现防火墙功能。iptables 本身不是 </p>
<p>防火墙，它可以理解为一个客户端代理，通过 iptables 来设定规则，最终运行 </p>
<p>在 netfilter 框架下。 </p>
<p>​    Iptables 中有四链五表，用来过滤所有进出的报文。防火墙的功能是对经过 </p>
<p>的报文匹配规则，然后执行对应的动作。对于每个关卡，都不止一条规则，故称 </p>
<p>为链。将那些具有相同规则的集合叫做表。链包括 INPUT、OUTPU、PREROURING(路 </p>
<p>由前)、FORWARD(转发)、POSTROUTING(路由后)。同时，在 iptables 中预定义了 </p>
<p>四种表，分别是负责过滤的 filter 表、负责网络地址转换的 nat 表、负责拆解 </p>
<p>报文做出修改的 mangle 表以及关闭 nat 表上启用的连接追踪机制的 raw 表。本 </p>
<p>次实验中主要涉及了前两个表。 </p>
<p>​    通过本次实验，学习了很多关于 iptables 以及网络、安全方面的知识。我 </p>
<p>将学到的知识治理成以下三个实验内容：主机防火墙、网络防火墙、NAT 转换。 </p>
<p>在理论课的过程中，老师经常提及 Dos 攻击。所以，在学习了 socket 编程 </p>
<p>之后，用 C 语言实现了两台虚拟机之间建立 TCP 连接。最终模拟了防御 Dos 攻击 </p>
<p>的情况，形成了实验四。 </p>
<p>​    总的来说，本次实验我递进式的做了四个实验，分别是主机防火墙、网络防 </p>
<p>火墙、NAT 动作、TCP 连接与 DoS 防御。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导第2章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC2%E7%AB%A0/"
    >计安导第2章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC2%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.494Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="物理保护与攻击"><a href="#物理保护与攻击" class="headerlink" title="物理保护与攻击"></a>物理保护与攻击</h1><h2 id="物理安全"><a href="#物理安全" class="headerlink" title="物理安全"></a>物理安全</h2><ol>
<li>物理安全：泛指保护贵重物品、信息或访问受限资源 所使用的物理措施，物理安全直接影响完整性、计算 机硬件和数字信息保护。包括<ol>
<li>位置保护</li>
<li>物理入侵检测</li>
<li>硬件攻击</li>
<li>窃听</li>
<li>物理接口攻击</li>
</ol>
</li>
</ol>
<h2 id="钥匙与锁"><a href="#钥匙与锁" class="headerlink" title="钥匙与锁"></a>钥匙与锁</h2><ol>
<li>包括TSA锁，凸块锁，万能钥匙，弹子锁</li>
<li>非破坏性开锁：选取，旁路</li>
<li>40种不同的钥匙坯，7个顶部锁鞘，8个不同高度的底部锁鞘，则可能的钥匙数量是40*8<sup>7</sup><h2 id="特权升级"><a href="#特权升级" class="headerlink" title="特权升级"></a>特权升级</h2>攻击者将地权限的密钥提升为高权限的密钥</li>
</ol>
<h2 id="指纹锁相关问题"><a href="#指纹锁相关问题" class="headerlink" title="指纹锁相关问题"></a>指纹锁相关问题</h2><ol>
<li>识别率不够高</li>
<li>电池寿命问题</li>
<li>指纹锁的稳定性不高</li>
</ol>
<h2 id="测信道攻击"><a href="#测信道攻击" class="headerlink" title="测信道攻击"></a>测信道攻击</h2><p>攻击者不是试图直接绕过 安全措施，而是通过利用 其他不受安全机制保护的 漏洞绕过安全措施</p>
<h1 id="身份认证技术"><a href="#身份认证技术" class="headerlink" title="身份认证技术"></a>身份认证技术</h1><ol>
<li>包括条形码，二维码，磁条卡，智能卡，SIM卡,RFID</li>
</ol>
<h2 id="磁条卡安全"><a href="#磁条卡安全" class="headerlink" title="磁条卡安全"></a>磁条卡安全</h2><ol>
<li>问题：易于读取和复制。词条阅读器成本相对较低</li>
<li>解决：要求输入PIN</li>
</ol>
<h2 id="智能卡安全"><a href="#智能卡安全" class="headerlink" title="智能卡安全"></a>智能卡安全</h2><ol>
<li>可以提供保护所有者信息的安全认证机制，并且极难复制</li>
<li>使用加密技术加强认证的手段</li>
</ol>
<h2 id="SIM卡安全"><a href="#SIM卡安全" class="headerlink" title="SIM卡安全"></a>SIM卡安全</h2><ol>
<li>SIM卡：用于识别所有者并对相应的蜂窝网络进行身份验证</li>
<li>18位，用于硬件识别</li>
<li>128位密钥</li>
</ol>
<h2 id="GSM挑战-相应协议"><a href="#GSM挑战-相应协议" class="headerlink" title="GSM挑战-相应协议"></a>GSM挑战-相应协议</h2><p><img src="/%E8%AE%A1%E5%AE%89%E5%AF%BC_img/36.png" alt=""></p>
<ol>
<li>当手机希望加入蜂窝网络时，它连接并发送其IMSI到网络提供商拥有的 本地基站。 </li>
<li>如果IMSI匹配网络提供商的数据库中的用户记录正确，则基站将128位 随机数发送到蜂窝电话。 </li>
<li>然后，该随机数由蜂窝电话编码存储在SIM卡中，用户的密钥使用A3的 专有加密算法，从而产生发送回基站的密文</li>
<li>然后，基站使用其存储的用于用户密钥的值来执行相同的计算。 如果两 个密文匹配，则手机被认证到网络并被允许拨打和接听电话。</li>
</ol>
<h2 id="RFID"><a href="#RFID" class="headerlink" title="RFID"></a>RFID</h2><ol>
<li>必须与单独的读取器或写入器一起使用</li>
<li>所有RFID都使用密钥加密</li>
</ol>
<h2 id="生物识别技术"><a href="#生物识别技术" class="headerlink" title="生物识别技术"></a>生物识别技术</h2><ol>
<li><p>生物特征：指用于基于生物或生理特 征唯一识别信息进行的任何身份度 量。</p>
</li>
<li><p>生物识别的要求</p>
<ol>
<li>普遍性</li>
<li>独特性</li>
<li>持久性</li>
<li>可回收性：该特征应具有有效确定和量化的能力</li>
</ol>
</li>
<li><p>如指纹，虹膜，步态</p>
</li>
</ol>
<h1 id="针对计算设备的攻击"><a href="#针对计算设备的攻击" class="headerlink" title="针对计算设备的攻击"></a>针对计算设备的攻击</h1><h2 id="环境攻击"><a href="#环境攻击" class="headerlink" title="环境攻击"></a>环境攻击</h2><ol>
<li>电力，温度，有限的传导</li>
</ol>
<h2 id="窃听"><a href="#窃听" class="headerlink" title="窃听"></a>窃听</h2><p>搭线窃听同轴电缆的电脉冲</p>
<h2 id="信号发射"><a href="#信号发射" class="headerlink" title="信号发射"></a>信号发射</h2><p>通过计算机屏幕发出的射频信号来检测正在显示的内容</p>
<h2 id="键盘记录"><a href="#键盘记录" class="headerlink" title="键盘记录"></a>键盘记录</h2><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ol>
<li>三级：1米；20米，100米</li>
<li>放射阻隔(阻隔光,音)</li>
<li>法拉第笼：阻挡电磁辐射</li>
</ol>
<h1 id="计算机取证"><a href="#计算机取证" class="headerlink" title="计算机取证"></a>计算机取证</h1><p>计算机取证是一种获取包含在电子媒介上的信息的方 法，如计算机系统、硬盘和光盘，通常用于收集用于 法律诉讼的证据</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li>鉴定</li>
<li>收集：注意不要修改数据</li>
<li>分析和评估</li>
<li>报告</li>
</ol>
<h2 id="取证约束"><a href="#取证约束" class="headerlink" title="取证约束"></a>取证约束</h2><ol>
<li>监管链</li>
<li>优先级RAM &gt; swap &gt; disk &gt; CDs/DVDs。第一时间捕获更易失的</li>
<li>犯罪现场的计算机应该被视为完全敌对的</li>
</ol>
<h2 id="隐藏数据的方法"><a href="#隐藏数据的方法" class="headerlink" title="隐藏数据的方法"></a>隐藏数据的方法</h2><ol>
<li>密码学</li>
<li>隐写术</li>
<li>更改文件名或者扩展名</li>
<li>隐藏分区</li>
<li>删除文件</li>
</ol>
<h2 id="反取证技术"><a href="#反取证技术" class="headerlink" title="反取证技术"></a>反取证技术</h2><ol>
<li>反取证技术试图阻止调查员及其取证技术</li>
<li>安全删除数据，以便无法使用取证方法进行恢复 </li>
<li>首先防止创建某些数据</li>
<li>从未出现的数据显然无法通过取证方法恢复。</li>
</ol>
<h2 id="磁盘擦出"><a href="#磁盘擦出" class="headerlink" title="磁盘擦出"></a>磁盘擦出</h2>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导第3章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC3%E7%AB%A0/"
    >计安导第3章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC3%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.494Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h1><ol>
<li><p>包括计算机硬件系统和计算机软件系统。</p>
<ol>
<li>硬件系统包括：运算器，控制器，存储器，输入设备，输出设备。</li>
<li>软件系统：操作系统</li>
</ol>
</li>
<li><p>操作系统：提供计算机用户和该计算机硬件之间的接口，管理应用程序访问计算机资源的方式。</p>
<ol>
<li>内核：操作系统的核心组件，处理对底层硬件资源的管理。</li>
</ol>
</li>
<li><p>系统调用：是一种机制，通过这种机制，应用程序可以委托内核来执行与硬件相关的操作。</p>
<h1 id="进程："><a href="#进程：" class="headerlink" title="进程："></a>进程：</h1></li>
<li><p>进程进程是正在执行的程序的一个实例。</p>
</li>
<li><p>进程树：新的进程由其父进程产生，构成一颗进程树。树的根是init进程，在加载和运行内核后开始执行，并创建登陆会话和系统任务等其他子进程。</p>
</li>
<li><p>进程ID：每个进程都通过唯一的非负整数进行标识。</p>
</li>
<li><p>进程间通信</p>
<ol>
<li>读写文件进行方式<ol>
<li>通过硬盘，速度较慢。</li>
<li>不便于进行私密通信。</li>
</ol>
</li>
<li>共享内存方式<ol>
<li>只有内核能管理共享内存区。</li>
</ol>
</li>
<li>管道和套接字：提供进程与进程间通信的通道，通信双方共享管道和套接字。</li>
<li>信号量机制</li>
</ol>
</li>
<li><p>远程过程调用RPC：允许一个进程调用另一个进程中的子例程。</p>
</li>
<li><p>守护进程和服务</p>
<ol>
<li>守护进程（后台进程）（Windows下称为服务）：运行权限高于任何用户，并在登陆会话结束前就一直存在。如Web服务器，远程登陆等<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1></li>
</ol>
</li>
<li><p>文件系统是如何组织计算机的外部、非易失性存储的一种抽象。</p>
</li>
<li><p>文件权限</p>
<p> 关键在于界定哪些用户可以访问哪些资源。</p>
</li>
<li><p>Unix文件权限</p>
<ol>
<li>包括三类用户：<ol>
<li>owner类</li>
<li>group类：决定了相同组中的用户的文件权限。</li>
<li>others类<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1></li>
</ol>
</li>
</ol>
</li>
<li><p>内存管理是指如何组织和分配计算机的内存。</p>
</li>
<li><p>进程的地址空间</p>
<ol>
<li>代码段</li>
<li>数据段</li>
<li>BSS：符号起始区块，包含未初始化的静态变量。</li>
<li>堆：动态段，存储运行时产生的数据。</li>
<li>栈：记录函数调用和他们的参数。</li>
</ol>
</li>
<li><p>内存访问权限</p>
<ol>
<li>五段都有各自的访问权限。通常代码段只读，其他段可以写入</li>
<li><strong>不允许进程访问其他进程的地址空间</strong></li>
</ol>
</li>
<li><p>虚拟内存</p>
<ol>
<li>每个进程都有一个虚拟地址空间，虚拟内存系统将每个虚拟地址映射为实际内存地址。</li>
<li>由MMU来进行地址转换。</li>
<li>在进程看来，它的虚拟地址空间是连续的，但是实际内存却未必。</li>
<li>优点：允许进程的地址空间大于内存。</li>
<li>缺点：访问硬盘速度慢。 </li>
<li><strong>问题</strong>：不正常关机的时候，虚拟页面可能未被删除。攻击者可以通过外部介质引导另一个操作系统，查看并重建部分内存，导致信息泄漏。</li>
<li><strong>解决</strong>：对硬盘内容进行加密。</li>
</ol>
</li>
<li><p>缺页</p>
</li>
<li><p>虚拟机</p>
<ol>
<li>不直接接触底层硬件就允许操作系统的运行。</li>
<li>在虚拟机中运行的操作系统称为客户机，本地的操作系统称为主机。</li>
<li>虚拟机的实现：<ol>
<li>模拟：主机系统翻译接口的通信，传给硬件。其优点是增加了硬件的灵活性，缺点是使性能下降。</li>
<li>虚拟化：失去硬件灵活性，但是性能提升了。</li>
</ol>
</li>
<li>虚拟机的优点<ol>
<li>提高了硬件效率：在一台机器上托管多个操作系统。</li>
<li>可移植性</li>
<li>安全：沙箱</li>
<li>便于管理<h1 id="进程安全"><a href="#进程安全" class="headerlink" title="进程安全"></a>进程安全</h1><h2 id="引导顺序及安全"><a href="#引导顺序及安全" class="headerlink" title="引导顺序及安全"></a>引导顺序及安全</h2></li>
</ol>
</li>
</ol>
</li>
<li><p>引导：从关机状态到将操作系统加载到内存。</p>
</li>
<li><p>加载分两阶段：首先加载BIOS固件中的代码，然后这程序会假爱国操作系统其余部分加载到内存，然后将控制权交给操作系统。</p>
</li>
<li><p><strong>问题</strong>：恶意用户可以利用引导过程的一些脆弱点来控制计算机的执行。</p>
</li>
<li><p><strong>解决</strong>：设置BIOS密码。</p>
<h2 id="引导设备的层次"><a href="#引导设备的层次" class="headerlink" title="引导设备的层次"></a>引导设备的层次</h2></li>
<li><p>第二阶段引导程序允许用户指定使用哪个设备来加载操作系统。</p>
</li>
<li><p><strong>问题</strong>：攻击者可以绕过运行的计算机上的安全机制，从外部介质引导其他操作系统。</p>
</li>
<li><p><strong>解决</strong>：对第二阶段引导程序启动密码保护。</p>
<h2 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h2></li>
<li><p>休眠：电源关闭的状态。当进入休眠时，操作系统将计算机内存的全部内容存储到硬盘中的休眠文件中；系统通电后，再迅速恢复计算机状态。</p>
</li>
<li><p><strong>问题</strong>：</p>
<ol>
<li>攻击者可以从休眠文件中获取一些敏感信息。Windows的休眠文件目录C:/hiberfil.sys</li>
<li>攻击者可以修改休眠文件，改变计算机上执行的程序。</li>
<li>即使计算机重启后，也不会删除休眠文件。</li>
</ol>
</li>
<li><p><strong>解决</strong>：使用硬盘加密来保护休眠文件。</p>
<h2 id="监控、管理和日志"><a href="#监控、管理和日志" class="headerlink" title="监控、管理和日志"></a>监控、管理和日志</h2><p>操作系统可以根据留下的线索解决常见的问题，还能确定出现安全漏洞的原因。</p>
</li>
<li><p>事件日志：</p>
<ol>
<li>由操作系统进行管理</li>
<li>Windows中定义了三种日记 源：系统、应用程序和安全。其中系统日志只有操作系统才能写入；应用程序日志只由应用程序写入；安全日志由操作系统提供的本地安全授予子系统服务才能写入。  </li>
</ol>
</li>
<li><p>进程监控：查看正在运行的进程</p>
</li>
<li><p>进程查看器：提供进程监控和管理的大量信息。</p>
<ol>
<li>提高进程的映像，即运行进程的代码所在的磁盘位置。</li>
<li><strong>问题</strong>：攻击者可以通过替换合法程序的映像来掩饰自身。</li>
<li><strong>解决</strong>：可以对映像使用数字签名来保证磁盘上存储的应用程序不被替换。</li>
</ol>
</li>
</ol>
<h1 id="基于密码的身份认证"><a href="#基于密码的身份认证" class="headerlink" title="基于密码的身份认证"></a>基于密码的身份认证</h1><ol>
<li><p>密码盐—反字典攻击：是一种加密技术，使用随机位作为散列函数的输入或加密算法的部分输入，从而增加随机性。<br> (U,S,h(S||P))其中S为U的盐，h是散列函数。</p>
</li>
<li><p>加盐的原理：增大字典攻击的搜索空间。2<sup>B×D，其中B是随机数位数，D是字典攻击单词列表。</p>
<h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><h2 id="Linux的权限"><a href="#Linux的权限" class="headerlink" title="Linux的权限"></a>Linux的权限</h2></li>
<li><p>使用文件权限矩阵</p>
</li>
<li><p>对于未明确授权的都默认拒绝</p>
</li>
<li><p>为了访问文件，在文件系统树中的每个祖先文件夹都必须有执行权限。</p>
</li>
<li><p>文件所有者具有自主访问控制权，可以修改文件权限。</p>
</li>
<li><p>可以使用chattr设置权限，lsattr查看。</p>
</li>
<li><p>目前开始支持ACL方案</p>
</li>
<li><p>对owner, group和other主体，每个文件都有基本的ACE(<strong>访问控制项</strong>)；对于命名用户和命名组可创建额外的ACE；还有掩码ACE,即规定主体允许的最大权限</p>
<h2 id="Linux的ACL权限方案"><a href="#Linux的ACL权限方案" class="headerlink" title="Linux的ACL权限方案"></a>Linux的ACL权限方案</h2></li>
<li><p>设U是进程的euid，具有一定的请求权限，视图访问文件或文件夹</p>
</li>
<li><p>为确定是否授权，操作系统将进行匹配：</p>
<ol>
<li>U是文件所有者的ID</li>
<li>U是命名组之一</li>
<li>U的一个组是所有组，该组的ACE包含请求权限。</li>
<li>U的一个组是命名组，该组的ACE包含请求权限。</li>
<li>对于U所在的每个组，该组的ACE都不包含请求权限。</li>
<li>检查other的ACE<h2 id="Windows权限基础"><a href="#Windows权限基础" class="headerlink" title="Windows权限基础"></a>Windows权限基础</h2></li>
</ol>
</li>
<li><p>Windows使用访问控制列表，允许用户创建访问控制规则。</p>
</li>
<li><p>默认是拒绝</p>
</li>
<li><p>标准权限包裹：读、写、修改、读和执行、完全控制。</p>
</li>
<li><p>读相关的高级属性：读取数据、读取属性、读取扩展属性和读取权限。</p>
</li>
<li><p>文件夹权限包括</p>
<ol>
<li>读权限：可以列出文件夹内容。</li>
<li>写权限：允许用户创建新文件夹。</li>
<li>Windows下可以禁止用户访问文件夹，但允许用户访问该文件夹下的特定文件。</li>
</ol>
</li>
<li><p>ACE</p>
<ol>
<li>继承ACE：文件夹的任何ACE可用于该文件夹内的子文件夹和文件。</li>
<li>显式ACE：针对文件或者文件夹专门设置的ACE。</li>
<li>ACE优先级：拒绝ACE&gt;允许ACE、显示ACE&gt;继承ACE、继承ACE优先级 由祖先与对象之间的距离决定，越近优先级越高。<h2 id="Windows文件权限"><a href="#Windows文件权限" class="headerlink" title="Windows文件权限"></a>Windows文件权限</h2></li>
</ol>
</li>
<li><p>SetUID操作：程序由普通用户运行，但期望允许程序改变普通用户无法改变的文件。</p>
<p> 例如：在早期UNIX系统中，用户登录信息存储在/etc/passwd中。普通用户 不能编辑这个文件，但允许该用户更改自己的密码是合理的要求</p>
<ol>
<li>设置了setuid位，使得程序以其所有者的有效ID来运行，而不是以正在执行程序的进程ID。</li>
<li><strong>问题</strong>  <ol>
<li>攻击者可以强制setuid程序执行任意代码，如缓冲区溢出攻击。</li>
<li>权限升级：攻击者可以通过setuid机制来运用程序的所有者权限。</li>
</ol>
</li>
</ol>
</li>
<li><p>文件描述符：存储在文件描述符表中的索引值，用来索引特定文件</p>
<ol>
<li>当程序需要访问文件时，访问open系统调用，该调用使内核创建一个文件 描述符表中的新项并将其返回给程序，该项映射到文件的磁盘位置。程序可以使用文件描述符发送读或者写命令。内核在接到读、写系统调用时， 在文件描述符表中查找相关的表项，并在磁盘适当位置执行读、写操作。完成操作后，要用close系统调用删除打开的文件描述符。</li>
<li><strong>漏洞</strong> 当进程创建子进程时，子进程会集成父进程打开的所有文 件描述符副本。当程序以高权限打开文件描述符，但未关闭，然后又创建了 低权限的进程，那么新进程就能够读写相关文件，但子进程本身不具有打开 该文件的权限。</li>
<li><strong>原因</strong> 在创建文件描述符项的时刻，操作 系统只检查进程是否具有读写权限；在实际读写文件操作时，只根据文件描 述符被打开时的权限来确认是否允许请求的操作。</li>
</ol>
</li>
<li><p>符号链接与快捷方式</p>
<ol>
<li><strong>问题</strong> 攻击者可以利用符号链接来诱使应用程序执行不良操作。</li>
<li><strong>解决</strong> 程序检查文件名是否指向符号链接，以确定打开的实际文件名。</li>
<li>Windows的快捷方式&amp;Linux的符号链接：符号链接由操作系统处 理，使用透明；而快捷方式是普通文件。<h1 id="应用程序安全"><a href="#应用程序安全" class="headerlink" title="应用程序安全"></a>应用程序安全</h1><h2 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h2></li>
</ol>
</li>
<li><p>编译：将源代码转换为处理器能够执行的机器代码的过程</p>
</li>
<li><p>静态链接：程序执行时所需的共享库需要复制到编译程序中。一般比较安全， 但重复代码会占用额外的空间。</p>
</li>
<li><p>动态链接：程序真正运行时，才会加载共享库。加载程序确定待运行程序需 要哪些共享库，然后在磁盘上找到这些库，并将它们导入进程的地址空间。</p>
<ol>
<li><strong>DDL注入</strong>：通过共享库向程序注入任意代码的过程。<strong>优点</strong> 是便于调试，<strong>缺点</strong> 是潜在的安全风险，恶意用户能向合法程序注入自己的代码。<h2 id="简单的缓冲区溢出攻击"><a href="#简单的缓冲区溢出攻击" class="headerlink" title="简单的缓冲区溢出攻击"></a>简单的缓冲区溢出攻击</h2></li>
</ol>
</li>
<li><p>缓冲区：进程为程序在内存中分配固定大小的存储空间。</p>
</li>
<li><p>缓冲区溢出：如果不进行边界检查，攻击者提供的输入数据可能会超出缓冲 区的大小。此时，内存缓冲区之外的数据可能会被覆盖。</p>
</li>
<li><p><strong>问题</strong> 攻击者利用缓冲区溢出获得进程的控制权，执行任意恶意代码。</p>
<h2 id="基于栈的缓冲区溢出"><a href="#基于栈的缓冲区溢出" class="headerlink" title="基于栈的缓冲区溢出"></a>基于栈的缓冲区溢出</h2></li>
<li><p>进程地址空间中栈由帧组成，每一帧存储局部变量、调用参数和返回地址。</p>
</li>
<li><p><strong>问题</strong> 如果攻击者提供的输入大于调用函数中缓冲区的大小，会导致溢出，从而导致栈缓冲区之外 的内存空间被覆盖。</p>
</li>
<li><p>缓冲区溢出攻击：当缓冲区是局部变量 或帧的参数时，用户的输入 可能覆盖返回地址，改变程 序的执行。</p>
<ol>
<li><strong>问题</strong> 攻击者利用栈缓冲区的脆弱 性，在栈中注入恶意代码， 覆盖当前调用的返回地址， 从而将执行权限传递给攻击 者的恶意代码。</li>
<li>实际攻击中，攻击者需要猜测缓冲区返回地址的位置，并确定用什么地址覆盖返回地址。难点在于：<ol>
<li>进程不能访问其他进程的地址空间，因此恶意代码必须驻留在被攻击进 程的地址空间内。一般驻留在缓冲区中或者在用户的Shell环境中。</li>
<li>给定进程的地址空间是不可预测的，程序在不同计算机上执行时，地址 空间可能发生改变。</li>
<li>为了克服以上困难，攻击者可以采取的相关技术有：NOP指令滑动(NOP sledding)、返回到libc(return-to-libc)、跳转到寄存器(jump-to-register)或蹦 床(Trampolining)技术<h2 id="缓冲区溢出攻击相关技术"><a href="#缓冲区溢出攻击相关技术" class="headerlink" title="缓冲区溢出攻击相关技术"></a>缓冲区溢出攻击相关技术</h2></li>
</ol>
</li>
</ol>
</li>
<li><p>NOP指令滑动:通过命中一串连续的NOP指令，从而使CPU指令执行流一直滑动到特定位 置来执行恶意代码。</p>
<ol>
<li>由于进程地址空间难以预测，所以通过一连串的NOP指令，只要有一个命中就能执行恶意代码。</li>
</ol>
</li>
<li><p>跳转到寄存器：在初始化时，大多数进程需要将外部库的内容加载到自己的地址空间。操作 系统一般将这些外部库加载到内存预留段的进程地址空间中。因此，外部库 在内存中的位置是可预测的。攻击者利用这些外部库的知识进行跳转攻击：</p>
<ol>
<li>攻击者找到特定代码集中 的跳转指令，如jump ESP；</li>
<li>攻击者设法把恶意代码放在ESP寄存器指定 的内存地址上；</li>
<li>攻击者将当前函数的返回地址重写为jump指令的地址； </li>
<li>函数返回时将执行jump指令，并跳转执行恶意代码；</li>
</ol>
</li>
<li><p>返回到libc攻击：攻击者确定脆弱进程的地址空间内C库函数的地址，如system()或execv的 地址，并使用这些信息强制进程调用该函数。</p>
<ol>
<li>攻击者首先让缓冲区溢出，并用所需库函数的地址覆盖返回地址，并传递重 新设定好的参数使其能够按攻击者的期望运行。</li>
<li>这种攻击方式在实现攻击的同时，也避开了数据执行保护策略中对攻击代码 的注入和执行所采取的的防护措施。Return-to-libc 攻击不需要注入新的恶意代码，而是重用漏洞程序中已有的 函数完成攻击，让漏洞程序跳转到已有的代码序列。</li>
</ol>
</li>
</ol>
<h2 id="防止基于栈的缓冲区溢出攻击"><a href="#防止基于栈的缓冲区溢出攻击" class="headerlink" title="防止基于栈的缓冲区溢出攻击"></a>防止基于栈的缓冲区溢出攻击</h2><ol>
<li>规范C语言编程</li>
<li>使用更安全的函数</li>
<li>操作系统也提供保护措施，如防止攻击者覆盖返回地址；使用金丝雀技术。</li>
</ol>
<h3 id="防止攻击者覆盖返回值地址"><a href="#防止攻击者覆盖返回值地址" class="headerlink" title="防止攻击者覆盖返回值地址"></a>防止攻击者覆盖返回值地址</h3><ol>
<li>在所有指针使用前后都进行异或编码</li>
<li>将内存的栈空间设置为非执行权限</li>
<li>地址空间布局随机化，随机地重新安排地址空间的数据，使得攻击者难以预测。</li>
</ol>
<h3 id="金丝雀预警技术"><a href="#金丝雀预警技术" class="headerlink" title="金丝雀预警技术"></a>金丝雀预警技术</h3><p>重新组织分配程序的堆栈数据，使用一个canary值，并将此值放在缓冲区和 控制数据之间。系统定期检查canary值的完整性。如果此值被更改，表明缓 冲区溢出，就要防止恶意代码的执行。</p>
<h2 id="基于堆的缓冲区溢出"><a href="#基于堆的缓冲区溢出" class="headerlink" title="基于堆的缓冲区溢出"></a>基于堆的缓冲区溢出</h2><p><strong>问题</strong> 如果在堆上显示分配了内存，但没有释放，会导致内存泄漏问题。</p>
<p><strong>攻击</strong> 攻击者一般通过修改堆中的数据 或者滥用管理堆内存的函数和宏 来执行恶意代码。</p>
<ol>
<li>如果攻击者向程序提供输入，而程序以不安全的方式将其复制到堆中的内存 块中。那么攻击者可以使数据溢出块的边界，并覆盖下一个内存块。通过精心设计，攻击者会覆盖下一个内存块的链表指针，并将该内存块标记 为空闲。此时，unlink例程可以向内存地址空间中的任意地址写入数据。如 果写入的数据是恶意代码的存储位置，会导致程序跳转并执行恶意代码。</li>
</ol>
<h2 id="防御基于堆的缓冲区溢出"><a href="#防御基于堆的缓冲区溢出" class="headerlink" title="防御基于堆的缓冲区溢出"></a>防御基于堆的缓冲区溢出</h2><p>如安全编程、地址空间随机化、设置堆数据不可执 行、将存储堆内存的指针数据和存储堆中的实际数据相分离。</p>
<h1 id="格式化字符串攻击"><a href="#格式化字符串攻击" class="headerlink" title="格式化字符串攻击"></a>格式化字符串攻击</h1><p><strong>攻击</strong> 攻击者可以精心指定所使用的格式化字符串作为输入，并可以将输入写入内 存的任意位置。如果写入的位置正好覆盖了返回地址、函数指针等，则攻击 者能够取得控制权，并在程序的上下文中执行任意代码。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导第4章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC4%E7%AB%A0/"
    >计安导第4章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC4%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.494Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="内部攻击"><a href="#内部攻击" class="headerlink" title="内部攻击"></a>内部攻击</h1><ol start="2">
<li>内部攻击：指控制和保护资产的内部人员利用安全漏洞进行的攻击</li>
</ol>
<h2 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h2><ol start="3">
<li>后门：是程序中隐藏的功能或命令，有时也称为活门，它允许用户执行一些正常情况下不允许用户执行的操作。通常这些操作会违反安全策略，如执行特权升级。<ol>
<li>为调试有时也会插入后门</li>
<li>为了紧急情况也可能留后门</li>
<li>恶意的后门：直接留后门；在程序中引入脆弱性，如缓冲区溢出。</li>
<li>彩蛋</li>
</ol>
</li>
</ol>
<h2 id="逻辑炸弹"><a href="#逻辑炸弹" class="headerlink" title="逻辑炸弹"></a>逻辑炸弹</h2><ol start="4">
<li>逻辑炸弹：是一种程序，它根据一定的逻辑条件执行恶意操作。</li>
<li>千年虫问题：具有和逻辑炸弹类似的效果，但是不视为逻辑炸弹</li>
</ol>
<h2 id="内部攻击的防御"><a href="#内部攻击的防御" class="headerlink" title="内部攻击的防御"></a>内部攻击的防御</h2><ol>
<li>避免单点故障：不能只让一个人创建备份或管理重要系统。</li>
<li>使用代码走查</li>
<li>使用归档和报告工具</li>
<li>限制授权和权限：使用最小权限原则；在保证每个员工能正常工作的情况下，授予他们最小权限。</li>
<li>重要系统的物理安全</li>
<li>监控员工行为</li>
<li>控制软件的安装</li>
</ol>
<h1 id="计算机病毒"><a href="#计算机病毒" class="headerlink" title="计算机病毒"></a>计算机病毒</h1><ol>
<li>计算机病毒：是一种能自我复制的计算机指令或程序代码，它通过修改其他文件与程序来插入代码，且能进一步自我复制；<ol>
<li>这种自我复制的特性是计算机病毒与其他类型恶意软件（如逻辑炸弹）的不同之处；</li>
<li>病毒的另一个特性是其复制需要某种类型的用户协助，如打开电子邮件附件或共享USB驱动器；</li>
</ol>
</li>
<li>恶意软件分类：<ol>
<li>按传播特性分：<ol>
<li>病毒：人工辅助传播</li>
<li>蠕虫：自动传播</li>
</ol>
</li>
<li>按隐藏特性分：<ol>
<li>Rootkit：修改操作系统以隐藏其存在</li>
<li>特洛伊木马：提供理想的功能但是隐藏恶意操作。</li>
</ol>
</li>
</ol>
</li>
<li>隐藏方式<ol>
<li>加密病毒：<ol>
<li>病毒包括解密引擎+病毒代码主体，随机生成加密密钥</li>
<li>检测：通过查找解密引擎</li>
</ol>
</li>
<li>多态病毒<ol>
<li>具有随机变体的解密引擎的加密病毒</li>
<li>检测：使用CPU仿真器</li>
</ol>
</li>
<li>变形病毒<ol>
<li>不同的病毒体；方法包括代码排列和指令替换</li>
<li>具有挑战性的检测</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="病毒的分类"><a href="#病毒的分类" class="headerlink" title="病毒的分类"></a>病毒的分类</h2><ol start="3">
<li>病毒执行的四个阶段<ol>
<li>潜伏阶段</li>
<li>繁殖阶段：病毒进行自我复制，归纳然新系统中的新文件。</li>
<li>触发阶段</li>
<li>行动阶段：此阶段，病毒会执行恶意操作。</li>
</ol>
</li>
<li>病毒的类型<ol>
<li>程序病毒（文件病毒）：通过修改文件包含的对象代码感染文件。</li>
<li>宏病毒（文档病毒）：打开文档时，启动病毒，此时，病毒搜索其他要感染的文件。此外，宏病毒还可以将自己插入到模板中，使得每次新建的文档都含有此病毒。另外，还可以通过电子邮件传播。</li>
<li>引导区病毒：感染驱动器引导区的代码，每次启动计算机或重启时，都会运行引导区的代码。</li>
</ol>
</li>
<li>病毒的特征<ol>
<li>传染性</li>
<li>隐蔽性</li>
<li>潜伏性：只有当触发条件满足时才破坏，否则只传染</li>
<li>多态性：不断变种</li>
<li>破坏性</li>
</ol>
</li>
<li>病毒注入：（1）在程序开始处简单注入（2）将病毒代码分成两部分，并将这两部分分别注入到程序的不同位置，使用跳转指令来执行。</li>
</ol>
<h2 id="病毒的防御"><a href="#病毒的防御" class="headerlink" title="病毒的防御"></a>病毒的防御</h2><ol>
<li>病毒的特征码：<ol>
<li>通过病毒样本找到病毒的特征指令集，产检唯一标识这类病毒的特征字符串。<strong>一般将特征字符串称为病毒的特征码</strong>。它是病毒的一种数字指纹</li>
</ol>
</li>
<li>病毒的检测与隔离<ol>
<li>可以定期扫描整个文件系统</li>
<li>可以实时的分析每个新创建的文件，每个修改的文件和收到的电子邮件。一旦文件中有一部分包含与病毒特征码匹配的代码，就会被放入隔离区。</li>
</ol>
</li>
</ol>
<h2 id="加密病毒"><a href="#加密病毒" class="headerlink" title="加密病毒"></a>加密病毒</h2><ol>
<li>加密病毒：通过加密病毒代码的主体，以隐藏其自身的特征码。<ol>
<li>包括解密代码、密钥和加密病毒代码（解密代码一般用暴力破解代替）。</li>
<li>对病毒主体的解密代码本身时未加密的代码，此结构本身就构成了一种病毒的特征码。</li>
</ol>
</li>
</ol>
<h2 id="多变体病毒和变形病毒"><a href="#多变体病毒和变形病毒" class="headerlink" title="多变体病毒和变形病毒"></a>多变体病毒和变形病毒</h2><ol>
<li><p>多变体：变异的病毒。</p>
<ol>
<li>一方面，多变体病毒通过加密使自身呈现出多种形式。</li>
<li>另一方面，多变体病毒采用非加密的混淆技术，如指令重排和包含无用指令技术。</li>
</ol>
</li>
<li><p>检测多变体病毒：单个字符串不可能检测变形病毒的特征码，可以采用</p>
<ol>
<li>联合特征码：由在被感染文件中必须出现的字符串集组成。</li>
<li>序列特征码：由在被感染文件中必须出现的有序字符串列表组成</li>
<li>概率特征码：由阈值和字符串-评分对组成。如果文件中存在的字符串的评分总和大于阈值，则认为被感染。</li>
</ol>
</li>
</ol>
<h1 id="恶意软件攻击"><a href="#恶意软件攻击" class="headerlink" title="恶意软件攻击"></a>恶意软件攻击</h1><h2 id="特洛伊木马"><a href="#特洛伊木马" class="headerlink" title="特洛伊木马"></a>特洛伊木马</h2><ol start="2">
<li><p>特洛伊木马：是一种恶意程序，表面上，它会执行一些有用的任务，但同时会隐形的执行具有负面后果的任务。</p>
<ol>
<li><p>组成：</p>
<ol>
<li>硬件部分：包括控制端、服务端、因特网；</li>
<li>软件部分：控制端程序、木马程序、木马配置程序；</li>
<li>具体连接部分：控制端IP、服务端IP、控制端端口、木马端口；</li>
</ol>
</li>
<li><p>木马入侵步骤：</p>
<p> 1.配置木马  2.传播木马  3.运行木马  </p>
<p> 4.信息反馈  5.建立连接  6.远程控制 </p>
</li>
</ol>
</li>
<li><p>计算机蠕虫：是一种恶意程序，不需要将自己注入其他程序就能传播自己的副本，并且不需要与人交互。</p>
<ol>
<li><p>蠕虫可以自我复制传播，但它不属于计算机病毒，因为他们不会感染其他程序。</p>
</li>
<li><p>大多数情况下，蠕虫用来删除文件或者安装后门</p>
</li>
<li><p>蠕虫的结构</p>
<img src="/计安导_img/第四章1.png" style="zoom:30%"/></li>
<li><p>设计蠕虫</p>
<img src="/计安导_img/第四章2.png" style="zoom:70%"/></li>
<li><p>蠕虫传播</p>
<ol>
<li><p>传播理论</p>
<p>经典的传播病模型</p>
<img src="/计安导_img/第四章3.png" style="zoom:70%"/>   

</li>
</ol>
<p>N: 易受感染的主机总数; I(t)：在t时刻被感染的主机数<br>S(t)：在t时刻，易被感染的主机数;I(t)+S(t)=N;β：感染率;I(t)的微分方程 ：dI/dt=βI(t)S(t);    </p>
<ol start="2">
<li>蠕虫可以利用正在运行应用程序的脆弱性（如缓冲区溢出）来进行自我传播。</li>
<li>一般通过修改注册表来隐藏自身。(同时杀毒软件也会观察一些注册表项)</li>
</ol>
</li>
</ol>
</li>
<li><p>Rootkits</p>
<ol>
<li>Rootkits最早是一组用于UNIX操作系统的工具集，黑客使用它们隐藏入侵活 动的痕迹，它能在操作系统中隐藏恶意程序。这些程序在植入系统后，rootkits 会将它们 隐藏起来，它能隐藏任何恶意程序过程、文件夹、注册码。</li>
<li>一般通过修改系统是实用程序或操作系统本身来防止检测。</li>
<li>通常使用Rootkits来隐藏其他恶意软件的恶意行为（在进程控制器中删除进程的显示，删除文件浏览器中文件的显示）</li>
</ol>
</li>
<li><p>恶意软件僵尸</p>
<ol>
<li>僵尸是一种外部控制以执行恶意攻击的计算机，通常作为僵尸网络的一部分。</li>
</ol>
</li>
</ol>
<h2 id="入侵隐私软件"><a href="#入侵隐私软件" class="headerlink" title="入侵隐私软件"></a>入侵隐私软件</h2><ol>
<li>包括广告软件、间谍软件</li>
</ol>
<h2 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h2><ol>
<li><p>病毒签名：一个签名是一个病毒指纹</p>
<ol>
<li>扫描将分析的对象与签名数据库进行比较。如果文件中包含签名，则文件被感染。</li>
</ol>
</li>
<li><p>黑/白名单</p>
<ol>
<li>维护加密哈希数据库<br> （1）操作系统文件 （2）热门应用程序<br> （3）已知被感染的文件</li>
<li>需要保护数据库的完整性</li>
</ol>
</li>
<li><p>启发式分析</p>
<ol>
<li>用于识别新的和“零日”恶意软件 </li>
<li>步骤<ol>
<li>代码分析：根据说明防病毒软件可以确定该程序是否是恶意的。</li>
<li>执行仿真：在隔离的仿真环境中执行代码，并监控目标文件所采取的操作，如果操作有害，则认为其为病毒。</li>
<li>启发式方法可以触发错误警报</li>
</ol>
</li>
</ol>
</li>
<li><p>隔离：将可疑文件隔离在隔离文件夹中。</p>
<ol>
<li>可疑文件未被删除，最终可以由用户决定何使删除</li>
<li>只能通过防病毒程序与隔离区中的文件交互。</li>
<li>隔离区的文件是无害的，因为它是加密的</li>
<li>隔离技术的细节是保密的</li>
</ol>
</li>
<li><p>静态分析与动态分析</p>
 <img src="/计安导_img/第四章4.png" style="zoom:70%"/>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导第5章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC5%E7%AB%A0/"
    >计安导第5章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC5%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.494Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="网络基本概念"><a href="#网络基本概念" class="headerlink" title="网络基本概念"></a>网络基本概念</h1><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><ol>
<li>OSI七层模型：应用层；表示层；会话层；传输层；网络层；链路层；物理层</li>
<li>TCP/IP五层模型：应用层；传输层；网络层；数据链路层；物理层</li>
</ol>
<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><ol>
<li><p>物理层</p>
<ol>
<li>其任务是以尽力服务为基础，在网络节点之间传输实际的比特位。</li>
<li>规定通信设备的机械的、电气的、功能的和过程的特性，用以建 立、维护和拆除物理链路连接。</li>
</ol>
</li>
<li><p>链路层</p>
<ol>
<li>其任务是在网络节点对间或局域网节点间传输数据并检测物理层出现的差错。</li>
<li>该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据 的检错、重发等。</li>
</ol>
</li>
<li><p>网络层</p>
<ol>
<li>其任务是以尽力服务为基础，在任意两台主机之间传送数据包。就是选择合适的网间路由和交换结点， 确保数据及 时传送。</li>
<li>网络层将数据链路层提供的帧组成数据包，包中封装有网络层包 头，其中含有逻辑地址信息：源站点和目的站点地址的网络地址。</li>
</ol>
</li>
<li><p>传输层</p>
<ol>
<li>其任务是基于IP地址和端口，支持应用程序之间的通信与连接。</li>
<li>传输层为上层提供端到端（最终用户到最终用户）的透明的、可 靠的数据传输服务。所谓透明的传输是指在通信过程中传输层对 上层屏蔽了通信传输系统的具体细节。</li>
</ol>
</li>
<li><p>应用层</p>
<ol>
<li>其任务是以传输层提供的服务为基础，提供协议来支持互联网上的有用的功能。</li>
<li>常用协议有FTP、TELNET、DNS、SMTP、POP3。</li>
</ol>
</li>
</ol>
<h2 id="网络与安全"><a href="#网络与安全" class="headerlink" title="网络与安全"></a>网络与安全</h2><h3 id="与计算机安全目标-CIA"><a href="#与计算机安全目标-CIA" class="headerlink" title="与计算机安全目标 CIA"></a>与计算机安全目标 CIA</h3><ol>
<li>机密性：网络协议的任何分层中，都没有要求传输数据的机密性。 需要修订相关协议来完成机密性。可以在应用层进行加密协议的 设计，也可以在网络层。</li>
<li>完整性：封装的数据包中的头和尾部都有简单的校验和，以检查 传输数据是否有改变。但这些校验和不是密码学意义下安全的， 因此不能提供计算机安全层面的完整性。</li>
<li>可用性：网络协议设计之初主要考虑的是节点发生故障时如何保 证可用性，并未考虑攻击者存在时的情形。如拒绝服务攻击会影 响系统可用性。</li>
</ol>
<h3 id="与计算机安全目标-3A"><a href="#与计算机安全目标-3A" class="headerlink" title="与计算机安全目标 3A"></a>与计算机安全目标 3A</h3><ol>
<li>保证：默认情况下网络中数据包可以在任何两个节点间阐述。如 果需要引入权限和策略来控制网络中的数据流，必须通过显式得 的措施来实现。</li>
<li>真实性：网络协议的数据格式中没有存储数字签名的字段，也没 有用户身份的概念。如果需要引入身份证明和数字签名，必须在 应用层完成。</li>
<li>匿名：网络协议没有用户身份的概念，因此具有内在的匿名性。 对于匿名攻击，可以通过确定用户正在使用网络中的哪台计算机 来确定。</li>
</ol>
<h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><ol>
<li>定义：以太网包括通信所使用的物理介质以及链路层的协议 标准IEEE 802.3。</li>
<li>不同帧 在以太网电缆上同时传输时会产生冲突，需要丢弃并重传冲突帧。</li>
<li>冲突处理：以太网协议使用CSMA/CD（载波监听多路访问及冲突 检测）技术来避免冲突。</li>
</ol>
<h2 id="集线器："><a href="#集线器：" class="headerlink" title="集线器："></a>集线器：</h2><ol>
<li>工作与物理层，将所有帧广播给与之相连的所有设备。</li>
<li>缺点是与集线器相连的所有设备共享带宽，传输效率低下。由于 是广播，所以数据容易被窃听。</li>
</ol>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><ol>
<li>交换机会记录连接到自己各个接口的计算机地址。之后交换机会 将接收到的帧发送到特定的接收端，而不是广播出去。</li>
</ol>
<h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><ol>
<li>MAC（Medium/Media Access Control）地址，用来表示互联网 上每一个站点的标识符，采用十六进制数表示，共六个字节。</li>
<li>MAC地址是网卡决定的，一般是固定的。但可以通过网卡的驱动 程序软件来修改MAC地址。因此，<strong>从安全角度考虑，不能使用MAC地址作为识别网络流源头的依据。</strong></li>
</ol>
<h2 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h2><ol>
<li>ARP:是一种链路层协议，其主要功能是将给定主机的网络层地址解析为主机 的硬件地址。</li>
<li>过程：主机通过发送包含目标IP地址的AARP请求到网络上所有主机，并接受返回消息，以此确定目标的物理地址。同时将映射存入ARP缓存。</li>
<li><strong>ARP欺骗</strong>：攻击者可以向某 一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主 机或到达错误的主机，这就构成了一个<strong>ARP欺骗</strong>。<ol>
<li>问题在于ARP缺乏身份认证</li>
<li><strong>解决</strong> ：<ol>
<li>检查相同的MAC是否在局域网中多次出现，以作为ARP欺骗的标志。</li>
<li>静态ARP表：通过手动指定路由器的ARP缓存来将具体的MAC地址与特定的IP地址进行绑定。问题是不够灵活。</li>
<li>更加复杂和灵活的措施：anti-arpsroof、XArp、Arpwatch，这些 程序会仔细检查所有的ARP数据包，并将数据包的内容与所存储 的ARP表项纪录做比较，以检测并防止ARP欺骗。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网际协议基本概念"><a href="#网际协议基本概念" class="headerlink" title="网际协议基本概念"></a>网际协议基本概念</h2><ol>
<li>IP：网络层协议，尽最大努力将一个数据包从源节点路由到目的 节点。节点由IP地址标识，IPv4地址为32位，IPv6地址为128位。</li>
<li>IP包路由：如果数据包的源和目的在同一个局域网内，则通过ARP进行。否则，将包传送至网关，由网关根据路由表来确定如何转发。</li>
<li>IP地址与子网掩码：例如IP地址为192.168.1.100,子网掩码为 255.255.255.0。则该地址的网络部分为192.168.1.0,主机部分为 0.0.0.100.</li>
<li>IPv4地址耗尽解决：IPv6；网络地址转换<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2></li>
<li>路由器：为数据包寻找一条最佳的传输路径。路由器中维护一张路由表，以提高效率。</li>
<li>路由操作：包括发送、丢弃、转发</li>
<li><strong>TTL</strong>:数据包的<strong>生存周期</strong>，由跳数决定，一般最大条数为255。</li>
<li>路由协议<ol>
<li>OSPF决定了如何在自治系统内路由数据包。</li>
<li>BGP决定了如何在自治系统之间路由数据包。</li>
</ol>
</li>
</ol>
<h2 id="ICMP-网际控制消息协议"><a href="#ICMP-网际控制消息协议" class="headerlink" title="ICMP 网际控制消息协议"></a>ICMP 网际控制消息协议</h2><ol>
<li>ICMP:用于在主机、路由器之间传递控制消息。<ol>
<li>包括：回显请求；回显响应；超时；目的地不可达</li>
</ol>
</li>
<li>Ping 命令：Ping发送一个ICMP<strong>回声请求</strong> 消息给目的地并报告是否收到ICMP<strong>回声应答</strong>消息。</li>
<li>traceroute命令：利用ICMP 协议定位您的计算机和目标计算机之间的所有路由器。<strong>利用ICMP超时报文，依次等增TTL，以确定路径上有哪些路由</strong></li>
</ol>
<h2 id="IP地址欺骗"><a href="#IP地址欺骗" class="headerlink" title="IP地址欺骗"></a>IP地址欺骗</h2><ol>
<li><strong>方法</strong> 恶意用户产生的IP数据包中的源IP地址是伪造的， 以便冒充其他系统或发件人的身份。源IP地址修改后， IP数据包 头部校验和也需重新计算。</li>
<li>攻击者不会收到服务器响应，因为服务器会将数据包返回给具有假冒IP地址的主机。因此，攻击者不在乎响应，故可以用来Dos攻击。</li>
<li><strong>应对</strong> <ol>
<li>通过边缘路由器禁止那些源地址在域内，但实际地址在域外的数据包或源地址在域外，但是从域内向域外发的送的数据包。</li>
<li>可以通过IP追踪计数追踪数据包返回到实际源地址的路径。<h2 id="数据包嗅探"><a href="#数据包嗅探" class="headerlink" title="数据包嗅探"></a>数据包嗅探</h2></li>
</ol>
</li>
<li>Wireshark：网络数据包分析软件。使用WinpCAP作为接口，直接与网卡进行数据报文交换。此时网卡需要设置为混杂模式。<ol>
<li><strong>问题</strong> 可能泄露敏感信息。</li>
</ol>
</li>
<li><strong>解决</strong><ol>
<li>对于有线网，使用以太网交换机而不是集线器，降低数据包包嗅探的可能性。</li>
<li>检查网卡是否被设置为混杂模式。 </li>
<li>利用高层协议进行加密，比如HTTPS</li>
</ol>
</li>
</ol>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ol>
<li><p>端口号：16位，用来标识应用层不同服务。</p>
<ol>
<li>FTP:21</li>
<li>Telnet:23</li>
<li>SSMTP:25</li>
<li>HTTP:80</li>
</ol>
</li>
<li><p><strong>TCP</strong>:面向连接的、可靠的。面向 连接意味着实现会比较复杂，可靠的是指信息会完整、有序地到 达。如果数据包丢失，TCP会保证重传。 TCP是传输文件、网页 和电子邮件的首选协议。</p>
</li>
<li><p><strong>UDP</strong>：无连接的、不可靠但速度快。基于IP的语音会话(VoIP)适合于使用UDP协议。</p>
<h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2></li>
<li><p>三次握手建立连接，每个数据包都有编号。</p>
</li>
<li><p>采用<strong>累计确认</strong></p>
</li>
<li><p>流量控制使用滑动窗口协议</p>
</li>
<li><p>校验和：使用循环冗余校验(CRC)，可以检测由网络错误引发的数据不一致，但不能检测恶意篡改。</p>
</li>
<li><p>拥塞控制：拥塞会导致传输速率急剧下降和数据包的丢弃。拥塞 控制是防止流量淹没网络的一种技术，通过收集确认数据包等信 息来调整数据的传输速率，防止拥塞。</p>
<ol>
<li>慢开始与拥塞避免</li>
<li>快重传与快恢复</li>
</ol>
</li>
<li><p>TCP三次握手</p>
 <img src="/计安导_img/1.png" style="zoom:80%">

<ol>
<li>初始序列号是随机的，以<strong>防止针对预测初始序列号的攻击</strong>。</li>
</ol>
</li>
</ol>
<h2 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h2><ol>
<li>无需三次握手，允许直接发送数据包。</li>
<li>UPD提供无连接、不可靠的服务。将数据报序列中丢失数据报的工作交给应用层。</li>
<li>使用16位校验和验证数据包完整性。</li>
<li>速度远远快于TCP,用于DNS和VoIP。</li>
</ol>
<h2 id="NAT-网络地址转换"><a href="#NAT-网络地址转换" class="headerlink" title="NAT 网络地址转换"></a>NAT 网络地址转换</h2><ol>
<li>NAT允许局域网内的主机共享一个公共IP，以接入因特网。<ol>
<li>解决了IP地址不足的问题。</li>
<li>有效的避免了来自网络外部的攻击，隐藏并保护网络内部的计算机。</li>
<li>NAT路由器：公网和私网之间的网关，负责管理流入和流出的数据包。</li>
<li>NAT路由器通过维护一个查找表来实现私有IP和公有IP的地址转换。</li>
<li>使用NAT设备时，互联网的流入流量不能到达内部网络，能够阻 止来自外部网络的威胁。</li>
</ol>
</li>
</ol>
<h2 id="TCP会话劫持"><a href="#TCP会话劫持" class="headerlink" title="TCP会话劫持"></a>TCP会话劫持</h2><ol>
<li><p><strong>TCP序列号预测攻击</strong> 通过预测TCP会话的初始序列号，以建立伪造的TCP会话。之后</p>
<ol>
<li>发动拒绝服务攻击</li>
<li>向服务器发送SYN，将源IP地址伪造成受害者客户端IP。</li>
<li>在等待服务器向客户端发送响应之后，攻击者通过发送一个 ACK数据包来结束TCP握手，该数据包的序列号是预测的下一个序列号；</li>
<li>攻击者以受害客户端名义向服务器发送请求。</li>
</ol>
</li>
<li><p><strong>盲注入</strong>：在TCP序列预测攻击中使用了IP欺骗，所以攻击者无法从服务器收到任何响应。盲注入允许攻击者使用请求者的源IP地址来执行某些命令，从而破坏系统。</p>
</li>
<li><p><strong>ACK风暴</strong>：盲注入后客户端不会向服务器发送同步消息，导致不同步。此时，客户端和服务端都会向对方发送ACK消息，来告知对方需要开始使用正确的序列号。这种反复的通信称为ACK风暴。</p>
</li>
<li><p><strong>完全会话劫持</strong>：当攻击者与目标服务器或客户端在同一网段时，攻击者可以通过数据包嗅探攻击，直到建立会话时的数据包序列号，从而完全劫持会话。</p>
</li>
<li><p><strong>防范会话劫持</strong>：</p>
<ol>
<li>在IP层或者应用层使用认证和加密，如IPSec或者应用层安全协议。</li>
<li>网站应避免创建以安全身份验证措施开始，但后来切换到未加密交 换的会话，这样会产生TCP会话劫持攻击的风险。</li>
</ol>
</li>
</ol>
<h1 id="Dos攻击"><a href="#Dos攻击" class="headerlink" title="Dos攻击"></a>Dos攻击</h1><ol>
<li><strong>拒绝服务攻击</strong>亦称洪水攻击，其目的在于使目标电脑的网络或系统 资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</li>
<li><strong>分布式拒绝服务攻击</strong>：使用多台僵尸机发起攻击。</li>
<li>症状：网络异常缓慢(打开文件或访问网站)、特定网站无法访 问、无法访问任何网站、垃圾邮件的数量急剧增加、无线或有线网 络连接异常断开、长时间尝试访问网站或任何互联网服务时被拒绝、 服务器容易断线、卡顿等。</li>
</ol>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol>
<li><p>带宽消耗：</p>
<ol>
<li>ICMP洪水攻击：通过向未良好设置的路由器发送广播信息以占用系统资源 。</li>
<li>UDP洪水攻击：大量UDP数据包发送给受害系统，可能会导致带宽。</li>
<li>死亡之ping：产生超过IP协议能容忍的数据包数，可能会导致死机。</li>
<li>泪滴攻击：数据在发送前都会经过切割，每个小切割都会记录位移的信息，以 便重组。此攻击模式就是捏造位移信息，导致重组时发生问题，造成错误。</li>
</ol>
</li>
<li><p>资源消耗型</p>
<ol>
<li>SYN 洪水攻击：大量TCP SYN请求反复发送，导致系统资源耗尽。</li>
<li>LAND攻击：与SYN floods类似，会导致被攻击的机器死循环。</li>
<li>分布式HTTP洪水攻击：使用代理服务器向受害服务器发送大量貌似合法的请 求，通常使用HTTP GET。</li>
<li>僵尸网络攻击：大量被命令与控制服务器所控制的互联网主机群协同攻击。</li>
</ol>
</li>
</ol>
<h2 id="ICMP-攻击"><a href="#ICMP-攻击" class="headerlink" title="ICMP 攻击"></a>ICMP 攻击</h2><ol>
<li><strong>ping洪水攻击</strong>：通过功能强大的计算机向单个受害服务器发送大量 回显请求命令。这样受害服务器会被这些网络流量 淹没，无法响应合法的请求。</li>
<li><strong>Smurf攻击</strong>：攻击者向网络广播地址发送ICMP包，并将回复地址 设置成受害网络的广播地址，通过使用ICMP应答请求数据包来淹 没受害主机的方式进行。</li>
<li><strong>阻止Smurf攻击</strong>：<ol>
<li>管理员应该将网络中的主机和路由器配置 为忽略广播请求；</li>
<li>避免直接向广播地址转发数据包；</li>
<li>忽略 ping请求。</li>
</ol>
</li>
</ol>
<h2 id="SYN洪水攻击"><a href="#SYN洪水攻击" class="headerlink" title="SYN洪水攻击"></a>SYN洪水攻击</h2><ol>
<li><p>攻击者故意延迟或不发送握手确认。</p>
</li>
<li><p><strong>过程</strong>：</p>
<ol>
<li>假设连接发起方是A，接受方是B。A发送SYN消息给B，B反馈 SYN-ACK消息给A，使连接进入半开状态。此时B会给每个半开连 接都设一个Timer，如果超过时间还没有收到A的ACK消息，则重 新发送一次SYN-ACK消息给A，直到重试超过一定次数时才会放弃。</li>
<li>攻击方A可以控制肉鸡向B发送大量SYN消息但不响应ACK消息， 或者干脆伪造SYN消息中的Source IP，使B反馈的SYN-ACK消息 石沉大海，导致B被大量注定不能完成的半开连接占据，直到资源 耗尽，停止响应正常的连接请求。</li>
</ol>
</li>
<li><p><strong>防范</strong></p>
<ol>
<li><strong>SYN Cookie机制</strong>：在TCP服务器接收到TCP SYN包并返回TCP SYN+ACK包时，不分配专门的数据区，而是根据SYN包计算一个 cookie值。 这个cookie作为将要返回的SYN-ACK包的初始序列号。</li>
</ol>
</li>
<li><p>SYN + ACK包的32比特结构如下：</p>
<ol>
<li>前5比特是时间戳，由每分 钟按模32递增的计数器实现</li>
<li>中间3比特是编码值，表示传输段 的最大值</li>
<li>最后24比特是基于密钥k，由服务器和客户端IP地址，端口号和前面使用的时间戳计算出来的MAC值。</li>
</ol>
</li>
<li><p>当客户端返回一个ACK包时</p>
<ol>
<li>服务器首先根据其前5比特判断是否 过期；</li>
<li>服务器根据包头信息重新计算24比特的MAC值，与返回的确认序列号(初始序列号 + 1)进行对比；</li>
<li>服务器对中间3 比特进行解码，完成对SYN队列项的重构。如果验证通过，则服务 器发起TCP会话。</li>
</ol>
</li>
<li><p>Optimistic TCP ACK攻击</p>
<ol>
<li>利用TCP的拥塞控制机制。在TCP的华东窗口协议中，虽则接收ACK的增多，窗口大小增大。</li>
<li><strong>攻击</strong> 恶意客户端在没有收到SYN-ACK时，就提前发送ACK，使得服务 器增加其传输速度。如果同时针对多台服务器进行TCP ACK攻击，它会通过淹 没网络带宽资源，导致互联网范围内的拥塞。</li>
<li><strong>防御</strong> 设置对每个客户端最大流量的限制。</li>
</ol>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/8/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/10/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        John Doe
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>