<!DOCTYPE html>


<html lang="en" >


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Hexo
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

  <script type="text/javascript"
	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-北大网课" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%8C%97%E5%A4%A7%E7%BD%91%E8%AF%BE/"
    >北大网课</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%8C%97%E5%A4%A7%E7%BD%91%E8%AF%BE/" class="article-date">
  <time datetime="2020-03-30T03:00:53.091Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="哈希函数与加密体制"><a href="#哈希函数与加密体制" class="headerlink" title="哈希函数与加密体制"></a>哈希函数与加密体制</h1><ol>
<li>性质：<ol>
<li>抗碰撞性：难以人为制造哈希碰撞。</li>
<li>单向性：前提是输入空间足够大并且输入的分布比较均匀。(如果输入空间不够大，那么把输入后面拼接一个随机数再哈希)</li>
<li>puzzle friendly:比特币特有的性质。比特币区块要求计算出来的哈希值小于等于某一个阈值。</li>
<li>难以计算，但是易于验证。</li>
</ol>
</li>
<li>比特币中用的哈希函数:SHA-256</li>
<li>账户：在本地创建一个公私钥对就是一个账户。</li>
<li>非对称加密体系：公私钥。加密用公钥，解密用私钥，且加密和解密用的是用一个人的公钥和私钥。<ol>
<li>私钥保存在本地就行，公钥可以公开。</li>
<li>公钥相当于你的银行账号，私钥相当于银行密码。</li>
</ol>
</li>
<li>对称加密体系：加密解密使用同一个密钥，假设前提是存在一种安全的渠道把密钥分发给通信双方。</li>
<li>比特币系统中的公钥和私钥<ol>
<li>比特币系统中的信息都是公开的</li>
<li>所以私钥用来对交易做签名。我发起一个交易，那么我拿我的私钥进行签名，发布到区块链上，别人再用我的公钥进行验证。 </li>
</ol>
</li>
<li>以上所述的公私钥体制建立在有一个好的随机源上，同时每次签名操作也需要一个好的随机源。</li>
</ol>
<h1 id="比特币中的数据结构"><a href="#比特币中的数据结构" class="headerlink" title="比特币中的数据结构"></a>比特币中的数据结构</h1><ol>
<li><p>哈希指针：比如一个哈希指针指向一个结构体，那么这个指针里不止存它的地址还存它的哈希值。</p>
</li>
<li><p>区块链&amp;普通链表</p>
<ol>
<li><p>以哈希指针代替普通指针。</p>
</li>
<li><p>后一块的哈希指针是通过前一区块的全部内容(包括前一区块的哈希指针)计算出来的。</p>
<p> <strong>这样从最后一个区块就能知道前面的区块是否被修改。</strong></p>
<p> <strong>这样系统中的某些节点就不需要保存全部区块信息</strong></p>
</li>
<li><p>梅克尔树</p>
<img src="/Iptables_img/2.png" style="zoom:80%">        
 1. 每个区块内部的交易组织成梅克尔树的形式
 2. 区块间通过哈希指针连接在一起。 </li>
<li><p>比特币网络由轻节点和全结点构成，其中</p>
<ol>
<li>轻节点只保存区块头；当轻节点想确认某笔交易是否已经被写进区块链中：轻节点向全节点请求红色的哈希值，轻节点自己计算绿色的哈希值。最终，可以将得到的根哈希值和头部中的根哈希值相比较。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="BTC协议：比特币的共识机制"><a href="#BTC协议：比特币的共识机制" class="headerlink" title="BTC协议：比特币的共识机制"></a>BTC协议：比特币的共识机制</h1><p>比特币需要解决问题：双花；发行</p>
<h2 id="双花问题"><a href="#双花问题" class="headerlink" title="双花问题"></a>双花问题</h2><ol>
<li><p>转账：假如A要向B和C转帐</p>
<ol>
<li><p>交易需要A的签名，证明是经过A统一 的。 </p>
</li>
<li><p>需要指明A的比特币从哪来</p>
</li>
<li><p>注：比特币系统中的交易包括输入和输出两部分，输入部分要指明币的来源，输出部分要给出收款人的公钥的哈希。</p>
<img src="/Iptables_img/8.png" style="zoom:80%">

<p>注意：其中包含两种哈希指针。一种用来构成链表，另一种用来指向前面某个交易，以说明币的来源。</p>
</li>
<li><p>A需要知道B的公钥，B乃至所有节点也需要知道A的公钥，用来验证A的签名。因为怀疑网络中存在恶意节点，所以每个节点都需要亲自验证。</p>
<p> <strong>问题</strong>：A的公钥需要A自己去公布；如果某个恶意节点伪造了转账记录，用自己的私钥去签名，再公开自己的公钥说是A的公钥，那么可以转走A上钱么？</p>
<p> <strong>不</strong>，因为每个交易要去追溯币的来源，最终会追溯到币基交易，而币基交易（前面的交易）的输出正是A的哈希地址，只有当转帐中用到的公钥和这个哈希能对上，才能认为合法。</p>
</li>
<li><p><strong>注</strong>：加密是用接收者的公钥加密，接收者用自己的私钥解密。 </p>
</li>
</ol>
</li>
<li><p>区块的头部，包括</p>
<ol>
<li>比特币协议版本信息</li>
<li>指向前一个区块的指针</li>
<li>梅克尔树的根哈希值</li>
<li>挖矿的难度目标阈值（整个块头的哈希要小于等于目标阈值）</li>
<li>随机数</li>
</ol>
</li>
<li><p>分布式共识</p>
<ol>
<li>比如分布式哈希表：需要取得共识的是哈希表中包含了哪些 键值对。</li>
</ol>
</li>
<li><p>比特币的共识协议：问题出现在比特币系统中部分节点是有恶意的。</p>
<ol>
<li>最简单的，想要通过投票来判断某个节点产生的区块是否正确（区块内部的交易是否都是合法的）。但是存在一个问题，就是如何判断谁有投票资格。<ol>
<li><strong>女巫攻击</strong>：产生大量的公私钥对，极端情况下超过半数，那么他就得到了控制权。  </li>
</ol>
</li>
<li>通过<strong>算力</strong>来投票，每个节点都可以在本地组装候选区块，把他认为合法的交易放进去。然后开始算能够使得头部的哈希值小于目标阈值的随机数的值，找到了这个随机数的节点就获得了记账权，向比特币网络中发布这个区块<ol>
<li>其他节点收到这个区块后，首先验证nbits域的设置是否符合难度要求；验证头的哈希是否小于等于目标阈值。</li>
<li>然后验证body中的交易<ol>
<li>是否是合法的签名</li>
<li>以前是否被花过</li>
</ol>
</li>
<li>即使通过了前面的检查，但是该区块不是连接在最长合法链的末尾，也不接受。因为验证交易合法性时候，只去验证他所在的分支。<ol>
<li><strong>分叉攻击</strong>：通过向区块链中间插入某个区块来回滚某个已经发生的交易。<img src="/Iptables_img/13.png" style="zoom:80%"></li>
</ol>
</li>
<li>接受一个区块意味着沿着这个区块继续往下扩展。如果产生的链不是基于最长的链，那么他在该链上通过币基交易得到的比特币也是不被认可的非法交易。</li>
</ol>
</li>
</ol>
</li>
<li><p>为什么要争夺记账权？为了币基交易的比特币奖励。 </p>
</li>
<li><p><strong>总结</strong>：比特币系统中的共识是针对分布式账本内容-&gt;只有获得记账权的节点才有权力向账本里写东西，有权决定账本中的内容-&gt;获得记账权需要算力支持-&gt;比特币的投票是基于算力的。</p>
<ol>
<li>比特币的性质：puzzle friendly，即想计算出结果，没有捷径，只有一个个试。</li>
</ol>
</li>
</ol>
<h1 id="比特币系统的实现"><a href="#比特币系统的实现" class="headerlink" title="比特币系统的实现"></a>比特币系统的实现</h1><ol>
<li>比特币使用基于交易的账本模式</li>
<li>比特币系统的全节点要维护一个UTXO的数据结构（所有没被花掉的交易输出组成的集合）以检查双花问题。  </li>
<li><strong>比特币激励机制2</strong>：交易费，激励争夺记账权的节点将他人的交易打包进区块。</li>
<li>想要使哈希值低于根哈希值，一个使太正nance，另一个使调整coinbase，这样搜索空间就达到了2<sup>96。</li>
<li>求解puzzle过程<img src="/Iptables_img/14.png" style="zoom:80%">

</li>
</ol>
<p>其中tx那一串在实际上只需要梅克尔树的根哈希值即可。</p>
<h2 id="挖矿的概率分析："><a href="#挖矿的概率分析：" class="headerlink" title="挖矿的概率分析："></a>挖矿的概率分析：</h2><ol>
<li>每次挖矿的过程可以看作是一个伯努利试验。大量的伯努利实验构成一个伯努利程序。<ol>
<li>性质1：无记忆性</li>
</ol>
</li>
<li>试验次数很多，但是实验成功的概率很小的时候，可以用泊松分布来近似。</li>
<li>整个系统的出块时间是服从指数分布的，平均是10分钟。这个指数分布也是无记忆的。所以将来还要挖多少时间和过去已经挖了多少时间是没有关系的。这也保证了算力强的矿工拥有成比例的优势。</li>
</ol>
<h2 id="比特币系统的总量"><a href="#比特币系统的总量" class="headerlink" title="比特币系统的总量"></a>比特币系统的总量</h2><ol>
<li>比特币区块奖励是固定的，每个四年减半一次，所以比特币的数量会构成一个几何序列。可以计算出一共只有2100万个比特币。  </li>
</ol>
<h2 id="挖矿的意义"><a href="#挖矿的意义" class="headerlink" title="挖矿的意义"></a>挖矿的意义</h2><ol>
<li>挖矿本身并不解决什么问题，但是其算力竞争对于维护比特币系统的安全性是至关重要的。只要大部分算力是掌握在诚实节点手里，那么安全性就得以保证。</li>
</ol>
<h2 id="安全性分析："><a href="#安全性分析：" class="headerlink" title="安全性分析："></a>安全性分析：</h2><ol>
<li>恶意节点能否将别人的比特币转走：<strong>不能</strong>，无法伪造签名。如果他把交易硬写到区块链里，那么诚实的节点不会认可这个交易，因为他包含了一个非法的交易</li>
<li>恶意节点能否双花（<strong>分叉攻击</strong>）<ol>
<li>简单的防范方法是多等待几个区块（几个确认）（比特币协议中是等待6个确认），这样写入了回滚交易的区块想要使自己所在的分支成为最长合法链的难度就大大增加。</li>
</ol>
</li>
<li>恶意节点故意不包含某些交易<ol>
<li>但是问题不大，总有诚实的节点愿意将交易写入区块。即使不在这个区块里写入，也会写在下一个区块里。</li>
<li>正常的情况下，也有可能出现这种情况，因为比特币协议要求每个区块不得大于1MB。</li>
</ol>
</li>
<li>selfish mining攻击：挖到区块先不发布，攒了一堆再去发布以争夺最长合法链<ol>
<li><strong>不行</strong>：这对算力要求很大，起码要占据51%以上的算力才有一定的成功的可能性。但是话说回来，如果恶意节点占据了如此大的算力，比特币系统就崩盘了。</li>
<li><strong>出于盈利目的</strong>：如果一个节点的算力特别强，他挖到n+1个区块，之后不发布并立即开始挖第n+2个区块。等到侦听到有人挖到第n+1个区块的时候，他立刻将n+1和n+2个区块同时发布，那么他所在的链就成为了最长合法链，他得到的币基交易才是真实有效的。<ol>
<li>存在很大的风险：我们只有在假设别人挖出一个的时间里，我可以挖出两个，才能获得更大的利益。如果别人挖完第一个而我没有挖出第二个，那么我只能去碰碰运气。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="比特币网络"><a href="#比特币网络" class="headerlink" title="比特币网络"></a>比特币网络</h1><ol>
<li>比特币工作在应用层，其底层运行的是一个P2P Overlay网络，且这里的P2P网路中所有节点都是对等的。网络存在一个种子节点，可以通过它直到网络中其他节点的信息。节点之间通过TCP连接（这样有利于穿透防火墙）</li>
<li>每个节点维护一个临近节点集合(临近节点的选取是随机的，而不考虑底层拓扑结构)，消息传播采用洪范方式</li>
</ol>
<h1 id="比特币系统的挖矿难度"><a href="#比特币系统的挖矿难度" class="headerlink" title="比特币系统的挖矿难度"></a>比特币系统的挖矿难度</h1><ol>
<li>通过调整目标空间占搜索空间的比例来调整挖矿难度。</li>
<li>挖矿难度和目标阈值是成反比的。</li>
<li>为什么要维护挖矿难度：<ol>
<li>如果不调整这个难度，那么随着挖矿的人数增多，设备的进步，那么相对于网路延迟来说，生成区块的速度过快，从而导致多分叉。分叉过多对系统达成共识没有帮助，也会危害到系统的安全性。</li>
<li>回顾分叉攻击：我们只有在假设大部分的算力都掌握在诚实的矿工手里的时候才能避免。如果出现多分叉，那么算力被分散，被分叉攻击的可能性大大增加。</li>
</ol>
</li>
<li>比特币系统规定每个2016个区块调整一次，大约14天一次。且增大和减小都有要求，增大不会一次性增大超过4倍，减少也不会一次减少到1/4以上。</li>
</ol>
<h1 id="比特币挖矿"><a href="#比特币挖矿" class="headerlink" title="比特币挖矿"></a>比特币挖矿</h1><ol>
<li><p>比特币系统包括全节点和轻节点</p>
 <img src="/Iptables_img/27.png" style="zoom:80%">

<p> 全节点：</p>
<ol>
<li><p>决定沿着那条链挖下去：缺省情况下，沿着最长合法链挖下去。</p>
</li>
<li><p>出现等长分叉：选择最先听到的分叉。</p>
<img src="/Iptables_img/28.png" style="zoom:80%">

<p>轻节点：</p>
</li>
<li><p>只能检测合法链，但是不知道哪个是最长合法链。</p>
</li>
<li><p>轻节点假设矿工是有理智的，不会沿着非法的链挖下去。</p>
</li>
<li><p>轻节点在挖矿过程中，如果监听到别的节点已经挖出了新的区块，那么它只能放弃已有的区块。因为梅克尔树的跟哈希值和组成链的哈希指针都发生了变化。尽管如此，这并不可惜，因为挖矿具有无记忆性，成功的概率是没区别的。</p>
</li>
</ol>
</li>
<li><p>比特币的安全性保障</p>
<ol>
<li>由密码学提供：无法伪造的私钥签名。这个的前提是比特币网络中大多数节点都是好的，不会接受不合法的交易。</li>
<li>由比特币的共识机制提供</li>
</ol>
</li>
<li><p>矿石：使得51%以上的攻击变得容易。</p>
</li>
<li><p>矿石可发动的攻击：</p>
<ol>
<li>分叉攻击：</li>
<li>Boycott：比如想封锁A账户，可以在任何包含A的交易的区块被发布之后，立刻组装新的不包含A 的交易的区块，并经可能是新区块所在链变为最长合法链。</li>
</ol>
</li>
</ol>
<h1 id="比特币分叉"><a href="#比特币分叉" class="headerlink" title="比特币分叉"></a>比特币分叉</h1><ol>
<li>state fork:两个节点几乎同时挖到了区块。</li>
<li>forking attack（deliberate fork）</li>
<li>protocal fork:由于比特币协议修改导致的分叉<ol>
<li>硬分叉：这样的分叉是永久的，只要有算力不更新软件就存在。</li>
<li>软分叉：临时性的分叉</li>
</ol>
</li>
</ol>
<h1 id="比特币的匿名性"><a href="#比特币的匿名性" class="headerlink" title="比特币的匿名性"></a>比特币的匿名性</h1><ol>
<li><p>假的匿名，类似于化名不是绝对的。而且比特币的账本是完全公开的，对匿名性一种挑战。</p>
</li>
<li><p>实际上不同的地址可能被关联在一起。通过推理出来。</p>
</li>
<li><p>如果交易只在区块链内，则不会泄漏。但是一旦和实体世界发生关联，那么就可能泄漏隐私，具体在：</p>
<ol>
<li>比特币支付</li>
<li>资金转入转出的时候</li>
</ol>
</li>
<li><p>提高匿名性的方法</p>
<ol>
<li>首先要实现网络层的匿名性：采用多路径转发的方法。</li>
<li>混合币</li>
</ol>
</li>
<li><p>保护匿名性很难的原因：（1）区块链是公开的（2）区块链具有不可修改性，一旦某一个交易暴露了身份，影响会是永久的。</p>
</li>
</ol>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><h2 id="哈希指针"><a href="#哈希指针" class="headerlink" title="哈希指针"></a>哈希指针</h2><ol>
<li>实际上比特币系统只有哈希没有指针。在全节点中,所有的区块是以levelDB这种键值对数据来存储,其中key为哈希值,value为区块内容。</li>
</ol>
<h2 id="区块恋"><a href="#区块恋" class="headerlink" title="区块恋"></a>区块恋</h2><ol>
<li>这样会严重影响私钥的安全性，因为私钥长度变短时，暴力破解的搜索空间大大降低。</li>
<li>所以应该用多重签名，其中每个私钥都是独立产生的。</li>
<li>如果两个人分手，那么所有的币都会被存在UTXO中。</li>
</ol>
<h2 id="分布式共识"><a href="#分布式共识" class="headerlink" title="分布式共识"></a>分布式共识</h2><ol>
<li>实际上比特币并没有达成真正意义的共识。随时可能被推翻。</li>
</ol>
<h2 id="比特币的稀缺性"><a href="#比特币的稀缺性" class="headerlink" title="比特币的稀缺性"></a>比特币的稀缺性</h2><ol>
<li>总量一定的东西并不适用于做货币。因为随着社会财富总值的增长，每单位该种货币就变得越来越值钱，先买的人就越来越富，后面的人就永远也赶不上。就像房地产。</li>
</ol>
<h1 id="以太坊概述"><a href="#以太坊概述" class="headerlink" title="以太坊概述"></a>以太坊概述</h1><ol>
<li>memory hard mining puzzle</li>
<li>以后想权益证明代替工作量证明，用类似于股权投票的方式。</li>
<li>智能合约：去中心化合约。加入参与方来自世界各地，那么手段维持合约的有效性就很困难，所以考虑写成程序，写进区块链。</li>
</ol>
<h1 id="以太坊中的账户"><a href="#以太坊中的账户" class="headerlink" title="以太坊中的账户"></a>以太坊中的账户</h1><ol>
<li>BTC中需要统计所有的UTXO。</li>
<li>账户天然的防护了双花问题。但是存在重放攻击。</li>
</ol>
<h2 id="重放攻击："><a href="#重放攻击：" class="headerlink" title="重放攻击："></a>重放攻击：</h2><ol>
<li>假设A给B转了一次帐，广播过一次，之后B又向网络广播这次交易。那么网络中的其他节点就会认为A又向B转账了一次。</li>
<li><strong>解决</strong>：多维护一个交易次数的属性，在签名的保护下一起发布出去。系统中的全节点维护这个交易次数值。假设A-&gt;B是第20次，那么全节点认为下次来的应该是第21，那么即使B重放，也不行。</li>
</ol>
<h2 id="外部账户"><a href="#外部账户" class="headerlink" title="外部账户"></a>外部账户</h2><ol>
<li>由公私钥控制，包括账户余额和交易次数。</li>
</ol>
<h2 id="合约账户"><a href="#合约账户" class="headerlink" title="合约账户"></a>合约账户</h2><ol>
<li>不是由公私钥对控制，也有nonce值，用来标识调用别的合约的次数。还有code，storage。但是合约账户不能主动发起交易。</li>
</ol>
<h2 id="为什么有合约"><a href="#为什么有合约" class="headerlink" title="为什么有合约"></a>为什么有合约</h2><ol>
<li>为了支持智能合约，要求参与者有相对稳定的身份。</li>
</ol>
<h1 id="以太坊状态树"><a href="#以太坊状态树" class="headerlink" title="以太坊状态树"></a>以太坊状态树</h1><p>目的是建立一个账户到状态的映射。以太坊的账户为160b，状态包括余额、交易次数（代码，存储）。</p>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><ol>
<li><p>优点：</p>
<ol>
<li>每个节点的分叉数目取决于取值范围。</li>
<li>查找效率取决于键的长度。</li>
<li>插入顺序不一样，得到的结构也一样。</li>
<li>更新局部性很好，每个区块对应的账户很少，伊这种结构不需要管别的分支</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>存储浪费</li>
<li>查找效率与深度有关</li>
</ol>
</li>
</ol>
<h2 id="Patricia-tree"><a href="#Patricia-tree" class="headerlink" title="Patricia tree"></a>Patricia tree</h2><ol>
<li>是路径压缩的trie树。键值分布稀疏的时候比较好。</li>
</ol>
<h2 id="MPT-Merkle-Partricia-Tree"><a href="#MPT-Merkle-Partricia-Tree" class="headerlink" title="MPT Merkle Partricia Tree"></a>MPT Merkle Partricia Tree</h2><ol>
<li>路径压缩加路径压缩</li>
<li>优点：<ol>
<li>放篡改</li>
<li>可以证明账户上的余额。 </li>
<li>还可以证明某个键值是不存在的。</li>
</ol>
</li>
</ol>
<h2 id="Modified-MPT"><a href="#Modified-MPT" class="headerlink" title="Modified MPT"></a>Modified MPT</h2><ol>
<li>以太坊的结构是一颗大的MPT包含很多小的MPT，每一个合约账户就是一颗小的MPT</li>
<li>系统中的全节点维护的不是一颗MPT，而是每产生一个新的区块就新建一颗MPT,这些树中大部分的节点是共享的，只有少数更新的节点要新建分支。</li>
<li>保留历史状态是因为可能需要回滚交易，比如分叉的时候。以太坊由于智能合约的出现，所以很难去反向推算前一个状态，所以要保存。</li>
<li>状态树中保存的是键值对，地址作为key。而value要首先经过序列化之后再存储，大致理解为变成字节数组。</li>
</ol>
<h1 id="以太坊数据结构"><a href="#以太坊数据结构" class="headerlink" title="以太坊数据结构"></a>以太坊数据结构</h1><h2 id="交易树–也是一种MPT"><a href="#交易树–也是一种MPT" class="headerlink" title="交易树–也是一种MPT"></a>交易树–也是一种MPT</h2><ol>
<li>区块中的交易形成一颗交易树</li>
</ol>
<h2 id="收据树–也是一种MPT"><a href="#收据树–也是一种MPT" class="headerlink" title="收据树–也是一种MPT"></a>收据树–也是一种MPT</h2><ol>
<li>每个交易执行完，会形成一颗收据树，记录这个交易的相关信息。交易树和收据树上的节点是一一对应的。利于快速查找执行的结果。</li>
<li>每个区块的交易树和收据树都是独立的。他们发布的交易本身我们也认为是独立的。</li>
</ol>
<h2 id="bloom-filter"><a href="#bloom-filter" class="headerlink" title="bloom filter"></a>bloom filter</h2><ol>
<li>为了在大的集合中进行查找，以支持复杂的查询操作。</li>
<li>一般的扫描存在存储问题和查找效率问题。</li>
<li>将每个元素取一个哈希，形成一个向量，其中某位为1代表该对应该哈希值的元素存在，这个向量称为摘要。</li>
<li>不支持删除操作。 </li>
<li>作用：加入要查找过去十天发生的和某个智能合约相关的交易。首先，查找区块块头的bloom filter，看哪个块头的bloom filter里有我要的类型。如果某个块头里有，在去找对应收据树里的bf,看看哪个有。有的再去仔细查看。</li>
</ol>
<h2 id="以太坊的运行过程"><a href="#以太坊的运行过程" class="headerlink" title="以太坊的运行过程"></a>以太坊的运行过程</h2><p>看成是交易驱动的状态机。状态是所有账户的状态；交易每次发布区块包含的交易，这些交易会驱动从当前的状态转移到下一个状态。 </p>
<h1 id="GHOST协议–利于出现分叉后及时合并"><a href="#GHOST协议–利于出现分叉后及时合并" class="headerlink" title="GHOST协议–利于出现分叉后及时合并"></a>GHOST协议–利于出现分叉后及时合并</h1><ol>
<li><p>没有竞争称为最长合法链上的区块也会发放一定的出块奖励（7/8）称为叔父区块。下一个区块要包含所有叔父区块，同时得到1/32个出块奖励的额外报酬。最多可以包含两个叔父区块。</p>
</li>
<li><p>不在最长合法链上的区块都是叔父区块，即使是爷爷啥的。  </p>
</li>
<li><p>为了防止在挖矿难度较低的时候产生叔父而不当获利，最多7代。叔父区块中的交易不执行，所以也不检查交易合法性，只检查是否符合挖矿难度。</p>
 <img src="/Iptables_img/52.png" style="zoom:80%">    </li>
<li><p>GHOST机制是为了解决临时性的分叉。</p>
</li>
</ol>
<h1 id="以太坊的挖矿算法"><a href="#以太坊的挖矿算法" class="headerlink" title="以太坊的挖矿算法"></a>以太坊的挖矿算法</h1><ol>
<li>求解很难，验证简单、</li>
<li>回避ASIC芯片。</li>
</ol>
<h2 id="Lite币"><a href="#Lite币" class="headerlink" title="Lite币"></a>Lite币</h2><ol>
<li>基于Scrypt加密，需要大内存来保存这个数组。</li>
<li>但是设定小了，只有128K。</li>
</ol>
<h2 id="以太币"><a href="#以太币" class="headerlink" title="以太币"></a>以太币</h2><ol>
<li>有两个数据集，初始一个是16M的cache，另一个是1G的DAG。DAG从cache中生成出来。轻节点只需要保存cache便于验证。</li>
<li>cache形成 ：首先从一个种子节点开始依次去哈希来填充数组。</li>
<li>DAG形成：从cache里随机读一个数，然后进行哈希计算，得到下一个要读取的数的位置。然后用cache中这个位置的数和当前的哈希值再计算出一个哈希值，反复迭代256次，将最终得到的数填充到数组的第一个位置。</li>
<li>挖矿的时候，先根据块头和nonce值计算一个哈希，这个哈希映射到数组中的某一个位置。通过这个位置和相邻位置的元素进行运算得到下一个位置，循环64次，最后得到的哈希值与目标阈值比较，看一下是否成功。不成功则换下一个nonce。</li>
<li>生成cache的seed每隔3w个区块会变一下。同时cache和DAG大小会增加1/128。 </li>
</ol>
<h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><ol>
<li>外部账户可以调用合约，一个合约可以调用另一个合约。只有外部账户可以调用。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-区块链目录" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9B%AE%E5%BD%95/"
    >区块链目录</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9B%AE%E5%BD%95/" class="article-date">
  <time datetime="2020-03-30T03:00:51.066Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="北大网课"><a href="#北大网课" class="headerlink" title="北大网课"></a><a href="/2020/03/30/北大网课">北大网课</a></h2><h2 id="区块链自学"><a href="#区块链自学" class="headerlink" title="区块链自学"></a><a href="/2020/03/30/区块链">区块链自学</a></h2><h2 id="区块链小论文"><a href="#区块链小论文" class="headerlink" title="区块链小论文"></a><a href="/2020/03/30/区块链小论文">区块链小论文</a></h2>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-iptables" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/iptables/"
    >iptables</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/iptables/" class="article-date">
  <time datetime="2020-03-30T02:51:26.428Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="iptables-基础"><a href="#iptables-基础" class="headerlink" title="iptables 基础"></a>iptables 基础</h1><p>iptables本身不是防火墙，可以理解为一个客户端代理，通过iptables来设定规则，最终运行在netfilter框架下。</p>
<h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h2><p>当客户端访问服务器的时候，客户端发送报文到网卡，通过内核的TCP协议传输到用户空间的web服务器中，而此时，客户端报文的目标终点为web服务所监听的套接字。当web服务需要相应客户端请求时，web服务发出的响应报文的目标终点为客户端。netfilter作为内核的一部分，所有进出的报文都要通过这些关卡。于是，就有了input和output关卡，在iptables中，这些关卡称为链。除了通往本机的链，还有PREROURING(路由前)、FORWARD(转发)、POSTROUTING(路由后)。</p>
<img src="/Iptables_img/29.png" style="zoom:80%">

<h2 id="链"><a href="#链" class="headerlink" title="链"></a>链</h2><ol>
<li>防火墙的功能是对经过的报文匹配规则，然后执行对应的动作。对于每个关卡，都不止一条规则，故称为链。</li>
</ol>
<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><ol>
<li>表：我们把具有相同功能的规则的集合叫做表。</li>
<li>iptables预定义了四种表<ol>
<li>filter表：负责过滤功能，防火墙；内核模块：iptables_filter</li>
<li>nat表：负责网络地址转换功能。内核模块：iptable_nat</li>
<li>mangle表：拆解报文，做出修改，并重新封装的功能；iptables_mangle</li>
<li>raw表：关闭nat表上启用的连接追踪机制；iptable_raw<br>也就是说，我们自定义的所有规则都是这四种分类中的规则。</li>
</ol>
</li>
</ol>
<h2 id="表链关系"><a href="#表链关系" class="headerlink" title="表链关系"></a>表链关系</h2><ol>
<li>prerouting：规则存在于raw,mangle,nat.</li>
<li>INPUT:规则存在于mangle,filter.</li>
<li>FORWARD:规则存在于mangle,filter.</li>
<li>OUTPUT:规则存在于raw,mangle,nat,filter.</li>
<li>POSTROUTING:规则存在于mangle,nat.</li>
<li>实际使用中，往往以表为入口，对规则进行定义。</li>
<li>表链关系：<img src="/Iptables_img/31.png" style="zoom:80%"></li>
<li>表的优先级：raw&gt;mangle&gt;nat&gt;filter</li>
<li>我们也可以在某个表中创建自定义链，将针对某个应用程序所设置的规则放置在这个自定义链中，但是自定义链接不能直接使用，之恶能被某个默认的链当作动作去调用才能起作用。</li>
</ol>
<h2 id="数据经过防火墙的流程"><a href="#数据经过防火墙的流程" class="headerlink" title="数据经过防火墙的流程"></a>数据经过防火墙的流程</h2><img src="/Iptables_img/32.png" style="zoom:80%">

<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ol>
<li>规则：根据指定的匹配条件来尝试匹配每个流经此处的报文，一旦匹配成功，则由规则后面指定的处理动作进行处理。</li>
</ol>
<h1 id="iptables实际操作之规则查询"><a href="#iptables实际操作之规则查询" class="headerlink" title="iptables实际操作之规则查询"></a>iptables实际操作之规则查询</h1><ol>
<li><strong>命令</strong> iptables -t filter -L<ol>
<li>-t指定要操作的表</li>
<li>-L列出规则</li>
</ol>
</li>
<li>如果我们要定义过滤规则，那么我们会在filter中定义，但是具体在那条链上实现，取决于我们的工作场景。</li>
<li>举例：<ol>
<li>我们需要禁止某个IP地址访问我们的主机，我们则需要在INPUT链上定义规则</li>
</ol>
</li>
<li><strong>命令</strong> iptables -t filter -vL INPUT 查看详细信息<ol>
<li>pkts 对应规则匹配到的报文的个数</li>
<li>bytes 对应匹配到的报文包的大小总和。</li>
<li>target 往往表示规则对应的动作，即匹配成功后需要采取的措施。</li>
<li>prot 表示规则对应的协议，是否只针对某些协议应用次规则。</li>
<li>opt 表示规则对应的选项。</li>
<li>in 表示数据包由哪个接口流入，我们可以设置通过哪块网卡流入的报文需要匹配当前规则。</li>
<li>out 表示数据包由哪个接口流出，我们可以设置通过哪块网卡流出的报文需要匹配当前规则。</li>
<li>source 表示规则对应的源地址，可以时一个IP，也可以是一个网段。</li>
<li>destination 表示规则对应的目的地址。可以是一个IP也可以是一个网段。</li>
</ol>
</li>
<li><strong>命令</strong> iptables -nvl INPUT不进行名称反解。</li>
<li><strong>命令</strong> iptables –line-number -nvL INPUT</li>
<li>命令小节<img src="/Iptables_img/33.png" style="zoom:80%">

</li>
</ol>
<img src="/Iptables_img/34.png" style="zoom:80%">

<h1 id="iptables规则管理"><a href="#iptables规则管理" class="headerlink" title="iptables规则管理"></a>iptables规则管理</h1><ol>
<li><strong>命令</strong> iptables -F INPUT 清空规则</li>
<li><strong>如果报文已经被前面的规则匹配到，iptables则会对报文执行相应动作，即使后面的规则也能匹配到当前报文，也没有机会对报文执行修改</strong></li>
<li>使用修改指令的时候，如果我拒绝某个源地址发来的包，但是修改时又没有指定对应的源地址，那么源地址会自动编程0.0.0.0，如果是为远程服务器配置iptables，那么正在使用的链接也会和中断。</li>
<li>REGECT&amp;DROP<ol>
<li>DROP丢弃而不返回，ping命令所在机器永远得不到回应</li>
<li>REGECT 返回拒绝，通知目的端不可达。</li>
</ol>
</li>
<li><img src="/Iptables_img/35.png" style="zoom:80%">

</li>
</ol>
<img src="/Iptables_img/36.png" style="zoom:80%">

<img src="/Iptables_img/37.png" style="zoom:80%">

<img src="/Iptables_img/38.png" style="zoom:80%">

<h1 id="匹配条件总结"><a href="#匹配条件总结" class="headerlink" title="匹配条件总结"></a>匹配条件总结</h1><h2 id="s参数：匹配源地址"><a href="#s参数：匹配源地址" class="headerlink" title="-s参数：匹配源地址"></a>-s参数：匹配源地址</h2><ol>
<li>可以是由逗号隔开的多个参数</li>
<li>可以通过指定子网掩码来指定某个网段</li>
<li>可以对某个地址取反，达到白（黑）名单的目的。但是存在问题，比如链上规则设定为不是某个源即进行-j操作；如果是，则继续匹配其他条件（都不匹配，则执行默认操作）。</li>
</ol>
<h2 id="d参数：匹配目的地址"><a href="#d参数：匹配目的地址" class="headerlink" title="-d参数：匹配目的地址"></a>-d参数：匹配目的地址</h2><p><strong>取反操作与同时指定多个IP的操作不能同时使用</strong></p>
<h2 id="p参数：匹配协议类型"><a href="#p参数：匹配协议类型" class="headerlink" title="-p参数：匹配协议类型"></a>-p参数：匹配协议类型</h2><ol>
<li><p>例如拒绝tcp请求 </p>
<p> iptables -I INPUT -s 192.168.1.146 -d 192.168.1.156 -p tcp -j REJECT</p>
<p> 使用ssh链接测试</p>
</li>
<li><p>-p支持的协议类型：</p>
<ol>
<li>tcp,udp,udplite,icmp,icmpv6,esp,ah,sctp,mh</li>
<li>缺省形况下，默认为-p all</li>
</ol>
</li>
</ol>
<h2 id="i参数：匹配流入的网卡-o匹配流出的网卡"><a href="#i参数：匹配流入的网卡-o匹配流出的网卡" class="headerlink" title="-i参数：匹配流入的网卡 -o匹配流出的网卡"></a>-i参数：匹配流入的网卡 -o匹配流出的网卡</h2><ol>
<li>通过ifconfig查询</li>
<li>-i 网卡名 来指定匹配</li>
<li>只能用来判断流入的包，故用于<ol>
<li>ROUTING 链</li>
<li>INPUT 链</li>
<li><strong>FORWARD 链</strong></li>
</ol>
</li>
<li>-o 用于匹配报文从哪个网卡流出，用于<ol>
<li>OUTPUT 链</li>
<li><strong>FORWARD 链</strong></li>
<li>POSTROUTING 链</li>
</ol>
</li>
</ol>
<h2 id="dport-扩展目的端口"><a href="#dport-扩展目的端口" class="headerlink" title="-dport 扩展目的端口"></a>-dport 扩展目的端口</h2><ol>
<li>dport(destination-port)<ol>
<li><strong>使用dport之前必须先使用-p选项</strong></li>
<li>之后使用-m指定扩展模块，缺省情况下，默认为于-p指定的协议同名。</li>
<li>最后，使用-dport指定目标端口</li>
</ol>
</li>
</ol>
<h2 id="sport-匹配源端口"><a href="#sport-匹配源端口" class="headerlink" title="-sport:匹配源端口"></a>-sport:匹配源端口</h2><ol>
<li>不管是sport还是dport都可以指定端口范围，如22：25</li>
<li>multiport模块：<ol>
<li>若要指定离散的端口，需要借助multiport模块。端口号间以逗号隔开。并且，这些端口中可以包含连续端口号。</li>
<li><strong>只有tcp,udp可以使用</strong></li>
</ol>
</li>
</ol>
<p>##<a href=""http://www.zsythink.net/archives/1544"">基本匹配条件总结</a></p>
<p>#<a href=""http://www.zsythink.net/archives/1564"">常用扩展模块</a></p>
<h2 id="iprange-扩展模块"><a href="#iprange-扩展模块" class="headerlink" title="iprange 扩展模块"></a>iprange 扩展模块</h2><ol>
<li>用于指定一系列连续的ip。包括–src-range,–dst-range。</li>
</ol>
<h2 id="string-扩展模块"><a href="#string-扩展模块" class="headerlink" title="string 扩展模块"></a>string 扩展模块</h2><ol>
<li><p>用于匹配含有某一个字符串的报文。</p>
<p> iptables -t filter -I INPUT -m string –algo bm –string “OOXX” -j REJECT</p>
<ol>
<li>-m 用于指定模块</li>
<li>–algo bm 表示用bm算法匹配。</li>
</ol>
</li>
</ol>
<h2 id="time-扩展模块"><a href="#time-扩展模块" class="headerlink" title="time 扩展模块"></a>time 扩展模块</h2><ol>
<li><p>用于限制时间</p>
<p> iptables -t filter -I OUTPUT -p tcp -dport 80 -m time –timestart 09:00:00 –timestop 18:00:00 -j REJECT</p>
<ol>
<li>可以使用timestart 和timestop 来指定起止时间。也可以通过weekdays 来指定某一天,多个天之间通过逗号隔开。也可以结合使用。</li>
<li>此外还有monthdays,datestart和datestop</li>
</ol>
</li>
</ol>
<h2 id="connlimit-扩展模块"><a href="#connlimit-扩展模块" class="headerlink" title="connlimit 扩展模块"></a>connlimit 扩展模块</h2><ol>
<li><p>用于限制每个IP地址同时连接到server的数量。</p>
<p> iptables -I INPUT -p tcp –dport 803 -m connlimit –connlimit-above 2 -j REJECT</p>
<ol>
<li>限制每个IP最多只能让两个ssh连接到server。</li>
</ol>
</li>
<li><p>其实还可以配合–connlimit-mask去限制某类网段的链接数量</p>
<p> iptables -I INPUT -p tcp –dport 22 -m conlimit –connlimit-above 2 –connlimit-mask 24 -j REJECT</p>
</li>
</ol>
<h2 id="limit-扩展模块"><a href="#limit-扩展模块" class="headerlink" title="limit 扩展模块"></a>limit 扩展模块</h2><p>对报文到达速率进行限制，即限制单位时间内流入的包的数量。</p>
<ol>
<li>iptables -t filter -I INPUT -p icmp -m limit –limit 10/minute -j ACCEPT</li>
</ol>
<p>表示每分钟最多放10个包，相当于每6秒最多放一个包。<br>然而这样遂率并没有变，是因为第六秒的报文确实被策略匹配到了，于是执行了放行操作，但是6秒钱的报文没有被匹配到，于是自动执行默认策略，也是放行。<br><strong>修改</strong>：iptables -t filter -A INPUT -p icmp -j REJECT</p>
<ol start="2">
<li><p>–limit-burst 选项用于指明空闲时放行包的数量，默认为5.</p>
</li>
<li><p>limit模块工作原理：令牌桶算法<br> 想象有一个木桶，里面放了5块令牌，且目前这个桶中最多只能存放5个令牌。所有报文想要出关入关，都必须持有木桶中的令牌，这个木桶可以每6秒生成一个新的令牌。此时，如果桶已经满了，那么新生成的令牌就被丢弃。假设现在有五个报文想要进入，那么这5个报文就会去桶中找令牌，正好一人一个。此时，如果再有令牌想要进入，则没有对应的令牌可以使用。如果长时间没有人使用令牌，令牌桶中又出现了5枚令牌，也就是所谓的空闲。</p>
</li>
</ol>
<p>#<a href=""http://www.zsythink.net/archives/1578"">iptables 扩展匹配条件 -tcp-flags</a></p>
<p>用于匹配tcp头部的标志位，然后根据标识位的实时情况进行实时访问控制功能。</p>
<ol>
<li><p>iptables -t filter -I INPUT -p tcp -m tcp –dport 22 –tcp-flags SYN,ACK,FIN,RST,URG,PSH SYN -j REJECT</p>
<ol>
<li>SYN,ACK,FIN,RST,URG,PSH 表示需要匹配报文tcp头部的标志位列表</li>
<li>第二个SYN处表示，要求为1的标志位列表。不出现的标志位必须为0。</li>
<li>这条命令是拒绝tcp第一次链接。</li>
<li>可以使用-syn代替这一段。</li>
</ol>
</li>
<li><p>iptables -t filter -I INPUT -p tcp -m tcp –dport 22 –tcp-flags SYN,ACK,FIN,RST,URG,PSH SYN，ACK -j REJECT</p>
</li>
</ol>
<p>#<a href=""http://www.zsythink.net/archives/1588"">iptables udp扩展与icmp扩展</a></p>
<h2 id="udp-扩展"><a href="#udp-扩展" class="headerlink" title="udp 扩展"></a>udp 扩展</h2><ol>
<li>iptables -t filter -I INPUT -p udp -m udp –dport 137 -j ACCEPT<ol>
<li>137为端口号，samba服务的端口为137，138</li>
<li>可以指定连续的端口号 137:157</li>
</ol>
</li>
</ol>
<h2 id="icmp-扩展"><a href="#icmp-扩展" class="headerlink" title="icmp 扩展"></a>icmp 扩展</h2><img src="/Iptables_img/51.png" style="zoom:80%">

<ol>
<li><p>可以指定匹配的类型和code</p>
<p> iptables -t filter -I INPUT -p icmp -m icmp –icmp-type3/1 -j REJECT</p>
<p> 表示拒绝主机不可达报文</p>
</li>
<li><p>还可以用icmp报文的描述名称去匹配对应类型的报文</p>
<p> iptables -t filter -I INPUT -p icmp –icmp-type “echo-request” -j REJECT</p>
</li>
</ol>
<p>#<a href=""http://www.zsythink.net/archives/1597"">iptables 扩展模块 state</a></p>
<p>当我们访问http时，需要放行80端口以便能够与服务端进行通信。进行ssh链接时，需要打开22端口。然而，这样并不安全，攻击者可以利用这些端口主动和我建立链接。使用state可以实现链接追踪功能。</p>
<h2 id="state基本概念"><a href="#state基本概念" class="headerlink" title="state基本概念"></a>state基本概念</h2><ol>
<li>连接：在state模块中，认为两台机器在你来我往的通信就算建立了连接。</li>
<li>连接状态包括：NEW,ESTABLISHED,RELATED,INVALID,UNTRACKED</li>
</ol>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ol>
<li>iptables -t filter -I INPUT -m state –state RELATED,ESTABLISHED -j ACCEPT<ol>
<li>只有回应我们的报文能够通过防火墙。</li>
</ol>
</li>
</ol>
<p>#<a href=""http://www.zsythink.net/archives/1604"">iptables的黑白名单机制</a></p>
<ol>
<li>黑名单：链中设置规则的动作为drop或reject，默认动作是ACCEPT，那么匹配到规则的报文会被拒绝。</li>
<li>白名单：默认规则是DROP，链中规则的动作是ACCEPT，则被匹配到的报文才会放行，即白名单机制。<h2 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h2></li>
</ol>
<p>#iptables -P INPUT DROP</p>
<p>#iptables -I INPUT -p tcp –dport 22 -j ACCEPT</p>
<p>#iptables -I INPUT -p tcp<br>–dport 80 -j ACCEPT</p>
<ol>
<li>注意-F选项只是将链中规则情况，此处修改了默认规则，所以即使-F也会DROP；</li>
<li><strong>改进</strong>：将链的设置保持为ACCEPT，然后将拒绝所有请求的规则放在链尾，将放行规则放在签名，这样既实现了白名单，又保证规则清空时，管理员能够连接到主机。</li>
</ol>
<p>#iptables -I INPUT -p tcp –dport 22 -j ACCEPT</p>
<p>#iptables -I INPUT -p tcp –dport 80 -j ACCEPT</p>
<p># iptables -A INPUT -j REJECT</p>
<p>#<a href=""http://www.zsythink.net/archives/1625"">iptables 自定义链</a></p>
<p>由于默认链的规则非常 多，不便于管理，所以引入自定义链。</p>
<h2 id="创建自定义链"><a href="#创建自定义链" class="headerlink" title="创建自定义链"></a>创建自定义链</h2><ol>
<li>iptables -t filter -N IN_WEB<h2 id="使用自定义链"><a href="#使用自定义链" class="headerlink" title="使用自定义链"></a>使用自定义链</h2></li>
<li>必须被默认链引用</li>
<li>iptables -I INPUT -p tcp –dport 80 -j IN WEB</li>
<li>自定义链也可以引用其他的自定义链</li>
</ol>
<h2 id="自定义链重命名"><a href="#自定义链重命名" class="headerlink" title="自定义链重命名"></a>自定义链重命名</h2><p>iptables -E IN_WEB WEB</p>
<h2 id="删除自定义链"><a href="#删除自定义链" class="headerlink" title="删除自定义链"></a>删除自定义链</h2><ol>
<li>如果被引用，则要iptables -D INPUT 1</li>
<li>如果链种含有规则，则要Iptables -t filter -F WEB</li>
<li>iptables -X WEB</li>
</ol>
<p>#<a href=""http://www.zsythink.net/archives/1663"">网络防火墙</a></p>
<ol>
<li><p>定义：处于网络入口或边缘，针对于网络入口进行防护，服务于防火墙背后的本地局域网。主要任务时过滤并转发。</p>
</li>
<li><p>涉及：INPUT,OUTPUT,FORWARD</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2></li>
<li><p>PC1：</p>
<ol>
<li>192.18.33.33</li>
<li>route add -net 192.18.22.0/24 gw 192.18.33.251</li>
</ol>
</li>
<li><p>PC2:</p>
<ol>
<li>192.18.22.22</li>
<li>route add -net 192.18.33.0/24 gw 192.18.22.251</li>
</ol>
</li>
<li><p>r1:</p>
<ol>
<li>ens33:192.18.33.251</li>
<li>ens37:192.18.22.251    <ol start="3">
<li>cat /proc/sys/net/ipv4/ip_forward 来查看是否支持转发功能。</li>
<li>每次需要echo 1 &gt; /proc/sys/net/ipv4/ip_forward来开启转发功能</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>#<a href=""http://www.zsythink.net/archives/1684"">iptables 动作总结</a></p>
<h2 id="REJECT"><a href="#REJECT" class="headerlink" title="REJECT"></a>REJECT</h2><ol>
<li>–reject-with :提示拒绝原因。包括：<ol>
<li>icmp-net-unreachable</li>
<li>icmp-host-unreachable</li>
<li>icmp-port-unreachable</li>
<li>icmp-proto-unreachable(默认)</li>
<li>icmp-net-prohibited</li>
<li>icmp-host-pro-hibited</li>
<li>icmp-admin-prohibited</li>
</ol>
</li>
</ol>
<h2 id="LOG"><a href="#LOG" class="headerlink" title="LOG"></a>LOG</h2><ol>
<li><p>LOG 可以将符合条件的报文的相关信息记录到日志中。可以在后面设置具体规则对报文进一步处理。</p>
</li>
<li><p>可以通过tail -f /var/log/messages 来查看。</p>
</li>
<li><p>–log-level 来指定日志的日志级别。包括</p>
<ol>
<li>emerg</li>
<li>alert</li>
<li>crit</li>
<li>error</li>
<li>warning</li>
<li>notice</li>
<li>info</li>
<li>debug</li>
</ol>
</li>
<li><p>–log-prefix 来给记录到的相关信息添加标签之类的信息，以区分各种记录到的报文。</p>
</li>
</ol>
<p>iptables -I INPUT -p tcp –dport 80 -m state –state NEW -j LOG –log-prefix “want-in-from-22”<br>#<a href=""http://www.zsythink.net/archives/1764"">iptables 动作总结2</a></p>
<h2 id="SNAT"><a href="#SNAT" class="headerlink" title="SNAT"></a>SNAT</h2><p>iptables -t nat -A POSTROUTING -s 192.18.0.0/16 -j SNAT –to-source 192.18.33.251</p>
<ol>
<li>其中-A 标识将snat规则添加到POSTROUTING链的末尾。POSTROUTING可以认为是报文发出的最后一个关卡。</li>
<li>-j SNAT表示对匹配到的报文进行源地址转换。</li>
<li>–to-source表示转换成这个源</li>
</ol>
<h2 id="DNAT"><a href="#DNAT" class="headerlink" title="DNAT"></a>DNAT</h2><p>按端口进行转发</p>
<ol>
<li><p>iptables -t nat -I PREROUTING -d 192.18.33.251 -p tcp –dport 801 -j DNAT –to-destination 192.18.22.22:80</p>
</li>
<li><p>注：开启端口/sbin/iptables -I INPUT -p tcp –dport 80 -j ACCEPT</p>
</li>
</ol>
<h2 id="MASQUERADE"><a href="#MASQUERADE" class="headerlink" title="MASQUERADE"></a>MASQUERADE</h2><p>动态的将源地址转换为可用的IP地址。类似于SNAT而无需指明修改成哪个IP，可以适应动态变化。</p>
<ol>
<li>iptables -t nat -I POSTROUTING -s 192.18.0.0/16 -o ens33 -j MASQUERADE</li>
</ol>
<h2 id="REDIRECT"><a href="#REDIRECT" class="headerlink" title="REDIRECT"></a>REDIRECT</h2><p>可以将本机端口进行映射。</p>
<ol>
<li>iptables -t nat -A PREROUTING -p tcp –dport 80 -j REDIRECT –to-ports 801</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Iptables实验目录" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/Iptables%E5%AE%9E%E9%AA%8C%E7%9B%AE%E5%BD%95/"
    >Iptables实验目录</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/Iptables%E5%AE%9E%E9%AA%8C%E7%9B%AE%E5%BD%95/" class="article-date">
  <time datetime="2020-03-30T02:36:52.223Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="IptablesExp基础"><a href="#IptablesExp基础" class="headerlink" title="IptablesExp基础"></a><a href="/2020/03/30/iptables">IptablesExp基础</a></h2><h2 id="实验详情见代码仓库"><a href="#实验详情见代码仓库" class="headerlink" title="实验详情见代码仓库"></a><a href="https://github.com/Cccceb/BTF.git">实验详情见代码仓库</a></h2><p>​    本次实验通过设置 iptables 规则，来实现防火墙功能。iptables 本身不是 </p>
<p>防火墙，它可以理解为一个客户端代理，通过 iptables 来设定规则，最终运行 </p>
<p>在 netfilter 框架下。 </p>
<p>​    Iptables 中有四链五表，用来过滤所有进出的报文。防火墙的功能是对经过 </p>
<p>的报文匹配规则，然后执行对应的动作。对于每个关卡，都不止一条规则，故称 </p>
<p>为链。将那些具有相同规则的集合叫做表。链包括 INPUT、OUTPU、PREROURING(路 </p>
<p>由前)、FORWARD(转发)、POSTROUTING(路由后)。同时，在 iptables 中预定义了 </p>
<p>四种表，分别是负责过滤的 filter 表、负责网络地址转换的 nat 表、负责拆解 </p>
<p>报文做出修改的 mangle 表以及关闭 nat 表上启用的连接追踪机制的 raw 表。本 </p>
<p>次实验中主要涉及了前两个表。 </p>
<p>​    通过本次实验，学习了很多关于 iptables 以及网络、安全方面的知识。我 </p>
<p>将学到的知识治理成以下三个实验内容：主机防火墙、网络防火墙、NAT 转换。 </p>
<p>在理论课的过程中，老师经常提及 Dos 攻击。所以，在学习了 socket 编程 </p>
<p>之后，用 C 语言实现了两台虚拟机之间建立 TCP 连接。最终模拟了防御 Dos 攻击 </p>
<p>的情况，形成了实验四。 </p>
<p>​    总的来说，本次实验我递进式的做了四个实验，分别是主机防火墙、网络防 </p>
<p>火墙、NAT 动作、TCP 连接与 DoS 防御。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导第2章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC2%E7%AB%A0/"
    >计安导第2章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC2%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.494Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="物理保护与攻击"><a href="#物理保护与攻击" class="headerlink" title="物理保护与攻击"></a>物理保护与攻击</h1><h2 id="物理安全"><a href="#物理安全" class="headerlink" title="物理安全"></a>物理安全</h2><ol>
<li>物理安全：泛指保护贵重物品、信息或访问受限资源 所使用的物理措施，物理安全直接影响完整性、计算 机硬件和数字信息保护。包括<ol>
<li>位置保护</li>
<li>物理入侵检测</li>
<li>硬件攻击</li>
<li>窃听</li>
<li>物理接口攻击</li>
</ol>
</li>
</ol>
<h2 id="钥匙与锁"><a href="#钥匙与锁" class="headerlink" title="钥匙与锁"></a>钥匙与锁</h2><ol>
<li>包括TSA锁，凸块锁，万能钥匙，弹子锁</li>
<li>非破坏性开锁：选取，旁路</li>
<li>40种不同的钥匙坯，7个顶部锁鞘，8个不同高度的底部锁鞘，则可能的钥匙数量是40*8<sup>7</sup><h2 id="特权升级"><a href="#特权升级" class="headerlink" title="特权升级"></a>特权升级</h2>攻击者将地权限的密钥提升为高权限的密钥</li>
</ol>
<h2 id="指纹锁相关问题"><a href="#指纹锁相关问题" class="headerlink" title="指纹锁相关问题"></a>指纹锁相关问题</h2><ol>
<li>识别率不够高</li>
<li>电池寿命问题</li>
<li>指纹锁的稳定性不高</li>
</ol>
<h2 id="测信道攻击"><a href="#测信道攻击" class="headerlink" title="测信道攻击"></a>测信道攻击</h2><p>攻击者不是试图直接绕过 安全措施，而是通过利用 其他不受安全机制保护的 漏洞绕过安全措施</p>
<h1 id="身份认证技术"><a href="#身份认证技术" class="headerlink" title="身份认证技术"></a>身份认证技术</h1><ol>
<li>包括条形码，二维码，磁条卡，智能卡，SIM卡,RFID</li>
</ol>
<h2 id="磁条卡安全"><a href="#磁条卡安全" class="headerlink" title="磁条卡安全"></a>磁条卡安全</h2><ol>
<li>问题：易于读取和复制。词条阅读器成本相对较低</li>
<li>解决：要求输入PIN</li>
</ol>
<h2 id="智能卡安全"><a href="#智能卡安全" class="headerlink" title="智能卡安全"></a>智能卡安全</h2><ol>
<li>可以提供保护所有者信息的安全认证机制，并且极难复制</li>
<li>使用加密技术加强认证的手段</li>
</ol>
<h2 id="SIM卡安全"><a href="#SIM卡安全" class="headerlink" title="SIM卡安全"></a>SIM卡安全</h2><ol>
<li>SIM卡：用于识别所有者并对相应的蜂窝网络进行身份验证</li>
<li>18位，用于硬件识别</li>
<li>128位密钥</li>
</ol>
<h2 id="GSM挑战-相应协议"><a href="#GSM挑战-相应协议" class="headerlink" title="GSM挑战-相应协议"></a>GSM挑战-相应协议</h2><p><img src="/%E8%AE%A1%E5%AE%89%E5%AF%BC_img/36.png" alt=""></p>
<ol>
<li>当手机希望加入蜂窝网络时，它连接并发送其IMSI到网络提供商拥有的 本地基站。 </li>
<li>如果IMSI匹配网络提供商的数据库中的用户记录正确，则基站将128位 随机数发送到蜂窝电话。 </li>
<li>然后，该随机数由蜂窝电话编码存储在SIM卡中，用户的密钥使用A3的 专有加密算法，从而产生发送回基站的密文</li>
<li>然后，基站使用其存储的用于用户密钥的值来执行相同的计算。 如果两 个密文匹配，则手机被认证到网络并被允许拨打和接听电话。</li>
</ol>
<h2 id="RFID"><a href="#RFID" class="headerlink" title="RFID"></a>RFID</h2><ol>
<li>必须与单独的读取器或写入器一起使用</li>
<li>所有RFID都使用密钥加密</li>
</ol>
<h2 id="生物识别技术"><a href="#生物识别技术" class="headerlink" title="生物识别技术"></a>生物识别技术</h2><ol>
<li><p>生物特征：指用于基于生物或生理特 征唯一识别信息进行的任何身份度 量。</p>
</li>
<li><p>生物识别的要求</p>
<ol>
<li>普遍性</li>
<li>独特性</li>
<li>持久性</li>
<li>可回收性：该特征应具有有效确定和量化的能力</li>
</ol>
</li>
<li><p>如指纹，虹膜，步态</p>
</li>
</ol>
<h1 id="针对计算设备的攻击"><a href="#针对计算设备的攻击" class="headerlink" title="针对计算设备的攻击"></a>针对计算设备的攻击</h1><h2 id="环境攻击"><a href="#环境攻击" class="headerlink" title="环境攻击"></a>环境攻击</h2><ol>
<li>电力，温度，有限的传导</li>
</ol>
<h2 id="窃听"><a href="#窃听" class="headerlink" title="窃听"></a>窃听</h2><p>搭线窃听同轴电缆的电脉冲</p>
<h2 id="信号发射"><a href="#信号发射" class="headerlink" title="信号发射"></a>信号发射</h2><p>通过计算机屏幕发出的射频信号来检测正在显示的内容</p>
<h2 id="键盘记录"><a href="#键盘记录" class="headerlink" title="键盘记录"></a>键盘记录</h2><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ol>
<li>三级：1米；20米，100米</li>
<li>放射阻隔(阻隔光,音)</li>
<li>法拉第笼：阻挡电磁辐射</li>
</ol>
<h1 id="计算机取证"><a href="#计算机取证" class="headerlink" title="计算机取证"></a>计算机取证</h1><p>计算机取证是一种获取包含在电子媒介上的信息的方 法，如计算机系统、硬盘和光盘，通常用于收集用于 法律诉讼的证据</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li>鉴定</li>
<li>收集：注意不要修改数据</li>
<li>分析和评估</li>
<li>报告</li>
</ol>
<h2 id="取证约束"><a href="#取证约束" class="headerlink" title="取证约束"></a>取证约束</h2><ol>
<li>监管链</li>
<li>优先级RAM &gt; swap &gt; disk &gt; CDs/DVDs。第一时间捕获更易失的</li>
<li>犯罪现场的计算机应该被视为完全敌对的</li>
</ol>
<h2 id="隐藏数据的方法"><a href="#隐藏数据的方法" class="headerlink" title="隐藏数据的方法"></a>隐藏数据的方法</h2><ol>
<li>密码学</li>
<li>隐写术</li>
<li>更改文件名或者扩展名</li>
<li>隐藏分区</li>
<li>删除文件</li>
</ol>
<h2 id="反取证技术"><a href="#反取证技术" class="headerlink" title="反取证技术"></a>反取证技术</h2><ol>
<li>反取证技术试图阻止调查员及其取证技术</li>
<li>安全删除数据，以便无法使用取证方法进行恢复 </li>
<li>首先防止创建某些数据</li>
<li>从未出现的数据显然无法通过取证方法恢复。</li>
</ol>
<h2 id="磁盘擦出"><a href="#磁盘擦出" class="headerlink" title="磁盘擦出"></a>磁盘擦出</h2>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导第3章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC3%E7%AB%A0/"
    >计安导第3章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC3%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.494Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h1><ol>
<li><p>包括计算机硬件系统和计算机软件系统。</p>
<ol>
<li>硬件系统包括：运算器，控制器，存储器，输入设备，输出设备。</li>
<li>软件系统：操作系统</li>
</ol>
</li>
<li><p>操作系统：提供计算机用户和该计算机硬件之间的接口，管理应用程序访问计算机资源的方式。</p>
<ol>
<li>内核：操作系统的核心组件，处理对底层硬件资源的管理。</li>
</ol>
</li>
<li><p>系统调用：是一种机制，通过这种机制，应用程序可以委托内核来执行与硬件相关的操作。</p>
<h1 id="进程："><a href="#进程：" class="headerlink" title="进程："></a>进程：</h1></li>
<li><p>进程进程是正在执行的程序的一个实例。</p>
</li>
<li><p>进程树：新的进程由其父进程产生，构成一颗进程树。树的根是init进程，在加载和运行内核后开始执行，并创建登陆会话和系统任务等其他子进程。</p>
</li>
<li><p>进程ID：每个进程都通过唯一的非负整数进行标识。</p>
</li>
<li><p>进程间通信</p>
<ol>
<li>读写文件进行方式<ol>
<li>通过硬盘，速度较慢。</li>
<li>不便于进行私密通信。</li>
</ol>
</li>
<li>共享内存方式<ol>
<li>只有内核能管理共享内存区。</li>
</ol>
</li>
<li>管道和套接字：提供进程与进程间通信的通道，通信双方共享管道和套接字。</li>
<li>信号量机制</li>
</ol>
</li>
<li><p>远程过程调用RPC：允许一个进程调用另一个进程中的子例程。</p>
</li>
<li><p>守护进程和服务</p>
<ol>
<li>守护进程（后台进程）（Windows下称为服务）：运行权限高于任何用户，并在登陆会话结束前就一直存在。如Web服务器，远程登陆等<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1></li>
</ol>
</li>
<li><p>文件系统是如何组织计算机的外部、非易失性存储的一种抽象。</p>
</li>
<li><p>文件权限</p>
<p> 关键在于界定哪些用户可以访问哪些资源。</p>
</li>
<li><p>Unix文件权限</p>
<ol>
<li>包括三类用户：<ol>
<li>owner类</li>
<li>group类：决定了相同组中的用户的文件权限。</li>
<li>others类<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1></li>
</ol>
</li>
</ol>
</li>
<li><p>内存管理是指如何组织和分配计算机的内存。</p>
</li>
<li><p>进程的地址空间</p>
<ol>
<li>代码段</li>
<li>数据段</li>
<li>BSS：符号起始区块，包含未初始化的静态变量。</li>
<li>堆：动态段，存储运行时产生的数据。</li>
<li>栈：记录函数调用和他们的参数。</li>
</ol>
</li>
<li><p>内存访问权限</p>
<ol>
<li>五段都有各自的访问权限。通常代码段只读，其他段可以写入</li>
<li><strong>不允许进程访问其他进程的地址空间</strong></li>
</ol>
</li>
<li><p>虚拟内存</p>
<ol>
<li>每个进程都有一个虚拟地址空间，虚拟内存系统将每个虚拟地址映射为实际内存地址。</li>
<li>由MMU来进行地址转换。</li>
<li>在进程看来，它的虚拟地址空间是连续的，但是实际内存却未必。</li>
<li>优点：允许进程的地址空间大于内存。</li>
<li>缺点：访问硬盘速度慢。 </li>
<li><strong>问题</strong>：不正常关机的时候，虚拟页面可能未被删除。攻击者可以通过外部介质引导另一个操作系统，查看并重建部分内存，导致信息泄漏。</li>
<li><strong>解决</strong>：对硬盘内容进行加密。</li>
</ol>
</li>
<li><p>缺页</p>
</li>
<li><p>虚拟机</p>
<ol>
<li>不直接接触底层硬件就允许操作系统的运行。</li>
<li>在虚拟机中运行的操作系统称为客户机，本地的操作系统称为主机。</li>
<li>虚拟机的实现：<ol>
<li>模拟：主机系统翻译接口的通信，传给硬件。其优点是增加了硬件的灵活性，缺点是使性能下降。</li>
<li>虚拟化：失去硬件灵活性，但是性能提升了。</li>
</ol>
</li>
<li>虚拟机的优点<ol>
<li>提高了硬件效率：在一台机器上托管多个操作系统。</li>
<li>可移植性</li>
<li>安全：沙箱</li>
<li>便于管理<h1 id="进程安全"><a href="#进程安全" class="headerlink" title="进程安全"></a>进程安全</h1><h2 id="引导顺序及安全"><a href="#引导顺序及安全" class="headerlink" title="引导顺序及安全"></a>引导顺序及安全</h2></li>
</ol>
</li>
</ol>
</li>
<li><p>引导：从关机状态到将操作系统加载到内存。</p>
</li>
<li><p>加载分两阶段：首先加载BIOS固件中的代码，然后这程序会假爱国操作系统其余部分加载到内存，然后将控制权交给操作系统。</p>
</li>
<li><p><strong>问题</strong>：恶意用户可以利用引导过程的一些脆弱点来控制计算机的执行。</p>
</li>
<li><p><strong>解决</strong>：设置BIOS密码。</p>
<h2 id="引导设备的层次"><a href="#引导设备的层次" class="headerlink" title="引导设备的层次"></a>引导设备的层次</h2></li>
<li><p>第二阶段引导程序允许用户指定使用哪个设备来加载操作系统。</p>
</li>
<li><p><strong>问题</strong>：攻击者可以绕过运行的计算机上的安全机制，从外部介质引导其他操作系统。</p>
</li>
<li><p><strong>解决</strong>：对第二阶段引导程序启动密码保护。</p>
<h2 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h2></li>
<li><p>休眠：电源关闭的状态。当进入休眠时，操作系统将计算机内存的全部内容存储到硬盘中的休眠文件中；系统通电后，再迅速恢复计算机状态。</p>
</li>
<li><p><strong>问题</strong>：</p>
<ol>
<li>攻击者可以从休眠文件中获取一些敏感信息。Windows的休眠文件目录C:/hiberfil.sys</li>
<li>攻击者可以修改休眠文件，改变计算机上执行的程序。</li>
<li>即使计算机重启后，也不会删除休眠文件。</li>
</ol>
</li>
<li><p><strong>解决</strong>：使用硬盘加密来保护休眠文件。</p>
<h2 id="监控、管理和日志"><a href="#监控、管理和日志" class="headerlink" title="监控、管理和日志"></a>监控、管理和日志</h2><p>操作系统可以根据留下的线索解决常见的问题，还能确定出现安全漏洞的原因。</p>
</li>
<li><p>事件日志：</p>
<ol>
<li>由操作系统进行管理</li>
<li>Windows中定义了三种日记 源：系统、应用程序和安全。其中系统日志只有操作系统才能写入；应用程序日志只由应用程序写入；安全日志由操作系统提供的本地安全授予子系统服务才能写入。  </li>
</ol>
</li>
<li><p>进程监控：查看正在运行的进程</p>
</li>
<li><p>进程查看器：提供进程监控和管理的大量信息。</p>
<ol>
<li>提高进程的映像，即运行进程的代码所在的磁盘位置。</li>
<li><strong>问题</strong>：攻击者可以通过替换合法程序的映像来掩饰自身。</li>
<li><strong>解决</strong>：可以对映像使用数字签名来保证磁盘上存储的应用程序不被替换。</li>
</ol>
</li>
</ol>
<h1 id="基于密码的身份认证"><a href="#基于密码的身份认证" class="headerlink" title="基于密码的身份认证"></a>基于密码的身份认证</h1><ol>
<li><p>密码盐—反字典攻击：是一种加密技术，使用随机位作为散列函数的输入或加密算法的部分输入，从而增加随机性。<br> (U,S,h(S||P))其中S为U的盐，h是散列函数。</p>
</li>
<li><p>加盐的原理：增大字典攻击的搜索空间。2<sup>B×D，其中B是随机数位数，D是字典攻击单词列表。</p>
<h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><h2 id="Linux的权限"><a href="#Linux的权限" class="headerlink" title="Linux的权限"></a>Linux的权限</h2></li>
<li><p>使用文件权限矩阵</p>
</li>
<li><p>对于未明确授权的都默认拒绝</p>
</li>
<li><p>为了访问文件，在文件系统树中的每个祖先文件夹都必须有执行权限。</p>
</li>
<li><p>文件所有者具有自主访问控制权，可以修改文件权限。</p>
</li>
<li><p>可以使用chattr设置权限，lsattr查看。</p>
</li>
<li><p>目前开始支持ACL方案</p>
</li>
<li><p>对owner, group和other主体，每个文件都有基本的ACE(<strong>访问控制项</strong>)；对于命名用户和命名组可创建额外的ACE；还有掩码ACE,即规定主体允许的最大权限</p>
<h2 id="Linux的ACL权限方案"><a href="#Linux的ACL权限方案" class="headerlink" title="Linux的ACL权限方案"></a>Linux的ACL权限方案</h2></li>
<li><p>设U是进程的euid，具有一定的请求权限，视图访问文件或文件夹</p>
</li>
<li><p>为确定是否授权，操作系统将进行匹配：</p>
<ol>
<li>U是文件所有者的ID</li>
<li>U是命名组之一</li>
<li>U的一个组是所有组，该组的ACE包含请求权限。</li>
<li>U的一个组是命名组，该组的ACE包含请求权限。</li>
<li>对于U所在的每个组，该组的ACE都不包含请求权限。</li>
<li>检查other的ACE<h2 id="Windows权限基础"><a href="#Windows权限基础" class="headerlink" title="Windows权限基础"></a>Windows权限基础</h2></li>
</ol>
</li>
<li><p>Windows使用访问控制列表，允许用户创建访问控制规则。</p>
</li>
<li><p>默认是拒绝</p>
</li>
<li><p>标准权限包裹：读、写、修改、读和执行、完全控制。</p>
</li>
<li><p>读相关的高级属性：读取数据、读取属性、读取扩展属性和读取权限。</p>
</li>
<li><p>文件夹权限包括</p>
<ol>
<li>读权限：可以列出文件夹内容。</li>
<li>写权限：允许用户创建新文件夹。</li>
<li>Windows下可以禁止用户访问文件夹，但允许用户访问该文件夹下的特定文件。</li>
</ol>
</li>
<li><p>ACE</p>
<ol>
<li>继承ACE：文件夹的任何ACE可用于该文件夹内的子文件夹和文件。</li>
<li>显式ACE：针对文件或者文件夹专门设置的ACE。</li>
<li>ACE优先级：拒绝ACE&gt;允许ACE、显示ACE&gt;继承ACE、继承ACE优先级 由祖先与对象之间的距离决定，越近优先级越高。<h2 id="Windows文件权限"><a href="#Windows文件权限" class="headerlink" title="Windows文件权限"></a>Windows文件权限</h2></li>
</ol>
</li>
<li><p>SetUID操作：程序由普通用户运行，但期望允许程序改变普通用户无法改变的文件。</p>
<p> 例如：在早期UNIX系统中，用户登录信息存储在/etc/passwd中。普通用户 不能编辑这个文件，但允许该用户更改自己的密码是合理的要求</p>
<ol>
<li>设置了setuid位，使得程序以其所有者的有效ID来运行，而不是以正在执行程序的进程ID。</li>
<li><strong>问题</strong>  <ol>
<li>攻击者可以强制setuid程序执行任意代码，如缓冲区溢出攻击。</li>
<li>权限升级：攻击者可以通过setuid机制来运用程序的所有者权限。</li>
</ol>
</li>
</ol>
</li>
<li><p>文件描述符：存储在文件描述符表中的索引值，用来索引特定文件</p>
<ol>
<li>当程序需要访问文件时，访问open系统调用，该调用使内核创建一个文件 描述符表中的新项并将其返回给程序，该项映射到文件的磁盘位置。程序可以使用文件描述符发送读或者写命令。内核在接到读、写系统调用时， 在文件描述符表中查找相关的表项，并在磁盘适当位置执行读、写操作。完成操作后，要用close系统调用删除打开的文件描述符。</li>
<li><strong>漏洞</strong> 当进程创建子进程时，子进程会集成父进程打开的所有文 件描述符副本。当程序以高权限打开文件描述符，但未关闭，然后又创建了 低权限的进程，那么新进程就能够读写相关文件，但子进程本身不具有打开 该文件的权限。</li>
<li><strong>原因</strong> 在创建文件描述符项的时刻，操作 系统只检查进程是否具有读写权限；在实际读写文件操作时，只根据文件描 述符被打开时的权限来确认是否允许请求的操作。</li>
</ol>
</li>
<li><p>符号链接与快捷方式</p>
<ol>
<li><strong>问题</strong> 攻击者可以利用符号链接来诱使应用程序执行不良操作。</li>
<li><strong>解决</strong> 程序检查文件名是否指向符号链接，以确定打开的实际文件名。</li>
<li>Windows的快捷方式&amp;Linux的符号链接：符号链接由操作系统处 理，使用透明；而快捷方式是普通文件。<h1 id="应用程序安全"><a href="#应用程序安全" class="headerlink" title="应用程序安全"></a>应用程序安全</h1><h2 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h2></li>
</ol>
</li>
<li><p>编译：将源代码转换为处理器能够执行的机器代码的过程</p>
</li>
<li><p>静态链接：程序执行时所需的共享库需要复制到编译程序中。一般比较安全， 但重复代码会占用额外的空间。</p>
</li>
<li><p>动态链接：程序真正运行时，才会加载共享库。加载程序确定待运行程序需 要哪些共享库，然后在磁盘上找到这些库，并将它们导入进程的地址空间。</p>
<ol>
<li><strong>DDL注入</strong>：通过共享库向程序注入任意代码的过程。<strong>优点</strong> 是便于调试，<strong>缺点</strong> 是潜在的安全风险，恶意用户能向合法程序注入自己的代码。<h2 id="简单的缓冲区溢出攻击"><a href="#简单的缓冲区溢出攻击" class="headerlink" title="简单的缓冲区溢出攻击"></a>简单的缓冲区溢出攻击</h2></li>
</ol>
</li>
<li><p>缓冲区：进程为程序在内存中分配固定大小的存储空间。</p>
</li>
<li><p>缓冲区溢出：如果不进行边界检查，攻击者提供的输入数据可能会超出缓冲 区的大小。此时，内存缓冲区之外的数据可能会被覆盖。</p>
</li>
<li><p><strong>问题</strong> 攻击者利用缓冲区溢出获得进程的控制权，执行任意恶意代码。</p>
<h2 id="基于栈的缓冲区溢出"><a href="#基于栈的缓冲区溢出" class="headerlink" title="基于栈的缓冲区溢出"></a>基于栈的缓冲区溢出</h2></li>
<li><p>进程地址空间中栈由帧组成，每一帧存储局部变量、调用参数和返回地址。</p>
</li>
<li><p><strong>问题</strong> 如果攻击者提供的输入大于调用函数中缓冲区的大小，会导致溢出，从而导致栈缓冲区之外 的内存空间被覆盖。</p>
</li>
<li><p>缓冲区溢出攻击：当缓冲区是局部变量 或帧的参数时，用户的输入 可能覆盖返回地址，改变程 序的执行。</p>
<ol>
<li><strong>问题</strong> 攻击者利用栈缓冲区的脆弱 性，在栈中注入恶意代码， 覆盖当前调用的返回地址， 从而将执行权限传递给攻击 者的恶意代码。</li>
<li>实际攻击中，攻击者需要猜测缓冲区返回地址的位置，并确定用什么地址覆盖返回地址。难点在于：<ol>
<li>进程不能访问其他进程的地址空间，因此恶意代码必须驻留在被攻击进 程的地址空间内。一般驻留在缓冲区中或者在用户的Shell环境中。</li>
<li>给定进程的地址空间是不可预测的，程序在不同计算机上执行时，地址 空间可能发生改变。</li>
<li>为了克服以上困难，攻击者可以采取的相关技术有：NOP指令滑动(NOP sledding)、返回到libc(return-to-libc)、跳转到寄存器(jump-to-register)或蹦 床(Trampolining)技术<h2 id="缓冲区溢出攻击相关技术"><a href="#缓冲区溢出攻击相关技术" class="headerlink" title="缓冲区溢出攻击相关技术"></a>缓冲区溢出攻击相关技术</h2></li>
</ol>
</li>
</ol>
</li>
<li><p>NOP指令滑动:通过命中一串连续的NOP指令，从而使CPU指令执行流一直滑动到特定位 置来执行恶意代码。</p>
<ol>
<li>由于进程地址空间难以预测，所以通过一连串的NOP指令，只要有一个命中就能执行恶意代码。</li>
</ol>
</li>
<li><p>跳转到寄存器：在初始化时，大多数进程需要将外部库的内容加载到自己的地址空间。操作 系统一般将这些外部库加载到内存预留段的进程地址空间中。因此，外部库 在内存中的位置是可预测的。攻击者利用这些外部库的知识进行跳转攻击：</p>
<ol>
<li>攻击者找到特定代码集中 的跳转指令，如jump ESP；</li>
<li>攻击者设法把恶意代码放在ESP寄存器指定 的内存地址上；</li>
<li>攻击者将当前函数的返回地址重写为jump指令的地址； </li>
<li>函数返回时将执行jump指令，并跳转执行恶意代码；</li>
</ol>
</li>
<li><p>返回到libc攻击：攻击者确定脆弱进程的地址空间内C库函数的地址，如system()或execv的 地址，并使用这些信息强制进程调用该函数。</p>
<ol>
<li>攻击者首先让缓冲区溢出，并用所需库函数的地址覆盖返回地址，并传递重 新设定好的参数使其能够按攻击者的期望运行。</li>
<li>这种攻击方式在实现攻击的同时，也避开了数据执行保护策略中对攻击代码 的注入和执行所采取的的防护措施。Return-to-libc 攻击不需要注入新的恶意代码，而是重用漏洞程序中已有的 函数完成攻击，让漏洞程序跳转到已有的代码序列。</li>
</ol>
</li>
</ol>
<h2 id="防止基于栈的缓冲区溢出攻击"><a href="#防止基于栈的缓冲区溢出攻击" class="headerlink" title="防止基于栈的缓冲区溢出攻击"></a>防止基于栈的缓冲区溢出攻击</h2><ol>
<li>规范C语言编程</li>
<li>使用更安全的函数</li>
<li>操作系统也提供保护措施，如防止攻击者覆盖返回地址；使用金丝雀技术。</li>
</ol>
<h3 id="防止攻击者覆盖返回值地址"><a href="#防止攻击者覆盖返回值地址" class="headerlink" title="防止攻击者覆盖返回值地址"></a>防止攻击者覆盖返回值地址</h3><ol>
<li>在所有指针使用前后都进行异或编码</li>
<li>将内存的栈空间设置为非执行权限</li>
<li>地址空间布局随机化，随机地重新安排地址空间的数据，使得攻击者难以预测。</li>
</ol>
<h3 id="金丝雀预警技术"><a href="#金丝雀预警技术" class="headerlink" title="金丝雀预警技术"></a>金丝雀预警技术</h3><p>重新组织分配程序的堆栈数据，使用一个canary值，并将此值放在缓冲区和 控制数据之间。系统定期检查canary值的完整性。如果此值被更改，表明缓 冲区溢出，就要防止恶意代码的执行。</p>
<h2 id="基于堆的缓冲区溢出"><a href="#基于堆的缓冲区溢出" class="headerlink" title="基于堆的缓冲区溢出"></a>基于堆的缓冲区溢出</h2><p><strong>问题</strong> 如果在堆上显示分配了内存，但没有释放，会导致内存泄漏问题。</p>
<p><strong>攻击</strong> 攻击者一般通过修改堆中的数据 或者滥用管理堆内存的函数和宏 来执行恶意代码。</p>
<ol>
<li>如果攻击者向程序提供输入，而程序以不安全的方式将其复制到堆中的内存 块中。那么攻击者可以使数据溢出块的边界，并覆盖下一个内存块。通过精心设计，攻击者会覆盖下一个内存块的链表指针，并将该内存块标记 为空闲。此时，unlink例程可以向内存地址空间中的任意地址写入数据。如 果写入的数据是恶意代码的存储位置，会导致程序跳转并执行恶意代码。</li>
</ol>
<h2 id="防御基于堆的缓冲区溢出"><a href="#防御基于堆的缓冲区溢出" class="headerlink" title="防御基于堆的缓冲区溢出"></a>防御基于堆的缓冲区溢出</h2><p>如安全编程、地址空间随机化、设置堆数据不可执 行、将存储堆内存的指针数据和存储堆中的实际数据相分离。</p>
<h1 id="格式化字符串攻击"><a href="#格式化字符串攻击" class="headerlink" title="格式化字符串攻击"></a>格式化字符串攻击</h1><p><strong>攻击</strong> 攻击者可以精心指定所使用的格式化字符串作为输入，并可以将输入写入内 存的任意位置。如果写入的位置正好覆盖了返回地址、函数指针等，则攻击 者能够取得控制权，并在程序的上下文中执行任意代码。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导第4章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC4%E7%AB%A0/"
    >计安导第4章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC4%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.494Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="内部攻击"><a href="#内部攻击" class="headerlink" title="内部攻击"></a>内部攻击</h1><ol start="2">
<li>内部攻击：指控制和保护资产的内部人员利用安全漏洞进行的攻击</li>
</ol>
<h2 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h2><ol start="3">
<li>后门：是程序中隐藏的功能或命令，有时也称为活门，它允许用户执行一些正常情况下不允许用户执行的操作。通常这些操作会违反安全策略，如执行特权升级。<ol>
<li>为调试有时也会插入后门</li>
<li>为了紧急情况也可能留后门</li>
<li>恶意的后门：直接留后门；在程序中引入脆弱性，如缓冲区溢出。</li>
<li>彩蛋</li>
</ol>
</li>
</ol>
<h2 id="逻辑炸弹"><a href="#逻辑炸弹" class="headerlink" title="逻辑炸弹"></a>逻辑炸弹</h2><ol start="4">
<li>逻辑炸弹：是一种程序，它根据一定的逻辑条件执行恶意操作。</li>
<li>千年虫问题：具有和逻辑炸弹类似的效果，但是不视为逻辑炸弹</li>
</ol>
<h2 id="内部攻击的防御"><a href="#内部攻击的防御" class="headerlink" title="内部攻击的防御"></a>内部攻击的防御</h2><ol>
<li>避免单点故障：不能只让一个人创建备份或管理重要系统。</li>
<li>使用代码走查</li>
<li>使用归档和报告工具</li>
<li>限制授权和权限：使用最小权限原则；在保证每个员工能正常工作的情况下，授予他们最小权限。</li>
<li>重要系统的物理安全</li>
<li>监控员工行为</li>
<li>控制软件的安装</li>
</ol>
<h1 id="计算机病毒"><a href="#计算机病毒" class="headerlink" title="计算机病毒"></a>计算机病毒</h1><ol>
<li>计算机病毒：是一种能自我复制的计算机指令或程序代码，它通过修改其他文件与程序来插入代码，且能进一步自我复制；<ol>
<li>这种自我复制的特性是计算机病毒与其他类型恶意软件（如逻辑炸弹）的不同之处；</li>
<li>病毒的另一个特性是其复制需要某种类型的用户协助，如打开电子邮件附件或共享USB驱动器；</li>
</ol>
</li>
<li>恶意软件分类：<ol>
<li>按传播特性分：<ol>
<li>病毒：人工辅助传播</li>
<li>蠕虫：自动传播</li>
</ol>
</li>
<li>按隐藏特性分：<ol>
<li>Rootkit：修改操作系统以隐藏其存在</li>
<li>特洛伊木马：提供理想的功能但是隐藏恶意操作。</li>
</ol>
</li>
</ol>
</li>
<li>隐藏方式<ol>
<li>加密病毒：<ol>
<li>病毒包括解密引擎+病毒代码主体，随机生成加密密钥</li>
<li>检测：通过查找解密引擎</li>
</ol>
</li>
<li>多态病毒<ol>
<li>具有随机变体的解密引擎的加密病毒</li>
<li>检测：使用CPU仿真器</li>
</ol>
</li>
<li>变形病毒<ol>
<li>不同的病毒体；方法包括代码排列和指令替换</li>
<li>具有挑战性的检测</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="病毒的分类"><a href="#病毒的分类" class="headerlink" title="病毒的分类"></a>病毒的分类</h2><ol start="3">
<li>病毒执行的四个阶段<ol>
<li>潜伏阶段</li>
<li>繁殖阶段：病毒进行自我复制，归纳然新系统中的新文件。</li>
<li>触发阶段</li>
<li>行动阶段：此阶段，病毒会执行恶意操作。</li>
</ol>
</li>
<li>病毒的类型<ol>
<li>程序病毒（文件病毒）：通过修改文件包含的对象代码感染文件。</li>
<li>宏病毒（文档病毒）：打开文档时，启动病毒，此时，病毒搜索其他要感染的文件。此外，宏病毒还可以将自己插入到模板中，使得每次新建的文档都含有此病毒。另外，还可以通过电子邮件传播。</li>
<li>引导区病毒：感染驱动器引导区的代码，每次启动计算机或重启时，都会运行引导区的代码。</li>
</ol>
</li>
<li>病毒的特征<ol>
<li>传染性</li>
<li>隐蔽性</li>
<li>潜伏性：只有当触发条件满足时才破坏，否则只传染</li>
<li>多态性：不断变种</li>
<li>破坏性</li>
</ol>
</li>
<li>病毒注入：（1）在程序开始处简单注入（2）将病毒代码分成两部分，并将这两部分分别注入到程序的不同位置，使用跳转指令来执行。</li>
</ol>
<h2 id="病毒的防御"><a href="#病毒的防御" class="headerlink" title="病毒的防御"></a>病毒的防御</h2><ol>
<li>病毒的特征码：<ol>
<li>通过病毒样本找到病毒的特征指令集，产检唯一标识这类病毒的特征字符串。<strong>一般将特征字符串称为病毒的特征码</strong>。它是病毒的一种数字指纹</li>
</ol>
</li>
<li>病毒的检测与隔离<ol>
<li>可以定期扫描整个文件系统</li>
<li>可以实时的分析每个新创建的文件，每个修改的文件和收到的电子邮件。一旦文件中有一部分包含与病毒特征码匹配的代码，就会被放入隔离区。</li>
</ol>
</li>
</ol>
<h2 id="加密病毒"><a href="#加密病毒" class="headerlink" title="加密病毒"></a>加密病毒</h2><ol>
<li>加密病毒：通过加密病毒代码的主体，以隐藏其自身的特征码。<ol>
<li>包括解密代码、密钥和加密病毒代码（解密代码一般用暴力破解代替）。</li>
<li>对病毒主体的解密代码本身时未加密的代码，此结构本身就构成了一种病毒的特征码。</li>
</ol>
</li>
</ol>
<h2 id="多变体病毒和变形病毒"><a href="#多变体病毒和变形病毒" class="headerlink" title="多变体病毒和变形病毒"></a>多变体病毒和变形病毒</h2><ol>
<li><p>多变体：变异的病毒。</p>
<ol>
<li>一方面，多变体病毒通过加密使自身呈现出多种形式。</li>
<li>另一方面，多变体病毒采用非加密的混淆技术，如指令重排和包含无用指令技术。</li>
</ol>
</li>
<li><p>检测多变体病毒：单个字符串不可能检测变形病毒的特征码，可以采用</p>
<ol>
<li>联合特征码：由在被感染文件中必须出现的字符串集组成。</li>
<li>序列特征码：由在被感染文件中必须出现的有序字符串列表组成</li>
<li>概率特征码：由阈值和字符串-评分对组成。如果文件中存在的字符串的评分总和大于阈值，则认为被感染。</li>
</ol>
</li>
</ol>
<h1 id="恶意软件攻击"><a href="#恶意软件攻击" class="headerlink" title="恶意软件攻击"></a>恶意软件攻击</h1><h2 id="特洛伊木马"><a href="#特洛伊木马" class="headerlink" title="特洛伊木马"></a>特洛伊木马</h2><ol start="2">
<li><p>特洛伊木马：是一种恶意程序，表面上，它会执行一些有用的任务，但同时会隐形的执行具有负面后果的任务。</p>
<ol>
<li><p>组成：</p>
<ol>
<li>硬件部分：包括控制端、服务端、因特网；</li>
<li>软件部分：控制端程序、木马程序、木马配置程序；</li>
<li>具体连接部分：控制端IP、服务端IP、控制端端口、木马端口；</li>
</ol>
</li>
<li><p>木马入侵步骤：</p>
<p> 1.配置木马  2.传播木马  3.运行木马  </p>
<p> 4.信息反馈  5.建立连接  6.远程控制 </p>
</li>
</ol>
</li>
<li><p>计算机蠕虫：是一种恶意程序，不需要将自己注入其他程序就能传播自己的副本，并且不需要与人交互。</p>
<ol>
<li><p>蠕虫可以自我复制传播，但它不属于计算机病毒，因为他们不会感染其他程序。</p>
</li>
<li><p>大多数情况下，蠕虫用来删除文件或者安装后门</p>
</li>
<li><p>蠕虫的结构</p>
<img src="/计安导_img/第四章1.png" style="zoom:30%"/></li>
<li><p>设计蠕虫</p>
<img src="/计安导_img/第四章2.png" style="zoom:70%"/></li>
<li><p>蠕虫传播</p>
<ol>
<li><p>传播理论</p>
<p>经典的传播病模型</p>
<img src="/计安导_img/第四章3.png" style="zoom:70%"/>   

</li>
</ol>
<p>N: 易受感染的主机总数; I(t)：在t时刻被感染的主机数<br>S(t)：在t时刻，易被感染的主机数;I(t)+S(t)=N;β：感染率;I(t)的微分方程 ：dI/dt=βI(t)S(t);    </p>
<ol start="2">
<li>蠕虫可以利用正在运行应用程序的脆弱性（如缓冲区溢出）来进行自我传播。</li>
<li>一般通过修改注册表来隐藏自身。(同时杀毒软件也会观察一些注册表项)</li>
</ol>
</li>
</ol>
</li>
<li><p>Rootkits</p>
<ol>
<li>Rootkits最早是一组用于UNIX操作系统的工具集，黑客使用它们隐藏入侵活 动的痕迹，它能在操作系统中隐藏恶意程序。这些程序在植入系统后，rootkits 会将它们 隐藏起来，它能隐藏任何恶意程序过程、文件夹、注册码。</li>
<li>一般通过修改系统是实用程序或操作系统本身来防止检测。</li>
<li>通常使用Rootkits来隐藏其他恶意软件的恶意行为（在进程控制器中删除进程的显示，删除文件浏览器中文件的显示）</li>
</ol>
</li>
<li><p>恶意软件僵尸</p>
<ol>
<li>僵尸是一种外部控制以执行恶意攻击的计算机，通常作为僵尸网络的一部分。</li>
</ol>
</li>
</ol>
<h2 id="入侵隐私软件"><a href="#入侵隐私软件" class="headerlink" title="入侵隐私软件"></a>入侵隐私软件</h2><ol>
<li>包括广告软件、间谍软件</li>
</ol>
<h2 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h2><ol>
<li><p>病毒签名：一个签名是一个病毒指纹</p>
<ol>
<li>扫描将分析的对象与签名数据库进行比较。如果文件中包含签名，则文件被感染。</li>
</ol>
</li>
<li><p>黑/白名单</p>
<ol>
<li>维护加密哈希数据库<br> （1）操作系统文件 （2）热门应用程序<br> （3）已知被感染的文件</li>
<li>需要保护数据库的完整性</li>
</ol>
</li>
<li><p>启发式分析</p>
<ol>
<li>用于识别新的和“零日”恶意软件 </li>
<li>步骤<ol>
<li>代码分析：根据说明防病毒软件可以确定该程序是否是恶意的。</li>
<li>执行仿真：在隔离的仿真环境中执行代码，并监控目标文件所采取的操作，如果操作有害，则认为其为病毒。</li>
<li>启发式方法可以触发错误警报</li>
</ol>
</li>
</ol>
</li>
<li><p>隔离：将可疑文件隔离在隔离文件夹中。</p>
<ol>
<li>可疑文件未被删除，最终可以由用户决定何使删除</li>
<li>只能通过防病毒程序与隔离区中的文件交互。</li>
<li>隔离区的文件是无害的，因为它是加密的</li>
<li>隔离技术的细节是保密的</li>
</ol>
</li>
<li><p>静态分析与动态分析</p>
 <img src="/计安导_img/第四章4.png" style="zoom:70%"/>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导第5章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC5%E7%AB%A0/"
    >计安导第5章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC5%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.494Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="网络基本概念"><a href="#网络基本概念" class="headerlink" title="网络基本概念"></a>网络基本概念</h1><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><ol>
<li>OSI七层模型：应用层；表示层；会话层；传输层；网络层；链路层；物理层</li>
<li>TCP/IP五层模型：应用层；传输层；网络层；数据链路层；物理层</li>
</ol>
<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><ol>
<li><p>物理层</p>
<ol>
<li>其任务是以尽力服务为基础，在网络节点之间传输实际的比特位。</li>
<li>规定通信设备的机械的、电气的、功能的和过程的特性，用以建 立、维护和拆除物理链路连接。</li>
</ol>
</li>
<li><p>链路层</p>
<ol>
<li>其任务是在网络节点对间或局域网节点间传输数据并检测物理层出现的差错。</li>
<li>该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据 的检错、重发等。</li>
</ol>
</li>
<li><p>网络层</p>
<ol>
<li>其任务是以尽力服务为基础，在任意两台主机之间传送数据包。就是选择合适的网间路由和交换结点， 确保数据及 时传送。</li>
<li>网络层将数据链路层提供的帧组成数据包，包中封装有网络层包 头，其中含有逻辑地址信息：源站点和目的站点地址的网络地址。</li>
</ol>
</li>
<li><p>传输层</p>
<ol>
<li>其任务是基于IP地址和端口，支持应用程序之间的通信与连接。</li>
<li>传输层为上层提供端到端（最终用户到最终用户）的透明的、可 靠的数据传输服务。所谓透明的传输是指在通信过程中传输层对 上层屏蔽了通信传输系统的具体细节。</li>
</ol>
</li>
<li><p>应用层</p>
<ol>
<li>其任务是以传输层提供的服务为基础，提供协议来支持互联网上的有用的功能。</li>
<li>常用协议有FTP、TELNET、DNS、SMTP、POP3。</li>
</ol>
</li>
</ol>
<h2 id="网络与安全"><a href="#网络与安全" class="headerlink" title="网络与安全"></a>网络与安全</h2><h3 id="与计算机安全目标-CIA"><a href="#与计算机安全目标-CIA" class="headerlink" title="与计算机安全目标 CIA"></a>与计算机安全目标 CIA</h3><ol>
<li>机密性：网络协议的任何分层中，都没有要求传输数据的机密性。 需要修订相关协议来完成机密性。可以在应用层进行加密协议的 设计，也可以在网络层。</li>
<li>完整性：封装的数据包中的头和尾部都有简单的校验和，以检查 传输数据是否有改变。但这些校验和不是密码学意义下安全的， 因此不能提供计算机安全层面的完整性。</li>
<li>可用性：网络协议设计之初主要考虑的是节点发生故障时如何保 证可用性，并未考虑攻击者存在时的情形。如拒绝服务攻击会影 响系统可用性。</li>
</ol>
<h3 id="与计算机安全目标-3A"><a href="#与计算机安全目标-3A" class="headerlink" title="与计算机安全目标 3A"></a>与计算机安全目标 3A</h3><ol>
<li>保证：默认情况下网络中数据包可以在任何两个节点间阐述。如 果需要引入权限和策略来控制网络中的数据流，必须通过显式得 的措施来实现。</li>
<li>真实性：网络协议的数据格式中没有存储数字签名的字段，也没 有用户身份的概念。如果需要引入身份证明和数字签名，必须在 应用层完成。</li>
<li>匿名：网络协议没有用户身份的概念，因此具有内在的匿名性。 对于匿名攻击，可以通过确定用户正在使用网络中的哪台计算机 来确定。</li>
</ol>
<h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><ol>
<li>定义：以太网包括通信所使用的物理介质以及链路层的协议 标准IEEE 802.3。</li>
<li>不同帧 在以太网电缆上同时传输时会产生冲突，需要丢弃并重传冲突帧。</li>
<li>冲突处理：以太网协议使用CSMA/CD（载波监听多路访问及冲突 检测）技术来避免冲突。</li>
</ol>
<h2 id="集线器："><a href="#集线器：" class="headerlink" title="集线器："></a>集线器：</h2><ol>
<li>工作与物理层，将所有帧广播给与之相连的所有设备。</li>
<li>缺点是与集线器相连的所有设备共享带宽，传输效率低下。由于 是广播，所以数据容易被窃听。</li>
</ol>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><ol>
<li>交换机会记录连接到自己各个接口的计算机地址。之后交换机会 将接收到的帧发送到特定的接收端，而不是广播出去。</li>
</ol>
<h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><ol>
<li>MAC（Medium/Media Access Control）地址，用来表示互联网 上每一个站点的标识符，采用十六进制数表示，共六个字节。</li>
<li>MAC地址是网卡决定的，一般是固定的。但可以通过网卡的驱动 程序软件来修改MAC地址。因此，<strong>从安全角度考虑，不能使用MAC地址作为识别网络流源头的依据。</strong></li>
</ol>
<h2 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h2><ol>
<li>ARP:是一种链路层协议，其主要功能是将给定主机的网络层地址解析为主机 的硬件地址。</li>
<li>过程：主机通过发送包含目标IP地址的AARP请求到网络上所有主机，并接受返回消息，以此确定目标的物理地址。同时将映射存入ARP缓存。</li>
<li><strong>ARP欺骗</strong>：攻击者可以向某 一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主 机或到达错误的主机，这就构成了一个<strong>ARP欺骗</strong>。<ol>
<li>问题在于ARP缺乏身份认证</li>
<li><strong>解决</strong> ：<ol>
<li>检查相同的MAC是否在局域网中多次出现，以作为ARP欺骗的标志。</li>
<li>静态ARP表：通过手动指定路由器的ARP缓存来将具体的MAC地址与特定的IP地址进行绑定。问题是不够灵活。</li>
<li>更加复杂和灵活的措施：anti-arpsroof、XArp、Arpwatch，这些 程序会仔细检查所有的ARP数据包，并将数据包的内容与所存储 的ARP表项纪录做比较，以检测并防止ARP欺骗。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网际协议基本概念"><a href="#网际协议基本概念" class="headerlink" title="网际协议基本概念"></a>网际协议基本概念</h2><ol>
<li>IP：网络层协议，尽最大努力将一个数据包从源节点路由到目的 节点。节点由IP地址标识，IPv4地址为32位，IPv6地址为128位。</li>
<li>IP包路由：如果数据包的源和目的在同一个局域网内，则通过ARP进行。否则，将包传送至网关，由网关根据路由表来确定如何转发。</li>
<li>IP地址与子网掩码：例如IP地址为192.168.1.100,子网掩码为 255.255.255.0。则该地址的网络部分为192.168.1.0,主机部分为 0.0.0.100.</li>
<li>IPv4地址耗尽解决：IPv6；网络地址转换<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2></li>
<li>路由器：为数据包寻找一条最佳的传输路径。路由器中维护一张路由表，以提高效率。</li>
<li>路由操作：包括发送、丢弃、转发</li>
<li><strong>TTL</strong>:数据包的<strong>生存周期</strong>，由跳数决定，一般最大条数为255。</li>
<li>路由协议<ol>
<li>OSPF决定了如何在自治系统内路由数据包。</li>
<li>BGP决定了如何在自治系统之间路由数据包。</li>
</ol>
</li>
</ol>
<h2 id="ICMP-网际控制消息协议"><a href="#ICMP-网际控制消息协议" class="headerlink" title="ICMP 网际控制消息协议"></a>ICMP 网际控制消息协议</h2><ol>
<li>ICMP:用于在主机、路由器之间传递控制消息。<ol>
<li>包括：回显请求；回显响应；超时；目的地不可达</li>
</ol>
</li>
<li>Ping 命令：Ping发送一个ICMP<strong>回声请求</strong> 消息给目的地并报告是否收到ICMP<strong>回声应答</strong>消息。</li>
<li>traceroute命令：利用ICMP 协议定位您的计算机和目标计算机之间的所有路由器。<strong>利用ICMP超时报文，依次等增TTL，以确定路径上有哪些路由</strong></li>
</ol>
<h2 id="IP地址欺骗"><a href="#IP地址欺骗" class="headerlink" title="IP地址欺骗"></a>IP地址欺骗</h2><ol>
<li><strong>方法</strong> 恶意用户产生的IP数据包中的源IP地址是伪造的， 以便冒充其他系统或发件人的身份。源IP地址修改后， IP数据包 头部校验和也需重新计算。</li>
<li>攻击者不会收到服务器响应，因为服务器会将数据包返回给具有假冒IP地址的主机。因此，攻击者不在乎响应，故可以用来Dos攻击。</li>
<li><strong>应对</strong> <ol>
<li>通过边缘路由器禁止那些源地址在域内，但实际地址在域外的数据包或源地址在域外，但是从域内向域外发的送的数据包。</li>
<li>可以通过IP追踪计数追踪数据包返回到实际源地址的路径。<h2 id="数据包嗅探"><a href="#数据包嗅探" class="headerlink" title="数据包嗅探"></a>数据包嗅探</h2></li>
</ol>
</li>
<li>Wireshark：网络数据包分析软件。使用WinpCAP作为接口，直接与网卡进行数据报文交换。此时网卡需要设置为混杂模式。<ol>
<li><strong>问题</strong> 可能泄露敏感信息。</li>
</ol>
</li>
<li><strong>解决</strong><ol>
<li>对于有线网，使用以太网交换机而不是集线器，降低数据包包嗅探的可能性。</li>
<li>检查网卡是否被设置为混杂模式。 </li>
<li>利用高层协议进行加密，比如HTTPS</li>
</ol>
</li>
</ol>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ol>
<li><p>端口号：16位，用来标识应用层不同服务。</p>
<ol>
<li>FTP:21</li>
<li>Telnet:23</li>
<li>SSMTP:25</li>
<li>HTTP:80</li>
</ol>
</li>
<li><p><strong>TCP</strong>:面向连接的、可靠的。面向 连接意味着实现会比较复杂，可靠的是指信息会完整、有序地到 达。如果数据包丢失，TCP会保证重传。 TCP是传输文件、网页 和电子邮件的首选协议。</p>
</li>
<li><p><strong>UDP</strong>：无连接的、不可靠但速度快。基于IP的语音会话(VoIP)适合于使用UDP协议。</p>
<h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2></li>
<li><p>三次握手建立连接，每个数据包都有编号。</p>
</li>
<li><p>采用<strong>累计确认</strong></p>
</li>
<li><p>流量控制使用滑动窗口协议</p>
</li>
<li><p>校验和：使用循环冗余校验(CRC)，可以检测由网络错误引发的数据不一致，但不能检测恶意篡改。</p>
</li>
<li><p>拥塞控制：拥塞会导致传输速率急剧下降和数据包的丢弃。拥塞 控制是防止流量淹没网络的一种技术，通过收集确认数据包等信 息来调整数据的传输速率，防止拥塞。</p>
<ol>
<li>慢开始与拥塞避免</li>
<li>快重传与快恢复</li>
</ol>
</li>
<li><p>TCP三次握手</p>
 <img src="/计安导_img/1.png" style="zoom:80%">

<ol>
<li>初始序列号是随机的，以<strong>防止针对预测初始序列号的攻击</strong>。</li>
</ol>
</li>
</ol>
<h2 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h2><ol>
<li>无需三次握手，允许直接发送数据包。</li>
<li>UPD提供无连接、不可靠的服务。将数据报序列中丢失数据报的工作交给应用层。</li>
<li>使用16位校验和验证数据包完整性。</li>
<li>速度远远快于TCP,用于DNS和VoIP。</li>
</ol>
<h2 id="NAT-网络地址转换"><a href="#NAT-网络地址转换" class="headerlink" title="NAT 网络地址转换"></a>NAT 网络地址转换</h2><ol>
<li>NAT允许局域网内的主机共享一个公共IP，以接入因特网。<ol>
<li>解决了IP地址不足的问题。</li>
<li>有效的避免了来自网络外部的攻击，隐藏并保护网络内部的计算机。</li>
<li>NAT路由器：公网和私网之间的网关，负责管理流入和流出的数据包。</li>
<li>NAT路由器通过维护一个查找表来实现私有IP和公有IP的地址转换。</li>
<li>使用NAT设备时，互联网的流入流量不能到达内部网络，能够阻 止来自外部网络的威胁。</li>
</ol>
</li>
</ol>
<h2 id="TCP会话劫持"><a href="#TCP会话劫持" class="headerlink" title="TCP会话劫持"></a>TCP会话劫持</h2><ol>
<li><p><strong>TCP序列号预测攻击</strong> 通过预测TCP会话的初始序列号，以建立伪造的TCP会话。之后</p>
<ol>
<li>发动拒绝服务攻击</li>
<li>向服务器发送SYN，将源IP地址伪造成受害者客户端IP。</li>
<li>在等待服务器向客户端发送响应之后，攻击者通过发送一个 ACK数据包来结束TCP握手，该数据包的序列号是预测的下一个序列号；</li>
<li>攻击者以受害客户端名义向服务器发送请求。</li>
</ol>
</li>
<li><p><strong>盲注入</strong>：在TCP序列预测攻击中使用了IP欺骗，所以攻击者无法从服务器收到任何响应。盲注入允许攻击者使用请求者的源IP地址来执行某些命令，从而破坏系统。</p>
</li>
<li><p><strong>ACK风暴</strong>：盲注入后客户端不会向服务器发送同步消息，导致不同步。此时，客户端和服务端都会向对方发送ACK消息，来告知对方需要开始使用正确的序列号。这种反复的通信称为ACK风暴。</p>
</li>
<li><p><strong>完全会话劫持</strong>：当攻击者与目标服务器或客户端在同一网段时，攻击者可以通过数据包嗅探攻击，直到建立会话时的数据包序列号，从而完全劫持会话。</p>
</li>
<li><p><strong>防范会话劫持</strong>：</p>
<ol>
<li>在IP层或者应用层使用认证和加密，如IPSec或者应用层安全协议。</li>
<li>网站应避免创建以安全身份验证措施开始，但后来切换到未加密交 换的会话，这样会产生TCP会话劫持攻击的风险。</li>
</ol>
</li>
</ol>
<h1 id="Dos攻击"><a href="#Dos攻击" class="headerlink" title="Dos攻击"></a>Dos攻击</h1><ol>
<li><strong>拒绝服务攻击</strong>亦称洪水攻击，其目的在于使目标电脑的网络或系统 资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</li>
<li><strong>分布式拒绝服务攻击</strong>：使用多台僵尸机发起攻击。</li>
<li>症状：网络异常缓慢(打开文件或访问网站)、特定网站无法访 问、无法访问任何网站、垃圾邮件的数量急剧增加、无线或有线网 络连接异常断开、长时间尝试访问网站或任何互联网服务时被拒绝、 服务器容易断线、卡顿等。</li>
</ol>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol>
<li><p>带宽消耗：</p>
<ol>
<li>ICMP洪水攻击：通过向未良好设置的路由器发送广播信息以占用系统资源 。</li>
<li>UDP洪水攻击：大量UDP数据包发送给受害系统，可能会导致带宽。</li>
<li>死亡之ping：产生超过IP协议能容忍的数据包数，可能会导致死机。</li>
<li>泪滴攻击：数据在发送前都会经过切割，每个小切割都会记录位移的信息，以 便重组。此攻击模式就是捏造位移信息，导致重组时发生问题，造成错误。</li>
</ol>
</li>
<li><p>资源消耗型</p>
<ol>
<li>SYN 洪水攻击：大量TCP SYN请求反复发送，导致系统资源耗尽。</li>
<li>LAND攻击：与SYN floods类似，会导致被攻击的机器死循环。</li>
<li>分布式HTTP洪水攻击：使用代理服务器向受害服务器发送大量貌似合法的请 求，通常使用HTTP GET。</li>
<li>僵尸网络攻击：大量被命令与控制服务器所控制的互联网主机群协同攻击。</li>
</ol>
</li>
</ol>
<h2 id="ICMP-攻击"><a href="#ICMP-攻击" class="headerlink" title="ICMP 攻击"></a>ICMP 攻击</h2><ol>
<li><strong>ping洪水攻击</strong>：通过功能强大的计算机向单个受害服务器发送大量 回显请求命令。这样受害服务器会被这些网络流量 淹没，无法响应合法的请求。</li>
<li><strong>Smurf攻击</strong>：攻击者向网络广播地址发送ICMP包，并将回复地址 设置成受害网络的广播地址，通过使用ICMP应答请求数据包来淹 没受害主机的方式进行。</li>
<li><strong>阻止Smurf攻击</strong>：<ol>
<li>管理员应该将网络中的主机和路由器配置 为忽略广播请求；</li>
<li>避免直接向广播地址转发数据包；</li>
<li>忽略 ping请求。</li>
</ol>
</li>
</ol>
<h2 id="SYN洪水攻击"><a href="#SYN洪水攻击" class="headerlink" title="SYN洪水攻击"></a>SYN洪水攻击</h2><ol>
<li><p>攻击者故意延迟或不发送握手确认。</p>
</li>
<li><p><strong>过程</strong>：</p>
<ol>
<li>假设连接发起方是A，接受方是B。A发送SYN消息给B，B反馈 SYN-ACK消息给A，使连接进入半开状态。此时B会给每个半开连 接都设一个Timer，如果超过时间还没有收到A的ACK消息，则重 新发送一次SYN-ACK消息给A，直到重试超过一定次数时才会放弃。</li>
<li>攻击方A可以控制肉鸡向B发送大量SYN消息但不响应ACK消息， 或者干脆伪造SYN消息中的Source IP，使B反馈的SYN-ACK消息 石沉大海，导致B被大量注定不能完成的半开连接占据，直到资源 耗尽，停止响应正常的连接请求。</li>
</ol>
</li>
<li><p><strong>防范</strong></p>
<ol>
<li><strong>SYN Cookie机制</strong>：在TCP服务器接收到TCP SYN包并返回TCP SYN+ACK包时，不分配专门的数据区，而是根据SYN包计算一个 cookie值。 这个cookie作为将要返回的SYN-ACK包的初始序列号。</li>
</ol>
</li>
<li><p>SYN + ACK包的32比特结构如下：</p>
<ol>
<li>前5比特是时间戳，由每分 钟按模32递增的计数器实现</li>
<li>中间3比特是编码值，表示传输段 的最大值</li>
<li>最后24比特是基于密钥k，由服务器和客户端IP地址，端口号和前面使用的时间戳计算出来的MAC值。</li>
</ol>
</li>
<li><p>当客户端返回一个ACK包时</p>
<ol>
<li>服务器首先根据其前5比特判断是否 过期；</li>
<li>服务器根据包头信息重新计算24比特的MAC值，与返回的确认序列号(初始序列号 + 1)进行对比；</li>
<li>服务器对中间3 比特进行解码，完成对SYN队列项的重构。如果验证通过，则服务 器发起TCP会话。</li>
</ol>
</li>
<li><p>Optimistic TCP ACK攻击</p>
<ol>
<li>利用TCP的拥塞控制机制。在TCP的华东窗口协议中，虽则接收ACK的增多，窗口大小增大。</li>
<li><strong>攻击</strong> 恶意客户端在没有收到SYN-ACK时，就提前发送ACK，使得服务 器增加其传输速度。如果同时针对多台服务器进行TCP ACK攻击，它会通过淹 没网络带宽资源，导致互联网范围内的拥塞。</li>
<li><strong>防御</strong> 设置对每个客户端最大流量的限制。</li>
</ol>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导第6章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC6%E7%AB%A0/"
    >计安导第6章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC6%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.494Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="DNS-域名系统"><a href="#DNS-域名系统" class="headerlink" title="DNS 域名系统"></a>DNS 域名系统</h1><ol>
<li><p>DNS是应用层协议，负责将域名映射到IP地址。</p>
</li>
<li><p>DNS数据库包括</p>
<ol>
<li>地址记录：与主机名相关链的IP地址。</li>
<li>邮件交换记录：域的邮件服务器。</li>
<li>名称服务器记录：域的权威服务器。<h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2></li>
</ol>
</li>
<li><p>DNS：建立IP和域名间的映射</p>
</li>
<li><p>HTTP:用来浏览网页</p>
</li>
<li><p>SSL/TLS: 以安全的、加密的方式浏览网页的协议(<strong>HTTPS</strong>)</p>
</li>
<li><p>IMAP/POP/SMAP:用于互联网电子邮件</p>
</li>
<li><p>SOAP：用于交换作为网络服务模式部分的结构化数据</p>
</li>
<li><p>talent：远程访问协议(与FTP一样，不提供加密)</p>
</li>
<li><p>SSH:较新的安全远程访问和管理协议</p>
<h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2></li>
<li><p>域名：最右为顶级域名(TLD)</p>
</li>
<li><p>域名服务器从上至下依次为</p>
<ol>
<li>根域名服务器：管理顶级域名.</li>
<li>顶级域名服务器:如.com。其中保存的每条记录都对应一个权威域名服务器</li>
<li>权威域名服务器<h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2></li>
</ol>
</li>
<li><p>区域：具有相同权威DNS服务器的已连接节点的集合。</p>
</li>
<li><p>域名解析：</p>
<ol>
<li><p>迭代解析</p>
<img src="/计安导_img/2.png"  />
</li>
<li><p>递归解析</p>
<img src="/计安导_img/3.png"  />    

</li>
</ol>
</li>
</ol>
<h2 id="权威域名服务器"><a href="#权威域名服务器" class="headerlink" title="权威域名服务器"></a>权威域名服务器</h2><ol>
<li>权威域名服务器层次结构：权威域名服务器也是分层的，每个域名服务器都存储着记录的集合，每个记录提供域名地址或者对该域权威域名服务器的引用。</li>
<li>作用：控制在权威域名服务器(ANS)之间分配<ol>
<li>负责特定域</li>
<li>可以为子域指定其他ANS</li>
</ol>
</li>
</ol>
<h2 id="DNS数据包"><a href="#DNS数据包" class="headerlink" title="DNS数据包"></a>DNS数据包</h2><ol>
<li>DNS查询和应答是通过UDP实现的，但当请求超过512时，会采用TCP。</li>
<li>DNS查询通常通过端口53上的UDP发出。<h3 id="组成："><a href="#组成：" class="headerlink" title="组成："></a>组成：</h3></li>
<li>头：包含16为查询标识符，用于标识查询和响应</li>
<li>查询部分：由问题序列组成，每个问题由所查询域名和查询记录的类型组成。</li>
<li>应答部分包括<ol>
<li>NAME 包含一个全域名</li>
<li>2B的TYPE 标识DNS记录的类型</li>
<li>2B的CLASS域 标识更广泛的类型</li>
<li>4B的TTL 标识有效时间</li>
<li>2B的RDLENGTH 标识数据段的长度</li>
<li>可变长RDATA段 包括实际的记录数据</li>
</ol>
</li>
</ol>
<h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><ol>
<li>目的：如果每个查询都遍历DNS树会导致根区域过载</li>
<li>缓存有效期：由ANS回复的TTL指定。</li>
<li>由操作系统和浏览器维护缓存<h2 id="DNS-攻击：-网络嫁接与网络钓鱼"><a href="#DNS-攻击：-网络嫁接与网络钓鱼" class="headerlink" title="DNS 攻击： 网络嫁接与网络钓鱼"></a>DNS 攻击： 网络嫁接与网络钓鱼</h2></li>
<li><strong>过程</strong> 攻击者把网站发送请求解析成子集恶意服务器的伪装IP地址，导致受害人浏览或下载伪造的内容。 </li>
<li><strong>用途</strong> 伪造王章</li>
</ol>
<h2 id="DNS-缓存中毒"><a href="#DNS-缓存中毒" class="headerlink" title="DNS 缓存中毒"></a>DNS 缓存中毒</h2><ol>
<li><p><strong>思想</strong> 攻击者欺骗DNS服务器缓存保存虚假的DNS记录。</p>
 <img src="/计安导_img/4.png"  />

 <img src="/计安导_img/5.png"  />

 <img src="/计安导_img/6.png"  />
</li>
<li><p><strong>检测</strong> DNS使用16位请求标识符将查询ID与响应ID配对。当服务器</p>
<ol>
<li><p>忽略标识符</p>
</li>
<li><p>具有可预测的ID</p>
</li>
<li><p>接受未经请求的DNS记录</p>
<p>说明可能中毒了</p>
</li>
</ol>
</li>
<li><p>防御DNS缓存中毒</p>
<ol>
<li>对查询使用随机标识符 </li>
<li>始终检查标识符 </li>
<li>DNS请求的端口随机化</li>
<li>部署DNSSEC（DNS协议的安全扩展集）</li>
</ol>
</li>
</ol>
<h2 id="DNS缓存中毒和生日悖论"><a href="#DNS缓存中毒和生日悖论" class="headerlink" title="DNS缓存中毒和生日悖论"></a>DNS缓存中毒和生日悖论</h2><blockquote>
<p>DNS 协议交换不验证对递归迭代查询的响应。验证查询只会检查 16 位事务 ID 以及响应数据包的源 IP 地址和目标端口。在 2008 年之前，所有 DNS 使用固定端口53 解析.因此，除了事务 ID 之外，欺骗 DNS 回复所需的所有信息都是可预测的。用这种弱点攻击 DNS 被称为“生日悖论”，平均需要 256 次来猜测事务 ID。为了使攻击成功，伪造的 DNS 回复必须在合法权威响应之前到达目标解析器。如果合法响应首先到达，它将由解析器缓存，并且直到其生存时间（TTL）到期，解析器将不会要求权威服务器解析相同的域名，从而防止攻击者中毒映射该域，直到 TTL 到期。</p>
</blockquote>
<h2 id="DNSSEC"><a href="#DNSSEC" class="headerlink" title="DNSSEC"></a>DNSSEC</h2><blockquote>
<p>DNSSEC 采用基于公共密钥加密的数字签名，从而增强 DNS 验证强度。DNSSEC 并非对 DNS 查询和响应本身进行加密签名，而是由数据所有者对 DNS 数据自身进行签名。</p>
</blockquote>
<blockquote>
<p>每一个 DNS 区均包含一个公私秘钥对。DNS 区所有者使用该区域的私钥对区域内的 DNS 数据进行签名，为这些数据生成数字签名。顾名思义，”私钥”是指 DNS 区所有者会对这些密钥材料保密。但是，该区域的公钥则在区域内公开发布，供全体用户检索。凡在区域内查找数据的递归解析器，还必需检索区域公钥，从而使用公钥验证 DNS 数据的真实性。解析器确认检索到的 DNS 数据的数字签名是否有效。如果有效，证明 DNS 数据合法，则将 DNS 数据返回给用户。如果签名未通过验证，解析器会假设发生攻击，丢弃数据并向用户返回错误。</p>
</blockquote>
<ol>
<li><p>目的：验证</p>
<ol>
<li>DNS回答来源的真实性</li>
<li>回复的完整性</li>
<li>拒绝存在的真实性</li>
</ol>
</li>
<li><p>通过在每一步中对DNS回复签名来实现这一点</p>
</li>
<li><p>使用公钥加密对所有DNS应答进行数字签名</p>
</li>
<li><p>通常使用信任锚，操作系统中的条目来引导进程</p>
</li>
<li><p>现状：加入安全机制后，数据包会远大于512B的UDP数据包。</p>
</li>
</ol>
<h1 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h1><ol>
<li><p>定义：防火墙是一种集成的安全措施集合，旨在防止对网络计算机 系统未经授权的访问。</p>
</li>
<li><p>防火墙策略：</p>
<ol>
<li>接收</li>
<li>拒绝</li>
<li>丢弃</li>
</ol>
</li>
<li><p>数据包匹配：基于数据包的一些特性。</p>
</li>
</ol>
<h2 id="黑名单与白名单"><a href="#黑名单与白名单" class="headerlink" title="黑名单与白名单"></a>黑名单与白名单</h2><h3 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h3><ol>
<li>默认规则为接收，只拒绝/丢弃黑名单定义的规则匹配到的数据包。</li>
</ol>
<h3 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h3><ol>
<li>默认规则拒绝，只接收白名单规则匹配到的数据包。</li>
</ol>
<h2 id="防火墙分类"><a href="#防火墙分类" class="headerlink" title="防火墙分类"></a>防火墙分类</h2><ol>
<li>数据包过滤器(无状态防火墙)：如果数据包与数据包过滤器的规则集匹配，则数据包过滤器将丢弃或者接受他。</li>
<li>状态过滤器(状态防火墙)：一种能够提供状态数据包检查或状态查看功能的防火墙，能够持续追踪穿过这个防火墙的各种网络连接（例如TCP与UDP连接）的状态。这种防火墙被设计来区分不同连接种类下的合法数据包。只有匹配主动连接的数据包才能够被允许穿过防火墙，其他的数据包都会被拒绝。</li>
<li>应用层防火墙：当内部计算机与外部主机连结时，将由代理服务器（Proxy Server）担任内部计算机与外部主机的连结中继者。使用ALG的好处是隐藏内部主机的地址和防止外部不正常的连接，如果代理服务器上未安装针对该应用程序设计的代理程序时，任何属于这个网络服务的封包将完全无法通过防火墙。</li>
</ol>
<h3 id="无状态防火墙"><a href="#无状态防火墙" class="headerlink" title="无状态防火墙"></a>无状态防火墙</h3><ol>
<li>将每个尝试通过它的数据包视为独立的，而不考虑前后数据包间的关系。</li>
<li>因此必须具有严格的限制性</li>
</ol>
<h3 id="状态防火墙"><a href="#状态防火墙" class="headerlink" title="状态防火墙"></a>状态防火墙</h3><ol>
<li>可以区分数据包是否是<strong>受信任网络</strong>内发起的<strong>合法会话</strong>的一部分。</li>
<li>状态防火墙维护一些表，表中包含每个活动<strong>连接的信息</strong>， 包括<strong>IP地址、端口和数据包的序列号</strong>。通过这些表，可以只允许响应内部网发起连接的TCP数据包流入。</li>
<li><strong>对于TCP</strong> 一旦完成初始的握手，且也允许数据包通过防火墙，则该连接的所有后续通信都允许通过防火墙，直到连接终止。</li>
<li><strong>对于UDP</strong> 由于UDP没有握手过程，所以一般情况下，当防火墙允许合法UDP通过</li>
</ol>
<h3 id="应用层防火墙"><a href="#应用层防火墙" class="headerlink" title="应用层防火墙"></a>应用层防火墙</h3><ol>
<li>基于进入或流出网络数据包的实际内容来管理流量，而不是仅仅分析源和目的。<h3 id="现状：基于深度数据包检测技术"><a href="#现状：基于深度数据包检测技术" class="headerlink" title="现状：基于深度数据包检测技术"></a>现状：基于深度数据包检测技术</h3></li>
</ol>
<h1 id="隧道—-gt-TCP"><a href="#隧道—-gt-TCP" class="headerlink" title="隧道—-&gt;TCP"></a>隧道—-&gt;TCP</h1><ol>
<li><strong>问题</strong> 由于TCP本身是不加密的，如果有人窃听TCP连接，就可以知道有效载荷中的全部内容。</li>
<li><strong>解决</strong> 使用隧道协议，无需改变软件的执行就能防止窃听，并且加密是自动的。</li>
<li><strong>缺点</strong> 需要在传输层或网络层协议中使用应用层概念，增加了协议栈的开销。<h2 id="安全的Shell-SSH-gt-Telnet-FTP-rlogin等早期远程管理协议"><a href="#安全的Shell-SSH-gt-Telnet-FTP-rlogin等早期远程管理协议" class="headerlink" title="安全的Shell (SSH) -&gt;Telnet,FTP,rlogin等早期远程管理协议"></a>安全的Shell (SSH) -&gt;Telnet,FTP,rlogin等早期远程管理协议</h2></li>
<li>使用对称和公钥密码技术加密通信。</li>
<li>常用于<strong>安全隧道</strong>，目的是使窃听者无法推断出SSH流量的内容，使用SSH建立的隧道能防止许多基于数据包嗅探的攻击。</li>
<li><strong>安全的交互式命令会话</strong>过程：<ol>
<li>客户端通过一个TCP会话连接到服务器</li>
<li>客户端与服务器交换管理细节的信息，如支持的加密方法、各 自协议的版本，每一方都要选择另一方支持的一组协议</li>
<li>客户端和服务器进行密钥交换，创建共享的秘密会话密钥，用 会话密钥加密双方的通信（但不用于身份验证）。这个会话密 钥配合选择的块加密（通常是AES、3DES、Blowfish或IDEA） 来加密所有后续的通信</li>
<li>服务器向客户端发送可以接受身份验证列表，客户端将按顺序尝 试。最常见的机制是使用密码或以下的公共密钥身份验证方法：<ol>
<li>如果选定的机制是<strong>公共密钥身份验证</strong>，则客户端向服务器发送<strong>自己的</strong>公钥；</li>
<li>然后服务器检查是否这密钥已存储在其授权的密钥列表之中。如果在， 服务器使用客户的<strong>公钥加密挑战</strong>，并将其发送给客户端；</li>
<li>客户用自己的私钥解密挑战，并向服务器发回响应，证明自己的身份；</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="IPSec–-gt-IP"><a href="#IPSec–-gt-IP" class="headerlink" title="IPSec–&gt;IP"></a>IPSec–&gt;IP</h2><p>IPSec协议族在网络层保证应用程序的安全，为数据包提供机密性和真实性。且协议族中每个协议都能运行在<strong>传输模式</strong>或<strong>隧道模式</strong>下</p>
<ol>
<li><strong>传输模式</strong>：在原数据包的数据之前，插入额外的IPSec的头信息，只对数据包的有效载荷继续加密或身份验证。</li>
<li><strong>隧道模式</strong>：构造一个新的数据包，将IPSec头信息和整个原数据包一起封装进新数据包的有效载荷中。</li>
</ol>
<h2 id="VPN-虚拟专用网"><a href="#VPN-虚拟专用网" class="headerlink" title="VPN 虚拟专用网"></a>VPN 虚拟专用网</h2><p>分为 <strong>远程访问VPN</strong>和<strong>站点到站点的VPN</strong></p>
<h3 id="远程访问VPN"><a href="#远程访问VPN" class="headerlink" title="远程访问VPN"></a>远程访问VPN</h3><p>允许授权的用户通过安装在自己电脑上的客户端通过NAS访问私有网络，即内网。</p>
<ol>
<li><strong>网路接入服务器(NAS)</strong>：VPN服务端</li>
</ol>
<h3 id="站点到站点的VPN"><a href="#站点到站点的VPN" class="headerlink" title="站点到站点的VPN"></a>站点到站点的VPN</h3><p>旨在为<strong>两个或更多</strong>远程网络提供安全的桥梁。两个网络各有一个独立的VPN端点，两端点之间相互通信。</p>
<h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><ol>
<li><p>使用点对点的隧道协议 PPTP</p>
<p> 首先使用PPP建立连接，然后封装PPP帧，然后用MPPE对其加密，最后通过互联网发送数据包。</p>
</li>
</ol>
<h2 id="隧道存在的安全风险"><a href="#隧道存在的安全风险" class="headerlink" title="隧道存在的安全风险"></a>隧道存在的安全风险</h2><ol>
<li>会规避防火墙的策略。当使用隧道技术时，会不同的传输协议对一系列网络数据包的有效载荷进行封装。同时，在隧道协议中也对有效载荷进行了加密，所以深度数据包检测也毫无用处。</li>
<li>如果内部用户通过隧道直接和外部服务器连接，并代表该用户向禁止访问的网站路由HTTP流量，同样通过隧道，将响应返回给该用户。相应的，攻击者也可以通过隧道规避防火墙。</li>
</ol>
<h1 id="入侵检测"><a href="#入侵检测" class="headerlink" title="入侵检测"></a>入侵检测</h1><h2 id="入侵检测系统-IDS"><a href="#入侵检测系统-IDS" class="headerlink" title="入侵检测系统 IDS"></a>入侵检测系统 IDS</h2><p>IDS 是一个软件或硬件系统，用于检测网络或个人计算机上恶意活动的迹象。</p>
<ol>
<li><p>分类： 按功能分</p>
<ol>
<li><p>IDS传感器，用于收集网络组件或计算机的实时数据</p>
</li>
<li><p>IDS管理器，用于接收来自传感器的报告</p>
</li>
<li><p><strong>关系</strong>：IDS管理器编译来自IDS传感器的数据，以确定是否发生了入侵。以此确定基于一组站点策略，这些策略是定义可能入侵的规则和条件。如果 IDS管理员检测到入侵，则会发出警报。</p>
</li>
</ol>
</li>
<li><p>IDS所检测的威胁包括</p>
<ol>
<li>伪装者：冒用合法用户的身份或凭据来获得对计算机系统或网络的访问的攻击者</li>
<li>违反者：执行了未经授权的操作的合法的用户</li>
<li>秘密用户：通过删除审计文件或系统日志，试图组织或掩盖自己行为的用户</li>
</ol>
</li>
<li><p>IDS所检测的攻击包括</p>
<ol>
<li><strong>端口扫描</strong>：是指某些别有用心的人发送一组端口扫描消息，试图以此侵入某台计算机，并了解其提供的计算机网络服务类型。攻击者可以通过它了解到从哪里可探寻到攻击弱点。</li>
<li><strong>拒绝服务攻击</strong>：网络攻击淹没主机，并将合法访问拒之门外</li>
<li><strong>恶意软件攻击</strong>：复制恶意软件的攻击，特洛伊木马、计算机蠕虫和病毒等</li>
<li>ARP欺骗：试图重定向局域网中的IP流量</li>
<li><strong>DNS缓存中毒</strong>：网络嫁接攻击旨在改变主机的DNS缓存，以创建伪造的域名/IP 地址的关联</li>
</ol>
</li>
</ol>
<h2 id="入侵检测技术"><a href="#入侵检测技术" class="headerlink" title="入侵检测技术"></a>入侵检测技术</h2><ol>
<li><p>传统的网络入侵检测系统（NIDS）</p>
<p> – 位于网络边界，基于<strong>流量模式和内容</strong>检测恶意的行为；</p>
</li>
<li><p>基于入侵检测系统的协议（PIDS）</p>
<p> – <strong>专门检测特定协议中的恶意行为</strong>，通常部署在特定的网络主机中。如 Web服务器可以运行PIDS来分析流入的HTTP流量，丢弃恶意的或包含错误的请求</p>
</li>
<li><p>基于主机的IDS（HIDS）</p>
<p> – 驻留在单个系统之中，<strong>监控这台计算机上的活动</strong>。如系统调用，进程间 的通信和资源使用模式</p>
</li>
</ol>
<h2 id="IDS攻击"><a href="#IDS攻击" class="headerlink" title="IDS攻击"></a>IDS攻击</h2><p>通过对IDS本身发动Dos攻击，故意触发大量入侵警报。直到淹没IDS，使他无法记录每个事件，或让管理员很难确定哪些日志代表攻击。</p>
<h2 id="入侵检测错误"><a href="#入侵检测错误" class="headerlink" title="入侵检测错误"></a>入侵检测错误</h2><p>包括：</p>
<ol>
<li>误报：当事件是良性活动而不是入侵时就发出警报，导致时间和资源的浪费。</li>
<li>漏报：当事件是入侵的恶意事件，却未发出警报。</li>
</ol>
<h3 id="基率谬误"><a href="#基率谬误" class="headerlink" title="基率谬误"></a>基率谬误</h3><p>由于基率谬误的存在，可能使某些IDS的有效性被误解。所以，当评估某些条件事件的概率而不考虑该事件的“基本概率”时，会发生此类错误。例如：</p>
<ol>
<li><p>假设IDS准确度为99％，假阳性或假阴性的概率为1％。 </p>
</li>
<li><p>假设入侵检测系统生成1,000,100个日志条目。 1,000,100个条目中只有100个对应于实际的恶意事件。 </p>
</li>
<li><p>由于IDS的成功率，在100个恶意事件中，99个将被检测为恶意，这意 味着我们有1个假阴性。 </p>
</li>
<li><p>然而，在1,000,000个良性事件中，10,000个将被错误地识别为恶意事件。 </p>
</li>
<li><p>因此，将共有10,099个警报响起，其中10,000个是误报警。也就是说，大约99％的警报都是误报警。</p>
</li>
</ol>
<h2 id="IDS数据收集和审计记录"><a href="#IDS数据收集和审计记录" class="headerlink" title="IDS数据收集和审计记录"></a>IDS数据收集和审计记录</h2><ol>
<li><p>入侵检测的输入是确定网络或主机操作基本的记录流</p>
</li>
<li><p>记录流中操作的类型包括：</p>
<ol>
<li>基于网的IDS，包括每次HTTP会话尝试、每次登录尝试、每 次TCP绘画的初始化等；</li>
<li>基于主机的IDS，包括对文件的读、写或执行</li>
</ol>
</li>
<li><p>IDS传感器检测这些操作，创建这些操作的特征。将这 些记录报告给IDS管理器或者将它们写入审计日志</p>
</li>
<li><p>IDS事件记录包括：主体，对象，操作，异常条件，占用的资源，时间戳。</p>
</li>
</ol>
<h2 id="入侵检测系统的类型"><a href="#入侵检测系统的类型" class="headerlink" title="入侵检测系统的类型"></a>入侵检测系统的类型</h2><h3 id="基于规则的入侵检测"><a href="#基于规则的入侵检测" class="headerlink" title="基于规则的入侵检测"></a>基于规则的入侵检测</h3><ol>
<li><p><strong>规则</strong>标识与入侵攻击的某些已知<strong>配置文件匹配的操作类型</strong>，在这种情况下， 规则将编码此类攻击的<strong>签名</strong>。因此，如果IDS管理器看到与该规则的签名匹配的事件，它将立即发出警报，甚至可能指示怀疑的类型。</p>
</li>
<li><p><strong>优点</strong>：减少了误报，因为决策者已经明确了规则列表。</p>
</li>
<li><p><strong>缺点</strong>：存在局限性，因为它需要IDS具有每一个攻击类型的特征。</p>
<h3 id="基于统计的入侵检测"><a href="#基于统计的入侵检测" class="headerlink" title="基于统计的入侵检测"></a>基于统计的入侵检测</h3></li>
<li><p>构建了一个配置文件，它是用户行为或主机使用的<strong>典型方式</strong>的统计表示； 因此，它可用于确定用户或主机何时以非常不寻常的<strong>异常方式</strong>运行。</p>
</li>
</ol>
<h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><ol>
<li><p>允许用户列举计算机的哪个端口正在接受连接的技术。端口的状态包括：开放的，关闭的，阻塞的。</p>
</li>
<li><p>端口扫描的方法：</p>
<ol>
<li><p>TCP扫描/连接扫描：向目标主机的每个端口发起TCP连接。完成连接的端口是开放的，否则要么是关闭的，要么是阻塞的。</p>
</li>
<li><p>SYN扫描：向目标主机端口发起SYN标志的数据包，看是否有SYN-ACK返回。(如果收到，则发出一个RST数据包终止连接而非完成握手)</p>
</li>
<li><p>空闲扫描：它允许进行端口完全欺骗扫描。使得攻击者能够不使用自己的IP向目标主机发送数据包。它的巧妙之处在于，利用不活跃的“僵尸主机”反弹给攻击者一个旁通信道，从而使得攻击者可以进行端口扫描。入侵检测系统也就会把无辜的僵尸主机当成攻击者。利用僵尸可预测的TCP序列号实现。其过程如下：</p>
<ol>
<li>探测僵尸主机的IP ID 并记录。</li>
<li>向需要扫描的目标主机端口发送一个伪造成来自僵尸主机的SYN包。根据目标主机端口状态的不同，目标主机返回的数据包会使得僵尸主机的IP ID递增或否。</li>
<li>再次探测僵尸主机的IP ID。并对比第一步记录的IP ID就可以确定目标主机端口的状态。如果序列号递增了，则表示目标端口是开放的。否则，目标端口是关闭或阻塞的。</li>
</ol>
</li>
<li><p>UDP扫描：向目标主机端口发送UDP数据包。</p>
</li>
</ol>
</li>
</ol>
<h2 id="蜜罐"><a href="#蜜罐" class="headerlink" title="蜜罐"></a>蜜罐</h2><p>使用一台计算机作为诱饵的入侵检测技术。其优点包括</p>
<ol>
<li><p>入侵检测：因为连接到蜜罐的尝试不会来自合法用户，所以 对蜜罐的任何连接都被安全地确定为入侵。</p>
</li>
<li><p>证据：蜜罐计算机中有吸引力的文件使入侵者逗留并留下证据，从而识别出入侵者或者确定他的位置。</p>
</li>
<li><p>导流：与合法计算机相比，蜜罐对入侵者更有吸引力，从而分散入侵者对敏感信息和服务的注意力。</p>
</li>
</ol>
<h1 id="无线网"><a href="#无线网" class="headerlink" title="无线网"></a>无线网</h1><p>无线网引入安全问题包括：</p>
<ol>
<li>使得<strong>数据包嗅探</strong>更加容易。因为同一个网段的所有计算机都共享一个无线接入点。</li>
<li>使得<strong>会话劫持</strong>更加容易。因为配有无线适配器的计算机都可以嗅探出数据包并模拟无线接入点。</li>
<li>存在<strong>入侵</strong>问题。入侵指未授权用户通过其他人的无限接入点连接到互联网。</li>
<li>验证<strong>合法用户</strong>的难度增加。通过在局域网中主机的位置来验证合法主机再不可能，需要其他的身份验证或授权方法。</li>
</ol>
<h2 id="无线网结构"><a href="#无线网结构" class="headerlink" title="无线网结构"></a>无线网结构</h2><img src="/计安导_img/7.png"  />    

<ol>
<li>基于802.11标准。大多数的TCP/IP实现会根据不同的接收者重新定义数据包，即802.11帧和以太网帧的相互转换。</li>
<li>结构<ol>
<li>客户端计算机与接入点建立无线连接。</li>
<li>无线接入点连接到有线网络的接入点提供到互联网的网关。</li>
</ol>
</li>
</ol>
<h2 id="SSID-服务集ID"><a href="#SSID-服务集ID" class="headerlink" title="SSID (服务集ID)"></a>SSID (服务集ID)</h2><ol>
<li>SSID 32个字符组成的网络标识，使得多个无线网络可以共存。<ol>
<li>制造商的名称是接入点的典型默认SSID。</li>
<li>经常广播SSID可以使潜在用户能够发现网络</li>
</ol>
</li>
<li><strong>问题</strong> ：由于SSID未被签名，所以可以进行欺骗攻击<ol>
<li>将恶意接入点放置在公共场所（例如，咖啡馆，机场）； </li>
<li>使用ISP的SSID</li>
<li>设置类似于ISP的登录页面； </li>
<li>等待客户端连接到恶意接入点并进行身份验证；</li>
<li>可能会转发到ISP网络的会话；</li>
<li>由自动连接默认值促成</li>
</ol>
</li>
</ol>
<h2 id="强制网络门户"><a href="#强制网络门户" class="headerlink" title="强制网络门户"></a>强制网络门户</h2><ol>
<li><p><strong>定义</strong>：是公共接入网络的用户在授予访问权限之前必须查看和交互的网页。通常 用于商业中心、机场、酒店大堂、咖啡店等为用户提供免费Wi-Fi的场所</p>
</li>
<li><p><strong>协议</strong></p>
<ol>
<li><p>通过MAC地址定位客户端。</p>
</li>
<li><p>认证完成之前，任何URL都会被重定向到身份验证界面。</p>
<ol>
<li>防火墙会阻止其他流量。</li>
<li>名称服务器会将一切映射到认证服务器。</li>
</ol>
</li>
<li><p>身份验证之后，恢复常规网络服务。由DHCP提供IP地址。</p>
</li>
</ol>
</li>
<li><p><strong>问题</strong> </p>
<ol>
<li>如果客户端没有主动断开连接，则可以执行MAC欺骗和会话窃取。</li>
<li>如果身份验证之前未阻止防火墙之外的DNS流量，则隧道攻击可以绕过强制网络门户。</li>
</ol>
</li>
</ol>
<h2 id="Wardriving-and-Warchalking"><a href="#Wardriving-and-Warchalking" class="headerlink" title="Wardriving and Warchalking"></a>Wardriving and Warchalking</h2><ol>
<li>Wardriving在移动的汽车中，使用移动设备四处寻找无线网。</li>
<li>Warchalking（开战标记）：在公共场所绘制引导公共Wi-Fi网 络的一种绘画符号（源自流浪汉符号）</li>
</ol>
<h2 id="WEP-有线等效保密协议"><a href="#WEP-有线等效保密协议" class="headerlink" title="WEP 有线等效保密协议"></a>WEP 有线等效保密协议</h2><p>###<strong>目标</strong> ：</p>
<ol>
<li>机密性:防止窃听。</li>
<li>数据完整性：保证数据包不被篡改。</li>
<li>访问控制：仅路由正确加密的数据包。<br>###<strong>限制</strong></li>
<li>在数据链路层加密每个帧的主体。</li>
<li>避免传统的802.11标准。</li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>接入点和客户端共享40b的密钥。密钥在WEP会话期间不被更改。</p>
<h3 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h3><ol>
<li>流密码是一种对称加密系统，密文C由明文消息M异或密钥流生成，而密钥流是密钥产生的伪随机数二进制向量S。</li>
<li><strong>流密码是安全的</strong> 因为相同的密钥流永远不会被重用，否则攻击者会得到两个明文消息的异或值，统计攻击就能同时恢复明文和密钥流。<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3></li>
<li>计算消息M(有效载荷部分)的CRC校验和。</li>
<li>选择24b的初始化向量V</li>
<li>使用RC4流密码生成密钥流S(K,V)</li>
<li>计算密文 C=(M||CRC(m))⊕S(K,V)</li>
</ol>
<h3 id="WEP-认证方法"><a href="#WEP-认证方法" class="headerlink" title="WEP 认证方法"></a>WEP 认证方法</h3><p>包括开放系统和共享密钥两种。</p>
<ol>
<li><p><strong>开放系统</strong>身份验证</p>
<p> 客户端无需任何凭证就可以连接接入点。且只能使用正确的密钥发送和接收信息，否则接入点会忽略请求。</p>
</li>
<li><p><strong>共享密钥</strong>身份验证</p>
<p> 在连入接入点之前要先证明自己拥有接入点的WEP密钥。</p>
<ol start="2">
<li>接入点向客户端发起明文挑战，客户端用拥有的密钥加密该明文，并将生成的密文发给接入点。</li>
<li>如果接入点能正确解密，则可连接接入点。</li>
</ol>
</li>
</ol>
<h2 id="消息篡改攻击"><a href="#消息篡改攻击" class="headerlink" title="消息篡改攻击"></a>消息篡改攻击</h2><h3 id="消息篡改"><a href="#消息篡改" class="headerlink" title="消息篡改"></a>消息篡改</h3><p>对于给定一个任意字符串 ，我们想用M’=M⊕▲替换消息M</p>
<p>可以在中途用C’=C⊕(▲||CRC(▲))来替换C。</p>
<ol>
<li>需要直到消息中文本的位置即可</li>
<li><strong>脆弱性原因</strong> CRC检验和是通过XOR</li>
<li><strong>解决</strong> 改用哈希函数</li>
</ol>
<h2 id="IP重定向攻击"><a href="#IP重定向攻击" class="headerlink" title="IP重定向攻击"></a>IP重定向攻击</h2><p>指攻击者利用物理接入点解密数据包，将目的地址修改为恶意主机地址。</p>
<ol>
<li><p>过程为：</p>
<ol>
<li>窃听入站的IP数据包。</li>
<li>将数据包重新发送到由攻击者控制的外部计算机。</li>
<li>接收由接入点解密的数据包。</li>
<li>重复出站数据包。</li>
</ol>
</li>
<li><p>需要修改数据包校验和。校验和的差为：x’-x=(D’H+D’L)-(DH-DL)</p>
</li>
</ol>
<h2 id="重用初始化向量IV"><a href="#重用初始化向量IV" class="headerlink" title="重用初始化向量IV"></a>重用初始化向量IV</h2><h3 id="初始化向量IV"><a href="#初始化向量IV" class="headerlink" title="初始化向量IV"></a>初始化向量IV</h3><ol>
<li>每个数据包一个，24位。</li>
<li>以邮件的明文部分发送。</li>
<li>初始化向量空间过小会导致重用相同的密钥流。</li>
</ol>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li><strong>问题</strong> 重用初始化向量意味着重用密钥流，攻击者获得两条消息的XOR，可以恢复出消息和密钥流。</li>
<li><strong>默认IV存在上述问题</strong></li>
<li><strong>解决</strong> 使用随机IV，且长度要足够长。<h3 id="注入方法"><a href="#注入方法" class="headerlink" title="注入方法"></a>注入方法</h3></li>
<li>假设攻击者知道一个加密消息的一个明文。</li>
<li>利用RC4(X )⊕X⊕Y=RC4(Y),来构造计算CRC32的新消息。</li>
</ol>
<h2 id="身份验证欺骗"><a href="#身份验证欺骗" class="headerlink" title="身份验证欺骗"></a>身份验证欺骗</h2><ol>
<li>不知道密钥的非法用户可以通过窃听身份验证消息。</li>
<li><strong>攻击</strong><ol>
<li>生成挑战R和加密挑战C =(R||CRC(R))⊕S(K,V)</li>
<li>计算密钥流S(K,V)=(R||CRC(R))⊕C</li>
<li>从接入点挑战时重用密钥流S(K,V)</li>
</ol>
</li>
</ol>
<h2 id="慢攻击：WEP嗅探"><a href="#慢攻击：WEP嗅探" class="headerlink" title="慢攻击：WEP嗅探"></a>慢攻击：WEP嗅探</h2><p>通过大量数据包去计算初始化向量IV</p>
<h2 id="快攻击：数据包注入"><a href="#快攻击：数据包注入" class="headerlink" title="快攻击：数据包注入"></a>快攻击：数据包注入</h2><h2 id="WPA-Wi-fi访问保护"><a href="#WPA-Wi-fi访问保护" class="headerlink" title="WPA Wi-fi访问保护"></a>WPA Wi-fi访问保护</h2><p>目的是为了改进WEP</p>
<h3 id="区别WEP"><a href="#区别WEP" class="headerlink" title="区别WEP"></a>区别WEP</h3><ol>
<li>采用128位密钥和48位IV</li>
<li>支持除共享密钥外各种类型的身份验证。</li>
<li>会话期间动态修改密钥。</li>
<li>支持检查完整性的加密。</li>
<li>增加帧计数器防止重放攻击</li>
</ol>
<h3 id="WPA2"><a href="#WPA2" class="headerlink" title="WPA2"></a>WPA2</h3><ol>
<li>使用AES而不是RC4</li>
<li>处理加密，密钥管理和完整性</li>
<li>由反模式提供的MAC与密码块链接（CCMP）一起使用</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导第7章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC7%E7%AB%A0/"
    >计安导第7章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC7%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.478Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h1><h2 id="HTML-超文本标记语言"><a href="#HTML-超文本标记语言" class="headerlink" title="HTML 超文本标记语言"></a>HTML 超文本标记语言</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>静态文档描述语言</li>
<li>支持链接到其他页面或者嵌入图像</li>
<li>通过表单（Forms）将用户输入发送到服务器<h2 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h2></li>
<li>先检索本地DNS，如果没有找到则查询DNS服务器</li>
<li>解析IP地址之后，建立TCP连接</li>
<li>HTTP请求和响应<strong>通过TCP的端口80</strong>传输</li>
<li>不提供数据加密，以明文发送</li>
</ol>
<h2 id="安全套接字层超文本传输协议HTTPS"><a href="#安全套接字层超文本传输协议HTTPS" class="headerlink" title="安全套接字层超文本传输协议HTTPS"></a>安全套接字层超文本传输协议HTTPS</h2><ol>
<li><p>与HTTP语法相同，但使用了安全套接字层SSL或传输层安全TLS</p>
</li>
<li><p>SSL和TLS都依靠证书来验 证服务器的身份，并建立加 密的通信信道</p>
 <img src="/计安导_img/8.png">

</li>
</ol>
<h1 id="网络钓鱼"><a href="#网络钓鱼" class="headerlink" title="网络钓鱼"></a>网络钓鱼</h1><p>通过伪造网页以欺诈的方式获取敏感资料</p>
<h2 id="URL混淆-同源攻击"><a href="#URL混淆-同源攻击" class="headerlink" title="URL混淆    同源攻击"></a>URL混淆    同源攻击</h2><p>注册带有unicode字符的域名，针对相似的字母进行注册。称为<strong>同源攻击</strong></p>
<h2 id="移除或伪造地址栏"><a href="#移除或伪造地址栏" class="headerlink" title="移除或伪造地址栏"></a>移除或伪造地址栏</h2><h1 id="图像崩溃"><a href="#图像崩溃" class="headerlink" title="图像崩溃"></a>图像崩溃</h1><p>由于浏览器的缺陷导致。通过HTML代码创建一个非常大比例的简单图像，可以使IE 崩溃，有时还会使电脑宕机。</p>
<h1 id="可移动代码"><a href="#可移动代码" class="headerlink" title="可移动代码"></a>可移动代码</h1><p><strong>可移动代码</strong> 指可执行、通过网络发送、在目标 电脑上执行的代码程序。包括</p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h2 id="ActiveX控件"><a href="#ActiveX控件" class="headerlink" title="ActiveX控件"></a>ActiveX控件</h2><h3 id="支持签名"><a href="#支持签名" class="headerlink" title="支持签名"></a>支持签名</h3><p>此签名的ActiveX控件要求 用户运行权限。如果获得批准，控件将以与用户相同的权限运行</p>
<h3 id="受信任-不受信任的ActiveX控件"><a href="#受信任-不受信任的ActiveX控件" class="headerlink" title="受信任/不受信任的ActiveX控件"></a>受信任/不受信任的ActiveX控件</h3><ol>
<li><p>可行的发布者：</p>
<ol>
<li>存储在Windows注册表中的列表 </li>
<li>恶意ActiveX控件可以修改注册表，使其发行者可信 </li>
<li>运行该发布者今后所有的插件不需要提示用户</li>
</ol>
</li>
<li><p>未签名的控件</p>
<ol>
<li>浏览器对于未签名的控件会给出一个接受/拒绝的选项</li>
<li>但即使你拒绝该控件，它也已被下载到一个临时文件夹中</li>
<li>如果拒绝，它不会被执行，但也不会被删除</li>
</ol>
</li>
</ol>
<p>###<strong>可以访问用户文件</strong></p>
<h2 id="Java插件"><a href="#Java插件" class="headerlink" title="Java插件"></a>Java插件</h2><h3 id="支持签名-1"><a href="#支持签名-1" class="headerlink" title="支持签名"></a>支持签名</h3><p>###<strong>沙箱执行</strong></p>
<ol>
<li>沙箱：应用程序或脚本在另一个应用程序中首先的运行权限。沙箱只能访问某些文件和设备。</li>
</ol>
<h1 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h1><p>cookie是指存储在计算机上、与特定服务器关联的 一小部分信息。用于在会话中保存状态信息。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>可能包含敏感信息</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol>
<li><strong>会话型cookie</strong>：是浏览器的处理过程中保留的，是暂时性的，当 浏览器关闭时则消除。</li>
<li><strong>持久性cookie</strong>：而持久性的是保存在客户端的硬盘上的，浏览器 关闭也不会消除。</li>
</ol>
<h1 id="跨站脚本-XSS"><a href="#跨站脚本-XSS" class="headerlink" title="跨站脚本 XSS"></a>跨站脚本 XSS</h1><p>用于攻击者将脚本代码注入Web应用程序生成的页面。攻击者通常在有漏洞的程序中插入Javascript， VBScript，ActiveX或Flash以欺骗用户。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>2005 年 Samy 在社交网站Myspace的个人资料中加入 Javascript ，打开该页面 的浏览器将执行该脚本 ― 首先把攻击者加为好友，其次把这段 XSS 复制到被 攻击者的个人资料中。</p>
<p>这算是一种<strong>蠕虫</strong></p>
<h2 id="XSS的发起条件"><a href="#XSS的发起条件" class="headerlink" title="XSS的发起条件"></a>XSS的发起条件</h2><ol>
<li>Web服务器没有对用户输入进行有效性验证或者验证强度不够 ，而又轻易地将它们返回到客户端</li>
<li>允许用户在表格或编辑框中输入不相关字符</li>
<li>存储并允许把用户输入显示在返回给终端的页面上，而没有去 除非法字符或者重新进行编码</li>
</ol>
<h2 id="XSS盗取cookie"><a href="#XSS盗取cookie" class="headerlink" title="XSS盗取cookie"></a>XSS盗取cookie</h2><ol>
<li>首先编写获取cokie的php脚本</li>
<li>向被攻击者服务器页面上注入一段JS代码，用于将被攻击者的cookie传送到我们的服务器。</li>
</ol>
<h2 id="XSS的防御"><a href="#XSS的防御" class="headerlink" title="XSS的防御"></a>XSS的防御</h2><h3 id="基于代理"><a href="#基于代理" class="headerlink" title="基于代理"></a>基于代理</h3><ol>
<li>分析浏览器和Web服务器之间的HTTP通信量</li>
<li>寻找HTML中的特殊字符</li>
<li>执行Web页面之前对它们进行编码</li>
</ol>
<h3 id="使用应用层防火墙"><a href="#使用应用层防火墙" class="headerlink" title="使用应用层防火墙"></a>使用应用层防火墙</h3><ol>
<li>分析HTML页面中可能导致敏感信息泄漏的超链接</li>
<li>对于使用不良请求的一系列链接进行停止操作</li>
</ol>
<h3 id="审计制度"><a href="#审计制度" class="headerlink" title="审计制度"></a>审计制度</h3><p>监视JavaScript代码的执行，并将操作与高级策略进行比较，以 检测恶意行为</p>
<h1 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h1><p>SQL注入：就是通过把SQL命令插入到Web表单提交或输入 域名或页面请求的查询字符串，最终达到欺骗服务器执行恶 意的SQL命令</p>
<h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><ol>
<li>web应用程序从表单中获取用户输入</li>
<li>用户提交的信息用于构建查询</li>
<li>SQL注入攻击涉及在用户输入中放置SQL语句。</li>
</ol>
<h2 id="万能语句-1-or-1"><a href="#万能语句-1-or-1" class="headerlink" title="万能语句 1 or 1"></a>万能语句 1 or 1</h2><h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><ol>
<li>使用预编译语句，绑定变量。</li>
<li>对用户提交的数据和输入参数进行严格过滤。</li>
<li>使用安全函数</li>
<li>摒弃动态SQL语句，改用存储过程来访问和操作数据。</li>
<li>最小权限原则：避免Web直接使用root</li>
</ol>
<h1 id="DoS-拒绝服务攻击"><a href="#DoS-拒绝服务攻击" class="headerlink" title="DoS 拒绝服务攻击"></a>DoS 拒绝服务攻击</h1><p>任何旨在 使计算机或系统不可用或无法执行基本功能的攻击。如TCP 泛滥攻击，DNS放大攻击。</p>
<h2 id="分布式拒绝服务攻击-DDoS"><a href="#分布式拒绝服务攻击-DDoS" class="headerlink" title="分布式拒绝服务攻击 DDoS"></a>分布式拒绝服务攻击 DDoS</h2><ol>
<li>利用控制的大量僵尸计算机同时攻击目标。使得传统DoS攻击不了的高性能服务器也变得不安全。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/8/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/10/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        John Doe
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>