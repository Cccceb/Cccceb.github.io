<!DOCTYPE html>


<html lang="cn" >


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

  <script type="text/javascript"
	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/Bg.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/"></a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-UnixIS命令" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/UnixIS%E5%91%BD%E4%BB%A4/"
    >UnixIS命令</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/UnixIS%E5%91%BD%E4%BB%A4/" class="article-date">
  <time datetime="2020-03-30T02:15:00.560Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="unix-is-命令"><a class="markdownIt-Anchor" href="#unix-is-命令"></a> unix is 命令</h1>
<p>输入正整数n 以及n个文件名，排序后按列优先的方式左对齐输出。假设最长文件名有M字符，则最右边有M字符，其他列都是M+2 字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  #include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">  # pragma warning(disable:4996)</span><br><span class="line">  # define LOCAL</span><br><span class="line">  # ifdef LOCAL</span><br><span class="line">  FILE *fin &#x3D; freopen(&quot;unix命令in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">  FILE *fout &#x3D; freopen(&quot;unix命令out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">  # endif &#x2F;&#x2F; LOCAL</span><br><span class="line">  using namespace std;</span><br><span class="line">  void print(const string &amp;in, int len, char extra) &#123;</span><br><span class="line">&#x2F;&#x2F;输出字符串s，长度不足len时补字符extra</span><br><span class="line">  	cout &lt;&lt; in;</span><br><span class="line">  	for (int i &#x3D; 0; i &lt; len - in.length(); i++) cout &lt;&lt; extra;</span><br><span class="line">  &#125;</span><br><span class="line">  int main() &#123;</span><br><span class="line">  	int n;</span><br><span class="line">  </span><br><span class="line">  	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">  		int m &#x3D; 0;</span><br><span class="line">  		print(&quot;&quot;, 60, &#39;-&#39;);</span><br><span class="line">  		cout &lt;&lt; endl;</span><br><span class="line">  		vector&lt;string&gt; s;</span><br><span class="line">  		for (int i &#x3D; 0; i &lt; n;i++) &#123;</span><br><span class="line">  			string in;</span><br><span class="line">  			cin &gt;&gt; in;</span><br><span class="line">  			s.push_back(in);</span><br><span class="line">  			m &#x3D; max(m, (int)in.length());</span><br><span class="line">  		&#125;</span><br><span class="line">  		sort(s.begin(), s.end());</span><br><span class="line">  </span><br><span class="line">  		&#x2F;*cout &lt;&lt; &quot;**********************************&quot; &lt;&lt; endl;</span><br><span class="line">  		for (int i &#x3D; 0; i &lt; s.size(); i++) cout &lt;&lt; s[i] &lt;&lt; endl;</span><br><span class="line">  		cout &lt;&lt; &quot;**********************************&quot; &lt;&lt; endl;*&#x2F;</span><br><span class="line">  		int cols &#x3D; (60 - m) &#x2F; (m + 2) + 1;</span><br><span class="line">  		int rows &#x3D; (n - 1) &#x2F; cols + 1;</span><br><span class="line">  		for (int r &#x3D; 0; r &lt; rows; r++) &#123;</span><br><span class="line">  			for (int c &#x3D; 0; c &lt; cols; c++) &#123;</span><br><span class="line">  				int idx &#x3D; c * rows + r;</span><br><span class="line">  				if (idx &lt; n) print(s[idx], c &#x3D;&#x3D; cols - 1 ? m : m + 2, &#39; &#39;);</span><br><span class="line">  			&#125;</span><br><span class="line">  			cout &lt;&lt; endl;</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-八皇后问题" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"
    >八皇后问题</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-03-30T02:15:00.560Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>/*<br />
恰好每行每列各放置一个皇后，如果用A[x]表示第x行皇后的列号，则问题变成了一个全排列生成问题。<br />
*/</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
# pragma warning(disable:4996)
# define LOCAL
# ifdef LOCAL
FILE *fin = freopen(&quot;八皇后in.txt&quot;, &quot;r&quot;, stdin);
FILE *fout = freopen(&quot;八皇后out.txt&quot;, &quot;w&quot;, stdout);
# endif 
using namespace std;
int print_num = 1;
int tot = 0;
int n;
int A[100];
int vis[100][100];
void search(int cur) {
ios::sync_with_stdio(false);
if (cur == n) {
	if (print_num &lt;= 3) {
		cout &lt;&lt; A[0];
		for (unsigned int i = 1; i &lt; n; i++)
			cout &lt;&lt; &quot; &quot;&lt;&lt; A[i] ;
		cout &lt;&lt; endl;
		print_num++;
	}
	tot++;
}
else for (unsigned int i = 0; i &lt; n; i++) {
	if (!vis[0][i] &amp;&amp; !vis[1][cur + i] &amp;&amp; !vis[2][cur - i + n]) {
		//对于(i,cur)
		//以cur+i来标识副对角线，cur-i来标识主对角线，由于主对角线可能为负
		//所以要加上n
		A[cur] = i + 1;
		//对于(cur,i)处要么有子要么无子--&gt;回溯的两种情况
		vis[0][i] = vis[1][cur + i] = vis[2][cur - i + n] = 1;
		search(cur + 1);
		vis[0][i] = vis[1][cur + i] = vis[2][cur - i + n] = 0;//非常关键，回溯法中修改的辅助
															 //局部变量，一定要及时恢复原状
	}
}
}
int main() {
	ios::sync_with_stdio(false);
	cin &gt;&gt; n;
	search(0);
	cout &lt;&lt; tot &lt;&lt; endl;
}</code></pre>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-八数码" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%85%AB%E6%95%B0%E7%A0%81/"
    >八数码</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%85%AB%E6%95%B0%E7%A0%81/" class="article-date">
  <time datetime="2020-03-30T02:15:00.560Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="八数码-p1379"><a class="markdownIt-Anchor" href="#八数码-p1379"></a> 八数码 P1379</h1>
<p>有一个3*3的网格，给定一个初始局面，问至少多少步能到达目标局面.</p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p>经典的隐式图最短路径问题。</p>
<h2 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h2>
<ol>
<li>sizeof(字符串)会计算结束符。对于二维的字符数组，对某一行用sizeof不会计算结束符，可能产生问题。</li>
<li>一般的bfs采用队列，但是本题中由于状态是八个元素的信息，所以采用了类似链表的方法近似队列。在编辑书稿中也使用了类似的方式，只不过那个题是dfs，迭代加深搜实现的。</li>
<li>本题可以使用bfs是因为每一步的状态不是无限的。</li>
<li>注意rear<ins>和front</ins>的位置</li>
<li>dist数组是必要的</li>
</ol>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<pre><code>const int maxn = 1000000;
bool bfs();
bool can_insert(int s);
char st[maxn][9];
int dx[] = { 1,-1,0,0 };
int dy[] = { 0,0,1,-1 };   
int dist[maxn];
char goal[] = {&quot;123804765&quot;};
int front, rear;
std::set&lt;int&gt; vis;
int main() {
scanf(&quot;%s&quot;, st[1]);
if (bfs()) printf(&quot;%d&quot;, dist[front]);
else printf(&quot;-1&quot;);
}
bool bfs() {
front = 1, rear = 2;
while (front &lt; rear) {
	if (memcmp(goal,st[front], sizeof(st[front])) == 0) return true;
	int z = 0;
	while (st[front][z] != '0') z++;
	for (int i = 0; i &lt; 4; i++) {
		int newx = z / 3 + dx[i];
		int newy = z % 3 + dy[i];
		if (newx &lt; 0 || newx &gt;= 3 || newy &lt; 0 || newy &gt;= 3) continue;
		int newz = newx * 3 + newy;
		memcpy(st[rear], st[front], sizeof(char)*9);
		st[rear][newz] = st[front][z];
		st[rear][z] = st[front][newz];
		dist[rear] = dist[front] + 1;
		if(can_insert(rear)) rear++;
	}
	front++;
}
	return false;
}
bool can_insert(int s) {
int v = 0;
for (int i = 0; i &lt; 9; i++) v = v * 10 + st[s][i] - '0';
if (!vis.count(v)) {
	vis.insert(v);
	return true;
}
return false;
}</code></pre>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-埃及分数" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%9F%83%E5%8F%8A%E5%88%86%E6%95%B0/"
    >埃及分数</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%9F%83%E5%8F%8A%E5%88%86%E6%95%B0/" class="article-date">
  <time datetime="2020-03-30T02:15:00.560Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-12258-埃及分数"><a class="markdownIt-Anchor" href="#uva-12258-埃及分数"></a> UVA 12258 埃及分数</h1>
<p>输入出a,b,k，然后输入k个数，要求这k个数不出现在结果中。埃及分数是将任何一个分数a/b，转换成1/x1+1/x2+1/x3…的形式。好的解应该是项数最少的，对于相同项数的解，最小的分数值越大越好。</p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<ol>
<li>由于本题中深度没有上限，而且加数的选择也没有上届，因此如果用广度有限遍历，可能连一层都遍历不完。</li>
<li>使用迭代加深度搜索解决。不断枚举深度的上限maxd，每次搜索深度不超过maxd的节点。<strong>这样只要解的深度有限，那么一定可以在有限的时间内枚举得到</strong>；</li>
<li>关于剪枝：本题中，如果剩余的maxd-d+1项都是1/i，但是和仍然小于目标a/b，那么说明项数不够，则不需要继续递归下去。</li>
<li>关于约分：使用到gcd算法，求出g = gcd(a,b)，那么a/b 可以转换成(a/g)/(b/g)；</li>
<li>关于inline:使用inline之后，时间从2290减到1380。不能使用inline的情况包括
<ol>
<li>不适用于包含复杂控制语句的函数</li>
<li>不适用于直接递归函数</li>
</ol>
</li>
</ol>
<p><strong>但是是否真的设置为内联，由编译器决定</strong></p>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<h3 id="dfs-深度搜索"><a class="markdownIt-Anchor" href="#dfs-深度搜索"></a> dfs 深度搜索</h3>
<pre><code>bool dfs(int d, LL from, LL a, LL b) {
if (d == maxd) {
	if (b%a || avoid.count(b / a)) return false;

	v[d] = b / a;
	if (better(d)) memcpy(ans, v, sizeof(LL)*(d + 1)); //0~d
	return true;
}
bool ok = false;
from = max(from, get_first(a, b));
for (LL i = from;; i++) {
	if (b*(maxd - d + 1) &lt;= a * i) break;
	//如果a/b &gt;= (maxd-d+1)*/(1/i)，则剪枝
	if (avoid.count(i)) continue;
	v[d] = i;

	//这一部分目的是计算a/b-1/i
	LL a2 = a * i - b;
	LL b2 = b * i;
	LL g = gcd(a, b);
	if (dfs(d + 1, i + 1, a2 / g, b2 / g)) ok = true;
}
return ok;
</code></pre>
<h3 id="比较函数"><a class="markdownIt-Anchor" href="#比较函数"></a> 比较函数</h3>
<pre><code>inline bool better(int d) {
for (int i = d; i &gt;= 0; i--) {
	if (ans[i] != v[i])
		return ans[i] == -1 || ans[i] &gt; v[i];
}
return false;
}
</code></pre>
<ol>
<li>要求最小的分数值越大越好，即是要求分母最大的数越小越好。所以从i=d开始比较。</li>
</ol>
<h3 id="gcd-固定的"><a class="markdownIt-Anchor" href="#gcd-固定的"></a> gcd 固定的</h3>
<pre><code>inline LL gcd(LL a, LL b) {
if (b == 0) return a;
return gcd(b, a%b);
}
</code></pre>
<h3 id="get_first-返回1从ab的最小的"><a class="markdownIt-Anchor" href="#get_first-返回1从ab的最小的"></a> get_first 返回1/从&lt;=a/b的最小的</h3>
<pre><code>inline LL get_first(LL a, LL b) 
{ return b / a + 1; }
</code></pre>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-宝箱" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%AE%9D%E7%AE%B1/"
    >宝箱</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%AE%9D%E7%AE%B1/" class="article-date">
  <time datetime="2020-03-30T02:15:00.560Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-12325-宝箱"><a class="markdownIt-Anchor" href="#uva-12325-宝箱"></a> UVA 12325 宝箱</h1>
<p>你有一个体积为N的箱子和两种数量无限的宝物。宝物1的体积为S1，价值为V1:；宝物2的体积为S2，价值为V2。输入均为32位带符号整数。 计算最多能装多大价值的宝物。（每种宝物都必须拿非负整数个）。</p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<ol>
<li>可以选择枚举宝藏1的个数，然后尽可能多的拿宝物2；或者；但是当n和s1,s2的差距较大的时候，这种方法不奏效。</li>
<li>假设宝物1取总体积S2，宝物2取总体积S1，且二者总价值相等，即S1<em>V2 == S2</em>V1。那么当V1较大时，宝藏1至多取S2-1个，否则可用S1个宝物二替换。同理，如果V2较大，那么宝物2至多取S1-1个.因此，枚举量只有S1和S2。</li>
<li>解决TLE：
<ol>
<li>当N/S1比较小时，枚举宝物1的个数，时间复杂度为O(N/S1)；否则，当N/S2比较小时，枚举宝物2的个数，时间复杂度为O(N/S2)。</li>
<li>因此枚举的时间复杂度为O(max(S1,S2))</li>
</ol>
</li>
</ol>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<pre><code>typedef long long int64;
using std::swap; using std::max;
int main() {
int T, id = 0; scanf(&quot;%d&quot;, &amp;T);
while (T--) {
	int n, s1, v1, s2, v2; scanf(&quot;%d %d %d %d %d&quot;, &amp;n, &amp;s1, &amp;v1, &amp;s2, &amp;v2);
	if (s1 &gt; s2) swap(s1, s2), swap(v1, v2);//目的是使得S2&gt;S1
	int64 ans = 0;
	if (n / s2 &gt;= 65536) {	//S2&gt;S1，如果除以S2都大于65536，说明S2就很小，那么S1更小，那么使用特殊枚举。
		for (int64 i = 0; i &lt;= s1; i++) ans = max(ans, v2 * i + (n - s2 * i) / s1 * v1);
		for (int64 i = 0; i &lt;= s2; i++) ans = max(ans, v1 * i + (n - s1 * i) / s2 * v2);
	}
	else {//否则枚举宝物2的数量。
		for (int64 i = 0; s2 * i &lt;= n; i++) ans = max(ans, v2 * i + (n - s2 * i) / s1 * v1);
	}
	printf(&quot;Case # %d: %lld\n&quot;, ++id, ans);
}

return 0;
}
</code></pre>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-安迪的第一本字典" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%AE%89%E8%BF%AA%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E5%AD%97%E5%85%B8/"
    >安迪的第一本字典</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%AE%89%E8%BF%AA%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E5%AD%97%E5%85%B8/" class="article-date">
  <time datetime="2020-03-30T02:15:00.560Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva10815-安迪的第一本字典"><a class="markdownIt-Anchor" href="#uva10815-安迪的第一本字典"></a> UVa10815 安迪的第一本字典</h1>
<p>输入一个文本，找出所有不同的单词(连续字母序列)，按字典序从小到大输出，单词不区分大小写</p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p>主要利用set自动排序的特性实现字典序;主要工作是分割单词，即连续字母序列</p>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;sstream&gt;
#include&lt;set&gt;
using namespace std;
set&lt;string&gt; dir;
int main() {
string s, buf;
while (cin &gt;&gt; s) {
	for (int i = 0; i &lt; s.length(); i++) {
		if (isalpha(s[i])) s[i] = tolower(s[i]);
		else s[i] = ' ';
		
	}

/*
将文本存在s中，遍历s；遇到字母，则都转为小写，防止排序出错；若字母序列中断，则插入一个空格，这样在之后向buf中输入的时候，单词即可分开。
*/

	stringstream ss(s);
	while (ss &gt;&gt; buf) dir.insert(buf);
}

for (set&lt;string&gt;::iterator it = dir.begin(); it != dir.end(); it++)
	cout &lt;&lt; *it &lt;&lt; endl;
}
</code></pre>
<p>主要这一段stringstream以及迭代器的用法；迭代器可以理解为一个指针</p>
<h2 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h2>
<p>本题主要是对set的应用</p>
<ol>
<li>要学习set的声明和基本使用：insert(插入元素)；</li>
<li>要学习拆分单词的技巧</li>
<li>要学习迭代器的使用方法</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-巴比伦塔" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%B7%B4%E6%AF%94%E4%BC%A6%E5%A1%94/"
    >巴比伦塔</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%B7%B4%E6%AF%94%E4%BC%A6%E5%A1%94/" class="article-date">
  <time datetime="2020-03-30T02:15:00.560Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-437-巴比伦塔"><a class="markdownIt-Anchor" href="#uva-437-巴比伦塔"></a> UVA 437 巴比伦塔</h1>
<p>你可能已经听说过巴比伦塔的传说。现在这个传说的许多细节已经被遗忘。所以本着本场比赛的教育性质，我们现在会告诉你整个传说：</p>
<p>巴比伦人有n种长方形方块，每种有无限个，第i种方块的三边边长是xi,yi,zi。对于每一个方块，你可以任意选择一面作为底，这样高就随着确定了。举个例子，同一种方块，可能其中一个是竖着放的，一个是侧着放的，一个是横着放的。</p>
<p>他们想要用堆方块的方式建尽可能高的塔。问题是，只有一个方块的底的两条边严格小于另一个方块的底的两条边，这个方块才能堆在另一个上面。这意味着，一个方块甚至不能堆在一个底的尺寸与它一样的方块的上面。</p>
<p>你的任务是编写一个程序，计算出这个塔可以建出的最高的高度。</p>
<p>输入会包含至少一组数据，每组数据的第一行是一个整数n(n&lt;=30)，表示方块的种类数。 这组数据接下来的n行，每行有三个整数，表示xi,yi,zi。 输入数据会以0结束。</p>
<p>对于每组数据，输出一行，其中包含组号(从1开始)和塔最高的高度。按以下格式： Case : maximum height = __</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol start="3">
<li>每次决策的影响因素只有顶面尺寸</li>
<li>每次的顶面长宽都会严格减小，所以状态图是一个有向无环图，所以问题转换成了求DAG上的最长路径问题</li>
<li>关于状态的存储。如果使用(a,b)表示顶面面积a*b，由于ab可能很大是，所以不可行；如果用(idx,k)表示以第idx号立方体的第k号边为高，则可行。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="get_wl-将以b号边为高的第a号矩形的长宽填入数组v"><a class="markdownIt-Anchor" href="#get_wl-将以b号边为高的第a号矩形的长宽填入数组v"></a> get_wl 将以b号边为高的第a号矩形的长宽填入数组v</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void get_wl(int *v, int a, int b) &#123;&#x2F;&#x2F;将长宽填入数组</span><br><span class="line">	int idx &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 3; i++)</span><br><span class="line">		if (i !&#x3D; b)</span><br><span class="line">			v[idx++] &#x3D; block[a][i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dp-尝试填充d数组"><a class="markdownIt-Anchor" href="#dp-尝试填充d数组"></a> dp 尝试填充d数组</h2>
<p>d[i][j]表示以第i个立方体的第j条边，能达到的最大高度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int dp(int i, int j) &#123;</span><br><span class="line">	int &amp;ans &#x3D; d[i][j];</span><br><span class="line">	if (ans &gt; 0)  return ans;</span><br><span class="line">	ans &#x3D; 0;</span><br><span class="line">	int v1[2], v2[2];</span><br><span class="line">	get_wl(v1, i, j);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; 3; j++) &#123;</span><br><span class="line">			get_wl(v2, i, j);</span><br><span class="line">			if (v1[0] &gt; v2[0] &amp;&amp; v1[1] &gt; v2[1])</span><br><span class="line">				ans &#x3D; max(ans, dp(i, j));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans +&#x3D; block[i][j];</span><br><span class="line">	return ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	int kase &#x3D; 0;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 3; j++)</span><br><span class="line">				scanf(&quot;%d&quot;, &amp;block[i][j]);</span><br><span class="line">			sort(block[i], block[i] + 3);</span><br><span class="line">		&#125;</span><br><span class="line">		memset(d, 0, sizeof(d));</span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 3; j++)</span><br><span class="line">				ans &#x3D; max(ans, dp(i, j));</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;Case %d: maximum height &#x3D; %d\n&quot;, ++kase, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Gergovia的酒交易" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/Gergovia%E7%9A%84%E9%85%92%E4%BA%A4%E6%98%93/"
    >Gergovia的酒交易</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/Gergovia%E7%9A%84%E9%85%92%E4%BA%A4%E6%98%93/" class="article-date">
  <time datetime="2020-03-30T02:15:00.545Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-11054-gergovia的酒交易"><a class="markdownIt-Anchor" href="#uva-11054-gergovia的酒交易"></a> UVA 11054 Gergovia的酒交易</h1>
<p>n个等距村庄,每个村庄要么买酒要么卖酒,把k个单位的酒运到相邻村庄去需要k*酒的需求的劳动力,问最少需要多少劳动力才能满足所有的村庄的要求。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>等价转换，考虑最左侧的村庄
<ol>
<li>假设a1&gt;0,则需要从其他的村庄向1运a1单位的酒，等价于只有村庄2-n，且第二个村庄的需求量为a1+a2。</li>
<li>再举个例子，如果a1&lt;0,a2&gt;0，由于供需平衡，a1的酒需要全部运出，耗费劳动力|a1|，剩余的酒从a2运走需要||a1|-a2| = a1+a2</li>
</ol>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">		long long ans &#x3D; 0, left &#x3D; 0, a;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%lld&quot;, &amp;a);</span><br><span class="line">			ans +&#x3D; abs(left);</span><br><span class="line">			left +&#x3D; a;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Hali-Bula的晚会" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/Hali-Bula%E7%9A%84%E6%99%9A%E4%BC%9A/"
    >Hali-Bula的晚会</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/Hali-Bula%E7%9A%84%E6%99%9A%E4%BC%9A/" class="article-date">
  <time datetime="2020-03-30T02:15:00.545Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-1220-hali-bula的晚会"><a class="markdownIt-Anchor" href="#uva-1220-hali-bula的晚会"></a> UVA 1220 Hali-Bula的晚会</h1>
<p>公司里有n(n&lt;=200)个人形成一个树状结构，即除了老板之外每个员工都有唯一的直属上司。要求选尽量多的人，但不能同时选择一个人和他的直属上司。问：最多能选多少人，以及在人数最多的前提下方案是否唯一。</p>
<p>输入：第一行一个数n;第二行输入老板的名字;以下的n-1行中,每行是一位员工的名字和其直属上司的名字(英文单词,长度为1到100),两个名字之间有空格隔开,'0’为输入结束的标识符。</p>
<p>输出：一行,输出一个数字，表示最大的访客数量。并再同一行输出单词’Yes’或’No’，代表目前方案是否唯一。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>参考最大独立集，不过本题实现与那篇不同</li>
<li>本题的特殊之处在于需要需要判断唯一性，<strong>我认为唯一性的原则是取判断导出当前状态的状态是否是唯一方案</strong></li>
<li>由于每个点处决策只有两种，选或不选，所以用d[maxn][2]表示以u为根的子树中，能达到的最大人数。0表示不取u，1表示取u。f[maxn][2]来表示相应状态是否是唯一的，具体的f的判定见注释</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; id;</span><br><span class="line"><span class="keyword">int</span> d[maxn][<span class="number">2</span>], f[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ID</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!id.count(s))</span><br><span class="line">		id[s] = cnt++;</span><br><span class="line">	<span class="keyword">return</span> id[s];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	f[u][k] = <span class="number">1</span>;</span><br><span class="line">	d[u][k] = k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">//如果取了u，那么他的孩子不能取</span></span><br><span class="line">			<span class="comment">//所以d[u][1]只能来源于d[v][0]</span></span><br><span class="line">			<span class="comment">//所以f取决于f[v][0]</span></span><br><span class="line">			d[u][<span class="number">1</span>] += dp(v, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (f[v][<span class="number">0</span>] == <span class="number">0</span>) f[u][<span class="number">1</span>] = <span class="number">0</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//如果不取u，那么v可取可不取</span></span><br><span class="line">			<span class="comment">//因为要求最大人数，所以u的状态来自要取二者最大值</span></span><br><span class="line">			<span class="comment">//所以f取决于子树的最大状态的f</span></span><br><span class="line">			d[u][<span class="number">0</span>] += <span class="built_in">max</span>(dp(v, <span class="number">0</span>), dp(v, <span class="number">1</span>));</span><br><span class="line">			<span class="keyword">if</span> (d[v][<span class="number">0</span>] == d[v][<span class="number">1</span>]) f[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (d[v][<span class="number">0</span>] &gt; d[v][<span class="number">1</span>] &amp;&amp; f[v][<span class="number">0</span>] == <span class="number">0</span>) f[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (d[v][<span class="number">1</span>] &gt; d[v][<span class="number">0</span>] &amp;&amp; f[v][<span class="number">1</span>] == <span class="number">0</span>) f[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> d[u][k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">string</span> s1, s2;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		id.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			g[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s1;</span><br><span class="line">		ID(s1);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">			g[ID(s2)].push_back(ID(s1));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, <span class="built_in">max</span>(dp(<span class="number">0</span>, <span class="number">0</span>), dp(<span class="number">0</span>, <span class="number">1</span>)));</span><br><span class="line">		<span class="keyword">bool</span> unique = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (d[<span class="number">0</span>][<span class="number">0</span>] &gt; d[<span class="number">0</span>][<span class="number">1</span>] &amp;&amp; f[<span class="number">0</span>][<span class="number">0</span>]) unique = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (d[<span class="number">0</span>][<span class="number">1</span>] &gt; d[<span class="number">0</span>][<span class="number">0</span>] &amp;&amp; f[<span class="number">0</span>][<span class="number">1</span>]) unique = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (unique) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Shuffle的播放记录" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/Shuffle%E7%9A%84%E6%92%AD%E6%94%BE%E8%AE%B0%E5%BD%95/"
    >Shuffle的播放记录</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/Shuffle%E7%9A%84%E6%92%AD%E6%94%BE%E8%AE%B0%E5%BD%95/" class="article-date">
  <time datetime="2020-03-30T02:15:00.545Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-12174-shuffle的播放记录"><a class="markdownIt-Anchor" href="#uva-12174-shuffle的播放记录"></a> UVA 12174 Shuffle的播放记录</h1>
<p>音乐播放器有一个所谓乱序播放功能，假设一共有s首歌，一开始会给这些歌随机排序，全部播放完毕后再随机排序，继续播放，以此类推。注：当s首歌播完前不会重新排序，所以播放记录里每s首歌都是1~s的排列.给出一个长度为n（1&lt;=s,n&lt;=100000) 的播放记录（不一定从最开始记录）xi（1&lt;=xi&lt;=s).统计下一次随机排序所发生的时间有多少种可能性。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>统计可能性，就是统计当前序列有多少种分法。</li>
<li>连续s个数是一段，想到滑动窗口问题，并且这个题的窗口大小相对固定。需要做的是找到所有可能的段的起始点，再验证哪些能作为整体的划分的开头。</li>
<li>段的起始点，有三种情况
<ol>
<li>位于播放列表开头的不完整段。这时判断条件是开头i个元素都是不重复的</li>
<li>完整的段。要求窗口内没有重复的数字</li>
<li>位于结尾的不完整的段。与开头的类似，只是判断条件为n+s-i个元素都是不重复的。等价于后面i个元素都是不重复的。</li>
</ol>
</li>
<li>本题还要注意一些边界条件和数组大小</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="solve"><a class="markdownIt-Anchor" href="#solve"></a> solve</h2>
<ol>
<li>先找到段的起始点，用ok[i]表示，再依次判断每个段起始点能否成为整个划分的开头</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">	int tot &#x3D; 0;&#x2F;&#x2F;记录不重复数字总数</span><br><span class="line">	fill(cnt + 1, cnt + s + 1, 0); &#x2F;&#x2F;cnt[i]表示值i出现的次数</span><br><span class="line">	fill(ok, ok + n + s + 1, 0);   &#x2F;&#x2F;ok[i]&#x3D;&#x3D;1表示第i个窗口内没有重复元素</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n+s+1; i++) &#123;</span><br><span class="line">		if (tot &#x3D;&#x3D; s) ok[i] &#x3D; 1;</span><br><span class="line">		if (i &lt; s&amp;&amp;tot &#x3D;&#x3D; i) </span><br><span class="line">			ok[i] &#x3D; 1;</span><br><span class="line">		if (i &gt; n&amp;&amp;tot &#x3D;&#x3D; n+s-i) </span><br><span class="line">			ok[i] &#x3D; 1;&#x2F;&#x2F;n+s-i 从后往前数的第i个</span><br><span class="line"></span><br><span class="line">		if (i &#x3D;&#x3D; n + s) break;;</span><br><span class="line">		if (a[i] !&#x3D; -1 &amp;&amp; --cnt[a[i]] &#x3D;&#x3D; 0) tot--;</span><br><span class="line">		if (a[i + s] !&#x3D; -1 &amp;&amp; cnt[a[i+s]]++ &#x3D;&#x3D; 0) tot++;&#x2F;&#x2F;窗口滑动一格</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;验证每个起始点</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; s; i++) &#123;</span><br><span class="line">		int valid &#x3D; 1;</span><br><span class="line">		for (int j &#x3D; i; j &lt; n + s + 1; j +&#x3D; s)</span><br><span class="line">			if (!ok[j]) valid &#x3D; 0;;</span><br><span class="line">		if (valid) ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	if (ans &#x3D;&#x3D; n + 1) ans &#x3D; s; &#x2F;&#x2F; special case</span><br><span class="line">	printf(&quot;%d\n&quot;, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100000 + 5;</span><br><span class="line"></span><br><span class="line">int s, n;</span><br><span class="line">int a[maxn*3+1];&#x2F;&#x2F;前后各空出s的空间，防止溢出</span><br><span class="line">int cnt[maxn];&#x2F;&#x2F;记录每个数字的出现次数</span><br><span class="line">int ok[maxn*3+1];&#x2F;&#x2F;ok[i]&#x3D;&#x3D;1表示第i个滑动窗口中没有重复数字</span><br><span class="line"></span><br><span class="line">void solve();</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d %d&quot;, &amp;s, &amp;n);</span><br><span class="line">		fill(a, a + n + 2 * s, -1);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i+s]);</span><br><span class="line">		solve();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/19/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="page-number" href="/page/19/">19</a><span class="page-number current">20</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/21/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        CuiEnbo
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt=""></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['', '', ''],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: false
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>