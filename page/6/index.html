<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://github.com/Cccceb/Cccceb.github.io').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Ceb">
<meta property="og:url" content="https://github.com/Cccceb/Cccceb.github.io/page/6/index.html">
<meta property="og:site_name" content="Ceb">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Cuienbo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://github.com/Cccceb/Cccceb.github.io/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Ceb</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a href="https://github.com/you"><img style="position:absolute;" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_left_gray_6d6d6d.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>  
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ceb</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/29/%E4%B8%A4%E4%BA%B2%E6%80%A7%E5%88%86%E5%AD%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/29/%E4%B8%A4%E4%BA%B2%E6%80%A7%E5%88%86%E5%AD%90/" class="post-title-link" itemprop="url">两亲性分子</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-29 23:54:05 / Modified: 23:55:44" itemprop="dateCreated datePublished" datetime="2020-01-29T23:54:05+08:00">2020-01-29</time>
            </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVA-1606-两亲性分子"><a href="#UVA-1606-两亲性分子" class="headerlink" title="UVA 1606 两亲性分子"></a>UVA 1606 两亲性分子</h1><p>平面上有n(n≤1000)n(n&lt;=1000)个点，每个点为白点或者黑点。</p>
<p>现在需要放置一条隔板，使得隔板一侧的白点数加上另一侧的黑点数总数最大。隔板上的点可以看作任意一侧。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>基础：令隔板经过至少两个点(否则可以移动隔板使其经过两个点而总数不变</li>
<li>最直接的，枚举两个点，再计算总数，O(n<sup>3</sup>)</li>
<li>改进：先枚举一个基准点，然后以这个点为轴，旋转直线，这样就可可以动态修改两侧的点数。</li>
<li>技巧：<ol>
<li>将黑点以当前的基准点为对称中心，将它对称过去，这样只用统计直线一端的点数就是答案</li>
<li>利用叉积判断两个向量是否反向(即旋转了180°)</li>
</ol>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="solve-枚举基准点，并统计每个基准点对应的总数"><a href="#solve-枚举基准点，并统计每个基准点对应的总数" class="headerlink" title="solve 枚举基准点，并统计每个基准点对应的总数"></a>solve 枚举基准点，并统计每个基准点对应的总数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int solve() &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">	scanf(&quot;%d %d %d&quot;, &amp;in[i].x, &amp;in[i].y, &amp;flag[i]);</span><br><span class="line"></span><br><span class="line">if (n &lt;&#x3D; 2) return 2;</span><br><span class="line">node p[maxn];</span><br><span class="line">int ans &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">	int k &#x3D; 0;</span><br><span class="line">	for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">		if (j &#x3D;&#x3D; i) continue;</span><br><span class="line">		p[k].x &#x3D; in[j].x - in[i].x;</span><br><span class="line">		p[k].y &#x3D; in[j].y - in[i].y;</span><br><span class="line">		if (flag[j]) p[k].x *&#x3D; -1, p[k].y *&#x3D; -1;</span><br><span class="line">		p[k].rad &#x3D; atan2(p[k].y, p[k].x);</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(p, p + k);</span><br><span class="line">	int L &#x3D; 0, R &#x3D; 0, cnt &#x3D; 2;</span><br><span class="line">	while (L &lt; k)</span><br><span class="line">	&#123;</span><br><span class="line">		if (R &#x3D;&#x3D; L) &#123;</span><br><span class="line">			R &#x3D; (R + 1) % k;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		while (R !&#x3D; L &amp;&amp; left(p[L], p[R]))</span><br><span class="line">		&#123;</span><br><span class="line">			R &#x3D; (R + 1) % k;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		cnt--;</span><br><span class="line">		L++;</span><br><span class="line">		ans &#x3D; max(ans, cnt);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="left-判断两个向量是否反向"><a href="#left-判断两个向量是否反向" class="headerlink" title="left 判断两个向量是否反向"></a>left 判断两个向量是否反向</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool left(node a, node b) &#123;</span><br><span class="line">return a.x*b.y - a.y*b.x &gt;&#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1005;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int x, y;</span><br><span class="line">	double rad;</span><br><span class="line">	bool operator &lt; (const node &amp;a) const &#123; return rad &lt; a.rad; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node in[maxn];</span><br><span class="line">int n;</span><br><span class="line">bool flag[maxn];</span><br><span class="line"></span><br><span class="line">bool left(node a, node b);</span><br><span class="line">int solve();</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n) &#123;</span><br><span class="line">		printf(&quot;%d\n&quot;, solve());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/29/%E5%94%AF%E4%B8%80%E7%9A%84%E9%9B%AA%E8%8A%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/29/%E5%94%AF%E4%B8%80%E7%9A%84%E9%9B%AA%E8%8A%B1/" class="post-title-link" itemprop="url">唯一的雪花</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-29 23:54:05" itemprop="dateCreated datePublished" datetime="2020-01-29T23:54:05+08:00">2020-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-01 17:59:52" itemprop="dateModified" datetime="2020-02-01T17:59:52+08:00">2020-02-01</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVA-11572-唯一的雪花"><a href="#UVA-11572-唯一的雪花" class="headerlink" title="UVA 11572 唯一的雪花"></a>UVA 11572 唯一的雪花</h1><p>求最长连续无重复子序列。输入：第一行给出样例数，对于每组数据，第一行给出序列长度n，之后n行给出每个元素的值。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>滑动窗口：优先向右扩展，如果A[R+1]已存在，那么增大L。这是因为L-R是解的情况下，增大L也必然是解，所以R不必动。</li>
<li>判断是否出现过，可以使用set(240ms),map(270ms),数组(1140ms)<ol>
<li>set的查询，插入，删除的复杂度都是O(logn)</li>
<li>map[i]来记录元素i上次出现的下标，并更新到数组last。后面，如果上一次出现的下标不在目前的搜索范围内，那么可以扩展。</li>
<li>数组法可能是因为数组太大，所以速度太慢。</li>
</ol>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="set法"><a href="#set法" class="headerlink" title="set法"></a>set法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000000 + 5;</span><br><span class="line">int A[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int T, n;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">  while(T--) &#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;A[i]);</span><br><span class="line"></span><br><span class="line">    set&lt;int&gt; s;</span><br><span class="line">    int L &#x3D; 0, R &#x3D; 0, ans &#x3D; 0;</span><br><span class="line">    while(R &lt; n) &#123;</span><br><span class="line">      while(R &lt; n &amp;&amp; !s.count(A[R])) s.insert(A[R++]);</span><br><span class="line">      ans &#x3D; max(ans, R - L);</span><br><span class="line">      s.erase(A[L++]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="map法"><a href="#map法" class="headerlink" title="map法"></a>map法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000000 + 5;</span><br><span class="line">int A[maxn], last[maxn];</span><br><span class="line">map&lt;int, int&gt; cur;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int T, n;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">  while(T--) &#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    cur.clear();</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">      scanf(&quot;%d&quot;, &amp;A[i]);</span><br><span class="line">      if(!cur.count(A[i])) last[i] &#x3D; -1;</span><br><span class="line">      else last[i] &#x3D; cur[A[i]];</span><br><span class="line">      cur[A[i]] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int L &#x3D; 0, R &#x3D; 0, ans &#x3D; 0;</span><br><span class="line">    while(R &lt; n) &#123;</span><br><span class="line">      while(R &lt; n &amp;&amp; last[R] &lt; L) R++;</span><br><span class="line">      ans &#x3D; max(ans, R - L);</span><br><span class="line">      L++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组法"><a href="#数组法" class="headerlink" title="数组法"></a>数组法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1e9 + 5;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int in[1000005];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		int n;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;in[i]);</span><br><span class="line">		int L &#x3D; 0, R &#x3D; 0, ans &#x3D; 0;</span><br><span class="line">		while (L &lt;&#x3D; R &amp;&amp; R &lt; n)</span><br><span class="line">		&#123;</span><br><span class="line">			if (!vis[in[R]]) &#123; vis[in[R]] &#x3D; 1; R++; &#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				ans &#x3D; max(ans, R - L);</span><br><span class="line">				vis[in[L]] &#x3D; 0; L++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, max(ans, R - L));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/29/%E7%85%8E%E9%A5%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/29/%E7%85%8E%E9%A5%BC/" class="post-title-link" itemprop="url">煎饼</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-29 23:54:05" itemprop="dateCreated datePublished" datetime="2020-01-29T23:54:05+08:00">2020-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-01 20:59:25" itemprop="dateModified" datetime="2020-02-01T20:59:25+08:00">2020-02-01</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVA-120-煎饼"><a href="#UVA-120-煎饼" class="headerlink" title="UVA 120 煎饼"></a>UVA 120 煎饼</h1><p>给你一迭薄煎饼，请你写一个程式来指出要如何安排才能使这些薄煎饼由上到下依薄煎饼的半径由小到大排好。所有的薄煎饼半径均不相同。</p>
<p>要把薄煎饼排好序需要对这些薄煎饼做翻面（flip）的动作。方法是以一抹刀插入一迭薄煎饼中，然后做翻面的动作（也就是说在抹刀上面的薄煎饼经翻面后，会依相反的次序排列）。若一迭共有n个薄煎饼，我们定义最底下的薄煎饼的位置为1，最上面的薄煎饼位置为n。当抹刀插入位置为k时，代表从位置k到位置n的薄煎饼要做翻面的动作。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>题意是要进行排序，只不过基本操作是颠倒一个连续的子序列</li>
<li>借鉴选择排序的思想，从大到小依次将每个数排到正确的位置。</li>
<li>实现时先翻到最上面，再翻到正确位置。因为大的在下面，并且按照从大到小的顺序处理，所以当处理第i大的煎饼时，不会影响到1，2，3，…，i-1大的煎饼。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><ol>
<li>由于规模较小，所以使用order数组来确定大小关系，也可以使用max_element函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 35;</span><br><span class="line">int in[maxn];</span><br><span class="line">int order[maxn];</span><br><span class="line">int ans[maxn];</span><br><span class="line">int n;</span><br><span class="line">int main() &#123;</span><br><span class="line">string line;</span><br><span class="line">while (getline(cin, line))</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">	stringstream ss(line);</span><br><span class="line">	n &#x3D; 0;</span><br><span class="line">	while (ss &gt;&gt; in[n]) n++;</span><br><span class="line">	memcpy(order, in, sizeof(in));</span><br><span class="line">	sort(order, order + n);</span><br><span class="line">	int now;</span><br><span class="line">	for (int i &#x3D; n - 1; i &gt;&#x3D; 0;i--) &#123;</span><br><span class="line">		int now &#x3D; order[i];</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">			if (in[j] &#x3D;&#x3D; now) &#123;</span><br><span class="line">				if (j &#x3D;&#x3D; i ) break;</span><br><span class="line">				if (j !&#x3D; 0)  filp(j);</span><br><span class="line">				filp(i);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt;&quot;0&quot;&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="filp-从p处开始翻"><a href="#filp-从p处开始翻" class="headerlink" title="filp 从p处开始翻"></a>filp 从p处开始翻</h2><ol>
<li>使用swap函数更好理解，并且省下了辅助数组所耗费的时间和空间</li>
</ol>
<pre><code>
void filp(int p) {
for (int i = 0; i &lt; p - i; i++) 
    swap(in[i], in[p - i]);
printf(&quot;%d &quot;, n - p);

}
</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/29/%E8%81%94%E5%90%88%E5%9B%BD%E5%A4%A7%E6%A5%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/29/%E8%81%94%E5%90%88%E5%9B%BD%E5%A4%A7%E6%A5%BC/" class="post-title-link" itemprop="url">联合国大楼</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-29 23:54:05 / Modified: 23:55:42" itemprop="dateCreated datePublished" datetime="2020-01-29T23:54:05+08:00">2020-01-29</time>
            </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVA-1605-联合国大楼"><a href="#UVA-1605-联合国大楼" class="headerlink" title="UVA 1605 联合国大楼"></a>UVA 1605 联合国大楼</h1><p>给出有多少个国家 nnn （ n&lt;= 50），需要给每个国家安排办公室。大楼的每一层有着相同的行列数，请你构造一种安排（输出层数，行数和列数），使得每两个国家之间都有一间挨着的办公室，且办公室总数不超过 1000000 ，用不同字母表示不同国家，输出每层楼的安排方法。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>最简单的，一共键两层，每层都是n*n,令第一层全是国家i，第二层第j列全是国家j。这样任何一个国家(行)必能与另一层的所有列相交，所以设计方案一定正确。</li>
<li>使用中途相遇法，从两个不同的方向来解决问题</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 50 + 5;</span><br><span class="line">int f1[maxn][maxn];</span><br><span class="line">int f2[maxn][maxn];</span><br><span class="line">inline char to_alp(int x) &#123; return x &lt; 26 ? x + &#39;A&#39; : &#39;a&#39; + x - 26; &#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int n;</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1) &#123;</span><br><span class="line"></span><br><span class="line">	printf(&quot;2 %d %d\n&quot;, n, n);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">			f1[i][j] &#x3D; i;</span><br><span class="line">			f2[i][j] &#x3D; j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">			printf(&quot;%c&quot;, to_alp(f1[i][j]));</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">			printf(&quot;%c&quot;, to_alp(f2[i][j]));</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/29/%E5%92%8C%E4%B8%BA0%E7%9A%844%E4%B8%AA%E5%80%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/29/%E5%92%8C%E4%B8%BA0%E7%9A%844%E4%B8%AA%E5%80%BC/" class="post-title-link" itemprop="url">和为0的4个值</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-29 23:54:05" itemprop="dateCreated datePublished" datetime="2020-01-29T23:54:05+08:00">2020-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-01 17:27:26" itemprop="dateModified" datetime="2020-02-01T17:27:26+08:00">2020-02-01</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVA-1152-和为0的4个值"><a href="#UVA-1152-和为0的4个值" class="headerlink" title="UVA 1152 和为0的4个值"></a>UVA 1152 和为0的4个值</h1><p>给出四个集合，从每个集合中任取一个数，问有多少种方案使得四个数和为0</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>最直观的四重循环复杂度O(n<sup>4</sup>)不可能</li>
<li>三重循环计算第四个数，之后查找这个数。如果查找使用二分查找，那么复杂度也在O(n<sup>3</sup>nlogn)</li>
<li><strong>解决</strong> 首先枚举a,b，把所有a+b记录下来放到一个有序sum数组中。之后枚举c,d，统计对于sum中的每个元素有多少种写成-C[i]-D[j]的方法(利用upper_bound和lower_bound的差计算)。两个步骤都是n<sup>2</sup>logn，总的也是n<sup>2</sup>logn</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 4000 + 5;</span><br><span class="line">int A[maxn];</span><br><span class="line">int B[maxn];</span><br><span class="line">int C[maxn];</span><br><span class="line">int D[maxn];</span><br><span class="line">int sum[maxn*maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">int T;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">while (T--)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">		scanf(&quot;%d %d %d %d&quot;, &amp;A[i], &amp;B[i], &amp;C[i], &amp;D[i]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	int index &#x3D; 0;</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++) </span><br><span class="line">			sum[index++] &#x3D; A[i] + B[j];</span><br><span class="line">	sort(sum, sum + index);</span><br><span class="line">	long long  cnt &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++) </span><br><span class="line">			cnt +&#x3D; upper_bound(0, index, -C[i] - D[j]) - lower_bound(0, index, -C[i] - D[j]);</span><br><span class="line">	printf(&quot;%lld\n&quot;, cnt);</span><br><span class="line">	if (T) printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a>upper_bound</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int upper_bound(int x, int y, int v) &#123;</span><br><span class="line">int m;</span><br><span class="line">while (x&lt;y)</span><br><span class="line">&#123;</span><br><span class="line">	m &#x3D; x + (y - x) &#x2F; 2;</span><br><span class="line">	if (sum[m] &lt;&#x3D; v) x &#x3D; m + 1;</span><br><span class="line">	else y &#x3D; m;</span><br><span class="line">&#125;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int lower_bound(int x, int y, int v) &#123;</span><br><span class="line">int m;</span><br><span class="line">while (x&lt;y)</span><br><span class="line">&#123;</span><br><span class="line">	m &#x3D; x + (y - x) &#x2F; 2;</span><br><span class="line">	if (sum[m] &gt;&#x3D; v) y &#x3D; m;</span><br><span class="line">	else x &#x3D; m + 1;</span><br><span class="line">&#125;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/29/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%B0%8F%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/29/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%B0%8F%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">滑动窗口最小问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-29 23:54:05" itemprop="dateCreated datePublished" datetime="2020-01-29T23:54:05+08:00">2020-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-01 20:51:23" itemprop="dateModified" datetime="2020-02-01T20:51:23+08:00">2020-02-01</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="P1886-滑动窗口最小问题"><a href="#P1886-滑动窗口最小问题" class="headerlink" title="P1886 滑动窗口最小问题"></a>P1886 滑动窗口最小问题</h1><p>有一个长为 n 的序列 a，以及一个大小为 k 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。</p>
<p><img src="/img_UVA%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/5.png" alt=""></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>窗口滑动的过程，相当于删除一个元素，再插入一个元素，同时获得最大值或者最小值。相当于一个<strong>优先级队列</strong>，可以使用set来模拟一个优先级队列实现,时间复杂度O((n-k)logk)，其中插入，删除，取极值都是logk,一共需要滑动n-k次。规模大时TLE。</li>
<li>使用<strong>单调队列</strong>：队列中元素顺序与输入相同，而元素的值是有序的。因为每个元素至多被删除依次，所以总的时间复杂度在O(n)。以单调增队列为例<ol>
<li>如果当前正在扫描的元素比队列队尾元素大，那么直接插入。如果比队尾元素小，则将元素从<strong>队尾出队</strong>，直到队尾元素小于当前元素。</li>
<li>如果插入元素后，有的元素滑动到窗口外，则应该从<strong>队头出队</strong></li>
</ol>
</li>
<li>单调增队列求最小值，单调减序列维护最大值。<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct monotone_queue &#123;</span><br><span class="line">	static const int maxn &#x3D; 1e6+5;</span><br><span class="line">	int n, k, a[maxn];</span><br><span class="line">	int q[maxn], head, tail, p[maxn];&#x2F;&#x2F;q是值的队列,q是编号的队列</span><br><span class="line"></span><br><span class="line">	void read_in() &#123;</span><br><span class="line">		scanf(&quot;%d %d&quot;, &amp;n, &amp;k);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void monotone_min() &#123;</span><br><span class="line">		int head &#x3D; 1;</span><br><span class="line">		int tail &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			while (head &lt;&#x3D; tail &amp;&amp; q[tail] &gt;&#x3D; a[i]) tail--;&#x2F;&#x2F;比当前元素大的全部从队尾出队</span><br><span class="line">			q[++tail] &#x3D; a[i];</span><br><span class="line">			p[tail] &#x3D; i;&#x2F;&#x2F;插入当前元素</span><br><span class="line">			while (p[head] &lt;&#x3D; i - k) head++;&#x2F;&#x2F;窗口外元素从队头出队</span><br><span class="line">			if (i &gt;&#x3D; k) printf(&quot;%d &quot;, q[head]);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void monotone_max() &#123;</span><br><span class="line">		int head &#x3D; 1;</span><br><span class="line">		int tail &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			while (head &lt;&#x3D; tail &amp;&amp; q[tail] &lt;&#x3D; a[i]) tail--;&#x2F;&#x2F;比当前元素小的全部从队尾出队</span><br><span class="line">			q[++tail] &#x3D; a[i];</span><br><span class="line">			p[tail] &#x3D; i;</span><br><span class="line">			while (p[head] &lt;&#x3D; i - k) head++;</span><br><span class="line">			if (i &gt;&#x3D; k) printf(&quot;%d &quot;, q[head]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">monotone_queue mq;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	mq.read_in();</span><br><span class="line">	mq.monotone_min();</span><br><span class="line">	mq.monotone_max();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="模拟优先队列-超时"><a href="#模拟优先队列-超时" class="headerlink" title="模拟优先队列(超时)"></a>模拟优先队列(超时)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1e6 + 5;</span><br><span class="line"> </span><br><span class="line">set&lt;int, less&lt;int&gt; &gt; s;</span><br><span class="line">int big[maxn], small[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, k;</span><br><span class="line">	scanf(&quot;%d %d&quot;, &amp;n, &amp;k);</span><br><span class="line"></span><br><span class="line">	int a;</span><br><span class="line">	int p1 &#x3D; 0, p2 &#x3D; 0;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">		q.push(a);</span><br><span class="line">		s.insert(a);</span><br><span class="line">		if (q.size() &#x3D;&#x3D; k) &#123;</span><br><span class="line">			int tmp &#x3D; q.front(); q.pop();</span><br><span class="line">			small[p1++] &#x3D; *(s.begin());</span><br><span class="line">			big[p2++] &#x3D; *(s.rbegin());</span><br><span class="line">			s.erase(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; p1; i++)</span><br><span class="line">		printf(&quot;%d &quot;, small[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; p2; i++)</span><br><span class="line">		printf(&quot;%d &quot;, big[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/27/%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%A3%80%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/27/%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%A3%80%E7%B4%A2/" class="post-title-link" itemprop="url">排序与检索</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-27 09:49:29" itemprop="dateCreated datePublished" datetime="2020-01-27T09:49:29+08:00">2020-01-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-08 20:09:56" itemprop="dateModified" datetime="2020-02-08T20:09:56+08:00">2020-02-08</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="归并排序-O-nlogn"><a href="#归并排序-O-nlogn" class="headerlink" title="归并排序 O(nlogn)"></a>归并排序 O(nlogn)</h1><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ol>
<li>划分问题： 把序列分成元素个数尽量相等的两半</li>
<li>递归求解： 把两半元素分别排序</li>
<li>合并问题： 把两个有序表合并成一个</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void merge_sort(int *A,int x,int y,int* T)&#123;</span><br><span class="line">if(y-x&gt;1)&#123;</span><br><span class="line">	int m &#x3D; x+(y-x)&#x2F;2;</span><br><span class="line">	int p &#x3D; x,q &#x3D; m,i &#x3D; x; </span><br><span class="line">	merge_sort(A,x,m,T);</span><br><span class="line">	merge_sort(A,m,y,T);</span><br><span class="line">	while(p&lt;m||q&lt;y)&#123;</span><br><span class="line">		if(q&gt;&#x3D;y||(p&lt;m&amp;&amp;A[p]&lt;&#x3D;A[q]))</span><br><span class="line">		&#x2F;&#x2F;如果右侧表为空而左表非空或者左表元素小于右表元素，那么将左表复制到临时表</span><br><span class="line">			T[i++] &#x3D; A[p++];</span><br><span class="line">		else&#123;</span><br><span class="line">			 T[i++] &#x3D; A[q++];</span><br><span class="line">			 &#x2F;&#x2F;cnt+&#x3D;m-p;	可以统计逆序对的个数</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(i &#x3D; x;i&lt;y;i++) A[i] &#x3D; T[i]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>加入cnt+=m-p可以统计序列中逆序对的个数。</strong>这是因为合并的时候是按从小到大的顺序进行，当执行else语句时，说明此时右侧元素更小，此时左边还没来得及复制的元素就是左边所有比A[j]大的数，m-p即为他的个数。</li>
</ol>
<h1 id="快速排序-O-nlogn"><a href="#快速排序-O-nlogn" class="headerlink" title="快速排序 O(nlogn)"></a>快速排序 O(nlogn)</h1><ol>
<li>划分问题： 把数组的各个元素重排后分成左右两部分，使得左边的任意元素都小于或等于右边的任意元素</li>
<li>递归求解： 把左右两部分分别划分</li>
<li>合并问题： 不用合并，因为此时数组已经完全有序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void QSort( SqList &amp;L,  int  low,  int high) &#123;</span><br><span class="line">   if( low &lt; high)&#123;</span><br><span class="line">          pivotloc &#x3D; Partition( L, low, high);</span><br><span class="line">          QSort( L, low, pivotloc – 1);</span><br><span class="line">          QSort( L, pivotloc + 1, high);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Partition( SqList &amp;L,  int low,  int high)</span><br><span class="line">&#123; </span><br><span class="line">   L.r[0] &#x3D; L.r[low];</span><br><span class="line">   pivotkey &#x3D; L.r[low].key;</span><br><span class="line">   while( low &lt; high)&#123;</span><br><span class="line">        while( low &lt; high &amp;&amp; L.r[high].key &gt;&#x3D; pivotkey)  --high;</span><br><span class="line">        L.r[low] &#x3D; L.r[high];</span><br><span class="line">        while( low &lt; high &amp;&amp; L.r[low].key &lt;&#x3D; pivotkey)  ++low;</span><br><span class="line">        L.r[high] &#x3D; L.r[low];</span><br><span class="line">   &#125;</span><br><span class="line">   L.r[low] &#x3D; L.r[0];   </span><br><span class="line">   return low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol>
<li>可以解决的问题：选择出第k大的数。序列划分成A[low,pivotkey]和A[pivotkey+1,high]两部分，比较左侧元素个数q-p+1和k的大小关系，选择在左半部递归还是在右半部递归。</li>
</ol>
<h1 id="二分查找-适用于有序序列"><a href="#二分查找-适用于有序序列" class="headerlink" title="二分查找 适用于有序序列"></a>二分查找 适用于有序序列</h1><ol>
<li>划分问题： 将序列分成尽量相等的两份</li>
<li>递归求解： 在左半部分或者右半部分搜素</li>
<li>合并问题： 无需合并</li>
</ol>
<h2 id="迭代-常用"><a href="#迭代-常用" class="headerlink" title="迭代(常用)"></a>迭代(常用)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">int bsearch(int* A,int x,int y,int v)&#123;</span><br><span class="line">while(x&lt;y)&#123;</span><br><span class="line">	m &#x3D; x + (y-x)&#x2F;2;</span><br><span class="line">	if(A[m]&#x3D;&#x3D;v) return m;</span><br><span class="line">	else if(A[m]&gt;v) y &#x3D; m;</span><br><span class="line">	else x &#x3D; m+1;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">int bsearch(int l,int r)&#123;</span><br><span class="line">	int m &#x3D; l+(r-l)&#x2F;2;</span><br><span class="line">	if(A[m]&#x3D;&#x3D;goal) return m;</span><br><span class="line">	else if(goal&lt;A[m])</span><br><span class="line">		return bsearch(l,m);</span><br><span class="line">	else return bsearch(m+1,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="考虑新问题："><a href="#考虑新问题：" class="headerlink" title="考虑新问题："></a>考虑新问题：</h2><p>如果数组中有多个goal，如果返回目标值的完整区间(上例程序返回中间那一个的索引)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int lower_bound(int* A,int x,int y,int v)&#123;</span><br><span class="line">int m;</span><br><span class="line">while(x&lt;y)&#123;</span><br><span class="line">	m &#x3D; x + (y-x)&#x2F;2;</span><br><span class="line">	if(A[m]&gt;&#x3D;v) y &#x3D; m;</span><br><span class="line">	else x &#x3D; m+1;</span><br><span class="line">&#125;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>上述程序返回v的第一个出现位置或者是返回一个下标i，在i处插入v，后面的序列仍然有序。</li>
<li>虽然搜索的区间是[x,y)，但是v可能比A[y-1]要大，所以返回值的取值范围在[x,y]。A[m]和v的关系的影响包括：<ol>
<li>A[m]==v 时，至少找到了一个，但是左边可能还有，搜索区间变成[x,m]</li>
<li>A[m]&gt;v 时，所求位置不可能在后面，但可能是m，因此区间变成[x,m]</li>
<li>A[m]&lt;v 时，区间变成[m+1,y]</li>
</ol>
</li>
<li>相应的可以写出upper_bound，共同构成    [L,R)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int upper_bound(int* A,int x,int y,int v)&#123;</span><br><span class="line">int m;</span><br><span class="line">while(x&lt;y)&#123;</span><br><span class="line">	m &#x3D; x+(y-x)&#x2F;2;</span><br><span class="line">	if(A[m]&lt;&#x3D;v) x &#x3D; m+1;</span><br><span class="line">	else y &#x3D; m;</span><br><span class="line">&#125;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-中"><a href="#C-中" class="headerlink" title="C++中"></a>C++中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;lower_bound(起始地址，结束地址，要查找的数值) 返回大于或等于val的第一个元素位置，返回类型为迭代器</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;upper_bound(起始地址，结束地址，要查找的数值)返回大于val的第一个元素位置，返回迭代器</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;binary_search(起始地址，结束地址，要查找的数值)  返回的是是否存在这么一个数，是一个bool值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; t;</span><br><span class="line">    t.push_back(1);</span><br><span class="line">    t.push_back(2);</span><br><span class="line">    t.push_back(3);</span><br><span class="line">    t.push_back(5);</span><br><span class="line">    t.push_back(5);</span><br><span class="line">    t.push_back(7);</span><br><span class="line">    t.push_back(8);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    int low&#x3D;lower_bound(t.begin(),t.end(),5) - t.begin();</span><br><span class="line">    int upp&#x3D;upper_bound(t.begin(),t.end(),5) - t.begin();</span><br><span class="line">    cout&lt;&lt;low&lt;&lt;endl;&#x2F;&#x2F;3</span><br><span class="line">    cout&lt;&lt;upp&lt;&lt;endl;&#x2F;&#x2F;5</span><br><span class="line"></span><br><span class="line">    return 0；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="递归与分支"><a href="#递归与分支" class="headerlink" title="递归与分支"></a>递归与分支</h1><h2 id="棋盘覆盖问题"><a href="#棋盘覆盖问题" class="headerlink" title="棋盘覆盖问题"></a>棋盘覆盖问题</h2><p>有一个2<sup>k</sup>×2<sup>k</sup>的方格棋盘，恰有一个方格是黑色的，其他是白色的。你的任务是用包含3个方格的L型牌覆盖所有白色方格。黑色方格不能被覆盖，且任意一个白色方格不能同时被两个或更多牌覆盖。问至少要用多少L型牌。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>分治法，每次将棋盘分割成4块，每块都是2<sup>k-1</sup>×2<sup>k-1</sup>。</li>
<li>对于有黑格子的块使用递归解决，没有黑格子的块构造出一个黑格子。</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;（tr,tc)表示棋盘左上角坐标 (dr,dc)表示黑块坐标</span><br><span class="line">void ChessBoard(int tr,int tc,int dr,int dc,int size)</span><br><span class="line">&#123;</span><br><span class="line">    if(size&#x3D;&#x3D;1) return;</span><br><span class="line">    int t&#x3D;tile++,s&#x3D;size&#x2F;2;</span><br><span class="line"></span><br><span class="line">    if(dr&lt;tr+s &amp;&amp; dc&lt;tc+s)&#x2F;&#x2F;&#x2F;在左上角区域内</span><br><span class="line">    	ChessBoard(tr,tc,dr,dc,s);</span><br><span class="line">    else&#x2F;&#x2F;&#x2F;不在左上角区域内</span><br><span class="line">    &#123;</span><br><span class="line">        Board[tr+s-1][tc+s-1]&#x3D;t;&#x2F;&#x2F;&#x2F;用t号(用一个数字表示)L型骨牌覆盖右下角</span><br><span class="line">        ChessBoard(tr,tc,tr+s-1,tc+s-1,s);&#x2F;&#x2F;&#x2F;覆盖剩余方格</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(dr&lt;tr+s &amp;&amp; dc&gt;&#x3D;tc+s)&#x2F;&#x2F;&#x2F;在右上角区域内</span><br><span class="line">        ChessBoard(tr,tc+s,dr,dc,s);</span><br><span class="line">    else&#x2F;&#x2F;&#x2F;不在右上角的区域内</span><br><span class="line">    &#123;</span><br><span class="line">        Board[tr+s-1][tc+s]&#x3D;t;</span><br><span class="line">        ChessBoard(tr,tc+s,tr+s-1,tc+s,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(dr&gt;&#x3D;tr+s &amp;&amp; dc&lt;tc+s)</span><br><span class="line">        ChessBoard(tr+s,tc,dr,dc,s);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Board[tr+s][tc+s-1]&#x3D;t;</span><br><span class="line">        ChessBoard(tr+s,tc,tr+s,tc+s-1,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(dr&gt;&#x3D;tr+s &amp;&amp; dc&gt;&#x3D;tc+s)</span><br><span class="line">        ChessBoard(tr+s,tc+s,dr,dc,s);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Board[tr+s][tc+s]&#x3D;t;</span><br><span class="line">        ChessBoard(tr+s,tc+s,tr+s,tc+s,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环日程表问题"><a href="#循环日程表问题" class="headerlink" title="循环日程表问题"></a>循环日程表问题</h2><p>有n=2<sup>k</sup>个运动员进行网球循环赛，需要设计比赛日程表。每个选手必须与其他n-1个选手各赛一次：每个选手每天只能赛一次，循环赛一共进行n-1天。按此要求设计一张比赛日程表，该表用n行和n-1列，第i行j列为第i个选手第j天遇到的选手。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>观察紫书P230页给出的样例结果，发现结果是对称矩阵，且每一个小块处都是对称的，所以考虑使用分治法。</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; (1 &lt;&lt; 10);</span><br><span class="line">int table[maxn][maxn];</span><br><span class="line">void fill(int x, int y, int n);&#x2F;&#x2F;填充左上角为x,y的，长度为n的方格</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	table[0][0] &#x3D; 1;</span><br><span class="line">	fill(0, 0, n);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">			printf(&quot;%d &quot;, table[i][j]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void fill(int x, int y, int n) &#123;</span><br><span class="line">	if (n &#x3D;&#x3D; 1) return;</span><br><span class="line">	int half &#x3D; n &#x2F; 2;</span><br><span class="line"></span><br><span class="line">	table[x + half][y + half] &#x3D; table[x][y];</span><br><span class="line">	table[x + half][y] &#x3D; table[x][y + half] &#x3D; table[x][y] + half;</span><br><span class="line">	fill(x, y, half);</span><br><span class="line">	fill(x + half, y, half);</span><br><span class="line">	fill(x, y + half, half);</span><br><span class="line">	fill(x + half, y + half, half);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="巨人与鬼"><a href="#巨人与鬼" class="headerlink" title="巨人与鬼"></a>巨人与鬼</h2><p>在平面上有n个巨人和n个鬼，没有三者在同一条直线上。每个巨人需要选择一个不同的鬼，向其发送质子流消灭它，质子流呈直线。质子流不能交叉，要求设计一种巨人和鬼的配对方法。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>使用分治法，以连线两侧内的巨人和鬼的数量相等来分割，然后递归解决。</li>
<li>考虑最左下角的点，假设它是一个巨人，然后将其余的点按照极角从小到大排列依次检查<ol>
<li>如果第一个点是鬼，则匹配完成，剩下的鬼和巨人一样多</li>
<li>如果第一个点是巨人，那么继续检查知道鬼和巨人一样多。</li>
<li>以这个连线为分界，分割问题，递归解决。</li>
</ol>
</li>
</ol>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">int x, y, flag, id;</span><br><span class="line">&#125;;</span><br><span class="line">node p[1000], base;</span><br><span class="line">int ans[1000];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void go(int l, int r);&#x2F;&#x2F;在数组中的左右边界</span><br><span class="line">bool cmp1(node &amp;a, node&amp;b) &#123; return a.y &lt; b.y || a.y &#x3D;&#x3D; b.y&amp;&amp;a.x &lt; b.x; &#125;</span><br><span class="line">bool cmp2(node &amp;a, node &amp;b) &#123;</span><br><span class="line">	return atan2((a.y - base.y), (a.x - base.x)) &lt; atan2((b.y - base.y), (b.x - base.x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int T;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">while (T--)</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d %d %d&quot;, &amp;p[i].flag, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">		p[i].id &#x3D; i + 1;</span><br><span class="line">	&#125;</span><br><span class="line">	go(0, n - 1);</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D;n; i++)</span><br><span class="line">		printf(&quot;%d &quot;, ans[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void go(int l, int r) &#123;</span><br><span class="line">if (l &gt; r)</span><br><span class="line">	return;</span><br><span class="line">sort(p + l, p + r + 1, cmp1);</span><br><span class="line">base &#x3D; p[l];</span><br><span class="line">sort(p + l + 1, p + r + 1, cmp2);</span><br><span class="line">int c1 &#x3D; 0, c2 &#x3D; 0;</span><br><span class="line">int k &#x3D; r;</span><br><span class="line">while (!(p[k].flag !&#x3D; base.flag&amp;&amp;c1 &#x3D;&#x3D; c2))</span><br><span class="line">&#123;</span><br><span class="line">	if (p[k].flag &#x3D;&#x3D; base.flag) c1++;&#x2F;&#x2F;巨人</span><br><span class="line">	else c2++;</span><br><span class="line">	k--;</span><br><span class="line">&#125;</span><br><span class="line">ans[p[k].id] &#x3D; base.id;</span><br><span class="line">ans[base.id] &#x3D; p[k].id;</span><br><span class="line">go(l + 1, k - 1);</span><br><span class="line">go(k + 1, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h1><h2 id="乘船问题"><a href="#乘船问题" class="headerlink" title="乘船问题"></a>乘船问题</h2><p>第一行输入s,表示测试数据的组数；<br>每组数据的第一行包括两个整数w，n，80&lt;=w&lt;=200,1&lt;=n&lt;=300，w为一条独木舟的最大承载量,n为人数；<br>接下来的一组数据为每个人的重量（不能大于船的承载量）；<br>输出<br>每组人数所需要的最少独木舟的条数。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol>
<li>贪心法：给最轻的人i找最重j的匹配，如果仍然超重，那么这个重人只能单独坐船。</li>
<li>证明：使用反证法<ol>
<li>如果目前i单独乘船，那么令j和他同乘不会使总的乘船数量增多。</li>
<li>如果目前i和k同乘，那么根据假设，k应该比j轻，那么k和j交换之后k所在的船仍然不会超重。按照贪心法的过程，交换后j所在船也不会超重。</li>
<li>因此，这样贪心不会丢失最优解</li>
</ol>
</li>
</ol>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 305;</span><br><span class="line">int weight[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int T, c, n;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">while (T--)</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d %d&quot;, &amp;c, &amp;n);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;weight[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int l &#x3D; 0, r &#x3D; n - 1;</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	sort(weight, weight + n);</span><br><span class="line">	while (l &lt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		if (weight[l] + weight[r] &lt;&#x3D; c)</span><br><span class="line">			l++;</span><br><span class="line">		ans++;</span><br><span class="line">		r--;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择不相交区间"><a href="#选择不相交区间" class="headerlink" title="选择不相交区间"></a>选择不相交区间</h2><p>输入n个区间，从中选出尽量多的不相交区间。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>首先，最明显的是如果区间A完全包含于区间B，那么应该选择区间A。所以贪心的策略是一定要选择第一个区间</p>
</li>
<li><p>证明： 首先对区间进行排序，b已经有序，观察a的关系</p>
<ol>
<li>如果a1&gt;a2，那么区间2包含了区间1，则应该选择区间1(依据1中讨论),并且以后的所有选中的区间i都要满足a1&lt;ai</li>
<li>在1的条件下，则a也有序。如果区间2和区间1完全不相交，那么没有影响；否则区间1和区间2只能保留一个。</li>
<li>考虑临近的区间3，区间1和区间3的重叠部分被区间2所包含，根据1中讨论，应该保留区间1。这也就说明不能因为其他区间的影响而不选择区间1，所以贪心策略成立。</li>
</ol>
</li>
<li><p>选择区间1后要把所有和区间1相交的区间排除在外，需要记录上一个被选择的区间编号。</p>
</li>
</ol>
<h3 id="代码-NBUT-今年暑假不AC"><a href="#代码-NBUT-今年暑假不AC" class="headerlink" title="代码 NBUT 今年暑假不AC"></a>代码 NBUT 今年暑假不AC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int a, b;</span><br><span class="line">	bool operator &lt; (const node&amp;x) const &#123; return b &lt; x.b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node g[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;g[i].a, &amp;g[i].b);</span><br><span class="line">			if (g[i].a &gt; g[i].b)</span><br><span class="line">				swap(g[i].a, g[i].b);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sort(g, g + n);</span><br><span class="line"></span><br><span class="line">		int r &#x3D; -1;</span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			if (g[i].a &gt;&#x3D; r) &#123;&#x2F;&#x2F;此处是否取等取决于题目中端点共有算几次</span><br><span class="line">				ans++;</span><br><span class="line">				r &#x3D; g[i].b;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间选点问题"><a href="#区间选点问题" class="headerlink" title="区间选点问题"></a>区间选点问题</h2><p>在数轴上有n个闭区间[a,b]，要求去尽量少的点，使得每个区间内都有至少一个点</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ol>
<li>如果区间1被区间2完全包含，那么在区间1内取的点必定在区间2中。</li>
<li>如果区间1和区间2部分相交，且区间2在后面，那么在区间1的尾部取点最可能在区间2中。</li>
<li>所以贪心策略是取最后一个点</li>
<li>所以首先对b进行排序，每次取最后一个点，如果某个区间的起始点超过了最后一个点的坐标，那么要更新最后一个点的位置。</li>
</ol>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><p>其实和选择不相交区间是一样的,此处留下一个板子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1005;</span><br><span class="line">struct node &#123;</span><br><span class="line">int a, b;</span><br><span class="line">bool operator &lt; (const node &amp;x)const &#123; return b &lt; x.b || b &#x3D;&#x3D; x.b&amp;&amp;a &lt; x.a; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node p[maxn];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;n)&#x3D;&#x3D;1)</span><br><span class="line">&#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d %d&quot;, &amp;p[i].a, &amp;p[i].b);</span><br><span class="line">		if (p[i].a &gt; p[i].b)</span><br><span class="line">			swap(p[i].a, p[i].b);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(p, p + n);</span><br><span class="line">	int r &#x3D; -1;&#x2F;&#x2F;此处也可以设置为p[0].b，同时ans&#x3D;1</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (p[i].a &gt; r) &#123;</span><br><span class="line">			ans++;</span><br><span class="line">			r &#x3D; p[i].b;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;ans: %d\n&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间覆盖问题"><a href="#区间覆盖问题" class="headerlink" title="区间覆盖问题"></a>区间覆盖问题</h2><p>从n个区间中选择尽量少的区间覆盖目标区间[s,t]。代码对应覆盖[0,t]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1005;</span><br><span class="line">int n;</span><br><span class="line">struct node &#123;</span><br><span class="line">int a, b;</span><br><span class="line">bool operator &lt; (const node &amp;x)const &#123; return a &lt; x.a || a &#x3D;&#x3D; x.a &amp;&amp; b&gt;x.b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node p[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int T;</span><br><span class="line">int s, t;</span><br><span class="line">s &#x3D; 0;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">while (T--)</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">	n &#x3D; 0;</span><br><span class="line">	while (scanf(&quot;%d %d&quot;, &amp;p[n].a, &amp;p[n].b) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">		if (p[n].a &#x3D;&#x3D; 0 &amp;&amp; p[n].b &#x3D;&#x3D; 0)</span><br><span class="line">			break;</span><br><span class="line">		if (p[n].a &gt; p[n].b)</span><br><span class="line">			swap(p[n].a, p[n].b);</span><br><span class="line">		if (p[n].b &lt; t || p[n].b &lt; s) continue;</span><br><span class="line">		p[n].a &#x3D; max(p[n].a, s);</span><br><span class="line">		p[n].b &#x3D; min(p[n].b, t);</span><br><span class="line">		if (p[n].a &lt; p[n].b)</span><br><span class="line">			n++;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(p, p + n);</span><br><span class="line">	if (!n||p[0].a !&#x3D; s)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;ans: 0\n&quot;);</span><br><span class="line">		continue;</span><br><span class="line">	&#125;</span><br><span class="line">	int r &#x3D; s;</span><br><span class="line">	int ans &#x3D;0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (p[i].b &gt; r) &#123;</span><br><span class="line">			r &#x3D; p[i].b;</span><br><span class="line">			ans++;</span><br><span class="line">			printf(&quot;%d %d\n&quot;, p[i].a, p[i].b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;ans: %d\n\n&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Huffman-编码"><a href="#Huffman-编码" class="headerlink" title="Huffman 编码"></a>Huffman 编码</h1><h2 id="Huffman-树"><a href="#Huffman-树" class="headerlink" title="Huffman 树"></a>Huffman 树</h2><ol>
<li>n个叶子的二叉树一定对应一个前缀码。如果编码a是编码b的前缀，则a所对应的结点一定为b所对应节点的先祖，而两个叶子不会有先祖后代的关系。</li>
<li>最优前缀码一定可以写成二叉树</li>
</ol>
<h2 id="Huffman-算法-O-nlogn"><a href="#Huffman-算法-O-nlogn" class="headerlink" title="Huffman 算法 O(nlogn)"></a>Huffman 算法 O(nlogn)</h2><p>把每个字符看作一个单结点子树放在一个树集合中，每颗子树的权值等于相应字符的频率。每次取权值最小的两颗紫书合并成一颗新树，并重新放到集合中。新树的权值等于两颗子树权值之和。</p>
<h2 id="相关问题-UVA10954"><a href="#相关问题-UVA10954" class="headerlink" title="相关问题 UVA10954"></a>相关问题 UVA10954</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, x;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">			pq.push(x);</span><br><span class="line">		&#125;</span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">			int a &#x3D; pq.top(); pq.pop();</span><br><span class="line">			int b &#x3D; pq.top(); pq.pop();</span><br><span class="line">			ans +&#x3D; a + b;</span><br><span class="line">			pq.push(a + b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/24/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">最大连续和问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-24 12:27:27" itemprop="dateCreated datePublished" datetime="2020-01-24T12:27:27+08:00">2020-01-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-02 10:16:11" itemprop="dateModified" datetime="2020-02-02T10:16:11+08:00">2020-02-02</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>给定一个长度为n的序列1,A2,···,An，求最大连续和</p>
<h1 id="O-n3"><a href="#O-n3" class="headerlink" title="O(n3)"></a>O(n<sup>3</sup>)</h1><p>枚举始末位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">for(int i&#x3D;0;i&lt;&#x3D;n;i++)</span><br><span class="line">	for(int j&#x3D;0;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">		int sum &#x3D; 0;</span><br><span class="line">		for(int k&#x3D;i;k&lt;&#x3D;j;k++)&#123;</span><br><span class="line">			sum+&#x3D;A[k];</span><br><span class="line">			tot++;</span><br><span class="line">		&#125;</span><br><span class="line">		if(sum&gt;best) best&#x3D;sum;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="O-n2"><a href="#O-n2" class="headerlink" title="O(n2)"></a>O(n<sup>2</sup>)</h1><p>先递推的求出前i项和，利用Sj-Si求出i-j的连续和</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">S[0] &#x3D; 0;</span><br><span class="line">for(int i&#x3D;0;i&lt;n;i++) S[i] &#x3D; A[i]+S[i-1];</span><br><span class="line">for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">for(int j &#x3D; i;j &lt; n;j++)</span><br><span class="line">best &#x3D; max(best,S[j]-S[i-1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分治法-O-nlogn"><a href="#分治法-O-nlogn" class="headerlink" title="分治法 O(nlogn)"></a>分治法 O(nlogn)</h1><ol>
<li>划分问题：将序列分成数量尽可能相等两部分</li>
<li>递归求解：分别求出完全位于左半部和完全位于右半部的最佳序列</li>
<li>合并问题：求出起点位于左半，终点位于右半的连续和序列<ol>
<li>注：递归方程T(n) = 2T(n/2)+O(n)</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int maxsum(int* A, int x, int y)&#123;</span><br><span class="line">	if(y-x&#x3D;&#x3D;1) return A[x];</span><br><span class="line">	int m &#x3D; x+(y-x)&#x2F;2;</span><br><span class="line">	int maxs &#x3D; max(maxsum(A,x,m),maxsum(A,m,y));</span><br><span class="line">	int v, L, R;</span><br><span class="line">	v&#x3D; 0;L &#x3D; A[m-1];</span><br><span class="line">	for(int i &#x3D; m-1;i &gt;&#x3D; x;i--)</span><br><span class="line">		L &#x3D; max(L,v +&#x3D; A[i]);</span><br><span class="line">	v&#x3D; 0;R &#x3D; A[m];</span><br><span class="line">	for(int i &#x3D; m;i &lt; y;i++)</span><br><span class="line">		R &#x3D; max(R,v +&#x3D; A[i]);</span><br><span class="line">	return max(maxs, L+R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/24/%E6%88%98%E5%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/%E6%88%98%E5%9C%BA/" class="post-title-link" itemprop="url">战场</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-24 11:11:04 / Modified: 13:02:07" itemprop="dateCreated datePublished" datetime="2020-01-24T11:11:04+08:00">2020-01-24</time>
            </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVA-11853-战场"><a href="#UVA-11853-战场" class="headerlink" title="UVA 11853 战场"></a>UVA 11853 战场</h1><p>有一个1000*1000的正方形战场，战场西南角的坐标为(0,0)，西北角的坐标为(0,1000)。战场上有n个敌人，给定每个敌人的坐标和攻击半径，求能否从西边进入，从东边离开。如果有多个位置进出，则求出最北的进/出位置。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>地图比较大，敌人相对较少。转换思路，考虑能否从上边界踩着敌人到达下边界</p>
<ol>
<li>如果能，则说明敌人将战场从中分割，即无解。</li>
<li>如果不能，在选择最北的点。</li>
</ol>
</li>
<li><p>将问题转换成了图的连通性问题，下面给出bfs和dfs两种解法</p>
</li>
<li><p>dfs速度远远快于bfs</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    bool dfs(int u)</span><br><span class="line">	&#123;</span><br><span class="line">	if (vis[u]) return false;</span><br><span class="line">	vis[u] &#x3D; 1;</span><br><span class="line">	if (y[u] &lt; r[u]) return true;</span><br><span class="line">	for (int v &#x3D; 0; v &lt; n; v++) &#123;</span><br><span class="line">		if (intersect(u, v) &amp;&amp; dfs(v)) </span><br><span class="line">			return true;</span><br><span class="line">	&#125;</span><br><span class="line">	check(u);</span><br><span class="line">	return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">1. 注意是在走不通时，才更新进入点</span><br></pre></td></tr></table></figure>
<h3 id="intersect-判断两个圆是否相交"><a href="#intersect-判断两个圆是否相交" class="headerlink" title="intersect 判断两个圆是否相交"></a>intersect 判断两个圆是否相交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool intersect(int a, int b) &#123;</span><br><span class="line">return sqrt((x[a] - x[b])*(x[a] - x[b]) + (y[a] - y[b])*(y[a] - y[b])) &lt; r[a] + r[b];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="check-更新进入点"><a href="#check-更新进入点" class="headerlink" title="check 更新进入点"></a>check 更新进入点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void check(int u)</span><br><span class="line">&#123;</span><br><span class="line">if (x[u] &lt; r[u]) left &#x3D; min(left, y[u] - sqrt(r[u] * r[u] - x[u] * x[u]));</span><br><span class="line">if (x[u] + r[u] &gt; W) right &#x3D; min(right, y[u] - sqrt(r[u] * r[u] - (W - x[u])*(W - x[u])));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">#ifdef local</span><br><span class="line">freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">#endif &#x2F;&#x2F; local</span><br><span class="line">while (~scanf(&quot;%d&quot;, &amp;n)) &#123;</span><br><span class="line">	bool ok &#x3D; true;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	left &#x3D; right &#x3D; W;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, x + i, y + i, r + i);</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (r[i] + y[i] &gt;&#x3D; W &amp;&amp; dfs(i)) &#123; ok &#x3D; false; break; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (ok) printf(&quot;0.00 %.2lf 1000.00 %.2lf\n&quot;, left, right);</span><br><span class="line">	else printf(&quot;IMPOSSIBLE\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#pragma warning(disable:4996)</span><br><span class="line">#define LOCAL</span><br><span class="line">#ifdef LOCAL</span><br><span class="line">FILE *fin &#x3D; freopen(&quot;战场in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">FILE *fout &#x3D; freopen(&quot;战场out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">#endif </span><br><span class="line">using namespace std;</span><br><span class="line">int vis[1005];</span><br><span class="line">int n;</span><br><span class="line">double le, ri;</span><br><span class="line">struct Node &#123;</span><br><span class="line">double x, y, r;</span><br><span class="line">Node(double x, double y, double r) :x(x), y(y), r(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Node&gt; enemy;</span><br><span class="line">bool intersect(int u, int v) &#123;</span><br><span class="line">return sqrt(pow(enemy[u].x - enemy[v].x, 2) + pow(enemy[u].y - enemy[v].y, 2)) &lt; enemy[u].r + enemy[v].r;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line">void check_circle(int u) &#123;</span><br><span class="line">if (enemy[u].x - enemy[u].r &lt; 0)</span><br><span class="line">	le &#x3D; min(le, enemy[u].y - sqrt(enemy[u].r * enemy[u].r - enemy[u].x * enemy[u].x));</span><br><span class="line">if (enemy[u].x + enemy[u].r &gt; 1000)</span><br><span class="line">	ri &#x3D; min(ri, enemy[u].y - sqrt(enemy[u].r * enemy[u].r - (1000 - enemy[u].x) *(1000 - enemy[u].x)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool bfs(int i) &#123;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(i);</span><br><span class="line">while (!q.empty()) &#123;</span><br><span class="line">	int u &#x3D; q.front(); q.pop();</span><br><span class="line">	if (enemy[u].y - enemy[u].r &lt;&#x3D; 0) &#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	vis[u] &#x3D; 1;</span><br><span class="line">	check_circle(u);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (!vis[i] &amp;&amp; intersect(i, u))</span><br><span class="line">			q.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">while (cin &gt;&gt; n) &#123;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	enemy.clear();</span><br><span class="line">	le &#x3D; ri &#x3D; 1000;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		int x, y, r;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; r;</span><br><span class="line">		enemy.push_back(Node(x, y, r));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool flag &#x3D; true;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">		if (enemy[i].y + enemy[i].r &gt;&#x3D; 1000)</span><br><span class="line">			flag &#x3D; bfs(i);</span><br><span class="line"></span><br><span class="line">	if (!flag) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;IMPOSSIBLE&quot; &lt;&lt; endl;</span><br><span class="line">		continue;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;0.00 %.2f 1000.00 %.2f\n&quot;,le, ri);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/24/%E5%88%86%E6%95%B0%E6%8B%86%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/24/%E5%88%86%E6%95%B0%E6%8B%86%E5%88%86/" class="post-title-link" itemprop="url">分数拆分</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-24 10:47:03" itemprop="dateCreated datePublished" datetime="2020-01-24T10:47:03+08:00">2020-01-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-01 23:54:18" itemprop="dateModified" datetime="2020-02-01T23:54:18+08:00">2020-02-01</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVA-10976-分数拆分"><a href="#UVA-10976-分数拆分" class="headerlink" title="UVA 10976 分数拆分"></a>UVA 10976 分数拆分</h1><p>输入正整数k，找到所有正整数x&gt;=y,使得1/k=1/x+1/y</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>枚举y，算x。 关键在于找到枚举的上界。</li>
<li>由x&gt;=y,1/x&lt;=1/y,则1/k-1/y=1/x&lt;=1/y，则y&lt;=2k</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 10000;</span><br><span class="line">int cnt, n;</span><br><span class="line">int ans[maxn][2];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int x, y;</span><br><span class="line">	int c;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">	cnt &#x3D; 0;</span><br><span class="line">	for (y &#x3D; n + 1; y &lt;&#x3D; 2 * n; y++) &#123;</span><br><span class="line">		if ((n*y % (y - n)))</span><br><span class="line">			continue;</span><br><span class="line">		x &#x3D; (n*y) &#x2F; (y - n);</span><br><span class="line"></span><br><span class="line">		ans[cnt][0] &#x3D; x;</span><br><span class="line">		ans[cnt][1] &#x3D; y;</span><br><span class="line">		cnt++;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;, cnt);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; cnt; i++)</span><br><span class="line">		printf(&quot;1&#x2F;%d &#x3D; 1&#x2F;%d + 1&#x2F;%d\n&quot;, n, ans[i][0], ans[i][1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cuienbo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">159</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cuienbo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.0
  </div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
  
</body>
</html>
