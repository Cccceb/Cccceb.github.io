<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://github.com/Cccceb/Cccceb.github.io').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Ceb">
<meta property="og:url" content="https://github.com/Cccceb/Cccceb.github.io/page/15/index.html">
<meta property="og:site_name" content="Ceb">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Cuienbo">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://github.com/Cccceb/Cccceb.github.io/page/15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Ceb</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a href="https://github.com/you"><img style="position:absolute;" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_left_gray_6d6d6d.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>  
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ceb</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/" class="post-title-link" itemprop="url">二叉树的层序遍历</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:47:05" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uva-122-树的层序遍历"><a href="#uva-122-树的层序遍历" class="headerlink" title="uva 122 树的层序遍历"></a>uva 122 树的层序遍历</h1><p>树状结构在电脑科学的许多领域中都相当重要。本问题牵涉到建立树及走访树。</p>
<p>给你一二元树，你的任务是写一个程式来列印依「阶层（level-order）」走访的结果。在本问题中，二元树的每个节点含有一个正整数，并且节点的数目最少1个，最多256个。</p>
<p>在「阶层」走访中，依阶层从低到高，同阶层从左到右的次序来列印。例如以下的二元树阶层走访的结果为：5, 4, 8, 11, 13, 4, 7, 2, 1</p>
<p>在本问题中，二元树以节点来表示。每个节点以一对(n,s)来表示。n代表此节点的值，s为一字串，代表从根节点到达此节点的路径。其中L代表往左，R代表往右。所以在上方的图中内容为13的节点其表示法为(13,RL)，而内容为2的节点其表示法为(2,LLR)，而根节点为(5,)。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>先根据给出的对，构造二叉树，在借助队列层序遍历</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    #include&lt;iostream&gt;</span><br><span class="line">    #include&lt;string&gt;</span><br><span class="line">    #include&lt;queue&gt;</span><br><span class="line">    # pragma warning(disable:4996)</span><br><span class="line">    # define LOCAL</span><br><span class="line">    # ifdef LOCAL</span><br><span class="line">    FILE *fin &#x3D; freopen(&quot;树的层序遍历in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    FILE *fout &#x3D; freopen(&quot;树的层序遍历out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    # endif </span><br><span class="line">    using namespace std;</span><br><span class="line">    struct node &#123;</span><br><span class="line">    	bool have_val;</span><br><span class="line">    	int v;</span><br><span class="line">    	node *left, *right;</span><br><span class="line">    	node() :have_val(false), left(NULL), right(NULL) &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    node* root;</span><br><span class="line">    node * newnode() &#123;</span><br><span class="line">    </span><br><span class="line">    	return new node();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">	bool flag;</span><br><span class="line">	void addnode(string s, int v) &#123;</span><br><span class="line">	node * u &#x3D; root;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; s.length()-1; i++)</span><br><span class="line">		if (s[i] &#x3D;&#x3D; &#39;L&#39;) &#123;</span><br><span class="line">			if (u-&gt;left &#x3D;&#x3D; NULL)</span><br><span class="line">				u-&gt;left &#x3D; newnode();</span><br><span class="line">			u &#x3D; u-&gt;left;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		else if (s[i] &#x3D;&#x3D; &#39;R&#39;) &#123;</span><br><span class="line">			if (u-&gt;right &#x3D;&#x3D; NULL)</span><br><span class="line">				u-&gt;right &#x3D; newnode();</span><br><span class="line">			u &#x3D; u-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">	if (u-&gt;have_val) &#123;</span><br><span class="line">		flag &#x3D; false;</span><br><span class="line">	&#125;</span><br><span class="line">	u-&gt;have_val &#x3D; true;	</span><br><span class="line">	u-&gt;v &#x3D; v;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	int main() &#123;</span><br><span class="line">	string s;</span><br><span class="line">	</span><br><span class="line">	while (cin.peek() !&#x3D; EOF&amp;&amp;cin.peek()!&#x3D;&#39;\n&#39;) &#123;</span><br><span class="line">		root &#x3D; newnode();</span><br><span class="line"></span><br><span class="line">		flag &#x3D; true;</span><br><span class="line"></span><br><span class="line">		while (cin &gt;&gt; s &amp;&amp; s !&#x3D; &quot;()&quot;) &#123;</span><br><span class="line">			int v;</span><br><span class="line">			sscanf(&amp;s[1], &quot;%d&quot;, &amp;v);</span><br><span class="line">&gt;※※※提取字符串中的数字的方法！！！</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F;		cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">			s &#x3D; s.substr(s.find(&#39;,&#39;) + 1);</span><br><span class="line">			addnode(s, v);</span><br><span class="line">		&#125;</span><br><span class="line">		getchar();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		if (!flag) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;not complete&quot; &lt;&lt; endl;</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		node *tmp &#x3D; root;</span><br><span class="line">		queue&lt;node *&gt; travel;</span><br><span class="line">		travel.push(tmp);</span><br><span class="line">&gt;注意层序遍历的初始值</span><br><span class="line"></span><br><span class="line">		string ans;</span><br><span class="line">		while (!travel.empty()) &#123;</span><br><span class="line">			tmp&#x3D; travel.front();</span><br><span class="line">			travel.pop();</span><br><span class="line">			</span><br><span class="line">			if (!tmp-&gt;have_val) &#123;</span><br><span class="line">				flag &#x3D; false;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			ans &#x3D;ans+&quot; &quot;+to_string( tmp-&gt;v);</span><br><span class="line">			if (tmp-&gt;left) travel.push(tmp-&gt;left);</span><br><span class="line">			if (tmp-&gt;right) travel.push(tmp-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">		flag ? cout &lt;&lt; ans.substr(1) &lt;&lt; endl : cout &lt;&lt; &quot;not complete&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li><p>首先一定要学习提取字符串中数字的方法</p>
<pre><code>：sscanf(&amp;数字起始地址,&quot;格式&quot;，&amp;存储变量名)</code></pre></li>
<li><p>动态申请空间的时候，要释放掉，否则会导致内存泄漏；</p>
</li>
<li><p>可以通过维护一个简单的内存池实现</p>
<pre><code>queue&lt;Node*&gt; freenodes;
   Node node[maxn];

void init(){
    for(int i=0;i&lt;maxn;i++)
    freenodes.push(&amp;node[i]);    
}

Node* new(){
    Node* u = freenodes.front();
    //处理u的成员变量
    freenodes.pop();
    return u;
}

void dele(Node *u){
    freenodes.push(u);
}</code></pre></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E5%8F%8D%E7%89%87%E8%AF%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E5%8F%8D%E7%89%87%E8%AF%AD/" class="post-title-link" itemprop="url">反片语</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-20 11:48:55" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-22 13:21:38" itemprop="dateModified" datetime="2020-01-22T13:21:38+08:00">2020-01-22</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uav156-反片语"><a href="#uav156-反片语" class="headerlink" title="uav156 反片语"></a>uav156 反片语</h1><p>输入一些单词，找出所有满足如下条件的单词：该单词不能通过字母重排，得到输入文本的另外一个单词。在判断是否满足条件时，字母不分大小写，但在输出时应保留输入中的大小写，按字典序进行排列(所有大写字母在所有小写字母的前面)</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>由于单词可以重拍，所有直接对各单词进行标准化，以便于使用map；map<br>为&lt;string,int&gt;，其中值对应单词出现次数；使用向量word记录原单词，向量ans记录答案序列；</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   #include&lt;iostream&gt;</span><br><span class="line">   #include&lt;map&gt;</span><br><span class="line">   #include&lt;string&gt;</span><br><span class="line">   #include&lt;vector&gt;</span><br><span class="line">   #include&lt;algorithm&gt;</span><br><span class="line">   using namespace std;</span><br><span class="line">   vector&lt;string&gt;word;</span><br><span class="line">   map&lt;string, int&gt; cnt;</span><br><span class="line">   string standard(const string &amp;in) &#123;</span><br><span class="line">string s &#x3D; in;</span><br><span class="line">for (int i &#x3D; 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">	s[i] &#x3D; tolower(s[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>此处书上是按上述方式给的，如果形参表写成const string s，之后直接操作s，并且返回s也没发现问题。</li>
<li>注意此处const的用法，编写该模块前如果认定了in仅作为输入，则加上const防止之后错误的操作。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sort(s.begin(), s.end());</span><br><span class="line">return s;</span><br><span class="line">   &#125;</span><br><span class="line">   int main() &#123;</span><br><span class="line">string s;</span><br><span class="line">while (cin &gt;&gt; s) &#123;</span><br><span class="line">	if (s[0] &#x3D;&#x3D; &#39;# &#39;)	break;</span><br><span class="line">	word.push_back(s);</span><br><span class="line">	string r &#x3D; standard(s);</span><br><span class="line">	if (!cnt.count(r)) cnt[r] &#x3D; 0;</span><br><span class="line">	cnt[r]++;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;string&gt; ans;</span><br><span class="line">for (int i &#x3D; 0; i &lt; word.size(); i++) &#123;</span><br><span class="line">	if (cnt[standard(word[i])] &#x3D;&#x3D; 1) ans.push_back(word[i]);</span><br><span class="line">&#125;</span><br><span class="line">sort(ans.begin(), ans.end());</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; ans.size(); i++) &#123;</span><br><span class="line">	cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li>本题主要是map的应用，想要用map，标准化的步骤是关键。</li>
<li>map提供了”[]”运算符，map[键]=值，使得map可以像数组一样使用。事实上，map也成为”关联数组”。</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E5%8F%A4%E4%BB%A3%E8%B1%A1%E5%BD%A2%E7%AC%A6%E5%8F%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E5%8F%A4%E4%BB%A3%E8%B1%A1%E5%BD%A2%E7%AC%A6%E5%8F%B7/" class="post-title-link" itemprop="url">古代象形符号</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-20 11:48:55" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-22 13:21:51" itemprop="dateModified" datetime="2020-01-22T13:21:51+08:00">2020-01-22</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uva-1103-古代象形符号"><a href="#uva-1103-古代象形符号" class="headerlink" title="uva 1103 古代象形符号"></a>uva 1103 古代象形符号</h1><p>描述： 为了理解早期文明，考古学家经常研究用古代语言编写的文本。在3000多年前的埃及使用的一种语言是基于称为象形文字的字符。如图显示了六个象形文字及其名称，在这个题目中，您需要编写一个程序来识别这六个字。 图c1<br>输入描述： 输入由几个测试用例组成，每个测试用例描述一个包含一个或多个的图像 象形文字选自图C.1所示的那些。图像以一系列水平扫描线的形式给出，这些水平扫描线由黑色像素（由1表示）和白色像素（由0表示）组成。在输入数据中，每个扫描线以十六进制表示法编码。 例如，序列将表示八个像素10011100（一个黑色像素，后面是两个白色像素，依此类推） 十六进制表示法为9c。 在十六进制中仅使用数字和小写字母a到f 编码。每个测试用例的第一行包含两个整数，H和W.H（0 &lt;H≤200）是 图像中的扫描行数。 W（0 &lt;W≤50）是每个中十六进制字符的数量 线。 接下来的H行包含图像的十六进制字符，从上到下工作。 输入图像符合以下规则： •图像仅包含图C.1中所示的象形文字。 •每个图像至少包含一个有效的象形文字。 •图像中的每个黑色像素都是有效象形文字的一部分。 •每个象形文字由一组连接的黑色像素组成，每个黑色像素至少有一个顶部，底部，左侧或右侧的其他黑色像素。 •象形文字没有触及，另一个象形文字中没有象形文字。 •对角线接触的两个黑色像素将始终具有共同的触摸黑色像素。 •象形文字可能会扭曲，但每个都有一个在拓扑上等同于其中一个的形状 图C.1中的符号。 （如果每个都可以转换，两个数字在拓扑上是等价的 通过伸展而不撕裂进入另一个。） 最后一个测试用例后跟一行包含两个零的行。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>本题中的符号可以随意压缩拉伸，所以试图去直接描述其形状是不可取的。<br>观察到每个符号的空白圈数不同，可以以此特征分辨</p>
<ol>
<li>注意：要先给这个图加上一圈白边，使得所有背景的白色部分可以连接起来。此处可以使用</li>
<li>所以总体来说要进行两次遍历</li>
<li>第一次将背景中的空白遍历</li>
<li>第二次去遍历黑圈，沿途遍历黑色周围未遍历的白色部分，对于每个黑色的连通分量，统计其周围遍历到的白色连通分量数，即白洞数。每次统计完的接完插入到一个向量中。</li>
<li>对向量排序，输出<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"># pragma warning(disable:4996)</span><br><span class="line"># define LOCAL</span><br><span class="line"># ifdef LOCAL</span><br><span class="line">FILE *fin &#x3D; freopen(&quot;古代象形符号in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">FILE *fout &#x3D; freopen(&quot;古代象形符号out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line"># endif </span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;string&gt; g;</span><br><span class="line">int vis[205][205];</span><br><span class="line">string b[] &#x3D; &#123; &quot;0000&quot;,&quot;0001&quot;,&quot;0010&quot;,&quot;0011&quot;,&quot;0100&quot;,&quot;0101&quot;,&quot;0110&quot;,&quot;0111&quot;,&quot;1000&quot;,&quot;1001&quot;,&quot;1010&quot;,&quot;1011&quot; ,&quot;1100&quot;,&quot;1101&quot;,&quot;1110&quot;,&quot;1111&quot; &#125;;</span><br><span class="line">char c[] &#x3D; &#123; &#39;W&#39;,&#39;A&#39;,&#39;K&#39;,&#39;J&#39;,&#39;S&#39;,&#39;D&#39; &#125;;</span><br><span class="line">int dx[] &#x3D; &#123; -1,0,1,0 &#125;;</span><br><span class="line">int dy[] &#x3D; &#123; 0,-1,0,1 &#125;;</span><br><span class="line">struct Node &#123;</span><br><span class="line">	int x, y;</span><br><span class="line">	Node(int x, int y) :x(x), y(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int H, W, cnt, num;</span><br><span class="line">bool notOk(int a, int b) &#123;</span><br><span class="line">	return vis[a][b] || a &lt; 0 || a &gt;&#x3D; g.size() || b &lt; 0 || b &gt;&#x3D; g[a].size();</span><br><span class="line">&#125;</span><br><span class="line">void dfs(Node u, char c) &#123;</span><br><span class="line">	vis[u.x][u.y] &#x3D; 1;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">		int a &#x3D; u.x + dx[i];</span><br><span class="line">		int b &#x3D; u.y + dy[i];</span><br><span class="line">		if (notOk(a, b)) continue;</span><br><span class="line">		if (c &#x3D;&#x3D; &#39;1&#39;&amp;&amp; g[a][b] &#x3D;&#x3D; &#39;0&#39;) &#123;</span><br><span class="line"></span><br><span class="line">			cnt++;</span><br><span class="line">			dfs(Node(a, b), &#39;0&#39;);</span><br><span class="line">		&#125;</span><br><span class="line">		if (g[a][b] &#x3D;&#x3D; c) dfs(Node(a, b), c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int kase &#x3D; 0;</span><br><span class="line">	while (cin &gt;&gt; H &gt;&gt; W &amp;&amp; H) &#123;</span><br><span class="line"></span><br><span class="line">		getchar();</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		g.clear();</span><br><span class="line">		g.resize(H + 2);</span><br><span class="line">		g.front() &#x3D; string(W * 4 + 2, &#39;0&#39;);&#x2F;&#x2F;加一层白边</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; H; ++i) &#123;&#x2F;&#x2F;读取输入</span><br><span class="line">			g[i] &#x3D; &quot;0&quot;;&#x2F;&#x2F;加一层白边</span><br><span class="line">			string s;</span><br><span class="line">			getline(cin, s);</span><br><span class="line">			for (char c : s)</span><br><span class="line">			&#123;</span><br><span class="line">				if (isdigit(c)) g[i] +&#x3D; b[c - &#39;0&#39;];</span><br><span class="line">				else g[i] +&#x3D; b[c - &#39;a&#39; + 10];</span><br><span class="line">			&#125;</span><br><span class="line">			g[i] +&#x3D; &quot;0&quot;;&#x2F;&#x2F;加一层白边</span><br><span class="line">		&#125;</span><br><span class="line">		g.back() &#x3D; string(W * 4 + 2, &#39;0&#39;);&#x2F;&#x2F;加一层白边</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		dfs(Node(0, 0), &#39;0&#39;);</span><br><span class="line"></span><br><span class="line">		string ans;</span><br><span class="line">		for (int i &#x3D; 1; i &lt; g.size(); i++) &#123;</span><br><span class="line">			for (int j &#x3D; 1; j &lt; g[i].size(); j++) &#123;</span><br><span class="line">				if (!vis[i][j] &amp;&amp; g[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">					cnt &#x3D; 0;</span><br><span class="line">					dfs(Node(i, j), &#39;1&#39;);</span><br><span class="line">					ans +&#x3D; c[cnt];</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++kase &lt;&lt; &quot;: &quot;;</span><br><span class="line"></span><br><span class="line">		sort(ans.begin(), ans.end());</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1></li>
<li>注意DRY问题，本题中的dfs的写法非常值得学习</li>
<li>利用向量的直接赋值来添加百变，减少了时间复杂度</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E5%9F%8E%E5%B8%82%E6%AD%A3%E8%A7%86%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E5%9F%8E%E5%B8%82%E6%AD%A3%E8%A7%86%E5%9B%BE/" class="post-title-link" itemprop="url">城市正视图</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-20 11:48:55" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-22 13:20:39" itemprop="dateModified" datetime="2020-01-22T13:20:39+08:00">2020-01-22</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uva221-城市正视图"><a href="#uva221-城市正视图" class="headerlink" title="uva221 城市正视图"></a>uva221 城市正视图</h1><p>&ensp;如图5-4所示，有n（n≤100）个建筑物。左侧是俯视图（左上角为建筑物编号，右下角为高度），右侧是从南向北看的正视图。<br>输入每个建筑物左下角坐标（即x、y坐标的最小值）、宽度（即x方向的长度）、深度（即y方向的长度）和高度（以上数据均为实数），输出正视图中能看到的所有建筑物，按照左下角x坐标从小到大进行排序。左下角x坐标相同时，按y坐标从小到大排序。</p>
<p>&ensp;输入保证不同的x坐标不会很接近（即任意两个x坐标要么完全相同，要么差别足够大，不会引起精度问题）。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>需要对横坐标进行离散化，然后判断每个区间中点是否可以看见。</li>
<li>判断一个建筑是否在某个坐标处可见：首先，要包含这个点。其次，其他包含这个点的建筑没有比他靠近南边，并且比他高的。<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct bulid &#123;</span><br><span class="line">	double x, y, w, d, h;</span><br><span class="line">	int id;</span><br><span class="line">	bool operator &lt;(const bulid&amp;r) const&#123; return x &lt; r.x || x &#x3D;&#x3D; r.x&amp;&amp;y &lt; r.y; &#125;</span><br><span class="line">&#125;b[105];</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>注意此处要重写小于号，用于后面的sort</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int n;</span><br><span class="line">bool cover(int id, double mx) &#123;</span><br><span class="line">	return mx &gt;&#x3D; b[id].x &amp;&amp; mx &lt;&#x3D; b[id].x + b[id].w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>判断id号建筑是否包办mx这个点</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool visable(int id, double mx) &#123;</span><br><span class="line">	if (!cover(id, mx)) return false;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (b[i].y &lt; b[id].y&amp;&amp;b[i].h &gt;&#x3D; b[id].h&amp;&amp;cover(i, mx)) return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>判断id号建筑是否在mx点处可见</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  int main() &#123;</span><br><span class="line">  	int kase &#x3D; 0;</span><br><span class="line">int first &#x3D; 1;</span><br><span class="line">while (cin &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line"></span><br><span class="line">if (first) first &#x3D; 0;</span><br><span class="line">else cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">int x[2*105]&#123;&#125;;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">	cin &gt;&gt; b[i].x &gt;&gt; b[i].y &gt;&gt; b[i].w &gt;&gt; b[i].d &gt;&gt; b[i].h;</span><br><span class="line">	b[i].id &#x3D; i + 1;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>对坐标进行离散化，把连续的坐标变成离散的区间</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	x[2 * i] &#x3D; b[i].x;</span><br><span class="line">	x[2 * i + 1] &#x3D; b[i].x + b[i].w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sort(b, b + n);</span><br><span class="line">sort(x, x + 2 * n);</span><br><span class="line"></span><br><span class="line">int m &#x3D; unique(x, x + 2 * n) - x;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>对x去重，unique返回值为一个地址，所以要减去x转成索引位置</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;For map # &quot; &lt;&lt;++kase &lt;&lt; &quot;, the visible buildings are numbered as follows:&quot; &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b[0].id ;</span><br><span class="line">		for (int i &#x3D; 1; i &lt; n; i++) &#123;&#x2F;&#x2F;循环所有的建筑</span><br><span class="line">			bool vis &#x3D; false;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; m - 1; j++) &#123;&#x2F;&#x2F;循环所有区间</span><br><span class="line">				if (visable(i, (x[j] + x[j + 1]) &#x2F; 2)) &#123;</span><br><span class="line">				&#x2F;&#x2F;如果id号建筑在该区间中点可见，则在整个区间可见</span><br><span class="line">					vis &#x3D; true;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			if (vis) cout &lt;&lt;&quot; &quot;&lt;&lt; b[i].id;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E5%B8%A6%E5%AE%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E5%B8%A6%E5%AE%BD/" class="post-title-link" itemprop="url">带宽</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-20 11:48:55" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-31 23:59:29" itemprop="dateModified" datetime="2020-01-31T23:59:29+08:00">2020-01-31</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uva-140-带宽"><a href="#uva-140-带宽" class="headerlink" title="uva 140 带宽"></a>uva 140 带宽</h1><p>题意： 给一个最多8个结点的无向图，把结点重排后对于图中每条边(u,v)，u和v在排列中的最大距离称为该排列的带宽。求带宽最小的排列.</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>本题是带优化的穷举法—-回溯法的应用</li>
<li>所谓回溯法，就是在遍历的过程中构建树和删除树(剪枝)，如果可以确定该子树中不含有问题的解，则放弃对该子树的搜索，返回到上层的父节点，继续下一步深度优先搜索。</li>
<li>类比到本题中，有两种情况可以剪枝：<ol>
<li>对于节点u来说，假设u有m个相邻的节点，那么最理想的情况就是这m个节点紧跟在u后面，这样的节点带宽为m，而其他任何非理想情况的带宽至少为m+1。所以，如果即使都是最好情况仍然大于目前的最优解，那么应该直接剪枝</li>
<li>如果当前节点的带宽已经大于最小带宽，那么说明这个位置不能放这个位置不能放i，即放回到上层，再又上层执行vis[i] = 0来回溯</li>
</ol>
</li>
<li>由于A即使在没有成功运行到底的情况下，也会被改变，所以要将每次的结果更新到另一个数组里，采用memcpy函数</li>
<li><strong>本题由于n=8，可通过直接枚举排列并计算的方法实现</strong>，尝试后发现速度更快<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">输入A:FB;B:GC;D:GC;F:AGH;E:HD </span><br><span class="line">    #	</span><br><span class="line">*&#x2F;</span><br><span class="line">using namespace std;</span><br><span class="line">   map&lt;int, set&lt;int&gt;&gt; xl;</span><br><span class="line">   int n;</span><br><span class="line">   int A[10],ans[10];</span><br><span class="line">   int vis[26];</span><br><span class="line">   int minb &#x3D; 100000000;</span><br><span class="line">int main() &#123;</span><br><span class="line">   	string line;</span><br><span class="line">   	while (getline(cin, line) &amp;&amp; line !&#x3D; &quot;# &quot;) &#123;</span><br><span class="line">   		xl.clear();</span><br><span class="line">   		memset(A, -1, sizeof(A));</span><br><span class="line">   		bool flag &#x3D; true;</span><br><span class="line">   		char u;</span><br><span class="line">   		for (int i &#x3D; 0; i &lt; line.length(); i++) &#123;</span><br><span class="line">   			if (isalpha(line[i])) &#123;</span><br><span class="line">   				if (flag) &#123;</span><br><span class="line">   					u &#x3D; line[i] - &#39;A&#39;;</span><br><span class="line">   					flag &#x3D; false;</span><br><span class="line">   					xl[line[i] - &#39;A&#39;];</span><br><span class="line">   				&#125;</span><br><span class="line">   				else &#123;</span><br><span class="line">   					xl[u].insert(line[i] - &#39;A&#39;);</span><br><span class="line">   					xl[line[i] - &#39;A&#39;].insert(u);</span><br><span class="line">   				&#125;</span><br><span class="line">   			&#125;</span><br><span class="line">   			else if (line[i] &#x3D;&#x3D; &#39;;&#39;) flag &#x3D; true;</span><br><span class="line">   		&#125;</span><br><span class="line">   		n &#x3D; xl.size();</span><br><span class="line">   		memset(vis, 0, sizeof(vis));</span><br><span class="line">   		memset(ans, 0, sizeof(ans));</span><br><span class="line">   		minb &#x3D; 100000000;</span><br><span class="line">   		dfs(0, 0);</span><br><span class="line">   		for (int i &#x3D; 0; i &lt; n; i++) cout &lt;&lt; char(&#39;A&#39; + ans[i]) &lt;&lt; &quot; &quot;;</span><br><span class="line">   		cout &lt;&lt; &quot;-&gt; &quot;&lt;&lt;minb &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> void dfs(int cur, int B) &#123;</span><br><span class="line"> 	if (cur &#x3D;&#x3D; n)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		&#x2F;&#x2F;能到这，说明已经是最优解了，所以要更新ans和最小带宽</span><br><span class="line">memcpy(ans, A, sizeof(int)*n);</span><br><span class="line"> 		minb &#x3D; B;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	else for (auto it &#x3D; xl.begin(); it !&#x3D; xl.end();it++) &#123;</span><br><span class="line"></span><br><span class="line"> 		int i &#x3D; it-&gt;first;</span><br><span class="line"> 		if (!vis[i]) &#123;&#x2F;&#x2F;vis[i]用来保证是个排列</span><br><span class="line"> 			int m &#x3D; 0;</span><br><span class="line"> 			for (int j &#x3D; 0; j &lt; cur; j++)</span><br><span class="line"> 				if (!vis[A[j]] &amp;&amp; xl[i].count(A[j])) </span><br><span class="line"> 					m++;</span><br><span class="line"> 			if (m &gt;&#x3D; minb) return;&#x2F;&#x2F;对应剪枝一</span><br><span class="line"> </span><br><span class="line"> 			int ok &#x3D; 1;</span><br><span class="line"> 			A[cur] &#x3D; i;</span><br><span class="line"> 			for (int j &#x3D; 0; j &lt; cur; j++) &#123;</span><br><span class="line"> 				</span><br><span class="line"> 				if (xl[i].count(A[j])) &#123;</span><br><span class="line"> 					int w &#x3D; cur - j;</span><br><span class="line"> 					if (w &gt; B) B &#x3D; w;</span><br><span class="line"> 					if (B &gt;&#x3D; minb) return;   			</span><br><span class="line"> 				&#125;    					</span><br><span class="line"> 			&#125;</span><br><span class="line"> </span><br><span class="line"> 			if (ok) &#123;</span><br><span class="line"> 				vis[i] &#x3D; 1;</span><br><span class="line"> 				dfs(cur + 1, B);</span><br><span class="line"> 				vis[i] &#x3D; 0;&#x2F;&#x2F;回溯：要么是到头了，回溯来找其他解；要么是中间返回，回溯以求正确解</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="直接生成排列法全部代码"><a href="#直接生成排列法全部代码" class="headerlink" title="直接生成排列法全部代码"></a>直接生成排列法全部代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 10;</span><br><span class="line">int id[256], letter[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  char input[1000];</span><br><span class="line">  while(scanf(&quot;%s&quot;, input) &#x3D;&#x3D; 1 &amp;&amp; input[0] !&#x3D; &#39;#&#39;) &#123;</span><br><span class="line">    &#x2F;&#x2F; 给每个字母一个编号 </span><br><span class="line">    int n &#x3D; 0;</span><br><span class="line">    for(char ch &#x3D; &#39;A&#39;; ch &lt;&#x3D; &#39;Z&#39;; ch++)</span><br><span class="line">      if(strchr(input, ch) !&#x3D; NULL) &#123;</span><br><span class="line">        id[ch] &#x3D; n++;</span><br><span class="line">        letter[id[ch]] &#x3D; ch;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 澶勭悊杈撳叆</span><br><span class="line">    int len &#x3D; strlen(input), p &#x3D; 0, q &#x3D; 0;</span><br><span class="line">    vector&lt;int&gt; u, v;&#x2F;&#x2F;u为起点列表，q为与任意节点相连的节点列表 ，一个(u(i),v(i))对 对应一条边 </span><br><span class="line">    for(;;) &#123;</span><br><span class="line">      while(p &lt; len &amp;&amp; input[p] !&#x3D; &#39;:&#39;) p++;</span><br><span class="line">      if(p &#x3D;&#x3D; len) break;</span><br><span class="line">      while(q &lt; len &amp;&amp; input[q] !&#x3D; &#39;;&#39;) q++;</span><br><span class="line">      for(int i &#x3D; p+1; i &lt; q; i++) &#123;</span><br><span class="line">        u.push_back(id[input[p-1]]);</span><br><span class="line">        v.push_back(id[input[i]]);</span><br><span class="line">      &#125;</span><br><span class="line">      p++; q++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int P[maxn], bestP[maxn], pos[maxn], ans &#x3D; n;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) P[i] &#x3D; i;</span><br><span class="line">    do &#123;</span><br><span class="line">      for(int i &#x3D; 0; i &lt; n; i++) pos[P[i]] &#x3D; i; &#x2F;&#x2F; 生成一种排列 </span><br><span class="line">      int bandwidth &#x3D; 0;</span><br><span class="line">      for(int i &#x3D; 0; i &lt; u.size(); i++)</span><br><span class="line">        bandwidth &#x3D; max(bandwidth, abs(pos[u[i]] - pos[v[i]])); &#x2F;&#x2F; 计算带宽 </span><br><span class="line">      if(bandwidth &lt; ans) &#123;</span><br><span class="line">        ans &#x3D; bandwidth;</span><br><span class="line">        memcpy(bestP, P, sizeof(P));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; while(next_permutation(P, P+n));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 输出结果 </span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) printf(&quot;%c &quot;, letter[bestP[i]]);</span><br><span class="line">    printf(&quot;-&gt; %d\n&quot;, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F/" class="post-title-link" itemprop="url">并行程序模拟</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-20 11:48:55" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-01 00:18:50" itemprop="dateModified" datetime="2020-02-01T00:18:50+08:00">2020-02-01</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uva-210-并行程序模拟"><a href="#uva-210-并行程序模拟" class="headerlink" title="uva 210 并行程序模拟"></a>uva 210 并行程序模拟</h1><p>你的任务是模拟n个程序（按输入顺序编号1~n）的并行执行。每个程序包含不超过25条语句。</p>
<p>格式一共是5种：赋值（var=constant），打印（print var），lock，unlock，end，耗时分别为t1,t2,t3,t4,t5.</p>
<p>变量用一个小写字母表示，初始时为0，为所有并行程序共有，且它的值始终保持在[0,100]内，所以一个程序对某一个变量的赋值会影响到另外一个程序。</p>
<p>每个时刻只能是一个程序处于运行状态，其他程序处于等待状态。运行状态之中的的程序每次最多分配Q个单位时间，一旦在未执行完程序时超过分配时间，这个程序则会被插入等待队列，然后从其的队首取出一共程序继续执行。而初始的等待队列为按照输入程序排入。</p>
<p>但是由于lock和unlock命令的出现，这个顺序会被改变。</p>
<p>lock的作用是申请对所有变量的独占访问，unlock则是解除对所有变量的独占访问，且它们一定成对出现。当一个程序已经对所有的变量独占访问后，其他程序若试图执行lock，无论其是否耗尽分配时间，都会被放在一个阻止队列的尾部，且当那个程序解除的时候，则会从阻止队列的头部的程序进入等待队列的头部。</p>
<p>现在给出n,t1,t2,t3,t4,t5,Qn,t_1,t_2,t_3,t_4,t_5,Qn,t1​,t2​,t3​,t4​,t5​,Q以及nnn个程序，你需要输出所有printprintprint命令执行输出的值。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>对于每个程序，将它所对应的代码存到一个队列中，所有的程序构成一个队列数组。</li>
<li>运行时定义三个队列，分别为等待，阻塞和运行，里面存程序的编号。</li>
<li>在等待队列不空的情况下持续循环。每次取等待队列首部的程序作为当前运行的程序队列，即running队列。</li>
<li>运行过程中，不断从running的队首取元素，分析代码，调用analysis函数运行指令，并返回相应时间。注意加锁和解锁的过程要特殊处理。</li>
<li>每次t-=返回的耗时，running队列弹出一条语句。</li>
<li>如果分配的时间片内没有完成，则将对应程序的编号插入等待队列的队尾，并且更新对应程序剩余代码。</li>
<li>锁机制使用全局变量lockKey实现，为false时可以进行加锁，否则将后来的想加锁的程序放入等待进程。注意此时不要弹出lock指令。<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="analysis-分析语句"><a href="#analysis-分析语句" class="headerlink" title="analysis 分析语句"></a>analysis 分析语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int analysis(string s) &#123;</span><br><span class="line">   	if (s.find(&#39;&#x3D;&#39;) !&#x3D; -1) &#123;</span><br><span class="line">   		int m &#x3D; s.find(&#39;&#x3D;&#39;);</span><br><span class="line">   		string l &#x3D; s.substr(0, m - 1);</span><br><span class="line">   		string r &#x3D; s.substr(m + 2);</span><br><span class="line">   		value[l] &#x3D; r;</span><br><span class="line">   		return tim[0];</span><br><span class="line">   	&#125;</span><br><span class="line">   	else if (s.substr(0, 5) &#x3D;&#x3D; &quot;print&quot;) &#123;</span><br><span class="line">   		string a &#x3D; s.substr(6);</span><br><span class="line">   		cout &lt;&lt; waiting.front() + 1 &lt;&lt; &quot;: &quot;;</span><br><span class="line">   		if(value.count(a)) cout&lt;&lt; value[a] &lt;&lt; endl;</span><br><span class="line">   		else cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;</span><br><span class="line">   		return tim[1];</span><br><span class="line">   	&#125;</span><br><span class="line">   	else if (s &#x3D;&#x3D; &quot;lock&quot;) &#123;</span><br><span class="line">   		if (!lockKey) &#123;</span><br><span class="line">   			lockKey &#x3D; true;</span><br><span class="line">   			return tim[2];</span><br><span class="line">   		&#125;</span><br><span class="line">   		else return -1;</span><br><span class="line">   </span><br><span class="line">   	&#125;</span><br><span class="line">   	else if (s &#x3D;&#x3D; &quot;unlock&quot;) &#123;</span><br><span class="line">   		lockKey &#x3D; false;</span><br><span class="line">   		return -2;</span><br><span class="line">   	&#125;</span><br><span class="line">   	else if (s &#x3D;&#x3D; &quot;end&quot;) &#123;</span><br><span class="line">   		return tim[4];</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="main-运行程序的过程"><a href="#main-运行程序的过程" class="headerlink" title="main 运行程序的过程"></a>main 运行程序的过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"># define maxn 500</span><br><span class="line">int tim[5];&#x2F;&#x2F;记录每个操作的时间</span><br><span class="line">map&lt;string, string&gt; value;</span><br><span class="line">deque&lt;int&gt; waiting;&#x2F;&#x2F;等待队列，存队列的ID（数组中的下标）</span><br><span class="line">int quota;&#x2F;&#x2F;配额</span><br><span class="line"></span><br><span class="line">bool lockKey &#x3D; false;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	bool first &#x3D; true;</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		if (first) first &#x3D; false;</span><br><span class="line">		else cout &lt;&lt; endl;</span><br><span class="line">		queue&lt;string&gt; pro[maxn];&#x2F;&#x2F;所有程序的指令序列</span><br><span class="line">	</span><br><span class="line">		queue&lt;int&gt; block;&#x2F;&#x2F;阻塞队列</span><br><span class="line">		value.clear();</span><br><span class="line">		waiting.clear();</span><br><span class="line">		int n;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 5; i++) cin &gt;&gt; tim[i];</span><br><span class="line"></span><br><span class="line">		cin &gt;&gt; quota; getchar();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			string s;</span><br><span class="line">			while (getline(cin, s)) &#123;</span><br><span class="line">				pro[i].push(s);</span><br><span class="line">				if (s &#x3D;&#x3D; &quot;end&quot;) break;</span><br><span class="line">			&#125;</span><br><span class="line">			waiting.push_back(i);</span><br><span class="line">		&#125;</span><br><span class="line">		while (!waiting.empty()) &#123;</span><br><span class="line">			queue&lt;string&gt; running &#x3D; pro[waiting.front()];</span><br><span class="line">			int t &#x3D; quota;</span><br><span class="line">			bool flag &#x3D; true;</span><br><span class="line">			while (!running.empty() &amp;&amp; t&gt;0) &#123;</span><br><span class="line">				int w &#x3D; analysis(running.front());</span><br><span class="line">				if (w &#x3D;&#x3D; -1) &#123;&#x2F;&#x2F;说明不是第一次执行到lock</span><br><span class="line">					block.push(waiting.front());</span><br><span class="line">					flag &#x3D; false;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				if (w &#x3D;&#x3D; -2) &#123;</span><br><span class="line">					if (!block.empty()) &#123;</span><br><span class="line">						int now &#x3D; waiting.front();</span><br><span class="line">						waiting.pop_front();</span><br><span class="line">						waiting.push_front(block.front());</span><br><span class="line">						block.pop();</span><br><span class="line">						waiting.push_front(now);</span><br><span class="line">					&#125;</span><br><span class="line">					w &#x3D; tim[3];</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line"></span><br><span class="line">				t -&#x3D; w;</span><br><span class="line">				running.pop();</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			if (flag &amp;&amp; !running.empty()) &#123;</span><br><span class="line"></span><br><span class="line">				waiting.push_back(waiting.front());</span><br><span class="line">			&#125;</span><br><span class="line">			pro[waiting.front()] &#x3D; running;</span><br><span class="line"></span><br><span class="line">			waiting.pop_front();</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="简化版代码-思路一致"><a href="#简化版代码-思路一致" class="headerlink" title="简化版代码 思路一致"></a>简化版代码 思路一致</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">deque&lt;int&gt; readyQ;</span><br><span class="line">queue&lt;int&gt; blockQ;</span><br><span class="line">int n, quantum, c[5], var[26], ip[maxn]; </span><br><span class="line">bool locked;</span><br><span class="line">char prog[maxn][10];</span><br><span class="line"></span><br><span class="line">void run(int pid) &#123;</span><br><span class="line">  int q &#x3D; quantum;</span><br><span class="line">  while(q &gt; 0) &#123;</span><br><span class="line">    char *p &#x3D; prog[ip[pid]];</span><br><span class="line">    switch(p[2]) &#123;</span><br><span class="line">      case &#39;&#x3D;&#39;:</span><br><span class="line">        var[p[0] - &#39;a&#39;] &#x3D; isdigit(p[5]) ? (p[4] - &#39;0&#39;) * 10 + p[5] - &#39;0&#39; : p[4] - &#39;0&#39;;</span><br><span class="line">        &#x2F;&#x2F;因为至多是两位数 </span><br><span class="line">        q -&#x3D; c[0];</span><br><span class="line">        break;</span><br><span class="line">      case &#39;i&#39;: &#x2F;&#x2F; print</span><br><span class="line">        printf(&quot;%d: %d\n&quot;, pid+1, var[p[6] - &#39;a&#39;]);</span><br><span class="line">        q -&#x3D; c[1];</span><br><span class="line">        break;</span><br><span class="line">      case &#39;c&#39;: &#x2F;&#x2F; lock</span><br><span class="line">        if(locked) &#123; blockQ.push(pid); return; &#125;</span><br><span class="line">        locked &#x3D; true;</span><br><span class="line">        q -&#x3D; c[2];</span><br><span class="line">        break;</span><br><span class="line">      case &#39;l&#39;: &#x2F;&#x2F; unlock</span><br><span class="line">        locked &#x3D; false;</span><br><span class="line">        if(!blockQ.empty()) &#123;</span><br><span class="line">          int pid2 &#x3D; blockQ.front(); blockQ.pop();</span><br><span class="line">          readyQ.push_front(pid2);</span><br><span class="line">        &#125;</span><br><span class="line">        q -&#x3D; c[3];</span><br><span class="line">        break;</span><br><span class="line">      case &#39;d&#39;: &#x2F;&#x2F; end</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ip[pid]++;</span><br><span class="line">  &#125;</span><br><span class="line">  readyQ.push_back(pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int T;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">  while(T--) &#123;</span><br><span class="line">    scanf(&quot;%d %d %d %d %d %d %d\n&quot;, &amp;n, &amp;c[0], &amp;c[1], &amp;c[2], &amp;c[3], &amp;c[4], &amp;quantum);</span><br><span class="line">    memset(var, 0, sizeof(var));</span><br><span class="line"></span><br><span class="line">    int line &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">      fgets(prog[line++], maxn, stdin);</span><br><span class="line">      ip[i] &#x3D; line - 1;</span><br><span class="line">      while(prog[line - 1][2] !&#x3D; &#39;d&#39;)</span><br><span class="line">        fgets(prog[line++], maxn, stdin);</span><br><span class="line">      readyQ.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    locked &#x3D; false;</span><br><span class="line">    while(!readyQ.empty()) &#123;</span><br><span class="line">      int pid &#x3D; readyQ.front(); readyQ.pop_front();</span><br><span class="line">      run(pid);</span><br><span class="line">    &#125;</span><br><span class="line">    if(T) printf(&quot;\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E6%89%93%E5%8D%B0%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E6%89%93%E5%8D%B0%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">打印队列</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-20 11:48:55" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-22 13:20:57" itemprop="dateModified" datetime="2020-01-22T13:20:57+08:00">2020-01-22</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uva12100-打印队列"><a href="#uva12100-打印队列" class="headerlink" title="uva12100 打印队列"></a>uva12100 打印队列</h1><p>&ensp;学生会里只有一台打印机，但是有很多文件需要打印，因此打印任务不可避免地需要等待。有些打印任务比较急，有些不那么急，所以每个任务都有一个1～9间的优先级，优先级越高表示任务越急。</p>
<p>&ensp;打印机的运作方式如下：首先从打印队列里取出一个任务J，如果队列里有比J更急的任务，则直接把J放到打印队列尾部，否则打印任务J（此时不会把它放回打印队列）。 输入打印队列中各个任务的优先级以及所关注的任务在队列中的位置（队首位置为0），输出该任务完成的时刻。所有任务都需要1分钟打印。例如，打印队列为{1,1,9,1,1,1}，目前处于队首的任务最终完成时刻为5。</p>
<p>&ensp;输入T 接下来T组数据 每组数据输入N，TOP。接下来N个数，TOP代表队列首</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>通过两个队列实现，一个是优先级队列，其队首即为当前允许出队的优先级；另一个是打印队列</li>
<li>只有当优先级队列的队首等于打印队列的队首的时候（当前要打印的任务优先级最高）时，才能打印；否则将打印队列的队首插到队尾</li>
<li>由于最终要根据在初始队列中的位置选择输出，所以既要记录优先级又要记录初始位置。</li>
<li>优先级队列与元素无关，所以用int型即可<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   &#x2F;&#x2F;list存打印请求队列，如果优先级队列pq的队首比list大，说明队列中还有优先级更高的任务，则将list的队首放在队尾</span><br><span class="line">   &#x2F;&#x2F;只有当pq的队首等于list的队首的时候，list才输出，pq才出队!!!</span><br><span class="line">   #include&lt;iostream&gt;</span><br><span class="line">   #include&lt;vector&gt;</span><br><span class="line">   #include&lt;queue&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;习题5-7in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;习题5-7out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   int n;</span><br><span class="line">   struct node &#123;</span><br><span class="line">   	int f;</span><br><span class="line">   	int pos;</span><br><span class="line">   	node(int f, int pos) :f(f), pos(pos) &#123;&#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   int main() &#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">while (n--)</span><br><span class="line">&#123;</span><br><span class="line">	queue&lt;node&gt; list;</span><br><span class="line">	priority_queue&lt;int&gt; pq;</span><br><span class="line">	int m, pos;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; pos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">		int x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		pq.push(x);</span><br><span class="line">		list.push(node(x,i));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	int time &#x3D; 0;</span><br><span class="line">	while(!list.empty()&amp;&amp;!pq.empty())&#123;</span><br><span class="line">		if (list.front().f &lt; pq.top()) &#123;</span><br><span class="line">			list.push(list.front());</span><br><span class="line">			list.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		else if (list.front().f &#x3D;&#x3D; pq.top()) &#123;</span><br><span class="line">			if (list.front().pos &#x3D;&#x3D; pos) break;</span><br><span class="line">			</span><br><span class="line">				list.pop();</span><br><span class="line">				pq.pop();&#x2F;&#x2F;！！只有成功打印了，优先级队列才队</span><br><span class="line">				time++;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; time+1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1></li>
<li>首先是学习了优先级队列，优先级队列是每次都挑出优先级最大的，而不是重排队列。</li>
<li>以后应该明确每个STL应该关注的点，像是这里的优先级队列，只需关注级数数值即可，无需定义为node型</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/UnixIS%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/UnixIS%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">UnixIS命令</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:49:12" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="unix-is-命令"><a href="#unix-is-命令" class="headerlink" title="unix is 命令"></a>unix is 命令</h1><p>输入正整数n 以及n个文件名，排序后按列优先的方式左对齐输出。假设最长文件名有M字符，则最右边有M字符，其他列都是M+2 字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  #include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">  # pragma warning(disable:4996)</span><br><span class="line">  # define LOCAL</span><br><span class="line">  # ifdef LOCAL</span><br><span class="line">  FILE *fin &#x3D; freopen(&quot;unix命令in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">  FILE *fout &#x3D; freopen(&quot;unix命令out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">  # endif &#x2F;&#x2F; LOCAL</span><br><span class="line">  using namespace std;</span><br><span class="line">  void print(const string &amp;in, int len, char extra) &#123;</span><br><span class="line">&#x2F;&#x2F;输出字符串s，长度不足len时补字符extra</span><br><span class="line">  	cout &lt;&lt; in;</span><br><span class="line">  	for (int i &#x3D; 0; i &lt; len - in.length(); i++) cout &lt;&lt; extra;</span><br><span class="line">  &#125;</span><br><span class="line">  int main() &#123;</span><br><span class="line">  	int n;</span><br><span class="line">  </span><br><span class="line">  	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">  		int m &#x3D; 0;</span><br><span class="line">  		print(&quot;&quot;, 60, &#39;-&#39;);</span><br><span class="line">  		cout &lt;&lt; endl;</span><br><span class="line">  		vector&lt;string&gt; s;</span><br><span class="line">  		for (int i &#x3D; 0; i &lt; n;i++) &#123;</span><br><span class="line">  			string in;</span><br><span class="line">  			cin &gt;&gt; in;</span><br><span class="line">  			s.push_back(in);</span><br><span class="line">  			m &#x3D; max(m, (int)in.length());</span><br><span class="line">  		&#125;</span><br><span class="line">  		sort(s.begin(), s.end());</span><br><span class="line">  </span><br><span class="line">  		&#x2F;*cout &lt;&lt; &quot;**********************************&quot; &lt;&lt; endl;</span><br><span class="line">  		for (int i &#x3D; 0; i &lt; s.size(); i++) cout &lt;&lt; s[i] &lt;&lt; endl;</span><br><span class="line">  		cout &lt;&lt; &quot;**********************************&quot; &lt;&lt; endl;*&#x2F;</span><br><span class="line">  		int cols &#x3D; (60 - m) &#x2F; (m + 2) + 1;</span><br><span class="line">  		int rows &#x3D; (n - 1) &#x2F; cols + 1;</span><br><span class="line">  		for (int r &#x3D; 0; r &lt; rows; r++) &#123;</span><br><span class="line">  			for (int c &#x3D; 0; c &lt; cols; c++) &#123;</span><br><span class="line">  				int idx &#x3D; c * rows + r;</span><br><span class="line">  				if (idx &lt; n) print(s[idx], c &#x3D;&#x3D; cols - 1 ? m : m + 2, &#39; &#39;);</span><br><span class="line">  			&#125;</span><br><span class="line">  			cout &lt;&lt; endl;</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">八皇后问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-20 11:48:55" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-22 13:18:57" itemprop="dateModified" datetime="2020-01-22T13:18:57+08:00">2020-01-22</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>/*<br>恰好每行每列各放置一个皇后，如果用A[x]表示第x行皇后的列号，则问题变成了一个全排列生成问题。<br>*/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   #include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;八皇后in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;八皇后out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   int print_num &#x3D; 1;</span><br><span class="line">   int tot &#x3D; 0;</span><br><span class="line">   int n;</span><br><span class="line">   int A[100];</span><br><span class="line">   int vis[100][100];</span><br><span class="line">   void search(int cur) &#123;</span><br><span class="line">ios::sync_with_stdio(false);</span><br><span class="line">if (cur &#x3D;&#x3D; n) &#123;</span><br><span class="line">	if (print_num &lt;&#x3D; 3) &#123;</span><br><span class="line">		cout &lt;&lt; A[0];</span><br><span class="line">		for (unsigned int i &#x3D; 1; i &lt; n; i++)</span><br><span class="line">			cout &lt;&lt; &quot; &quot;&lt;&lt; A[i] ;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		print_num++;</span><br><span class="line">	&#125;</span><br><span class="line">	tot++;</span><br><span class="line">&#125;</span><br><span class="line">else for (unsigned int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">	if (!vis[0][i] &amp;&amp; !vis[1][cur + i] &amp;&amp; !vis[2][cur - i + n]) &#123;</span><br><span class="line">		&#x2F;&#x2F;对于(i,cur)</span><br><span class="line">		&#x2F;&#x2F;以cur+i来标识副对角线，cur-i来标识主对角线，由于主对角线可能为负</span><br><span class="line">		&#x2F;&#x2F;所以要加上n</span><br><span class="line">		A[cur] &#x3D; i + 1;</span><br><span class="line">		&#x2F;&#x2F;对于(cur,i)处要么有子要么无子--&gt;回溯的两种情况</span><br><span class="line">		vis[0][i] &#x3D; vis[1][cur + i] &#x3D; vis[2][cur - i + n] &#x3D; 1;</span><br><span class="line">		search(cur + 1);</span><br><span class="line">		vis[0][i] &#x3D; vis[1][cur + i] &#x3D; vis[2][cur - i + n] &#x3D; 0;&#x2F;&#x2F;非常关键，回溯法中修改的辅助</span><br><span class="line">															 &#x2F;&#x2F;局部变量，一定要及时恢复原状</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   int main() &#123;</span><br><span class="line">   	ios::sync_with_stdio(false);</span><br><span class="line">   	cin &gt;&gt; n;</span><br><span class="line">   	search(0);</span><br><span class="line">   	cout &lt;&lt; tot &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E5%85%AB%E6%95%B0%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E5%85%AB%E6%95%B0%E7%A0%81/" class="post-title-link" itemprop="url">八数码</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-20 11:48:55" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-18 14:46:24" itemprop="dateModified" datetime="2020-02-18T14:46:24+08:00">2020-02-18</time>
              </span>

          
          <div>
            
          </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="八数码-P1379"><a href="#八数码-P1379" class="headerlink" title="八数码 P1379"></a>八数码 P1379</h1><p>有一个3*3的网格，给定一个初始局面，问至少多少步能到达目标局面.</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>经典的隐式图最短路径问题。</li>
<li>sizeof(字符串)会计算结束符。对于二维的字符数组，对某一行用sizeof不会计算结束符，可能产生问题。</li>
<li>一般的bfs采用队列，但是本题中由于状态是八个元素的信息，所以采用了类似链表的方法近似队列。在编辑书稿中也使用了类似的方式，只不过那个题是dfs，迭代加深搜实现的。</li>
<li>本题可以使用bfs是因为每一步的状态不是无限的。</li>
<li>注意rear++和front++的位置</li>
<li>dist数组是必要的</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">const int maxn &#x3D; 1000000;</span><br><span class="line">bool bfs();</span><br><span class="line">bool can_insert(int s);</span><br><span class="line">char st[maxn][9];</span><br><span class="line">int dx[] &#x3D; &#123; 1,-1,0,0 &#125;;</span><br><span class="line">int dy[] &#x3D; &#123; 0,0,1,-1 &#125;;   </span><br><span class="line">int dist[maxn];</span><br><span class="line">char goal[] &#x3D; &#123;&quot;123804765&quot;&#125;;</span><br><span class="line">int front, rear;</span><br><span class="line">std::set&lt;int&gt; vis;</span><br><span class="line">int main() &#123;</span><br><span class="line">	scanf(&quot;%s&quot;, st[1]);</span><br><span class="line">	if (bfs()) printf(&quot;%d&quot;, dist[front]);</span><br><span class="line">	else printf(&quot;-1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">bool bfs() &#123;</span><br><span class="line">	front &#x3D; 1, rear &#x3D; 2;</span><br><span class="line">	while (front &lt; rear) &#123;</span><br><span class="line">		if (memcmp(goal,st[front], sizeof(st[front])) &#x3D;&#x3D; 0) return true;</span><br><span class="line">		int z &#x3D; 0;</span><br><span class="line">		while (st[front][z] !&#x3D; &#39;0&#39;) z++;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">			int newx &#x3D; z &#x2F; 3 + dx[i];</span><br><span class="line">			int newy &#x3D; z % 3 + dy[i];</span><br><span class="line">			if (newx &lt; 0 || newx &gt;&#x3D; 3 || newy &lt; 0 || newy &gt;&#x3D; 3) continue;</span><br><span class="line">			int newz &#x3D; newx * 3 + newy;</span><br><span class="line">			memcpy(st[rear], st[front], sizeof(char)*9);</span><br><span class="line">			st[rear][newz] &#x3D; st[front][z];</span><br><span class="line">			st[rear][z] &#x3D; st[front][newz];</span><br><span class="line">			dist[rear] &#x3D; dist[front] + 1;</span><br><span class="line">			if(can_insert(rear)) rear++;</span><br><span class="line">		&#125;</span><br><span class="line">		front++;</span><br><span class="line">	&#125;</span><br><span class="line">		return false;</span><br><span class="line">&#125;</span><br><span class="line">bool can_insert(int s) &#123;</span><br><span class="line">	int v &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 9; i++) v &#x3D; v * 10 + st[s][i] - &#39;0&#39;;</span><br><span class="line">	if (!vis.count(v)) &#123;</span><br><span class="line">		vis.insert(v);</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cuienbo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">159</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cuienbo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.0
  </div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
  
</body>
</html>
