<!DOCTYPE html>


<html lang="en" >


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Hexo
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

  <script type="text/javascript"
	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-计安导第6章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC6%E7%AB%A0/"
    >计安导第6章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC6%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.494Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="DNS-域名系统"><a href="#DNS-域名系统" class="headerlink" title="DNS 域名系统"></a>DNS 域名系统</h1><ol>
<li><p>DNS是应用层协议，负责将域名映射到IP地址。</p>
</li>
<li><p>DNS数据库包括</p>
<ol>
<li>地址记录：与主机名相关链的IP地址。</li>
<li>邮件交换记录：域的邮件服务器。</li>
<li>名称服务器记录：域的权威服务器。<h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2></li>
</ol>
</li>
<li><p>DNS：建立IP和域名间的映射</p>
</li>
<li><p>HTTP:用来浏览网页</p>
</li>
<li><p>SSL/TLS: 以安全的、加密的方式浏览网页的协议(<strong>HTTPS</strong>)</p>
</li>
<li><p>IMAP/POP/SMAP:用于互联网电子邮件</p>
</li>
<li><p>SOAP：用于交换作为网络服务模式部分的结构化数据</p>
</li>
<li><p>talent：远程访问协议(与FTP一样，不提供加密)</p>
</li>
<li><p>SSH:较新的安全远程访问和管理协议</p>
<h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2></li>
<li><p>域名：最右为顶级域名(TLD)</p>
</li>
<li><p>域名服务器从上至下依次为</p>
<ol>
<li>根域名服务器：管理顶级域名.</li>
<li>顶级域名服务器:如.com。其中保存的每条记录都对应一个权威域名服务器</li>
<li>权威域名服务器<h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2></li>
</ol>
</li>
<li><p>区域：具有相同权威DNS服务器的已连接节点的集合。</p>
</li>
<li><p>域名解析：</p>
<ol>
<li><p>迭代解析</p>
<img src="/计安导_img/2.png"  />
</li>
<li><p>递归解析</p>
<img src="/计安导_img/3.png"  />    

</li>
</ol>
</li>
</ol>
<h2 id="权威域名服务器"><a href="#权威域名服务器" class="headerlink" title="权威域名服务器"></a>权威域名服务器</h2><ol>
<li>权威域名服务器层次结构：权威域名服务器也是分层的，每个域名服务器都存储着记录的集合，每个记录提供域名地址或者对该域权威域名服务器的引用。</li>
<li>作用：控制在权威域名服务器(ANS)之间分配<ol>
<li>负责特定域</li>
<li>可以为子域指定其他ANS</li>
</ol>
</li>
</ol>
<h2 id="DNS数据包"><a href="#DNS数据包" class="headerlink" title="DNS数据包"></a>DNS数据包</h2><ol>
<li>DNS查询和应答是通过UDP实现的，但当请求超过512时，会采用TCP。</li>
<li>DNS查询通常通过端口53上的UDP发出。<h3 id="组成："><a href="#组成：" class="headerlink" title="组成："></a>组成：</h3></li>
<li>头：包含16为查询标识符，用于标识查询和响应</li>
<li>查询部分：由问题序列组成，每个问题由所查询域名和查询记录的类型组成。</li>
<li>应答部分包括<ol>
<li>NAME 包含一个全域名</li>
<li>2B的TYPE 标识DNS记录的类型</li>
<li>2B的CLASS域 标识更广泛的类型</li>
<li>4B的TTL 标识有效时间</li>
<li>2B的RDLENGTH 标识数据段的长度</li>
<li>可变长RDATA段 包括实际的记录数据</li>
</ol>
</li>
</ol>
<h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><ol>
<li>目的：如果每个查询都遍历DNS树会导致根区域过载</li>
<li>缓存有效期：由ANS回复的TTL指定。</li>
<li>由操作系统和浏览器维护缓存<h2 id="DNS-攻击：-网络嫁接与网络钓鱼"><a href="#DNS-攻击：-网络嫁接与网络钓鱼" class="headerlink" title="DNS 攻击： 网络嫁接与网络钓鱼"></a>DNS 攻击： 网络嫁接与网络钓鱼</h2></li>
<li><strong>过程</strong> 攻击者把网站发送请求解析成子集恶意服务器的伪装IP地址，导致受害人浏览或下载伪造的内容。 </li>
<li><strong>用途</strong> 伪造王章</li>
</ol>
<h2 id="DNS-缓存中毒"><a href="#DNS-缓存中毒" class="headerlink" title="DNS 缓存中毒"></a>DNS 缓存中毒</h2><ol>
<li><p><strong>思想</strong> 攻击者欺骗DNS服务器缓存保存虚假的DNS记录。</p>
 <img src="/计安导_img/4.png"  />

 <img src="/计安导_img/5.png"  />

 <img src="/计安导_img/6.png"  />
</li>
<li><p><strong>检测</strong> DNS使用16位请求标识符将查询ID与响应ID配对。当服务器</p>
<ol>
<li><p>忽略标识符</p>
</li>
<li><p>具有可预测的ID</p>
</li>
<li><p>接受未经请求的DNS记录</p>
<p>说明可能中毒了</p>
</li>
</ol>
</li>
<li><p>防御DNS缓存中毒</p>
<ol>
<li>对查询使用随机标识符 </li>
<li>始终检查标识符 </li>
<li>DNS请求的端口随机化</li>
<li>部署DNSSEC（DNS协议的安全扩展集）</li>
</ol>
</li>
</ol>
<h2 id="DNS缓存中毒和生日悖论"><a href="#DNS缓存中毒和生日悖论" class="headerlink" title="DNS缓存中毒和生日悖论"></a>DNS缓存中毒和生日悖论</h2><blockquote>
<p>DNS 协议交换不验证对递归迭代查询的响应。验证查询只会检查 16 位事务 ID 以及响应数据包的源 IP 地址和目标端口。在 2008 年之前，所有 DNS 使用固定端口53 解析.因此，除了事务 ID 之外，欺骗 DNS 回复所需的所有信息都是可预测的。用这种弱点攻击 DNS 被称为“生日悖论”，平均需要 256 次来猜测事务 ID。为了使攻击成功，伪造的 DNS 回复必须在合法权威响应之前到达目标解析器。如果合法响应首先到达，它将由解析器缓存，并且直到其生存时间（TTL）到期，解析器将不会要求权威服务器解析相同的域名，从而防止攻击者中毒映射该域，直到 TTL 到期。</p>
</blockquote>
<h2 id="DNSSEC"><a href="#DNSSEC" class="headerlink" title="DNSSEC"></a>DNSSEC</h2><blockquote>
<p>DNSSEC 采用基于公共密钥加密的数字签名，从而增强 DNS 验证强度。DNSSEC 并非对 DNS 查询和响应本身进行加密签名，而是由数据所有者对 DNS 数据自身进行签名。</p>
</blockquote>
<blockquote>
<p>每一个 DNS 区均包含一个公私秘钥对。DNS 区所有者使用该区域的私钥对区域内的 DNS 数据进行签名，为这些数据生成数字签名。顾名思义，”私钥”是指 DNS 区所有者会对这些密钥材料保密。但是，该区域的公钥则在区域内公开发布，供全体用户检索。凡在区域内查找数据的递归解析器，还必需检索区域公钥，从而使用公钥验证 DNS 数据的真实性。解析器确认检索到的 DNS 数据的数字签名是否有效。如果有效，证明 DNS 数据合法，则将 DNS 数据返回给用户。如果签名未通过验证，解析器会假设发生攻击，丢弃数据并向用户返回错误。</p>
</blockquote>
<ol>
<li><p>目的：验证</p>
<ol>
<li>DNS回答来源的真实性</li>
<li>回复的完整性</li>
<li>拒绝存在的真实性</li>
</ol>
</li>
<li><p>通过在每一步中对DNS回复签名来实现这一点</p>
</li>
<li><p>使用公钥加密对所有DNS应答进行数字签名</p>
</li>
<li><p>通常使用信任锚，操作系统中的条目来引导进程</p>
</li>
<li><p>现状：加入安全机制后，数据包会远大于512B的UDP数据包。</p>
</li>
</ol>
<h1 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h1><ol>
<li><p>定义：防火墙是一种集成的安全措施集合，旨在防止对网络计算机 系统未经授权的访问。</p>
</li>
<li><p>防火墙策略：</p>
<ol>
<li>接收</li>
<li>拒绝</li>
<li>丢弃</li>
</ol>
</li>
<li><p>数据包匹配：基于数据包的一些特性。</p>
</li>
</ol>
<h2 id="黑名单与白名单"><a href="#黑名单与白名单" class="headerlink" title="黑名单与白名单"></a>黑名单与白名单</h2><h3 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h3><ol>
<li>默认规则为接收，只拒绝/丢弃黑名单定义的规则匹配到的数据包。</li>
</ol>
<h3 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h3><ol>
<li>默认规则拒绝，只接收白名单规则匹配到的数据包。</li>
</ol>
<h2 id="防火墙分类"><a href="#防火墙分类" class="headerlink" title="防火墙分类"></a>防火墙分类</h2><ol>
<li>数据包过滤器(无状态防火墙)：如果数据包与数据包过滤器的规则集匹配，则数据包过滤器将丢弃或者接受他。</li>
<li>状态过滤器(状态防火墙)：一种能够提供状态数据包检查或状态查看功能的防火墙，能够持续追踪穿过这个防火墙的各种网络连接（例如TCP与UDP连接）的状态。这种防火墙被设计来区分不同连接种类下的合法数据包。只有匹配主动连接的数据包才能够被允许穿过防火墙，其他的数据包都会被拒绝。</li>
<li>应用层防火墙：当内部计算机与外部主机连结时，将由代理服务器（Proxy Server）担任内部计算机与外部主机的连结中继者。使用ALG的好处是隐藏内部主机的地址和防止外部不正常的连接，如果代理服务器上未安装针对该应用程序设计的代理程序时，任何属于这个网络服务的封包将完全无法通过防火墙。</li>
</ol>
<h3 id="无状态防火墙"><a href="#无状态防火墙" class="headerlink" title="无状态防火墙"></a>无状态防火墙</h3><ol>
<li>将每个尝试通过它的数据包视为独立的，而不考虑前后数据包间的关系。</li>
<li>因此必须具有严格的限制性</li>
</ol>
<h3 id="状态防火墙"><a href="#状态防火墙" class="headerlink" title="状态防火墙"></a>状态防火墙</h3><ol>
<li>可以区分数据包是否是<strong>受信任网络</strong>内发起的<strong>合法会话</strong>的一部分。</li>
<li>状态防火墙维护一些表，表中包含每个活动<strong>连接的信息</strong>， 包括<strong>IP地址、端口和数据包的序列号</strong>。通过这些表，可以只允许响应内部网发起连接的TCP数据包流入。</li>
<li><strong>对于TCP</strong> 一旦完成初始的握手，且也允许数据包通过防火墙，则该连接的所有后续通信都允许通过防火墙，直到连接终止。</li>
<li><strong>对于UDP</strong> 由于UDP没有握手过程，所以一般情况下，当防火墙允许合法UDP通过</li>
</ol>
<h3 id="应用层防火墙"><a href="#应用层防火墙" class="headerlink" title="应用层防火墙"></a>应用层防火墙</h3><ol>
<li>基于进入或流出网络数据包的实际内容来管理流量，而不是仅仅分析源和目的。<h3 id="现状：基于深度数据包检测技术"><a href="#现状：基于深度数据包检测技术" class="headerlink" title="现状：基于深度数据包检测技术"></a>现状：基于深度数据包检测技术</h3></li>
</ol>
<h1 id="隧道—-gt-TCP"><a href="#隧道—-gt-TCP" class="headerlink" title="隧道—-&gt;TCP"></a>隧道—-&gt;TCP</h1><ol>
<li><strong>问题</strong> 由于TCP本身是不加密的，如果有人窃听TCP连接，就可以知道有效载荷中的全部内容。</li>
<li><strong>解决</strong> 使用隧道协议，无需改变软件的执行就能防止窃听，并且加密是自动的。</li>
<li><strong>缺点</strong> 需要在传输层或网络层协议中使用应用层概念，增加了协议栈的开销。<h2 id="安全的Shell-SSH-gt-Telnet-FTP-rlogin等早期远程管理协议"><a href="#安全的Shell-SSH-gt-Telnet-FTP-rlogin等早期远程管理协议" class="headerlink" title="安全的Shell (SSH) -&gt;Telnet,FTP,rlogin等早期远程管理协议"></a>安全的Shell (SSH) -&gt;Telnet,FTP,rlogin等早期远程管理协议</h2></li>
<li>使用对称和公钥密码技术加密通信。</li>
<li>常用于<strong>安全隧道</strong>，目的是使窃听者无法推断出SSH流量的内容，使用SSH建立的隧道能防止许多基于数据包嗅探的攻击。</li>
<li><strong>安全的交互式命令会话</strong>过程：<ol>
<li>客户端通过一个TCP会话连接到服务器</li>
<li>客户端与服务器交换管理细节的信息，如支持的加密方法、各 自协议的版本，每一方都要选择另一方支持的一组协议</li>
<li>客户端和服务器进行密钥交换，创建共享的秘密会话密钥，用 会话密钥加密双方的通信（但不用于身份验证）。这个会话密 钥配合选择的块加密（通常是AES、3DES、Blowfish或IDEA） 来加密所有后续的通信</li>
<li>服务器向客户端发送可以接受身份验证列表，客户端将按顺序尝 试。最常见的机制是使用密码或以下的公共密钥身份验证方法：<ol>
<li>如果选定的机制是<strong>公共密钥身份验证</strong>，则客户端向服务器发送<strong>自己的</strong>公钥；</li>
<li>然后服务器检查是否这密钥已存储在其授权的密钥列表之中。如果在， 服务器使用客户的<strong>公钥加密挑战</strong>，并将其发送给客户端；</li>
<li>客户用自己的私钥解密挑战，并向服务器发回响应，证明自己的身份；</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="IPSec–-gt-IP"><a href="#IPSec–-gt-IP" class="headerlink" title="IPSec–&gt;IP"></a>IPSec–&gt;IP</h2><p>IPSec协议族在网络层保证应用程序的安全，为数据包提供机密性和真实性。且协议族中每个协议都能运行在<strong>传输模式</strong>或<strong>隧道模式</strong>下</p>
<ol>
<li><strong>传输模式</strong>：在原数据包的数据之前，插入额外的IPSec的头信息，只对数据包的有效载荷继续加密或身份验证。</li>
<li><strong>隧道模式</strong>：构造一个新的数据包，将IPSec头信息和整个原数据包一起封装进新数据包的有效载荷中。</li>
</ol>
<h2 id="VPN-虚拟专用网"><a href="#VPN-虚拟专用网" class="headerlink" title="VPN 虚拟专用网"></a>VPN 虚拟专用网</h2><p>分为 <strong>远程访问VPN</strong>和<strong>站点到站点的VPN</strong></p>
<h3 id="远程访问VPN"><a href="#远程访问VPN" class="headerlink" title="远程访问VPN"></a>远程访问VPN</h3><p>允许授权的用户通过安装在自己电脑上的客户端通过NAS访问私有网络，即内网。</p>
<ol>
<li><strong>网路接入服务器(NAS)</strong>：VPN服务端</li>
</ol>
<h3 id="站点到站点的VPN"><a href="#站点到站点的VPN" class="headerlink" title="站点到站点的VPN"></a>站点到站点的VPN</h3><p>旨在为<strong>两个或更多</strong>远程网络提供安全的桥梁。两个网络各有一个独立的VPN端点，两端点之间相互通信。</p>
<h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><ol>
<li><p>使用点对点的隧道协议 PPTP</p>
<p> 首先使用PPP建立连接，然后封装PPP帧，然后用MPPE对其加密，最后通过互联网发送数据包。</p>
</li>
</ol>
<h2 id="隧道存在的安全风险"><a href="#隧道存在的安全风险" class="headerlink" title="隧道存在的安全风险"></a>隧道存在的安全风险</h2><ol>
<li>会规避防火墙的策略。当使用隧道技术时，会不同的传输协议对一系列网络数据包的有效载荷进行封装。同时，在隧道协议中也对有效载荷进行了加密，所以深度数据包检测也毫无用处。</li>
<li>如果内部用户通过隧道直接和外部服务器连接，并代表该用户向禁止访问的网站路由HTTP流量，同样通过隧道，将响应返回给该用户。相应的，攻击者也可以通过隧道规避防火墙。</li>
</ol>
<h1 id="入侵检测"><a href="#入侵检测" class="headerlink" title="入侵检测"></a>入侵检测</h1><h2 id="入侵检测系统-IDS"><a href="#入侵检测系统-IDS" class="headerlink" title="入侵检测系统 IDS"></a>入侵检测系统 IDS</h2><p>IDS 是一个软件或硬件系统，用于检测网络或个人计算机上恶意活动的迹象。</p>
<ol>
<li><p>分类： 按功能分</p>
<ol>
<li><p>IDS传感器，用于收集网络组件或计算机的实时数据</p>
</li>
<li><p>IDS管理器，用于接收来自传感器的报告</p>
</li>
<li><p><strong>关系</strong>：IDS管理器编译来自IDS传感器的数据，以确定是否发生了入侵。以此确定基于一组站点策略，这些策略是定义可能入侵的规则和条件。如果 IDS管理员检测到入侵，则会发出警报。</p>
</li>
</ol>
</li>
<li><p>IDS所检测的威胁包括</p>
<ol>
<li>伪装者：冒用合法用户的身份或凭据来获得对计算机系统或网络的访问的攻击者</li>
<li>违反者：执行了未经授权的操作的合法的用户</li>
<li>秘密用户：通过删除审计文件或系统日志，试图组织或掩盖自己行为的用户</li>
</ol>
</li>
<li><p>IDS所检测的攻击包括</p>
<ol>
<li><strong>端口扫描</strong>：是指某些别有用心的人发送一组端口扫描消息，试图以此侵入某台计算机，并了解其提供的计算机网络服务类型。攻击者可以通过它了解到从哪里可探寻到攻击弱点。</li>
<li><strong>拒绝服务攻击</strong>：网络攻击淹没主机，并将合法访问拒之门外</li>
<li><strong>恶意软件攻击</strong>：复制恶意软件的攻击，特洛伊木马、计算机蠕虫和病毒等</li>
<li>ARP欺骗：试图重定向局域网中的IP流量</li>
<li><strong>DNS缓存中毒</strong>：网络嫁接攻击旨在改变主机的DNS缓存，以创建伪造的域名/IP 地址的关联</li>
</ol>
</li>
</ol>
<h2 id="入侵检测技术"><a href="#入侵检测技术" class="headerlink" title="入侵检测技术"></a>入侵检测技术</h2><ol>
<li><p>传统的网络入侵检测系统（NIDS）</p>
<p> – 位于网络边界，基于<strong>流量模式和内容</strong>检测恶意的行为；</p>
</li>
<li><p>基于入侵检测系统的协议（PIDS）</p>
<p> – <strong>专门检测特定协议中的恶意行为</strong>，通常部署在特定的网络主机中。如 Web服务器可以运行PIDS来分析流入的HTTP流量，丢弃恶意的或包含错误的请求</p>
</li>
<li><p>基于主机的IDS（HIDS）</p>
<p> – 驻留在单个系统之中，<strong>监控这台计算机上的活动</strong>。如系统调用，进程间 的通信和资源使用模式</p>
</li>
</ol>
<h2 id="IDS攻击"><a href="#IDS攻击" class="headerlink" title="IDS攻击"></a>IDS攻击</h2><p>通过对IDS本身发动Dos攻击，故意触发大量入侵警报。直到淹没IDS，使他无法记录每个事件，或让管理员很难确定哪些日志代表攻击。</p>
<h2 id="入侵检测错误"><a href="#入侵检测错误" class="headerlink" title="入侵检测错误"></a>入侵检测错误</h2><p>包括：</p>
<ol>
<li>误报：当事件是良性活动而不是入侵时就发出警报，导致时间和资源的浪费。</li>
<li>漏报：当事件是入侵的恶意事件，却未发出警报。</li>
</ol>
<h3 id="基率谬误"><a href="#基率谬误" class="headerlink" title="基率谬误"></a>基率谬误</h3><p>由于基率谬误的存在，可能使某些IDS的有效性被误解。所以，当评估某些条件事件的概率而不考虑该事件的“基本概率”时，会发生此类错误。例如：</p>
<ol>
<li><p>假设IDS准确度为99％，假阳性或假阴性的概率为1％。 </p>
</li>
<li><p>假设入侵检测系统生成1,000,100个日志条目。 1,000,100个条目中只有100个对应于实际的恶意事件。 </p>
</li>
<li><p>由于IDS的成功率，在100个恶意事件中，99个将被检测为恶意，这意 味着我们有1个假阴性。 </p>
</li>
<li><p>然而，在1,000,000个良性事件中，10,000个将被错误地识别为恶意事件。 </p>
</li>
<li><p>因此，将共有10,099个警报响起，其中10,000个是误报警。也就是说，大约99％的警报都是误报警。</p>
</li>
</ol>
<h2 id="IDS数据收集和审计记录"><a href="#IDS数据收集和审计记录" class="headerlink" title="IDS数据收集和审计记录"></a>IDS数据收集和审计记录</h2><ol>
<li><p>入侵检测的输入是确定网络或主机操作基本的记录流</p>
</li>
<li><p>记录流中操作的类型包括：</p>
<ol>
<li>基于网的IDS，包括每次HTTP会话尝试、每次登录尝试、每 次TCP绘画的初始化等；</li>
<li>基于主机的IDS，包括对文件的读、写或执行</li>
</ol>
</li>
<li><p>IDS传感器检测这些操作，创建这些操作的特征。将这 些记录报告给IDS管理器或者将它们写入审计日志</p>
</li>
<li><p>IDS事件记录包括：主体，对象，操作，异常条件，占用的资源，时间戳。</p>
</li>
</ol>
<h2 id="入侵检测系统的类型"><a href="#入侵检测系统的类型" class="headerlink" title="入侵检测系统的类型"></a>入侵检测系统的类型</h2><h3 id="基于规则的入侵检测"><a href="#基于规则的入侵检测" class="headerlink" title="基于规则的入侵检测"></a>基于规则的入侵检测</h3><ol>
<li><p><strong>规则</strong>标识与入侵攻击的某些已知<strong>配置文件匹配的操作类型</strong>，在这种情况下， 规则将编码此类攻击的<strong>签名</strong>。因此，如果IDS管理器看到与该规则的签名匹配的事件，它将立即发出警报，甚至可能指示怀疑的类型。</p>
</li>
<li><p><strong>优点</strong>：减少了误报，因为决策者已经明确了规则列表。</p>
</li>
<li><p><strong>缺点</strong>：存在局限性，因为它需要IDS具有每一个攻击类型的特征。</p>
<h3 id="基于统计的入侵检测"><a href="#基于统计的入侵检测" class="headerlink" title="基于统计的入侵检测"></a>基于统计的入侵检测</h3></li>
<li><p>构建了一个配置文件，它是用户行为或主机使用的<strong>典型方式</strong>的统计表示； 因此，它可用于确定用户或主机何时以非常不寻常的<strong>异常方式</strong>运行。</p>
</li>
</ol>
<h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><ol>
<li><p>允许用户列举计算机的哪个端口正在接受连接的技术。端口的状态包括：开放的，关闭的，阻塞的。</p>
</li>
<li><p>端口扫描的方法：</p>
<ol>
<li><p>TCP扫描/连接扫描：向目标主机的每个端口发起TCP连接。完成连接的端口是开放的，否则要么是关闭的，要么是阻塞的。</p>
</li>
<li><p>SYN扫描：向目标主机端口发起SYN标志的数据包，看是否有SYN-ACK返回。(如果收到，则发出一个RST数据包终止连接而非完成握手)</p>
</li>
<li><p>空闲扫描：它允许进行端口完全欺骗扫描。使得攻击者能够不使用自己的IP向目标主机发送数据包。它的巧妙之处在于，利用不活跃的“僵尸主机”反弹给攻击者一个旁通信道，从而使得攻击者可以进行端口扫描。入侵检测系统也就会把无辜的僵尸主机当成攻击者。利用僵尸可预测的TCP序列号实现。其过程如下：</p>
<ol>
<li>探测僵尸主机的IP ID 并记录。</li>
<li>向需要扫描的目标主机端口发送一个伪造成来自僵尸主机的SYN包。根据目标主机端口状态的不同，目标主机返回的数据包会使得僵尸主机的IP ID递增或否。</li>
<li>再次探测僵尸主机的IP ID。并对比第一步记录的IP ID就可以确定目标主机端口的状态。如果序列号递增了，则表示目标端口是开放的。否则，目标端口是关闭或阻塞的。</li>
</ol>
</li>
<li><p>UDP扫描：向目标主机端口发送UDP数据包。</p>
</li>
</ol>
</li>
</ol>
<h2 id="蜜罐"><a href="#蜜罐" class="headerlink" title="蜜罐"></a>蜜罐</h2><p>使用一台计算机作为诱饵的入侵检测技术。其优点包括</p>
<ol>
<li><p>入侵检测：因为连接到蜜罐的尝试不会来自合法用户，所以 对蜜罐的任何连接都被安全地确定为入侵。</p>
</li>
<li><p>证据：蜜罐计算机中有吸引力的文件使入侵者逗留并留下证据，从而识别出入侵者或者确定他的位置。</p>
</li>
<li><p>导流：与合法计算机相比，蜜罐对入侵者更有吸引力，从而分散入侵者对敏感信息和服务的注意力。</p>
</li>
</ol>
<h1 id="无线网"><a href="#无线网" class="headerlink" title="无线网"></a>无线网</h1><p>无线网引入安全问题包括：</p>
<ol>
<li>使得<strong>数据包嗅探</strong>更加容易。因为同一个网段的所有计算机都共享一个无线接入点。</li>
<li>使得<strong>会话劫持</strong>更加容易。因为配有无线适配器的计算机都可以嗅探出数据包并模拟无线接入点。</li>
<li>存在<strong>入侵</strong>问题。入侵指未授权用户通过其他人的无限接入点连接到互联网。</li>
<li>验证<strong>合法用户</strong>的难度增加。通过在局域网中主机的位置来验证合法主机再不可能，需要其他的身份验证或授权方法。</li>
</ol>
<h2 id="无线网结构"><a href="#无线网结构" class="headerlink" title="无线网结构"></a>无线网结构</h2><img src="/计安导_img/7.png"  />    

<ol>
<li>基于802.11标准。大多数的TCP/IP实现会根据不同的接收者重新定义数据包，即802.11帧和以太网帧的相互转换。</li>
<li>结构<ol>
<li>客户端计算机与接入点建立无线连接。</li>
<li>无线接入点连接到有线网络的接入点提供到互联网的网关。</li>
</ol>
</li>
</ol>
<h2 id="SSID-服务集ID"><a href="#SSID-服务集ID" class="headerlink" title="SSID (服务集ID)"></a>SSID (服务集ID)</h2><ol>
<li>SSID 32个字符组成的网络标识，使得多个无线网络可以共存。<ol>
<li>制造商的名称是接入点的典型默认SSID。</li>
<li>经常广播SSID可以使潜在用户能够发现网络</li>
</ol>
</li>
<li><strong>问题</strong> ：由于SSID未被签名，所以可以进行欺骗攻击<ol>
<li>将恶意接入点放置在公共场所（例如，咖啡馆，机场）； </li>
<li>使用ISP的SSID</li>
<li>设置类似于ISP的登录页面； </li>
<li>等待客户端连接到恶意接入点并进行身份验证；</li>
<li>可能会转发到ISP网络的会话；</li>
<li>由自动连接默认值促成</li>
</ol>
</li>
</ol>
<h2 id="强制网络门户"><a href="#强制网络门户" class="headerlink" title="强制网络门户"></a>强制网络门户</h2><ol>
<li><p><strong>定义</strong>：是公共接入网络的用户在授予访问权限之前必须查看和交互的网页。通常 用于商业中心、机场、酒店大堂、咖啡店等为用户提供免费Wi-Fi的场所</p>
</li>
<li><p><strong>协议</strong></p>
<ol>
<li><p>通过MAC地址定位客户端。</p>
</li>
<li><p>认证完成之前，任何URL都会被重定向到身份验证界面。</p>
<ol>
<li>防火墙会阻止其他流量。</li>
<li>名称服务器会将一切映射到认证服务器。</li>
</ol>
</li>
<li><p>身份验证之后，恢复常规网络服务。由DHCP提供IP地址。</p>
</li>
</ol>
</li>
<li><p><strong>问题</strong> </p>
<ol>
<li>如果客户端没有主动断开连接，则可以执行MAC欺骗和会话窃取。</li>
<li>如果身份验证之前未阻止防火墙之外的DNS流量，则隧道攻击可以绕过强制网络门户。</li>
</ol>
</li>
</ol>
<h2 id="Wardriving-and-Warchalking"><a href="#Wardriving-and-Warchalking" class="headerlink" title="Wardriving and Warchalking"></a>Wardriving and Warchalking</h2><ol>
<li>Wardriving在移动的汽车中，使用移动设备四处寻找无线网。</li>
<li>Warchalking（开战标记）：在公共场所绘制引导公共Wi-Fi网 络的一种绘画符号（源自流浪汉符号）</li>
</ol>
<h2 id="WEP-有线等效保密协议"><a href="#WEP-有线等效保密协议" class="headerlink" title="WEP 有线等效保密协议"></a>WEP 有线等效保密协议</h2><p>###<strong>目标</strong> ：</p>
<ol>
<li>机密性:防止窃听。</li>
<li>数据完整性：保证数据包不被篡改。</li>
<li>访问控制：仅路由正确加密的数据包。<br>###<strong>限制</strong></li>
<li>在数据链路层加密每个帧的主体。</li>
<li>避免传统的802.11标准。</li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>接入点和客户端共享40b的密钥。密钥在WEP会话期间不被更改。</p>
<h3 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h3><ol>
<li>流密码是一种对称加密系统，密文C由明文消息M异或密钥流生成，而密钥流是密钥产生的伪随机数二进制向量S。</li>
<li><strong>流密码是安全的</strong> 因为相同的密钥流永远不会被重用，否则攻击者会得到两个明文消息的异或值，统计攻击就能同时恢复明文和密钥流。<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3></li>
<li>计算消息M(有效载荷部分)的CRC校验和。</li>
<li>选择24b的初始化向量V</li>
<li>使用RC4流密码生成密钥流S(K,V)</li>
<li>计算密文 C=(M||CRC(m))⊕S(K,V)</li>
</ol>
<h3 id="WEP-认证方法"><a href="#WEP-认证方法" class="headerlink" title="WEP 认证方法"></a>WEP 认证方法</h3><p>包括开放系统和共享密钥两种。</p>
<ol>
<li><p><strong>开放系统</strong>身份验证</p>
<p> 客户端无需任何凭证就可以连接接入点。且只能使用正确的密钥发送和接收信息，否则接入点会忽略请求。</p>
</li>
<li><p><strong>共享密钥</strong>身份验证</p>
<p> 在连入接入点之前要先证明自己拥有接入点的WEP密钥。</p>
<ol start="2">
<li>接入点向客户端发起明文挑战，客户端用拥有的密钥加密该明文，并将生成的密文发给接入点。</li>
<li>如果接入点能正确解密，则可连接接入点。</li>
</ol>
</li>
</ol>
<h2 id="消息篡改攻击"><a href="#消息篡改攻击" class="headerlink" title="消息篡改攻击"></a>消息篡改攻击</h2><h3 id="消息篡改"><a href="#消息篡改" class="headerlink" title="消息篡改"></a>消息篡改</h3><p>对于给定一个任意字符串 ，我们想用M’=M⊕▲替换消息M</p>
<p>可以在中途用C’=C⊕(▲||CRC(▲))来替换C。</p>
<ol>
<li>需要直到消息中文本的位置即可</li>
<li><strong>脆弱性原因</strong> CRC检验和是通过XOR</li>
<li><strong>解决</strong> 改用哈希函数</li>
</ol>
<h2 id="IP重定向攻击"><a href="#IP重定向攻击" class="headerlink" title="IP重定向攻击"></a>IP重定向攻击</h2><p>指攻击者利用物理接入点解密数据包，将目的地址修改为恶意主机地址。</p>
<ol>
<li><p>过程为：</p>
<ol>
<li>窃听入站的IP数据包。</li>
<li>将数据包重新发送到由攻击者控制的外部计算机。</li>
<li>接收由接入点解密的数据包。</li>
<li>重复出站数据包。</li>
</ol>
</li>
<li><p>需要修改数据包校验和。校验和的差为：x’-x=(D’H+D’L)-(DH-DL)</p>
</li>
</ol>
<h2 id="重用初始化向量IV"><a href="#重用初始化向量IV" class="headerlink" title="重用初始化向量IV"></a>重用初始化向量IV</h2><h3 id="初始化向量IV"><a href="#初始化向量IV" class="headerlink" title="初始化向量IV"></a>初始化向量IV</h3><ol>
<li>每个数据包一个，24位。</li>
<li>以邮件的明文部分发送。</li>
<li>初始化向量空间过小会导致重用相同的密钥流。</li>
</ol>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li><strong>问题</strong> 重用初始化向量意味着重用密钥流，攻击者获得两条消息的XOR，可以恢复出消息和密钥流。</li>
<li><strong>默认IV存在上述问题</strong></li>
<li><strong>解决</strong> 使用随机IV，且长度要足够长。<h3 id="注入方法"><a href="#注入方法" class="headerlink" title="注入方法"></a>注入方法</h3></li>
<li>假设攻击者知道一个加密消息的一个明文。</li>
<li>利用RC4(X )⊕X⊕Y=RC4(Y),来构造计算CRC32的新消息。</li>
</ol>
<h2 id="身份验证欺骗"><a href="#身份验证欺骗" class="headerlink" title="身份验证欺骗"></a>身份验证欺骗</h2><ol>
<li>不知道密钥的非法用户可以通过窃听身份验证消息。</li>
<li><strong>攻击</strong><ol>
<li>生成挑战R和加密挑战C =(R||CRC(R))⊕S(K,V)</li>
<li>计算密钥流S(K,V)=(R||CRC(R))⊕C</li>
<li>从接入点挑战时重用密钥流S(K,V)</li>
</ol>
</li>
</ol>
<h2 id="慢攻击：WEP嗅探"><a href="#慢攻击：WEP嗅探" class="headerlink" title="慢攻击：WEP嗅探"></a>慢攻击：WEP嗅探</h2><p>通过大量数据包去计算初始化向量IV</p>
<h2 id="快攻击：数据包注入"><a href="#快攻击：数据包注入" class="headerlink" title="快攻击：数据包注入"></a>快攻击：数据包注入</h2><h2 id="WPA-Wi-fi访问保护"><a href="#WPA-Wi-fi访问保护" class="headerlink" title="WPA Wi-fi访问保护"></a>WPA Wi-fi访问保护</h2><p>目的是为了改进WEP</p>
<h3 id="区别WEP"><a href="#区别WEP" class="headerlink" title="区别WEP"></a>区别WEP</h3><ol>
<li>采用128位密钥和48位IV</li>
<li>支持除共享密钥外各种类型的身份验证。</li>
<li>会话期间动态修改密钥。</li>
<li>支持检查完整性的加密。</li>
<li>增加帧计数器防止重放攻击</li>
</ol>
<h3 id="WPA2"><a href="#WPA2" class="headerlink" title="WPA2"></a>WPA2</h3><ol>
<li>使用AES而不是RC4</li>
<li>处理加密，密钥管理和完整性</li>
<li>由反模式提供的MAC与密码块链接（CCMP）一起使用</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导第7章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC7%E7%AB%A0/"
    >计安导第7章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC7%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.478Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h1><h2 id="HTML-超文本标记语言"><a href="#HTML-超文本标记语言" class="headerlink" title="HTML 超文本标记语言"></a>HTML 超文本标记语言</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>静态文档描述语言</li>
<li>支持链接到其他页面或者嵌入图像</li>
<li>通过表单（Forms）将用户输入发送到服务器<h2 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h2></li>
<li>先检索本地DNS，如果没有找到则查询DNS服务器</li>
<li>解析IP地址之后，建立TCP连接</li>
<li>HTTP请求和响应<strong>通过TCP的端口80</strong>传输</li>
<li>不提供数据加密，以明文发送</li>
</ol>
<h2 id="安全套接字层超文本传输协议HTTPS"><a href="#安全套接字层超文本传输协议HTTPS" class="headerlink" title="安全套接字层超文本传输协议HTTPS"></a>安全套接字层超文本传输协议HTTPS</h2><ol>
<li><p>与HTTP语法相同，但使用了安全套接字层SSL或传输层安全TLS</p>
</li>
<li><p>SSL和TLS都依靠证书来验 证服务器的身份，并建立加 密的通信信道</p>
 <img src="/计安导_img/8.png">

</li>
</ol>
<h1 id="网络钓鱼"><a href="#网络钓鱼" class="headerlink" title="网络钓鱼"></a>网络钓鱼</h1><p>通过伪造网页以欺诈的方式获取敏感资料</p>
<h2 id="URL混淆-同源攻击"><a href="#URL混淆-同源攻击" class="headerlink" title="URL混淆    同源攻击"></a>URL混淆    同源攻击</h2><p>注册带有unicode字符的域名，针对相似的字母进行注册。称为<strong>同源攻击</strong></p>
<h2 id="移除或伪造地址栏"><a href="#移除或伪造地址栏" class="headerlink" title="移除或伪造地址栏"></a>移除或伪造地址栏</h2><h1 id="图像崩溃"><a href="#图像崩溃" class="headerlink" title="图像崩溃"></a>图像崩溃</h1><p>由于浏览器的缺陷导致。通过HTML代码创建一个非常大比例的简单图像，可以使IE 崩溃，有时还会使电脑宕机。</p>
<h1 id="可移动代码"><a href="#可移动代码" class="headerlink" title="可移动代码"></a>可移动代码</h1><p><strong>可移动代码</strong> 指可执行、通过网络发送、在目标 电脑上执行的代码程序。包括</p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h2 id="ActiveX控件"><a href="#ActiveX控件" class="headerlink" title="ActiveX控件"></a>ActiveX控件</h2><h3 id="支持签名"><a href="#支持签名" class="headerlink" title="支持签名"></a>支持签名</h3><p>此签名的ActiveX控件要求 用户运行权限。如果获得批准，控件将以与用户相同的权限运行</p>
<h3 id="受信任-不受信任的ActiveX控件"><a href="#受信任-不受信任的ActiveX控件" class="headerlink" title="受信任/不受信任的ActiveX控件"></a>受信任/不受信任的ActiveX控件</h3><ol>
<li><p>可行的发布者：</p>
<ol>
<li>存储在Windows注册表中的列表 </li>
<li>恶意ActiveX控件可以修改注册表，使其发行者可信 </li>
<li>运行该发布者今后所有的插件不需要提示用户</li>
</ol>
</li>
<li><p>未签名的控件</p>
<ol>
<li>浏览器对于未签名的控件会给出一个接受/拒绝的选项</li>
<li>但即使你拒绝该控件，它也已被下载到一个临时文件夹中</li>
<li>如果拒绝，它不会被执行，但也不会被删除</li>
</ol>
</li>
</ol>
<p>###<strong>可以访问用户文件</strong></p>
<h2 id="Java插件"><a href="#Java插件" class="headerlink" title="Java插件"></a>Java插件</h2><h3 id="支持签名-1"><a href="#支持签名-1" class="headerlink" title="支持签名"></a>支持签名</h3><p>###<strong>沙箱执行</strong></p>
<ol>
<li>沙箱：应用程序或脚本在另一个应用程序中首先的运行权限。沙箱只能访问某些文件和设备。</li>
</ol>
<h1 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h1><p>cookie是指存储在计算机上、与特定服务器关联的 一小部分信息。用于在会话中保存状态信息。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>可能包含敏感信息</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol>
<li><strong>会话型cookie</strong>：是浏览器的处理过程中保留的，是暂时性的，当 浏览器关闭时则消除。</li>
<li><strong>持久性cookie</strong>：而持久性的是保存在客户端的硬盘上的，浏览器 关闭也不会消除。</li>
</ol>
<h1 id="跨站脚本-XSS"><a href="#跨站脚本-XSS" class="headerlink" title="跨站脚本 XSS"></a>跨站脚本 XSS</h1><p>用于攻击者将脚本代码注入Web应用程序生成的页面。攻击者通常在有漏洞的程序中插入Javascript， VBScript，ActiveX或Flash以欺骗用户。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>2005 年 Samy 在社交网站Myspace的个人资料中加入 Javascript ，打开该页面 的浏览器将执行该脚本 ― 首先把攻击者加为好友，其次把这段 XSS 复制到被 攻击者的个人资料中。</p>
<p>这算是一种<strong>蠕虫</strong></p>
<h2 id="XSS的发起条件"><a href="#XSS的发起条件" class="headerlink" title="XSS的发起条件"></a>XSS的发起条件</h2><ol>
<li>Web服务器没有对用户输入进行有效性验证或者验证强度不够 ，而又轻易地将它们返回到客户端</li>
<li>允许用户在表格或编辑框中输入不相关字符</li>
<li>存储并允许把用户输入显示在返回给终端的页面上，而没有去 除非法字符或者重新进行编码</li>
</ol>
<h2 id="XSS盗取cookie"><a href="#XSS盗取cookie" class="headerlink" title="XSS盗取cookie"></a>XSS盗取cookie</h2><ol>
<li>首先编写获取cokie的php脚本</li>
<li>向被攻击者服务器页面上注入一段JS代码，用于将被攻击者的cookie传送到我们的服务器。</li>
</ol>
<h2 id="XSS的防御"><a href="#XSS的防御" class="headerlink" title="XSS的防御"></a>XSS的防御</h2><h3 id="基于代理"><a href="#基于代理" class="headerlink" title="基于代理"></a>基于代理</h3><ol>
<li>分析浏览器和Web服务器之间的HTTP通信量</li>
<li>寻找HTML中的特殊字符</li>
<li>执行Web页面之前对它们进行编码</li>
</ol>
<h3 id="使用应用层防火墙"><a href="#使用应用层防火墙" class="headerlink" title="使用应用层防火墙"></a>使用应用层防火墙</h3><ol>
<li>分析HTML页面中可能导致敏感信息泄漏的超链接</li>
<li>对于使用不良请求的一系列链接进行停止操作</li>
</ol>
<h3 id="审计制度"><a href="#审计制度" class="headerlink" title="审计制度"></a>审计制度</h3><p>监视JavaScript代码的执行，并将操作与高级策略进行比较，以 检测恶意行为</p>
<h1 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h1><p>SQL注入：就是通过把SQL命令插入到Web表单提交或输入 域名或页面请求的查询字符串，最终达到欺骗服务器执行恶 意的SQL命令</p>
<h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><ol>
<li>web应用程序从表单中获取用户输入</li>
<li>用户提交的信息用于构建查询</li>
<li>SQL注入攻击涉及在用户输入中放置SQL语句。</li>
</ol>
<h2 id="万能语句-1-or-1"><a href="#万能语句-1-or-1" class="headerlink" title="万能语句 1 or 1"></a>万能语句 1 or 1</h2><h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><ol>
<li>使用预编译语句，绑定变量。</li>
<li>对用户提交的数据和输入参数进行严格过滤。</li>
<li>使用安全函数</li>
<li>摒弃动态SQL语句，改用存储过程来访问和操作数据。</li>
<li>最小权限原则：避免Web直接使用root</li>
</ol>
<h1 id="DoS-拒绝服务攻击"><a href="#DoS-拒绝服务攻击" class="headerlink" title="DoS 拒绝服务攻击"></a>DoS 拒绝服务攻击</h1><p>任何旨在 使计算机或系统不可用或无法执行基本功能的攻击。如TCP 泛滥攻击，DNS放大攻击。</p>
<h2 id="分布式拒绝服务攻击-DDoS"><a href="#分布式拒绝服务攻击-DDoS" class="headerlink" title="分布式拒绝服务攻击 DDoS"></a>分布式拒绝服务攻击 DDoS</h2><ol>
<li>利用控制的大量僵尸计算机同时攻击目标。使得传统DoS攻击不了的高性能服务器也变得不安全。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导第10章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC10%E7%AB%A0/"
    >计安导第10章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC10%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.478Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="数据库安全"><a href="#数据库安全" class="headerlink" title="数据库安全"></a>数据库安全</h1><h2 id="两阶段协议–实现完整性和可用性"><a href="#两阶段协议–实现完整性和可用性" class="headerlink" title="两阶段协议–实现完整性和可用性"></a>两阶段协议–实现完整性和可用性</h2><ol>
<li>第一阶段是请求阶段：<ol>
<li>该阶段，确定所要修改的部分，并标记。</li>
<li>结果是成功或终止。在成功时，每个修改请求都是可 用的，标记被修改；在中止时，由于别人早已对其进行了标记，或者 由于网络或系统出现了故障，所以不能标记所有需要修改的部分。</li>
<li>如果第一阶段被中止，则重置所有修改的请求，这样做是完全可行 的，因为并未进行任何永久性的修改。如果第一阶段成功完成，则协议继续第二个阶段。</li>
</ol>
</li>
<li>第二阶段是提交阶段<ol>
<li>在这个阶段，对于其他 修改而言，数据库是锁定的，只执行在请求阶段确定的修改序列。</li>
<li>如果更新成功完成，则清除所有确定请求修改的标志，并释放对数据库的锁定。</li>
<li>如果更新操作失败，则回滚，使数据库回到完成第一 阶段后的状态。</li>
</ol>
</li>
</ol>
<h2 id="数据库访问控制"><a href="#数据库访问控制" class="headerlink" title="数据库访问控制"></a>数据库访问控制</h2><ol>
<li><p><strong>最小特权原则</strong>：实现适当的访问控制应遵 循最小特权原则，使每个用户都拥有完成自己任务所必需的权限，但 除此之外，不再拥有其他的权限</p>
</li>
<li><p><strong>特权分离原则</strong>：实现适当的访问控 制还应遵循特权分离原则，以便不同的用户具有不同的权限，这取决 于他们需要执行的不同任务</p>
</li>
<li><p>数据库允许SQL实现权限委托</p>
</li>
<li><p>权限委托：除了能向其他用户授予具体的权限外，表的所有者还允许其他用户来授予 这些表的权限，这称为策略授权委托</p>
</li>
<li><p>权限撤销：级联撤销</p>
</li>
</ol>
<h2 id="敏感信息"><a href="#敏感信息" class="headerlink" title="敏感信息"></a>敏感信息</h2><p>1.要保护用户因素，满足机密性要求<br>2. 方法：使用加密，存储密文。授权用户直到解密密钥，但不能将解密密钥存储在数据库中。<br>3. 隐私保护：如果数据库是公开的，比如说是出于研究的目的，则应删除姓名、地址、 社会安全码、员工人数和学生人数等身份信息，或改用掩码值 ，从而不提供任何身份信息。</p>
<h2 id="推理攻击"><a href="#推理攻击" class="headerlink" title="推理攻击"></a>推理攻击</h2><ol>
<li><p>推理攻击：即使删除或屏蔽掉身份信息，攻击者仍能将其他的信息与数据库结合，得到底层的数据。</p>
</li>
<li><p>推理攻击的防御：</p>
<ol>
<li><p>单元抑制：在使用这种技术时，会删除数据库 中的一些单元，在公开版本中只留下空白。</p>
</li>
<li><p>推广：在使用这种技术时，公开数据库中的一些 值被更常用的值所替代。</p>
</li>
<li><p>加噪：在使用这种技术时，在公开数据库中添加 了随机值，使具有相同属性的所有记录的平均噪声为零。</p>
<img src="/计安导_img/27.png">

</li>
</ol>
</li>
</ol>
<h1 id="垃圾邮件和网络犯罪"><a href="#垃圾邮件和网络犯罪" class="headerlink" title="垃圾邮件和网络犯罪"></a>垃圾邮件和网络犯罪</h1><h2 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h2><ol>
<li>使用25端口建立TCP连接</li>
<li>客户端向服务器发送命令，服务器确认或通知错误</li>
<li><strong>问题</strong> <ol>
<li>发件人未经过身份验证 </li>
<li>消息和消息头使用明文传输 </li>
<li>消息和消息头完整性没有得到保护</li>
</ol>
</li>
</ol>
<h2 id="垃圾邮件"><a href="#垃圾邮件" class="headerlink" title="垃圾邮件"></a>垃圾邮件</h2><ol>
<li>垃圾邮件：不清自来的批量电子邮件</li>
</ol>
<h2 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h2><img src="/计安导_img/28.png">

<h2 id="灰名单"><a href="#灰名单" class="headerlink" title="灰名单"></a>灰名单</h2><ol>
<li>灰名单：是一种垃圾邮件过滤技术，接收邮件服务器拒绝来自未知发 件人的邮件。当接收来自未知发件人的邮件时，接收服务器会发送一 个“临时拒绝”消息给发送方，并记录相应的信息。</li>
<li>维护一个可信发件服务器的数据库</li>
<li>简单易行高效</li>
</ol>
<h2 id="发件人ID和发件人策略框架"><a href="#发件人ID和发件人策略框架" class="headerlink" title="发件人ID和发件人策略框架"></a>发件人ID和发件人策略框架</h2><ol>
<li>发件人策略框架(SPF)可对发件人的发送邮 件代理进行身份验证，其中不使用加密 技术。接收方MTA会检查发送方MTA的IP是否在发件人域的授权IP 地址列表中。</li>
</ol>
<h2 id="发件人的MTA身份验证：DKIM"><a href="#发件人的MTA身份验证：DKIM" class="headerlink" title="发件人的MTA身份验证：DKIM"></a>发件人的MTA身份验证：DKIM</h2><ol>
<li>域密钥标识邮件DKIM：是一种用于验证发送邮件传输代理的方法</li>
<li>签名实体(通常是发件人的MTA) 向消息中增加签名， 表明消息的签名实体所在的域</li>
<li>公钥存储在DNS的文本记录中</li>
</ol>
<h2 id="SPF-vs-DKIM"><a href="#SPF-vs-DKIM" class="headerlink" title="SPF vs DKIM"></a>SPF vs DKIM</h2><img src="/计安导_img/29.png">

<h2 id="网络犯罪"><a href="#网络犯罪" class="headerlink" title="网络犯罪"></a>网络犯罪</h2><ol>
<li>网络犯罪：是使用计算机、网络或硬件设备犯下的任何罪行。 计算机或 设备可以是犯罪的代理人，犯罪的促进者或犯罪的目标。 犯罪可以 单独在计算机上进行，也可以在其他地方进行</li>
</ol>
<h2 id="信用卡"><a href="#信用卡" class="headerlink" title="信用卡"></a>信用卡</h2><ol>
<li><p>特点</p>
<ol>
<li>支持保密</li>
<li>可与多个商家共享</li>
<li>经常被不安全的传送</li>
<li>熵值较低</li>
</ol>
</li>
<li><p>优点：简单易行</p>
</li>
<li><p>缺点：易发生欺诈</p>
</li>
<li><p>防范：</p>
<ol>
<li>一次性信用卡号码</li>
<li>监控交易</li>
<li>交易时启动密码输入</li>
</ol>
</li>
</ol>
<h2 id="常见银行欺诈"><a href="#常见银行欺诈" class="headerlink" title="常见银行欺诈"></a>常见银行欺诈</h2><ol>
<li>伪造支票</li>
<li>电子汇款</li>
<li>创建恶意账户</li>
<li>多重身份认证</li>
<li>账户所有权验证</li>
<li>账户限制</li>
<li>监控银行交易</li>
<li>取消网银</li>
</ol>
<h1 id="支付系统"><a href="#支付系统" class="headerlink" title="支付系统"></a>支付系统</h1><h2 id="电子支付方案"><a href="#电子支付方案" class="headerlink" title="电子支付方案"></a>电子支付方案</h2><ol>
<li>是一种多方协议</li>
<li>目标：<ol>
<li>完整性：电子货币不能伪造或复制；合法交易能够兑现</li>
<li>问责制：交易后不可否认</li>
<li>隐私</li>
</ol>
</li>
</ol>
<h2 id="私密支付方案"><a href="#私密支付方案" class="headerlink" title="私密支付方案"></a>私密支付方案</h2><h3 id="盲签名"><a href="#盲签名" class="headerlink" title="盲签名"></a>盲签名</h3><ol>
<li><p>允许签名者在不知道消息本身的情况下对消息进行签名</p>
</li>
<li><p>基本过程</p>
<ol>
<li>银行对客户提取的货币进行盲签名 </li>
<li>商家验证签名并存入货币 </li>
<li>银行无法将货币与客户关联起来</li>
</ol>
</li>
<li><p>RSA 盲签名</p>
 <img src="/计安导_img/30.png">

 <img src="/计安导_img/31.png"></li>
<li><p>对钱币进行盲签名</p>
 <img src="/计安导_img/32.png">

</li>
</ol>
<h2 id="防止双重支付"><a href="#防止双重支付" class="headerlink" title="防止双重支付"></a>防止双重支付</h2><ol>
<li>联机系统：在支付过程中，银行保持在线，实时撤销已使用的钱币</li>
<li>离线系统：<ol>
<li>每个提款的钱币都包含客户身份的加密信息</li>
<li>每个存款的钱币都包含商家身份的加密信息</li>
<li>双重支付将导致欺骗者的身份被披露出来</li>
</ol>
</li>
</ol>
<h2 id="秘密分享"><a href="#秘密分享" class="headerlink" title="秘密分享"></a>秘密分享</h2><p>步骤</p>
<ol>
<li>一个秘密字符串 x 可以被划分为以下的随机值 y 和 z。选择一个随机数 y ；z = y⊕x</li>
<li>通过x = y⊕z重构字符串x</li>
<li>其中y和z都是随机值，成为x的秘密份额，任一秘密份额都不会揭示关于秘密值 x 的任何信息</li>
</ol>
<h2 id="钱币–保护匿名性"><a href="#钱币–保护匿名性" class="headerlink" title="钱币–保护匿名性"></a>钱币–保护匿名性</h2><ol>
<li>给定一个秘密值x和关于x的承诺(a,b)</li>
<li>a=h(y) b=h(z) y,z是x的秘密份额</li>
</ol>
<h2 id="取款"><a href="#取款" class="headerlink" title="取款"></a>取款</h2><ol>
<li>客户生成并向银行提交 k 个钱币 </li>
<li>银行随机选择 k-1 枚钱币 </li>
<li>银行要求客户向其披露所选定的 k-1 个钱币的承诺的秘密份额 </li>
<li>银行在剩余的硬币上创建一个盲签名 </li>
<li>银行签名的钱币是有效的概率是 1 - 1/k</li>
</ol>
<h2 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h2><ol>
<li><p>客户向商家提交钱币 {x, [(a1, b2) , … , (an, bn)]} </p>
</li>
<li><p>商家验证钱币上的签名 </p>
</li>
<li><p>商家发送给客户一个随机的二进制向量 s1, … , sn, 称为选择器。</p>
</li>
<li><p>客户向商家揭示由选择器所选定的秘密份额，即客户向商家发送 一组字符串 P1, … , Pn </p>
<p> h(Pi) = ai if si = 0 </p>
<p> h(Pi) = bi if si= 1</p>
</li>
</ol>
<h2 id="存款及其安全性分析"><a href="#存款及其安全性分析" class="headerlink" title="存款及其安全性分析"></a>存款及其安全性分析</h2><ol>
<li><p>存款</p>
<ol>
<li>商人将钱币和字符串 P1, … , Pn提交给银行进行存款 </li>
<li>银行验证签名并且记录钱币和相应字符串的对应关系</li>
</ol>
</li>
<li><p>安全性分析</p>
<ol>
<li>两个商家提供的选择器相同的概率是 1/2<sup>n</sup> </li>
<li>因此，如果客户将1个钱币进行双重支付，那么银行发现该客户 身份的概率为 1/2<sup>n</sup>  </li>
<li>客户想要在不被银行发现的情况进行双重支付的唯一办法是找到 一个Hash函数的碰撞。</li>
</ol>
</li>
</ol>
<h1 id="数字版权管理"><a href="#数字版权管理" class="headerlink" title="数字版权管理"></a>数字版权管理</h1><ol>
<li>数字版权管理：是指能限制用户 使用数字内容的做法，常用于数字媒体，如DVD、下载的音乐和 许可的软件<h2 id="复制保护方法"><a href="#复制保护方法" class="headerlink" title="复制保护方法"></a>复制保护方法</h2></li>
<li>加密狗</li>
<li>产品密钥</li>
<li>手机激活</li>
</ol>
<h2 id="用于媒体文件的DRM方案"><a href="#用于媒体文件的DRM方案" class="headerlink" title="用于媒体文件的DRM方案"></a>用于媒体文件的DRM方案</h2><p>步骤</p>
<ol>
<li>媒体服务器向播放器发送用文件密钥加密的媒体文件和用播放器密钥加密的文件密钥</li>
<li>播放器先用播放器密 钥解密文件密钥，然 后使用文件密钥解密 媒体文件</li>
</ol>
<h2 id="叛徒识别"><a href="#叛徒识别" class="headerlink" title="叛徒识别"></a>叛徒识别</h2><p><img src="/%E8%AE%A1%E5%AE%89%E5%AF%BC_img/33.png" alt=""></p>
<h2 id="逻辑密钥对"><a href="#逻辑密钥对" class="headerlink" title="逻辑密钥对"></a>逻辑密钥对</h2><p><img src="/%E8%AE%A1%E5%AE%89%E5%AF%BC_img/34.png" alt=""></p>
<ol>
<li>是平衡二叉树，树的每个节点都与一个对称加密密钥相关联 </li>
<li>将设备与叶子节点关联，每个设备上存储着从叶子到根路径上的所有密钥</li>
<li>用节点 v 的密钥加密的内容可以被 v 的子树中的所有设备解密</li>
<li>撤销设备：如果设备需要被撤销，则必须更改此设备已知的密钥，并分发新的密钥。新密钥的分发可以通过广播对数级数量的加密消息来完成</li>
</ol>
<h2 id="加密广播"><a href="#加密广播" class="headerlink" title="加密广播"></a>加密广播</h2><ol>
<li>广播之前，每个内容都用单一的对称密钥进行加密。被授权产看内容项的订阅者应该拥有解密该项的密钥</li>
<li>每个节点的密钥可以被用来计算子孙节点的密钥</li>
<li>存在密钥分配问题</li>
</ol>
<h2 id="可信设备"><a href="#可信设备" class="headerlink" title="可信设备"></a>可信设备</h2><ol>
<li>由可信制造商加工，被分配一个保密的播放器密钥</li>
</ol>
<h2 id="内容扰乱系统CSS"><a href="#内容扰乱系统CSS" class="headerlink" title="内容扰乱系统CSS"></a>内容扰乱系统CSS</h2><p><img src="/%E8%AE%A1%E5%AE%89%E5%AF%BC_img/35.png" alt=""></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导第8章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC8%E7%AB%A0/"
    >计安导第8章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC8%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.478Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h1><h2 id="基本符号"><a href="#基本符号" class="headerlink" title="基本符号"></a>基本符号</h2><ol>
<li>密钥 K</li>
<li>加密算法 E<sub>K</sub>(P) = C</li>
<li>解密算法 D<sub>K</sub>(C)    = M<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2></li>
<li>密文长度通常和明文长度相同</li>
<li>加密/解密是所有n位二进制序列构成的集合上的 (双射)置换函数。加密算法EK(P)和解密算法DK(C)必须是高效的。</li>
<li>对密文解密后可恢复出明文，即D<sub>K</sub>(E<sub>K</sub>(P))=P</li>
</ol>
<h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><p>加密和解密使用同一个密钥</p>
<h2 id="攻击者主要类型"><a href="#攻击者主要类型" class="headerlink" title="攻击者主要类型"></a>攻击者主要类型</h2><ol>
<li>唯密文攻击：攻击者收集一个或多个消息的密文。且这些消息都使用相同的密钥K加密。攻击者的目标是根据一个或多个密文来确定明文，或者找到密钥K。</li>
<li>已知明文攻击：攻击者收集一个或多个明文-密文对。且每个这样的对都使用相同的密钥K加密。攻击者目标是确定密钥K。</li>
<li>选择明文攻击: 攻击者可收集指定的明文对应的密文信息。且这些明文都使用相同的密钥K。 目的在于破解密钥K。</li>
<li>选择密文攻击：攻击者可收集指定的密文 对应的明文信息。且这些明文都使用相同的密钥K。 目的在于破解密钥K。</li>
<li>穷举攻击：穷举可能的密钥，直到能把密文转换称有意义的明文。需要了解明文结构且密钥不长。</li>
</ol>
<h2 id="英文文本的唯一解距离计算"><a href="#英文文本的唯一解距离计算" class="headerlink" title="英文文本的唯一解距离计算"></a>英文文本的唯一解距离计算</h2><p>已知英文文本的信息熵为1.25bits，共t个字符，每个字符由8位二进制数的ASCII码表示。</p>
<img src="/计安导_img/9.png">

<img src="/计安导_img/10.png">

<h2 id="替换密码"><a href="#替换密码" class="headerlink" title="替换密码"></a>替换密码</h2><p>每个字母用不同的独一无二的其他字符替代。存在26!个可能的替换密码。存在4.03×1026个可能的密文。</p>
<h3 id="主要弱点"><a href="#主要弱点" class="headerlink" title="主要弱点"></a>主要弱点</h3><p>他们不隐藏明文中不同字母的基本频率。</p>
<h3 id="多字母替换密码和替换盒"><a href="#多字母替换密码和替换盒" class="headerlink" title="多字母替换密码和替换盒"></a>多字母替换密码和替换盒</h3><ol>
<li><p>多字母替换密码：对字母组进行替换。由26<sup>2</sup> = 676种可能的组合。会产生676!个可能的密钥</p>
</li>
<li><p>问题 导致密钥太长，需要保存所有替换组合密码。</p>
</li>
<li><p>替换盒(S-盒)：一张二维表，交叉处为相应的替换。</p>
 <img src="/计安导_img/11.png">

</li>
</ol>
<h3 id="频率分析"><a href="#频率分析" class="headerlink" title="频率分析"></a>频率分析</h3><p>对字母频率的分析是针对替换密码的有效攻击手段</p>
<h3 id="一次一密"><a href="#一次一密" class="headerlink" title="一次一密"></a>一次一密</h3><p>绝对牢不可破的替换密码</p>
<ol>
<li>使用密钥块(k1, k2, . . . , kn)来加密长度为n的明文M，每个密钥ki都是均匀随机生成的。由于每次都是完全随机地选择移动量，在密文中字母表的每 个字母出现的概率几乎相同</li>
<li>弱点：<ol>
<li>密钥块的长度m必须和明文的 长度n相同</li>
<li>密钥不可以被重用。而事实是密钥很可能被用完，当重用密钥时，安全性会大大降低。<h2 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h2>每条消息被划分成一系列的块，基于这些数据块来进行加密或解密。<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3></li>
</ol>
</li>
<li>明文和密文具有固定的长度b</li>
<li>长度为 n 的明文被划分为 m 个序列块 P[0], …, P[m-1]（n ≤ bm＜ n + b）</li>
</ol>
<h3 id="填充要求"><a href="#填充要求" class="headerlink" title="填充要求"></a>填充要求</h3><p>分组密码要求明文长度n应该为块长度b的倍数，所以最后一个块特殊。对最后一个数据块的填充必须是明确的（不能只是填充0）。要求</p>
<ol>
<li>当块大小和明文长度是8的倍数时，一种常用的填充方法（PKCS5） 是一组相同的字节，每个字节都表示填充的长度（以字节为单位）</li>
</ol>
<img src="/计安导_img/12.png"> 

<p>意思貌似是要填充9个字节，所以用9来填充。</p>
<h2 id="实际使用的分组密码"><a href="#实际使用的分组密码" class="headerlink" title="实际使用的分组密码"></a>实际使用的分组密码</h2><h3 id="AES-高级加密标准"><a href="#AES-高级加密标准" class="headerlink" title="AES 高级加密标准"></a>AES 高级加密标准</h3><ol>
<li>每组128位，所采用的密钥长度为128、192或者256 位，所得到的密码称为AES-128、AES-192和AES-256。</li>
<li>AES轮结构</li>
</ol>
<img src="/计安导_img/13.png"> 

<p>10轮异或之后得到密文。</p>
<ol>
<li>SubBytes步骤：S-盒替换步骤 </li>
<li>ShiftRows步骤：置换步骤 </li>
<li>MixColumns步骤：矩阵乘法（希尔密码）步骤</li>
<li>AddRoundKey步骤：使用从128位密钥派生的轮密钥的XOR步骤</li>
</ol>
<h3 id="数据加密标准（DES）"><a href="#数据加密标准（DES）" class="headerlink" title="数据加密标准（DES）"></a>数据加密标准（DES）</h3><h3 id="三重DES-（3DES）"><a href="#三重DES-（3DES）" class="headerlink" title="三重DES （3DES）"></a>三重DES （3DES）</h3><h2 id="分组密码的操作模式"><a href="#分组密码的操作模式" class="headerlink" title="分组密码的操作模式"></a>分组密码的操作模式</h2><h3 id="电子密码本模式-ECB"><a href="#电子密码本模式-ECB" class="headerlink" title="电子密码本模式     ECB"></a>电子密码本模式     ECB</h3><ol>
<li>明文块 P[i] 加密成密文块 C[i] = EK( P[i] )；密文块 C[i] 解密成明文块 M[i] = DK( C[i] )</li>
<li>优点 可以容忍分组丢失。因为解密i分组与i-1分组无关。</li>
<li>缺点<ol>
<li>如果加密算法是完全确定的，比如使用AES，那么每个明文都与唯一的密文相关联。对于很长的消息，ECB模式可能会解释分组流中出现的模式。</li>
<li>适用于短报文，如<strong>密钥和初始向量的加密</strong></li>
</ol>
</li>
</ol>
<h3 id="密码分组链接模式-CBC"><a href="#密码分组链接模式-CBC" class="headerlink" title="密码分组链接模式    CBC"></a>密码分组链接模式    CBC</h3><p>是最常用的模式之一</p>
<img src="/计安导_img/14.png"> 

<ol>
<li><p>加密 C[i] = EK(C[i-1] ⊕ P[i])    </p>
<p> C[-1] = V， 一个单独传输的随机加密数据块将作为初始化向量</p>
</li>
<li><p>解密 P[i] = C[i-1] ⊕DK(C[i])</p>
</li>
<li><p>优点</p>
<ol>
<li>没有在明文中泄露明文的模式</li>
<li>快速而简单</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>需要所有数据进行有序可靠的传输</li>
<li>不适用于允许丢包的应用，如音频流、视频流</li>
</ol>
</li>
</ol>
<h3 id="密码反馈模式-CFB"><a href="#密码反馈模式-CFB" class="headerlink" title="密码反馈模式 CFB"></a>密码反馈模式 CFB</h3><h3 id="输出反馈模式-OFB"><a href="#输出反馈模式-OFB" class="headerlink" title="输出反馈模式 OFB"></a>输出反馈模式 OFB</h3><h2 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h2><h3 id="密钥流"><a href="#密钥流" class="headerlink" title="密钥流"></a>密钥流</h3><p>是一组伪随机序列S = S[0], S[1], S[2], …… ；每次生成1位或者1个字节。</p>
<h3 id="流密码-1"><a href="#流密码-1" class="headerlink" title="流密码"></a>流密码</h3><p>密钥流和明文流进行对位异或操作 C[i] = S[i]⊕P[i]</p>
<h3 id="同步流密码"><a href="#同步流密码" class="headerlink" title="同步流密码"></a>同步流密码</h3><ol>
<li>密钥流的生成只依靠密钥K</li>
<li>如果明文是带有序列号的包，同步流密码可在不可靠信道下工作。</li>
</ol>
<h3 id="自同步流密码"><a href="#自同步流密码" class="headerlink" title="自同步流密码"></a>自同步流密码</h3><ol>
<li>使用密钥K和前q个密文来生成密钥流</li>
<li>在接收到q个密文后自动与密钥流生成器同步，如果数字被丢弃或添加到明文流中，更容易恢复。</li>
<li>自同步：因解码当前文字只依赖于固定个数的之前的密文字。所以仅有确定数量的明文字符不可被恢复。</li>
</ol>
<h3 id="RC4-流密码与密钥流生成器"><a href="#RC4-流密码与密钥流生成器" class="headerlink" title="RC4 流密码与密钥流生成器"></a>RC4 流密码与密钥流生成器</h3><ol>
<li>最多可以使用2048位的密钥</li>
<li>使用块大小为b的数据块</li>
<li>使用一个密钥对(K, t), K为密钥，计数器t是一个b位的值</li>
<li>密钥流由下列密文块连接而成: E<sub>K</sub>(t), E<sub>K</sub>(t+1), E<sub>K</sub>(t+2), ……<h2 id="针对流密码的攻击"><a href="#针对流密码的攻击" class="headerlink" title="针对流密码的攻击"></a>针对流密码的攻击</h2><h3 id="重试攻击"><a href="#重试攻击" class="headerlink" title="重试攻击"></a>重试攻击</h3>如果密钥流被重用，那么攻击者可获得两个明文的异或值<h3 id="插入攻击"><a href="#插入攻击" class="headerlink" title="插入攻击"></a>插入攻击</h3>将由攻击者选定的字节插入到消息流中，并使用相同的密钥流进行加密</li>
</ol>
<h1 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h1><h2 id="数论基础"><a href="#数论基础" class="headerlink" title="数论基础"></a>数论基础</h2><h3 id="素数-只能被1和他自身整除。"><a href="#素数-只能被1和他自身整除。" class="headerlink" title="素数 只能被1和他自身整除。"></a>素数 只能被1和他自身整除。</h3><ol>
<li>正整数n可以写成若干个素数的某次幂的乘积。如200=2<sup>3</sup>×5<sup>2</sup></li>
<li>算术基本定理：一个正整数的素数分解是唯一的</li>
</ol>
<h3 id="互质-两个数的最大公约数为1"><a href="#互质-两个数的最大公约数为1" class="headerlink" title="互质 两个数的最大公约数为1"></a>互质 两个数的最大公约数为1</h3><h3 id="辗转相除法-用于计算两个正整数的最大公约数"><a href="#辗转相除法-用于计算两个正整数的最大公约数" class="headerlink" title="辗转相除法 用于计算两个正整数的最大公约数"></a>辗转相除法 用于计算两个正整数的最大公约数</h3><ol>
<li><p>gcd(a, b) = gcd(b, a mod b)</p>
</li>
<li><p>算法最大迭代次数为1+2log max(a,b) </p>
<p> 复杂度 O(log min(a,b))</p>
<p> gcd(412,260)=4</p>
 <img src="/计安导_img/15.png">

</li>
</ol>
<h3 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h3><ol>
<li><p>xy mod n = 1, 则称 y 是 x 在 Zn的乘法逆元，记作 y = x - 1</p>
 <img src="/计安导_img/16.png">
</li>
<li><p>定理：Zn中的元素 x 有乘法逆元当且仅当 x 和 n 互素。</p>
</li>
<li><p>定理：a存在模b的乘法逆元的充要条件是gcd（a,b）= 1</p>
</li>
<li><p>定理：如果p是素数，那么Zp上的非0剩余类都有乘法逆元</p>
</li>
<li><p>定理：欧几里得算法可以用来计算 Zn 中元素 x 的乘法逆元或者确定该元素是否存在乘法逆元</p>
</li>
</ol>
<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><ol>
<li><p>若 p 是素数，x 是正整数且不能被 p 整除，则 x<sup>p-1</sup> mod p = 1</p>
 <img src="/计安导_img/17.png">
</li>
<li><p>若 p 是素数，x 是正整数且不能被 p 整除，x的乘法逆元是 xp<sup>p-2</sup> mod p</p>
</li>
</ol>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><ol>
<li>欧拉函数  Φ(n)指的是小于n且与n互素的正整数个数。Φ(1) = 1。 当p为素数时，Φ(p - 1) = p</li>
<li>欧拉定理：对任意互素的x和n，有 x<sup>Φ(n)</sup> mod n = 1</li>
</ol>
<img src="/计安导_img/18.png">

<h2 id="RSA-密码系统"><a href="#RSA-密码系统" class="headerlink" title="RSA 密码系统"></a>RSA 密码系统</h2><img src="/计安导_img/19.png">

<img src="/计安导_img/20.png">

<h3 id="RSA-安全性"><a href="#RSA-安全性" class="headerlink" title="RSA 安全性"></a>RSA 安全性</h3><p>基于给定e和n，找到d是困难的</p>
<h1 id="密码学哈希函数"><a href="#密码学哈希函数" class="headerlink" title="密码学哈希函数"></a>密码学哈希函数</h1><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><ol>
<li>哈希函数 指将可变长度的消息P 作为输入，产生固定 长度的Hash值 x = h(P)，称函数值h(P)为P的哈希值或消息摘要。</li>
<li>哈希表 是根据关键码值(Key value)而直接进行访问的数据结构。也就是说， 它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。</li>
<li>性质：<ol>
<li>单向性</li>
<li>抗弱碰撞性 想穷举出明文是困难的</li>
<li>抗强碰撞性 想伪造哈希签名是困难的</li>
<li>一个函数如果是抗强碰撞的，那么也同时是抗弱碰撞的，但反之则不 一定成立</li>
</ol>
</li>
</ol>
<h2 id="随机预言机"><a href="#随机预言机" class="headerlink" title="随机预言机"></a>随机预言机</h2><p>把随机预言机理解为<strong>完美</strong>的散列函数，具有</p>
<ol>
<li>一致性：对于相同的输入，其输出必然相同</li>
<li>可计算性：输出的计算可以在多项式时间内完成</li>
<li>均匀分布性：预言机的输出在取值空间内均匀分布，<strong>无碰撞</strong></li>
</ol>
<h2 id="生日攻击"><a href="#生日攻击" class="headerlink" title="生日攻击"></a>生日攻击</h2><p>暴力破解哈希，危害其抗碰撞性</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>随机产生消息序列X1，X2，X3，…</li>
<li>对于每个Xi计算Hash值 yi = h(Xi) 并且检测yi是否等于yj ( j &lt; i )</li>
<li>直至找到碰撞即停止</li>
</ol>
<h3 id="概率分析"><a href="#概率分析" class="headerlink" title="概率分析"></a>概率分析</h3><ol>
<li>对于b位的Hash函数，则有2<sup>b</sup>个Hash值数目</li>
<li>攻击者 生成的第 i 个消息与前面 i-1 个消息中任意一个产生冲突的概率为 1 - (i - 1)/m</li>
<li>在k轮的失败概率(即攻击者在生成 k个消息后没有找到冲突的概率)为Fk = (1 - 1/m) (1 - 2/m) (1 - 3/m) … (1 - (k - 1)/m)</li>
<li>用1- x ≈ e<sup>-x</sup>逼近,Fk ≈ e <sup>-(1/m + 2/m + 3/m + … + (k - 1)/m) </sup>= e <sup>-k ( k-1) / 2m</sup></li>
<li>当Fk = 1/2时，攻击成功/失败的概率为50%，即e <sup>-k ( k-1) / 2m</sup> = 1/2</li>
<li>进一步得到k=1.17&radic;m , 其中&radic;m 的位数是b/2，m位数的一半</li>
<li>所以通常根据输出大小的一半来考虑加密散列函数的安全, 比如256位抗冲突Hash函数的安全是128位。</li>
</ol>
<h2 id="MD5消息签名算法"><a href="#MD5消息签名算法" class="headerlink" title="MD5消息签名算法"></a>MD5消息签名算法</h2><p>对于任意两个密文Ｐ和Ｑ，通过250次MD5哈希运算可以找出两个前 缀S1和S2使得 P||S1 和 Q||S2 发生碰撞.</p>
<h1 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h1><h2 id="消息认证码-MAC"><a href="#消息认证码-MAC" class="headerlink" title="消息认证码 MAC"></a>消息认证码 MAC</h2><ol>
<li>发送方计算MAC值 c = h(K, M) 并且将c连同消息M一起传输。接收方从收到的消息中重新计算MAC值并将其与接收到的MAC进行比较。</li>
<li>密钥可以以单独加密并签名的方式发送</li>
</ol>
<h2 id="基于Hash函数的MAC-HMAC"><a href="#基于Hash函数的MAC-HMAC" class="headerlink" title="基于Hash函数的MAC HMAC"></a>基于Hash函数的MAC HMAC</h2><ol>
<li>密码学Hash函数不能直接用作消息认证函数。因为Hash函数内部迭代结构，所以标准Hash并不安全。</li>
<li>HMAC构造方法<ol>
<li>h(K⊕A||h(K⊕B||M)) A和B为常数</li>
</ol>
</li>
</ol>
<h2 id="安全信道"><a href="#安全信道" class="headerlink" title="安全信道"></a>安全信道</h2><p>确保不安全信道所传输的消息的完整性和机密性。包括</p>
<ol>
<li>签名配合加密：对(message, signature)加密后再进行传输</li>
<li>MAC配合加密：对(message, MAC)加密后再进行传输。<ol>
<li>比签名配合加密的方法更加高效：计算消息的MAC比对消息进行签名 和验证更快，且开销更低。</li>
</ol>
</li>
</ol>
<h2 id="Hash链"><a href="#Hash链" class="headerlink" title="Hash链"></a>Hash链</h2><img src="/计安导_img/21.png">

<ol>
<li><p>计算Hash链</p>
<p> xn = r </p>
<p> xi = h(x<sub>i+1</sub>) for i = n-1, …, 1</p>
</li>
<li><p>验证Hash链</p>
<p> xn+1 = 0</p>
<p> xi = h(Pi || x<sub>i+1</sub>) ) for i = n, …, 1</p>
</li>
</ol>
<h2 id="Hash-树"><a href="#Hash-树" class="headerlink" title="Hash 树"></a>Hash 树</h2><p>是一种树 形数据结构，每个叶节点均以 数据块的Hash作为标签，而 除了叶节点以外的节点则以其 子节点标签的Hash作为标签</p>
<h2 id="哈希认证树"><a href="#哈希认证树" class="headerlink" title="哈希认证树"></a>哈希认证树</h2><img src="/计安导_img/22.png">

<ol>
<li>g = h(h(a, h(x3, x4)), d)</li>
<li>proof(x4) = [(x3, L), (a, L), (d, R)]</li>
<li>具有对数级的存储和计算复杂度</li>
</ol>
<h2 id="允许丢包的数据流检验"><a href="#允许丢包的数据流检验" class="headerlink" title="允许丢包的数据流检验"></a>允许丢包的数据流检验</h2><img src="/计安导_img/23.png">
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导第9章" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC9%E7%AB%A0/"
    >计安导第9章</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC9%E7%AB%A0/" class="article-date">
  <time datetime="2020-03-30T02:29:18.478Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="策略、模型与信任"><a href="#策略、模型与信任" class="headerlink" title="策略、模型与信任"></a>策略、模型与信任</h1><h2 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h2><h3 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h3><p>是与系统交互的代理</p>
<h3 id="客体"><a href="#客体" class="headerlink" title="客体"></a>客体</h3><p>是安全策略要保护和管理的信息与计算资源</p>
<h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p>主体对客体可能(或不可能)执行的操作</p>
<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>主体、操作与客体之间的映射，权限明确规定允许或禁止哪些操作</p>
<h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p>策略中包含的特定安全特性或规则，以 帮助实现特定的安全目标，如保密性、完整性、可用性或匿 名性。</p>
<h2 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h2><p>是一种抽象的、为管理员指定安全策略提供 概念语言。</p>
<p>通常定义了</p>
<ol>
<li>组织成员所拥有的访问或修改权限的层次结构</li>
</ol>
<h2 id="自主访问控制-DAC"><a href="#自主访问控制-DAC" class="headerlink" title="自主访问控制 DAC"></a>自主访问控制 DAC</h2><p>指的是赋予用户能力确定文件访 问权限的一种方案。</p>
<ol>
<li>允许用户根据用户和组设置访问控制措施。</li>
<li>允许用户将资源特权授予同一系统上的其他用户。</li>
</ol>
<h2 id="强制访问控制-MAC"><a href="#强制访问控制-MAC" class="headerlink" title="强制访问控制 MAC"></a>强制访问控制 MAC</h2><ol>
<li>不允许用户定义文件的权限.</li>
<li>而是由中央策略管理员制定安全策略。</li>
<li>每个安全规则都由主体、客体和一系列的权限组成。其中主体是获得权限的的一方，客体是被访问的资源。</li>
</ol>
<h2 id="信任管理系统"><a href="#信任管理系统" class="headerlink" title="信任管理系统"></a>信任管理系统</h2><h2 id="组成包括"><a href="#组成包括" class="headerlink" title="组成包括"></a>组成包括</h2><ol>
<li><strong>策略语言</strong></li>
<li><strong>一致性检查器</strong></li>
<li>策略规则由策略语言指定，并由一致性检查器执行</li>
</ol>
<h2 id="规则包括"><a href="#规则包括" class="headerlink" title="规则包括"></a>规则包括</h2><ol>
<li>操作 与系统安全相关的结果</li>
<li>主题 可以在系统 上执行操作的用户、进程或其他实体</li>
<li>策略 就是制定的规 则，制定赋予主体哪些权限，能执行那些操作</li>
<li>凭证 数字签名 的文件，将主体身份与允许的行 为绑定，包括允许主体将权限委 托给其他主体的权限</li>
</ol>
<h1 id="访问控制模型"><a href="#访问控制模型" class="headerlink" title="访问控制模型"></a>访问控制模型</h1><h2 id="Bell-La-Padula模型"><a href="#Bell-La-Padula模型" class="headerlink" title="Bell-La Padula模型"></a>Bell-La Padula模型</h2><p>强制访问控制模型，保护机密性</p>
<h3 id="全序和偏序"><a href="#全序和偏序" class="headerlink" title="全序和偏序"></a>全序和偏序</h3><ol>
<li>全序：自反，反对称，传递，完全性(如果x和y在U中，则x ≤ y 或 y ≤ x)</li>
<li>偏序：去掉完全性</li>
</ol>
<h3 id="BLP-工作原理"><a href="#BLP-工作原理" class="headerlink" title="BLP 工作原理"></a>BLP 工作原理</h3><ol>
<li>原则：信息只能从低安全级别流向高安全级别。</li>
<li>安全级别是偏序的</li>
<li>每个对象x被分配到一个安全级别L(X)。同样，每个用户u被分配到 安全级别L(U)。用户对象的访问受以下两条规则控制：<ol>
<li>简单安全性质：只有满足L(x) ≼ L(u)，用户u才能读取对象x：即<strong>不可向上读</strong></li>
<li>性质只有满足L(u) ≼ L(x)，用户u才能写入（创建、编 辑或追加）对象x：即<strong>不可向下写</strong></li>
</ol>
</li>
</ol>
<h2 id="Biba模型"><a href="#Biba模型" class="headerlink" title="Biba模型"></a>Biba模型</h2><ol>
<li>Biba模型的完整性级别表明对象和用户的可信度或准确度。</li>
<li>Biba 不允许从下一级阅读，也不允许写到上层。</li>
</ol>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>如果让I(u)表示用户u的完整性级别，I(x)表示对象x的完整性级别， 则Biba模型中有以下规则：</p>
<ol>
<li>原则：信息只能从较高的完整性级别下降 到较低的完整性级别</li>
<li>用户u只能在I(u) ≼ I(x)情况下读取对象x：</li>
<li>用户u只能在I(x) ≼ I(u)情况下才能写入(创建、编辑或追加)一个对象x</li>
</ol>
<h2 id="低水印模型"><a href="#低水印模型" class="headerlink" title="低水印模型"></a>低水印模型</h2><p>扩展的Biba模型，放宽了不可想下读的限制。</p>
<ol>
<li>原则 具有较高完整性级别的用户可以读取完整性级别较低 的对象。</li>
<li>在这样的读取之后，对执行读取的用户进行降级，使其完整性级别 与所读取对象的完整性级别相匹配。</li>
</ol>
<h2 id="克拉克-威尔逊模型"><a href="#克拉克-威尔逊模型" class="headerlink" title="克拉克-威尔逊模型"></a>克拉克-威尔逊模型</h2><p>用于处理执行事务的系统。关键组件包括</p>
<ol>
<li>完整性约束：表明为了保证系统的状态有效，各对象之间必须满足的关系。</li>
<li>认证方法：验证事务给定的完整性约束。一旦认证了事务的程序，每 次执行事务时，则不必再次进行完整性约束验证。</li>
<li>职责分离原则：防止执行事务的用户验证事务。通常，每个事务都被 分配给可以分别验证和执行事务的不相交的用户集。</li>
</ol>
<h2 id="中国墙模型"><a href="#中国墙模型" class="headerlink" title="中国墙模型"></a>中国墙模型</h2><p>被设计用于商业领域， 以消除利益冲突的可能性。</p>
<ol>
<li>讲资源分组为利益冲突类</li>
<li>每个用户只能从每个利益冲突类访问一个资源。</li>
</ol>
<h2 id="基于角色的访问控制-RBAC"><a href="#基于角色的访问控制-RBAC" class="headerlink" title="基于角色的访问控制 RBAC"></a>基于角色的访问控制 RBAC</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>便于组织授权管理</li>
<li>支持继承</li>
<li>便于实现最小特权原则</li>
<li>可实现指责隔离原则</li>
<li>支持客体抽象</li>
<li>策略中立，通过不同配置能够实现特殊策略</li>
</ol>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ol>
<li>用户：需要访问组织的资源以执行任务的实体</li>
<li>角色：组织中具有类似功能和职责的用户的集合</li>
<li>权限：权限描述了允许访问资源的方法。</li>
<li>会话：由为执行特定任务而激活用户角色的子集组成。</li>
</ol>
<h3 id="分级RBAC"><a href="#分级RBAC" class="headerlink" title="分级RBAC"></a>分级RBAC</h3><ol>
<li>定义：色R1继承（inherits）R2，如果R1包含R2的所有权限，R2包括 R1的所有用户，可以表示为R1 ≽ R2。称R1为R2的上一层。</li>
</ol>
<h1 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p>渗透测试：从攻击者(黑客)的角度测试系统和体系结构的安全性，在 固定时间内必须获得的具有预定目标的“模拟攻击”</p>
<ol>
<li>组我欸其他安全措施的补充</li>
<li>花销大</li>
</ol>
</li>
<li><p>流程：</p>
<ol>
<li>收集信息<ol>
<li>IP地址信息</li>
<li>个人信息</li>
</ol>
</li>
<li>扫描IP：给定一组IP地址，确定每个服务和操作系统都在运行</li>
<li>识别系统：通过扫描开放电脑的网络连接端，确定哪些服务运行在哪些连接端，并且推断计算机运行哪个操作系统</li>
<li>识别易受攻击的服务：给定特定的IP地址和端口，尝试获得对机器 的访问权限。报告此目标的所有已知漏洞</li>
<li>利用漏洞</li>
</ol>
</li>
</ol>
<h1 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h1><ol>
<li>Kerberos：基于可信第三方（Trusted Third Party， TTP）的身份认证协议；</li>
<li>旨在对整个网络进行集中身份验证，而不是在每个用户计算机上存储敏感的身份验证信息。</li>
</ol>
<h2 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h2><ol>
<li><p>在身份验证过程中，客户端收到两个票据</p>
<ol>
<li>票据授予票据（TGT）：用户和会话密钥的全局标识符。</li>
<li>服务票据（service ticket）：对用户进行身份验证，确定用户能否 使用特殊服务。</li>
<li>票据都有时间戳，用于标明数据的有效期限</li>
</ol>
</li>
<li><p>密钥分发中心 KDC 组成</p>
<p> 为了实现安全的身份验证</p>
<ol>
<li>身份验证服务器(AS):用于执行用户身份验证。维护存储用户和服务密钥的数据库。对用户提供的密码执行单向散列来生成用户的密钥。</li>
<li>票据授予服务器(TGS):用于向用户授予票据</li>
</ol>
</li>
</ol>
<h3 id="身份认证过程"><a href="#身份认证过程" class="headerlink" title="身份认证过程"></a>身份认证过程</h3><p>概括的说</p>
<ol>
<li>客户端与AS互相进行身份验证</li>
<li>客户端与TGS互相进行身份验证</li>
<li>客户端与服务S互相进行身份验证，为客户端提供服务</li>
</ol>
<p>具体</p>
<ol>
<li><p>用户输入的密码经过哈希散列形成客户端密钥Kc</p>
</li>
<li><p>客户端与AS联系，AS执行</p>
<ol>
<li><p>使用客户端密钥Kc加密客户端-TGS的会话密钥K<sub>CT</sub></p>
</li>
<li><p>使用TGS的密钥K<sub>T</sub>加密票据授予票据TGT。TGT中包含K<sub>CT</sub>和有效期。</p>
</li>
<li><p>客户端使用Kc解密TGS会话密钥K<sub>CT</sub>。之后，客户端向TGS发送如下两个消息：</p>
<ol>
<li>TGT 和 所请求服务名称S</li>
<li>验证令牌 有用户ID和时间戳组成，使用客户端TGS会话密钥K<sub>CT</sub>进行加密</li>
</ol>
</li>
<li><p>.TGS使KT解密TGS，从而得到客户端TGS的会话密钥K<sub>CT</sub>和TGT的 有效期。在有效期之内，TGS使用密钥K<sub>CT</sub>解密身份验证令牌，向客 户端发送如下两个消息：</p>
<ol>
<li>使用K<sub>CT</sub>加密的新的客户端-服务器会话密K<sub>CS</sub>。 </li>
<li>使用具体服务的密钥KS加密客户端-服务器票据（client-server ticket），其中 TGS已知密钥KS 。票据包含客户端ID、网络地址、有效期、密钥K<sub>CS</sub>。</li>
</ol>
</li>
<li><p>在对客户端-服务器会话密钥K<sub>CS</sub>解密后，为了使服务对客户端进行身份验证，客户端发送以下两个消息： </p>
<ol>
<li>在上个步骤中，TGS发送的客户端-服务器的票据。 </li>
<li>使用K<sub>CS</sub>加密的客户端ID和时间戳。</li>
</ol>
</li>
<li><p>服务使用自己的密钥KS解密客户端-服务器的票据，得到客户端-服 务器的会话密钥K<sub>CS</sub> 。使用K<sub>CS</sub>解密客户端ID和时间戳。最后，为了向客户端证码自己的身份，它使用时间戳加1，并用K<sub>CS</sub>重新加密送回客户端。 </p>
</li>
<li><p>客户端使用KCS解密并验证这个响应，如果验证成功，就可以开始 客户端-服务器的会话了。</p>
</li>
<li><p>票据有效期内，客户端为了访问多个服务，可以一直重复3-7步。</p>
</li>
</ol>
</li>
</ol>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol>
<li>分布式体系结构，可以在不安全的网络中使用。</li>
<li>由于每次传输都使用适当的密钥进行加密，攻击者在不能破解密 钥或底层的加密算法的情况下，无法伪造有效的票据来获得对未 授权服务的访问。</li>
<li>可防止重放攻击，因为不接受未授权方重传的消息。</li>
<li>使用对称加密，所以比较高效</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>存在单点故障问题：密钥分发中心不可用</li>
<li>如果KDC被破坏，在每个客户端和服务器的身法验证信息都被泄漏</li>
<li>需要所有参与方都有同步的时钟</li>
</ol>
<h1 id="安全存储"><a href="#安全存储" class="headerlink" title="安全存储"></a>安全存储</h1><h2 id="安全保护措施"><a href="#安全保护措施" class="headerlink" title="安全保护措施"></a>安全保护措施</h2><ol>
<li>保存好U盘手机</li>
<li>防范窃取数据的恶意软件</li>
<li>合理处置废旧设备</li>
<li>备份</li>
<li>云存储</li>
</ol>
<h2 id="文件密码保护"><a href="#文件密码保护" class="headerlink" title="文件密码保护"></a>文件密码保护</h2><p>保护信息的一种方法就是对文件进行加密，在密码算法没有在理论破解或密钥泄露的情况下，即使文件被盗，也不用担心信息会泄露。</p>
<ol>
<li><p>常见密码算法</p>
 <img src="/计安导_img/25.png">


</li>
</ol>
<h3 id="加密文件系统-EFS"><a href="#加密文件系统-EFS" class="headerlink" title="加密文件系统 EFS"></a>加密文件系统 EFS</h3><ol>
<li><p>特点</p>
<ol>
<li>自动加密解密</li>
<li>保护文件内容，而不保护文件名和其他元数据</li>
<li>支持共享加密文件</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>只保护本地文件系统，所以传送到其他文件系统会被破解</li>
<li>临时文件不受保护</li>
<li>密钥管理很麻烦</li>
</ol>
</li>
<li><p>加密技术：同时使用对称和非对称加密</p>
 <img src="/计安导_img/26.png">

<ol>
<li>加密时首先使用AES(对称)单独的加密密钥FEK加密每个文件</li>
<li>然后使用FEK加密数据</li>
<li>再用用户的RSA(非对称)的公钥加密FEK，并保存文件的元数据。</li>
<li>解密时首先用用户的私钥解密FEK</li>
<li>然后再用FEK解密数据</li>
<li>注：每个用户对应一个经过公钥加密的FEK</li>
</ol>
</li>
</ol>
<h2 id="磁盘加密"><a href="#磁盘加密" class="headerlink" title="磁盘加密"></a>磁盘加密</h2><h3 id="TrueCrypt"><a href="#TrueCrypt" class="headerlink" title="TrueCrypt"></a>TrueCrypt</h3><ol>
<li>以分区为基础</li>
<li>所有加密数据都是经过AES等加密算法，难以破解</li>
<li>加密过程自动透明</li>
<li>提供两级方案<h3 id="BitLocker"><a href="#BitLocker" class="headerlink" title="BitLocker"></a>BitLocker</h3></li>
<li>使用AES对扇区进行加密</li>
<li>使用NTFS格式的卷</li>
<li>可以通过冷启动攻击：属于一种边信道攻击方法，可 以物理接触到计算机的攻击者能够运用这种攻击手段 在冷启动或硬盘重启之后，比如计算机没经历正常的 关机过程就突然重启时，从计算机的内存(RAM)中获 取加密密钥、口令和其他数据。断电后内存中的数据 能维持几十秒或数分钟，但通过液氮或压缩空气冷冻 ，这一数据衰减过程可被攻击者拉长至数小时之久。</li>
</ol>
<h2 id="可信平台模块-TPM"><a href="#可信平台模块-TPM" class="headerlink" title="可信平台模块 TPM"></a>可信平台模块 TPM</h2><p>是设计安装在主板上的芯片 ，作为安全密码处理器，它能安全地生成和存储密 钥。在生产时，将一个唯一地RSA私钥铸入到每一 个TPM芯片中。TPM的设计是防篡改的，所以，能 进行物理访问的攻击者也很难恢复这个密钥。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-计安导目录" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%9B%AE%E5%BD%95/"
    >计安导目录</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%9B%AE%E5%BD%95/" class="article-date">
  <time datetime="2020-03-30T02:25:27.697Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="计安导第2章"><a href="#计安导第2章" class="headerlink" title="计安导第2章"></a><a href="/2020/03/30/计安导第2章/">计安导第2章</a></h2><h2 id="计安导第3章"><a href="#计安导第3章" class="headerlink" title="计安导第3章"></a><a href="/2020/03/30/计安导第3章/">计安导第3章</a></h2><h2 id="计安导第4章"><a href="#计安导第4章" class="headerlink" title="计安导第4章"></a><a href="/2020/03/30/计安导第4章/">计安导第4章</a></h2><h2 id="计安导第5章"><a href="#计安导第5章" class="headerlink" title="计安导第5章"></a><a href="/2020/03/30/计安导第5章/">计安导第5章</a></h2><h2 id="计安导第6章"><a href="#计安导第6章" class="headerlink" title="计安导第6章"></a><a href="/2020/03/30/计安导第6章/">计安导第6章</a></h2><h2 id="计安导第7章"><a href="#计安导第7章" class="headerlink" title="计安导第7章"></a><a href="/2020/03/30/计安导第7章/">计安导第7章</a></h2><h2 id="计安导第8章"><a href="#计安导第8章" class="headerlink" title="计安导第8章"></a><a href="/2020/03/30/计安导第8章/">计安导第8章</a></h2><h2 id="计安导第9章"><a href="#计安导第9章" class="headerlink" title="计安导第9章"></a><a href="/2020/03/30/计安导第9章/">计安导第9章</a></h2><h2 id="计安导第10章"><a href="#计安导第10章" class="headerlink" title="计安导第10章"></a><a href="/2020/03/30/计安导第10章/">计安导第10章</a></h2>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-周期串" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%91%A8%E6%9C%9F%E4%B8%B2/"
    >周期串</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%91%A8%E6%9C%9F%E4%B8%B2/" class="article-date">
  <time datetime="2020-03-30T02:15:00.748Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uav-455-周期串"><a href="#uav-455-周期串" class="headerlink" title="uav 455 周期串"></a>uav 455 周期串</h1><p>如果一个字符串可以由某个长度为kkk 的字符串重复多次得到，则称该串以kkk 为周期。例如，abcabcabcabcabcabcabcabcabcabcabcabc 以333 为周期（注意，它也以666 和121212 为周期）。</p>
<p>输入一个长度不超过808080 的字符串，输出其最小周期。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
 # pragma warning(disable:4996)
# define LOCAL
# ifdef LOCAL
FILE *fin = freopen(&quot;习题3-8in.txt&quot;, &quot;r&quot;, stdin);
FILE *fout = freopen(&quot;习题3-8out.txt&quot;, &quot;w&quot;, stdout);
# endif 
using namespace std;
int main()
{
    int t; cin &gt;&gt; t;
    char s[85];
    while (t--)
    {
        memset(s, 0, sizeof(s));
        scanf(&quot;%s&quot;, s);
        int len = strlen(s);
        int j;
        for (int i = 1; i &lt;= len; ++i)
            if (len%i == 0)//说明长度i可以作为一个循环节
            {
                for (j = i; j &lt;= len; j++)
                    if (s[j] != s[j%i])//之后都和0-i-1的字符串来比较
                        break;
                if (j == len)
                {
                    cout &lt;&lt; i &lt;&lt; endl;
                    break;
                }
            }
        if (t)cout &lt;&lt; endl;
    }
}</code></pre>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-战场" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E6%88%98%E5%9C%BA/"
    >战场</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E6%88%98%E5%9C%BA/" class="article-date">
  <time datetime="2020-03-30T02:15:00.748Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="UVA-11853-战场"><a href="#UVA-11853-战场" class="headerlink" title="UVA 11853 战场"></a>UVA 11853 战场</h1><p>有一个1000*1000的正方形战场，战场西南角的坐标为(0,0)，西北角的坐标为(0,1000)。战场上有n个敌人，给定每个敌人的坐标和攻击半径，求能否从西边进入，从东边离开。如果有多个位置进出，则求出最北的进/出位置。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>地图比较大，敌人相对较少。转换思路，考虑能否从上边界踩着敌人到达下边界</p>
<ol>
<li>如果能，则说明敌人将战场从中分割，即无解。</li>
<li>如果不能，在选择最北的点。</li>
</ol>
</li>
<li><p>将问题转换成了图的连通性问题，下面给出bfs和dfs两种解法</p>
</li>
<li><p>dfs速度远远快于bfs</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    bool dfs(int u)</span><br><span class="line">	&#123;</span><br><span class="line">	if (vis[u]) return false;</span><br><span class="line">	vis[u] &#x3D; 1;</span><br><span class="line">	if (y[u] &lt; r[u]) return true;</span><br><span class="line">	for (int v &#x3D; 0; v &lt; n; v++) &#123;</span><br><span class="line">		if (intersect(u, v) &amp;&amp; dfs(v)) </span><br><span class="line">			return true;</span><br><span class="line">	&#125;</span><br><span class="line">	check(u);</span><br><span class="line">	return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">1. 注意是在走不通时，才更新进入点</span><br></pre></td></tr></table></figure>
<h3 id="intersect-判断两个圆是否相交"><a href="#intersect-判断两个圆是否相交" class="headerlink" title="intersect 判断两个圆是否相交"></a>intersect 判断两个圆是否相交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool intersect(int a, int b) &#123;</span><br><span class="line">return sqrt((x[a] - x[b])*(x[a] - x[b]) + (y[a] - y[b])*(y[a] - y[b])) &lt; r[a] + r[b];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="check-更新进入点"><a href="#check-更新进入点" class="headerlink" title="check 更新进入点"></a>check 更新进入点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void check(int u)</span><br><span class="line">&#123;</span><br><span class="line">if (x[u] &lt; r[u]) left &#x3D; min(left, y[u] - sqrt(r[u] * r[u] - x[u] * x[u]));</span><br><span class="line">if (x[u] + r[u] &gt; W) right &#x3D; min(right, y[u] - sqrt(r[u] * r[u] - (W - x[u])*(W - x[u])));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">#ifdef local</span><br><span class="line">freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">#endif &#x2F;&#x2F; local</span><br><span class="line">while (~scanf(&quot;%d&quot;, &amp;n)) &#123;</span><br><span class="line">	bool ok &#x3D; true;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	left &#x3D; right &#x3D; W;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, x + i, y + i, r + i);</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (r[i] + y[i] &gt;&#x3D; W &amp;&amp; dfs(i)) &#123; ok &#x3D; false; break; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (ok) printf(&quot;0.00 %.2lf 1000.00 %.2lf\n&quot;, left, right);</span><br><span class="line">	else printf(&quot;IMPOSSIBLE\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#pragma warning(disable:4996)</span><br><span class="line">#define LOCAL</span><br><span class="line">#ifdef LOCAL</span><br><span class="line">FILE *fin &#x3D; freopen(&quot;战场in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">FILE *fout &#x3D; freopen(&quot;战场out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">#endif </span><br><span class="line">using namespace std;</span><br><span class="line">int vis[1005];</span><br><span class="line">int n;</span><br><span class="line">double le, ri;</span><br><span class="line">struct Node &#123;</span><br><span class="line">double x, y, r;</span><br><span class="line">Node(double x, double y, double r) :x(x), y(y), r(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Node&gt; enemy;</span><br><span class="line">bool intersect(int u, int v) &#123;</span><br><span class="line">return sqrt(pow(enemy[u].x - enemy[v].x, 2) + pow(enemy[u].y - enemy[v].y, 2)) &lt; enemy[u].r + enemy[v].r;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line">void check_circle(int u) &#123;</span><br><span class="line">if (enemy[u].x - enemy[u].r &lt; 0)</span><br><span class="line">	le &#x3D; min(le, enemy[u].y - sqrt(enemy[u].r * enemy[u].r - enemy[u].x * enemy[u].x));</span><br><span class="line">if (enemy[u].x + enemy[u].r &gt; 1000)</span><br><span class="line">	ri &#x3D; min(ri, enemy[u].y - sqrt(enemy[u].r * enemy[u].r - (1000 - enemy[u].x) *(1000 - enemy[u].x)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool bfs(int i) &#123;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(i);</span><br><span class="line">while (!q.empty()) &#123;</span><br><span class="line">	int u &#x3D; q.front(); q.pop();</span><br><span class="line">	if (enemy[u].y - enemy[u].r &lt;&#x3D; 0) &#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	vis[u] &#x3D; 1;</span><br><span class="line">	check_circle(u);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (!vis[i] &amp;&amp; intersect(i, u))</span><br><span class="line">			q.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">while (cin &gt;&gt; n) &#123;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	enemy.clear();</span><br><span class="line">	le &#x3D; ri &#x3D; 1000;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		int x, y, r;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; r;</span><br><span class="line">		enemy.push_back(Node(x, y, r));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool flag &#x3D; true;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">		if (enemy[i].y + enemy[i].r &gt;&#x3D; 1000)</span><br><span class="line">			flag &#x3D; bfs(i);</span><br><span class="line"></span><br><span class="line">	if (!flag) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;IMPOSSIBLE&quot; &lt;&lt; endl;</span><br><span class="line">		continue;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;0.00 %.2f 1000.00 %.2f\n&quot;,le, ri);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-最大连续和问题" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C%E9%97%AE%E9%A2%98/"
    >最大连续和问题</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-03-30T02:15:00.748Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>给定一个长度为n的序列1,A2,···,An，求最大连续和</p>
<h1 id="O-n3"><a href="#O-n3" class="headerlink" title="O(n3)"></a>O(n<sup>3</sup>)</h1><p>枚举始末位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">for(int i&#x3D;0;i&lt;&#x3D;n;i++)</span><br><span class="line">	for(int j&#x3D;0;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">		int sum &#x3D; 0;</span><br><span class="line">		for(int k&#x3D;i;k&lt;&#x3D;j;k++)&#123;</span><br><span class="line">			sum+&#x3D;A[k];</span><br><span class="line">			tot++;</span><br><span class="line">		&#125;</span><br><span class="line">		if(sum&gt;best) best&#x3D;sum;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="O-n2"><a href="#O-n2" class="headerlink" title="O(n2)"></a>O(n<sup>2</sup>)</h1><p>先递推的求出前i项和，利用Sj-Si求出i-j的连续和</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">S[0] &#x3D; 0;</span><br><span class="line">for(int i&#x3D;0;i&lt;&#x3D;n;i++) S[i] &#x3D; A[i]+S[i-1];</span><br><span class="line">for(int i&#x3D;0;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">for(int j &#x3D; i;j &lt;&#x3D; n;j++)</span><br><span class="line">brest &#x3D; max(best,S[j]-S[i-1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分治法-O-nlogn"><a href="#分治法-O-nlogn" class="headerlink" title="分治法 O(nlogn)"></a>分治法 O(nlogn)</h1><ol>
<li>划分问题：将序列分成数量尽可能相等两部分</li>
<li>递归求解：分别求出完全位于左半部和完全位于右半部的最佳序列</li>
<li>合并问题：求出起点位于左半，终点位于右半的连续和序列<ol>
<li>注：递归方程T(n) = 2T(n/2)+O(n)</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int maxsum(int* A, int x, int y)&#123;</span><br><span class="line">int v, L , R,     maxs;</span><br><span class="line">if(y-x&#x3D;&#x3D;1) return A[X];</span><br><span class="line">int m &#x3D; x+(y-x)&#x2F;2;</span><br><span class="line">int maxs &#x3D; max(maxsum(A,x,m),maxsum(A,m,y));</span><br><span class="line">int v, L, R;</span><br><span class="line">v&#x3D; 0;L &#x3D; A[m-1];</span><br><span class="line">for(int i &#x3D; m-1;i &gt;&#x3D; x;i--)</span><br><span class="line">	L &#x3D; max(L,v +&#x3D; A[i]);</span><br><span class="line">v&#x3D; 0;L &#x3D; A[m];</span><br><span class="line">for(int i &#x3D; m;i &lt; y;i++)</span><br><span class="line">	R &#x3D; max(R,v +&#x3D; A[i]);</span><br><span class="line">return max(maxs, L+R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-照明系统设计" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E7%85%A7%E6%98%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"
    >照明系统设计</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E7%85%A7%E6%98%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" class="article-date">
  <time datetime="2020-03-30T02:15:00.748Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="UVA-11400-照明系统设计"><a href="#UVA-11400-照明系统设计" class="headerlink" title="UVA 11400 照明系统设计"></a>UVA 11400 照明系统设计</h1><p>题意: 给定n(n≤1000)种类型灯泡，每个灯泡给出其电压v(v≤132000)，电源花费k(k≤1000)，每个灯的花费c(c≤10) 和需求量l(1≤l≤100)l。现在通过用电压大的灯泡替换某些电压小的灯泡来减小总花费，求最小的花费。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>首先有结论，每种电压的灯泡要么全换，要么全部不换。这是因为，如果因为换1个降低成本，那么换2个也降低成本…全换了还剩一个电源钱，就很棒。</li>
<li>其次，由于题干要求只能换成电压更大的灯泡，所以先将所有种类的灯泡按电压从小到大排序。顺次遍历，对于更大电压的灯泡，依次尝试替换比他电压小的灯泡，更新状态。</li>
<li>设d(i)表示灯泡1~i的最小开销</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">struct Lamp &#123;</span><br><span class="line">	int v, k, c, l;</span><br><span class="line">	bool operator &lt; (const Lamp&amp;x)const &#123; return v &lt; x.v; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Lamp lamp[maxn];</span><br><span class="line">int d[maxn];</span><br><span class="line">int s[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d%d%d%d&quot;, &amp;lamp[i].v, &amp;lamp[i].k, &amp;lamp[i].c, &amp;lamp[i].l);</span><br><span class="line"></span><br><span class="line">		sort(lamp + 1, lamp + 1 + n);</span><br><span class="line">		s[0] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) s[i] &#x3D; s[i - 1] + lamp[i].l;</span><br><span class="line">		d[0] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			d[i] &#x3D; s[i] * lamp[i].c + lamp[i].k; </span><br><span class="line">			for (int j &#x3D; 1; j &lt;&#x3D; i; j++)</span><br><span class="line">				d[i] &#x3D; min(d[i], d[j] + (s[i] - s[j]) * lamp[i].c + lamp[i].k);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; d[n] &lt;&lt; &quot;\n&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/9/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/11/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        John Doe
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>