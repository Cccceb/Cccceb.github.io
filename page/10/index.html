<!DOCTYPE html>


<html lang="cn" >


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

  <script type="text/javascript"
	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/Bg.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/"></a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-视觉第5讲" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC5%E8%AE%B2/"
    >视觉第5讲</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC5%E8%AE%B2/" class="article-date">
  <time datetime="2020-03-30T03:17:13.871Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="特征不变性"><a class="markdownIt-Anchor" href="#特征不变性"></a> 特征不变性</h1>
<ol>
<li>
<p>不变性与协变性</p>
<ol>
<li>
<p>不变性：图像变换后，角点位置不变。</p>
<p>我们希望角点的位置对光照变换有不</p>
</li>
<li>
<p>协变性：如果有两张同一图像的变换版本，则应在相应的位置检测到同一特征。</p>
<p>我们希望角点对几何变换具有协变性。</p>
</li>
</ol>
</li>
<li>
<p>Harris检测器</p>
<ol>
<li>平移：
<ol>
<li>导数和窗口函数是平移不变的。</li>
<li>角点位置是平移协变的。</li>
</ol>
</li>
<li>图像旋转
<ol>
<li>形状是旋转不变的</li>
<li>角点位置是旋转协变的。</li>
</ol>
</li>
<li>仿射强度变化
<ol>
<li>
<p>对仿射强度变化部分具有不变性。</p>
 <img src="/视觉_img/5_1.png" style="zoom:80%">
</li>
</ol>
</li>
<li>缩放
<ol>
<li>对缩放不具有不变性。</li>
<li>实现尺度不变性：寻找使f具有局部最大值的尺度。
<ol>
<li>同时在位置和尺度上查找。</li>
</ol>
</li>
<li>自动尺度选择：规格化到固定尺度。
<ol>
<li>是在高斯金字塔中使用固定大小的窗口。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>高斯-拉布普拉斯算子(LoG)</p>
<p><a href="%22https://blog.csdn.net/touch_dream/article/details/62237018%22/a">高斯-拉普拉斯算子</a></p>
<ol>
<li>
<p>LoG是高斯函数的二阶导数</p>
</li>
<li>
<p>为了减少计算量，可以用高斯差分算子(DoG)来近似</p>
 <img src="/视觉_img/5_2.png" style="zoom:80%">
<p>该函数逼近是因为发现高斯二阶导和原高斯函数对sigma参数求导之后函数模型的关系如上述的公式，然后约等于右边的导数表达式（严格的话需要加上极限的）！模型逼近如下：好处是可以提高算法的效率减少计算量</p>
</li>
<li>
<p>LoG和DoG都是旋转不变的。</p>
</li>
</ol>
</li>
<li>
<p>Blob斑点检测器</p>
<ol>
<li>在空间和尺度上查找LoG算子的极大值和极小值。
<ol>
<li>
<p>将一个点与周围26个点比较，以求得极大值。</p>
 <img src="/视觉_img/5_3.png" style="zoom:80%">
</li>
</ol>
</li>
<li>特征尺度：产生拉普拉斯响应峰值的尺度。</li>
</ol>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-视觉第4讲" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC4%E8%AE%B2/"
    >视觉第4讲</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC4%E8%AE%B2/" class="article-date">
  <time datetime="2020-03-30T03:17:13.868Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="harris角点检测"><a class="markdownIt-Anchor" href="#harris角点检测"></a> Harris角点检测</h1>
<ol>
<li>不变的局部特征
<ol>
<li>几何不变性：平移、旋转、缩放</li>
<li>光度不变性：亮度、曝光率</li>
<li>局部特征的优点
<ol>
<li>局部性：由于特征是局部的，所以对遮挡和噪声鲁棒。</li>
<li>数量：一张图片中成百上千。</li>
<li>独特性：可以区分大量对象</li>
<li>效率：可实现实时性能。</li>
</ol>
</li>
</ol>
</li>
<li>好的特征
<ol>
<li>需要具有唯一性</li>
<li>在任何方向上移动窗口都导致大的变化–&gt;角点。</li>
</ol>
</li>
<li>Harris角点检测
<ol>
<li>
<p>通过比较平移前后窗口w内每个像素的差异平方和(SSD)</p>
</li>
<li>
<p>SSD:<br />
<img src="/视觉_img/4_1.png" style="zoom:80%"></p>
<ol>
<li>SSD越大越好</li>
<li>问题：计算每个点的SSD很慢。</li>
<li>对平移量进行泰勒级数展开。</li>
</ol>
</li>
<li>
<p>近似SSD</p>
 <img src="/视觉_img/4_2.png" style="zoom:80%">
 <img src="/视觉_img/4_3.png" style="zoom:80%">
 1. 对于水平边缘Ix=0;垂直边缘Iy=0;
 2. 对于矩阵H可以看作一个椭圆
<pre><code> &lt;img src=&quot;/视觉_img/4_4.png&quot; style=&quot;zoom:80%&quot;&gt;
 
 可以通过查看H的特征向量来找到导致最大和最小的E的方向。
 1. &lt;img src=&quot;/视觉_img/4_4.png&quot; style=&quot;zoom:80%&quot;&gt;
 2. 特征值与特征检测的关系：我们希望E(u,v)的最小值对于小的平移量(u,v)都大，此最小值由H的较小的特征值λ&lt;sub&gt;min&lt;/sub&gt;给出
</code></pre>
</li>
</ol>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-视觉第3讲" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC3%E8%AE%B2/"
    >视觉第3讲</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC3%E8%AE%B2/" class="article-date">
  <time datetime="2020-03-30T03:17:13.865Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="子采样"><a class="markdownIt-Anchor" href="#子采样"></a> 子采样</h1>
<ol>
<li>每隔一行一列丢弃一行一列</li>
<li>问题：导致噪声变多</li>
<li>解决：先滤波，再子采样</li>
</ol>
<h2 id="混叠"><a class="markdownIt-Anchor" href="#混叠"></a> 混叠</h2>
<ol>
<li>定义：当采样频率不够高时，无法捕捉图像中的细节。</li>
<li>解决：采样率≥2 * 图像中的最大频率&lt;=&gt;每周期至少两个样本</li>
<li>若原始图像频率太高，则先做高斯预处理，然后子采样。（高斯金字塔）</li>
</ol>
<h1 id="上采样"><a class="markdownIt-Anchor" href="#上采样"></a> 上采样</h1>
<h2 id="最简单方法"><a class="markdownIt-Anchor" href="#最简单方法"></a> 最简单方法</h2>
<p>重复每行每列n次</p>
<h2 id="图像插值"><a class="markdownIt-Anchor" href="#图像插值"></a> 图像插值</h2>
<img src="/视觉_img/3-1.png" style="zoom:80%">
### 重建滤波器
1. 目的是重建连续图像f
2. 步骤
	1. 将F转换成连续函数：
		f<sub>F</sub>(x)=F(x/d) 当x/d是整数，否则为0
	2. 用重建滤波器H来卷积
		f = h*f<sub>F</sub>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-视觉第2讲" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC2%E8%AE%B2/"
    >视觉第2讲</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC2%E8%AE%B2/" class="article-date">
  <time datetime="2020-03-30T03:17:13.862Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="边缘"><a class="markdownIt-Anchor" href="#边缘"></a> 边缘</h1>
<ol>
<li>
<p>来源：</p>
<ol>
<li>表面法线不连续</li>
<li>深度不连续</li>
<li>颜色不连续</li>
<li>光照不连续</li>
</ol>
</li>
<li>
<p>特征是图像强度函数中快速变化的地方：</p>
<ol>
<li>一阶导数的极值点</li>
<li>二阶导数为0的点</li>
</ol>
</li>
</ol>
<h2 id="图像导数求解"><a class="markdownIt-Anchor" href="#图像导数求解"></a> 图像导数求解</h2>
<img src="/视觉_img/1-6.png" style="zoom:1%">
<h2 id="图像梯度求解"><a class="markdownIt-Anchor" href="#图像梯度求解"></a> 图像梯度求解</h2>
<img src="/视觉_img/1-7.png" style="zoom:1%">
<ol>
<li>梯度点在强度增大最快的方向上</li>
<li>边缘方向与梯度方向垂直</li>
</ol>
<h2 id="去噪"><a class="markdownIt-Anchor" href="#去噪"></a> 去噪</h2>
<ol>
<li>
<p>问题</p>
 <img src="/视觉_img/1-8.png" style="zoom:1%">
</li>
<li>
<p>解决:先做平滑</p>
 <img src="/视觉_img/1-9.png" style="zoom:1%">
<ol>
<li>核一般不变，可以先求h的导数，以简化计算。</li>
</ol>
</li>
</ol>
<h1 id="边缘检测"><a class="markdownIt-Anchor" href="#边缘检测"></a> 边缘检测</h1>
<h2 id="高斯一阶导"><a class="markdownIt-Anchor" href="#高斯一阶导"></a> 高斯一阶导</h2>
<img src="/视觉_img/1-10.png" style="zoom:1%">
<h2 id="sobel算子"><a class="markdownIt-Anchor" href="#sobel算子"></a> Sobel算子</h2>
<img src="/视觉_img/1-11.png" style="zoom:1%">
<ol>
<li>是高斯导数的一般近似</li>
<li>标准定义中没有1/8，不会影响边缘检测</li>
<li>如果要得到正确的梯度值，1/8是必须的。</li>
</ol>
<h2 id="非最大抑制"><a class="markdownIt-Anchor" href="#非最大抑制"></a> 非最大抑制</h2>
<p>检测像素是否是梯度方向上的局部最大值，一般需要插值。</p>
<img src="/视觉_img/1-12.png" style="zoom:1%">
<h2 id="canny-边缘检测器"><a class="markdownIt-Anchor" href="#canny-边缘检测器"></a> Canny 边缘检测器</h2>
<p><strong>步骤</strong></p>
<ol>
<li>用高斯导数做滤波
<ol>
<li>大σ检测大尺度边缘</li>
<li>小σ检测细微边缘</li>
</ol>
</li>
<li>获得梯度的赋值和方向</li>
<li>非最大抑制</li>
<li>连接与滞后 阈值化（两个阈值）
<ol>
<li>高阈值寻找边缘曲线的起点</li>
<li>低阈值确定后继点</li>
</ol>
</li>
</ol>
<h1 id="尺度空间"><a class="markdownIt-Anchor" href="#尺度空间"></a> 尺度空间</h1>
<p><strong>性质</strong></p>
<ol>
<li>边缘位置随尺度(σ) 的增大而变化</li>
<li>随尺度增加，两条边缘有可能合并</li>
<li>随尺度增加，边缘不可能分成两个</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-区块链小论文" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B0%8F%E8%AE%BA%E6%96%87/"
    >区块链小论文</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B0%8F%E8%AE%BA%E6%96%87/" class="article-date">
  <time datetime="2020-03-30T03:09:41.423Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="摘-要"><a class="markdownIt-Anchor" href="#摘-要"></a> 摘    要</h1>
<p>区块链技术在电子加密货币、存证鉴伪、供应链溯源、选举投票、物联网等场景中有广泛应用。从最初的比特币，到后来代表区块链技术2.0的以太坊，再到现在的石墨烯技术上建立的去中心化应用，区块链技术在不断的完善着。本文将针对区块链技术及其发展，从数据结构、共识机制等角度探讨自己关于这几代区块链技术的认识和理解，最后再结合一个实例来讨论区块链3.0之后的去中心化应用及发展。</p>
<p>关键词：区块链；比特币； 数据结构； 共识机制；去中心化应用</p>
<h1 id="第1章-绪-论"><a class="markdownIt-Anchor" href="#第1章-绪-论"></a> 第1章  绪 论</h1>
<h2 id="11-区块链起源"><a class="markdownIt-Anchor" href="#11-区块链起源"></a> 1.1  区块链起源</h2>
<p>2008年中本聪综合前人在加密货币上的成果提出了比特币的概念，并于2009年1月3日挖出了创世区块，实现了数字世界的价值表示与价值转移，也引发了人们对其底层技术–区块链技术的探索。在比特币之前就有很多专家进行过加密货币的研究，并给出了自己方案，如亚当·贝克的哈希现金，哈尔·芬妮的比特黄金，戴伟的B-Money等。他们的方案存在着一个共同点，就是要通过计算机的计算来创造电子现金。在这种思想的基础上，中本聪融合前人观点，设计了基于工作量证明的共识机制，使得去中心化成为可能，最终解决了数字现金的问题。</p>
<h2 id="12-以太坊"><a class="markdownIt-Anchor" href="#12-以太坊"></a> 1.2  以太坊</h2>
<p>以太坊创始人维塔利克分析了比特币系统，在比特币系统的四点不足上建立以太坊。其目标是建立一个新的区块链，内设有成熟的图灵完备的语言，可以利用这种语言来编写代码，创建合约，实现任意的状态转换。</p>
<p>以太坊的突出贡献在于实现了智能合约，使区块链技术从数字货币向数字资产转变。对于由智能合约来控制的实体资产，引用萨博的例子来说明：&quot;例如，为了防止一部车被偷窃，除非确定拥有者完成正确的&quot;挑战响应协议&quot;，否则车是不会启动激活的。例如，如果车是贷款买的，当拥有者无法偿还贷款时，智能合约将会自动启动扣押令，并将车钥匙的控制权交给银行。一旦拥有者还清贷款，智能合约就移除扣押令。&quot;总而言之，以太坊的出现使得创造通证变得简单。随着物联网技术的发展，越来越多的机器需要通证，基于区块链技术，为机器设计专用的钱包和通证将成为未来物联网发展的又一可能。</p>
<h2 id="13-eos"><a class="markdownIt-Anchor" href="#13-eos"></a> 1.3  EOS</h2>
<p>在《区块链革命》中，商业思想家唐·塔普斯科特这样写道：&quot;区块链上运行的所有计算资源可以在整体上视为一台计算机。&quot;。仔细考虑使用一条区块链所需要的资源，包括带宽资源（相当于硬盘）、计算资源（相当于CPU）、        状态资源（相当于RAM），确实和一台计算机十分相似。以太坊曾把自己定位为一台&quot;全球分布式计算机&quot;，那么EOS就是建立在这台计算机上的软件系统，他代表了区块链应用的一种发展方向，即开发一条通用的基础公链，实现一切去中心化。通过相关资料，我发现EOS已经在许多方面大异于比特币和以太坊，比如他的共识机制、        区块产生方式，账户等，并且开创性的提出了基于角色的权限系统。目前来说，区块链技术想要落地应用还有很多问题没有解决，哪条路才是切实有效的也没有定论，未来等着我们去探索。</p>
<h2 id="14-结构安排"><a class="markdownIt-Anchor" href="#14-结构安排"></a> 1.4  结构安排</h2>
<p>本文共分为三大部分，首先从比特币说起，讲述我学习到的比特币系统，阐述其数据结构、共识机制，分析安全性等。之后，讨论代表区块链2.0的以太坊，由于他的共识机制基本与比特币相同，所以主要阐述了以太坊的三种主要的数据结构。第三部分，阐述了区块链应用的可能方向以及一款基于功能类公链的应用实例–Steemit。</p>
<h1 id="第2章-比特币系统的技术原理及安全分析"><a class="markdownIt-Anchor" href="#第2章-比特币系统的技术原理及安全分析"></a> 第2章 比特币系统的技术原理及安全分析</h1>
<p>在比特币系统中第一次给出了区块链技术的定义：&quot;区块链是数字世界中进行价值表示和价值转移的技术。&quot;而比特币作为区块链硬币，他的一面是表示价值的加密数字货币或通证，另一面是进行价值转移的分布式账本与去中心网络。本章将从分布式账本与去中心网络及数据结构的角度讨论比特币系统，并分析其安全性。</p>
<h2 id="21分布式账本与去中心网络"><a class="markdownIt-Anchor" href="#21分布式账本与去中心网络"></a> 2.1分布式账本与去中心网络</h2>
<p>威廉·穆贾雅在《商业区块链》中将比特币总结为四个要点分别是：点对点电子交易；不需要金融机构；加密证据而不是中心化信用；信用存在于网络，而不是某个中心机构。</p>
<p>现如今的数字世界中的货币有三种存在形式，包括中心化的在线支付，如微信、支付宝等；中心化互联网积分，如Q币等；去中心化的电子现金。在中心化的在线支付系统中流转的货币是各种法币的映射，这些映射来的&quot;数字货币&quot;本身没有价值，其价值依赖于法币本身的购买力。同样中心化的互联网积分，其价值不与任何法币想关联，        完全由发行公司决定，且只能用于购买这家公司的服务和产品。对于比特币系统的去中心网络比特币的价值由其算法保证，即使整体的算力出现波动，算法也能在至多2016个区块后通过调整目标阈值来调整挖矿难度，从而使得比特币系统的平均出块间隔维持在10分钟左右，以此保证了比特币系统内部比特币的价值稳定（与法币的汇率不是由比特币系统决定的）。比特币的以上优点很大程度上是得益于其分布式账本和去中心网络。</p>
<p>比特币的去中心网络由由众多轻节点和全结点组成，其中全节点包含所有比特币区块链的区块数据，轻节点仅包含自己相关的数据。并且比特币网络是开放的，任何服务器都可以加入成为全结点，共同维护这个去中心网络。由于网络没有一个类似于&quot;央行&quot;的中心化组织存储信息，所以所有用户持有的比特币信息都存在一个分布式账本中，可以认为同时存储在所有全结点中。</p>
<h2 id="22比特币系统的加密体制"><a class="markdownIt-Anchor" href="#22比特币系统的加密体制"></a> 2.2比特币系统的加密体制</h2>
<p>比特币与密码学是密不可分的，从比特币&quot;账户&quot;（实际是地址）产生就使用了非对称密码体制，到每次交易签名，再到区块链内部的梅克尔树，以及区块链间的哈希指针都反应了密码学原理。</p>
<p>首先，在生成一个比特币账户时，实际上我们得到的一对公私钥对，其中公钥的哈希值即为比特币地址，作为转账交易的收付款地址；而私钥用于对我支付的每一笔交易进行签名。当我发起一笔交易时，我将用我的私钥对这笔交易记录进行签名， 同时广播出我的公钥以便其他的节点能够验证这笔交易的合法性，同时我还要为这笔交易付一点&quot;小费&quot;。这样操作下来，再等上一段时间，我的交易就会被写入区块链中成为不可逆的交易。</p>
<p>比特币系统使用的哈希函数是 SHA-256。除了哈希函数本身的抗碰撞性和单向性外，应用于比特币系统的哈希值还有puzzle friendly的性质，即要求块头的哈希值小于某个目标阈值。以及难于计算，但易于验证的性质。这些性质一方面保证了区块链上数据的不可篡改性，另一方面也为各个节点达成共识提供了基础保障。</p>
<p>此外，这种密码体制的安全性还建立在一个好的随机源上，这样才能确保有足够大的搜索空间来保证安全性。</p>
<h2 id="23比特币区块链的数据结构"><a class="markdownIt-Anchor" href="#23比特币区块链的数据结构"></a> 2.3比特币区块链的数据结构</h2>
<p>比特币区块链是一条通过哈希指针连接起来的链表。后一的区块的哈希指针是通过前一区块的全部内容(包括前一区块的哈希指针)计算出来的。这样从最后一个区块就能知道前面的区块是否被修改，使得系统中的某些节点不需要保存全部区块信息。</p>
<p>每个区块中的数据是被打包进这个区块的一系列交易，这些交易按规则形成一颗梅克尔树。梅克尔树是一颗由哈希指针连接起来的哈希树，其中叶子节点是要打包进区块的交易信息，非叶子节点是由叶子节点计算而来的哈希值。这样设计有很多好处，比如一个轻节点如果想知道自己的交易(位于第n层)是否已经被打包进区块链中，那么他只需要向全节点请求他不在的那条路径上非叶子节点的哈希值。之后，它就可以先计算要验证交易的哈希值（这一定是已知的），再将这个哈希与全节点给出的第（n-1）层的哈希值共同计算(n-2)层的哈希值，如此迭代下去，最终可以求得这笔交易所在的梅克尔树的根哈希值。将这个根哈希值与全节点给出的根哈希值比较即可验证交易。这样设计使得更多的节点能够低门槛的连入比特币系统，增加了比特币系统的活跃程度。</p>
<p>此外，区块头部中也包含着很多的重要信息，比如比特币版本协议信息，指向前一个区块的指针，梅克尔树的根哈希值，挖矿的难度目标阈值，随机数等。这些信息对于比特币系统达成共识有着至关重要的作用。</p>
<h2 id="24比特币系统的共识机制"><a class="markdownIt-Anchor" href="#24比特币系统的共识机制"></a> 2.4比特币系统的共识机制</h2>
<p>所谓共识机制，指的是众多互不相识、互不信任的节点之间就交易的合法性达成一致意见。这对于比特币这样一个去中心化的网络十分重要，只有确保了共识机制，才能保证不同账本节点上数据的一致性和正确性。</p>
<p>比特币系统所采用的策略是工作量证明。简单来说就是通过求解一个随机数来使得块头的哈希值小于一个给定的目标阈值，这个过程也称为挖矿。从概率学的角度来说，每次实验都可以看作是一次伯努利实验。当试验次数很多，而成功概率很小的时候，我们就可以用泊松分布来近似。也就是说，在比特币系统中，想要得到记账权没有任何捷径可走，只能单纯的通过反复尝试不同的随机数来求解。这也就保证了每个挖出区块的节点都是做了大量的工作来维护这条区块链，从而保证了区块链上数据的一致性。</p>
<p>比特币系统在共识机制做出了两点创新。其一是引入了奖励机制，通过比特币奖励使得区块链上节点愿意打包交易，主动维护账本，加快了一致性的达成。其二是引入了随机性的概念，尽管比特币系统不是完全可靠的，但是一般来说经过6个区块后，出问题的概率会呈指数级下降。</p>
<p>实际上，共识机制的形成过程是一个投票过程，只不过比特币系统是通过算力进行投票。拥有较大算力的节点能够优先把自己认为合法的交易打包进区块中，即通过算力给这些交易投票。</p>
<h2 id="25-比特币系统的安全分析"><a class="markdownIt-Anchor" href="#25-比特币系统的安全分析"></a> 2.5 比特币系统的安全分析</h2>
<p>首先通过一个例子来简单的说一下比特币的转账过程。假设现在甲要向乙进行转账，那么甲会发起一个转账交易，并用自己的私钥进行签名，同时将收款人的姓名写为乙的地址，并发布出去。听到这个交易的节点，首先验证nbits域的设置是否符合难度要求；验证头的哈希是否小于等于目标阈值。然后验证body中的交易是否有甲的合法签名，这笔钱以前是否被花过。第三要验证这个区块是否是连在最长合法链上。假设这个区块已经被打包进了区块链中，那么沿着这个区块继续挖的区块也会来验证这笔交易。一般来说，经过6个区块后这笔交易就可以认为是这笔交易不可篡改。针对比特币的转账过程，我探究了以下几种安全问题。</p>
<h3 id="251-伪造转账交易"><a class="markdownIt-Anchor" href="#251-伪造转账交易"></a> 2.5.1 伪造转账交易</h3>
<p>首先，考虑攻击者能否转走别人账户上的比特币。这是不可能的。第一，因为比特币系统中合法交易需要交易发起方用自己的私钥进行签名，而私钥无法伪造，所以不能成功。第二，如果恶意节点强行将交易写入区块中，那么诚实的节点也不会认可这笔交易，同时攻击者也损失了一笔出块奖励，同样说明这种攻击难以实现。</p>
<p>一般情况下，发起交易的一方要广播自己公钥来让其他节点可以验证自己的签名合法性。假设现在有一个攻击者想要转走A账户上的比特币，那么他先伪造一笔A转出的转账交易，并用自己的私钥进行签名，同时广播自己的公钥说成是A的公钥。这样能否转走A账户上的比特币呢？也是不可能的，因为A账户上的比特币一定来自之前的某一笔交易，而之前交易的收款人地址正是A的公钥的哈希。由于攻击者的公钥哈希与这个收款地址哈希对不上，其他节点就不把他作为合法交易，也不会写进区块链中。</p>
<h3 id="252回滚交易数据"><a class="markdownIt-Anchor" href="#252回滚交易数据"></a> 2.5.2回滚交易数据</h3>
<p>假设现在A要向B转账5个比特币，A签名了这个交易并发布到网络上，表面看起来B已经得到这笔交易的输出。但是如果攻击者立即发布一笔交易将这5个比特币转给自己，由于两笔交易都有A的合法签名，所以两者都会被作为合法交易打包进区块链中。同时如果攻击者具有足够多的算力将回滚交易所在的链拓展成最长链，那么交易就会被回滚。这种通过向区块链中间插入某个区块来回滚某个已经发生的交易，又称为分叉攻击。防范这种攻击的简单方式是等待六个区块的确认，这样拓展回滚交易所在的链的难度就会大大增加。</p>
<p>分叉的原因有很多，实际上，即使完全正常运作的比特币系统中也会存在分叉。可能有两个节点几乎同时挖出了新的区块，并把它广播出去。由于网络延迟和节点间距离的差异最终导致不同的节点收到了不同的合法区块。按照比特币协议，一个节点只会接受第一个收到的合法区块，所以最终会导致区块链出现分叉。但这种分叉只是暂时的，随着时间的推移，两条分叉上的算力互相竞争，最终会以一方称为绝对的最长合法链而告终。</p>
<h3 id="253掌控最长合法链"><a class="markdownIt-Anchor" href="#253掌控最长合法链"></a> 2.5.3掌控最长合法链</h3>
<p>我们知道，新的区块的内容中包含前一区块的哈希值。也就是说，在正常情况下没有前一个区块就不能产生新的区块。并且比特币系统中，合法的区块应该是位于最长合法链上。现在如果有一个恶意节点想要掌握最长合法链，当他挖出一个区块后，先不广播，而是在这个区块的基础上接着挖下一个。直到自己手里这条链变成绝对的最长合法链再一起发布出去，从而使得其中的非法交易合法化。这种攻击很难奏效，因为比特币系统是基于算力进行投票的，所以攻击者想要将自己的链变成最长合法链有很大难度。</p>
<p>挖出区块而不广播的理由可能还包括盈利目的。假设某个节点挖出了第n+1个区块，但是不立即广播，然后接着这个区块继续挖第n+2块。当有其他节点挖出第n+1块时，他立即广播第n+1和n+2块。那么由他记账的区块链就变成了最长合法链，同时得到这两个区块的出块奖励，看起来就像是一步领先，步步领先。</p>
<p>但实际上，在比特币系统中，这种行为很难成功。这样做的成功前提是在别的节点挖出一个区块的时间里，他能保证挖出两个以上区块。这样做存在很大风险，有可能一个出块奖励也得不到。</p>
<h3 id="254比特币的匿名性"><a class="markdownIt-Anchor" href="#254比特币的匿名性"></a> 2.5.4比特币的匿名性</h3>
<p>比特币系统的匿名性是很难以维护的，因为区块链是公开的，并且区块链具有不可修改性。一旦有一次交易暴露了身份，那么这个影响将是永久性的。并且比特币作为一种虚拟货币，最终会和法币相关联，一旦与实体世界发生关系，那么就可能在用比特币支付和进行资金转入转出时发生隐私的泄漏。如果先不考虑与实体世界的联系，我们可以每次转账交易都生成一个新的地址，采用多路径转发的方式，使得从交易推理出身份的难度增大，从而加强匿名性。此外，市面上还出现了牺牲性能而增强匿名性的货币，如零币零钞等基于零知识证明的加密货币。但是由于普通用户对匿名性的要求并不高，所以并未被广泛使用。</p>
<h2 id="26-总结"><a class="markdownIt-Anchor" href="#26-总结"></a> 2.6 总结</h2>
<p>以上就是我对一些感兴趣的攻击比特币系统的手段分析。上述分析基础是比特币网络中大部分节点都是诚实的，恶意节点只是少数，不会占据51%以上的算力。然而近些年出现的矿场使得算力更加聚集，历史上就曾经出现过大型矿场占据51%以上的算力的情况(他们为了防止引起恐慌，自行分解了算力)。这说明比特币系统的安全性是相对的，想要持久的维护比特币系统的安全性就要维持比特币社区的活跃度，使得诚实的节点永远占据大多数。</p>
<h1 id="第3章-以太坊"><a class="markdownIt-Anchor" href="#第3章-以太坊"></a> 第3章 以太坊</h1>
<p>维塔利克在分析了比特币系统的缺陷的基础上提出了以太坊。目标是提供一个区块链，内置有成熟的图灵完备的编程语言，用这种语言可以创建合约来编码，实现任意状态转换功能。通过这种语言，按照ERC标准，我们可以编写出自己的智能合约，进行区块链上的状态转换，进行链上数字资产的转移。其开创性的智能合约使得区块链技术从数字现金向数字资产转移，为日后的应用奠定了基础。接下来的一部分主要描述一些关于以太坊的数据结构。</p>
<h2 id="31以太坊的数据结构"><a class="markdownIt-Anchor" href="#31以太坊的数据结构"></a> 3.1以太坊的数据结构</h2>
<p>首先，以太坊区别于比特币系统，设置了账户系统。在比特币系统中，每次交易都会把余额转到另一个零钱地址中。而以太坊中为了支持智能合约，就需要参与方有相对稳定的身份，所以改用账户系统，每次交易直接增删余额。以太坊被看作是由交易驱动的状态机，所以在以太坊中要保存状态和交易。因此，以太坊设置了三种树，分别是状态树，交易树，和收据树。</p>
<h3 id="331状态树-交易树-收据树"><a class="markdownIt-Anchor" href="#331状态树-交易树-收据树"></a> 3.3.1状态树、交易树、收据树</h3>
<p>建立状态树的目的是要建立一个从账户到状态的映射。其中以太坊账户为40位十六进制数，状态中包括余额，交易次数，如果是合约账户还包括代码和存储的变量。同时，要求这颗树上的数据不可篡改，便于查找，增加，删除，同时节省存储空间。此外，应该令轻节点易于验证某个键值对是否存在。于是以太坊在传统的Trie树的基础上，压缩路径，增加哈希指针得到了Modified Merkle Partricia Tree。</p>
<p>首先说Trie树，它常被用来存储单词，进行多模式串的模式匹配。在以太坊中，由于账户是由40位十六进制数构成，所以每个节点的分支最多有17种可能（加一个结束标志）。Trie树的优点是无需排序，即使插入顺序不一样，得到的结构也是一样的；同时它还具有很好的更新局部性，由于每个区块中涉及发生的交易是少数的，采用这种结构不需要去管其他的分支，增强了修改的性能。</p>
<p>Trie树的缺点也很明显，它有很大的存储浪费，并且实际的查找效率与树的深度有关。于是进一步的考虑Partricia tree，一种路径压缩的trie树。对于基数树的每个节点，如果该节点是唯一的儿子的话，就和父节点合并。当键值分布较为稀疏的时候，更新时需要打开压缩部分的概率就比较低，性能也就更好。而以太坊的地址就恰好是这种结构。</p>
<p>借鉴比特币系统的思想，将树中指针全部换成哈希指针得到了Merkle Partricia Tree(MPT)树。而以太坊系统中使用的是略作修改的MPT树，本质上没有改变。</p>
<p>以太坊的结构是一颗大的MPT树中包含很多小的MPT树，每个小的MPT就是一个合约账户。对于全节点来说，他维护的也不是一颗MPT，而是每产生一个新的区块就新建一颗MPT，这些树中大部分节点是共享的，只有少数更新的节点可能要新建分支。</p>
<p>我通过与比特币系统的对比，发现比特币系统中不需要保存历史状态，而是通过UTXO的输入输出计算得来。但是以太坊不同，由于账户的设计，智能合约的出现，每个交易被打包进区块链的时候，其账户余额也被改变。这样设计的优点是天然的防范了双花攻击。但是如果某个交易所在区块不在最长合法链上，为了保持账户余额和合法链上得到的交易的结果是一致的，就需要对分叉部分进行回滚。我认为这就是需要保存历史状态的原因。</p>
<p>至于交易树和收据树，他们本身也是一颗MPT树。每个交易执行完，会形成一颗收据树，记录这个交易的相关信息。交易树和收据树上的节点是一一对应的。但每个区块的交易树和收据树又是相互独立的。他们发布的交易本身也被认为是相互独立的。</p>
<h3 id="332bloom-filter"><a class="markdownIt-Anchor" href="#332bloom-filter"></a> 3.3.2bloom filter</h3>
<p>以太坊为了支持一些复杂的查询的查询操作，比如查询近十天里和某个智能合约相关的交易而设计了这个数据结构。对于这个问题，可能最开始的想法就是遍历这个链将符合规则的区块挑出来，但是对于轻节点来说，他不能保存所有区块的信息，同时也存在查找效率低下的问题。</p>
<p>而bloom filter结构可以理解为一个大的向量，称为摘要。是将每个元素取一个哈希，形成的一个向量，其中某位为1代表对应该哈希值的元素存在。假如现在要查找过去十天发生的和某个智能合约相关的交易。首先，查找区块块头的bloom filter，看看哪个块头的bloom fikter里有我要的交易类型。如果某个块头里有，再去相应的收据树的bloom filter中查找。每一步轻节点都可以向全节点请求少量的信息就可以查询下去，很好的解决了问题。即使考虑哈希碰撞，那么也只会出现误报，而不会出现漏报。而误报情况可以在逐渐细化的查询中被发现。</p>
<h3 id="333cache与dag"><a class="markdownIt-Anchor" href="#333cache与dag"></a> 3.3.3cache与DAG</h3>
<p>比特币的挖矿设备从最初的CPU，转向GPU，再到现在的ASIC芯片挖矿，设备趋向于专业化，挖矿门槛越来越高。这样不利于比特币系统的安全稳定，只有当算力足够分散的时候，发动51%以上算力的攻击才很困难。为了做到杜绝ASIC芯片，以太坊在莱特币的基础上改进了挖矿算法，使得求解从纯粹的算力竞争上转向内存竞争。</p>
<p>莱特币曾经是市值仅次于比特币的一种加密货币。他首先将内存引入了挖矿算法。他基于Scrypt加密算法，需要用大的内存来保存这个数组，否则每次都要重新计算。简单来说，Scrypt算法是先通过一个种子取哈希得到数组中的第一个元素，之后再将这个元素取哈希得到第二个，反复迭代得到后面的元素。但是对于轻节点来说，他只是想验证某个区块的合法性，却需要和矿工等量的计算。这与区块链的基本理念:难于计算，易于验证相悖。考虑到这个原因，莱特币只将这个数组设置为128K，这显然太小了，对于矿机来说，完全可以通过计算来弥补内存的薄弱。</p>
<p>以太坊在莱特币的基础上进行了改进。他规定了两个数据集，16M的cache和1G的DAG，其中DAG是通过cache计算得来。轻节点只需要保存cache即可验证区块，矿工通过DAG来计算随机数使最后的哈希值低于目标阈值。</p>
<p>Cache的形成与莱特币类似，也是从一个种子节点开始依次取哈希来填充数组。对于DAG，他首先从cache里随机读一个数，然后进行哈希计算，得到下一个要读取的数的位置。然后用cache中这个位置的数和当前的哈希值再计算出一个哈希。反复迭代256次，将最终得到的数填充到DAG的第一个位置。</p>
<p>对于矿工来说，在挖矿的时候，先根据块头和nonce值计算一个哈希，这个哈希映射到数组中的某一个位置。通过这个位置和其相邻位置的元素进行运算得到下一个要计算哈希的位置。反复迭代64次，最后得到的哈希值与目标阈值比较，看一下是否满足要求，不成功则换下一个nonce尝试。</p>
<p>对于轻节点，想要验证一个区块是否符合要求，他需要这个区块的nonce以及cache数组。验证的过程与挖矿类似，只是轻节点没有保存DAG中的元素，所以用到的部分需要从cache中重新计算生成。</p>
<h2 id="32智能合约"><a class="markdownIt-Anchor" href="#32智能合约"></a> 3.2智能合约</h2>
<p>关于智能合约，其智能可以理解为是一段自动执行的代码，无需外界干预，自动自治进行，运行在以太坊虚拟机中；合约可以看作一个管家，一个&quot;自治代理&quot;，它拥有自己的账户，交易发生时自动执行一段代码。借用V神的话就是&quot;他们收到交易信息后就相当于被捅了一下，然后自动执行一段代码&quot;。</p>
<p>如果说区块链存储的是状态，那么智能合约就是用于状态转换的方式。它像是一个特别的时钟，把世界从同步转向异步。</p>
<p>智能合约的出现使得创建通证变得简单。Komhar公司曾给出过ERC20通证发行过程，大体可以表述为：一个项目通过智能合约创建通证，这个通证是实体资产或线上资产的价值表示物。投资者（用户）发起交易，向智能合约转入以太币（ETH），智能合约自动运转，在满足一定规则后，它向投资者账户转入相应数量的通证。这里的通证大多对应以太坊区块链之外的资产。因此，以太坊的出现对区块链技术转向数字资产做出了巨大贡献。</p>
<h2 id="33以太坊共识机制与ghost协议"><a class="markdownIt-Anchor" href="#33以太坊共识机制与ghost协议"></a> 3.3以太坊共识机制与GHOST协议</h2>
<p>在比特币系统中，只有在最长合法链上挖出来的区块才有出块奖励。这使得挖出分叉的节点不甘心放弃自己链，对于大的矿池来说，他很有可能不顾一切的去挖自己的链使他成为最长链。这样做的优点是便于确认区块的合法性，也在一定程度上避免了双花。但是对于以太坊来说，这样做并不合适。以太坊设有账户系统，可以杜绝双花，而且以太坊的平均出块时间设定为15秒，分叉也会成为常态。因此，以太坊引入了GHOST协议，目的是在出现分叉后及时合并。</p>
<p>GHOST协议的核心思想是对没有竞争成为最长合法链的区块也发放一定的出块奖励。同时下一&quot;代&quot;区块要包含所有的叔父区块，并得到1/32个出块奖励的额外报酬。为了防止在挖矿难度较低的时候产生叔父而不当获利，以太坊规定叔父必须是7代以内。并且叔父区块中的交易不执行，因此也不检查交易合法性，只检查这个区块是否符合挖矿难度。</p>
<p>GHOST协议一方面保证了分叉及时被合并，另一方面也减少了ASIC矿机挖矿的必要性，有利于维持分布式账本和区中心化的稳定。在回避ASIC的问题的问题上，以太坊另一个做法是每年都宣称自己即将从工作量证明转为权益证明，从而有效的将以太坊挖矿限制在GPU挖矿的级别。</p>
<h1 id="第四章-区块链的应用与steemit博客"><a class="markdownIt-Anchor" href="#第四章-区块链的应用与steemit博客"></a> 第四章 区块链的应用与Steemit博客</h1>
<h2 id="41-区块链的性质"><a class="markdownIt-Anchor" href="#41-区块链的性质"></a> 4.1 区块链的性质</h2>
<p>想要将区块链投入应用，首先要明确区块链有什么用。有人总结区块链的性质总结为以下四条。</p>
<ol>
<li>
<p>第一，是不可篡改性。要修改一个区块中的数据，那么就要修改后面所有的所有区块。而共识机制的存在使得修改大量区块的成本极高，因此篡改几乎不可能实现。2018 年3 月，在网络零售集团京东发布的《区块链技术实践白皮书》中，京东认为，&quot;区块链技术（分布式账本）的三种应用场景是：跨主体协作，需要低成本信任，存在长周期交易链条。这三个应用场景所利用的都是区块链的不可篡改特性。多主体在一个不可篡改的账本上协作，降低了信任成本。区块链账本中存储的是状态，未被涉及的数据的状态不会发生变化，且越早前的数据越难被篡改，这使得它适用于长周期交易。&quot;</p>
</li>
<li>
<p>第二，是表示价值所需要的唯一性。比特币的出现使得数字世界中出现了一种不可复制的&quot;文件&quot;。腾讯CEO马化腾说&quot;区块链确实是一项具有创新性的技术，用数字化表达唯一性，区块链可以模拟现实中的实物唯一性。&quot;百度CEO 李彦宏说：&quot;区块链到来之后，可以真正使虚拟物品变得唯一，这样的互联网跟以前的互联网会是非常不一样的。&quot;</p>
</li>
<li>
<p>第三，是智能合约。智能合约的出现使区块链上可以进行更加复杂的交易，并且交易本身也不可篡改。在以太坊白皮书中，维塔利克写道：&quot;（合约）应被看成存在于以太坊执行环境中的&quot;自治代理&quot;，它拥有自己的以太坊账户，收到交易信息，它们就相当于被捅了一下，然后它就自动执行一段代码。&quot;</p>
</li>
<li>
<p>第四，是去中心自组织。在《去中心化应用》一书中，作者西拉杰·拉瓦尔（Siraj Raval）从两个维度看现有的互联网技术产品：一个维度是，在组织上是中心化的，还是去中心化的；另一个维度是，在逻辑上是中心化的，还是去中心化的。在他看来比特币在组织上是去中心化的，在逻辑上是集中的。</p>
</li>
</ol>
<p>根据这些性质，有人总结了五条区块链通向应用平台的可能路径。分别是通用类基础公链，功能类基础公链，行业类基础公链，联盟类基础公链，基础服务。在我看来，开发专用于某个功能的基础公链更可行，接下来通过Steemit来谈一谈区块链的应用。</p>
<h2 id="42-steemit"><a class="markdownIt-Anchor" href="#42-steemit"></a> 4.2 Steemit</h2>
<p>Steemit是基于steem公链平台的社交软件，类似于博客。可以通过发文章，写评论来赚钱，但没人直接付钱。这个平台促进内容生产者发布更加优质的内容，同时屏蔽掉劣质内容。</p>
<p>Steem链中有三种代币，分别是steem，steem power,steem dollar。其中，Steem币是Steem链的基础代币。Steem Power 相当于股权，只能持有不能买卖。Steem Dollar是公链中稳定代币，无论何时，SBD只能兑换成价值一美元的Steem币，维持内部代币价格稳定。</p>
<p>当作者发布一篇文章时，并不马上得到收益。其收益真正来源于持有SP用户的点赞，这点类似于EOS的权益证明。拥有SP越多的用户点赞带来的收益也越多，同时点赞用户也会得到一部分收益，类似于矿工打包交易时的得到的手续费。此外，SP用户还可点踩，当点踩的人足够多时，Steemit会隐藏这些内容。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>总的来说，区块链很有可能成为互联网上的新层次，专门用于进行价值表示和价值转移。 在其上可以建立区块链应用，以利用区块链的价值表示和价值转移特性，在链上进行数字资产的转移。同时这些数字资产被映射成链上原生资产，线上资产或线下资产，从而改变目前人类的生成生活方式，影响金融、军事、教育乃至生活的方方面面。</p>
<p>通过本次大作业的机会，我充分学习了关于区块链的内容。区块链的诸多性质中，去中心化的性质尤其吸引我。在中心化的网络中，我们的数据是不安全的，每天倡导安全的组织却能轻易掌握我们的数据；我们的思想可能是被蓄意引导的；努力工作得到的货币也未必是保值的；同时，离开中心我们也是生存不下去的。也许去中心化的系统中存在着混乱，比如区块链中的分叉，但是我认为混乱也是一种自治，或许目前的去中心化的结构还不完善，性能还不够强大，但我相信在不远的将来，我们就可以在生活的方方面面感受到去中心后的便利。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-区块链" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%8C%BA%E5%9D%97%E9%93%BE/"
    >区块链</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%8C%BA%E5%9D%97%E9%93%BE/" class="article-date">
  <time datetime="2020-03-30T03:00:53.094Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="比特币的诞生"><a class="markdownIt-Anchor" href="#比特币的诞生"></a> 比特币的诞生</h1>
<ol>
<li>
<p>比特币目的是在数字世界，创造一个具有现金特性的事物</p>
</li>
<li>
<p>比特币组成成分</p>
<p>1）加密数字货币</p>
<p>2）分布式账本</p>
<ol start="3">
<li>去中心网络</li>
</ol>
</li>
<li>
<p>目前的电子现金系统：依靠中心化数据库和可信的第三方中介来避免双花问题</p>
</li>
<li>
<p>比特币同时做到了去中介化和去中心化</p>
<p>1） 个人与个人之间的电子现金无需可信第三方中介的介入，这是去中介化</p>
<p>2）这个电子现金的货币发行也不需要一个中心化的机构，而是由代码与社区共识完成，这是去中心化</p>
</li>
<li>
<p>比特币系统三层结构</p>
<p>1）最上一层是比特币这种电子现金。是整个系统的应用层</p>
<p>2）中间一层的功能是发行比特币与处理用户见的比特币转移。这一层也叫比特币协议，是整个系统的应用协议层。（相当于中央银行（发行货币）与银行（处理转账）等金融机构间的关系）</p>
<p>3）最底层是比特币的分布式账本和去中心化网络。这一层也被称为比特币区块链，是整个系统的通用协议层。</p>
</li>
</ol>
<h1 id="区块链"><a class="markdownIt-Anchor" href="#区块链"></a> 区块链</h1>
<ol>
<li>定义：区块链是数字世界中进行价值表示和价值转移的技术。区块链硬币一面是表示价值的加密数字货币或通证，另一面是进行价值转移的分布式账本与去中心网络。</li>
<li>通证：基于区块链的价值表示无都称为通证。</li>
</ol>
<h1 id="加密数字货币前传"><a class="markdownIt-Anchor" href="#加密数字货币前传"></a> 加密数字货币前传</h1>
<ol>
<li>大卫·乔姆：
<ol>
<li>盲签：在一张纸条上， 你选择一个只有你知道的序列号，然后我在上面签名。由于我不知道这个序列号，所以我没法再复制一份这张纸条给另一个人。</li>
<li>这个方案的缺点是：必须有一个所有参与者都薪人的中心化服务器来进行这些“数字纸条”的验证。</li>
</ol>
</li>
<li>尼克·萨博
<ol>
<li>提出智能合约。智能合约是区块链处理交易的核心方式，区块链应用的实质可被看成是一个个智能合约的组合。</li>
</ol>
</li>
<li>哈尔·芬妮
<ol>
<li>著名的PGP加密中的&quot;G&quot;</li>
</ol>
</li>
<li>中本聪
<ol>
<li>首次建立了一个去中心化，非基于信任的系统。</li>
<li>它通过已有的公钥加密方式来管理所有权，并用一个名为工作量证明的共识算法来记录谁拥有货币。</li>
</ol>
</li>
</ol>
<h1 id="中心化"><a class="markdownIt-Anchor" href="#中心化"></a> 中心化</h1>
<h2 id="数字世界中的货币有三种形式"><a class="markdownIt-Anchor" href="#数字世界中的货币有三种形式"></a> 数字世界中的货币有三种形式</h2>
<ol>
<li>中心化的在线支付：
<ol>
<li>在这些支付系统中流转的是映射到数字世界的各国法定货币（也乘法币）</li>
<li>法定货币的价值来自拥有者相信货币将来能维持其购买力，本身并无内在价值。</li>
</ol>
</li>
<li>中心化的计算机点数或互联网积分
<ol>
<li>不与物理世界的法币对应，而是由商业公司中心化发行，仅可以在一家公司的体系中使用，称为虚拟货币。如Q币</li>
</ol>
</li>
<li>去中心化的电子现金：比特币</li>
</ol>
<h2 id="比特币实现了极致的去中心化"><a class="markdownIt-Anchor" href="#比特币实现了极致的去中心化"></a> 比特币实现了极致的去中心化</h2>
<ol>
<li>威廉·穆贾雅在《商业区块链》一书中对比特币白皮书摘要进行了分析，他总结了四个要点：
<ol>
<li>点对点电子交易；</li>
<li>不需要金融机构；</li>
<li>加密证据而不是中心化的信用；</li>
<li>信用存在于网络，而不是某个中心机构。</li>
</ol>
</li>
<li>在《去中心化应用》一书中，开发者西拉杰·拉瓦尔对去中心化应用的去中心化程度进行了一番讨论。他认为，区块链可能在四个过去集中化的方面完成去中心化： 数据；财富；身份；计算。</li>
</ol>
<h2 id="比特币系统设计的五个要点"><a class="markdownIt-Anchor" href="#比特币系统设计的五个要点"></a> 比特币系统设计的五个要点：</h2>
<p>比特币的区块链系统是由分布式账本（即狭义的区块链）和去中心网络（点对点网络）组成的，形成链条的方式是工作量证明共识机制。最长链是由网络中的算力共同决定的，因而它是可信的，节点离开和加入依据的是最长链是可信的这一原则。这些组合起来形成了比特币系统。</p>
<ol>
<li>
<p>去中心化的点对点电子现金</p>
</li>
<li>
<p>分布式账本</p>
<p>比特币的区块链是基于工作量证明形成的带时间戳、存储数据的数据块和由哈希指针连接成的链条。</p>
<p>这个链条或者说账本以分布式的方式存储在比特币网络的各个节点上，因而也被称为分布式账本。</p>
</li>
<li>
<p>工作量证明</p>
</li>
<li>
<p>最长链原则</p>
</li>
<li>
<p>去中心网络</p>
</li>
</ol>
<h1 id="比特币是如何转账的"><a class="markdownIt-Anchor" href="#比特币是如何转账的"></a> 比特币是如何转账的</h1>
<h2 id="分布式账本和去中心网络"><a class="markdownIt-Anchor" href="#分布式账本和去中心网络"></a> 分布式账本和去中心网络</h2>
<ol>
<li>比特币网络由众多轻节点和全结点组成，这些结点形成一个去中心网络，其中：
<ol>
<li>全节点包含所有比特币区块链的区块数据</li>
<li>轻节点仅包含自己相关的数据。</li>
<li>比特币网络是开放的，任何服务器都可以加入成为全结点</li>
</ol>
</li>
<li>分布式账本：所有用户持有的比特币信息都存在一个分布式账本中；比特币账本可被认为同时存储在所有全结点中。</li>
<li>中心化在线支付系统的交易流程：交易双方通过中心化的交易平台中开设的账户完成交易。中心化在线支付系统维护一个中心化的账本，用户在账本上开设账户，通过密码(私钥)来与之交互。</li>
<li>比特币系统的交易过程：
<ol>
<li>
<p>每个人在比特币区块链上建立账户(地址)，获得一对公钥和私钥，地址是公钥的哈希值，我们通过私钥与地址进行交互。</p>
</li>
<li>
<p>每个人有一个钱包，钱包中装的是私钥，转账时，可以通过各自的钱包软件直接进行。</p>
</li>
<li>
<p>对比而言，对于中心化在线支付系统，它通常是由中心化的服务器来管理集中式账本。对于比特币系统，它背后的系统是一个去中心网络，网络节点共同维护一个分布式账本。</p>
<p> 比特币是记录在账本中的，看起来还是有一个“中心”？</p>
<p> 其实，这个账本是分布式地存储在去中心网络中的，因而从这个层面看，它可以看成是去中心化的。</p>
</li>
</ol>
</li>
</ol>
<h2 id="utxo未使用的交易输出"><a class="markdownIt-Anchor" href="#utxo未使用的交易输出"></a> UTXO:未使用的交易输出</h2>
<ol>
<li>比特币系统中的账户：没有账户，只有地址(是公钥的哈希值)。如果愿意可以开始无限多的钱包地址，但是系统不会汇总形成账户。</li>
<li>所以转账是从我的一个钱包地址转到你的一个钱包地址。</li>
<li>UTXO
<ol>
<li>通证经济专家孟岩曾撰写一篇文章，标题是“其实没有什么比特币，只有UTXO”，这个标题指出了，对于计算机来说比特币是什么——比特币是区块链账本上的交易输出。</li>
<li>例子：假
<ol>
<li>如我有8比特币，说明之前有一个交易把这些比特币转入我的地址，这个交易的输出未被使用，我拥有了8个比特币。</li>
<li>现在我发起一个转账交易，这个交易的输入是我拥有的这些比特币的上一个交易。我转账给你，假设对我拥有的这8毕业比的上一个交易进行签名，把这一新转账交易的输出地址设为你的钱包地址。</li>
<li>这样，这8比特币就属于你了，你拥有的是我这个交易的未使用的交易输出。等矿工把这一交易打包进新的区块，转账交易完成。</li>
<li>交易中涉及比特币的公钥和私钥的非对称加密机制。钱包地址理解为房间号和锁，私钥则相当于钥匙，钥匙可以打开对应的锁。</li>
<li>对于每一笔比特币的源头，都有一种特殊的交易–创币交易。对于矿工赢得25比特币的创币交易，它的输入是0，而输出是25个比特币进到矿工的钱包地址中。</li>
</ol>
</li>
<li>UTXO的优点（相比于账户）
<ol>
<li>
<p>UTXO设计易于确认比特币的所有权。</p>
<p>想要转账，只需要确认上一个交易时真实的，我就的确拥有这些比特币。而一个区块经过6次确认，其中的交易可被认为是真实无误的。</p>
</li>
<li>
<p>UTXO设计与区块链账本是完全融为一体的</p>
<p>区块链账本存储的是状态。区块链中的交易都是一种状态转换函数。每一个新区快和它之前的所有区块一起形成了一个新的状态。在确认之后，之前的状态就不可篡改。</p>
</li>
</ol>
</li>
<li>深入理解UXTO
<ol>
<li>比特币就是UTXO
<ol>
<li>当甲要把一笔比特币转给乙时，这个过程是把甲的钱包地址中之前的一个UTXO，用私钥进行签名，发送给乙的地址，这个过程就是一个新的交易，而乙得到的是一个新的UTXO。</li>
<li>世界上根本没有比特币，只有UTXO，你的地址中的比特币是指没花掉的交易输出。</li>
</ol>
</li>
<li>详细阐述从甲向乙的转账过程。
<ol>
<li>假设A之前通过币基交易挖矿获得了12.5个比特币，那么在它的钱包地址中，就有了相应的UTXO</li>
<li>Alice发起一个转账交易，输入是自己的上一个交易，输出是B的地址，数量是12.5比特币，A用自己的私钥进行签名。</li>
<li>当交易的区块链确认后，A的UTXO变成0.而B的地址中就多了一个UTXO，数量是12.5.</li>
<li>存在B的地址中的这些比特币只有用B的私钥进行签名才可以转账给其他人。</li>
<li>总的来说，比特币转账就是用这个地址对应的私钥打开，再加密发送到另一个地址的过程。这个私钥的打开和加密就是签名的过程。在这个过程中，接受比特币的一方不需要动用自己的私钥。</li>
</ol>
</li>
</ol>
</li>
<li>比特币存在哪儿
<ol>
<li>一方面，你的比特币是一个物理存在的一一对应的一个数据文件。比特币以一个交易的UTXO的形式存在着，每个交易都被看成是一个数据文件。</li>
<li>另一方面，比特币是区块链这个账本上的记录。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="比特币区块的数据结构"><a class="markdownIt-Anchor" href="#比特币区块的数据结构"></a> 比特币区块的数据结构</h2>
<ol>
<li>每个区块由两个部分组成–区块头部和区块数据。</li>
<li>区块头部
<ol>
<li>头部中有一个哈希指针指向上一个区块，这个哈希指针包含前一个数据块的哈希值。</li>
<li>如果前一个区块中的数据被篡改了，那么通过哈希指针就能够发现。所以，要修改一个区块中的数据，对其后的每个区块都必须相应的进行修改。</li>
</ol>
</li>
<li>区块数据：一个区块中的数据是被打包进这个区块的一系列交易。这些交易按规则打包最终形成梅克尔树。</li>
<li>区块链中的两种哈希指针：
<ol>
<li>一个是形成&quot;区块+链&quot;的链状数据结构。</li>
<li>另一个是数据块内部用来形成梅克尔树的哈希指针</li>
</ol>
</li>
</ol>
<h2 id="工作量证明共识机制"><a class="markdownIt-Anchor" href="#工作量证明共识机制"></a> 工作量证明共识机制</h2>
<ol>
<li>共识机制为什么存在：是因为这是一个非基于信任的网络，任何人无需许可都可以接入这个网络。并且，这些节点需要达成一致。共识机制即为这些节点达成一致的机制。</li>
<li>比特币的共识机制有两个与过去不同的特点
<ol>
<li>
<p>引入了奖励机制</p>
<ol>
<li>
<p>通过比特币奖励使网络中的节点愿意打包交易，维护账本。</p>
<p> 除了新区块相关奖励外，挖矿节点还可以的饿到区块中包含的所有交易付出的交易费。</p>
</li>
</ol>
</li>
<li>
<p>包含了随机性的概念</p>
<ol>
<li>
<p>比特币的共识系统并不是完全可靠的，但是经过约一小时(6个区块)后，出问题概率呈指数级下降，从实用角度来看，这个共识是可信的。</p>
 <img src="/Iptables_img/1.png" style="zoom:80%">
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="比特币的挖矿机制"><a class="markdownIt-Anchor" href="#比特币的挖矿机制"></a> 比特币的挖矿机制</h2>
<ol start="5">
<li>
<p>挖矿结点计算机的两个任务</p>
<ol>
<li>
<p>第一个任务是把比特币网络中未确认的交易按梅克尔树组装成候选区块，未被纳入的交易则往下顺延。</p>
<p>在创建候选区块时，除了普通的交易外，矿工在器中增加一个特殊的交易： 如果挖矿成功，则币基交易会凭空转出新区块的奖励比特币到矿工的钱包地址中，从而发行这些比特币出来。</p>
</li>
<li>
<p>第二个任务是进行加密哈希计算，解决一个计算难题，进行算力竞争。在众多争夺记账权的结点中，谁最先完成这个计算，它打包的区块就被加到了区块链的最后，称为最新的区块。刷先完成计算的矿工会赢得新区快对对挖矿奖励。</p>
</li>
</ol>
</li>
<li>
<p>比特币的工作量证明共识机制与它的挖矿机制</p>
<ol>
<li>向内看： 在候选区块的头部有一个32位的随机数区域，矿工需要反复调整随机数并计算，目标是让整个区块的哈希值小于一个目标值。如果尝试过所有的32位随机数可能性后，计算仍未成功，那么就要改变币基的一个随机数，接着反复计算。</li>
<li>向外看： 随着算力的增长，会调整目标值的难度使得挖出一个区块的时间始终是10分钟左右。</li>
<li>总之，比特币的经济系统是以竞争-记账-奖励循环为核心的。</li>
</ol>
</li>
</ol>
<h2 id="比特币转账过程"><a class="markdownIt-Anchor" href="#比特币转账过程"></a> 比特币转账过程</h2>
<img src="/Iptables_img/3.png" style="zoom:80%">
<h1 id="区块链的应用"><a class="markdownIt-Anchor" href="#区块链的应用"></a> 区块链的应用</h1>
<ol>
<li>总的来说，区块链让我们从信息互联网跨越到价值互联网。</li>
<li>信息传递到价值传递
<ol>
<li>
<p>区块链提供了数字世界中价值表示与价值转移</p>
 <img src="/Iptables_img/4.png" style = "zoom:80%">
</li>
<li>
<p>目前的互联网实现的是信息传递，其特征是进行信息的复制。这一特征使得在数字空间中进行价值转移时，必须依赖可信的第三方</p>
</li>
<li>
<p>未来，我们不再需要这些“信用中介”。基于区块链技术，我们可能建立一个通过网络本身进行价值表示、价值转移的全新交易基础设施。</p>
</li>
</ol>
</li>
<li>数字世界中的价值转移和价值表示
<ol>
<li>价值的转移依靠记录：比如进行房产交易，那么要做的是把记录中所有权人改为你。</li>
<li>数字世界中，可完美复制的数据文件和需要唯一性的价值表示形式形成冲突。为了防止双花问题，所以需要一个可信的第三方作为中介。所有与价值转移有关的事处于成本高，效率低的状态，互联网上的价值转移就局限在少数的价值类别上。</li>
</ol>
</li>
</ol>
<h2 id="价值表示"><a class="markdownIt-Anchor" href="#价值表示"></a> 价值表示</h2>
<ol>
<li>价值的表示是在交易中体现出来的，因此可以从价值转移来讨论价值表示。</li>
<li>传统的体系中：价值的表示需要一个中介来参与。中介维护一个集中的账本用以记录，协助完成价值转移。</li>
<li>比特币系统中，区块链的账本以分布式的方式存在于互联网上，由去中心网络的节点共同维护。只要掌握自己的私钥即可。即所有人共享一个云端账本。</li>
</ol>
<h2 id="价值转移"><a class="markdownIt-Anchor" href="#价值转移"></a> 价值转移</h2>
<ol>
<li>在基础层次上，区块链担任信用中介，协助进行价值表示和价值转移。</li>
<li>互联网的层次：
<ol>
<li>最上层，是普通用户看到的网站与App等应用。</li>
<li>中间层，是协议层，这一层过去主要是信息传递的WWW等协议。</li>
<li>最底层，是网络传输硬件和网络传输协议如TCP/IP等。</li>
</ol>
</li>
<li>区块链给互联网带来了进行价值表示和价值转移的新协议。区块链信用层协议由一组协议组成，在现有硬件网络之上，形成了一个协助我们进行价值表示和价值转移的新层次。这组协议目前仍未定性，也尚未被广泛认可，在持续发展中。</li>
</ol>
<h2 id="价值表示物数字世界中表示价值的通证"><a class="markdownIt-Anchor" href="#价值表示物数字世界中表示价值的通证"></a> 价值表示物：数字世界中表示价值的通证</h2>
<ol>
<li>以太坊创始人维塔利克写道，常被提及的应用包括：
<ol>
<li>使用链上数字资产来代表定制货币和金融工具。</li>
<li>某种基础物理设备的所有权。</li>
<li>如域名一样的不可互换的资产</li>
<li>以及复杂的应用来直接控制转移数字资产（<strong>智能合约</strong>）</li>
<li>甚至基于区块链的分布式自治组织。</li>
</ol>
</li>
<li><a href="http://c.biancheng.net/view/1908.html" target="_blank" rel="noopener">应用及以太坊简史</a></li>
<li>把数字世界中，基于区块链的各种价值表示物都称为通证。</li>
<li>总的来说，现在在数字世界中，类似于 HTML 的代表价值的语言（通证）已经准备好了。“怎么用通证，通证有什么用”等问题等待着创造性的回答。</li>
</ol>
<h2 id="区块链的第三第四定义"><a class="markdownIt-Anchor" href="#区块链的第三第四定义"></a> 区块链的第三第四定义</h2>
<img src="/Iptables_img/5.png" style = "zoom:80%">
<img src="/Iptables_img/6.png" style = "zoom:80%">
<img src="/Iptables_img/7.png" style = "zoom:80%">
<h1 id="区块链将成为互联网基础协议"><a class="markdownIt-Anchor" href="#区块链将成为互联网基础协议"></a> 区块链将成为互联网基础协议</h1>
<ol>
<li>
<p>目前互联网通信用的协议是TCP/IP协议族。通常认为包括四层：</p>
<ol>
<li>链路层：将一些数据放在电线上。</li>
<li>网络层：对数据进行路由</li>
<li>传输层：将数据持久化</li>
<li>应用层：以应用的形式提供数据的抽象。</li>
</ol>
</li>
<li>
<p>万维网协议包括三部分：</p>
<ol>
<li>文本标记语言HTML</li>
<li>文档传输协议HTTP</li>
<li>指定文档网络地址的统一资源定位符URL</li>
</ol>
</li>
<li>
<p>区块链技术作用于硬件网络之上、WWW协议旁边</p>
 <img src="/Iptables_img/9.png" style = "zoom:80%">
</li>
</ol>
<h1 id="以太坊"><a class="markdownIt-Anchor" href="#以太坊"></a> 以太坊</h1>
<ol>
<li>
<p>在软件层面加入智能合约，但在实际应用中，它真正带来巨变的是通证。</p>
<blockquote>
<p>当下，对于区块链的发展阶段划分，一个被普遍接受的分类来自区块链研究者梅兰妮·斯万，在《区块链：新经济蓝图》一书中，她将区块链分为：区块链1.0，货币；区块链2.0，合约；区块链3.0，应用。从货币到合约、再到应用是一种阶段分类，以太坊白皮书的题目即宣称，它试图成为智能合约和去中心化应用的平台。</p>
</blockquote>
</li>
<li>
<p>以太坊是区块链2.0，实现了从数字现金到数字资产的转换。</p>
</li>
</ol>
<h2 id="智能合约与去中心化的平台"><a class="markdownIt-Anchor" href="#智能合约与去中心化的平台"></a> 智能合约与去中心化的平台</h2>
<ol>
<li>
<p>维塔利克分析在比特币系统的基础上开发高级应用的三种可行路径：</p>
<ol>
<li>建立一个新的区块链</li>
<li>在比特币区块链上使用脚本。</li>
<li>在比特币区块链上建立元协议。</li>
</ol>
</li>
<li>
<p>维塔利克认为，比特币系统的主要设计UTXO和其对应的脚本语言有缺陷。他总结了四点不足：</p>
<ol>
<li>缺少图灵完备性。尽管比特币的脚本语言可以支持多种计算，但并非所有。</li>
<li>价值盲：UTXO脚本不能为账户的取款额度提供精细的控制。</li>
<li>缺少状态：UTXO只能是已花费或者未花费状态，这意味着UTXO只能用于建立简单的、一次性的合约。</li>
<li>区块链盲：UTXO看不到区块链的数据，比如区块头部的随机数、时间戳和上一个区块数据的哈希值。</li>
</ol>
 <img src="/Iptables_img/10.png" style = "zoom:80%">
</li>
<li>
<p>以太坊的目标：提供一个区块链，内置有成熟的图灵完备的编程语言，用这种语言可以创建合约来编码，实现任意<strong>状态转换</strong>功能。（他认为比特币是一个状态转换系统）。</p>
<ol>
<li>
<p>要创建一个新的区块链。</p>
</li>
<li>
<p>这个区块链的特色是，有一个实现所有计算，即所谓的图灵完备的脚本编程语言。</p>
</li>
<li>
<p>这个脚本语言可以用来创建复杂的智能合约，用以控制区块链的状态转换，也即进行链上数字资产的转移。</p>
<blockquote>
<p>关于智能合约，在以太坊白皮书中，维塔利克用的词汇是“实现预先设定规则的一段代码”（implementing arbitrary rules）。在区块链上，这些代码的用途是控制链上的数字资产的转移。关于智能合约的更多介绍见相关冷知识专栏讨论</p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>维塔利克认为在以太坊上可以开发的三大类应用</p>
<ol>
<li>金融应用：用他们的钱去管理和参与合约。这些应用包括子货币、金融衍生品、对冲合约、储蓄钱包、遗嘱，甚至雇用合约。</li>
<li>半金融应用：这里有钱的存在，但非金钱的方面所占的比例也很重。一个好例子是为了解决计算问题而设的自动执行的悬赏。</li>
<li>非金融应用：如在线投票和去中心化治理等。</li>
</ol>
</li>
</ol>
<h2 id="用智能合约管理数字资产与erc20通证标准"><a class="markdownIt-Anchor" href="#用智能合约管理数字资产与erc20通证标准"></a> 用智能合约管理数字资产与ERC20通证标准</h2>
<p>目前以太坊最常用的功能是通过编写智能合约来管理用通证表示的数字资产。</p>
<ol>
<li>比特币出现以后，出现了很多通过简单修改比特币开源代码的参数得到替代币。而以太坊的智能合约将创建通证的门槛降到了很低。</li>
</ol>
<img src="/Iptables_img/11.png" style = "zoom:80%">
<img src="/Iptables_img/10.png" style = "zoom:80%">
2. ERC721（不可互换通证标准）：比如我的一本专门题名给我的签名书和你的同一本书是不同的，二者不可互换。
3. ERC20（可互换通证）：指的是每一个通证都是一模一样的，比如任何两张100元的价值是完全相同的。符合ERC20的通证的重要用途是被用于首次代币发行的筹资。人们可以用以太币按照项目方案设定的兑换率来换取这些通证，而项目方获得以太币形式的资金。
<p><a href="http://c.biancheng.net/view/1915.html" target="_blank" rel="noopener">“V神简介”</a></p>
<h1 id="智能合约"><a class="markdownIt-Anchor" href="#智能合约"></a> 智能合约</h1>
<ol>
<li>其中智能可以理解为，按条件自动执行，无须人的干预，是自动的或者自治的。</li>
<li>其中合约应该看成是存在于以太坊执行环境中的&quot;自治代理&quot;，它拥有自己的以太坊账户，他们收到交易信息后就相当于被捅了一下，然后自动执行一段代码-----V神如是说。（类比有限状态机，自动售货机）</li>
<li>可以认为区块链存储的是状态，智能合约是它用于状态转换的方式。智能合约像是一个特别的时钟，把世界从同步转向异步。</li>
</ol>
<h2 id="智能资产用智能合约来控制实体资产"><a class="markdownIt-Anchor" href="#智能资产用智能合约来控制实体资产"></a> 智能资产：用智能合约来控制实体资产</h2>
<ol>
<li>
<p>所谓智能财产，是智能合约程序按照设定的规则控制的财产。萨博举例说明如下：</p>
<p>例如，为了防止一部车被偷窃，除非确定拥有者完成正确的“挑战响应协议”，否则车是不会启动激活的。<br />
例如，如果车是贷款买的，当拥有者无法偿还贷款时，智能合约将会自动启动扣押令，并将车钥匙的控制权交给银行。一旦拥有者还清贷款，智能合约就移除扣押令。</p>
</li>
</ol>
<p>目前来说：由比特币区块链上的智能合约控制的资产，不管是实体的还是数字的，都叫智能资产。</p>
<h2 id="以太坊的智能合约"><a class="markdownIt-Anchor" href="#以太坊的智能合约"></a> 以太坊的智能合约</h2>
<ol>
<li>以太坊的智能合约是存在于区块链上，可以被触发执行的一段程序代码，这些代码实现了某种预定的规则，是存在于以太坊执行环境中的“自治代理”。</li>
</ol>
<img src="/Iptables_img/15.png" style = "zoom:80%">
<p>注：合约账户不能自己启动运行自己的智能合约。要运行一个智能合约，需要由外部账户对合约账户发起交易，从而启动其中的代码的执行。</p>
<h2 id="以太坊的智能合约有什么用"><a class="markdownIt-Anchor" href="#以太坊的智能合约有什么用"></a> 以太坊的智能合约有什么用</h2>
<ol>
<li>创建通证，通证对应的多是以太坊区块链之外的资产。</li>
<li>图 2 是一个简明的图示，这是从 Komhar 咨询公司的一个图示重绘而来的。图示是一个典型的 ERC20 通证发行过程：一个项目通过智能合约创建通证，这个通证是实体资产或线上资产的价值表示物。投资者（用户）发起交易，向智能合约转入以太币（ETH），智能合约自动运转，在满足一定规则后，它向投资者账户转入相应数量的通证。</li>
</ol>
<img src="/Iptables_img/16.png" style = "zoom:80%">
<h1 id="令牌系统-token-systems"><a class="markdownIt-Anchor" href="#令牌系统-token-systems"></a> 令牌系统 token systems</h1>
<p>令牌：用以表示资产的通证。</p>
<ol>
<li>
<p>所有的货币或者令牌系统从根本上来说都是带有如下操作的数据库：从A中减去X单位并把X单位加到B上。前提条件是</p>
<ol>
<li>A在交易之前至少有X单位</li>
<li>交易被A批准</li>
</ol>
<p>实施令牌系统，即是把这样一个逻辑实例实施到一个合约之中。</p>
</li>
<li>
<p>区块链能方便的承载Token系统，是因为它存储的是状态。</p>
</li>
<li>
<blockquote>
<p>在《商业区块链》一书中，区块链专家威廉·穆贾雅提出了一个可以用Token系统表示的事物的分类。他把区块链中可存储的事物的首字母组成了一个单词“ATOMIC”：</p>
</blockquote>
<p>可编程的资产（assets）。</p>
<p>可编程的信任（trust）。</p>
<p>可编程的所有权（ownership）。</p>
<p>可编程的货币（money）。</p>
<p>可编程的身份（identity）。</p>
<p>可编程的合同（contracts）。</p>
</li>
</ol>
<h1 id="通证有什么用机器比人更需要通证"><a class="markdownIt-Anchor" href="#通证有什么用机器比人更需要通证"></a> 通证有什么用：机器比人更需要通证</h1>
<img src="/Iptables_img/17.png" style = "zoom:80%">
<ol>
<li>要<strong>把其他象限的价值映射到链上</strong>，用通证来表示，主要有两个途径：
<ol>
<li>路径之一是，把原本在互联网上通过中心化机构的数据库表示的价值和价值转移，切换到去中心化的区块链上来。比如常见的有网络零售的支付、社交网络的积分、游戏里的道具等，反映在图中就是从象限 ② 到象限 ③。</li>
<li>路径之二是，把实体中的资产映射到链上，通过区块链进行流通。比如常见的有：把线下的民宿、供应链金融、资产证券化（ABS）中的资产用通证进行表示，反映在图中就是从象限 ③ 到象限 ①。</li>
</ol>
</li>
</ol>
<p>但实际上，以上的路通过传统的方法已经做的够好了（我们总在考虑我们手中的加密货币能兑换多少法币，这恰恰说明了法币在价值表示上已经做的很好了）</p>
<h2 id="在机器视角看通证"><a class="markdownIt-Anchor" href="#在机器视角看通证"></a> 在机器视角看通证</h2>
<ol>
<li>
<p>令牌：初始用于通信网络，只有拥有两派的节点才能参与通信，令牌代表了权力。</p>
<blockquote>
<p>一个关于令牌的例子：假设，为了防止网络中的机器发出垃圾邮件，我们设定如下规则：个人电脑或手机在发出邮件时，需要消耗一个 token；发件邮件服务器也要消耗一个 token。如果这个邮件不被垃圾邮件规则拦截，或不被个人举报为垃圾邮件，那么在一定时间内，所消耗的 token 又会回到我们手中。</p>
</blockquote>
<p>在这里实际发生了令牌抵押，以确保我们在实施正当行为。</p>
</li>
<li>
<p>随着物联网技术的发展，越来越多的机器需要通证，我们的做法也不应该是给每一个传感器开设一个和法币对应的账户。这时，我们应该设计机器专用的钱包和通证。</p>
</li>
</ol>
<h1 id="erc20通证标准"><a class="markdownIt-Anchor" href="#erc20通证标准"></a> ERC20通证标准</h1>
<p>–是通过以太坊创建通证时得到一种规范。按照ERC20的规范可以编写一个智能合约。</p>
<p><a href="http://c.biancheng.net/view/1922.html" target="_blank" rel="noopener">详解ERC20W</a></p>
<h1 id="the-dao众筹事件与以太坊分叉"><a class="markdownIt-Anchor" href="#the-dao众筹事件与以太坊分叉"></a> The DAO众筹事件与以太坊分叉</h1>
<h2 id="分叉的存在比特币共识机制"><a class="markdownIt-Anchor" href="#分叉的存在比特币共识机制"></a> 分叉的存在：比特币共识机制</h2>
<ol>
<li>分叉方案：即从某个区块开始以太坊区块链不向前兼容，从而把 The DAO 众筹来的以太币夺回来，转移到一个恢复地址上，再还给参与众筹的人。<br />
比特币的共识机制本质上是通过算力进行的投票。在去中心化的网络中，一定程度上来说我们不存在真币和假币。你相信他是真的，愿意在包含这个交易的区块后面继续追加区块，维护这一区块链分支，那么他就是真的。日后，如果还要和其他人进行交易，并且他也认为你的比特币的起源是真实可靠的，那么你们就可以完成交易；反之，则会出现分歧，如果多数人都不站在你那边，那么你所拥有的比特币就来自非法交易。</li>
</ol>
<h1 id="设计通证用通证表示资产"><a class="markdownIt-Anchor" href="#设计通证用通证表示资产"></a> 设计通证：用通证表示资产</h1>
<p>有了智能合约和通证之后，以太坊就有了新的用途—进行数字资产的表示与交易。这使得数字资产也有了相对统一的价值表示形式，所以以太坊超越作为数字现金系统的比特币，开始解决如何表示资产等问题。</p>
<img src="/Iptables_img/18.png" style = "zoom:80%">
<h2 id="用通证将资产表示为链上的数字资产"><a class="markdownIt-Anchor" href="#用通证将资产表示为链上的数字资产"></a> 用通证将资产表示为链上的“数字资产”</h2>
<ol>
<li>
<p>通证是资产在区块链上的价值表示物，涉及的资产包括：</p>
<ol>
<li>比特币，以太币等链上的原生资产、映射到链上的线上资产、映射到链上的线下资产。</li>
</ol>
</li>
<li>
<p>我们通过以太坊区块链和他的智能合约来创建与发行代表价值的通证，然后用它去关联资产。</p>
</li>
<li>
<p>以太坊上的通证包括两种：可互换的ERC20和不可互换的ERC721。可互换的通证可类比现金，不可互换的通证类比房契。</p>
 <img src="/Iptables_img/19.png" style = "zoom:80%">
</li>
<li>
<p>链上和链下的交互包括两大部分：</p>
<ol>
<li>将链下资产与通证关联，进行通证的发行与分配。</li>
<li>在链上进行通证交易后，对链下资产进行相应的变动，并将变动在链上确认。</li>
</ol>
</li>
<li>
<p>将资产表示成通证的好处：</p>
<ol>
<li>帮助市场交易发现价格</li>
<li>在流动周转中增加资产价值。</li>
</ol>
<blockquote>
<p>其中，关于流动增加总体价值的例子，我们在现实生活中也可以体验到：二手物品的流动让买方和卖方都收益，车辆与房屋的共享提升了资源的利用效率。</p>
</blockquote>
</li>
</ol>
<h2 id="数字资产系统的去中心化交易场景"><a class="markdownIt-Anchor" href="#数字资产系统的去中心化交易场景"></a> 数字资产系统的去中心化交易场景</h2>
<p>-----以太坊的出现使得基于它的智能合约创建的各种通证都可以进行中心化或去中心化交易。</p>
<ol>
<li>
<p>通过智能合约进行链上数字资产交易：假设我们编写一个合约，售卖一种基于 ERC721 的不可互换通证，如性质类似于收藏卡的“加密猫”。每个加密猫通证各不相同，预先在智能合约中设定价格均为 10 个以太币，购买方式是先到先得。</p>
<p>这时，去中心化的数字资产交易过程如下：</p>
<ol>
<li>买方向智能合约地址转入 10 个以太币，即为发起购买邀约，智能合约担任第三方保管的角色。</li>
<li>卖方把该收藏卡（基于 ERC721 的通证）转入买方地址。</li>
<li>智能合约自动将以太币款项转入卖家账户。</li>
</ol>
<p>由于这里仅涉及以太坊区块链上的数字资产（加密猫通证和以太币）的转移，因此在链上可以完成全部过程。</p>
<p>对比 A、B 两种场景我们看到，原本中心化的中介（如淘宝与支付宝）被按预先设定规则自动执行的智能合约所取代。中心化中介被区块链（即分布式账本和去中心网络）所取代。</p>
</li>
<li>
<p>通过智能合约进行涉及线下资产的交易</p>
<ol>
<li>
<p>当交易的不是链上的数字资产时，智能合约和预言机是一对必备的组合。智能合约在链上，预言机在链下，它可以与链上的智能合约进行通信（见图4）。</p>
 <img src="/Iptables_img/20.png" style = "zoom:80%">
</li>
<li>
<p>比如，当卖家把数字文件传递给买家，买家确认之后，连接链上和链下的预言机就发出消息通知智能合约。接到消息后，智能合约执行后续的步骤，把以太币转入卖家账户。</p>
</li>
</ol>
</li>
<li>
<p>对比两个场景，我们知道</p>
<ol>
<li>有了智能合约，用通证表示的数字资产就是可编程的；</li>
<li>它是可以由计算机自动处理的；</li>
<li>如果数字资产交易各方形成一定的规则与逻辑，那么这些交易方之间可以进行完全自治的交易。</li>
</ol>
<p><strong>最终，可以大幅度降低资产流转交易的成本，提高效率，并实现智能化。</strong></p>
</li>
</ol>
<h2 id="通证的四个特征"><a class="markdownIt-Anchor" href="#通证的四个特征"></a> 通证的四个特征</h2>
<ol>
<li>中关村区块链产业联盟理事长元道指出的通证的三个要素：
<ol>
<li>第一是数字权益证明。通证必须代表一种权利，一种固有和内在的价值。</li>
<li>第二是加密。通证的真实性、防篡改性，保护隐私等特性由密码学给出。</li>
<li>第三是可流通。通证必须能够在一个网络中流通，从而随时随地都可以进行验证。</li>
</ol>
<blockquote>
<p>事实上，通证可以代表一切权益证明，从身份证到学历文凭，从货币到票据，从钥匙、门票到积分、卡券，从股票到债券，人类社会的全部权益证明都可以用通证来代表。</p>
</blockquote>
</li>
<li>第四个特点：通证是可编程的。</li>
</ol>
<p>在区块链上，可以通过智能合约自治或自动的处理通证。</p>
<img src="/Iptables_img/21.png" style = "zoom:80%">
<h2 id="通过经济系统设计和通证的发行与分配"><a class="markdownIt-Anchor" href="#通过经济系统设计和通证的发行与分配"></a> 通过经济系统设计和通证的发行与分配</h2>
<ol>
<li>回以太坊的建立过程，他起初进行了一轮众筹，严格来说，以太币的发行时中心化的，由以太币基金会发起的。但是过程时自动化的，由预先确定规则，编写后不能修改的智能合约自动执行的。
<ol>
<li>中心化的原因：用区块链上的通证来表示链上资产、线上资产、线下资产时，完全的去中心化，甚至完全无人介入的自动化通常是不可行的。资产的设计、发行的设计以及后续项目的运行，都需要有机构来发起。这个机构在一定程度上是区块链项目的中心。</li>
<li>然而中心化机构只需要在初期持续运行项目和社群，直到社区能够自行运转。随着项目的发展，社区的扩大，中心化开始弱化，甚至是最终达到去中心化的状态。</li>
</ol>
</li>
<li>通证经济体
<ol>
<li>
<p>通证经济体：是一个产业生态圈或社区，用通证来表示一个生态或社区的广义资产；借助通证来进行分配、交易。</p>
</li>
<li>
<p>核心事务：</p>
<ol>
<li>链：区块链技术的落实。</li>
<li>通证：通证的建立、分配与管理。</li>
<li>社群：用户社区与投资社区等以价值共识形成的社群。</li>
</ol>
 <img src="/Iptables_img/22.png" style = "zoom:80%">
</li>
</ol>
</li>
<li>通证经济系统的设计：一方面是和通证的价值相关的设计，另一方面是和通证的数量相关的设计。</li>
</ol>
<img src="/Iptables_img/23.png" style = "zoom:80%">
<img src="/Iptables_img/24.png" style = "zoom:80%">
4. **一个例子**：假设用通证经济系统来改造一个线下社区，那么可能的初始分配包括：投资方、团队和顾问、社区成员、留存。其中社区成员按一定规则得到的通证就是将线上资产映射到链上，用通证表示出来。之后，还需要设定规则定义生态成员如何获得通证，如何使用通证，此外还需要定义相关的经济逻辑。都确定之后，就可以通过编写智能合约来用代码实现它。
<img src="/Iptables_img/25.png" style = "zoom:80%">
<ol start="5">
<li><strong>通证，参考元道的说法是一种权利，不要局限于资产。他可以对应某种线上或线下的资产，也可能是代表某种功能的使用权</strong></li>
</ol>
<img src="/Iptables_img/26.png" style = "zoom:80%">
<h2 id="以太坊数字资产的基础设施"><a class="markdownIt-Anchor" href="#以太坊数字资产的基础设施"></a> 以太坊：数字资产的基础设施</h2>
<p>之前，在以太坊的 ERC20 标准被广泛接纳之前，要发行一个原生数字资产需要自行开发一条链，而现在我们可以基于以太坊这条公链来创建一个数字资产的价值表示物。<br />
#<a href="%22http://c.biancheng.net/view/1931.html%22">通证的分类</a></p>
<h1 id="以太坊只能合约的技术与组件"><a class="markdownIt-Anchor" href="#以太坊只能合约的技术与组件"></a> 以太坊只能合约的技术与组件</h1>
<img src="/Iptables_img/39.png" style = "zoom:80%">
<h1 id="erc721标准与加密猫"><a class="markdownIt-Anchor" href="#erc721标准与加密猫"></a> ERC721标准与加密猫</h1>
<p>加密猫—基于以太坊的ERC721标准发行的加密数字宠物，每一只猫咪<strong>各不相同</strong>。在此之前人们对以太坊的认识是，它的主要应用是用它的智能合约发行符合 ERC20 标准的可互换通证，同一种通证的一枚和另一枚是完全一样的。</p>
<h1 id="以太坊的账户"><a class="markdownIt-Anchor" href="#以太坊的账户"></a> 以太坊的账户</h1>
<p>以太币账户可以查看余额（包括以太币和其他基于ERC20标准的通证）。以太坊账户分为外部账户和合约账户。外部账户由密钥控制，合约账户由只能合约控制</p>
<img src="/Iptables_img/40.png" style = "zoom:80%">
<ol>
<li>以太坊的账户包括：一个随机数、账户余额、[合约代码]，存储</li>
</ol>
<h2 id="合约账户"><a class="markdownIt-Anchor" href="#合约账户"></a> 合约账户</h2>
<ol>
<li>只有合约账户才有代码，存储的是这个账户的以太坊虚拟机代码的哈希值。生成后不可修改，即智能合约代码不能修改。</li>
<li>合约账户可以设置多重签名</li>
</ol>
<h2 id="外部账户"><a class="markdownIt-Anchor" href="#外部账户"></a> 外部账户</h2>
<ol>
<li>外部账户可以触发交易，而合约账户不能主动发起交易，只能在被触发后执行代码。</li>
</ol>
<h2 id="以太坊的区块"><a class="markdownIt-Anchor" href="#以太坊的区块"></a> 以太坊的区块</h2>
<ol>
<li>区块中存交易，本质是状态转移函数。一个交易触发它的执行，它将相应的账户从一个状态转变成新状态，然后将新状态存储在区块链的数据区块中。</li>
<li>以梅克尔帕特丽夏树组织。</li>
</ol>
<h1 id="区块链的四大特征区块链有什么用"><a class="markdownIt-Anchor" href="#区块链的四大特征区块链有什么用"></a> 区块链的四大特征—区块链有什么用</h1>
<img src="/Iptables_img/41.png" style = "zoom:80%">
<h2 id="一-不可篡改"><a class="markdownIt-Anchor" href="#一-不可篡改"></a> 一 不可篡改</h2>
<ol>
<li>要修改一个区块中的数据，那么就要生成后面所有的区块。</li>
<li>共识机制的重要作用之一是使得修改大量区块的成本极高，从而几乎不可能。</li>
<li><strong>应用</strong>：农产品或商品溯源的应用：将它们的流通记录在区块链上，以确保数据记录不被篡改，从而提供追溯的证据。</li>
</ol>
<blockquote>
<p>2018 年 3 月，在网络零售集团京东发布的《区块链技术实践白皮书》中，京东认为，区块链技术（分布式账本）的三种应用场景是：跨主体协作，需要低成本信任，存在长周期交易链条。这三个应用场景所利用的都是区块链的不可篡改特性。多主体在一个不可篡改的账本上协作，降低了信任成本。区块链账本中存储的是状态，未被涉及的数据的状态不会发生变化，且越早前的数据越难被篡改，这使得它适用于长周期交易。</p>
</blockquote>
<h2 id="二-表示价值所需要的唯一性"><a class="markdownIt-Anchor" href="#二-表示价值所需要的唯一性"></a> 二 表示价值所需要的唯一性</h2>
<ol>
<li>中心化账本存在是因为在数字世界中，文件可以复制。</li>
</ol>
<blockquote>
<p>2018 年年初，中国的两位科技互联网企业领袖不约而同地强调了区块链带来的“唯一性”。腾讯主要创始人、CEO 马化腾说：“区块链确实是一项具有创新性的技术，用数字化表达唯一性，区块链可以模拟现实中的实物唯一性。”</p>
</blockquote>
<blockquote>
<p>百度创始人、CEO 李彦宏说：“区块链到来之后，可以真正使虚拟物品变得唯一，这样的互联网跟以前的互联网会是非常不一样的。”</p>
</blockquote>
<h2 id="三-智能合约"><a class="markdownIt-Anchor" href="#三-智能合约"></a> 三 智能合约</h2>
<ol>
<li>
<p>智能合约的出现使得基于区块链的两个人不只是可以进行简单的价值转移，而是可以设置复杂的规则，由智能合约来进行自治，自动的管理。</p>
</li>
<li>
<p>智能合约的性质：相当于一种特殊的服务端后台程序。</p>
<blockquote>
<p>在以太坊白皮书中，维塔利克写道：（合约）应被看成是存在于以太坊执行环境中的“自治代理”（autonomous agents），它拥有自己的以太坊账户，收到交易信息，它们就相当于被捅了一下，然后它就自动执行一段代码。</p>
</blockquote>
</li>
<li>
<p>编写智能合约</p>
 <img src="/Iptables_img/42.png" style = "zoom:80%">
</li>
<li>
<p><strong>区块链的新认识</strong></p>
<ol>
<li>区块链：是分布式账本技术。各方共同维护一个共享、互通、互联的账本，在此账本上就价值的确认、交易、分配达成共识。</li>
<li>区块链：是基于分布式账本技术的自治执行机制，即把区块链等同于智能合约。
<ol>
<li>在没有通证的情况下，通过智能合约的自动/自治执行，进行数字资产的交易。</li>
<li>在有通证的情况下，通过智能合约的自治执行，进行通证形式的数字资产的交易。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="四-去中心自组织"><a class="markdownIt-Anchor" href="#四-去中心自组织"></a> 四 去中心自组织</h2>
<p>----可能会失控，但失控也是一种自治。</p>
<ol>
<li>
<blockquote>
<p>在《去中心化应用》一书中，作者西拉杰·拉瓦尔（Siraj Raval）还从另一个角度进行了区分，他的这个区分有助于我们更好地理解未来的应用与组织。他从两个维度看现有的互联网技术产品：一个维度是，在组织上是中心化的，还是去中心化的；另一个维度是，在逻辑上是中心化的，还是去中心化的。</p>
</blockquote>
<p>他认为：“比特币在组织上去中心化，在逻辑上集中。”而电子邮件系统在组织上和逻辑上都是去中心化的</p>
 <img src="/Iptables_img/43.png" style = "zoom:80%">
</li>
<li>
<p><strong>区块链在技术之外的意义</strong> 可能作为基础设施支持人类的生产组织和协同的变革。这正是区块链与互联网是完全同构的又一例证，互联网也不仅仅是一项技术，它改变了人们的组织和协同。</p>
</li>
<li>
<p><strong>再看以太坊</strong> 以太坊将区块链技术带入了新的阶段，带来了智能合约和通证。作为价值表示物的通证，它的角色类似于 HTML。在有了 HTML 之后，建什么样的网站完全取决于我们的想象力。</p>
</li>
</ol>
<h1 id="区块链30"><a class="markdownIt-Anchor" href="#区块链30"></a> 区块链3.0</h1>
<h2 id="类比理解"><a class="markdownIt-Anchor" href="#类比理解"></a> 类比理解</h2>
<ol>
<li>
<p>类比操作系统的市场</p>
<blockquote>
<p>在 2016 年出版的《商业区块链》一书中，区块链专家威廉·穆贾雅以“数以百万计的区块链”（Getting to millions of blockchains）作为一个小节的标题。从整体上，他展望的未来图景是：“随着公有、私有、半私有、特殊目的以及其他类型的区块链的增长扩散，数以百万计的区块链世界将会实现。”这个说法可能展现了最可能的区块链未来图景。</p>
</blockquote>
<p>区块链的未来很可能不止是一条。</p>
</li>
<li>
<p>类比网站</p>
<blockquote>
<p>威廉·穆贾雅还做了一个虽然不甚准确但易懂的类比——“区块链将会成为新的网站”。在回顾了从 20 世纪 90 年代开始的网站发展史后，他类比指出：“每个公司一定会拥有或参与各种各样的区块链，无论它们是私有的、半私有的或公共的。”</p>
</blockquote>
</li>
<li>
<p>类比为云服务平台</p>
<ol>
<li>和现有的云不同，他们的核心功能是价值交易。</li>
</ol>
</li>
</ol>
<h2 id="作为云服务的区块链30"><a class="markdownIt-Anchor" href="#作为云服务的区块链30"></a> 作为云服务的区块链3.0</h2>
<ol>
<li>以太坊曾把自己定位为一台“全球分布式计算机”。在《区块链革命》中，商业思想家唐·塔普斯科特这样写道：“区块链上运行的所有计算资源可以在整体上视为一台计算机。”</li>
<li>区块链3.0从一个个的通证进化到一个个的应用，会使得它的基础模型可能与已知的以太坊模型有很大的不同。</li>
<li>目前，人们关注的焦点往往是性能问题，比如以太坊计划通过改用 POS 共识机制（casper）和分片技术（sharding）来提升性能，又比如人们关注 EOS 采用委托权益证明机制（DPOS）来提升性能。或许，架构也需要改变。</li>
<li>要看待这一个个应用（App），可以有两种方式：既可以把它们看成是区块链操作系统上的软件，它们用的是一条区块链的分布式账本和去中心网络；也可以把这些应用看成类似于一条条链，它们有着自己的分布式账本与去中心网络。
<ol>
<li>类比地看，在云服务出现之前，要开发一个网站或应用，我们要自己架设和运维服务器；而有了云服务之后，我们可以在云服务上开发自己的应用。在采用云服务时，一个个应用就有自己的一组专用服务器，像之前一样。类似地，如果采用类似的架构来开发区块链的应用，则可以认为，一个个应用也像有着自己的一条条独立的区块链。</li>
<li>现在的各个作为基础公链的区块链项目，做的正是云服务：以开源软件系统、分布式账本、去中心网络为基础，提供一系列和价值有关的云计算服务。</li>
<li>现在，对试图在各个领域或产业中实际应用区域链的人来说，要在区块链上开发应用，需要的正是一个类似的云服务架构：区块链的软件系统、分布式账本与去中心网络，从及一系列云计算软件服务。</li>
<li>当然，区块链云服务与现有的云服务也有很多不同：
<ol>
<li>它提供的云计算软件服务是基于分布式账本与去中心网络的。</li>
<li>软件系统通常不是由一家公司开发，而是由社区开发的，以开源方式发布。</li>
<li>去中心网络不是由一家公司运维，而是由不同主体出于经济激励而自主提供的。</li>
<li>一系列云计算软件服务也不是由一家公司提供，而是由社区提供的。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="走向应用的五条路径"><a class="markdownIt-Anchor" href="#走向应用的五条路径"></a> 走向应用的五条路径</h2>
<img src="/Iptables_img/44.png" style = "zoom:80%">
<ol>
<li>
<p>以超级账本为代表的联盟链软件：</p>
<ol>
<li>与比特币，以太坊等公有链不同，联盟链需要经过许可才能加入。联盟链有其特定的用途，较为适合大型公司在自己的内部部署使用，或部署后在自己的产业链生态中邀请合作伙伴接入，也可以由产业联盟共同部署。</li>
<li>从互联网的发展经验来看，区块链的未来只要还是开辟一套基础公链。目标是开发一条有通用功能或专一功能的公有链，并同时做三件事：开发软件，运行系统，运行社区。</li>
</ol>
</li>
<li>
<p>基础公链：通用类</p>
<p>开发一条通用类的基础公链。代表EOS（一个更快，更好，更适合应用开发的以太坊）</p>
</li>
<li>
<p>基础公链：功能类</p>
<p>开发专用于某类功能的区块链，代表IOTA（专用于物联网等），Steem和Steemit（专用于数字内容），再比如比原链（专用于数字资产交换，按白皮书披露的信息它要做到的是，连通比特世界与原子世界，实现“比特资产”（原生的数字货币、数字资产）和“原子资产”（有传统物理世界对应物）的交互与流转。 ）</p>
</li>
<li>
<p>基础公链：行业类</p>
<p>开发专用于某个行业的区块链，充分考虑该行业的特点提供相关的功能，比如保险、供应链金融、游戏、政务等。</p>
</li>
<li>
<p>基础设施 跨链的资产交易</p>
<p>可以预见的是区块链世界中必然有着很多链，甚至是非常多的链的共存。链与链之间的功能或资产的连接就变得非常重要。</p>
<blockquote>
<p>2018 年年初，新区块链项目区块基石（ArcBlock）自称是区块链 3.0，它的核心是提供跨链的协议，并以云服务的形式为开发者提供便利。另一个新项目梵塔网络（Penta）则定位在做“区块链世界的连接器”，要实现三大连接——链与链的连接、链与中心化系统的连接、链下与链上价值的连接，即为了推进区块链的应用，不只是连接不同的链，连接链上与链下，更要在需要时连接链与中心化系统。<br />
在鲸准研究院与节点资本研究中心的“侧链跨链研究报告”（2018年）中，它认为侧链与跨链在技术上大体相似，只有在谈到它们的服务对象时才需做细致的区分：一般来说，侧链服务于主链，而跨链试图改进的是链之间价值和功能的连通。其实，现在区块链领域的主要应用之一“币币交易所”实质上做的也是跨链资产的交易，只是目前采用的主要还是中心化的方式。目前，主要的交易所都推出了自己的通证（一般称平台币），并公布基础公链计划，也即准备用区块链技术来改进自身业务。</p>
</blockquote>
</li>
<li>
<p>基础设施 服务中心化应用</p>
<p>随着去中心化应用的出现，各种基础性技术服务成为刚需。如星际文件系统，分布式文件存储等。</p>
</li>
<li>
<p>区块链3.0 类比云服务</p>
 <img src="/Iptables_img/45.png" style = "zoom:80%">
</li>
</ol>
<h2 id="从多个网到多条链"><a class="markdownIt-Anchor" href="#从多个网到多条链"></a> 从多个网到多条链</h2>
<p>雷纳特·卡桑辛（Renat Khasanshyn）曾展示他基于联盟链理解的区块链应用未来。现在的各类系统，比如相互连接在一起的金融系统，是由多个中心化的数据库组成的。用区块链技术来改造这些系统，他的设想是，在合适的地方用相应的区块链来取代原来的数据库（见图 6）。从图 6 中可以看到，中心化的数据库被去中心化的区块链所取代。</p>
<h1 id="eos-比特币-以太坊"><a class="markdownIt-Anchor" href="#eos-比特币-以太坊"></a> EOS、比特币、以太坊</h1>
<ol>
<li>
<p>EOS 是一款企业操作系统（区块链软件系统）,其目的是将一切去中心化。</p>
<p>从 2017 年年中开始，经过一年的代币众筹后，它于 2018 年 6 月 15 通过由数十个区块生产者（block producer，BP，又称超级节点）组成的社区上线了主网，EOS 主网这条主要的区块链开始正式运转。</p>
</li>
<li>
<p>EOS包括三个部分：</p>
<ol>
<li>EOSIO软件，一共社区开发 的开源软件，任何人都可以参与开发、提交代码。</li>
<li>EOS币（EOS通证）</li>
<li>EOS主网：通过竞选，一批区块生产者被选出来，它们启动EOS主网。</li>
</ol>
</li>
<li>
<p>EOS账户：</p>
<ol>
<li>外部账户：由私钥控制</li>
<li>合约账户</li>
<li>与账户相关的概念：
<ol>
<li>钱包：保存密钥的客户端；</li>
<li>权限：包裹owner和active，用户可自定义各种权限。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>EOS的智能合约：<br />
其含义非常接近与linux的后台应用，节点在启动时包括缺省合约。</p>
<ol>
<li>调用方法：用户命令调用；EOSIO的send方法调用</li>
</ol>
</li>
</ol>
<h2 id="eos-vs-以太坊"><a class="markdownIt-Anchor" href="#eos-vs-以太坊"></a> EOS VS 以太坊</h2>
<img src="/Iptables_img/46.png" style="zoom:80%">
<ol>
<li>以太坊是比特币的改进，EOS是以太坊的改进（进化到应用）</li>
<li>以太坊的设计思路类似于高速公路。在这条收费高速公路上，车辆行驶需要付费。它早期募集资金，建设“高速公路”，早期投资者享有“高速公路”的主要权益。之后，一起建设与维护“高速公路”的挖矿节点也可以获得挖矿奖励与交易费收益。在以太坊网络中，由于各类项目已经基于它生成了大量的通证，以太坊网络的交易量相对较多，挖矿节点获得的交易费收益占比高于比特币。</li>
<li>EOS 的设计思路则类似于房地产开发。Block.one 公司在将土地售卖出去之后，逻辑上它用获得的资金进行基础的开发，此后每年再以类似填海造田的方式增加 5% 的土地出来。</li>
<li>EOS 网络要依靠超级节点（即区块生产者）来各自建设、共同运营，按现在的设计，这些节点共同获得每年 1% 新增发的 EOS 作为回报。其繁荣程度主要取决于超级节点能否建设号自己的地盘。</li>
<li>实际上，EOS的实际情况是：BlockOne公司募集资金开发一个名为EOSIO的开源软件。EOS社区通过这个软件运行EOS主网。EOS是对以太坊的改进，各中由EOSIO运行起来的区块链网络，也可以做以太坊能做的事。</li>
</ol>
<h2 id="eos的超级节点竞选"><a class="markdownIt-Anchor" href="#eos的超级节点竞选"></a> EOS的超级节点竞选</h2>
<ol>
<li>EOS采用的共识机制是DPOS（委托权益证明），即一些节点在获得足够多的投票后，成为见证人节点或EOS中所说的区块链生产者，<strong>负责区块的生成</strong>。</li>
<li>基于区块链的思路开发的软件系统的关键要求：
<ol>
<li>一是性能：它的去中心化网络的整体性能能否支撑大量应用。</li>
<li>二是网络：它的共识机制、经济激励和社区运营能否吸引足够多的节点加入，形成安全可靠的去中心网络。</li>
<li>三是功能：无论目标是通用类，功能类还是行业类，它是否提供了应用开发所需要的必备功能。</li>
</ol>
</li>
<li>超级节点竞选（DPOS）是一种激励。通过DPOS来刺激形成一个活跃的去中心网络，并且，超级节点竞选时与其共识机制DPOS高度匹配的。区块生产则时动态的，时刻根据投票动态调整。
<blockquote>
<p>EOS 的区块链生产者的收益分配机制是，区块生产者一共可获得每年新增出来的 1% 的 EOS 通证作为回报，其中 0.25% 按每个区块来进行奖励，0.75% 按所获投票来进行分配。可参见 2018 年 5 月 12 日项目发布的信息。</p>
</blockquote>
</li>
</ol>
<h2 id="eos-的共识机制"><a class="markdownIt-Anchor" href="#eos-的共识机制"></a> EOS 的共识机制</h2>
<p>所有的出块者都要对所有区块签名，以确保在同一时间戳或者同一区块高度上，没有区块生产者能够同时在两个区块上签名。一旦一个区块有了 15 个区块生产者的签名，该区块就被认为是不可逆的。任一区块生产者如果想在同一时间戳或者同一区块高度的两个区块上签名，就会留下密码学证据。在这一模式下，一秒之内就可以达成不可逆的共识。</p>
<ol>
<li>EOSIO 设定每0.5秒产生一个区块，每126个区块为一个周期（每个出块者6个区块，乘以21个出块者）。在每个出块周期开始时，软件会根据通证持有人投票选出21个区块生产者。每个生产的区块要获得15个以上的区块生产者的签名即变成不可逆的交易。</li>
<li>如果在计划的时间内没有成功出块，则跳过该块，产生0.5秒的空白。如果出块者错过了一个区块，并且在最近24小时内都没有产生任何区块，则这个出块者将被踢出考虑范围，直至他们通知区块链可以重新开始产生区块。这确保了网络的顺利运行。</li>
</ol>
<h1 id="区块链的不可能三角"><a class="markdownIt-Anchor" href="#区块链的不可能三角"></a> 区块链的不可能三角</h1>
<img src="/Iptables_img/47.png" style="zoom:80%">
<p>对比一下比特币和 EOS：比特币系统看重的是去中心化和安全，而牺牲了可扩展性；EOS 在一定程度上牺牲了去中心化，而去追求可扩展性与安全。</p>
<h1 id="去中心化的应用"><a class="markdownIt-Anchor" href="#去中心化的应用"></a> 去中心化的应用</h1>
<ol>
<li>
<p>EOS白皮书中给出了区块链应用的六个条件：</p>
<ol>
<li>支持百万级别的用户，需要能够处理数千万日活跃用户的区块链技术。</li>
<li>使用免费，应用开发人员需要具备灵活性，能够为用户提供免费服务；用户不必为了使用平台或从平台的服务中受益而付费。</li>
<li>轻松升级和故障修复，区块链平台必须对软件和智能合约的升级提供支持。</li>
<li>延迟低，及时地反馈是良好用户体验的基础。</li>
<li>串行性能，有些应用程序由于必须顺序执行命令，无法用并行算法进行实现。区块链需要提供强大的串行性能支持。</li>
<li>并行性能，大型应用程序需要在多个CPU和计算机之间分配工作负载。</li>
</ol>
</li>
<li>
<p>早期的应用:将会在区块链上出现原生的区块链应用或去中心化应用。</p>
</li>
<li>
<p>如果单独看一条区块链的应用，情形可能如图 2 所示。</p>
<ol>
<li>这条区块链是分布式账本与去中心网络，它提供着一系列与价值相关的数据和功能。</li>
<li>多个应用接入区块链网络。在这些应用中，有的可能是普通用户可以使用的，是网站/移动 App 与区块链应用的组合；有的可能是纯粹的区块链应用。<br />
<img src="/Iptables_img/48.png" style="zoom:80%"></li>
</ol>
</li>
<li>
<p>有的应用可能接入多个区块链，比如现在常见的应用交易所、钱包就接入多个区块链。</p>
</li>
<li>
<p>去中心化应用可以从去财富中心化和去计算中心化入手。</p>
</li>
<li>
<p>区块链3.0的先驱者EOS为应用而做的三件事：用户免费、账户与权限体系、存储系统。</p>
</li>
</ol>
<h2 id="区块链应用实例steemit博客"><a class="markdownIt-Anchor" href="#区块链应用实例steemit博客"></a> 区块链应用实例—Steemit博客</h2>
<ol>
<li>基于Steem区块链上存储价值，并按照内容贡献进行分配。</li>
<li>基于这条区块链建有多个应用：普通用户可用的 Steemit 博客平台、视频平台 DTube 等；常备的应用如区块链浏览器 <a href="http://steemd.com" target="_blank" rel="noopener">steemd.com</a> 网站。它的社区算是较为活跃的，还有其他的很多应用。</li>
</ol>
<h2 id="用户免费"><a class="markdownIt-Anchor" href="#用户免费"></a> 用户免费</h2>
<p>----用户不必为了使用平台或从平台的服务中收益而付费。</p>
<ol>
<li>
<p>使用一个区块链应用需要三种资源，均由维护这个去中心网络的计算机提供。分别是：</p>
<ol>
<li>带宽资源：带宽和日志存储。(磁盘)</li>
<li>计算资源：计算和计算积压。（CPU）</li>
<li>状态资源：状态存储。（RAM）</li>
</ol>
</li>
<li>
<p>关于状态：区块链账本中存储的是状态，比如交易账本、账户余额等，按其名字缩写为 RAM，它的性质大约相当于内存。EOS 还特别举例说明，什么应该存入状态，什么不应该存入状态。例如，一个区块链应用程序的逻辑不需要读取博客文章的内容和评论，因此它们不应该存储在区块链的状态中。但是，博客文章或评论是否存在、投票数以及其他属性，需要存在区块链的状态之中。</p>
<p><strong>简单的说，区块链是用于交易的，区块链的状态是交易账本，那么，与交易相关的信息应该存入交易账本，而与交易无关的信息不应存入交易账本。</strong></p>
</li>
<li>
<p>EOS中的三种资源的消耗机制：区块生产者（BP）公布可用的带宽（bandwidth）、计算（computation）和状态（state）的容量。EOSIO 系统允许每个账户消耗一定比例的可用资源，这个比例是根据账户将自己持有的通证存入“三天抵押合约”的数量决定的。</p>
</li>
<li>
<p>关于交易费：</p>
<ol>
<li>以太币和比特币中都需要交易的发起方设定一个交易费，付给区块链网络，从而使网络能够处理这一交易。</li>
<li>EOS的逻辑是去中心化应用程序不应该强迫它的用户为使用区块链而支付费用。具体实现是由应用自己决定采用什么方式，通常为了用户使用，应用会自行解决，从而使得用户看上去是免费的。</li>
</ol>
</li>
<li>
<p>交易成本与通证价值分开</p>
<ol>
<li>在以太坊的网络中，我们交易支付以太币，随着以太币价格的涨跌，交易成本也随之变化。</li>
<li>EOS的逻辑是使交易成本与通证价值无关。EOS的做法是，一个应用拥有的带宽、计算、状态等资源，是与其持有的通证数量有关的，但由于不需要消耗，因此一定程度上与通证价值无关。</li>
<li>如果应用开发者不持有足够多的通证，则EOS网络还有一种“将资源能力授权出去”的机制，通证持有人可以不立刻消耗可用带宽或全部资源，可以将未消耗的带宽委托或租赁给其他人。</li>
</ol>
<blockquote>
<p>根据 EOSIO 文档，这里的状态可认为指的是一个应用所占用的区块链网络的 RAM 存储空间。原文为：Storage of application state will require an application developer to hold tokens until that state is deleted.If state is never deleted,then the tokens are effectively removed from circulation.</p>
</blockquote>
<blockquote>
<p>对比以太坊和 EOS 我们可以看到，在以太坊中进行交易，个人用户需要支付交易费，而在 EOS 中进行交易，则是应用提供者需要承担成本，现在看来其中主要的成本是与 RAM 存储空间相关的。</p>
</blockquote>
</li>
</ol>
<h2 id="账户与权限体系"><a class="markdownIt-Anchor" href="#账户与权限体系"></a> 账户与权限体系</h2>
<ol>
<li>比特币：没有账户，所有比特币交易都是地址见的交换。</li>
<li>以太坊：引入了账户。每个账户包括四个信息：一个随机数、账户的余额、合约代码（如果有的话）、存储（通常为空）。分为外部账户和合约账户。这里的合约代码相当于以太坊中的自治代理。</li>
</ol>
<h3 id="eos账户"><a class="markdownIt-Anchor" href="#eos账户"></a> EOS账户</h3>
<ol>
<li>一个EOS账户可以发送动作给另一个账户，而每个账户都可以设定一个处理器来自动处理发给自己的动作。动作与处理器的结合就是智能合约。</li>
<li>EOS系统提供了一个标准的基于角色的权限系统。允许每个用户持有者定义自己的权限层次结构以及动作的分组。</li>
<li>其账户系统包含两个缺省的权限组：最高级别的缺省是owner，第二个缺省权限组是active，其他的权限组都可以由active派生出来</li>
</ol>
<h2 id="存储系统"><a class="markdownIt-Anchor" href="#存储系统"></a> 存储系统</h2>
<p>—与交易相关的数据被存储在区块链中，那么应用相关数据放在哪呢？</p>
<ol>
<li>目前EOS的想法是存储在基于IPFS的EOS存储中。</li>
</ol>
<h2 id="总结-区块链的定义七-八"><a class="markdownIt-Anchor" href="#总结-区块链的定义七-八"></a> 总结 区块链的定义七 八</h2>
<img src="/Iptables_img/49.png" style="zoom:80%">
<img src="/Iptables_img/50.png" style="zoom:80%">
<h1 id="eos账户的密钥被盗找回"><a class="markdownIt-Anchor" href="#eos账户的密钥被盗找回"></a> EOS账户的密钥被盗找回</h1>
<ol>
<li>基于它的用户权限机制</li>
<li>在这种情况下，你可以用过去 30 天中有效的 owner 权限对应的私钥，和你预先设定的账户恢复合作伙伴（account recovery partner）重置账户的私钥。这样你可能夺回了账户的所有权。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-北大网课" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%8C%97%E5%A4%A7%E7%BD%91%E8%AF%BE/"
    >北大网课</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%8C%97%E5%A4%A7%E7%BD%91%E8%AF%BE/" class="article-date">
  <time datetime="2020-03-30T03:00:53.091Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="哈希函数与加密体制"><a class="markdownIt-Anchor" href="#哈希函数与加密体制"></a> 哈希函数与加密体制</h1>
<ol>
<li>性质：
<ol>
<li>抗碰撞性：难以人为制造哈希碰撞。</li>
<li>单向性：前提是输入空间足够大并且输入的分布比较均匀。(如果输入空间不够大，那么把输入后面拼接一个随机数再哈希)</li>
<li>puzzle friendly:比特币特有的性质。比特币区块要求计算出来的哈希值小于等于某一个阈值。</li>
<li>难以计算，但是易于验证。</li>
</ol>
</li>
<li>比特币中用的哈希函数:SHA-256</li>
<li>账户：在本地创建一个公私钥对就是一个账户。</li>
<li>非对称加密体系：公私钥。加密用公钥，解密用私钥，且加密和解密用的是用一个人的公钥和私钥。
<ol>
<li>私钥保存在本地就行，公钥可以公开。</li>
<li>公钥相当于你的银行账号，私钥相当于银行密码。</li>
</ol>
</li>
<li>对称加密体系：加密解密使用同一个密钥，假设前提是存在一种安全的渠道把密钥分发给通信双方。</li>
<li>比特币系统中的公钥和私钥
<ol>
<li>比特币系统中的信息都是公开的</li>
<li>所以私钥用来对交易做签名。我发起一个交易，那么我拿我的私钥进行签名，发布到区块链上，别人再用我的公钥进行验证。</li>
</ol>
</li>
<li>以上所述的公私钥体制建立在有一个好的随机源上，同时每次签名操作也需要一个好的随机源。</li>
</ol>
<h1 id="比特币中的数据结构"><a class="markdownIt-Anchor" href="#比特币中的数据结构"></a> 比特币中的数据结构</h1>
<ol>
<li>哈希指针：比如一个哈希指针指向一个结构体，那么这个指针里不止存它的地址还存它的哈希值。</li>
<li>区块链&amp;普通链表
<ol>
<li>
<p>以哈希指针代替普通指针。</p>
</li>
<li>
<p>后一块的哈希指针是通过前一区块的全部内容(包括前一区块的哈希指针)计算出来的。</p>
<p><strong>这样从最后一个区块就能知道前面的区块是否被修改。</strong></p>
<p><strong>这样系统中的某些节点就不需要保存全部区块信息</strong></p>
</li>
<li>
<p>梅克尔树<br />
<img src="/Iptables_img/2.png" style="zoom:80%"></p>
<ol>
<li>每个区块内部的交易组织成梅克尔树的形式</li>
<li>区块间通过哈希指针连接在一起。</li>
</ol>
</li>
<li>
<p>比特币网络由轻节点和全结点构成，其中</p>
<ol>
<li>轻节点只保存区块头；当轻节点想确认某笔交易是否已经被写进区块链中：轻节点向全节点请求红色的哈希值，轻节点自己计算绿色的哈希值。最终，可以将得到的根哈希值和头部中的根哈希值相比较。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="btc协议比特币的共识机制"><a class="markdownIt-Anchor" href="#btc协议比特币的共识机制"></a> BTC协议：比特币的共识机制</h1>
<p>比特币需要解决问题：双花；发行</p>
<h2 id="双花问题"><a class="markdownIt-Anchor" href="#双花问题"></a> 双花问题</h2>
<ol>
<li>
<p>转账：假如A要向B和C转帐</p>
<ol>
<li>交易需要A的签名，证明是经过A统一 的。</li>
<li>需要指明A的比特币从哪来</li>
<li>注：比特币系统中的交易包括输入和输出两部分，输入部分要指明币的来源，输出部分要给出收款人的公钥的哈希。</li>
</ol>
 <img src="/Iptables_img/8.png" style="zoom:80%">
<p>注意：其中包含两种哈希指针。一种用来构成链表，另一种用来指向前面某个交易，以说明币的来源。</p>
<ol start="4">
<li>
<p>A需要知道B的公钥，B乃至所有节点也需要知道A的公钥，用来验证A的签名。因为怀疑网络中存在恶意节点，所以每个节点都需要亲自验证。</p>
<p><strong>问题</strong>：A的公钥需要A自己去公布；如果某个恶意节点伪造了转账记录，用自己的私钥去签名，再公开自己的公钥说是A的公钥，那么可以转走A上钱么？</p>
<p><strong>不</strong>，因为每个交易要去追溯币的来源，最终会追溯到币基交易，而币基交易（前面的交易）的输出正是A的哈希地址，只有当转帐中用到的公钥和这个哈希能对上，才能认为合法。<br />
2.<strong>注</strong>：加密是用接收者的公钥加密，接收者用自己的私钥解密。</p>
</li>
</ol>
</li>
<li>
<p>区块的头部，包括</p>
<ol>
<li>比特币协议版本信息</li>
<li>指向前一个区块的指针</li>
<li>梅克尔树的根哈希值</li>
<li>挖矿的难度目标阈值（整个块头的哈希要小于等于目标阈值）</li>
<li>随机数</li>
</ol>
</li>
<li>
<p>分布式共识</p>
<ol>
<li>比如分布式哈希表：需要取得共识的是哈希表中包含了哪些 键值对。</li>
</ol>
</li>
<li>
<p>比特币的共识协议：问题出现在比特币系统中部分节点是有恶意的。</p>
<ol>
<li>最简单的，想要通过投票来判断某个节点产生的区块是否正确（区块内部的交易是否都是合法的）。但是存在一个问题，就是如何判断谁有投票资格。
<ol>
<li><strong>女巫攻击</strong>：产生大量的公私钥对，极端情况下超过半数，那么他就得到了控制权。</li>
</ol>
</li>
<li>通过<strong>算力</strong>来投票，每个节点都可以在本地组装候选区块，把他认为合法的交易放进去。然后开始算能够使得头部的哈希值小于目标阈值的随机数的值，找到了这个随机数的节点就获得了记账权，向比特币网络中发布这个区块
<ol>
<li>其他节点收到这个区块后，首先验证nbits域的设置是否符合难度要求；验证头的哈希是否小于等于目标阈值。</li>
<li>然后验证body中的交易
<ol>
<li>是否是合法的签名</li>
<li>以前是否被花过</li>
</ol>
</li>
<li>即使通过了前面的检查，但是该区块不是连接在最长合法链的末尾，也不接受。因为验证交易合法性时候，只去验证他所在的分支。
<ol>
<li><strong>分叉攻击</strong>：通过向区块链中间插入某个区块来回滚某个已经发生的交易。<br />
<img src="/Iptables_img/13.png" style="zoom:80%"></li>
</ol>
</li>
<li>接受一个区块意味着沿着这个区块继续往下扩展。如果产生的链不是基于最长的链，那么他在该链上通过币基交易得到的比特币也是不被认可的非法交易。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>为什么要争夺记账权？为了币基交易的比特币奖励。</p>
</li>
<li>
<p><strong>总结</strong>：比特币系统中的共识是针对分布式账本内容-&gt;只有获得记账权的节点才有权力向账本里写东西，有权决定账本中的内容-&gt;获得记账权需要算力支持-&gt;比特币的投票是基于算力的。</p>
<ol>
<li>比特币的性质：puzzle friendly，即想计算出结果，没有捷径，只有一个个试。</li>
</ol>
</li>
</ol>
<h1 id="比特币系统的实现"><a class="markdownIt-Anchor" href="#比特币系统的实现"></a> 比特币系统的实现</h1>
<ol>
<li>比特币使用基于交易的账本模式</li>
<li>比特币系统的全节点要维护一个UTXO的数据结构（所有没被花掉的交易输出组成的集合）以检查双花问题。</li>
<li><strong>比特币激励机制2</strong>：交易费，激励争夺记账权的节点将他人的交易打包进区块。</li>
<li>想要使哈希值低于根哈希值，一个使太正nance，另一个使调整coinbase，这样搜索空间就达到了2<sup>96。</li>
<li>求解puzzle过程<br />
<img src="/Iptables_img/14.png" style="zoom:80%"></li>
</ol>
<p>其中tx那一串在实际上只需要梅克尔树的根哈希值即可。</p>
<h2 id="挖矿的概率分析"><a class="markdownIt-Anchor" href="#挖矿的概率分析"></a> 挖矿的概率分析：</h2>
<ol>
<li>每次挖矿的过程可以看作是一个伯努利试验。大量的伯努利实验构成一个伯努利程序。
<ol>
<li>性质1：无记忆性</li>
</ol>
</li>
<li>试验次数很多，但是实验成功的概率很小的时候，可以用泊松分布来近似。</li>
<li>整个系统的出块时间是服从指数分布的，平均是10分钟。这个指数分布也是无记忆的。所以将来还要挖多少时间和过去已经挖了多少时间是没有关系的。这也保证了算力强的矿工拥有成比例的优势。</li>
</ol>
<h2 id="比特币系统的总量"><a class="markdownIt-Anchor" href="#比特币系统的总量"></a> 比特币系统的总量</h2>
<ol>
<li>比特币区块奖励是固定的，每个四年减半一次，所以比特币的数量会构成一个几何序列。可以计算出一共只有2100万个比特币。</li>
</ol>
<h2 id="挖矿的意义"><a class="markdownIt-Anchor" href="#挖矿的意义"></a> 挖矿的意义</h2>
<ol>
<li>挖矿本身并不解决什么问题，但是其算力竞争对于维护比特币系统的安全性是至关重要的。只要大部分算力是掌握在诚实节点手里，那么安全性就得以保证。</li>
</ol>
<h2 id="安全性分析"><a class="markdownIt-Anchor" href="#安全性分析"></a> 安全性分析：</h2>
<ol>
<li>恶意节点能否将别人的比特币转走：<strong>不能</strong>，无法伪造签名。如果他把交易硬写到区块链里，那么诚实的节点不会认可这个交易，因为他包含了一个非法的交易</li>
<li>恶意节点能否双花（<strong>分叉攻击</strong>）
<ol>
<li>简单的防范方法是多等待几个区块（几个确认）（比特币协议中是等待6个确认），这样写入了回滚交易的区块想要使自己所在的分支成为最长合法链的难度就大大增加。</li>
</ol>
</li>
<li>恶意节点故意不包含某些交易
<ol>
<li>但是问题不大，总有诚实的节点愿意将交易写入区块。即使不在这个区块里写入，也会写在下一个区块里。</li>
<li>正常的情况下，也有可能出现这种情况，因为比特币协议要求每个区块不得大于1MB。</li>
</ol>
</li>
<li>selfish mining攻击：挖到区块先不发布，攒了一堆再去发布以争夺最长合法链
<ol>
<li><strong>不行</strong>：这对算力要求很大，起码要占据51%以上的算力才有一定的成功的可能性。但是话说回来，如果恶意节点占据了如此大的算力，比特币系统就崩盘了。</li>
<li><strong>出于盈利目的</strong>：如果一个节点的算力特别强，他挖到n+1个区块，之后不发布并立即开始挖第n+2个区块。等到侦听到有人挖到第n+1个区块的时候，他立刻将n+1和n+2个区块同时发布，那么他所在的链就成为了最长合法链，他得到的币基交易才是真实有效的。
<ol>
<li>存在很大的风险：我们只有在假设别人挖出一个的时间里，我可以挖出两个，才能获得更大的利益。如果别人挖完第一个而我没有挖出第二个，那么我只能去碰碰运气。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="比特币网络"><a class="markdownIt-Anchor" href="#比特币网络"></a> 比特币网络</h1>
<ol>
<li>比特币工作在应用层，其底层运行的是一个P2P Overlay网络，且这里的P2P网路中所有节点都是对等的。网络存在一个种子节点，可以通过它直到网络中其他节点的信息。节点之间通过TCP连接（这样有利于穿透防火墙）</li>
<li>每个节点维护一个临近节点集合(临近节点的选取是随机的，而不考虑底层拓扑结构)，消息传播采用洪范方式</li>
</ol>
<h1 id="比特币系统的挖矿难度"><a class="markdownIt-Anchor" href="#比特币系统的挖矿难度"></a> 比特币系统的挖矿难度</h1>
<ol>
<li>通过调整目标空间占搜索空间的比例来调整挖矿难度。</li>
<li>挖矿难度和目标阈值是成反比的。</li>
<li>为什么要维护挖矿难度：
<ol>
<li>如果不调整这个难度，那么随着挖矿的人数增多，设备的进步，那么相对于网路延迟来说，生成区块的速度过快，从而导致多分叉。分叉过多对系统达成共识没有帮助，也会危害到系统的安全性。</li>
<li>回顾分叉攻击：我们只有在假设大部分的算力都掌握在诚实的矿工手里的时候才能避免。如果出现多分叉，那么算力被分散，被分叉攻击的可能性大大增加。</li>
</ol>
</li>
<li>比特币系统规定每个2016个区块调整一次，大约14天一次。且增大和减小都有要求，增大不会一次性增大超过4倍，减少也不会一次减少到1/4以上。</li>
</ol>
<h1 id="比特币挖矿"><a class="markdownIt-Anchor" href="#比特币挖矿"></a> 比特币挖矿</h1>
<ol>
<li>
<p>比特币系统包括全节点和轻节点</p>
 <img src="/Iptables_img/27.png" style="zoom:80%">
<p>全节点：</p>
<ol>
<li>决定沿着那条链挖下去：缺省情况下，沿着最长合法链挖下去。</li>
<li>出现等长分叉：选择最先听到的分叉。</li>
</ol>
 <img src="/Iptables_img/28.png" style="zoom:80%">
<p>轻节点：</p>
<ol>
<li>只能检测合法链，但是不知道哪个是最长合法链。</li>
<li>轻节点假设矿工是有理智的，不会沿着非法的链挖下去。</li>
<li>轻节点在挖矿过程中，如果监听到别的节点已经挖出了新的区块，那么它只能放弃已有的区块。因为梅克尔树的跟哈希值和组成链的哈希指针都发生了变化。尽管如此，这并不可惜，因为挖矿具有无记忆性，成功的概率是没区别的。</li>
</ol>
</li>
<li>
<p>比特币的安全性保障</p>
<ol>
<li>由密码学提供：无法伪造的私钥签名。这个的前提是比特币网络中大多数节点都是好的，不会接受不合法的交易。</li>
<li>由比特币的共识机制提供</li>
</ol>
</li>
<li>
<p>矿石：使得51%以上的攻击变得容易。</p>
</li>
<li>
<p>矿石可发动的攻击：</p>
<ol>
<li>分叉攻击：</li>
<li>Boycott：比如想封锁A账户，可以在任何包含A的交易的区块被发布之后，立刻组装新的不包含A 的交易的区块，并经可能是新区块所在链变为最长合法链。</li>
</ol>
</li>
</ol>
<h1 id="比特币分叉"><a class="markdownIt-Anchor" href="#比特币分叉"></a> 比特币分叉</h1>
<ol>
<li>state fork:两个节点几乎同时挖到了区块。</li>
<li>forking attack（deliberate fork）</li>
<li>protocal fork:由于比特币协议修改导致的分叉
<ol>
<li>硬分叉：这样的分叉是永久的，只要有算力不更新软件就存在。</li>
<li>软分叉：临时性的分叉</li>
</ol>
</li>
</ol>
<h1 id="比特币的匿名性"><a class="markdownIt-Anchor" href="#比特币的匿名性"></a> 比特币的匿名性</h1>
<ol>
<li>
<p>假的匿名，类似于化名不是绝对的。而且比特币的账本是完全公开的，对匿名性一种挑战。</p>
</li>
<li>
<p>实际上不同的地址可能被关联在一起。通过推理出来。</p>
</li>
<li>
<p>如果交易只在区块链内，则不会泄漏。但是一旦和实体世界发生关联，那么就可能泄漏隐私，具体在：</p>
<ol>
<li>比特币支付</li>
<li>资金转入转出的时候</li>
</ol>
</li>
<li>
<p>提高匿名性的方法</p>
<ol>
<li>首先要实现网络层的匿名性：采用多路径转发的方法。</li>
<li>混合币</li>
</ol>
</li>
<li>
<p>保护匿名性很难的原因：（1）区块链是公开的（2）区块链具有不可修改性，一旦某一个交易暴露了身份，影响会是永久的。</p>
</li>
</ol>
<h1 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h1>
<h2 id="哈希指针"><a class="markdownIt-Anchor" href="#哈希指针"></a> 哈希指针</h2>
<ol>
<li>实际上比特币系统只有哈希没有指针。在全节点中,所有的区块是以levelDB这种键值对数据来存储,其中key为哈希值,value为区块内容。</li>
</ol>
<h2 id="区块恋"><a class="markdownIt-Anchor" href="#区块恋"></a> 区块恋</h2>
<ol>
<li>这样会严重影响私钥的安全性，因为私钥长度变短时，暴力破解的搜索空间大大降低。</li>
<li>所以应该用多重签名，其中每个私钥都是独立产生的。</li>
<li>如果两个人分手，那么所有的币都会被存在UTXO中。</li>
</ol>
<h2 id="分布式共识"><a class="markdownIt-Anchor" href="#分布式共识"></a> 分布式共识</h2>
<ol>
<li>实际上比特币并没有达成真正意义的共识。随时可能被推翻。</li>
</ol>
<h2 id="比特币的稀缺性"><a class="markdownIt-Anchor" href="#比特币的稀缺性"></a> 比特币的稀缺性</h2>
<ol>
<li>总量一定的东西并不适用于做货币。因为随着社会财富总值的增长，每单位该种货币就变得越来越值钱，先买的人就越来越富，后面的人就永远也赶不上。就像房地产。</li>
</ol>
<h1 id="以太坊概述"><a class="markdownIt-Anchor" href="#以太坊概述"></a> 以太坊概述</h1>
<ol>
<li>memory hard mining puzzle</li>
<li>以后想权益证明代替工作量证明，用类似于股权投票的方式。</li>
<li>智能合约：去中心化合约。加入参与方来自世界各地，那么手段维持合约的有效性就很困难，所以考虑写成程序，写进区块链。</li>
</ol>
<h1 id="以太坊中的账户"><a class="markdownIt-Anchor" href="#以太坊中的账户"></a> 以太坊中的账户</h1>
<ol>
<li>BTC中需要统计所有的UTXO。</li>
<li>账户天然的防护了双花问题。但是存在重放攻击。</li>
</ol>
<h2 id="重放攻击"><a class="markdownIt-Anchor" href="#重放攻击"></a> 重放攻击：</h2>
<ol>
<li>假设A给B转了一次帐，广播过一次，之后B又向网络广播这次交易。那么网络中的其他节点就会认为A又向B转账了一次。</li>
<li><strong>解决</strong>：多维护一个交易次数的属性，在签名的保护下一起发布出去。系统中的全节点维护这个交易次数值。假设A-&gt;B是第20次，那么全节点认为下次来的应该是第21，那么即使B重放，也不行。</li>
</ol>
<h2 id="外部账户"><a class="markdownIt-Anchor" href="#外部账户"></a> 外部账户</h2>
<ol>
<li>由公私钥控制，包括账户余额和交易次数。</li>
</ol>
<h2 id="合约账户"><a class="markdownIt-Anchor" href="#合约账户"></a> 合约账户</h2>
<ol>
<li>不是由公私钥对控制，也有nonce值，用来标识调用别的合约的次数。还有code，storage。但是合约账户不能主动发起交易。</li>
</ol>
<h2 id="为什么有合约"><a class="markdownIt-Anchor" href="#为什么有合约"></a> 为什么有合约</h2>
<ol>
<li>为了支持智能合约，要求参与者有相对稳定的身份。</li>
</ol>
<h1 id="以太坊状态树"><a class="markdownIt-Anchor" href="#以太坊状态树"></a> 以太坊状态树</h1>
<p>目的是建立一个账户到状态的映射。以太坊的账户为160b，状态包括余额、交易次数（代码，存储）。</p>
<h2 id="trie"><a class="markdownIt-Anchor" href="#trie"></a> Trie</h2>
<ol>
<li>
<p>优点：</p>
<ol>
<li>每个节点的分叉数目取决于取值范围。</li>
<li>查找效率取决于键的长度。</li>
<li>插入顺序不一样，得到的结构也一样。</li>
<li>更新局部性很好，每个区块对应的账户很少，伊这种结构不需要管别的分支</li>
</ol>
</li>
<li>
<p>缺点：</p>
<ol>
<li>存储浪费</li>
<li>查找效率与深度有关</li>
</ol>
</li>
</ol>
<h2 id="patricia-tree"><a class="markdownIt-Anchor" href="#patricia-tree"></a> Patricia tree</h2>
<ol>
<li>是路径压缩的trie树。键值分布稀疏的时候比较好。</li>
</ol>
<h2 id="mpt-merkle-partricia-tree"><a class="markdownIt-Anchor" href="#mpt-merkle-partricia-tree"></a> MPT Merkle Partricia Tree</h2>
<ol>
<li>路径压缩加路径压缩</li>
<li>优点：
<ol>
<li>放篡改</li>
<li>可以证明账户上的余额。</li>
<li>还可以证明某个键值是不存在的。</li>
</ol>
</li>
</ol>
<h2 id="modified-mpt"><a class="markdownIt-Anchor" href="#modified-mpt"></a> Modified MPT</h2>
<ol>
<li>以太坊的结构是一颗大的MPT包含很多小的MPT，每一个合约账户就是一颗小的MPT</li>
<li>系统中的全节点维护的不是一颗MPT，而是每产生一个新的区块就新建一颗MPT,这些树中大部分的节点是共享的，只有少数更新的节点要新建分支。</li>
<li>保留历史状态是因为可能需要回滚交易，比如分叉的时候。以太坊由于智能合约的出现，所以很难去反向推算前一个状态，所以要保存。</li>
<li>状态树中保存的是键值对，地址作为key。而value要首先经过序列化之后再存储，大致理解为变成字节数组。</li>
</ol>
<h1 id="以太坊数据结构"><a class="markdownIt-Anchor" href="#以太坊数据结构"></a> 以太坊数据结构</h1>
<h2 id="交易树也是一种mpt"><a class="markdownIt-Anchor" href="#交易树也是一种mpt"></a> 交易树–也是一种MPT</h2>
<ol>
<li>区块中的交易形成一颗交易树</li>
</ol>
<h2 id="收据树也是一种mpt"><a class="markdownIt-Anchor" href="#收据树也是一种mpt"></a> 收据树–也是一种MPT</h2>
<ol>
<li>每个交易执行完，会形成一颗收据树，记录这个交易的相关信息。交易树和收据树上的节点是一一对应的。利于快速查找执行的结果。</li>
<li>每个区块的交易树和收据树都是独立的。他们发布的交易本身我们也认为是独立的。</li>
</ol>
<h2 id="bloom-filter"><a class="markdownIt-Anchor" href="#bloom-filter"></a> bloom filter</h2>
<ol>
<li>为了在大的集合中进行查找，以支持复杂的查询操作。</li>
<li>一般的扫描存在存储问题和查找效率问题。</li>
<li>将每个元素取一个哈希，形成一个向量，其中某位为1代表该对应该哈希值的元素存在，这个向量称为摘要。</li>
<li>不支持删除操作。</li>
<li>作用：加入要查找过去十天发生的和某个智能合约相关的交易。首先，查找区块块头的bloom filter，看哪个块头的bloom filter里有我要的类型。如果某个块头里有，在去找对应收据树里的bf,看看哪个有。有的再去仔细查看。</li>
</ol>
<h2 id="以太坊的运行过程"><a class="markdownIt-Anchor" href="#以太坊的运行过程"></a> 以太坊的运行过程</h2>
<p>看成是交易驱动的状态机。状态是所有账户的状态；交易每次发布区块包含的交易，这些交易会驱动从当前的状态转移到下一个状态。</p>
<h1 id="ghost协议利于出现分叉后及时合并"><a class="markdownIt-Anchor" href="#ghost协议利于出现分叉后及时合并"></a> GHOST协议–利于出现分叉后及时合并</h1>
<ol>
<li>
<p>没有竞争称为最长合法链上的区块也会发放一定的出块奖励（7/8）称为叔父区块。下一个区块要包含所有叔父区块，同时得到1/32个出块奖励的额外报酬。最多可以包含两个叔父区块。</p>
</li>
<li>
<p>不在最长合法链上的区块都是叔父区块，即使是爷爷啥的。</p>
</li>
<li>
<p>为了防止在挖矿难度较低的时候产生叔父而不当获利，最多7代。叔父区块中的交易不执行，所以也不检查交易合法性，只检查是否符合挖矿难度。</p>
 <img src="/Iptables_img/52.png" style="zoom:80%">	
</li>
<li>
<p>GHOST机制是为了解决临时性的分叉。</p>
</li>
</ol>
<h1 id="以太坊的挖矿算法"><a class="markdownIt-Anchor" href="#以太坊的挖矿算法"></a> 以太坊的挖矿算法</h1>
<ol>
<li>求解很难，验证简单、</li>
<li>回避ASIC芯片。</li>
</ol>
<h2 id="lite币"><a class="markdownIt-Anchor" href="#lite币"></a> Lite币</h2>
<ol>
<li>基于Scrypt加密，需要大内存来保存这个数组。</li>
<li>但是设定小了，只有128K。</li>
</ol>
<h2 id="以太币"><a class="markdownIt-Anchor" href="#以太币"></a> 以太币</h2>
<ol>
<li>有两个数据集，初始一个是16M的cache，另一个是1G的DAG。DAG从cache中生成出来。轻节点只需要保存cache便于验证。</li>
<li>cache形成 ：首先从一个种子节点开始依次去哈希来填充数组。</li>
<li>DAG形成：从cache里随机读一个数，然后进行哈希计算，得到下一个要读取的数的位置。然后用cache中这个位置的数和当前的哈希值再计算出一个哈希值，反复迭代256次，将最终得到的数填充到数组的第一个位置。</li>
<li>挖矿的时候，先根据块头和nonce值计算一个哈希，这个哈希映射到数组中的某一个位置。通过这个位置和相邻位置的元素进行运算得到下一个位置，循环64次，最后得到的哈希值与目标阈值比较，看一下是否成功。不成功则换下一个nonce。</li>
<li>生成cache的seed每隔3w个区块会变一下。同时cache和DAG大小会增加1/128。</li>
</ol>
<h1 id="智能合约"><a class="markdownIt-Anchor" href="#智能合约"></a> 智能合约</h1>
<ol>
<li>外部账户可以调用合约，一个合约可以调用另一个合约。只有外部账户可以调用。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-区块链目录" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9B%AE%E5%BD%95/"
    >区块链目录</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9B%AE%E5%BD%95/" class="article-date">
  <time datetime="2020-03-30T03:00:51.066Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="北大网课"><a class="markdownIt-Anchor" href="#北大网课"></a> <a href="/2020/03/30/%E5%8C%97%E5%A4%A7%E7%BD%91%E8%AF%BE">北大网课</a></h2>
<h2 id="区块链自学"><a class="markdownIt-Anchor" href="#区块链自学"></a> <a href="/2020/03/30/%E5%8C%BA%E5%9D%97%E9%93%BE">区块链自学</a></h2>
<h2 id="区块链小论文"><a class="markdownIt-Anchor" href="#区块链小论文"></a> <a href="/2020/03/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B0%8F%E8%AE%BA%E6%96%87">区块链小论文</a></h2>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-iptables" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/iptables/"
    >iptables</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/iptables/" class="article-date">
  <time datetime="2020-03-30T02:51:26.428Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="iptables-基础"><a class="markdownIt-Anchor" href="#iptables-基础"></a> iptables 基础</h1>
<p>iptables本身不是防火墙，可以理解为一个客户端代理，通过iptables来设定规则，最终运行在netfilter框架下。</p>
<h2 id="通信过程"><a class="markdownIt-Anchor" href="#通信过程"></a> 通信过程</h2>
<p>当客户端访问服务器的时候，客户端发送报文到网卡，通过内核的TCP协议传输到用户空间的web服务器中，而此时，客户端报文的目标终点为web服务所监听的套接字。当web服务需要相应客户端请求时，web服务发出的响应报文的目标终点为客户端。netfilter作为内核的一部分，所有进出的报文都要通过这些关卡。于是，就有了input和output关卡，在iptables中，这些关卡称为链。除了通往本机的链，还有PREROURING(路由前)、FORWARD(转发)、POSTROUTING(路由后)。</p>
<img src="/Iptables_img/29.png" style="zoom:80%">
<h2 id="链"><a class="markdownIt-Anchor" href="#链"></a> 链</h2>
<ol>
<li>防火墙的功能是对经过的报文匹配规则，然后执行对应的动作。对于每个关卡，都不止一条规则，故称为链。</li>
</ol>
<h2 id="表"><a class="markdownIt-Anchor" href="#表"></a> 表</h2>
<ol>
<li>表：我们把具有相同功能的规则的集合叫做表。</li>
<li>iptables预定义了四种表
<ol>
<li>filter表：负责过滤功能，防火墙；内核模块：iptables_filter</li>
<li>nat表：负责网络地址转换功能。内核模块：iptable_nat</li>
<li>mangle表：拆解报文，做出修改，并重新封装的功能；iptables_mangle</li>
<li>raw表：关闭nat表上启用的连接追踪机制；iptable_raw<br />
也就是说，我们自定义的所有规则都是这四种分类中的规则。</li>
</ol>
</li>
</ol>
<h2 id="表链关系"><a class="markdownIt-Anchor" href="#表链关系"></a> 表链关系</h2>
<ol>
<li>prerouting：规则存在于raw,mangle,nat.</li>
<li>INPUT:规则存在于mangle,filter.</li>
<li>FORWARD:规则存在于mangle,filter.</li>
<li>OUTPUT:规则存在于raw,mangle,nat,filter.</li>
<li>POSTROUTING:规则存在于mangle,nat.</li>
<li>实际使用中，往往以表为入口，对规则进行定义。</li>
<li>表链关系：<br />
<img src="/Iptables_img/31.png" style="zoom:80%"></li>
<li>表的优先级：raw&gt;mangle&gt;nat&gt;filter</li>
<li>我们也可以在某个表中创建自定义链，将针对某个应用程序所设置的规则放置在这个自定义链中，但是自定义链接不能直接使用，之恶能被某个默认的链当作动作去调用才能起作用。</li>
</ol>
<h2 id="数据经过防火墙的流程"><a class="markdownIt-Anchor" href="#数据经过防火墙的流程"></a> 数据经过防火墙的流程</h2>
<img src="/Iptables_img/32.png" style="zoom:80%">
<h2 id="规则"><a class="markdownIt-Anchor" href="#规则"></a> 规则</h2>
<ol>
<li>规则：根据指定的匹配条件来尝试匹配每个流经此处的报文，一旦匹配成功，则由规则后面指定的处理动作进行处理。</li>
</ol>
<h1 id="iptables实际操作之规则查询"><a class="markdownIt-Anchor" href="#iptables实际操作之规则查询"></a> iptables实际操作之规则查询</h1>
<ol>
<li><strong>命令</strong> iptables -t filter -L
<ol>
<li>-t指定要操作的表</li>
<li>-L列出规则</li>
</ol>
</li>
<li>如果我们要定义过滤规则，那么我们会在filter中定义，但是具体在那条链上实现，取决于我们的工作场景。</li>
<li>举例：
<ol>
<li>我们需要禁止某个IP地址访问我们的主机，我们则需要在INPUT链上定义规则</li>
</ol>
</li>
<li><strong>命令</strong> iptables -t filter -vL INPUT 查看详细信息
<ol>
<li>pkts 对应规则匹配到的报文的个数</li>
<li>bytes 对应匹配到的报文包的大小总和。</li>
<li>target 往往表示规则对应的动作，即匹配成功后需要采取的措施。</li>
<li>prot 表示规则对应的协议，是否只针对某些协议应用次规则。</li>
<li>opt 表示规则对应的选项。</li>
<li>in 表示数据包由哪个接口流入，我们可以设置通过哪块网卡流入的报文需要匹配当前规则。</li>
<li>out 表示数据包由哪个接口流出，我们可以设置通过哪块网卡流出的报文需要匹配当前规则。</li>
<li>source 表示规则对应的源地址，可以时一个IP，也可以是一个网段。</li>
<li>destination 表示规则对应的目的地址。可以是一个IP也可以是一个网段。</li>
</ol>
</li>
<li><strong>命令</strong> iptables -nvl INPUT不进行名称反解。</li>
<li><strong>命令</strong> iptables --line-number -nvL INPUT</li>
<li>命令小节<br />
<img src="/Iptables_img/33.png" style="zoom:80%"></li>
</ol>
<img src="/Iptables_img/34.png" style="zoom:80%">
<h1 id="iptables规则管理"><a class="markdownIt-Anchor" href="#iptables规则管理"></a> iptables规则管理</h1>
<ol>
<li><strong>命令</strong> iptables -F INPUT 清空规则</li>
<li><strong>如果报文已经被前面的规则匹配到，iptables则会对报文执行相应动作，即使后面的规则也能匹配到当前报文，也没有机会对报文执行修改</strong></li>
<li>使用修改指令的时候，如果我拒绝某个源地址发来的包，但是修改时又没有指定对应的源地址，那么源地址会自动编程0.0.0.0，如果是为远程服务器配置iptables，那么正在使用的链接也会和中断。</li>
<li>REGECT&amp;DROP
<ol>
<li>DROP丢弃而不返回，ping命令所在机器永远得不到回应</li>
<li>REGECT 返回拒绝，通知目的端不可达。</li>
</ol>
</li>
<li></li>
</ol>
<img src="/Iptables_img/35.png" style="zoom:80%">
<img src="/Iptables_img/36.png" style="zoom:80%">
<img src="/Iptables_img/37.png" style="zoom:80%">
<img src="/Iptables_img/38.png" style="zoom:80%">
<h1 id="匹配条件总结"><a class="markdownIt-Anchor" href="#匹配条件总结"></a> 匹配条件总结</h1>
<h2 id="-s参数匹配源地址"><a class="markdownIt-Anchor" href="#-s参数匹配源地址"></a> -s参数：匹配源地址</h2>
<ol>
<li>可以是由逗号隔开的多个参数</li>
<li>可以通过指定子网掩码来指定某个网段</li>
<li>可以对某个地址取反，达到白（黑）名单的目的。但是存在问题，比如链上规则设定为不是某个源即进行-j操作；如果是，则继续匹配其他条件（都不匹配，则执行默认操作）。</li>
</ol>
<h2 id="-d参数匹配目的地址"><a class="markdownIt-Anchor" href="#-d参数匹配目的地址"></a> -d参数：匹配目的地址</h2>
<p><strong>取反操作与同时指定多个IP的操作不能同时使用</strong></p>
<h2 id="-p参数匹配协议类型"><a class="markdownIt-Anchor" href="#-p参数匹配协议类型"></a> -p参数：匹配协议类型</h2>
<ol>
<li>
<p>例如拒绝tcp请求</p>
<p>iptables -I INPUT -s 192.168.1.146 -d 192.168.1.156 -p tcp -j REJECT</p>
<p>使用ssh链接测试</p>
</li>
<li>
<p>-p支持的协议类型：</p>
<ol>
<li>tcp,udp,udplite,icmp,icmpv6,esp,ah,sctp,mh</li>
<li>缺省形况下，默认为-p all</li>
</ol>
</li>
</ol>
<h2 id="-i参数匹配流入的网卡-o匹配流出的网卡"><a class="markdownIt-Anchor" href="#-i参数匹配流入的网卡-o匹配流出的网卡"></a> -i参数：匹配流入的网卡 -o匹配流出的网卡</h2>
<ol>
<li>通过ifconfig查询</li>
<li>-i 网卡名 来指定匹配</li>
<li>只能用来判断流入的包，故用于
<ol>
<li>ROUTING 链</li>
<li>INPUT 链</li>
<li><strong>FORWARD 链</strong></li>
</ol>
</li>
<li>-o 用于匹配报文从哪个网卡流出，用于
<ol>
<li>OUTPUT 链</li>
<li><strong>FORWARD 链</strong></li>
<li>POSTROUTING 链</li>
</ol>
</li>
</ol>
<h2 id="-dport-扩展目的端口"><a class="markdownIt-Anchor" href="#-dport-扩展目的端口"></a> -dport 扩展目的端口</h2>
<ol>
<li>dport(destination-port)
<ol>
<li><strong>使用dport之前必须先使用-p选项</strong></li>
<li>之后使用-m指定扩展模块，缺省情况下，默认为于-p指定的协议同名。</li>
<li>最后，使用-dport指定目标端口</li>
</ol>
</li>
</ol>
<h2 id="-sport匹配源端口"><a class="markdownIt-Anchor" href="#-sport匹配源端口"></a> -sport:匹配源端口</h2>
<ol>
<li>不管是sport还是dport都可以指定端口范围，如22：25</li>
<li>multiport模块：
<ol>
<li>若要指定离散的端口，需要借助multiport模块。端口号间以逗号隔开。并且，这些端口中可以包含连续端口号。</li>
<li><strong>只有tcp,udp可以使用</strong></li>
</ol>
</li>
</ol>
<p>##<a href="%22http://www.zsythink.net/archives/1544%22">基本匹配条件总结</a></p>
<p>#<a href="%22http://www.zsythink.net/archives/1564%22">常用扩展模块</a></p>
<h2 id="iprange-扩展模块"><a class="markdownIt-Anchor" href="#iprange-扩展模块"></a> iprange 扩展模块</h2>
<ol>
<li>用于指定一系列连续的ip。包括–src-range,–dst-range。</li>
</ol>
<h2 id="string-扩展模块"><a class="markdownIt-Anchor" href="#string-扩展模块"></a> string 扩展模块</h2>
<ol>
<li>
<p>用于匹配含有某一个字符串的报文。</p>
<p>iptables -t filter -I INPUT -m string --algo bm --string “OOXX” -j REJECT</p>
<ol>
<li>-m 用于指定模块</li>
<li>–algo bm 表示用bm算法匹配。</li>
</ol>
</li>
</ol>
<h2 id="time-扩展模块"><a class="markdownIt-Anchor" href="#time-扩展模块"></a> time 扩展模块</h2>
<ol>
<li>
<p>用于限制时间</p>
<p>iptables -t filter -I OUTPUT -p tcp -dport 80 -m time --timestart 09:00:00 --timestop 18:00:00 -j REJECT</p>
<ol>
<li>可以使用timestart 和timestop 来指定起止时间。也可以通过weekdays 来指定某一天,多个天之间通过逗号隔开。也可以结合使用。</li>
<li>此外还有monthdays,datestart和datestop</li>
</ol>
</li>
</ol>
<h2 id="connlimit-扩展模块"><a class="markdownIt-Anchor" href="#connlimit-扩展模块"></a> connlimit 扩展模块</h2>
<ol>
<li>
<p>用于限制每个IP地址同时连接到server的数量。</p>
<p>iptables -I INPUT -p tcp --dport 803 -m connlimit --connlimit-above 2 -j REJECT</p>
<ol>
<li>限制每个IP最多只能让两个ssh连接到server。</li>
</ol>
</li>
<li>
<p>其实还可以配合–connlimit-mask去限制某类网段的链接数量</p>
<p>iptables -I INPUT -p tcp --dport 22 -m conlimit --connlimit-above 2 --connlimit-mask 24 -j REJECT</p>
</li>
</ol>
<h2 id="limit-扩展模块"><a class="markdownIt-Anchor" href="#limit-扩展模块"></a> limit 扩展模块</h2>
<p>对报文到达速率进行限制，即限制单位时间内流入的包的数量。</p>
<ol>
<li>iptables -t filter -I INPUT -p icmp -m limit --limit 10/minute -j ACCEPT</li>
</ol>
<p>表示每分钟最多放10个包，相当于每6秒最多放一个包。<br />
然而这样遂率并没有变，是因为第六秒的报文确实被策略匹配到了，于是执行了放行操作，但是6秒钱的报文没有被匹配到，于是自动执行默认策略，也是放行。<br />
<strong>修改</strong>：iptables -t filter -A INPUT -p icmp -j REJECT</p>
<ol start="2">
<li>
<p>–limit-burst 选项用于指明空闲时放行包的数量，默认为5.</p>
</li>
<li>
<p>limit模块工作原理：令牌桶算法<br />
想象有一个木桶，里面放了5块令牌，且目前这个桶中最多只能存放5个令牌。所有报文想要出关入关，都必须持有木桶中的令牌，这个木桶可以每6秒生成一个新的令牌。此时，如果桶已经满了，那么新生成的令牌就被丢弃。假设现在有五个报文想要进入，那么这5个报文就会去桶中找令牌，正好一人一个。此时，如果再有令牌想要进入，则没有对应的令牌可以使用。如果长时间没有人使用令牌，令牌桶中又出现了5枚令牌，也就是所谓的空闲。</p>
</li>
</ol>
<p>#<a href="%22http://www.zsythink.net/archives/1578%22">iptables 扩展匹配条件 -tcp-flags</a></p>
<p>用于匹配tcp头部的标志位，然后根据标识位的实时情况进行实时访问控制功能。</p>
<ol>
<li>
<p>iptables -t filter -I INPUT -p tcp -m tcp --dport 22 --tcp-flags SYN,ACK,FIN,RST,URG,PSH SYN -j REJECT</p>
<ol>
<li>SYN,ACK,FIN,RST,URG,PSH 表示需要匹配报文tcp头部的标志位列表</li>
<li>第二个SYN处表示，要求为1的标志位列表。不出现的标志位必须为0。</li>
<li>这条命令是拒绝tcp第一次链接。</li>
<li>可以使用-syn代替这一段。</li>
</ol>
</li>
<li>
<p>iptables -t filter -I INPUT -p tcp -m tcp --dport 22 --tcp-flags SYN,ACK,FIN,RST,URG,PSH SYN，ACK -j REJECT</p>
</li>
</ol>
<p>#<a href="%22http://www.zsythink.net/archives/1588%22">iptables udp扩展与icmp扩展</a></p>
<h2 id="udp-扩展"><a class="markdownIt-Anchor" href="#udp-扩展"></a> udp 扩展</h2>
<ol>
<li>iptables -t filter -I INPUT -p udp -m udp --dport 137 -j ACCEPT
<ol>
<li>137为端口号，samba服务的端口为137，138</li>
<li>可以指定连续的端口号 137:157</li>
</ol>
</li>
</ol>
<h2 id="icmp-扩展"><a class="markdownIt-Anchor" href="#icmp-扩展"></a> icmp 扩展</h2>
<img src="/Iptables_img/51.png" style="zoom:80%">
<ol>
<li>
<p>可以指定匹配的类型和code</p>
<p>iptables -t filter -I INPUT -p icmp -m icmp --icmp-type3/1 -j REJECT</p>
<p>表示拒绝主机不可达报文</p>
</li>
<li>
<p>还可以用icmp报文的描述名称去匹配对应类型的报文</p>
<p>iptables -t filter -I INPUT -p icmp --icmp-type “echo-request” -j REJECT</p>
</li>
</ol>
<p>#<a href="%22http://www.zsythink.net/archives/1597%22">iptables 扩展模块 state</a></p>
<p>当我们访问http时，需要放行80端口以便能够与服务端进行通信。进行ssh链接时，需要打开22端口。然而，这样并不安全，攻击者可以利用这些端口主动和我建立链接。使用state可以实现链接追踪功能。</p>
<h2 id="state基本概念"><a class="markdownIt-Anchor" href="#state基本概念"></a> state基本概念</h2>
<ol>
<li>连接：在state模块中，认为两台机器在你来我往的通信就算建立了连接。</li>
<li>连接状态包括：NEW,ESTABLISHED,RELATED,INVALID,UNTRACKED</li>
</ol>
<h2 id="指令"><a class="markdownIt-Anchor" href="#指令"></a> 指令</h2>
<ol>
<li>iptables -t filter -I INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
<ol>
<li>只有回应我们的报文能够通过防火墙。</li>
</ol>
</li>
</ol>
<p>#<a href="%22http://www.zsythink.net/archives/1604%22">iptables的黑白名单机制</a></p>
<ol>
<li>黑名单：链中设置规则的动作为drop或reject，默认动作是ACCEPT，那么匹配到规则的报文会被拒绝。</li>
<li>白名单：默认规则是DROP，链中规则的动作是ACCEPT，则被匹配到的报文才会放行，即白名单机制。</li>
</ol>
<h2 id="白名单"><a class="markdownIt-Anchor" href="#白名单"></a> 白名单</h2>
<p>#iptables -P INPUT DROP</p>
<p>#iptables -I INPUT -p tcp --dport 22 -j ACCEPT</p>
<p>#iptables -I INPUT -p tcp<br />
–dport 80 -j ACCEPT</p>
<ol>
<li>注意-F选项只是将链中规则情况，此处修改了默认规则，所以即使-F也会DROP；</li>
<li><strong>改进</strong>：将链的设置保持为ACCEPT，然后将拒绝所有请求的规则放在链尾，将放行规则放在签名，这样既实现了白名单，又保证规则清空时，管理员能够连接到主机。</li>
</ol>
<p>#iptables -I INPUT -p tcp --dport 22 -j ACCEPT</p>
<p>#iptables -I INPUT -p tcp --dport 80 -j ACCEPT</p>
<p># iptables -A INPUT -j REJECT</p>
<p>#<a href="%22http://www.zsythink.net/archives/1625%22">iptables 自定义链</a></p>
<p>由于默认链的规则非常 多，不便于管理，所以引入自定义链。</p>
<h2 id="创建自定义链"><a class="markdownIt-Anchor" href="#创建自定义链"></a> 创建自定义链</h2>
<ol>
<li>iptables -t filter -N IN_WEB</li>
</ol>
<h2 id="使用自定义链"><a class="markdownIt-Anchor" href="#使用自定义链"></a> 使用自定义链</h2>
<ol>
<li>必须被默认链引用</li>
<li>iptables -I INPUT -p tcp --dport 80 -j IN WEB</li>
<li>自定义链也可以引用其他的自定义链</li>
</ol>
<h2 id="自定义链重命名"><a class="markdownIt-Anchor" href="#自定义链重命名"></a> 自定义链重命名</h2>
<p>iptables -E IN_WEB WEB</p>
<h2 id="删除自定义链"><a class="markdownIt-Anchor" href="#删除自定义链"></a> 删除自定义链</h2>
<ol>
<li>如果被引用，则要iptables -D INPUT 1</li>
<li>如果链种含有规则，则要Iptables -t filter -F WEB</li>
<li>iptables -X WEB</li>
</ol>
<p>#<a href="%22http://www.zsythink.net/archives/1663%22">网络防火墙</a></p>
<ol>
<li>定义：处于网络入口或边缘，针对于网络入口进行防护，服务于防火墙背后的本地局域网。主要任务时过滤并转发。</li>
<li>涉及：INPUT,OUTPUT,FORWARD</li>
</ol>
<h2 id="环境准备"><a class="markdownIt-Anchor" href="#环境准备"></a> 环境准备</h2>
<ol>
<li>
<p>PC1：</p>
<ol>
<li>192.18.33.33</li>
<li>route add -net 192.18.22.0/24 gw 192.18.33.251</li>
</ol>
</li>
<li>
<p>PC2:</p>
<ol>
<li>192.18.22.22</li>
<li>route add -net 192.18.33.0/24 gw 192.18.22.251</li>
</ol>
</li>
<li>
<p>r1:</p>
<ol>
<li>ens33:192.18.33.251</li>
<li>ens37:192.18.22.251</li>
<li>cat /proc/sys/net/ipv4/ip_forward 来查看是否支持转发功能。</li>
<li>每次需要echo 1 &gt; /proc/sys/net/ipv4/ip_forward来开启转发功能</li>
</ol>
</li>
</ol>
<p>#<a href="%22http://www.zsythink.net/archives/1684%22">iptables 动作总结</a></p>
<h2 id="reject"><a class="markdownIt-Anchor" href="#reject"></a> REJECT</h2>
<ol>
<li>–reject-with :提示拒绝原因。包括：
<ol>
<li>icmp-net-unreachable</li>
<li>icmp-host-unreachable</li>
<li>icmp-port-unreachable</li>
<li>icmp-proto-unreachable(默认)</li>
<li>icmp-net-prohibited</li>
<li>icmp-host-pro-hibited</li>
<li>icmp-admin-prohibited</li>
</ol>
</li>
</ol>
<h2 id="log"><a class="markdownIt-Anchor" href="#log"></a> LOG</h2>
<ol>
<li>
<p>LOG 可以将符合条件的报文的相关信息记录到日志中。可以在后面设置具体规则对报文进一步处理。</p>
</li>
<li>
<p>可以通过tail -f /var/log/messages 来查看。</p>
</li>
<li>
<p>–log-level 来指定日志的日志级别。包括</p>
<ol>
<li>emerg</li>
<li>alert</li>
<li>crit</li>
<li>error</li>
<li>warning</li>
<li>notice</li>
<li>info</li>
<li>debug</li>
</ol>
</li>
<li>
<p>–log-prefix 来给记录到的相关信息添加标签之类的信息，以区分各种记录到的报文。</p>
</li>
</ol>
<p>iptables -I INPUT -p tcp --dport 80 -m state --state NEW -j LOG --log-prefix “want-in-from-22”<br />
#<a href="%22http://www.zsythink.net/archives/1764%22">iptables 动作总结2</a></p>
<h2 id="snat"><a class="markdownIt-Anchor" href="#snat"></a> SNAT</h2>
<p>iptables -t nat -A POSTROUTING -s 192.18.0.0/16 -j SNAT --to-source 192.18.33.251</p>
<ol>
<li>其中-A 标识将snat规则添加到POSTROUTING链的末尾。POSTROUTING可以认为是报文发出的最后一个关卡。</li>
<li>-j SNAT表示对匹配到的报文进行源地址转换。</li>
<li>–to-source表示转换成这个源</li>
</ol>
<h2 id="dnat"><a class="markdownIt-Anchor" href="#dnat"></a> DNAT</h2>
<p>按端口进行转发</p>
<ol>
<li>
<p>iptables -t nat -I PREROUTING -d 192.18.33.251 -p tcp --dport 801 -j DNAT --to-destination 192.18.22.22:80</p>
</li>
<li>
<p>注：开启端口/sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT</p>
</li>
</ol>
<h2 id="masquerade"><a class="markdownIt-Anchor" href="#masquerade"></a> MASQUERADE</h2>
<p>动态的将源地址转换为可用的IP地址。类似于SNAT而无需指明修改成哪个IP，可以适应动态变化。</p>
<ol>
<li>iptables -t nat -I POSTROUTING -s 192.18.0.0/16 -o ens33 -j MASQUERADE</li>
</ol>
<h2 id="redirect"><a class="markdownIt-Anchor" href="#redirect"></a> REDIRECT</h2>
<p>可以将本机端口进行映射。</p>
<ol>
<li>iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 801</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Iptables实验目录" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/Iptables%E5%AE%9E%E9%AA%8C%E7%9B%AE%E5%BD%95/"
    >Iptables实验目录</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/Iptables%E5%AE%9E%E9%AA%8C%E7%9B%AE%E5%BD%95/" class="article-date">
  <time datetime="2020-03-30T02:36:52.223Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="iptablesexp基础"><a class="markdownIt-Anchor" href="#iptablesexp基础"></a> <a href="/2020/03/30/iptables">IptablesExp基础</a></h2>
<h2 id="实验详情见代码仓库"><a class="markdownIt-Anchor" href="#实验详情见代码仓库"></a> <a href="https://github.com/Cccceb/BTF.git">实验详情见代码仓库</a></h2>
<p>​	本次实验通过设置 iptables 规则，来实现防火墙功能。iptables 本身不是</p>
<p>防火墙，它可以理解为一个客户端代理，通过 iptables 来设定规则，最终运行</p>
<p>在 netfilter 框架下。</p>
<p>​	Iptables 中有四链五表，用来过滤所有进出的报文。防火墙的功能是对经过</p>
<p>的报文匹配规则，然后执行对应的动作。对于每个关卡，都不止一条规则，故称</p>
<p>为链。将那些具有相同规则的集合叫做表。链包括 INPUT、OUTPU、PREROURING(路</p>
<p>由前)、FORWARD(转发)、POSTROUTING(路由后)。同时，在 iptables 中预定义了</p>
<p>四种表，分别是负责过滤的 filter 表、负责网络地址转换的 nat 表、负责拆解</p>
<p>报文做出修改的 mangle 表以及关闭 nat 表上启用的连接追踪机制的 raw 表。本</p>
<p>次实验中主要涉及了前两个表。</p>
<p>​	通过本次实验，学习了很多关于 iptables 以及网络、安全方面的知识。我</p>
<p>将学到的知识治理成以下三个实验内容：主机防火墙、网络防火墙、NAT 转换。</p>
<p>在理论课的过程中，老师经常提及 Dos 攻击。所以，在学习了 socket 编程</p>
<p>之后，用 C 语言实现了两台虚拟机之间建立 TCP 连接。最终模拟了防御 Dos 攻击</p>
<p>的情况，形成了实验四。</p>
<p>​	总的来说，本次实验我递进式的做了四个实验，分别是主机防火墙、网络防</p>
<p>火墙、NAT 动作、TCP 连接与 DoS 防御。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/9/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/11/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        CuiEnbo
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt=""></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['', '', ''],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: false
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>