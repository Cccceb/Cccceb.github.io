<!DOCTYPE html>


<html lang="cn" >


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

  <script type="text/javascript"
	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/Bg.png" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/"></a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-修改天平" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E4%BF%AE%E6%94%B9%E5%A4%A9%E5%B9%B3/"
    >修改天平</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E4%BF%AE%E6%94%B9%E5%A4%A9%E5%B9%B3/" class="article-date">
  <time datetime="2020-03-30T02:15:00.717Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva12166-修改天平括号表示法给出树"><a class="markdownIt-Anchor" href="#uva12166-修改天平括号表示法给出树"></a> uva12166 修改天平	(括号表示法给出树)</h1>
<p>给出一个深度不超过16的二叉树，代表一个天平。每根杆都悬挂在中间，每个秤砣的重量已知。至少修改多少个秤砣的重量才能让天平平衡？</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>思考如何使得修改的天平最少：保证让总重量最多的秤砣不变。</li>
<li>用sum记录总的秤砣个数，用base记录每个对应重量的秤砣数。注意秤砣重量与所在高度有关，重w的秤砣在depth深处的总重量为w&lt;&lt;depth</li>
<li>括号表示法给出树的结构可以参考本题</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<pre class="highlight"><code class="">    #include&lt;bits/stdc++.h&gt;
    # pragma warning(disable:4996)
    # define LOCAL
    # ifdef LOCAL
    FILE *fin = freopen(&quot;习题6-6in.txt&quot;, &quot;r&quot;, stdin);
    FILE *fout = freopen(&quot;习题6-6out.txt&quot;, &quot;w&quot;, stdout);
    # endif 
    using namespace std;
    int T;
    string s;
    int sum;
    map&lt;long long, int&gt; base;
    void dfs(int depth, int p, int e) {
    	if (s[p] == '[') {
		int not_ok = 0;
		for (int i = p + 1; i != e; i++) {
			if (s[i] == '[') not_ok++;
			if (s[i] == ']') not_ok--;
			//注意此处脱括号的方法非常灵性
			if (!not_ok&amp;&amp;s[i] == ',') {
				dfs(depth + 1, p + 1, i - 1);
				dfs(depth + 1, i + 1, e - 1);
			}
		}
	}
	else {
		long long w = 0;
		for (int i = p; i &lt;= e; i++)
			w = w * 10 + s[i] - '0';
		++sum;
		++base[w &lt;&lt; depth];//sum统计砝码总数量，base[w&lt;&lt;depth]统计该总重量对应的砝码个数

	}
	}
	int main() {
	cin &gt;&gt; T;
	while (T--)
	{
		cin &gt;&gt; s;
		sum = 0;
		base.clear();
		dfs(0, 0, s.length() - 1);
		int maxn = 0;
		for (auto it = base.begin(); it != base.end(); it++)
			maxn = max(maxn, it-&gt;second);
		cout &lt;&lt; sum - maxn &lt;&lt; endl;
	}
	}</code></pre>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-唯一的雪花" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%94%AF%E4%B8%80%E7%9A%84%E9%9B%AA%E8%8A%B1/"
    >唯一的雪花</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%94%AF%E4%B8%80%E7%9A%84%E9%9B%AA%E8%8A%B1/" class="article-date">
  <time datetime="2020-03-30T02:15:00.717Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-11572-唯一的雪花"><a class="markdownIt-Anchor" href="#uva-11572-唯一的雪花"></a> UVA 11572 唯一的雪花</h1>
<p>求最长连续无重复子序列。输入：第一行给出样例数，对于每组数据，第一行给出序列长度n，之后n行给出每个元素的值。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>滑动窗口：优先向右扩展，如果A[R+1]已存在，那么增大L。这是因为L-R是解的情况下，增大L也必然是解，所以R不必动。</li>
<li>判断是否出现过，可以使用set(240ms),map(270ms),数组(1140ms)
<ol>
<li>set的查询，插入，删除的复杂度都是O(nlogn)</li>
<li>map[i]来记录元素i上次出现的下标，并更新到数组last。后面，如果上一次出现的下标不在目前的搜索范围内，那么可以扩展。</li>
<li>数组法可能是因为数组太大，所以速度太慢。</li>
</ol>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000000 + 5;</span><br><span class="line">int A[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int T, n;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">  while(T--) &#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;A[i]);</span><br><span class="line"></span><br><span class="line">    set&lt;int&gt; s;</span><br><span class="line">    int L &#x3D; 0, R &#x3D; 0, ans &#x3D; 0;</span><br><span class="line">    while(R &lt; n) &#123;</span><br><span class="line">      while(R &lt; n &amp;&amp; !s.count(A[R])) s.insert(A[R++]);</span><br><span class="line">      ans &#x3D; max(ans, R - L);</span><br><span class="line">      s.erase(A[L++]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="map"><a class="markdownIt-Anchor" href="#map"></a> map</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000000 + 5;</span><br><span class="line">int A[maxn], last[maxn];</span><br><span class="line">map&lt;int, int&gt; cur;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int T, n;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">  while(T--) &#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    cur.clear();</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">      scanf(&quot;%d&quot;, &amp;A[i]);</span><br><span class="line">      if(!cur.count(A[i])) last[i] &#x3D; -1;</span><br><span class="line">      else last[i] &#x3D; cur[A[i]];</span><br><span class="line">      cur[A[i]] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int L &#x3D; 0, R &#x3D; 0, ans &#x3D; 0;</span><br><span class="line">    while(R &lt; n) &#123;</span><br><span class="line">      while(R &lt; n &amp;&amp; last[R] &lt; L) R++;</span><br><span class="line">      ans &#x3D; max(ans, R - L);</span><br><span class="line">      L++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1e9 + 5;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int in[1000005];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		int n;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;in[i]);</span><br><span class="line">		int L &#x3D; 0, R &#x3D; 0, ans &#x3D; 0;</span><br><span class="line">		while (L &lt;&#x3D; R &amp;&amp; R &lt; n)</span><br><span class="line">		&#123;</span><br><span class="line">			if (!vis[in[R]]) &#123; vis[in[R]] &#x3D; 1; R++; &#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				ans &#x3D; max(ans, R - L);</span><br><span class="line">				vis[in[L]] &#x3D; 0; L++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, max(ans, R - L));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-小球下落" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%B0%8F%E7%90%83%E4%B8%8B%E8%90%BD/"
    >小球下落</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%B0%8F%E7%90%83%E4%B8%8B%E8%90%BD/" class="article-date">
  <time datetime="2020-03-30T02:15:00.717Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-679-小球下落"><a class="markdownIt-Anchor" href="#uva-679-小球下落"></a> uva 679 小球下落</h1>
<p> 许多的小球一个一个的从一棵满二叉树上掉下来组成一个新满二叉树，每一时间，一个正在下降的球第一个访问的是非叶子节点。然后继续下降时，或者走右子树，或者走左子树，直到访问到叶子节点。<br />
决定球运动方向的是每个节点的布尔值。最初，所有的节点都是 FALSE，当访问到一个节点时，如果这个节点是 FALSE，则这个球把它变成 TRUE，然后从左子树走，继续它的旅程。如果节点是TRUE，则球也会改变它为 FALSE，而接下来从右子树走。满二叉树的标记方法如下图。<br />
因为所有的节点最初为 FALSE，所以第一个球将会访问节点 1，节点 2 和节点 4，转变节点的布尔值后在在节点 8 停止。第二个球将会访问节点 1、3、6，在节点 12 停止。；明显地，第三个球在它停止之前，会访问节点 1、2、5，在节点 10 停止。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>对于二叉树，有结论编号为i的节点的左子树编号为2i,右子树为2i+1</li>
<li>如果用一个数组存二叉树，并进行遍历，会TEL，并且数组占很大空间</li>
<li>发现只要知道是第几个通过该节点的小球，那么就可以知道这一步他落到左子树还是右子树</li>
<li>如果I为奇数，那么他是第（I+1）/2个向左走的小球，如果I为偶数，那么他是第I/2个向右走的小球。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   #include&lt;iostream&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;小球下落in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;小球下落out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   int main() &#123;</span><br><span class="line">int T;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">while (T--) &#123;</span><br><span class="line">	int num, depth;</span><br><span class="line">	cin &gt;&gt; depth &gt;&gt; num;</span><br><span class="line">	int No &#x3D; 1;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; depth-1; i++) &#123;</span><br><span class="line">		if (num % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">			No &#x3D; 2 * No;</span><br><span class="line">			num &#x3D; (num + 1) &#x2F; 2;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			No &#x3D; 2 * No + 1;</span><br><span class="line">			num &#x3D; num &#x2F; 2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; No &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<ol>
<li>关注该关注的，并找规律很重要</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-巡逻机器人" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%B7%A1%E9%80%BB%E6%9C%BA%E5%99%A8%E4%BA%BA/"
    >巡逻机器人</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%B7%A1%E9%80%BB%E6%9C%BA%E5%99%A8%E4%BA%BA/" class="article-date">
  <time datetime="2020-03-30T02:15:00.717Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva1600-巡逻机器人"><a class="markdownIt-Anchor" href="#uva1600-巡逻机器人"></a> uva1600 巡逻机器人</h1>
<p>本题有t组数据，每组数据包含一个m*n的01矩阵，0表示能走，1表示有一个障碍物。机器人能往上下左右四个方向走动.它要从(1,1)到(m,n),可以连续翻越k个障碍物,求它从(1,1)到(m,n)的最短路径.如果不能到达输出&quot;-1&quot;.</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>本题基础是一个bfs，附加可以跳跃0的条件。</li>
<li>对无权图进行bfs的时候，走到每一个点时的步数都是一定的，所以对于每个点，应该让能够跨越障碍的机会越多越好，所以Node节点中应该包含(r,c,k,step)其中k为到达(r,c)位置时剩余的跨越障碍的机会，step为最小步数。(※如果只需要知道步数而不需要路径，则将其包在结构体里即可)</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<pre><code>#include&lt;bits/stdc++.h&gt;
# pragma warning(disable:4996)
# define LOCAL
# ifdef LOCAL
FILE *fin = freopen(&quot;习题6-5in.txt&quot;, &quot;r&quot;, stdin);
FILE *fout = freopen(&quot;习题6-5out.txt&quot;, &quot;w&quot;, stdout);
# endif 
using namespace std;
int n, x, y, k;
int g[20][20];
struct node {
	int r, c, k, step;

	node(int r, int c, int k, int step = 0) :r(r), c(c), k(k), step(step) {}
};
int step[20][20];
int dr[] = { 1, 0, -1, 0 };
int dc[] = { 0, 1, 0, -1 };
int min_step;
void bfs() {
	queue&lt;node&gt;q;
	q.push(node(0, 0, k));
	int block = 0;
	while (!q.empty()) {
		node u = q.front(); q.pop();

		if (u.r == x - 1 &amp;&amp; u.c == y - 1) {
			min_step = u.step;
			break;
		}
		for (int i = 0; i &lt; 4; i++) {
			int r = u.r + dr[i], c = u.c + dc[i];
			if (r &gt;= 0 &amp;&amp; r &lt; x&amp;&amp;c &gt;= 0 &amp;&amp; c &lt; y) {
				if (step[r][c] &lt; u.k) {//u.k是走到step[r][c]处，还剩余的跳过障碍的机会，所以要保留大的
					step[r][c] = u.k;
				}
				else continue;//如果step[r][c]更大，说明目前正在走的路不是最好的(因为bfs走到每个节点的步数是一定的
							  //所以剩余的跨越障碍的次数越多越好),不需要再走下去，所以不入队)
				if (g[r][c] == 0) q.push(node(r, c, k, u.step + 1));
				else if(u.k) q.push(node(r, c, u.k - 1, u.step + 1));
			}
		}
	}
}
int main() {
cin &gt;&gt; n;
while (n--) {

	memset(g, 0, sizeof(g));
	memset(step, -1, sizeof(step));
	cin &gt;&gt; x &gt;&gt; y;
	cin &gt;&gt; k;
	for (int i = 0; i &lt; x; i++)
		for (int j = 0; j &lt; y; j++)
			cin &gt;&gt; g[i][j];
	min_step = 999;
	bfs();
	min_step == 999 ? cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl:cout &lt;&lt; min_step &lt;&lt; endl;
}
}</code></pre>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-消防车" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E6%B6%88%E9%98%B2%E8%BD%A6/"
    >消防车</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E6%B6%88%E9%98%B2%E8%BD%A6/" class="article-date">
  <time datetime="2020-03-30T02:15:00.717Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-208-消防车"><a class="markdownIt-Anchor" href="#uva-208-消防车"></a> UVA 208 消防车</h1>
<p>给你一张图，输入x，y表示xy见有一条边。输出从1到z所有的遍历方案（字典序）。每个节点从1到N标号。 有多组数据，每组数据以0 0结束。 （注意，刚开始的输入不是节点或边的数目） 输入输出格式可以参考样例. 数据范围（节点总数N&lt;21）</p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<ol>
<li>本题要求输出所有的完整的路径，即要沿着一条路走到头，所以使用dfs</li>
<li>辅助用bfs判断依次是否存在路径，否则会超时</li>
<li>本题中各层的path之间不会影响，因为递归是走到头再返回的。</li>
</ol>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<pre><code>#include&lt;bits/stdc++.h&gt;
# pragma warning(disable:4996)
FILE *fin = freopen(&quot;习题7-1in.txt&quot;, &quot;r&quot;, stdin);
FILE *fout = freopen(&quot;习题7-1out.txt&quot;, &quot;w&quot;, stdout);
using namespace std;
const int maxn = 20+5;
map&lt;int, vector&lt;int&gt;&gt; g;
bool bfs();
void dfs(int u,int step);
int goal, cnt,kase = 0;
bool vis[maxn];
int path[maxn];
struct edge {
int x, y;
edge(int x, int y) :x(x), y(y) {}
bool operator &lt; (const edge&amp;a) const { return x &lt; a.x; }
};
int main() {
int a, b;
while (scanf(&quot;%d&quot;, &amp;goal) == 1) {
	g.clear();
	printf(&quot;CASE %d:\n&quot;, ++kase);
	while (scanf(&quot;%d %d&quot;, &amp;a, &amp;b) &amp;&amp; a) {
		g[a].push_back(b);
		g[b].push_back(a);
	}
	for (int i = 0; i &lt; maxn; i++)
		sort(g[i].begin(), g[i].end());
	cnt = 0;
	memset(vis, 0, sizeof(0));
	if (!bfs()) {//优化，否则会T
		cnt = 0;
	}
	else {
		vis[1] = 1;
		dfs(1,0);
	}
	printf(&quot;There are %d routes from the firestation to streetcorner %d.\n&quot;, cnt,goal);
}
}
bool bfs() {
queue&lt;int&gt; q;
q.push(1);
while (!q.empty()) {
	int u = q.front(); q.pop();
	if (u == goal) {
		memset(vis, 0, sizeof(vis));
		return true;
	}
	for (int i = 0; i &lt; g[u].size(); i++) {
		int v = g[u][i];
		if (!vis[v])
		{
			vis[v] = 1;
			q.push(v);
		}
	}
}
memset(vis, 0, sizeof(vis));
return false;
}
void dfs(int u,int step) {
path[step] = u;
if (u == goal) {
	printf(&quot;%d&quot;, path[0]);
	for (int i =1; i &lt;= step; i++)
		printf(&quot; %d&quot;, path[i]);
	printf(&quot;\n&quot;);
	cnt++;
}
for (int i = 0; i &lt; g[u].size(); i++) {
	int v = g[u][i];
	if (vis[v]) continue;
	vis[v] = 1;
	dfs(v,step+1);
	vis[v] = 0;
}
}
</code></pre>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-旋转游戏" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E6%97%8B%E8%BD%AC%E6%B8%B8%E6%88%8F/"
    >旋转游戏</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E6%97%8B%E8%BD%AC%E6%B8%B8%E6%88%8F/" class="article-date">
  <time datetime="2020-03-30T02:15:00.717Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-1343-旋转游戏"><a class="markdownIt-Anchor" href="#uva-1343-旋转游戏"></a> UVA 1343 旋转游戏</h1>
<img src="/计安导_img/1.png">
<p>现给定一个初始状态，请使用最少的操作次数，使 “# ” 形棋盘最中间的 888 个格子里的数字相同。输入包括不超过 303030 组测试数据。每个测试数据只包括一行，包含 242424 个整数，每相邻两个整数之间用 111 个空格隔开，表示这个 “# ” 形棋盘的初始状态。（这些整数的排列顺序是从上至下，同一行的从左至右。例如 1 1 1 1 3 2 3 2 3 1 3 2 2 3 1 2 2 2 3 1 2 1 3 3\text{1 1 1 1 3 2 3 2 3 1 3 2 2 3 1 2 2 2 3 1 2 1 3 3}1 1 1 1 3 2 3 2 3 1 3 2 2 3 1 2 2 2 3 1 2 1 3 3 表示图 111 最左边的状态。）每两组测试数据之间没有换行符。输入文件以一行 000 结束。对于每组测试数据，输出两行。第一行用字符 A∼H\text{A}\sim \text{H}A∼H 输出操作的方法，每两个操作字符之间没有空格分开，如果不需要任何步数，输出 No moves needed。第二行输出最终状态中最中间的 888 个格子里的数字。如果有多组解，输出操作次数最少的一组解；如果仍有多组解，输出字典序最小的一组。任意相邻两组测试数据的输出之间不需输出换行符。</p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<ol>
<li>
<p>典型的状态空间搜索，采用迭代加深搜的方法。</p>
</li>
<li>
<p><strong>IDA*模板题</strong></p>
</li>
<li>
<p>本题中要求中间8个数是相同的，而出现的数字又限定在1，2，3中。所以可以分三次求解，这样可以减少搜素空间。以目标为1为例，这时，将元素看作为1和非1的元素，那么状态总数就变成了8个1，16个非1的全排列，即24!/(8!*16!)。</p>
</li>
<li>
<p>其实本题中的state可以定义为bool型，因为只关心比如1和非1</p>
</li>
<li>
<p>关于剪枝</p>
<ol>
<li>最直接的，由于A-F/B-E/H-C/G-D相对，所以不能回滚上一层的操作。<strong>实现时使用op数组记录对应关系</strong></li>
<li>每次旋转至多引入一个新的元素，也就是说每次回滚只能增加一个相同的元素。所以如果当前的层数d加上中间8个数字中非当前目标的数字个数大于最大个数maxd时，需要进行剪枝。</li>
</ol>
</li>
<li>
<p>关于旋转：由于输入方式比较特殊，旋转的次序固定，所以把A-H中每个元素在输入串中出现的位置手动写出。旋转时只需要模7加即可。</p>
</li>
<li>
<p>相同的思路，将中间8个格出现的位置预先写出也可简化代码。</p>
</li>
<li>
<p>与编辑书稿有相似之处</p>
</li>
</ol>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<h3 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> dfs</h3>
<pre><code>bool dfs(int d) {
if (d == maxd) {
	if (not_equal(d) == 0) return true;
	else return false;
}
int next = d + 1;
if (d + not_equal(d) &gt; maxd) return false;
for (int i = 0; i &lt; 8; i++) {
	if (d &gt; 0 &amp;&amp; op[v[d-1]]== i) continue;

	v[d] = i;
	memcpy(state[next], state[d], 24 * sizeof(int));
	for (int j = 0; j &lt; 7; j++)
		state[next][move[i][j]] = state[d][move[i][(j + 1) % 7]];
	if (dfs(next)) return true;
}
return false;
}
</code></pre>
<h3 id="update-判断是否字典序更小"><a class="markdownIt-Anchor" href="#update-判断是否字典序更小"></a> update 判断是否字典序更小</h3>
<pre><code>bool update() {
if (ans[0] != -1)
	for (int i = 0; i &lt; maxd; i++)
		if (v[i] &gt; ans[i]) return false;
		else if (v[i] &lt; ans[i]) break;
memcpy(ans, v, sizeof(int)*maxd);
return true;
}
</code></pre>
<h3 id="not_equla-统计中间八格中与当前目标不等的元素个数"><a class="markdownIt-Anchor" href="#not_equla-统计中间八格中与当前目标不等的元素个数"></a> not_equla 统计中间八格中与当前目标不等的元素个数</h3>
<pre><code>int not_equal(int d) {
int ans = 0;
for (int i = 0; i &lt; 8; i++)
	if (state[d][mid[i]] != cur_nm)	ans++;
return ans;
}
</code></pre>
<h3 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h3>
<pre><code>int maxd;
int move[8][7] = {
{0,2,6,11,15,20,22},
{1,3,8,12,17,21,23},
{10,9,8,7,6,5,4},
{19,18,17,16,15,14,13},
{23,21,17,12,8,3,1},
{22,20,15,11,6,2,0},
{13,14,15,16,17,18,19},
{4,5,6,7,8,9,10}
};
int mid[8] = { 6,7,8,11,12,15,16,17 };
int op[8] = { 5,4,7,6,1,0,3,2 };
int state[50][24];
int ans[50], v[50];
int table[24];
inline int not_equal(int d);
bool dfs(int d);
inline bool update();
int cur_nm;
int main() {
while (true)
{
	memset(ans, -1, sizeof(ans));
	scanf(&quot;%d&quot;, &amp;table[0]);
	if (!table[0]) break;
	for (int i = 1; i &lt; 24; i++)
		scanf(&quot;%d&quot;, &amp;table[i]);
	int p = 0;
	for (maxd = 0;; maxd++) {
		for (cur_nm = 1; cur_nm &lt;= 3; cur_nm++) {
			memcpy(state[0], table, 24 * sizeof(int));
			if (dfs(0) &amp;&amp; update()) 
				p = cur_nm;
		}
		if (p) break;
	}
	if (maxd)
		for (int i = 0; i &lt; maxd; i++) printf(&quot;%c&quot;, ans[i] + 'A');
	else printf(&quot;No moves needed&quot;);
	printf(&quot;\n%d\n&quot;, p);
}
}</code></pre>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-万圣节后的早晨" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E4%B8%87%E5%9C%A3%E8%8A%82%E5%90%8E%E7%9A%84%E6%97%A9%E6%99%A8/"
    >万圣节后的早晨</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E4%B8%87%E5%9C%A3%E8%8A%82%E5%90%8E%E7%9A%84%E6%97%A9%E6%99%A8/" class="article-date">
  <time datetime="2020-03-30T02:15:00.701Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-1601-万圣节后的早晨"><a class="markdownIt-Anchor" href="#uva-1601-万圣节后的早晨"></a> UVA 1601 万圣节后的早晨</h1>
<p>w h （w, h &lt;= 16)的网格有 n （ n &lt;= 3) 个小写字母（代表鬼）其余的是‘# ’（代表障碍格） 或 ‘ ’（代表空格。 要求把他们移动到对应的大写字母里。每步可以有多少个鬼同时移动（均为上下左右4个移动方向之一）， 但每步移动两个鬼不能占用同一个位置， 也不能在一步之内交换位置。输入保证空格联通，障碍联通，且在2 2子网格中至少有一个障碍格，并且最外面一层是障碍格。输入保证有解。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>是隐式图最短路径问题，通过bfs求解最短路径即可。</li>
<li>由于鬼的数量不大于3，所以统一按照3个鬼的情况编程。两个鬼看作是第三个一直不动；一个鬼同理。</li>
<li>问题主要在于有三个点，状态如何保存？访问标志如何保存？</li>
<li>由于题中说每2*2的小格中必有障碍，暗示了可移动的位置是少数，所以给空白格建立一张图。</li>
<li>通过一个索引值cnt来连接空白格的坐标，用x[cnt],y[cnt]来表示第cnt个非障碍格的坐标;用id[i][j]=cnt来记录每个位置的索引值。</li>
<li>建立空白格图，在每个空白格处可移动的空白格必然是其他的空白格。用blank[cnt][num_blank[cnt]] = id[x][y]来表示索引为cnt的空白格处可移动的方向中第num_blank[cnt]个的目的格的索引值。</li>
<li>由于本题中的图比较小，所以可以开三维数组来标记访问。此外可以使用哈希函数，编码或者set的方法来判重。本题中出入队列的值即是通过编码得到。</li>
<li>应该关注ID函数、索引值的写法、多个值同时改变构成新状态的做法。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 20;</span><br><span class="line">int id[maxn][maxn];</span><br><span class="line">int s[3], t[3];</span><br><span class="line">char g[maxn][maxn];</span><br><span class="line"></span><br><span class="line">int blank[maxn*maxn][5];</span><br><span class="line">int dist[maxn*maxn][maxn*maxn][maxn*maxn];</span><br><span class="line">int num_blank[maxn*maxn];</span><br><span class="line">int r, c, w;</span><br><span class="line"></span><br><span class="line">int dx[] &#x3D; &#123; 0, -1, 1, 0, 0 &#125;;</span><br><span class="line">int dy[] &#x3D; &#123; 0, 0, 0, -1, 1 &#125;;</span><br><span class="line">inline void read_in();</span><br><span class="line">inline int bfs();</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">while (~scanf(&quot;%d %d %d\n&quot;, &amp;c, &amp;r, &amp;w) &amp;&amp; w)</span><br><span class="line">&#123;</span><br><span class="line">	read_in();</span><br><span class="line">	printf(&quot;%d\n&quot;, bfs());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="read_in"><a class="markdownIt-Anchor" href="#read_in"></a> read_in</h2>
<p>读入数据，并用数组记录鬼的初始位置和目标位置。之后，给空白建图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">inline void read_in() &#123;</span><br><span class="line">int x[maxn*maxn];</span><br><span class="line">int y[maxn*maxn];</span><br><span class="line">for (int i &#x3D; 0; i &lt; r; i++) fgets(g[i], 20, stdin);</span><br><span class="line">int cnt &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; r; i++)</span><br><span class="line">	for (int j &#x3D; 0; j &lt; c; j++) &#123;</span><br><span class="line">		if (g[i][j] !&#x3D; &#39;# &#39;) &#123;</span><br><span class="line">			x[cnt] &#x3D; i;</span><br><span class="line">			y[cnt] &#x3D; j;</span><br><span class="line">			id[i][j] &#x3D; cnt;</span><br><span class="line">			if (islower(g[i][j])) s[g[i][j] - &#39;a&#39;] &#x3D; cnt;</span><br><span class="line">			else if (isupper(g[i][j])) t[g[i][j] - &#39;A&#39;] &#x3D; cnt;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;记录每个空白处可以走的方向</span><br><span class="line">for (int i &#x3D; 0; i &lt; cnt; i++) &#123;</span><br><span class="line">	num_blank[i] &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F;四个正方向加不动</span><br><span class="line">	for (int k &#x3D; 0; k &lt; 5; k++) &#123;</span><br><span class="line">		int nx &#x3D; x[i] + dx[k];</span><br><span class="line">		int ny &#x3D; y[i] + dy[k];</span><br><span class="line">		if (g[nx][ny] !&#x3D; &#39;# &#39;)</span><br><span class="line">			blank[i][num_blank[i]++] &#x3D; id[nx][ny];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果少于三个鬼，令另外的不动，初始位置等于末位置。</span><br><span class="line">if (w &lt;&#x3D; 2) &#123; num_blank[cnt] &#x3D; 1; blank[cnt][0] &#x3D; cnt; s[2] &#x3D; t[2] &#x3D; cnt++; &#125;</span><br><span class="line">if (w &lt;&#x3D; 1) &#123; num_blank[cnt] &#x3D; 1; blank[cnt][0] &#x3D; cnt; s[1] &#x3D; t[1] &#x3D; cnt++; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> bfs</h2>
<p>进行广度搜索，利用二进制法存储状态，沿途更新到达每个状态的步数，当走到目标状态时退出循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">inline int bfs() &#123;</span><br><span class="line">memset(dist, -1, sizeof(dist));</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(ID(s[0], s[1], s[2]));</span><br><span class="line">dist[s[0]][s[1]][s[2]] &#x3D; 0;</span><br><span class="line">while (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">	int u &#x3D; q.front(); q.pop();</span><br><span class="line">	int a &#x3D; (u &gt;&gt; 16) &amp; 0xff, b &#x3D; (u &gt;&gt; 8) &amp; 0xff, c &#x3D; u &amp; 0xff;</span><br><span class="line">	if (a &#x3D;&#x3D; t[0] &amp;&amp; b &#x3D;&#x3D; t[1] &amp;&amp; c &#x3D;&#x3D; t[2])</span><br><span class="line">		return dist[a][b][c];</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; num_blank[a]; i++) &#123;</span><br><span class="line">		int a2 &#x3D; blank[a][i];</span><br><span class="line">		for (int j &#x3D; 0; j &lt; num_blank[b]; j++) &#123;</span><br><span class="line">			int b2 &#x3D; blank[b][j];</span><br><span class="line">			if (!isOk(a, a2, b, b2)) continue;</span><br><span class="line"></span><br><span class="line">			for (int k &#x3D; 0; k &lt; num_blank[c]; k++) &#123;</span><br><span class="line">				int c2 &#x3D; blank[c][k];</span><br><span class="line">				if (!isOk(a, a2, c, c2) || !isOk(b, b2, c, c2)) continue;</span><br><span class="line"></span><br><span class="line">				if (dist[a2][b2][c2] &#x3D;&#x3D; -1) &#123;</span><br><span class="line">					dist[a2][b2][c2] &#x3D; dist[a][b][c] + 1;</span><br><span class="line">					q.push(ID(a2, b2, c2));</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="id-对二进制编码状态进行解码"><a class="markdownIt-Anchor" href="#id-对二进制编码状态进行解码"></a> ID 对二进制编码状态进行解码</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">inline int ID(int a, int b, int c) &#123;</span><br><span class="line">return (a &lt;&lt; 16) | (b &lt;&lt; 8) | c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="isok-判断两个鬼是否占据同一个位置或者在一步之内交叉"><a class="markdownIt-Anchor" href="#isok-判断两个鬼是否占据同一个位置或者在一步之内交叉"></a> isOk 判断两个鬼是否占据同一个位置或者在一步之内交叉</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">inline bool isOk(int a1, int a2, int b1, int b2) &#123;</span><br><span class="line">return a2 !&#x3D; b2 &amp;&amp; !(a2 &#x3D;&#x3D; b1 &amp;&amp; b2 &#x3D;&#x3D; a1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-团体队列" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%9B%A2%E4%BD%93%E9%98%9F%E5%88%97/"
    >团体队列</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%9B%A2%E4%BD%93%E9%98%9F%E5%88%97/" class="article-date">
  <time datetime="2020-03-30T02:15:00.701Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva540-团体队列"><a class="markdownIt-Anchor" href="#uva540-团体队列"></a> UVA540 团体队列</h1>
<p>有t个团队的人正在排一个长队。每次新来一个人时，如果他有队友在排队，那么这个新人会插队到最后一个队友的身后。如果没有任何一个队友排队，则他会排到长队的队尾。输入每个团队中所有队员的编号，要求支持如下3种指令（前两种指令可以穿插进行）。</p>
<p>ENQUEUEx：编号为x的人进入长队。</p>
<p>DEQUEUE：长队的队首出队。</p>
<p>STOP：停止模拟。</p>
<p>对于每个DEQUEUE指令，输出出队的人的编号。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>本题中涉及两种队列，一个是每个团队的队列，一个是整体的长队。所以用两个整型队列来存储。</li>
<li>由于一个团队的人一定站在一起，所以在整体的长队里，我们不关心每个人的具体位置。所以用给每个团队映射为一个编号，长队中是元素是队伍的编号</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<pre><code>/*
p117 例5-6 UVA540
*/
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
int main() {
int kase = 0;
for (;;) {
	map&lt;int, int&gt; belong;
	queue&lt;int&gt; total,team[1100];
	int n;
	cin &gt;&gt; n;
	if (!n) return 0;
	cout &lt;&lt; &quot;Scenario # &quot; &lt;&lt; ++kase &lt;&lt; endl;
	for(int i=0;i&lt;n;i++) {
		int m;
		cin &gt;&gt; m;
		while(m--) {
			int x;
			cin &gt;&gt; x;
			belong[x] = i;
		}
	}
</code></pre>
<p><strong>完成输入，并给每个队伍的成员都映射一个编号</strong></p>
<pre><code>	for (;;) {
		string cmd;
		cin &gt;&gt; cmd;
		if (cmd[0] == 'S') break;
		else {
			if (cmd[0] == 'D') {
				int t = total.front();
				cout &lt;&lt; team[t].front() &lt;&lt; endl;
				team[t].pop();
				if (team[t].empty()) total.pop();

			}
			if (cmd[0] == 'E') {
				int num;
				cin &gt;&gt; num;
				int t = belong[num];
				if (team[t].empty()) total.push(t);
				team[t].push(num);
			}
		}
	}
	cout &lt;&lt; endl;
}
}
</code></pre>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<ol>
<li>因为队伍数量不定，所以一开始想用vector，但是会出现越界，所以使用vector时，最好用push_back，不要随机访问。</li>
<li>两个指令，一个有操作数，一个没有，注意分情况输入！！</li>
<li>学习映射的方法，注意需要什么，应该关注什么。本题中，长队里只需关注各队伍的相对顺序，无需在长队中注意每个人的相对位置。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-图书管理系统" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"
    >图书管理系统</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time datetime="2020-03-30T02:15:00.701Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva230-图书管理系统"><a class="markdownIt-Anchor" href="#uva230-图书管理系统"></a> uva230 图书管理系统</h1>
<p> 你的任务是模拟一个图书管理系统。首先输入若干图书的标题和作者（标题各不相同，以END结束），然后是若干指令：BORROW指令表示借书，RETURN指令表示还书，SHELVE指令表示把所有已归还但还没有上架的图书排序后依次插入书架并输出图书标题和插入位置（可能是第一本书或者某本书的后面）。<br />
 图书排序的方法是先按作者从小到大排，再按标题从小到大排。在处理第一条指令之前，你应当现将所有图书按照这种方式排序。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>涉及排序，想到用一个集合来存，其中元素既要包含作者名，又要包含书名，并且要先按作者名排序，再按书名排序。所以要写一个结构体，并冲写&lt;号。</li>
<li>由于指令后面只跟书名，所以还要用一个map来存储每本书的作者，以便在处理指令的时候，补全字段，从而在集合中查找</li>
<li>SHELVE是在所有return结束后一起进行，所以还要用一个容器来存归还过的书，并且也要按要求排序，所以用了一个after这个set。</li>
<li>BORROW即在集合中找到对应元素，然后擦除(要判断是否为结束迭代器，否则re)</li>
<li>RETURN即插入图书集合以及after集合</li>
<li>SHELVE时，按after中顺序结合作者名查找对应书，输出前一个迭代器指向的对象，注意first的判断即可</li>
<li>别的都十分正常，主要是注意以下erase时，要判断是否为end</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">   #include&lt;iostream&gt;</span><br><span class="line">   #include&lt;string&gt;</span><br><span class="line">   #include&lt;algorithm&gt;</span><br><span class="line">   #include&lt;vector&gt;</span><br><span class="line">   #include&lt;iterator&gt;</span><br><span class="line">   #include&lt;set&gt;</span><br><span class="line">   #include&lt;map&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;习题5-8in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;习题5-8out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   string s;</span><br><span class="line">   struct node &#123;</span><br><span class="line">   	string book;</span><br><span class="line">   	string auth;</span><br><span class="line">   	node() &#123; &#125;</span><br><span class="line">   	node(string book, string auth) : book(book), auth(auth) &#123;&#125;</span><br><span class="line">   	bool operator &lt; (const node &amp;a)const &#123;</span><br><span class="line">   		return auth &lt; a.auth || (auth &#x3D;&#x3D; a.auth &amp;&amp; book &lt; a.book);</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   int main() &#123;</span><br><span class="line">set&lt;node&gt; library;</span><br><span class="line">map&lt;string, string&gt; who;</span><br><span class="line">set&lt;node&gt; after;</span><br><span class="line">while (getline(cin, s) &amp;&amp; s !&#x3D; &quot;END&quot;) &#123;</span><br><span class="line">	int f1 &#x3D; s.find(&quot;\&quot;&quot;);</span><br><span class="line">	int f2 &#x3D; s.substr(f1+1).find(&#39;&quot;&#39;);&#x2F;&#x2F;+1!!!!</span><br><span class="line">	node b(s.substr(f1 + 1, f2), s.substr(f2 + 5));</span><br><span class="line">	library.insert(b);</span><br><span class="line">	who[b.book] &#x3D; b.auth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while (getline(cin, s) &amp;&amp; s !&#x3D; &quot;END&quot;) &#123;</span><br><span class="line">	set&lt;node&gt;::iterator it;</span><br><span class="line">	int f1 &#x3D; s.find(&quot;\&quot;&quot;);</span><br><span class="line">	int f2 &#x3D; s.substr(f1 + 1).find(&#39;&quot;&#39;);</span><br><span class="line">	string bookname &#x3D; s.substr(f1 + 1,f2);</span><br><span class="line">	</span><br><span class="line">	if (s[0] &#x3D;&#x3D; &#39;B&#39;) &#123;</span><br><span class="line">		</span><br><span class="line">		it &#x3D; library.find(node(bookname, who[bookname]));</span><br><span class="line">		</span><br><span class="line">		if (it !&#x3D; library.end())	library.erase(it);</span><br><span class="line">	&#125;</span><br><span class="line">	if (s[0] &#x3D;&#x3D; &#39;R&#39;) &#123;</span><br><span class="line">		library.insert(node(bookname, who[bookname]));</span><br><span class="line">		after.insert(node(bookname, who[bookname]));</span><br><span class="line">	&#125;</span><br><span class="line">	if (s[0] &#x3D;&#x3D; &#39;S&#39;) &#123;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		for (set&lt;node&gt;::iterator i &#x3D; after.begin(); i !&#x3D; after.end();i++) &#123;&#x2F;&#x2F;输出也是先按作者名排序再按书名排序</span><br><span class="line">			bookname &#x3D; i-&gt;book;</span><br><span class="line">			it &#x3D; library.find(node(bookname, who[bookname]));</span><br><span class="line">			cout &lt;&lt; &quot;Put \&quot;&quot; &lt;&lt; bookname &lt;&lt;&quot;\&quot;&quot;;</span><br><span class="line">			if (it !&#x3D; library.begin()) cout &lt;&lt; &quot; after \&quot;&quot; &lt;&lt; (--it)-&gt;book &lt;&lt; &quot;\&quot;&quot;&lt;&lt;endl;</span><br><span class="line">			else cout &lt;&lt; &quot; first&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;END&quot; &lt;&lt; endl;</span><br><span class="line">		after.clear();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<p>存储重复的数据有时候也是必要的，不要为了那点空间，花太多力气</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-天平难题" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%A4%A9%E5%B9%B3%E9%9A%BE%E9%A2%98/"
    >天平难题</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%A4%A9%E5%B9%B3%E9%9A%BE%E9%A2%98/" class="article-date">
  <time datetime="2020-03-30T02:15:00.701Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-1354-天平难题"><a class="markdownIt-Anchor" href="#uva-1354-天平难题"></a> UVA 1354 <a href="%22https://www.luogu.com.cn/problem/UVA1354%22">天平难题</a></h1>
<p>给出房间宽度r和s个吊坠的重量wi。设计一个尽量宽（不超过r)的天平，挂着所有挂坠。 天平由一些长度为1的木棍组成。木棍的每一端要么挂一个挂坠，要么挂另外一个木棍。设n和m分别是两端挂的总重量，a和b为两端长度，要让天平平衡，必须满足na=mb。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<p>回溯法加暴搜，通过枚举二叉树来求解，<strong>其中天平力矩平衡的条件用来计算偏移量</strong>。</p>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="dfs函数"><a class="markdownIt-Anchor" href="#dfs函数"></a> DFS函数</h2>
<p>用来遍历解答树，同时进行剪枝。只有当可扩展位置和剩余挂坠全部刚好同时用尽，才说明是一个可能的解，对于其他的情况需要进行剪枝。对于枚举二叉树中的每个节点，可能的情况又分成两种，一种是在该节点(step)处放一个木棍，那么可放置挂坠的节点数+1(别忘了回溯);另一种是在该节点处放置一个挂坠，那么可放置挂坠的位置-1，同时剩余挂坠-1(也要回溯)</p>
<pre><code>void dfs(int step, int leaf, int node) {
if (!node &amp;&amp; !leaf) {
	update(step - 1);
	return;
}
if ((!node&amp;&amp;leaf) || (node &amp;&amp; !leaf)) {
	return;
}
if (tree[step / 2] != -1) {
	dfs(step + 1, leaf, node);
	return;
}
if (leaf &lt; node) {
	tree[step] = -1;
	dfs(step + 1, leaf + 1, node);
	tree[step] = 0;
}
for (int i = 1; i &lt;= s; i++) {
	if (!vis[i]) {
		vis[i] = 1;
		tree[step] = i;

		dfs(step + 1, leaf - 1, node - 1);

		vis[i] = 0;
		tree[step] = 0;
	}
}

}
</code></pre>
<h2 id="update函数"><a class="markdownIt-Anchor" href="#update函数"></a> update函数</h2>
<p>在枚举出一种二叉树之后，要计算他的宽度并和目前的最优解比较。这里首先使用一个val数组来记录各个节点处的权重：</p>
<ol>
<li>如果是木棍，那么他的重量等于他的两个子节点之和；</li>
<li>如果是挂坠，那么重量就是该挂坠的重量。</li>
</ol>
<p>之后使用findedge函数计算宽度。</p>
<pre><code>void update(int num) {
memset(val, 0, sizeof(val));
for (int i = num; i &gt;= 1; i--) {
	if (tree[i] &lt; 0) val[i] = val[i * 2] + val[i * 2 + 1];
	else if(tree[i]&gt;0) val[i] = w[tree[i]];
}
left = DBL_MAX;
right = DBL_MIN;

findedge(double(0), 1);
double fin = right - left;
if (fin &lt; r) {
	ans = max(ans, fin);
}

}
</code></pre>
<h2 id="findedge函数"><a class="markdownIt-Anchor" href="#findedge函数"></a> findedge函数</h2>
<p>利用天平平衡，力矩为0计算宽度。nl * a = nr * b。如果该节点是一个木棍，那么需要计算他的子节点的偏移量，过程与前面一样，所以整体上构成了一个递归的结构。</p>
<pre><code>void findedge(double mid, int cur) {
int a = cur * 2;
int b = cur * 2 + 1;
double nl = mid - ((double)val[b] / (val[a] + val[b]));
double nr = mid + ((double)val[a] / (val[a] + val[b]));

left = min(left, nl);
right = max(right, nr);

if (tree[cur] &lt; 0) {
	findedge(nl, a);
	findedge(nr, b);
}
</code></pre>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/12/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/14/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        CuiEnbo
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt=""></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['', '', ''],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: false
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>