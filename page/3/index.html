<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://github.com/Cccceb/Cccceb.github.io').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://github.com/Cccceb/Cccceb.github.io/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Ceb">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://github.com/Cccceb/Cccceb.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a href="https://github.com/you"><img style="position:absolute;" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_left_gray_6d6d6d.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>  
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E7%A0%B4%E5%9D%8F%E6%AD%A3%E6%96%B9%E5%BD%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ceb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E7%A0%B4%E5%9D%8F%E6%AD%A3%E6%96%B9%E5%BD%A2/" class="post-title-link" itemprop="url">破坏正方形</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:47:33" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVA-1603-破坏正方形"><a href="#UVA-1603-破坏正方形" class="headerlink" title="UVA 1603 破坏正方形"></a>UVA 1603 破坏正方形</h1><p>一个 n×n的网格,共 2×n×(n+1)条边,现在已经删除了一些边,问至 少还需删去多少边,可以使得剩下的边不能构成正方形。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>可以采用迭代加深度深搜，或者回溯法解决</p>
</li>
<li><p>搜索对象可以是木棍或者正方形，对应不同的剪枝</p>
<ol>
<li>如果搜索对象是木棍，那么可以将每个木棍影响的正方形数量记录下来，从大到小排序。当最大影响数量为1时，可以停止搜索，结果为当前层数+剩余正方形数。这是因为如果最大影响数为1，说明剩余正方形之间没有耦合，删除任一木棍，至多减少1个正方形。</li>
<li>如果搜索对象是正方形，那么应该从小正方形开始破坏。本题中采用这种方法。</li>
</ol>
</li>
<li><p>此外，还需要找规律，寻找各行各列，竖线横线的标号关系。以标记构成正方形的边。</p>
</li>
<li><p>本题中判断是否为正方形，<strong>通过size数组和full数组，分别记录第cnt个正方形实际有的边和应该有的边，如果二者相等，那么是一个完整的正方形</strong></p>
</li>
<li><p>本题中使用了回溯法，因为搜素深度有明显的上界2<em>n</em>(n+1)，其中n为边长。</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><pre><code>void dfs(int d) {
if (d &gt;= maxd) return;
int next = getNext();
if (next == 0) {
    maxd = d;
    return;
}
for (int j = 1; j &lt;= sum; j++) {
    if (in[next][j])
    {
        for (int k = 1; k &lt;= cnt; k++)//删掉火柴棍
            if (in[k][j]) Size[k]--;
        dfs(d + 1);
        for (int k = 1; k &lt;= cnt; k++)//复原
            if (in[k][j]) Size[k]++;
    }
}
return;
}</code></pre><ol>
<li>在删除木棍和回溯的部分，由于判断是才用size[i]==full[i]，所以in[k][j]处必有火柴。</li>
</ol>
<h2 id="getr-getc-求横竖线编号"><a href="#getr-getc-求横竖线编号" class="headerlink" title="getr,getc 求横竖线编号"></a>getr,getc 求横竖线编号</h2><pre><code>inline int getr(int r, int c) {
return r * (2 * n + 1) + c + 1;
}
inline int getc(int r, int c) {
return r * (2 * n + 1) + c + n + 1;
}</code></pre><h2 id="get-cnt-填充size数组和full数组"><a href="#get-cnt-填充size数组和full数组" class="headerlink" title="get_cnt 填充size数组和full数组"></a>get_cnt 填充size数组和full数组</h2><pre><code>inline void get_cnt() {
int a, b, e, f;
cnt = 0;
for (int len = 1; len &lt;= n; len++) {
    for (int r = 0; r + len &lt;= n; r++) {
        for (int c = 0; c + len &lt;= n; c++) {
            ++cnt;
            full[cnt] = len * 4;
            Size[cnt] = 0;
            for (int i = 0; i &lt; len; i++)
            {
                a = getr(r, c + i);
                b = getr(r + len, c + i);
                e = getc(r + i, c);
                f = getc(r + i, c + len);
                in[cnt][a] = true;
                in[cnt][b] = true;
                in[cnt][e] = true;
                in[cnt][f] = true;
                Size[cnt] += sticks[a] + sticks[b] + sticks[e] + sticks[f];
            }
        }
    }
}
}</code></pre><ol>
<li>注意这种判断的思维。</li>
</ol>
<h2 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h2><pre><code>int n, maxd, cnt, sum;
bool sticks[2 * maxn*(maxn + 1) + 1];
int Size[625];
int full[625];
int in[625][2 * maxn*(maxn + 1) + 1];
int main() {
int T, k, tmp;
scanf(&quot;%d&quot;, &amp;T);
while (T--) {
    scanf(&quot;%d\n%d&quot;, &amp;n, &amp;k);
    memset(sticks, 1, sizeof(sticks));
    memset(in, 0, sizeof(in));
    while (k--) {
        scanf(&quot;%d&quot;, &amp;tmp);
        sticks[tmp] = false;
    }
    sum = 2 * n*(n + 1);
    maxd = sum;
    get_cnt();
    dfs(0);
    printf(&quot;%d\n&quot;, maxd);
}
}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ceb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">空间结构</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:47:23" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVA-806-空间结构"><a href="#UVA-806-空间结构" class="headerlink" title="UVA 806 空间结构"></a>UVA 806 空间结构</h1><p>一个四分树是由一个方格的结构组成的，如图：（就是上面的三个图）。</p>
<p>那些像素点可以构成一个四分树，如图：（就是上面的那个树）。</p>
<p>我们规定，NW=1,NE=2,SW=3,SE=4，而一个节点所构成的数字串可以认为是一个五进制数，将它们排序后输出。</p>
<p>例如：上图中地四号节点的路径为NE,SW，所以是32532_5325​ （五进制数）=171017_{10}1710​（十进制数）</p>
<p>那么上树所对应的一传数列为：（在十进制下）</p>
<p>9 14 17 22 23 44 63 69 88 94 113\text{9 14 17 22 23 44 63 69 88 94 113} 9 14 17 22 23 44 63 69 88 94 113</p>
<p>你的任务是在这两者之间转换。</p>
<p>注意，数串中的数字顺序是从叶子到根的，别搞错了。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>对于n&gt;0的情况，需要将矩阵转化为四分树。</p>
<p> 采用递归算法，每次递归四分之一块，如果遇到范围内纯黑或纯白，则返回。并且在遇到纯黑时，将序列存入向量中。</p>
<p> 注意：要先判断整个图是否为纯黑或者纯白。</p>
<p> 然后将五进制转化为十进制</p>
</li>
<li><p>对于n&lt;0的情况，将四分树转化为矩阵<br> 先将十进制转化为五进制，并在字符串尾部添加*，以标识叶子节点<br> 采用递归算法，每次根据当前字符，来选择下一步递归的范围。当遇到叶子节点时，将当前层的范围内的点涂黑</p>
<p> 注意：pre向量中的每个元素，代表一条从根到叶子的路径，所以要用循环配合递归。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p> #include<iostream><br> #include<string><br> #include&lt;string.h&gt;<br> #include<vector><br> #include<algorithm><br> #include<cmath></p>
<h1 id="pragma-warning-disable-4996"><a href="#pragma-warning-disable-4996" class="headerlink" title="pragma warning(disable:4996)"></a>pragma warning(disable:4996)</h1><h1 id="define-LOCAL"><a href="#define-LOCAL" class="headerlink" title="define LOCAL"></a>define LOCAL</h1><h1 id="ifdef-LOCAL"><a href="#ifdef-LOCAL" class="headerlink" title="ifdef LOCAL"></a>ifdef LOCAL</h1><p> FILE *fin = freopen(“空间结构in.txt”, “r”, stdin);<br> FILE *fout = freopen(“空间结构out.txt”, “w”, stdout);</p>
<h1 id="endif"><a href="#endif" class="headerlink" title="endif"></a>endif</h1><p> using namespace std;</p>
<p> vector<int> number;<br> vector<string> pre;<br> char g[64][64];<br> int n;<br> void five() {</p>
<pre><code>for (int i = 0; i &lt; number.size(); i++) {
    int temp = 0;
    while (number[i]) {
        temp *= 10;        //注意此处要先乘10
        temp += number[i] % 5;
        number[i] = number[i] / 5;
    }

    pre.push_back(to_string(temp) + &apos;*&apos;);
    //加*以标识叶子
}</code></pre><p> }<br> void draw(const string s, int &amp;p, int r, int c, int w) {</p>
<pre><code>if (p == s.length()) return;
char ch = s[p++];
switch (ch - &apos;0&apos;)
{

case 1:    draw(s, p, r, c, w / 2); break;
case 2: draw(s, p, r, c + w / 2, w / 2); break;
case 3:    draw(s, p, r + w / 2, c, w / 2); break;
case 4:    draw(s, p, r + w / 2, c + w / 2, w / 2); break;
default:
    break;
}
if (ch == &apos;*&apos;) {
    for (int i = r; i &lt; r + w; i++)
        for (int j = c; j &lt; c + w; j++) {

                g[i][j] = &apos;*&apos;;

        }
}</code></pre><p> }<br> bool judge(int r, int c, int w,char ch) {</p>
<pre><code>// ch为0代表是否纯黑，为1代表是否纯白
for (int i = r; i &lt; r + w; i++)
    for (int j = c; j &lt; c + w; j++)
        if (g[i][j] == ch)
            return false;
return true;    //任何情况下都要有return否则会RE</code></pre><p> }<br> void matrix(string str, int r, int c, int w) {</p>
<pre><code>if (judge(r, c, w,&apos;0&apos;)) {
    pre.push_back(str);    //纯黑则递归到头，将序列保存
    return;
}
else if (judge(r, c, w,&apos;1&apos;)) return;
else {
    matrix(str + &quot;1&quot;, r, c, w / 2);
    matrix(str + &quot;2&quot;, r, c + w / 2, w / 2);
    matrix(str + &quot;3&quot;, r + w / 2, c, w / 2);
    matrix(str + &quot;4&quot;, r + w / 2, c + w / 2, w / 2);
}</code></pre><p> }<br> void ten() {</p>
<pre><code>for (int i = 0; i &lt; pre.size(); i++) {
    int temp = 0;
    for (int j = pre[i].size() - 1; j &gt;= 0; j--)
        temp += (pre[i][j] - &apos;0&apos;)*pow(5, j);
    number.push_back(temp);

}</code></pre><p> }<br> int main() {</p>
<pre><code>int first = 1;
int kase = 0;
while (cin &gt;&gt; n &amp;&amp; n) {
    if (first) first = 0; else cout &lt;&lt; endl;
    cout &lt;&lt; &quot;Image &quot; &lt;&lt; ++kase &lt;&lt; endl;

    number.clear();
    pre.clear();
    memset(g, &apos;.&apos;, sizeof(g));
    getchar();
    if (n &gt; 0) {
        for (int i = 0; i &lt; n; i++)
            for (int j = 0; j &lt; n; j++)
                cin &gt;&gt; g[i][j];</code></pre></li>
</ol>
<pre><code>            if (judge(0, 0, n,&apos;0&apos;)) number.push_back(0);
            //纯黑的情况
            else if (judge(0, 0, n,&apos;1&apos;));//纯白

            else {
                matrix(&quot;1&quot;, 0, 0, n / 2);
                matrix(&quot;2&quot;, 0, n / 2, n / 2);
                matrix(&quot;3&quot;, n / 2, 0, n / 2);
                matrix(&quot;4&quot;, n / 2, n / 2, n / 2);
                ten();
            }


            sort(number.begin(), number.end());
            if (!number.empty()) {
                for (int i = 0; i &lt; number.size(); i++)
                {
                    cout &lt;&lt; number[i];
                    if ((i + 1) % 12 == 0||i==number.size()-1) cout &lt;&lt; endl;
                    else cout &lt;&lt; &quot; &quot;;
                }
            }

            cout &lt;&lt; &quot;Total number of black nodes = &quot; &lt;&lt; number.size() &lt;&lt; endl;

        }
        if (n &lt; 0) {

            string s;
            bool flag = false;
            bool zero = false;
            for (;;) {
                int a;
                //由于输入的结束标志-1不一定出现在哪里，所以
                //要设置标志
                for (int i = 0; i &lt; 12; i++) {
                    cin &gt;&gt; a;
                    if (a == -1) {
                        flag = true;
                        break;
                    }
                    if (a == 0)zero = true;
                    number.push_back(a);
                }
                if (flag) break;
            }    
            if (zero) {
            //如果包含0，代表它是一个只有一个节点的树
                memset(g, &apos;*&apos;, sizeof(g));
            }
            else {
                five();
                for (int i = 0; i &lt; pre.size(); i++) {
                    int p = 0;
                    draw(pre[i], p, 0, 0, abs(n));
                }
            }



            for (int i = 0; i &lt; abs(n); i++) {
                for (int j = 0; j &lt; abs(n); j++)
                    cout &lt;&lt; g[i][j];
                cout &lt;&lt; endl;
            }
        }


    }
}</code></pre><h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li>本题加深了对递归问题的理解，使用递归算法也不是仅仅用递归实现，要搭配循环，减小递归代码的编写难度。</li>
<li>理清思路再写递归，注意认清递归结束条件，不要模糊。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E9%9B%86%E5%90%88%E6%A0%88%E8%AE%A1%E7%AE%97%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ceb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E9%9B%86%E5%90%88%E6%A0%88%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="post-title-link" itemprop="url">集合栈计算机</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:47:21" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uva12096-※集合栈计算机※"><a href="#uva12096-※集合栈计算机※" class="headerlink" title="uva12096 ※集合栈计算机※"></a>uva12096 ※集合栈计算机※</h1><p>（输入：先输入测试次数，再输入操作次数，再输入具体操作）</p>
<pre><code>Sample Input
2
9
PUSH
DUP
ADD
PUSH
ADD
DUP
ADD
DUP
UNION
5
PUSH
PUSH
ADD
PUSH
INTERSECT

Sample Output
0
0
1
0
1
1
2
***
0
0
1
0
0</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>首先考虑集合的存储问题：由于有集合作为元素插入到另一个集合的情况，所以不能直接定义集合类型的栈。考虑将集合映射到值(map)，另用一个向量存集合本身。</li>
<li>按照题干输入输出判断操作即可。注意后三种操作可以合并简化代码<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2> #include<iostream><br> #include<string><br> #include<map><br> #include<set><br> #include<vector><br> #include<stack><br> #include<iterator><br> #include<algorithm><h1 id="define-ALL-x-x-begin-x-end"><a href="#define-ALL-x-x-begin-x-end" class="headerlink" title="define ALL(x) x.begin(),x.end()"></a>define ALL(x) x.begin(),x.end()</h1><h1 id="define-INS-x-inserter-x-x-begin"><a href="#define-INS-x-inserter-x-x-begin" class="headerlink" title="define INS(x) inserter(x,x.begin())"></a>define INS(x) inserter(x,x.begin())</h1></li>
</ol>
<blockquote>
<p>INS(x)插入迭代器，插入而非覆盖<br><a href="https://blog.csdn.net/m0_37456764/article/details/83019250" target="_blank" rel="noopener">inserter</a>.</p>
</blockquote>
<pre><code>using namespace std;
typedef set&lt;int&gt; Set;
map&lt;Set, int&gt; id;//将每个集合对应一个编号，编号是在向量中的下标
vector&lt;Set&gt; Setcache;
int ID(Set x) {//既是插入又是查询！！
    if (id.count(x)) return id[x];//存在则返回id

    //不存在则添加
    Setcache.push_back(x);
    return id[x] = Setcache.size() - 1;
}</code></pre><p>插入和查询合并简化代码</p>
<pre><code>int main() {
int n;

cin &gt;&gt; n;
while (n--) {
    int m;
    cin &gt;&gt; m;
    stack&lt;int&gt; s;
    while (m--) {
        string op;
        cin &gt;&gt; op;
        if (op[0] == &apos;P&apos;) s.push(ID(Set()));
        //空集入栈，注意此处空集的写法
        else if (op[0] == &apos;D&apos;) s.push(s.top());
        else {
            Set x1 = Setcache[s.top()]; s.pop();
            //不同直接用pop赋值，因为pop的返回值为void
            Set x2 = Setcache[s.top()]; s.pop();
            Set x;
            if (op[0] == &apos;U&apos;) set_union(ALL(x1), ALL(x2), INS(x));
            if (op[0] == &apos;I&apos;) set_intersection(ALL(x1), ALL(x2), INS(x));
            if (op[0] == &apos;A&apos;) { x = x2; x.insert(ID(x1)); }
            s.push(ID(x));
        }
        cout &lt;&lt; Setcache[s.top()].size() &lt;&lt; endl;
    }
    cout &lt;&lt; &quot;***&quot; &lt;&lt; endl;
}
}</code></pre><h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li>本题主要注重多种STL的结合使用，尤其是集合映射为整型的处理方式</li>
<li>记住题中交并集的函数，set_union(参数为5个迭代器),set_intersection(参数为5个迭代器);要配合两处define使用</li>
<li>注意模拟多种操作时提取相同部分简化代码，也降低出错的可能性和调试难度。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E9%BB%84%E9%87%91%E5%9B%BE%E5%BD%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ceb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E9%BB%84%E9%87%91%E5%9B%BE%E5%BD%A2/" class="post-title-link" itemprop="url">黄金图形</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:47:18" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UVA-225-黄金图形"><a href="#UVA-225-黄金图形" class="headerlink" title="UVA 225 黄金图形"></a>UVA 225 黄金图形</h1><p>平面上有k个障碍点。 从(0,0)点出发，第一次走1个单位，第二次走2个单位，……， 第n次走n个单位，恰好回到(0,0)。 要求只能沿着东南西北方向走，且每次必须转弯90°（不能沿着同一个方向继续走，也不能后退）。 走出的图形可以自交，但不能经过障碍点，如图 7-25所示。每个转折点只能走一次。 输入n、k（1≤n≤20，0≤k≤50）和所有障碍点的坐标，输出所有满足要求的移动序列（用 news表示北、东、西、南），按照字典序从小到大排列，最后输出移动序列的总数。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>又要输出所有的路径，所以直观的想到用dfs。dfs中处理好可以移动的方向即可。</p>
</li>
<li><p>本题的特殊之处在于，障碍格可能出现负坐标。由于本题中最长边长n小于等于20，所以采用给(0,0)点以及障碍物点加一个比较大的值来消负号。我是假设n=20，那么一共也就能走1+2+…20/2=105，所以我加了一个120.</p>
</li>
<li><p>注意：卡了很久的原因主要是题干中要求最长边等于n，这条件不仅是限定搜索深度的。他还要求必须包含长度为n的边。</p>
</li>
<li><p>注意每个转折点只能走一次的条件。这个转折点是指每一步走完之后的终点。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p> #include&lt;bits/stdc++.h&gt;</p>
<h1 id="pragma-warning-disable-4996"><a href="#pragma-warning-disable-4996" class="headerlink" title="pragma warning(disable:4996)"></a>pragma warning(disable:4996)</h1><p> FILE <em>fin = freopen(“习题7-2in.txt”, “r”, stdin);<br> FILE *fout = freopen(“习题7-2out.txt”, “w”, stdout);<br> using namespace std;<br> const int maxn = 20;<br> void dfs(int r, int c, int dir, int step);<br> int dx[] = { 1,0,0,-1 };//东北南西<br> int dy[] = { 0,1,-1,0 };<br> int cnt, n;<br> bool g[maxn * maxn + 1][maxn * maxn + 1];<br> char direction[] = { ‘e’,’n’,’s’,’w’ };<br> int path[maxn</em>maxn];<br> bool vis[maxn<em>maxn + 1][maxn</em>maxn+ 1];<br> int stax, stay;<br> int main() {<br> int T;<br> scanf(“%d”, &amp;T);<br> int k;<br> while (T–)<br> {</p>
<pre><code>int x, y;
memset(g, 1, sizeof(g));
memset(path, 0, sizeof(path));

scanf(&quot;%d\n%d&quot;, &amp;n, &amp;k);
vector&lt;int&gt; tmpx;
vector&lt;int&gt; tmpy;
stax = stay = 120;
cnt = 0;
while (k--)
{
    scanf(&quot;%d %d&quot;, &amp;x, &amp;y);
    g[x + stax][y + stay] = 0;
}

for (int i = 0; i &lt; 4; i++) {
    memset(vis, 0, sizeof(vis));
    dfs(stax, stay, i, 1);</code></pre></li>
</ol>
<pre><code>    }
    printf(&quot;Found %d golygon(s).\n\n&quot;, cnt);
}
}
void dfs(int r, int c, int dir, int step) {
path[step] = dir;
for (int i = 0; i &lt; step; i++) {
    r += dx[dir];
    c += dy[dir];
    if (!g[r][c] || r &lt; 0 || c &lt; 0 ) {
        return;
    }
}
if (vis[r][c]) return;
if (step &gt;= n) {
    if (r == (stax) &amp;&amp; c == (stay)) {
        for (int i = 1; i &lt;= step; i++)
            printf(&quot;%c&quot;, direction[path[i]]);
        printf(&quot;\n&quot;);
        cnt++;
    }
    return;
}

vis[r][c] = 1;
if (dir == 0 || dir == 3) {
    dfs(r, c, 1, step + 1);
    dfs(r, c, 2, step + 1);
}
else {
    dfs(r, c, 0, step + 1);
    dfs(r, c, 3, step + 1);
}
vis[r][c] = 0;
}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ceb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/" class="post-title-link" itemprop="url">二叉树的层序遍历</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:47:05" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uva-122-树的层序遍历"><a href="#uva-122-树的层序遍历" class="headerlink" title="uva 122 树的层序遍历"></a>uva 122 树的层序遍历</h1><p>树状结构在电脑科学的许多领域中都相当重要。本问题牵涉到建立树及走访树。</p>
<p>给你一二元树，你的任务是写一个程式来列印依「阶层（level-order）」走访的结果。在本问题中，二元树的每个节点含有一个正整数，并且节点的数目最少1个，最多256个。</p>
<p>在「阶层」走访中，依阶层从低到高，同阶层从左到右的次序来列印。例如以下的二元树阶层走访的结果为：5, 4, 8, 11, 13, 4, 7, 2, 1</p>
<p>在本问题中，二元树以节点来表示。每个节点以一对(n,s)来表示。n代表此节点的值，s为一字串，代表从根节点到达此节点的路径。其中L代表往左，R代表往右。所以在上方的图中内容为13的节点其表示法为(13,RL)，而内容为2的节点其表示法为(2,LLR)，而根节点为(5,)。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>先根据给出的对，构造二叉树，在借助队列层序遍历</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    #include&lt;iostream&gt;</span><br><span class="line">    #include&lt;string&gt;</span><br><span class="line">    #include&lt;queue&gt;</span><br><span class="line">    # pragma warning(disable:4996)</span><br><span class="line">    # define LOCAL</span><br><span class="line">    # ifdef LOCAL</span><br><span class="line">    FILE *fin &#x3D; freopen(&quot;树的层序遍历in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    FILE *fout &#x3D; freopen(&quot;树的层序遍历out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    # endif </span><br><span class="line">    using namespace std;</span><br><span class="line">    struct node &#123;</span><br><span class="line">    	bool have_val;</span><br><span class="line">    	int v;</span><br><span class="line">    	node *left, *right;</span><br><span class="line">    	node() :have_val(false), left(NULL), right(NULL) &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    node* root;</span><br><span class="line">    node * newnode() &#123;</span><br><span class="line">    </span><br><span class="line">    	return new node();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">	bool flag;</span><br><span class="line">	void addnode(string s, int v) &#123;</span><br><span class="line">	node * u &#x3D; root;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; s.length()-1; i++)</span><br><span class="line">		if (s[i] &#x3D;&#x3D; &#39;L&#39;) &#123;</span><br><span class="line">			if (u-&gt;left &#x3D;&#x3D; NULL)</span><br><span class="line">				u-&gt;left &#x3D; newnode();</span><br><span class="line">			u &#x3D; u-&gt;left;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		else if (s[i] &#x3D;&#x3D; &#39;R&#39;) &#123;</span><br><span class="line">			if (u-&gt;right &#x3D;&#x3D; NULL)</span><br><span class="line">				u-&gt;right &#x3D; newnode();</span><br><span class="line">			u &#x3D; u-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">	if (u-&gt;have_val) &#123;</span><br><span class="line">		flag &#x3D; false;</span><br><span class="line">	&#125;</span><br><span class="line">	u-&gt;have_val &#x3D; true;	</span><br><span class="line">	u-&gt;v &#x3D; v;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	int main() &#123;</span><br><span class="line">	string s;</span><br><span class="line">	</span><br><span class="line">	while (cin.peek() !&#x3D; EOF&amp;&amp;cin.peek()!&#x3D;&#39;\n&#39;) &#123;</span><br><span class="line">		root &#x3D; newnode();</span><br><span class="line"></span><br><span class="line">		flag &#x3D; true;</span><br><span class="line"></span><br><span class="line">		while (cin &gt;&gt; s &amp;&amp; s !&#x3D; &quot;()&quot;) &#123;</span><br><span class="line">			int v;</span><br><span class="line">			sscanf(&amp;s[1], &quot;%d&quot;, &amp;v);</span><br><span class="line">&gt;※※※提取字符串中的数字的方法！！！</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F;		cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">			s &#x3D; s.substr(s.find(&#39;,&#39;) + 1);</span><br><span class="line">			addnode(s, v);</span><br><span class="line">		&#125;</span><br><span class="line">		getchar();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		if (!flag) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;not complete&quot; &lt;&lt; endl;</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		node *tmp &#x3D; root;</span><br><span class="line">		queue&lt;node *&gt; travel;</span><br><span class="line">		travel.push(tmp);</span><br><span class="line">&gt;注意层序遍历的初始值</span><br><span class="line"></span><br><span class="line">		string ans;</span><br><span class="line">		while (!travel.empty()) &#123;</span><br><span class="line">			tmp&#x3D; travel.front();</span><br><span class="line">			travel.pop();</span><br><span class="line">			</span><br><span class="line">			if (!tmp-&gt;have_val) &#123;</span><br><span class="line">				flag &#x3D; false;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			ans &#x3D;ans+&quot; &quot;+to_string( tmp-&gt;v);</span><br><span class="line">			if (tmp-&gt;left) travel.push(tmp-&gt;left);</span><br><span class="line">			if (tmp-&gt;right) travel.push(tmp-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">		flag ? cout &lt;&lt; ans.substr(1) &lt;&lt; endl : cout &lt;&lt; &quot;not complete&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li><p>首先一定要学习提取字符串中数字的方法</p>
<pre><code>：sscanf(&amp;数字起始地址,&quot;格式&quot;，&amp;存储变量名)</code></pre></li>
<li><p>动态申请空间的时候，要释放掉，否则会导致内存泄漏；</p>
</li>
<li><p>可以通过维护一个简单的内存池实现</p>
<pre><code>queue&lt;Node*&gt; freenodes;
   Node node[maxn];

void init(){
    for(int i=0;i&lt;maxn;i++)
    freenodes.push(&amp;node[i]);    
}

Node* new(){
    Node* u = freenodes.front();
    //处理u的成员变量
    freenodes.pop();
    return u;
}

void dele(Node *u){
    freenodes.push(u);
}</code></pre></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%87%8D%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ceb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%87%8D%E5%BB%BA/" class="post-title-link" itemprop="url">二叉树的重建</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:47:08" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uva-536-二叉树的重建-先中造树"><a href="#uva-536-二叉树的重建-先中造树" class="headerlink" title="uva 536 二叉树的重建 (先中造树)"></a>uva 536 二叉树的重建 (先中造树)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">   #include&lt;string&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;习题6-3in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;习题6-3out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   typedef struct node &#123;</span><br><span class="line">   	struct node *lchild, *rchild;</span><br><span class="line">   	char data;</span><br><span class="line">   &#125;node, *ptr;</span><br><span class="line">   ptr Create(char *pre, char *in, int n)</span><br><span class="line">   &#123;</span><br><span class="line">   	ptr s;</span><br><span class="line">   </span><br><span class="line">   	if (n &#x3D;&#x3D; 1)</span><br><span class="line">   	&#123;</span><br><span class="line">   		s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">   		s-&gt;data &#x3D; *pre;</span><br><span class="line">   		s-&gt;lchild &#x3D; s-&gt;rchild &#x3D; NULL;</span><br><span class="line">   		return s;</span><br><span class="line">   	&#125;</span><br><span class="line">   	char *p;</span><br><span class="line">   	for (p &#x3D; in; p &lt; in + n; p++)</span><br><span class="line">   		if (*p &#x3D;&#x3D; *pre) break;</span><br><span class="line">   	int k &#x3D; p - in;</span><br><span class="line">   	s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">   	s-&gt;data &#x3D; *p;</span><br><span class="line">   	s-&gt;lchild &#x3D; s-&gt;rchild &#x3D; NULL;</span><br><span class="line">   	if (k) s-&gt;lchild &#x3D; Create(pre + 1, in, k);</span><br><span class="line">   	if (n - k - 1) s-&gt;rchild &#x3D; Create(pre + k + 1, p + 1, n - k - 1);</span><br><span class="line">   	return s;</span><br><span class="line">   &#125;</span><br><span class="line">   int lastorder(ptr T)</span><br><span class="line">   &#123;</span><br><span class="line">   	if (!T) return 0;</span><br><span class="line">   	lastorder(T-&gt;lchild);</span><br><span class="line">   	lastorder(T-&gt;rchild);</span><br><span class="line">   	printf(&quot;%c&quot;, T-&gt;data);</span><br><span class="line">   	return 1;</span><br><span class="line">   &#125;</span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">   </span><br><span class="line">   	string pre, in;</span><br><span class="line">   	while (cin &gt;&gt; pre &gt;&gt; in) &#123;</span><br><span class="line">   		int n &#x3D; pre.length();</span><br><span class="line">   		ptr T &#x3D; Create(&amp;pre[0], &amp;in[0], n);</span><br><span class="line">   		lastorder(T);</span><br><span class="line">   		cout &lt;&lt; endl;</span><br><span class="line">   	&#125;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E5%8F%A4%E4%BB%A3%E8%B1%A1%E5%BD%A2%E7%AC%A6%E5%8F%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ceb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E5%8F%A4%E4%BB%A3%E8%B1%A1%E5%BD%A2%E7%AC%A6%E5%8F%B7/" class="post-title-link" itemprop="url">古代象形符号</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:47:13" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uva-1103-古代象形符号"><a href="#uva-1103-古代象形符号" class="headerlink" title="uva 1103 古代象形符号"></a>uva 1103 古代象形符号</h1><p>描述： 为了理解早期文明，考古学家经常研究用古代语言编写的文本。在3000多年前的埃及使用的一种语言是基于称为象形文字的字符。如图显示了六个象形文字及其名称，在这个题目中，您需要编写一个程序来识别这六个字。 图c1<br>输入描述： 输入由几个测试用例组成，每个测试用例描述一个包含一个或多个的图像 象形文字选自图C.1所示的那些。图像以一系列水平扫描线的形式给出，这些水平扫描线由黑色像素（由1表示）和白色像素（由0表示）组成。在输入数据中，每个扫描线以十六进制表示法编码。 例如，序列将表示八个像素10011100（一个黑色像素，后面是两个白色像素，依此类推） 十六进制表示法为9c。 在十六进制中仅使用数字和小写字母a到f 编码。每个测试用例的第一行包含两个整数，H和W.H（0 &lt;H≤200）是 图像中的扫描行数。 W（0 &lt;W≤50）是每个中十六进制字符的数量 线。 接下来的H行包含图像的十六进制字符，从上到下工作。 输入图像符合以下规则： •图像仅包含图C.1中所示的象形文字。 •每个图像至少包含一个有效的象形文字。 •图像中的每个黑色像素都是有效象形文字的一部分。 •每个象形文字由一组连接的黑色像素组成，每个黑色像素至少有一个顶部，底部，左侧或右侧的其他黑色像素。 •象形文字没有触及，另一个象形文字中没有象形文字。 •对角线接触的两个黑色像素将始终具有共同的触摸黑色像素。 •象形文字可能会扭曲，但每个都有一个在拓扑上等同于其中一个的形状 图C.1中的符号。 （如果每个都可以转换，两个数字在拓扑上是等价的 通过伸展而不撕裂进入另一个。） 最后一个测试用例后跟一行包含两个零的行。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>本题中的符号可以随意压缩拉伸，所以试图去直接描述其形状是不可取的。<br>观察到每个符号的空白圈数不同，可以以此特征分辨</p>
<ol>
<li><p>注意：要先给这个图加上一圈白边，使得所有背景的白色部分可以连接起来。此处可以使用</p>
</li>
<li><p>所以总体来说要进行两次遍历</p>
</li>
<li><p>第一次将背景中的空白遍历</p>
</li>
<li><p>第二次去遍历黑圈，沿途遍历黑色周围未遍历的白色部分，对于每个黑色的连通分量，统计其周围遍历到的白色连通分量数，即白洞数。每次统计完的接完插入到一个向量中。</p>
</li>
<li><p>对向量排序，输出</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p> #include<iostream><br> #include<queue><br> #include<string><br> #include<algorithm><br> #include&lt;string.h&gt;</p>
<h1 id="pragma-warning-disable-4996"><a href="#pragma-warning-disable-4996" class="headerlink" title="pragma warning(disable:4996)"></a>pragma warning(disable:4996)</h1><h1 id="define-LOCAL"><a href="#define-LOCAL" class="headerlink" title="define LOCAL"></a>define LOCAL</h1><h1 id="ifdef-LOCAL"><a href="#ifdef-LOCAL" class="headerlink" title="ifdef LOCAL"></a>ifdef LOCAL</h1><p> FILE *fin = freopen(“古代象形符号in.txt”, “r”, stdin);<br> FILE *fout = freopen(“古代象形符号out.txt”, “w”, stdout);</p>
<h1 id="endif"><a href="#endif" class="headerlink" title="endif"></a>endif</h1><p> using namespace std;<br> vector<string> g;<br> int vis[205][205];<br> string b[] = { “0000”,”0001”,”0010”,”0011”,”0100”,”0101”,”0110”,”0111”,”1000”,”1001”,”1010”,”1011” ,”1100”,”1101”,”1110”,”1111” };<br> char c[] = { ‘W’,’A’,’K’,’J’,’S’,’D’ };<br> int dx[] = { -1,0,1,0 };<br> int dy[] = { 0,-1,0,1 };<br> struct Node {</p>
<pre><code>int x, y;
Node(int x, int y) :x(x), y(y) {}</code></pre><p> };<br> int H, W, cnt, num;<br> bool notOk(int a, int b) {</p>
<pre><code>return vis[a][b] || a &lt; 0 || a &gt;= g.size() || b &lt; 0 || b &gt;= g[a].size();</code></pre><p> }<br> void dfs(Node u, char c) {</p>
<pre><code>vis[u.x][u.y] = 1;
for (int i = 0; i &lt; 4; i++) {
    int a = u.x + dx[i];
    int b = u.y + dy[i];
    if (notOk(a, b)) continue;
    if (c == &apos;1&apos;&amp;&amp; g[a][b] == &apos;0&apos;) {

        cnt++;
        dfs(Node(a, b), &apos;0&apos;);
    }
    if (g[a][b] == c) dfs(Node(a, b), c);
}</code></pre><p> }</p>
<p> int main() {</p>
<pre><code>int kase = 0;
while (cin &gt;&gt; H &gt;&gt; W &amp;&amp; H) {

    getchar();
    memset(vis, 0, sizeof(vis));
    g.clear();
    g.resize(H + 2);
    g.front() = string(W * 4 + 2, &apos;0&apos;);//加一层白边
    for (int i = 1; i &lt;= H; ++i) {//读取输入
        g[i] = &quot;0&quot;;//加一层白边
        string s;
        getline(cin, s);
        for (char c : s)
        {
            if (isdigit(c)) g[i] += b[c - &apos;0&apos;];
            else g[i] += b[c - &apos;a&apos; + 10];
        }
        g[i] += &quot;0&quot;;//加一层白边
    }
    g.back() = string(W * 4 + 2, &apos;0&apos;);//加一层白边</code></pre></li>
</ol>
<pre><code>        dfs(Node(0, 0), &apos;0&apos;);

        string ans;
        for (int i = 1; i &lt; g.size(); i++) {
            for (int j = 1; j &lt; g[i].size(); j++) {
                if (!vis[i][j] &amp;&amp; g[i][j] == &apos;1&apos;) {
                    cnt = 0;
                    dfs(Node(i, j), &apos;1&apos;);
                    ans += c[cnt];

                }


            }
        }

        cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++kase &lt;&lt; &quot;: &quot;;

        sort(ans.begin(), ans.end());

        cout &lt;&lt; ans &lt;&lt; endl;

    }

}</code></pre><h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li>注意DRY问题，本题中的dfs的写法非常值得学习</li>
<li>利用向量的直接赋值来添加百变，减少了时间复杂度</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E5%8F%8D%E7%89%87%E8%AF%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ceb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E5%8F%8D%E7%89%87%E8%AF%AD/" class="post-title-link" itemprop="url">反片语</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:47:10" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uav156-反片语"><a href="#uav156-反片语" class="headerlink" title="uav156 反片语"></a>uav156 反片语</h1><p>输入一些单词，找出所有满足如下条件的单词：该单词不能通过字母重排，得到输入文本的另外一个单词。在判断是否满足条件时，字母不分大小写，但在输出时应保留输入中的大小写，按字典序进行排列(所有大写字母在所有小写字母的前面)</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>由于单词可以重拍，所有直接对各单词进行标准化，以便于使用map；map<br>为&lt;string,int&gt;，其中值对应单词出现次数；使用向量word记录原单词，向量ans记录答案序列；</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
vector&lt;string&gt;word;
map&lt;string, int&gt; cnt;
string standard(const string &amp;in) {
string s = in;
for (int i = 0; i &lt; s.length(); i++) {
    s[i] = tolower(s[i]);
}</code></pre><ol>
<li><p>此处书上是按上述方式给的，如果形参表写成const string s，之后直接操作s，并且返回s也没发现问题。</p>
</li>
<li><p>注意此处const的用法，编写该模块前如果认定了in仅作为输入，则加上const防止之后错误的操作。</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>sort(s.begin(), s.end());<br>return s;<br>}<br>int main() {<br>string s;<br>while (cin &gt;&gt; s) {<br>  if (s[0] == ‘# ‘)    break;<br>  word.push_back(s);<br>  string r = standard(s);<br>  if (!cnt.count(r)) cnt[r] = 0;<br>  cnt[r]++;<br>}<br>vector<string> ans;<br>for (int i = 0; i &lt; word.size(); i++) {<br>  if (cnt[standard(word[i])] == 1) ans.push_back(word[i]);<br>}<br>sort(ans.begin(), ans.end());</p>
<p>for (int i = 0; i &lt; ans.size(); i++) {<br>  cout &lt;&lt; ans[i] &lt;&lt; endl;<br>}<br>}</p>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li>本题主要是map的应用，想要用map，标准化的步骤是关键。</li>
<li>map提供了”[]”运算符，map[键]=值，使得map可以像数组一样使用。事实上，map也成为”关联数组”。</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E5%9F%8E%E5%B8%82%E6%AD%A3%E8%A7%86%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ceb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E5%9F%8E%E5%B8%82%E6%AD%A3%E8%A7%86%E5%9B%BE/" class="post-title-link" itemprop="url">城市正视图</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:46:56" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uva221-城市正视图"><a href="#uva221-城市正视图" class="headerlink" title="uva221 城市正视图"></a>uva221 城市正视图</h1><p>&ensp;如图5-4所示，有n（n≤100）个建筑物。左侧是俯视图（左上角为建筑物编号，右下角为高度），右侧是从南向北看的正视图。<br>输入每个建筑物左下角坐标（即x、y坐标的最小值）、宽度（即x方向的长度）、深度（即y方向的长度）和高度（以上数据均为实数），输出正视图中能看到的所有建筑物，按照左下角x坐标从小到大进行排序。左下角x坐标相同时，按y坐标从小到大排序。</p>
<p>&ensp;输入保证不同的x坐标不会很接近（即任意两个x坐标要么完全相同，要么差别足够大，不会引起精度问题）。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>需要对横坐标进行离散化，然后判断每个区间中点是否可以看见。</p>
</li>
<li><p>判断一个建筑是否在某个坐标处可见：首先，要包含这个点。其次，其他包含这个点的建筑没有比他靠近南边，并且比他高的。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p> #include<iostream><br> #include <algorithm><br> using namespace std;<br> struct bulid {</p>
<pre><code>double x, y, w, d, h;
int id;
bool operator &lt;(const bulid&amp;r) const{ return x &lt; r.x || x == r.x&amp;&amp;y &lt; r.y; }</code></pre><p> }b[105];</p>
<blockquote>
<blockquote>
<p>注意此处要重写小于号，用于后面的sort</p>
</blockquote>
</blockquote>
<p> int n;<br> bool cover(int id, double mx) {</p>
<pre><code>return mx &gt;= b[id].x &amp;&amp; mx &lt;= b[id].x + b[id].w;</code></pre><p> }</p>
<blockquote>
<blockquote>
<p>判断id号建筑是否包办mx这个点</p>
</blockquote>
</blockquote>
<p> bool visable(int id, double mx) {</p>
<pre><code>if (!cover(id, mx)) return false;
for (int i = 0; i &lt; n; i++) {
    if (b[i].y &lt; b[id].y&amp;&amp;b[i].h &gt;= b[id].h&amp;&amp;cover(i, mx)) return false;
}
return true;</code></pre><p> }</p>
<blockquote>
<blockquote>
<p>判断id号建筑是否在mx点处可见</p>
</blockquote>
</blockquote>
<p> int main() {</p>
<pre><code>int kase = 0;
int first = 1;
while (cin &gt;&gt; n &amp;&amp; n) {

if (first) first = 0;
else cout &lt;&lt; endl;

int x[2*105]{};
for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; b[i].x &gt;&gt; b[i].y &gt;&gt; b[i].w &gt;&gt; b[i].d &gt;&gt; b[i].h;
    b[i].id = i + 1;</code></pre><blockquote>
<blockquote>
<p>对坐标进行离散化，把连续的坐标变成离散的区间</p>
</blockquote>
</blockquote>
<pre><code>    x[2 * i] = b[i].x;
    x[2 * i + 1] = b[i].x + b[i].w;
}</code></pre></li>
</ol>
<pre><code>sort(b, b + n);
sort(x, x + 2 * n);


int m = unique(x, x + 2 * n) - x;</code></pre><blockquote>
<blockquote>
<p>对x去重，unique返回值为一个地址，所以要减去x转成索引位置</p>
</blockquote>
</blockquote>
<pre><code>    cout &lt;&lt; &quot;For map # &quot; &lt;&lt;++kase &lt;&lt; &quot;, the visible buildings are numbered as follows:&quot; &lt;&lt; endl;
    cout &lt;&lt; b[0].id ;
        for (int i = 1; i &lt; n; i++) {//循环所有的建筑
            bool vis = false;
            for (int j = 0; j &lt; m - 1; j++) {//循环所有区间
                if (visable(i, (x[j] + x[j + 1]) / 2)) {
                //如果id号建筑在该区间中点可见，则在整个区间可见
                    vis = true;
                    break;
                }

            }
            if (vis) cout &lt;&lt;&quot; &quot;&lt;&lt; b[i].id;

        }
        cout &lt;&lt; &quot;\n&quot;;
}
}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/20/%E5%B8%A6%E5%AE%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ceb">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/%E5%B8%A6%E5%AE%BD/" class="post-title-link" itemprop="url">带宽</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-01-20 11:48:55 / Modified: 14:47:02" itemprop="dateCreated datePublished" datetime="2020-01-20T11:48:55+08:00">2020-01-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="uva-140-带宽"><a href="#uva-140-带宽" class="headerlink" title="uva 140 带宽"></a>uva 140 带宽</h1><p>题意： 给一个最多8个结点的无向图，把结点重排后对于图中每条边(u,v)，u和v在排列中的最大距离称为该排列的带宽。求带宽最小的排列.</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>本题是带优化的穷举法—-回溯法的应用</p>
</li>
<li><p>所谓回溯法，就是在遍历的过程中构建树和删除树(剪枝)，如果可以确定该子树中不含有问题的解，则放弃对该子树的搜索，返回到上层的父节点，继续下一步深度优先搜索。</p>
</li>
<li><p>类比到本题中，有两种情况可以剪枝：</p>
<ol>
<li>对于节点u来说，假设u有m个相邻的节点，那么最理想的情况就是这m个节点紧跟在u后面，这样的节点带宽为m，而其他任何非理想情况的带宽至少为m+1</li>
<li>如果当前节点的带宽已经大于最小带宽，那么说明这个位置不能放这个位置不能放i，即放回到上层，再又上层执行vis[i] = 0来回溯</li>
</ol>
</li>
<li><p>由于A即使在没有成功运行到底的情况下，也会被改变，所以要将每次的结果更新到另一个数组里，采用memcpy函数</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p> #include&lt;bits/stdc++.h&gt;</p>
<h1 id="pragma-warning-disable-4996"><a href="#pragma-warning-disable-4996" class="headerlink" title="pragma warning(disable:4996)"></a>pragma warning(disable:4996)</h1><h1 id="define-LOCAL"><a href="#define-LOCAL" class="headerlink" title="define LOCAL"></a>define LOCAL</h1><h1 id="ifdef-LOCAL"><a href="#ifdef-LOCAL" class="headerlink" title="ifdef LOCAL"></a>ifdef LOCAL</h1><p> FILE *fin = freopen(“带宽in.txt”, “r”, stdin);<br> FILE *fout = freopen(“带宽out.txt”, “w”, stdout);</p>
<h1 id="endif"><a href="#endif" class="headerlink" title="endif"></a>endif</h1><p> using namespace std;<br> map&lt;int, set<int>&gt; xl;<br> int n;<br> int A[10],ans[10];<br> int vis[26];<br> int minb = 100000000;<br> void dfs(int cur, int B) {</p>
<pre><code>if (cur == n)
{
    //能到这，说明已经是最优解了，所以要更新ans和最小带宽
    memcpy(ans, A, sizeof(int)*n);
    minb = B;
}
else for (auto it = xl.begin(); it != xl.end();it++) {
    //由于给的点不一定是前n个，所以要用迭代器来遍历可以用的点
    int i = it-&gt;first;
    if (!vis[i]) {//vis[i]用来保证是个排列
        int m = 0;
        for (int j = 0; j &lt; cur; j++)
            if (!vis[A[j]] &amp;&amp; xl[i].count(A[j])) 
                m++;
        if (m &gt;= minb) return;//等于号很重要，用来保证是第一个最优解

        int ok = 1;
        A[cur] = i;
        for (int j = 0; j &lt; cur; j++) {

            if (xl[i].count(A[j])) {
                int w = cur - j;
                if (w &gt; B) B = w;
                if (B &gt;= minb) return;</code></pre></li>
</ol>
<pre><code>                }

            }

            if (ok) {
                vis[i] = 1;
                dfs(cur + 1, B);
                vis[i] = 0;//回溯：要么是到头了，回溯来找其他解；要么是中间返回，回溯以求正确解
            }
        }
    }
}
int main() {
    string line;
    while (getline(cin, line) &amp;&amp; line != &quot;# &quot;) {
        xl.clear();
        memset(A, -1, sizeof(A));
        bool flag = true;
        char u;
        for (int i = 0; i &lt; line.length(); i++) {
            if (isalpha(line[i])) {
                if (flag) {
                    u = line[i] - &apos;A&apos;;
                    flag = false;
                    xl[line[i] - &apos;A&apos;];
                }
                else {
                    xl[u].insert(line[i] - &apos;A&apos;);
                    xl[line[i] - &apos;A&apos;].insert(u);
                }
            }
            else if (line[i] == &apos;;&apos;) flag = true;
        }
        n = xl.size();
        memset(vis, 0, sizeof(vis));
        memset(ans, 0, sizeof(ans));
        minb = 100000000;
        dfs(0, 0);
        for (int i = 0; i &lt; n; i++) cout &lt;&lt; char(&apos;A&apos; + ans[i]) &lt;&lt; &quot; &quot;;
        cout &lt;&lt; &quot;-&gt; &quot;&lt;&lt;minb &lt;&lt; endl;


    }
}</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ceb</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ceb</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
  
</body>
</html>
