<!DOCTYPE html>


<html lang="en" >


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Hexo
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

  <script type="text/javascript"
	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-动态规划" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"
    >动态规划</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="article-date">
  <time datetime="2020-03-30T03:55:19.536Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="递推求解"><a class="markdownIt-Anchor" href="#递推求解"></a> 递推求解</h1>
<p>我理解为已知规模解的递归</p>
<h2 id="n阶楼梯上楼问题"><a class="markdownIt-Anchor" href="#n阶楼梯上楼问题"></a> N阶楼梯上楼问题</h2>
<h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3>
<ol>
<li>考虑最后一步，可以从n-2阶迈两步，或者从n-1阶迈一步。这样就将走法分成了两类，总的走法f(n)=f(n-1)+f(n-2)。而f(n-1)就是n-1阶时的走法，又可以分成两类，所以问题是一个递推问题</li>
<li>对于小规模的解，我们是知道的，f(1)=1,f(2)=2，所以递推得解</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">int f(int k) &#123;</span><br><span class="line">	if (k &#x3D;&#x3D; 1) return 1;</span><br><span class="line">	if (k &#x3D;&#x3D; 2) return 2;</span><br><span class="line">	return f(k - 1) + f(k - 2);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int k;</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;k)&#x3D;&#x3D;1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d\n&quot;, f(k));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hdu-1465-不容易系列之一"><a class="markdownIt-Anchor" href="#hdu-1465-不容易系列之一"></a> HDU 1465 不容易系列之一</h2>
<h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3>
<p>考虑n号信封里装着k号信，m号信封里装着n号信。按照k和m是否相等分成两类</p>
<ol>
<li>若k!=m，那么交换两封信后，除n号外，其余n-1封信都是错装。那么n号信有n-1中交换方式使得n号错序。此时f(n)=(n-1)*f(n-1)</li>
<li>若k==m，那么交换之后，有n-2封信错装。m有n-1种交换策略，此时，f(n)=(n-1)*f(n-2)</li>
<li>故**错装公式：f(n)=(n-1)<em>f(n-1)+(n-1)<em>f(n-2)</em></em></li>
</ol>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">long long f(int n) &#123;</span><br><span class="line">	if (n &#x3D;&#x3D; 1) return 0;</span><br><span class="line">	if (n &#x3D;&#x3D; 2) return 1;</span><br><span class="line">	return (n - 1)*(f(n - 1) + f(n - 2));</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%lld\n&quot;, f(n));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最长递增子序列-lis"><a class="markdownIt-Anchor" href="#最长递增子序列-lis"></a> 最长递增子序列 LIS</h1>
<p>用F[i]代表若递增子序列以ai结束时它的最长长度,易知F[1]=1.现假设已知F[1]-F[x-1]，依次比较ax和ai(i&lt;x)，如果ax&lt;ai，那么ax可以接在ai后面，使得子序列长度加1。取这些长度的最大值即为F[x]</p>
<h2 id="拦截导弹"><a class="markdownIt-Anchor" href="#拦截导弹"></a> 拦截导弹</h2>
<p>某国为了防御敌国的导弹袭击，开发出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭，并观测到导弹依次飞来的高度，请计算这套系统最多能拦截多少导弹。拦截来袭导弹时，必须按来袭导弹袭击的时间顺序，不允许先拦截后面的导弹，再拦截前面的导弹。<br />
求最多拦截导弹数量</p>
<h3 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h3>
<ol>
<li>本题求的是最长非递增子序列(不需连续)</li>
<li>对于第i个高度，可以将它加在它前面的比他大的序列末尾，并且保证加在最长的那条序列尾部即可</li>
<li>递推公式
<ol>
<li>f[1] =1</li>
<li>f[i] = max(1,f[j]+1) ;j&lt;i&amp;&amp;aj&gt;ai</li>
</ol>
</li>
</ol>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 30;</span><br><span class="line">int p[maxn];</span><br><span class="line">int dp[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int k;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;k) &#x3D;&#x3D; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;p[i]);</span><br><span class="line">		fill(dp, dp + k, 0);</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">			int cnt &#x3D; 1;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; i; j++)</span><br><span class="line">				if (p[j] &gt;&#x3D; p[i])</span><br><span class="line">					cnt &#x3D; max(cnt, dp[j] + 1);</span><br><span class="line">			dp[i] &#x3D; cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		int ans &#x3D; 1;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; i++)</span><br><span class="line">			ans &#x3D; max(ans, dp[i]);</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合唱队形"><a class="markdownIt-Anchor" href="#合唱队形"></a> 合唱队形</h2>
<p>给出k个同学的身高，问在位置不变的情况下，出队几名同学可以是队列呈现中间高两边低的状态</p>
<h3 id="思路-4"><a class="markdownIt-Anchor" href="#思路-4"></a> 思路</h3>
<ol>
<li>分别从两侧求递增子序列，然后求同一位置处两侧序列和最长的，即为结果序列长度</li>
<li>假设第i人满足1中条件，那么第i个人被算了两次，别忘了减去</li>
</ol>
<h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100+5;</span><br><span class="line">int p1[maxn];</span><br><span class="line">int p2[maxn];</span><br><span class="line">int dp1[maxn];</span><br><span class="line">int dp2[maxn];</span><br><span class="line">int k;</span><br><span class="line">void update_dp(int* dp, const int*p) &#123;</span><br><span class="line">	fill(dp, dp + k, 0);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">		int cnt &#x3D; 1;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; i; j++)</span><br><span class="line">			if (p[j] &lt; p[i])</span><br><span class="line">				cnt &#x3D; max(cnt, dp[j] + 1);</span><br><span class="line">		dp[i] &#x3D; cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;k) &#x3D;&#x3D; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;p1[i]);</span><br><span class="line">			p2[k - i - 1] &#x3D; p1[i];</span><br><span class="line">		&#125;</span><br><span class="line">		update_dp(dp1, p1);</span><br><span class="line">		update_dp(dp2, p2);</span><br><span class="line"></span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">			if (ans &lt; dp1[i] + dp2[k-i-1])</span><br><span class="line">				ans &#x3D; dp1[i] + dp2[k-i-1];</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, k-ans+1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最长公共子序列-lcs"><a class="markdownIt-Anchor" href="#最长公共子序列-lcs"></a> 最长公共子序列 LCS</h1>
<p>用dp[i][j]表示S1中前i个字符与S2中前j个字符分别组成的两个前缀字符串的最长公共子串，易知dp[0][j] = 0;递推公式为</p>
<ol>
<li>dp[0][j] = dp[i][0] = 0</li>
<li>dp[i][j] = dp[i-1][j-1]+1;S1[i]==S2[j]</li>
<li>dp[i][j] = max{dp[i][j-1],dp[i-1][j]};S1[i]!=S2[j]</li>
<li>最终dp[n][m]即为最长连续字串长</li>
<li>注意循环范围</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">char s1[maxn];</span><br><span class="line">char s2[maxn];</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line">int lcs(const char *s1, const char *s2) &#123;</span><br><span class="line">	memset(dp, 0, sizeof(dp));</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; strlen(s1); i++) &#123;</span><br><span class="line">		for (int j &#x3D; 1; j &lt;&#x3D; strlen(s2); j++) &#123;</span><br><span class="line">			if (s1[i-1] !&#x3D; s2[j-1])</span><br><span class="line">				dp[i][j] &#x3D; max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">			else</span><br><span class="line">				dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return dp[strlen(s1)][strlen(s2)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="状态与状态转移方程"><a class="markdownIt-Anchor" href="#状态与状态转移方程"></a> 状态与状态转移方程</h1>
<h2 id="状态"><a class="markdownIt-Anchor" href="#状态"></a> 状态</h2>
<ol>
<li>是一个数字量</li>
<li>可以描述一个状态的特征而不需要其他的辅助信息</li>
<li>状态间的转移完全依赖于状态本身</li>
</ol>
<h2 id="状态转移"><a class="markdownIt-Anchor" href="#状态转移"></a> 状态转移</h2>
<ol>
<li>指由一个或多个状态得到新状态的过程</li>
</ol>
<h1 id="动态规划问题举例"><a class="markdownIt-Anchor" href="#动态规划问题举例"></a> 动态规划问题举例</h1>
<h2 id="hdu-1421-搬寝室"><a class="markdownIt-Anchor" href="#hdu-1421-搬寝室"></a> HDU 1421 搬寝室</h2>
<p>搬寝室是很累的,xhd深有体会.时间追述2006年7月9号,那天xhd迫于无奈要从27号楼搬到3号楼,因为10号要封楼了.看着寝室里的n件物品,xhd开始发呆,因为n是一个小于2000的整数,实在是太多了,于是xhd决定随便搬2<em>k件过去就行了.但还是会很累,因为2</em>k也不小是一个不大于n的整数.幸运的是xhd根据多年的搬东西的经验发现每搬一次的疲劳度是和左右手的物品的重量差的平方成正比(这里补充一句,xhd每次搬两件东西,左手一件右手一件).例如xhd左手拿重量为3的物品,右手拿重量为6的物品,则他搬完这次的疲劳度为(6-3)^2 = 9.现在可怜的xhd希望知道搬完这2*k件物品后的最佳状态是怎样的(也就是最低的疲劳度),请告诉他吧.</p>
<p>每组输入数据有两行,第一行有两个数n,k(2&lt;=2*k&lt;=n&lt;2000).第二行有n个整数分别表示n件物品的重量(重量是一个小于2^15的正整数).</p>
<p>对应每组输入数据,输出数据只有一个表示他的最少的疲劳度,每个一行.</p>
<h3 id="思路-5"><a class="markdownIt-Anchor" href="#思路-5"></a> 思路</h3>
<ol>
<li>
<p>设dp[i][j]表示前i件物品组成j对所消耗的体力最小；所以分成了两种情况</p>
<ol>
<li>第j对里含有第i件物品，则dp [i][j] = dp [i-2][j-1] + (a[i]-a[i-1])*(a[i]-a[i-1]);</li>
<li>不含第i件物品则有：dp [i][j] = dp [i-1][j];</li>
</ol>
</li>
<li>
<p>总上，动态转移方程为:dp[i][j]=min(dp[i-2][j-1]+(a[i]-a[i-1])*(a[i]-a[i-1]), dp[i][j]=dp[i-1][j]);</p>
</li>
</ol>
<h3 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">int dp[2010][2010], a[2010];</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, k;</span><br><span class="line">	while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;k))</span><br><span class="line">	&#123;</span><br><span class="line">		int i, j;</span><br><span class="line">		memset(a, 0, sizeof(a));</span><br><span class="line">		memset(dp, 0, sizeof(dp));</span><br><span class="line">		for (i &#x3D; 0; i &lt;&#x3D; n; i++)</span><br><span class="line">			for (j &#x3D; 1; j &lt;&#x3D; k; j++)</span><br><span class="line">				dp[i][j] &#x3D; inf;</span><br><span class="line">		for (i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">		sort(a, a + n + 1);</span><br><span class="line">		for (i &#x3D; 2; i &lt;&#x3D; n; i++)</span><br><span class="line">			for (j &#x3D; 1; j * 2 &lt;&#x3D; i; j++)</span><br><span class="line">				dp[i][j] &#x3D; min(dp[i - 1][j], dp[i - 2][j - 1] + (a[i] - a[i - 1])*(a[i] - a[i - 1]));</span><br><span class="line">		printf(&quot;%d\n&quot;, dp[n][k]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hdu-3578-greedy-tino"><a class="markdownIt-Anchor" href="#hdu-3578-greedy-tino"></a> HDU 3578 Greedy Tino</h2>
<p>未完待续</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define OFFSET 2000&#x2F;&#x2F;因为j有正负，所以添加一个偏移量，方便做题</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line">int wi[101];</span><br><span class="line">int dp[101][4001];</span><br><span class="line">int max(int a, int b, int c)&#123;</span><br><span class="line">    int flag &#x3D; a;</span><br><span class="line">    if(flag &lt; b)&#123;</span><br><span class="line">        flag &#x3D; b;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag &lt; c)&#123;</span><br><span class="line">        flag &#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i&#x3D;0;i&lt;40001;i++)</span><br><span class="line">            dp[0][i] &#x3D; -INF;</span><br><span class="line">    dp[0][OFFSET] &#x3D; 0;&#x2F;&#x2F;core</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t, n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; t; i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        wi[0] &#x3D; 0;</span><br><span class="line">         bool hasZero &#x3D; false;</span><br><span class="line">        int cnt &#x3D; 0;</span><br><span class="line">        for(int j &#x3D; 0; j &lt; n; j++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;wi[++cnt]);</span><br><span class="line">            if(wi[cnt] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                   hasZero &#x3D; true;</span><br><span class="line">                   cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n &#x3D; cnt;</span><br><span class="line">        init();</span><br><span class="line">        for(int j &#x3D; 1; j &lt;&#x3D; n; j++)&#123;</span><br><span class="line">            for(int k &#x3D; -2000; k &lt;&#x3D; 2000; k++)&#123;</span><br><span class="line">                dp[j][k+OFFSET] &#x3D; max(dp[j-1][k-wi[j]+OFFSET]+wi[j], dp[j-1][k+wi[j]+OFFSET]+wi[j], dp[j-1][k+OFFSET]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf (&quot;Case %d: &quot;, i+1);</span><br><span class="line">        if(dp[n][0+OFFSET] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            if(hasZero &#x3D;&#x3D; true)&#123;</span><br><span class="line">                printf(&quot;0\n&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                printf(&quot;-1\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            printf(&quot;%d\n&quot;, dp[n][0+OFFSET]&#x2F;2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="背包"><a class="markdownIt-Anchor" href="#背包"></a> 背包</h1>
<h2 id="0-1背包问题"><a class="markdownIt-Anchor" href="#0-1背包问题"></a> 0-1背包问题</h2>
<p>特点是每个物品只能选一件，即每个物品的数量只能出现0和1</p>
<h3 id="openj_bailian-2726"><a class="markdownIt-Anchor" href="#openj_bailian-2726"></a> OpenJ_Bailian 2726</h3>
<p>辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是辰辰，你能完成这个任务吗？</p>
<h3 id="思路-6"><a class="markdownIt-Anchor" href="#思路-6"></a> 思路</h3>
<ol>
<li>用dp[i][j]表示取前i个物品，重量不超过j时能达到的最大价值。</li>
<li>可以根据第i个物品是否取分成两类
<ol>
<li>取第i个物品，那么需要更新所有能再装下一个i的状态，即dp[i-1][j-p[i].w]</li>
<li>不取i，那么dp[i][j]=dp[i-1][j]</li>
</ol>
</li>
<li>综上，递推关系为dp[i][j] = max(dp[i-1][j], dp[i - 1][j - p[i].w] + p[i].v)</li>
<li><strong>注意</strong> 对于dp[i-1][j]下装不下第i个物品的状态，要赋值为dp[i-1][j]</li>
</ol>
<h3 id="代码-5"><a class="markdownIt-Anchor" href="#代码-5"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line">struct node &#123;</span><br><span class="line">	int w;</span><br><span class="line">	int v;</span><br><span class="line">&#125;;</span><br><span class="line">int s, m;</span><br><span class="line">node p[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;s, &amp;m) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;p[i].w, &amp;p[i].v);</span><br><span class="line"></span><br><span class="line">		memset(dp, 0, sizeof(0));</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">			for (int j &#x3D; s; j &gt;&#x3D; p[i].w; j--) &#123;</span><br><span class="line">				dp[i][j] &#x3D; max(dp[i-1][j], dp[i - 1][j - p[i].w] + p[i].v);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			for (int j &#x3D; p[i].w-1; j &gt;&#x3D; 0; j--)&#x2F;&#x2F;对于p[i].w-1~1的状态只能来自于dp[i-1][j]</span><br><span class="line">				dp[i][j] &#x3D; dp[i-1][j];</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, dp[m][s]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h3>
<ol>
<li>发现新的状态至于最近的一个状态有关，所以可以降维。</li>
<li>状态转移方程为：dp[j]=max{dp[j-p[i].w]+v,dp[i]}</li>
<li><strong>注意</strong> 更新dp时是逆序更新，这是因为在0-1背包问题中每个物品至多放入一次。逆序循环，保证了更新dp[j]时，dp[j-p[i].w]是没有放入i时的数据(dp[i-1][j-p[i].w])</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">	for (int j &#x3D; s; j &gt;&#x3D; p[i].w; j--) &#123;</span><br><span class="line">		dp[j]&#x3D;max(dp[j-p[i].w]+v,dp[i]);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完全背包问题"><a class="markdownIt-Anchor" href="#完全背包问题"></a> 完全背包问题</h2>
<p>每种物品的数量可以任意多</p>
<h3 id="hdu-1114-piggy-bank"><a class="markdownIt-Anchor" href="#hdu-1114-piggy-bank"></a> HDU 1114 Piggy-Bank</h3>
<p>有个存钱罐，已知空罐质量和满罐质量，以及n种硬币质量和价值，求罐中硬币的最小价值。</p>
<h3 id="思路-7"><a class="markdownIt-Anchor" href="#思路-7"></a> 思路</h3>
<ol>
<li>完全背包问题的区别在于，每个物品可以被选择很多次，因此dp[j]可以由已放入物品i后的数据dp[j-p[i].w]得来，所以顺序循环</li>
<li>本题求最小值，将max要换成min</li>
<li>由于要求恰好装满，所以初始时只有dp[0]=0，其他状态都不存在</li>
</ol>
<h3 id="代码-6"><a class="markdownIt-Anchor" href="#代码-6"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 10000+ 5;</span><br><span class="line">int dp[maxn];</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line">struct node &#123;</span><br><span class="line">	int w;</span><br><span class="line">	int v;</span><br><span class="line">&#125;;</span><br><span class="line">int s, m;</span><br><span class="line">node p[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;m, &amp;s);</span><br><span class="line">		s -&#x3D; m;</span><br><span class="line">		int n;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;p[i].v, &amp;p[i].w);</span><br><span class="line">		for (int i &#x3D; 0; i &lt;&#x3D; s; i++)</span><br><span class="line">			dp[i] &#x3D; INF;</span><br><span class="line">		dp[0] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; p[i].w; j &lt;&#x3D; s;j++) &#123;</span><br><span class="line">				if (dp[j - p[i].w] !&#x3D; INF)&#x2F;&#x2F;该状态存在，那么才可以产生新的状态</span><br><span class="line">					dp[j] &#x3D; min(dp[j], dp[j - p[i].w] + p[i].v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (dp[s] !&#x3D; INF)</span><br><span class="line">			printf(&quot;The minimum amount of money in the piggy-bank is %d.\n&quot;, dp[s]);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot;This is impossible.\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多重背包问题"><a class="markdownIt-Anchor" href="#多重背包问题"></a> 多重背包问题</h2>
<p>介于完全背包问题和0-1背包问题之间，每种物品数量有限。可以将k个物品看作k种物品，在进行0-1背包求解。但是这样会使时间复杂度过大。稍加改变，将该种物品分成很多堆，每堆数量为1~k-2<sup>c+1,其中c为使k-2</sup>c+1大于0的最大整数。</p>
<h3 id="hdu-2191-珍惜现在感恩生活"><a class="markdownIt-Anchor" href="#hdu-2191-珍惜现在感恩生活"></a> HDU 2191 珍惜现在，感恩生活</h3>
<p>输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1&lt;=n&lt;=100, 1&lt;=m&lt;=100),分别表示经费的金额和大米的种类，然后是m行数据，每行包含3个数p，h和c(1&lt;=p&lt;=20,1&lt;=h&lt;=200,1&lt;=c&lt;=20)，分别表示每袋的价格、每袋的重量以及对应种类大米的袋数。</p>
<p>对于每组测试数据，请输出能够购买大米的最多重量，你可以假设经费买不光所有的大米，并且经费你可以不用完。每个实例的输出占一行。</p>
<h3 id="思路-8"><a class="markdownIt-Anchor" href="#思路-8"></a> 思路</h3>
<ol>
<li>先将每个物品分成很多堆，类似二进制拆分</li>
<li>然后进行0-1背包求解</li>
</ol>
<h3 id="代码-7"><a class="markdownIt-Anchor" href="#代码-7"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 10000 + 5;</span><br><span class="line">int dp[maxn];</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line">struct node &#123;</span><br><span class="line">	int w;</span><br><span class="line">	int v;</span><br><span class="line">&#125;;</span><br><span class="line">int s, m;</span><br><span class="line">node a[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;s, &amp;m);</span><br><span class="line">		int p, h, c;</span><br><span class="line">		int cnt &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;p, &amp;h, &amp;c);</span><br><span class="line">			int t &#x3D; 1;</span><br><span class="line">			while (c &gt; t)</span><br><span class="line">			&#123;</span><br><span class="line">				c -&#x3D; t;</span><br><span class="line">				a[++cnt].w &#x3D; t * p;</span><br><span class="line">				a[cnt].v &#x3D; t * h;</span><br><span class="line">				t *&#x3D; 2;</span><br><span class="line">			&#125;</span><br><span class="line">			a[++cnt].w &#x3D; p * c;</span><br><span class="line">			a[cnt].v &#x3D; h * c;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		memset(dp, 0, sizeof(dp));</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; cnt; i++) &#123;</span><br><span class="line">			for (int j &#x3D; s; j &gt;&#x3D; a[i].w;j--) &#123;</span><br><span class="line">					dp[j] &#x3D; max(dp[j], dp[j - a[i].w] + a[i].v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;%d\n&quot;, dp[s]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-基础相关" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/"
    >基础相关</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/" class="article-date">
  <time datetime="2020-03-30T03:55:19.536Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="日期类"><a class="markdownIt-Anchor" href="#日期类"></a> 日期类</h1>
<h2 id="date"><a class="markdownIt-Anchor" href="#date"></a> Date</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const static int Month[13][2] &#x3D; &#123;</span><br><span class="line">	&#123;0,0&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;28,29&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;30,30&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;30,30&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;30,30&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;30,30&#125;,</span><br><span class="line">	&#123;31,31&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct  Date</span><br><span class="line">&#123;</span><br><span class="line">	int year;</span><br><span class="line">	int month;</span><br><span class="line">	int day;</span><br><span class="line"></span><br><span class="line">	Date(int d, int m, int y) :year(y), day(d), month(m) &#123;&#125;;</span><br><span class="line">	bool isLeap(int year) &#123;</span><br><span class="line">		return year % 100 !&#x3D; 0 &amp;&amp; year % 4 &#x3D;&#x3D; 0 || year % 400 &#x3D;&#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void nextDay() &#123;</span><br><span class="line">		day++;</span><br><span class="line">		if (day &gt; Month[month][isLeap(year)]) &#123;</span><br><span class="line">			day &#x3D; 1;</span><br><span class="line">			month++;</span><br><span class="line">			if (month &gt; 12) &#123;</span><br><span class="line">				month &#x3D; 1;</span><br><span class="line">				year++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="打表"><a class="markdownIt-Anchor" href="#打表"></a> 打表</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int cnt &#x3D; 0;</span><br><span class="line">	Date tmp(1,1,0) ;</span><br><span class="line">	while (tmp.year&lt;&#x3D;5000)</span><br><span class="line">	&#123;</span><br><span class="line">		buf[tmp.year][tmp.month][tmp.day]  &#x3D; cnt;</span><br><span class="line">		tmp.nextDay();</span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求两个日期间隔多少天-日期差值"><a class="markdownIt-Anchor" href="#求两个日期间隔多少天-日期差值"></a> 求两个日期间隔多少天 日期差值</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	</span><br><span class="line">	int y1, m1, d1;</span><br><span class="line">	int y2, m2, d2;</span><br><span class="line">	while (scanf(&quot;%4d %2d %2d&quot;,&amp;y1,&amp;m1,&amp;d1))</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%4d %2d %2d&quot;, &amp;y2, &amp;m2, &amp;d2);</span><br><span class="line">		printf(&quot;%d\n&quot;, abs(buf[y1][m1][d1] - buf[y2][m2][d2])+1);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>注意输入%xd的方法。+1别忘了</li>
<li>将输入日期统一到0年1月1日为起点</li>
</ol>
<h3 id="求给定日期是星期几-day-of-week"><a class="markdownIt-Anchor" href="#求给定日期是星期几-day-of-week"></a> 求给定日期是星期几 Day of Week</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">const static char NMonth[13][20] &#x3D; &#123;</span><br><span class="line">	&quot;&quot;,</span><br><span class="line">	&quot;January&quot;,</span><br><span class="line">	&quot;February&quot;,</span><br><span class="line">	&quot;March&quot;,</span><br><span class="line">	&quot;April&quot;,</span><br><span class="line">	&quot;May&quot;,</span><br><span class="line">	&quot;June&quot;,</span><br><span class="line">	&quot;July&quot;,</span><br><span class="line">	&quot;August&quot;,</span><br><span class="line">	&quot;September&quot;,</span><br><span class="line">	&quot;October&quot;,</span><br><span class="line">	&quot;November&quot;,</span><br><span class="line">	&quot;December&quot;</span><br><span class="line">&#125;;</span><br><span class="line">const static char week[7][20] &#x3D; &#123;</span><br><span class="line">	&quot;Sunday&quot;,</span><br><span class="line">	&quot;Monday&quot;,</span><br><span class="line">	&quot;Tuesday&quot;,</span><br><span class="line">	&quot;Wednesday&quot;,</span><br><span class="line">	&quot;Thursday&quot;,</span><br><span class="line">	&quot;Friday&quot;,</span><br><span class="line">	&quot;Saturday&quot;</span><br><span class="line">&#125;;</span><br><span class="line">int y, d;</span><br><span class="line">char month[20];</span><br><span class="line">while (scanf(&quot;%d%s%4d&quot;, &amp;d, month, &amp;y) !&#x3D; EOF)</span><br><span class="line">&#123;</span><br><span class="line">	int m;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; 12; i++)</span><br><span class="line">		if (!strcmp(month, NMonth[i])) &#123;</span><br><span class="line">			m &#x3D; i;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	int days &#x3D; buf[y][m][d] - buf[2020][2][5];</span><br><span class="line">	days +&#x3D; 3;</span><br><span class="line">	printf(&quot;%s\n&quot;, week[(days % 7 + 7) % 7]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure>
<ol>
<li>也是将输入日期统一到0年1月1日为起点</li>
<li>然后计算与今天的差，</li>
</ol>
<h1 id="hash"><a class="markdownIt-Anchor" href="#hash"></a> Hash</h1>
<h2 id="输出前m大的数"><a class="markdownIt-Anchor" href="#输出前m大的数"></a> 输出前m大的数</h2>
<p>将数值看成数组下标，从数组尾部开始输出m个存在的数字。</p>
<h2 id="其他使用"><a class="markdownIt-Anchor" href="#其他使用"></a> 其他使用</h2>
<ol>
<li>主要是记录每个数字出现的次数的思想</li>
</ol>
<h1 id="排版题"><a class="markdownIt-Anchor" href="#排版题"></a> 排版题</h1>
<h2 id="输出梯形"><a class="markdownIt-Anchor" href="#输出梯形"></a> 输出梯形</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">#pragma warning(disable:4996)</span><br><span class="line">const int maxn &#x3D; 1005;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">	&#123;</span><br><span class="line">		int m &#x3D; n + 2 * (n - 1);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; m-n-2*i; j++) &#123;</span><br><span class="line">				printf(&quot; &quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; n+i*2; j++) &#123;</span><br><span class="line">				printf(&quot;*&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="叠筐-hdu2074"><a class="markdownIt-Anchor" href="#叠筐-hdu2074"></a> 叠筐 HDU2074</h2>
<p>需要的时候，就把一个个大小差一圈的筐叠上去，使得从上往下看时，边筐花色交错。这个工作现在要让计算机来完成，得看你的了。<br />
输入是一个个的三元组，分别是，外筐尺寸n（n为满足0&lt;n&lt;80的奇整数），中心花色字符，外筐花色字符，后二者都为ASCII可见字符；<br />
输出叠在一起的筐图案，中心花色与外筐花色字符从内层起交错相叠，多筐相叠时，最外筐的角总是被打磨掉。叠筐与叠筐之间应有一行间隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 80 + 5;</span><br><span class="line">char g[maxn][maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	char a, b;</span><br><span class="line">	int first &#x3D; 1;</span><br><span class="line">	while (scanf(&quot;%d %c %c\n&quot;, &amp;n, &amp;b, &amp;a) &#x3D;&#x3D; 3)</span><br><span class="line">	&#123;</span><br><span class="line">		if (((n - 1) &#x2F; 2) % 2 &#x3D;&#x3D; 0) std::swap(a, b);</span><br><span class="line">		memset(g, b, sizeof(g));</span><br><span class="line">		if (first) first &#x3D; 0;</span><br><span class="line">		else printf(&quot;\n&quot;);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i +&#x3D; 2) &#123;</span><br><span class="line">			for (int j &#x3D; i; j &lt; n - 2 * i + i; j++) &#123;</span><br><span class="line">				g[i][j] &#x3D; g[n - i - 1][j] &#x3D; a;</span><br><span class="line">				g[j][i] &#x3D; g[j][n - i - 1] &#x3D; a;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (n !&#x3D; 1)</span><br><span class="line">			g[0][0] &#x3D; g[0][n - 1] &#x3D; g[n - 1][0] &#x3D; g[n - 1][n - 1] &#x3D; &#39; &#39;;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">				printf(&quot;%c&quot;, g[i][j]);</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="repeater"><a class="markdownIt-Anchor" href="#repeater"></a> Repeater</h2>
<p>Harmony is indispensible in our daily life and no one can live without it----may be Facer is the only exception. One day it is rumored that repeat painting will create harmony and then hundreds of people started their endless drawing. Their paintings were based on a small template and a simple method of duplicating. Though Facer can easily imagine the style of the whole picture, but he cannot find the essential harmony. Now you need to help Facer by showing the picture on computer. You will be given a template containing only one kind of character and spaces, and the template shows how the endless picture is created----use the characters as basic elements and put them in the right position to form a bigger template, and then repeat and repeat doing that. Here is an example. # #  #      &lt;-template # # So the Level 1 picture will be # #  # # # Level 2 picture will be # #     # #  #         # # #     # #      # #         #         # #   # #    # #  #        # # #    # #</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 3000 + 5;</span><br><span class="line">char g[maxn][maxn];</span><br><span class="line">char tmp[maxn][maxn];</span><br><span class="line">char tmp2[maxn][maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int p, q;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;p) &#x3D;&#x3D; 1 &amp;&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		getchar();</span><br><span class="line">		memset(g, &#39; &#39;, sizeof(g));</span><br><span class="line">		for (int i &#x3D; 0; i &lt; p; i++)</span><br><span class="line">			std::cin.getline(g[i], 6);</span><br><span class="line"></span><br><span class="line">		scanf(&quot;%d&quot;, &amp;q);</span><br><span class="line"></span><br><span class="line">		memcpy(tmp, g, sizeof(g));</span><br><span class="line">		if (q !&#x3D; 1)</span><br><span class="line">			for (int scale &#x3D; 2; scale &lt;&#x3D; q; scale++) &#123;&#x2F;&#x2F;代</span><br><span class="line">				memset(tmp2, &#39; &#39;, sizeof(tmp2));</span><br><span class="line">				int r , c ;</span><br><span class="line">				int oldr, oldc;</span><br><span class="line">				oldr &#x3D; oldc &#x3D; pow(p, scale - 1);</span><br><span class="line">				for (int i &#x3D; 0; i &lt; p; i++) &#123;</span><br><span class="line">					for (int j &#x3D; 0; j &lt; p; j++) &#123;&#x2F;&#x2F;初代模板</span><br><span class="line">						r &#x3D; i * oldr;</span><br><span class="line">						c &#x3D; j * oldc;</span><br><span class="line">						if (g[i][j] !&#x3D; &#39; &#39;) &#123;</span><br><span class="line">							for (int k &#x3D; 0; k &lt; oldr; k++) &#123;&#x2F;&#x2F;在元素处复制模板</span><br><span class="line">								for (int f &#x3D; 0; f &lt; oldc; f++)</span><br><span class="line">									tmp2[r + k][c + f] &#x3D; tmp[k][f];</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				memcpy(tmp, tmp2,sizeof(tmp2));</span><br><span class="line">			&#125;</span><br><span class="line">		for (int k &#x3D; 0; k &lt; pow(p, q); k++) &#123;</span><br><span class="line">			for (int f &#x3D; 0; f &lt; pow(p, q); f++) &#123;</span><br><span class="line"></span><br><span class="line">				printf(&quot;%c&quot;, tmp[k][f]);</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h1>
<h2 id="查找学生信息-二分查找"><a class="markdownIt-Anchor" href="#查找学生信息-二分查找"></a> 查找学生信息 二分查找</h2>
<p>输入N个学生的信息，然后进行查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">	int no;</span><br><span class="line">	string name;</span><br><span class="line">	string sex;</span><br><span class="line">	int age;</span><br><span class="line">	node() &#123;&#125;;</span><br><span class="line">	node(int no, string name, string sex, int age)</span><br><span class="line">		:no(no), name(name), sex(sex), age(age) &#123;&#125;;</span><br><span class="line">	bool operator &lt; (const node &amp;a) const &#123;</span><br><span class="line">		return no &lt; a.no;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">node stu[maxn];</span><br><span class="line">int bsearch(int l, int r, int q) &#123;</span><br><span class="line">	while (l &lt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		int m &#x3D; l + (r - l) &#x2F; 2;</span><br><span class="line">		if (stu[m].no &#x3D;&#x3D; q) return m;</span><br><span class="line">		else if (stu[m].no &gt; q) r &#x3D; m;</span><br><span class="line">		else l &#x3D; m + 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (cin&gt;&gt;n&amp;&amp;n) &#123;</span><br><span class="line">		string  b, c;</span><br><span class="line">		int a,d;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">			stu[i] &#x3D; node(a, b, c, d);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(stu, stu + n);</span><br><span class="line">		int m;</span><br><span class="line">		cin &gt;&gt; m;</span><br><span class="line">		int que;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			cin &gt;&gt; que;</span><br><span class="line">			int ans &#x3D; bsearch(0, n, que);</span><br><span class="line">			ans !&#x3D; -1 ? cout &lt;&lt; stu[ans].no&lt;&lt;&quot; &quot;&lt;&lt;stu[ans].name&lt;&lt;&quot; &quot;&lt;&lt;stu[ans].sex&lt;&lt;&quot; &quot;&lt;&lt;stu[ans].age &lt;&lt; endl </span><br><span class="line">				: cout &lt;&lt; &quot;No Answer!&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="打印极值点下标"><a class="markdownIt-Anchor" href="#打印极值点下标"></a> 打印极值点下标</h2>
<p>在一个整数数组上，对于下标为i的整数，如果它大于所有它相邻的整数， 或者小于所有它相邻的整数，则称为该整数为一个极值点，极值点的下标就是i。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 80 + 5;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line"></span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n)&#x3D;&#x3D;1&amp;&amp;n)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		int x;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		if (n &gt; 2) &#123;</span><br><span class="line">			if (a[2] &gt; a[1]) a[0] &#x3D; a[1] + 1;</span><br><span class="line">			else if(a[2] &lt; a[1]) a[0] &#x3D; a[1] - 1;</span><br><span class="line">			else a[0] &#x3D; a[1];</span><br><span class="line">		&#125;</span><br><span class="line">		if (a[n - 1] &lt; a[n]) a[n + 1] &#x3D; a[n] - 1;</span><br><span class="line">		else if (a[n - 1] &gt; a[n]) a[n + 1] &#x3D; a[n] + 1;</span><br><span class="line">		else a[n + 1] &#x3D; a[n];</span><br><span class="line"></span><br><span class="line">		int first &#x3D; 1;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			int x &#x3D; a[i] - a[i - 1];</span><br><span class="line">			int y &#x3D; a[i] - a[i + 1];</span><br><span class="line">			</span><br><span class="line">			if (x*y &gt; 0) &#123;</span><br><span class="line">				if (first) first &#x3D; 0;</span><br><span class="line">				else printf(&quot; &quot;);</span><br><span class="line">				printf(&quot;%d&quot;, i-1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找-2"><a class="markdownIt-Anchor" href="#查找-2"></a> 查找</h2>
<p>读入一组字符串（待操作的），再读入一个int n记录记下来有几条命令，总共有2中命令：1、翻转  从下标为i的字符开始到i+len-1之间的字符串倒序；2、替换  命中如果第一位为1，用命令的第四位开始到最后的字符串替换原读入的字符串下标 i 到 i+len-1的字符串。每次执行一条命令后新的字符串代替旧的字符串（即下一条命令在作用在得到的新字符串上）。     命令格式：第一位0代表翻转，1代表替换；第二位代表待操作的字符串的起始下标int i；第三位表示需要操作的字符串长度int len。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">char s[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%s&quot;,s)&#x3D;&#x3D;1)</span><br><span class="line">	&#123;</span><br><span class="line">		int n;</span><br><span class="line">		int first &#x3D; 1;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		int op, index, len;</span><br><span class="line">		char ex[maxn];</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%1d%1d%1d&quot;, &amp;op, &amp;index, &amp;len);</span><br><span class="line">			if (op) scanf(&quot;%s&quot;,ex);</span><br><span class="line">			if (op &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				for (int j &#x3D; 0; 2*j &lt; len; j++) &#123;</span><br><span class="line">					swap(s[index + j], s[index + len - j-1]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				char tmp[maxn]&#123;&#39;\0&#39;&#125;;</span><br><span class="line">				for (int j &#x3D; 0; j &lt; index; j++) tmp[j] &#x3D; s[j];</span><br><span class="line">				for (int j &#x3D; 0; j &lt; strlen(ex); j++)</span><br><span class="line">					tmp[j + index] &#x3D; ex[j];</span><br><span class="line">				for (int j &#x3D; index; j &lt; strlen(s); j++)</span><br><span class="line">					tmp[j+strlen(ex)] &#x3D; s[j+len];</span><br><span class="line"></span><br><span class="line">				memcpy(s, tmp, sizeof(tmp));</span><br><span class="line">			&#125;</span><br><span class="line">			if (first) first &#x3D; 0;</span><br><span class="line">			else printf(&quot;\n&quot;);</span><br><span class="line">			printf(&quot;%s&quot;, s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="贪心算法"><a class="markdownIt-Anchor" href="#贪心算法"></a> 贪心算法</h1>
<h2 id="fatmouses-trade"><a class="markdownIt-Anchor" href="#fatmouses-trade"></a> FatMouse’s Trade</h2>
<p>FatMouse prepared M pounds of cat food, ready to trade with the cats guarding the warehouse containing his favorite food, JavaBean.<br />
The warehouse has N rooms. The i-th room contains J[i] pounds of JavaBeans and requires F[i] pounds of cat food. FatMouse does not have to trade for all the JavaBeans in the room, instead, he may get J[i]* a% pounds of JavaBeans if he pays F[i]* a% pounds of cat food. Here a is a real number. Now he is assigning this homework to you: tell him the maximum amount of JavaBeans he can obtain.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int j;</span><br><span class="line">	int f;</span><br><span class="line">	double v;</span><br><span class="line">	bool operator &lt;(const node &amp;a) const &#123; return v &lt; a.v; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node a[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int m, n;</span><br><span class="line">	int j, f;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;m, &amp;n) &amp;&amp; m !&#x3D; -1 &amp;&amp; n !&#x3D; -1) &#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;j, &amp;f);</span><br><span class="line">			a[i].f &#x3D; f;</span><br><span class="line">			a[i].j &#x3D; j;</span><br><span class="line">			a[i].v &#x3D; double(j) &#x2F; f;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a, a + n);</span><br><span class="line">		double ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			if (m &gt; a[i].f) &#123;</span><br><span class="line">				m -&#x3D; a[i].f;</span><br><span class="line">				ans +&#x3D; a[i].j;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				ans +&#x3D; double(m) * a[i].j &#x2F; a[i].f;</span><br><span class="line">				m &#x3D; 0;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (m &lt;&#x3D; 0) break;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%.3f\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择不连续区间问题"><a class="markdownIt-Anchor" href="#选择不连续区间问题"></a> 选择不连续区间问题</h2>
<h2 id="迷瘴"><a class="markdownIt-Anchor" href="#迷瘴"></a> 迷瘴</h2>
<p>通过悬崖的yifenfei，又面临着幽谷的考验——<br />
幽谷周围瘴气弥漫，静的可怕，隐约可见地上堆满了骷髅。由于此处长年不见天日，导致空气中布满了毒素，一旦吸入体内，便会全身溃烂而死。<br />
幸好yifenfei早有防备，提前备好了解药材料（各种浓度的万能药水）。现在只需按照配置成不同比例的浓度。<br />
现已知yifenfei随身携带有n种浓度的万能药水，体积V都相同，浓度则分别为Pi%。并且知道，针对当时幽谷的瘴气情况，只需选择部分或者全部的万能药水，然后配置出浓度不大于 W%的药水即可解毒。<br />
现在的问题是：如何配置此药，能得到最大体积的当前可用的解药呢？<br />
特别说明：由于幽谷内设备的限制,只允许把一种已有的药全部混入另一种之中（即：不能出现对一种药只取它的一部分这样的操作）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">int a[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	int n, v, w;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, &amp;n, &amp;v, &amp;w);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a, a + n);</span><br><span class="line"></span><br><span class="line">		double nw &#x3D; 0;</span><br><span class="line">		int nv &#x3D; 0;</span><br><span class="line">		double tmp;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			tmp &#x3D; (nw  * nv + a[i] * v) &#x2F; (v + nv);</span><br><span class="line">			if (tmp &lt;&#x3D; w) &#123;</span><br><span class="line">				nw &#x3D; tmp;</span><br><span class="line">				nv +&#x3D; v;</span><br><span class="line">			&#125;</span><br><span class="line">			else break;</span><br><span class="line">		&#125;</span><br><span class="line">		if(nv&#x3D;&#x3D;0)</span><br><span class="line">			printf(&quot;0 0.00\n&quot;);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot;%d %.2lf\n&quot;, nv, nw&#x2F;100);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>我的实现全部使用整型避免了浮点数误差。关于<a href="https://www.cnblogs.com/crazyacking/p/4668471.html" target="_blank" rel="noopener">浮点数误差</a></li>
</ol>
<h2 id="to-fill-or-not-to-fill"><a class="markdownIt-Anchor" href="#to-fill-or-not-to-fill"></a> To Fill or Not to Fill</h2>
<p>With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go.</p>
<p>For each case, the first line contains 4 positive numbers: Cmax (&lt;= 100), the maximum capacity of the tank; D (&lt;=30000), the distance between Hangzhou and the destination city; Davg (&lt;=20), the average distance per unit gas that the car can run; and N (&lt;= 500), the total number of gas stations. Then N lines follow, each contains a pair of non-negative numbers: Pi, the unit gas price, and Di (&lt;=D), the distance between this station and Hangzhou, for i=1,…N. All the numbers in a line are separated by a space.</p>
<p>For each test case, print the cheapest price in a line, accurate up to 2 decimal places. It is assumed that the tank is empty at the beginning. If it is impossible to reach the destination, print “The maximum travel distance = X” where X is the maximum possible distance the car can run, accurate up to 2 decimal places.</p>
<h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3>
<ol>
<li>
<p>在每一站处，查找能到达的站中油价比当前站便宜的站。如果没有，则找一个相对最便宜的。</p>
<ol>
<li>如果找到了比当前站便宜的，那么在本站只需要加油到刚好到达最便宜的站。</li>
<li>如果没有比当前更便宜的，那么把油箱加满，并直接开到这个相对最便宜的站。</li>
</ol>
</li>
<li>
<p>如果在当前的站处能够到达的最大范围内都没有站</p>
<ol>
<li>如果能到达终点，那么输出总价</li>
<li>否则计算出走的最大长度，加上当前站的位置即为最大移动距离</li>
</ol>
</li>
<li>
<p>这样保证了每次都是朝着油价最便宜的站进发，同时油箱里的油比沿路的站都便宜。</p>
</li>
</ol>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 500 + 5;</span><br><span class="line">struct node &#123;</span><br><span class="line">	double price;</span><br><span class="line">	double dis;</span><br><span class="line">	bool operator &lt; (const node&amp;a) const &#123;</span><br><span class="line">		return dis &lt; a.dis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int ns &#x3D; 0;</span><br><span class="line"></span><br><span class="line">node a[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	double c, dis, cost;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%lf%lf%lf%d&quot;, &amp;c, &amp;dis, &amp;cost, &amp;n) &#x3D;&#x3D; 4)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			scanf(&quot;%lf%lf&quot;, &amp;a[i].price, &amp;a[i].dis);</span><br><span class="line">		&#x2F;&#x2F;a[n].price &#x3D; 0;</span><br><span class="line">		&#x2F;&#x2F;a[n].dis &#x3D; dis;</span><br><span class="line">		sort(a, a + n);</span><br><span class="line">		double maxd &#x3D; c * cost;</span><br><span class="line">		double nc &#x3D; 0;</span><br><span class="line">		double no &#x3D; 0;</span><br><span class="line">		int ns &#x3D; 0;</span><br><span class="line">		if (dis&#x3D;&#x3D; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;0.00\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		if (a[0].dis !&#x3D; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;The maximum travel distance &#x3D; 0.00\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		while (ns &lt; n) &#123;</span><br><span class="line">			&#x2F;&#x2F;printf(&quot;%d\n&quot;, ns);</span><br><span class="line">			double minc &#x3D; 100000;</span><br><span class="line">			int index;</span><br><span class="line">			bool havenx &#x3D; false;</span><br><span class="line">			bool cheaper &#x3D; false;</span><br><span class="line">			for (int i &#x3D; ns + 1; i &lt; n; i++) &#123;</span><br><span class="line">				if ((a[i].dis - a[ns].dis) &lt;&#x3D; maxd) &#123;&#x2F;&#x2F;有更便宜的</span><br><span class="line">					havenx &#x3D; true;</span><br><span class="line">					if (a[i].price &lt; a[ns].price) &#123;</span><br><span class="line">						cheaper &#x3D; true;</span><br><span class="line">						double d &#x3D; a[i].dis - a[ns].dis;</span><br><span class="line">						nc +&#x3D; a[ns].price*(d &#x2F; cost - no);</span><br><span class="line">						no &#x3D; 0;</span><br><span class="line">						ns &#x3D; i;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					else if (a[i].price &lt; minc) &#123;&#x2F;&#x2F;目前没有更便宜的，则记录一下相对最便宜的</span><br><span class="line">						minc &#x3D; a[i].price;</span><br><span class="line">						index &#x3D; i;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				else break;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (!cheaper &amp;&amp; (maxd &gt;&#x3D; (dis - a[ns].dis))) &#123;</span><br><span class="line">				</span><br><span class="line">				&#x2F;&#x2F;没有更便宜的，但是能直接走到终点，那么直接走</span><br><span class="line">				double d &#x3D; dis - a[ns].dis;</span><br><span class="line">				nc +&#x3D; (d &#x2F; cost - no)*a[ns].price;</span><br><span class="line">				printf(&quot;%.2lf\n&quot;, nc);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			if (!cheaper &amp;&amp; havenx) &#123;</span><br><span class="line">			</span><br><span class="line">				&#x2F;&#x2F;范围内有站，但是没有更便宜的</span><br><span class="line">				nc +&#x3D; (c - no)*a[ns].price;</span><br><span class="line">				double d &#x3D; a[index].dis - a[ns].dis;</span><br><span class="line">				no &#x3D; c - d &#x2F; cost;</span><br><span class="line">				ns &#x3D; index;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (!havenx) &#123;</span><br><span class="line">			</span><br><span class="line">				&#x2F;&#x2F;没有站也到不了终点</span><br><span class="line">				printf(&quot;The maximum travel distance &#x3D; %.2lf\n&quot;,</span><br><span class="line">					a[ns].dis + maxd);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-搜索" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E6%90%9C%E7%B4%A2/"
    >搜索</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E6%90%9C%E7%B4%A2/" class="article-date">
  <time datetime="2020-03-30T03:55:19.536Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="枚举"><a class="markdownIt-Anchor" href="#枚举"></a> 枚举</h1>
<ol>
<li>枚举要关注查找空间，查找目标，查找方式，估计时间复杂度</li>
<li>有时需要注意精度问题</li>
</ol>
<h2 id="scu-2416"><a class="markdownIt-Anchor" href="#scu-2416"></a> SCU 2416</h2>
<p>有一个总价为_XYZ_，<em>表示看不清的位。现给出火鸡的总数和一个_XYZ</em>，求最大的火鸡单价是多少，输出这两位和最大的单价。火鸡单价为正整数</p>
<p>枚举两位，判断单价是否为整数即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	int a, b, c;</span><br><span class="line">	int n;</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);</span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		int ansi &#x3D; 0, ansj &#x3D; 0;</span><br><span class="line">		int beg &#x3D; a * 1000 + b * 100 + c * 10;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">			int t &#x3D; i * 10000 + beg;</span><br><span class="line">			for (int j &#x3D; 0; j &lt;&#x3D; 9; j++) &#123;</span><br><span class="line">				int now &#x3D; t + j;</span><br><span class="line">				int xx &#x3D; now &#x2F; n;</span><br><span class="line">				if (xx*n &#x3D;&#x3D; now)</span><br><span class="line">				&#123;</span><br><span class="line">					ansi &#x3D; i;</span><br><span class="line">					ansj &#x3D; j;</span><br><span class="line">					ans &#x3D; xx; </span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (ans)</span><br><span class="line">			printf(&quot;%d %d %d\n&quot;, ansi, ansj, ans);</span><br><span class="line">		else printf(&quot;0\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="广度优先搜索-bfs"><a class="markdownIt-Anchor" href="#广度优先搜索-bfs"></a> 广度优先搜索 BFS</h1>
<h2 id="hdu-1253-胜利大逃亡"><a class="markdownIt-Anchor" href="#hdu-1253-胜利大逃亡"></a> HDU 1253 胜利大逃亡</h2>
<p>大意是问能否在T时间内从(0,0,0)走到(A-1,B-1,C-1),且正好等于T时到达出口也可</p>
<h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3>
<p>三维隐式图最短路问题，使用bfs求解即可</p>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 50 + 5;</span><br><span class="line">int dx[] &#x3D; &#123; 1,-1,0,0, 0,0 &#125;;</span><br><span class="line">int dy[] &#x3D; &#123; 0,0,1,-1,0,0 &#125;;</span><br><span class="line">int dz[] &#x3D; &#123; 0,0,0,0,1,-1 &#125;;</span><br><span class="line">int A, B, C, T;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int x, y, z;</span><br><span class="line">	int t;</span><br><span class="line">	node(int x, int y, int z, int t) :x(x), y(y), z(z), t(t) &#123;&#125;</span><br><span class="line">	bool operator &#x3D;&#x3D; (const node&amp;a) const</span><br><span class="line">	&#123;</span><br><span class="line">		return x &#x3D;&#x3D; a.x&amp;&amp;y &#x3D;&#x3D; a.y&amp;&amp;z &#x3D;&#x3D; a.z;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int g[maxn][maxn][maxn];</span><br><span class="line">bool vis[maxn][maxn][maxn];</span><br><span class="line">inline bool ok(int x, int y, int z) &#123;</span><br><span class="line">	return x &gt;&#x3D; 0 &amp;&amp; x &lt; A</span><br><span class="line">		&amp;&amp;y &gt;&#x3D; 0 &amp;&amp; y &lt; B</span><br><span class="line">		&amp;&amp;z &gt;&#x3D; 0 &amp;&amp; z &lt; C;</span><br><span class="line">&#125;</span><br><span class="line">bool bfs() &#123;</span><br><span class="line">	node beg(0, 0, 0, 0);</span><br><span class="line">	node goal(A - 1, B - 1, C - 1, 0);</span><br><span class="line">	queue&lt;node&gt; q;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	q.push(beg);</span><br><span class="line">	vis[0][0][0] &#x3D; 1;</span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		node u &#x3D; q.front(); q.pop();</span><br><span class="line">		if (u &#x3D;&#x3D; goal) &#123;</span><br><span class="line">			printf(&quot;%d\n&quot;, u.t);</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		if (u.t &gt; T) &#123;</span><br><span class="line">			printf(&quot;-1\n&quot;);</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 6; i++) &#123;</span><br><span class="line">			int newx &#x3D; u.x + dx[i];</span><br><span class="line">			int newy &#x3D; u.y + dy[i];</span><br><span class="line">			int newz &#x3D; u.z + dz[i];</span><br><span class="line">			if (ok(newx, newy, newz))</span><br><span class="line">				if (!vis[newx][newy][newz] &amp;&amp; !g[newx][newy][newz]) &#123;</span><br><span class="line">					q.push(node(newx, newy, newz, u.t + 1));</span><br><span class="line">					vis[newx][newy][newz] &#x3D; 1;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;-1\n&quot;);</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int kase;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;kase);</span><br><span class="line">	while (kase--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d%d%d%d&quot;, &amp;A, &amp;B, &amp;C, &amp;T);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; A; i++)</span><br><span class="line">			for (int j &#x3D; 0; j &lt; B; j++)</span><br><span class="line">				for (int k &#x3D; 0; k &lt; C; k++)</span><br><span class="line">					scanf(&quot;%d&quot;, &amp;g[i][j][k]);</span><br><span class="line">		bfs();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非常可乐"><a class="markdownIt-Anchor" href="#非常可乐"></a> 非常可乐</h2>
<p>大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升　(正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出&quot;NO&quot;。</p>
<p>三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以&quot;0 0 0&quot;结束。</p>
<p>如果能平分的话请输出最少要倒的次数，否则输出&quot;NO&quot;。</p>
<h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3>
<ol>
<li>隐式图最短路，详细可看UVA习题中<strong>倒水问题</strong></li>
<li>值得注意的是
<ol>
<li>由于是倒水次数最小，所以不需要使用优先级队列</li>
<li>由于总水量一定，所以vis开二维足够</li>
<li>如果初始水量为奇数，一定不成功。</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int c[3];</span><br><span class="line">	int t;</span><br><span class="line">&#125;;</span><br><span class="line">bool vis[maxn][maxn];</span><br><span class="line">int cap[3];</span><br><span class="line">void bfs() &#123;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	int s &#x3D; cap[0];</span><br><span class="line">	node beg;</span><br><span class="line">	beg.c[0] &#x3D; s;	beg.c[1] &#x3D; 0;	beg.c[2] &#x3D; 0;</span><br><span class="line">	beg.t &#x3D; 0;</span><br><span class="line">	vis[s][0] &#x3D; 1;</span><br><span class="line">	queue&lt;node&gt; q;</span><br><span class="line">	q.push(beg);</span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		node u &#x3D; q.front(); q.pop();</span><br><span class="line">		if ((2 * u.c[0] &#x3D;&#x3D; s &amp;&amp; 2 * u.c[1] &#x3D;&#x3D; s)</span><br><span class="line">			|| (2 * u.c[0] &#x3D;&#x3D; s &amp;&amp; 2 * u.c[2] &#x3D;&#x3D; s)</span><br><span class="line">			|| (2 * u.c[1] &#x3D;&#x3D; s &amp;&amp; 2 * u.c[2] &#x3D;&#x3D; s)) &#123;</span><br><span class="line">			printf(&quot;%d\n&quot;, u.t);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 3; i++) &#123;&#x2F;&#x2F;i向j倒水</span><br><span class="line">			if (u.c[i] &#x3D;&#x3D; 0) continue;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 3; j++) &#123;</span><br><span class="line">				if (i !&#x3D; j) &#123;</span><br><span class="line">					node v &#x3D; u;</span><br><span class="line">					int delta &#x3D; min(cap[j], v.c[i] + v.c[j]) - v.c[j];</span><br><span class="line">					v.c[i] -&#x3D; delta;</span><br><span class="line">					v.c[j] +&#x3D; delta;</span><br><span class="line">					v.t +&#x3D; 1;</span><br><span class="line">					if (!vis[v.c[0]][v.c[1]]) &#123;</span><br><span class="line">						vis[v.c[0]][v.c[1]] &#x3D; 1;</span><br><span class="line">						q.push(v);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;NO\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d%d%d&quot;, &amp;cap[0], &amp;cap[1], &amp;cap[2]) &#x3D;&#x3D; 3)</span><br><span class="line">	&#123;</span><br><span class="line">		if (cap[0] &#x3D;&#x3D; 0 &amp;&amp; cap[1] &#x3D;&#x3D; 0 &amp;&amp; cap[2] &#x3D;&#x3D; 0) break;</span><br><span class="line">		if (cap[0] % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">			printf(&quot;NO\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		bfs();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h1>
<h2 id="汉诺塔问题"><a class="markdownIt-Anchor" href="#汉诺塔问题"></a> 汉诺塔问题</h2>
<h3 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h3>
<ol>
<li>每次都需要借助第2个柱子将前K-1小的转移到3上.具体来说是先将k-1个盘子移动到3上，再将最大的移到2上，再将k-1个移动到1上，再将最大的移动到3上，再将k-1个移动到3上。</li>
<li>设总的移动次数为F(k)=3*F(k-1)+2</li>
</ol>
<h1 id="递归的应用"><a class="markdownIt-Anchor" href="#递归的应用"></a> 递归的应用</h1>
<h2 id="素数环"><a class="markdownIt-Anchor" href="#素数环"></a> 素数环</h2>
<p><a href="https://cccceb.github.io/2020/01/24/%E7%B4%A0%E6%95%B0%E7%8E%AF/" target="_blank" rel="noopener">详情见UVA习题素数环</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 16 + 5;</span><br><span class="line">int A[maxn];</span><br><span class="line">bool isp[10000000];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int n;</span><br><span class="line">bool is_prime(int a) &#123;</span><br><span class="line">	for (int i &#x3D; 2; i &lt; a; i++)</span><br><span class="line">		if (a%i &#x3D;&#x3D; 0) return 0;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int cur) &#123;</span><br><span class="line">	if (cur &#x3D;&#x3D; n &amp;&amp; isp[A[0] + A[cur - 1]]) &#123;</span><br><span class="line">		cout &lt;&lt; A[0];</span><br><span class="line">		for (int i &#x3D; 1; i &lt; n; i++) cout &lt;&lt; &quot; &quot; &lt;&lt; A[i];</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		for (int j &#x3D; 2; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">			if (!vis[j] &amp;&amp; isp[A[cur - 1] + j]) &#123;</span><br><span class="line">				A[cur] &#x3D; j;</span><br><span class="line">				vis[j] &#x3D; 1;</span><br><span class="line">				dfs(cur + 1);</span><br><span class="line"></span><br><span class="line">				A[cur] &#x3D; 0;</span><br><span class="line">				vis[j] &#x3D; 0;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int kase &#x3D; 0;</span><br><span class="line">	while (cin &gt;&gt; n) &#123;</span><br><span class="line">		if (kase) cout &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++kase &lt;&lt; &quot;:&quot; &lt;&lt; endl;</span><br><span class="line">		memset(vis, 0,  sizeof(vis));</span><br><span class="line">		memset(isp, 0,  sizeof(isp));</span><br><span class="line">		for (int i &#x3D; 2; i &lt;&#x3D; 2 * n; i++)</span><br><span class="line">			isp[i] &#x3D; is_prime(i);</span><br><span class="line">		A[0] &#x3D; 1;</span><br><span class="line">		isp[1] &#x3D; 1;</span><br><span class="line">		dfs(1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="油田"><a class="markdownIt-Anchor" href="#油田"></a> 油田</h2>
<p>给出一个图，判断其中有多少个@的连通块。正方向和对角线都算相连</p>
<h3 id="思路-4"><a class="markdownIt-Anchor" href="#思路-4"></a> 思路</h3>
<ol>
<li>直接深搜即可</li>
<li>走的方向i,j不同时为0，简化代码为i||j</li>
</ol>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">char g[maxn][maxn];</span><br><span class="line">int r, c;</span><br><span class="line">int vis[maxn][maxn];</span><br><span class="line">int num;</span><br><span class="line">void dfs(int x, int y) &#123;</span><br><span class="line">	if (g[x][y] !&#x3D; &#39;@&#39; || vis[x][y]) return;</span><br><span class="line">	if (x &lt; 0 || x &gt;&#x3D; r || y &lt; 0 || y &gt;&#x3D; c) return;</span><br><span class="line">	vis[x][y] &#x3D; num;</span><br><span class="line">	for (int i &#x3D; -1; i &lt;&#x3D; 1; i++) &#123;</span><br><span class="line">		for (int j &#x3D; -1; j &lt;&#x3D; 1; j++) &#123;</span><br><span class="line">			if (i || j)</span><br><span class="line">				dfs(x + i, y + j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d%d\n&quot;, &amp;r, &amp;c) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		if (r &#x3D;&#x3D; 0 &amp;&amp; c &#x3D;&#x3D; 0) break;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; c; j++)</span><br><span class="line">				scanf(&quot;%c&quot;, &amp;g[i][j]);</span><br><span class="line">			getchar();</span><br><span class="line">		&#125;</span><br><span class="line">		num &#x3D; 1;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; c; j++)</span><br><span class="line">				if (g[i][j] &#x3D;&#x3D; &#39;@&#39;&amp;&amp;!vis[i][j])</span><br><span class="line">				&#123;</span><br><span class="line">					dfs(i, j);</span><br><span class="line">					num++;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, num-1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="openj_bailian-4070-全排列"><a class="markdownIt-Anchor" href="#openj_bailian-4070-全排列"></a> OpenJ_Bailian - 4070 全排列</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const int maxn &#x3D; 8;</span><br><span class="line">int p[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			p[i] &#x3D; i + 1;</span><br><span class="line">		sort(p, p + n);</span><br><span class="line">		do &#123;</span><br><span class="line">			printf(&quot;%d&quot;, p[0]);</span><br><span class="line">			for (int i &#x3D; 1; i &lt; n; i++)</span><br><span class="line">				printf(&quot; %d&quot;, p[i]);</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125; while (next_permutation(p, p + n));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="深度优先搜索-dfs"><a class="markdownIt-Anchor" href="#深度优先搜索-dfs"></a> 深度优先搜索 DFS</h1>
<h2 id="temple-of-the-bone"><a class="markdownIt-Anchor" href="#temple-of-the-bone"></a> temple of the bone</h2>
<p>S是起点，D是终点，X是墙，.是地面，问能否在T时间内到达D。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 8;</span><br><span class="line">char g[maxn][maxn];</span><br><span class="line">bool vis[maxn][maxn];</span><br><span class="line">int maxr, maxc,T;</span><br><span class="line">int dx[] &#x3D; &#123; 1,-1,0,0 &#125;;</span><br><span class="line">int dy[] &#x3D; &#123; 0,0,1,-1 &#125;;</span><br><span class="line">bool dfs(int x,int y,int t) &#123;</span><br><span class="line">	if (x &lt; 0 || x &gt;&#x3D; maxr || y &lt; 0 || y &gt;&#x3D; maxc) return false;</span><br><span class="line">	if (g[x][y] &#x3D;&#x3D; &#39;D&#39;) &#123;</span><br><span class="line">		printf(&quot;YES\n&quot;);</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	if (t &gt; T) return false;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">		int newx &#x3D; x + dx[i];</span><br><span class="line">		int newy &#x3D; y + dy[i];</span><br><span class="line">		if (vis[newx][newy]||g[newx][newy]&#x3D;&#x3D;&#39;X&#39;) continue;</span><br><span class="line">		vis[newx][newy] &#x3D; 1;</span><br><span class="line">		if (dfs(newx, newy, t + 1)) return true;</span><br><span class="line">		vis[newx][newy] &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int begx, begy;</span><br><span class="line"></span><br><span class="line">	while(scanf(&quot;%d%d%d\n&quot;,&amp;maxr,&amp;maxc,&amp;T)&#x3D;&#x3D;3)&#123;</span><br><span class="line">		if (maxr &#x3D;&#x3D; 0 &amp;&amp; maxc &#x3D;&#x3D; 0 &amp;&amp; T&#x3D;&#x3D;0) break;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		for(int i &#x3D; 0; i &lt; maxr; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; maxc; j++) &#123;</span><br><span class="line">				scanf(&quot;%c&quot;, &amp;g[i][j]);</span><br><span class="line">				if (g[i][j] &#x3D;&#x3D; &#39;S&#39;) &#123;</span><br><span class="line">					begx &#x3D; i;</span><br><span class="line">					begy &#x3D; j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			getchar();</span><br><span class="line">		&#125;</span><br><span class="line">		if (!dfs(begx, begy, 0))</span><br><span class="line">			printf(&quot;NO\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hdu-1421-搬寝室"><a class="markdownIt-Anchor" href="#hdu-1421-搬寝室"></a> HDU 1421 搬寝室</h2>
<p>搬寝室是很累的,xhd深有体会.时间追述2006年7月9号,那天xhd迫于无奈要从27号楼搬到3号楼,因为10号要封楼了.看着寝室里的n件物品,xhd开始发呆,因为n是一个小于2000的整数,实在是太多了,于是xhd决定随便搬2<em>k件过去就行了.但还是会很累,因为2</em>k也不小是一个不大于n的整数.幸运的是xhd根据多年的搬东西的经验发现每搬一次的疲劳度是和左右手的物品的重量差的平方成正比(这里补充一句,xhd每次搬两件东西,左手一件右手一件).例如xhd左手拿重量为3的物品,右手拿重量为6的物品,则他搬完这次的疲劳度为(6-3)^2 = 9.现在可怜的xhd希望知道搬完这2*k件物品后的最佳状态是怎样的(也就是最低的疲劳度),请告诉他吧.</p>
<p>每组输入数据有两行,第一行有两个数n,k(2&lt;=2*k&lt;=n&lt;2000).第二行有n个整数分别表示n件物品的重量(重量是一个小于2^15的正整数).</p>
<p>对应每组输入数据,输出数据只有一个表示他的最少的疲劳度,每个一行.</p>
<h3 id="思路-5"><a class="markdownIt-Anchor" href="#思路-5"></a> 思路</h3>
<ol>
<li>
<p>设dp[i][j]表示前i件物品组成j对所消耗的体力最小；所以分成了两种情况</p>
<ol>
<li>第j对里含有第i件物品，则dp [i][j] = dp [i-2][j-1] + (a[i]-a[i-1])*(a[i]-a[i-1]);</li>
<li>不含第i件物品则有：dp [i][j] = dp [i-1][j];</li>
</ol>
</li>
<li>
<p>总上，动态转移方程为:dp[i][j]=min(dp[i-2][j-1]+(a[i]-a[i-1])*(a[i]-a[i-1]), dp[i][j]=dp[i-1][j]);</p>
</li>
</ol>
<h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">int dp[2010][2010], a[2010];</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, k;</span><br><span class="line">	while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;k))</span><br><span class="line">	&#123;</span><br><span class="line">		int i, j;</span><br><span class="line">		memset(a, 0, sizeof(a));</span><br><span class="line">		memset(dp, 0, sizeof(dp));</span><br><span class="line">		for (i &#x3D; 0; i &lt;&#x3D; n; i++)</span><br><span class="line">			for (j &#x3D; 1; j &lt;&#x3D; k; j++)</span><br><span class="line">				dp[i][j] &#x3D; inf;</span><br><span class="line">		for (i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">		sort(a, a + n + 1);</span><br><span class="line">		for (i &#x3D; 2; i &lt;&#x3D; n; i++)</span><br><span class="line">			for (j &#x3D; 1; j * 2 &lt;&#x3D; i; j++)</span><br><span class="line">				dp[i][j] &#x3D; min(dp[i - 1][j], dp[i - 2][j - 1] + (a[i] - a[i - 1])*(a[i] - a[i - 1]));</span><br><span class="line">		printf(&quot;%d\n&quot;, dp[n][k]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hdu-3578-greedy-tino"><a class="markdownIt-Anchor" href="#hdu-3578-greedy-tino"></a> HDU 3578 Greedy Tino</h2>
<p>未完待续</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define OFFSET 2000&#x2F;&#x2F;因为j有正负，所以添加一个偏移量，方便做题</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line">int wi[101];</span><br><span class="line">int dp[101][4001];</span><br><span class="line">int max(int a, int b, int c)&#123;</span><br><span class="line">    int flag &#x3D; a;</span><br><span class="line">    if(flag &lt; b)&#123;</span><br><span class="line">        flag &#x3D; b;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag &lt; c)&#123;</span><br><span class="line">        flag &#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i&#x3D;0;i&lt;40001;i++)</span><br><span class="line">            dp[0][i] &#x3D; -INF;</span><br><span class="line">    dp[0][OFFSET] &#x3D; 0;&#x2F;&#x2F;core</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t, n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; t; i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        wi[0] &#x3D; 0;</span><br><span class="line">         bool hasZero &#x3D; false;</span><br><span class="line">        int cnt &#x3D; 0;</span><br><span class="line">        for(int j &#x3D; 0; j &lt; n; j++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;wi[++cnt]);</span><br><span class="line">            if(wi[cnt] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                   hasZero &#x3D; true;</span><br><span class="line">                   cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n &#x3D; cnt;</span><br><span class="line">        init();</span><br><span class="line">        for(int j &#x3D; 1; j &lt;&#x3D; n; j++)&#123;</span><br><span class="line">            for(int k &#x3D; -2000; k &lt;&#x3D; 2000; k++)&#123;</span><br><span class="line">                dp[j][k+OFFSET] &#x3D; max(dp[j-1][k-wi[j]+OFFSET]+wi[j], dp[j-1][k+wi[j]+OFFSET]+wi[j], dp[j-1][k+OFFSET]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf (&quot;Case %d: &quot;, i+1);</span><br><span class="line">        if(dp[n][0+OFFSET] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            if(hasZero &#x3D;&#x3D; true)&#123;</span><br><span class="line">                printf(&quot;0\n&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                printf(&quot;-1\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            printf(&quot;%d\n&quot;, dp[n][0+OFFSET]&#x2F;2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="背包"><a class="markdownIt-Anchor" href="#背包"></a> 背包</h1>
<h2 id="0-1背包问题"><a class="markdownIt-Anchor" href="#0-1背包问题"></a> 0-1背包问题</h2>
<p>特点是每个物品只能选一件，即每个物品的数量只能出现0和1</p>
<h3 id="openj_bailian-2726"><a class="markdownIt-Anchor" href="#openj_bailian-2726"></a> OpenJ_Bailian 2726</h3>
<p>辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是辰辰，你能完成这个任务吗？</p>
<h3 id="思路-6"><a class="markdownIt-Anchor" href="#思路-6"></a> 思路</h3>
<ol>
<li>用dp[i][j]表示取前i个物品，重量不超过j时能达到的最大价值。</li>
<li>可以根据第i个物品是否取分成两类
<ol>
<li>取第i个物品，那么需要更新所有能再装下一个i的状态，即dp[i-1][j-p[i].w]</li>
<li>不取i，那么dp[i][j]=dp[i-1][j]</li>
</ol>
</li>
<li>综上，递推关系为dp[i][j] = max(dp[i-1][j], dp[i - 1][j - p[i].w] + p[i].v)</li>
<li><strong>注意</strong> 对于dp[i-1][j]下装不下第i个物品的状态，要赋值为dp[i-1][j]</li>
</ol>
<h3 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line">struct node &#123;</span><br><span class="line">	int w;</span><br><span class="line">	int v;</span><br><span class="line">&#125;;</span><br><span class="line">int s, m;</span><br><span class="line">node p[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;s, &amp;m) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;p[i].w, &amp;p[i].v);</span><br><span class="line"></span><br><span class="line">		memset(dp, 0, sizeof(0));</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">			for (int j &#x3D; s; j &gt;&#x3D; p[i].w; j--) &#123;</span><br><span class="line">				dp[i][j] &#x3D; max(dp[i-1][j], dp[i - 1][j - p[i].w] + p[i].v);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			for (int j &#x3D; p[i].w-1; j &gt;&#x3D; 0; j--)&#x2F;&#x2F;对于p[i].w-1~1的状态只能来自于dp[i-1][j]</span><br><span class="line">				dp[i][j] &#x3D; dp[i-1][j];</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, dp[m][s]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h3>
<ol>
<li>发现新的状态至于最近的一个状态有关，所以可以降维。</li>
<li>状态转移方程为：dp[j]=max{dp[j-p[i].w]+v,dp[i]}</li>
<li><strong>注意</strong> 更新dp时是逆序更新，这是因为在0-1背包问题中每个物品至多放入一次。逆序循环，保证了更新dp[j]时，dp[j-p[i].w]是没有放入i时的数据(dp[i-1][j-p[i].w])</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">	for (int j &#x3D; s; j &gt;&#x3D; p[i].w; j--) &#123;</span><br><span class="line">		dp[j]&#x3D;max(dp[j-p[i].w]+v,dp[i]);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完全背包问题"><a class="markdownIt-Anchor" href="#完全背包问题"></a> 完全背包问题</h2>
<p>每种物品的数量可以任意多</p>
<h3 id="hdu-1114-piggy-bank"><a class="markdownIt-Anchor" href="#hdu-1114-piggy-bank"></a> HDU 1114 Piggy-Bank</h3>
<p>有个存钱罐，已知空罐质量和满罐质量，以及n种硬币质量和价值，求罐中硬币的最小价值。</p>
<h3 id="思路-7"><a class="markdownIt-Anchor" href="#思路-7"></a> 思路</h3>
<ol>
<li>完全背包问题的区别在于，每个物品可以被选择很多次，因此dp[j]可以由已放入物品i后的数据dp[j-p[i].w]得来，所以顺序循环</li>
<li>本题求最小值，将max要换成min</li>
<li>由于要求恰好装满，所以初始时只有dp[0]=0，其他状态都不存在</li>
</ol>
<h3 id="代码-5"><a class="markdownIt-Anchor" href="#代码-5"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 10000+ 5;</span><br><span class="line">int dp[maxn];</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line">struct node &#123;</span><br><span class="line">	int w;</span><br><span class="line">	int v;</span><br><span class="line">&#125;;</span><br><span class="line">int s, m;</span><br><span class="line">node p[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;m, &amp;s);</span><br><span class="line">		s -&#x3D; m;</span><br><span class="line">		int n;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;p[i].v, &amp;p[i].w);</span><br><span class="line">		for (int i &#x3D; 0; i &lt;&#x3D; s; i++)</span><br><span class="line">			dp[i] &#x3D; INF;</span><br><span class="line">		dp[0] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; p[i].w; j &lt;&#x3D; s;j++) &#123;</span><br><span class="line">				if (dp[j - p[i].w] !&#x3D; INF)&#x2F;&#x2F;该状态存在，那么才可以产生新的状态</span><br><span class="line">					dp[j] &#x3D; min(dp[j], dp[j - p[i].w] + p[i].v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (dp[s] !&#x3D; INF)</span><br><span class="line">			printf(&quot;The minimum amount of money in the piggy-bank is %d.\n&quot;, dp[s]);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot;This is impossible.\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多重背包问题"><a class="markdownIt-Anchor" href="#多重背包问题"></a> 多重背包问题</h2>
<p>介于完全背包问题和0-1背包问题之间，每种物品数量有限。可以将k个物品看作k种物品，在进行0-1背包求解。但是这样会使时间复杂度过大。稍加改变，将该种物品分成很多堆，每堆数量为1~k-2<sup>c+1,其中c为使k-2</sup>c+1大于0的最大整数。</p>
<h3 id="hdu-2191-珍惜现在感恩生活"><a class="markdownIt-Anchor" href="#hdu-2191-珍惜现在感恩生活"></a> HDU 2191 珍惜现在，感恩生活</h3>
<p>输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1&lt;=n&lt;=100, 1&lt;=m&lt;=100),分别表示经费的金额和大米的种类，然后是m行数据，每行包含3个数p，h和c(1&lt;=p&lt;=20,1&lt;=h&lt;=200,1&lt;=c&lt;=20)，分别表示每袋的价格、每袋的重量以及对应种类大米的袋数。</p>
<p>对于每组测试数据，请输出能够购买大米的最多重量，你可以假设经费买不光所有的大米，并且经费你可以不用完。每个实例的输出占一行。</p>
<h3 id="思路-8"><a class="markdownIt-Anchor" href="#思路-8"></a> 思路</h3>
<ol>
<li>先将每个物品分成很多堆，类似二进制拆分</li>
<li>然后进行0-1背包求解</li>
</ol>
<h3 id="代码-6"><a class="markdownIt-Anchor" href="#代码-6"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 10000 + 5;</span><br><span class="line">int dp[maxn];</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line">struct node &#123;</span><br><span class="line">	int w;</span><br><span class="line">	int v;</span><br><span class="line">&#125;;</span><br><span class="line">int s, m;</span><br><span class="line">node a[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;s, &amp;m);</span><br><span class="line">		int p, h, c;</span><br><span class="line">		int cnt &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;p, &amp;h, &amp;c);</span><br><span class="line">			int t &#x3D; 1;</span><br><span class="line">			while (c &gt; t)</span><br><span class="line">			&#123;</span><br><span class="line">				c -&#x3D; t;</span><br><span class="line">				a[++cnt].w &#x3D; t * p;</span><br><span class="line">				a[cnt].v &#x3D; t * h;</span><br><span class="line">				t *&#x3D; 2;</span><br><span class="line">			&#125;</span><br><span class="line">			a[++cnt].w &#x3D; p * c;</span><br><span class="line">			a[cnt].v &#x3D; h * c;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		memset(dp, 0, sizeof(dp));</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; cnt; i++) &#123;</span><br><span class="line">			for (int j &#x3D; s; j &gt;&#x3D; a[i].w;j--) &#123;</span><br><span class="line">					dp[j] &#x3D; max(dp[j], dp[j - a[i].w] + a[i].v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;%d\n&quot;, dp[s]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-数学理论" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E6%95%B0%E5%AD%A6%E7%90%86%E8%AE%BA/"
    >数学理论</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E6%95%B0%E5%AD%A6%E7%90%86%E8%AE%BA/" class="article-date">
  <time datetime="2020-03-30T03:55:19.536Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="数位拆分"><a class="markdownIt-Anchor" href="#数位拆分"></a> 数位拆分</h1>
<p>主要注意溢出问题</p>
<h1 id="进制转换"><a class="markdownIt-Anchor" href="#进制转换"></a> 进制转换</h1>
<h2 id="数值转换"><a class="markdownIt-Anchor" href="#数值转换"></a> 数值转换</h2>
<p>将a进制的s转换成b进制输出.输入a,s,b</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000000;</span><br><span class="line">char s[maxn];</span><br><span class="line">char ans[maxn];</span><br><span class="line">const char alp[] &#x3D; &#123; &#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39; &#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">	long long a, b;</span><br><span class="line">	while (scanf(&quot;%lld%s%lld&quot;, &amp;a, s, &amp;b) &#x3D;&#x3D; 3) &#123;</span><br><span class="line">		int cf &#x3D; 1;</span><br><span class="line">		long long ten &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; strlen(s) - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			if (isdigit(s[i])) &#123;</span><br><span class="line">				ten +&#x3D; (s[i] - &#39;0&#39;)*cf;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (s[i] &gt;&#x3D; &#39;a&#39;&amp;&amp;s[i] &lt;&#x3D; &#39;z&#39;) &#123;</span><br><span class="line">				ten +&#x3D; (s[i] - &#39;a&#39;+10)*cf;</span><br><span class="line">			&#125;</span><br><span class="line">			else ten +&#x3D; (s[i] - &#39;A&#39;+10)*cf;</span><br><span class="line">			cf *&#x3D; a;</span><br><span class="line">		&#125;</span><br><span class="line">		int id &#x3D; 0;</span><br><span class="line">		while (ten)</span><br><span class="line">		&#123;</span><br><span class="line">			ans[id++] &#x3D; alp[ten % b];</span><br><span class="line">			ten &#x2F;&#x3D; b;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; id - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			printf(&quot;%c&quot;, ans[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进制转换-2"><a class="markdownIt-Anchor" href="#进制转换-2"></a> 进制转换</h2>
<p>将不超过30位的非负整数转成二进制</p>
<h3 id="c"><a class="markdownIt-Anchor" href="#c"></a> C++</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 30 + 5;</span><br><span class="line">char s[maxn];</span><br><span class="line">int ans[20000];</span><br><span class="line">int num[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%s&quot;, s) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; strlen(s); i++)</span><br><span class="line">			num[i] &#x3D; s[i] - &#39;0&#39;;</span><br><span class="line">		int id &#x3D; 0;</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; strlen(s);) &#123;</span><br><span class="line">			int tmp &#x3D; 0, remain &#x3D; 0;</span><br><span class="line">			for (int j &#x3D; i; j &lt; strlen(s); j++) &#123;</span><br><span class="line">				tmp &#x3D; (10 * remain + num[j]) % 2;</span><br><span class="line">				num[j] &#x3D; (10 * remain + num[j]) &#x2F; 2;</span><br><span class="line">				remain &#x3D; tmp;</span><br><span class="line">			&#125;</span><br><span class="line">			ans[id++] &#x3D; remain;</span><br><span class="line">			while (num[i] &#x3D;&#x3D; 0&amp;&amp;i&lt;strlen(s))</span><br><span class="line">				i++;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; id - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			printf(&quot;%d&quot;, ans[i]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="java"><a class="markdownIt-Anchor" href="#java"></a> ※ Java ※</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import  java.util.*;</span><br><span class="line">import java.math.BigInteger;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in&#x3D;new Scanner(System.in);</span><br><span class="line">        while (in.hasNext())&#123;</span><br><span class="line">            String str&#x3D;in.nextLine();</span><br><span class="line">            BigInteger a&#x3D;new BigInteger(str,10);</span><br><span class="line">            System.out.println(a.toString(2));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="补充求整型ab并保留任意位小数"><a class="markdownIt-Anchor" href="#补充求整型ab并保留任意位小数"></a> 补充：求整型a/b并保留任意位小数</h3>
<p>其中res存小数部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int c &#x3D; a % b, cnt &#x3D; 0;</span><br><span class="line">c *&#x3D; 10;</span><br><span class="line">while (cnt &lt; n) &#123;</span><br><span class="line">	res[cnt] &#x3D; c &#x2F; b;</span><br><span class="line">	vis[c] &#x3D; cnt++;</span><br><span class="line">	c %&#x3D; b;</span><br><span class="line">	c *&#x3D; 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最大公约数"><a class="markdownIt-Anchor" href="#最大公约数"></a> 最大公约数</h1>
<h2 id="辗转相除法"><a class="markdownIt-Anchor" href="#辗转相除法"></a> 辗转相除法</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int gcd(int a, int b) &#123;</span><br><span class="line">	if (!b) return a;</span><br><span class="line">	else return gcd(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最小公倍数"><a class="markdownIt-Anchor" href="#最小公倍数"></a> 最小公倍数</h1>
<p>a,b两数的最小公倍数为两数的乘积除以它们的最大公约数</p>
<h2 id="least-common-multiple-eolymp-1243"><a class="markdownIt-Anchor" href="#least-common-multiple-eolymp-1243"></a> Least Common Multiple EOlymp-1243</h2>
<p>求一系列数的最小公倍数，输入的第一行为测试组数，接下来每行的第一个数为该组数字的个数，数字限定在32bit整型范围内。输出这些数字的最小公倍数。</p>
<p>注意： n等于1直接输出；<strong>尽管a,b都是32bit，但是lcm时，a*b可能大于32b,可以使用long long或者先除法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long </span><br><span class="line">ll gcd(ll a, ll b) &#123;</span><br><span class="line">	if (b &#x3D;&#x3D; 0) return a;</span><br><span class="line">	else return gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	ll a, b, x, n;</span><br><span class="line">	getchar();</span><br><span class="line"></span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		if (n &gt; 1) &#123;</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">			ll  g &#x3D; gcd(a, b);</span><br><span class="line">			ll l &#x3D; a * b &#x2F; g;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; n - 2; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				cin &gt;&gt; x;</span><br><span class="line">				if (l%x &#x3D;&#x3D; 0) continue;</span><br><span class="line">				g &#x3D; gcd(l, x);</span><br><span class="line">				l &#x3D; l * x &#x2F; g;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			cout &lt;&lt; x &lt;&lt; endl;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="素数筛法"><a class="markdownIt-Anchor" href="#素数筛法"></a> 素数筛法</h1>
<h2 id="素数判定"><a class="markdownIt-Anchor" href="#素数判定"></a> 素数判定</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool judge(int a) &#123;</span><br><span class="line">	if (a&lt;&#x3D; 1) return false;</span><br><span class="line">	for (int i &#x3D; 2; i &lt; (int)sqrt(a) + 1; i++) &#123;</span><br><span class="line">		if (a%i &#x3D;&#x3D; 0) return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="素数筛法-2"><a class="markdownIt-Anchor" href="#素数筛法-2"></a> 素数筛法</h2>
<p>要输出不超过n的所有素数，方法是当我们得到一个素数时，即将它的所有倍数均标记为非素数，这样当我们遍历到每一个数时，它没有被任何其他的素数标记为非素数，则我们确定其为素数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">memset(notp, 0, sizeof(notp));</span><br><span class="line">		for (int i &#x3D;2; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">;			if (!notp[i]) &#123;</span><br><span class="line">				for (int j &#x3D; 2; i*j &lt; n; j++)</span><br><span class="line">					notp[i*j] &#x3D; 1;</span><br><span class="line">				if (i % 10 &#x3D;&#x3D; 1) printf(&quot;%d &quot;, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="goldbachs-conjecture"><a class="markdownIt-Anchor" href="#goldbachs-conjecture"></a> Goldbach’s Conjecture</h2>
<p>别忘了打表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; (1 &lt;&lt; 15) + 5;</span><br><span class="line">bool notp[maxn];</span><br><span class="line">int sum[maxn];</span><br><span class="line">int prime[maxn];</span><br><span class="line">int get_ans() &#123;</span><br><span class="line">	memset(sum, 0, sizeof(sum));</span><br><span class="line">	int id &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 2; i &lt; maxn; i++) &#123;</span><br><span class="line">		if (!notp[i]) &#123;</span><br><span class="line">			for (int j &#x3D; 2; i*j &lt; maxn; j++)</span><br><span class="line">				notp[i*j] &#x3D; 1;</span><br><span class="line">			prime[id++] &#x3D; i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int ix &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; id; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; id; j++) &#123;</span><br><span class="line">			int h &#x3D; prime[i] + prime[j];</span><br><span class="line">			if (h &lt; maxn) &#123;</span><br><span class="line">				sum[h]++;</span><br><span class="line">				if (i &#x3D;&#x3D; j) sum[h]++;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return ix;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	int r &#x3D; get_ans();</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;n)&#x3D;&#x3D;1&amp;&amp;n)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d\n&quot;, sum[n]&#x2F;2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分解质因数"><a class="markdownIt-Anchor" href="#分解质因数"></a> 分解质因数</h1>
<p>1不是N的质因数；若N为质数，N是N的质因数</p>
<h2 id="质因数的个数"><a class="markdownIt-Anchor" href="#质因数的个数"></a> 质因数的个数</h2>
<p>求正整数N(N&gt;1)的质因数的个数。 相同的质因数需要重复计算。如120=2*2*2*3*5，共有5个质因数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100000;</span><br><span class="line">bool notp[maxn];</span><br><span class="line">int prime[maxn];</span><br><span class="line">int res[maxn];</span><br><span class="line">int get_ans() &#123;</span><br><span class="line">	int id &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 2; i &lt; maxn; i++) &#123;</span><br><span class="line">		if (!notp[i]) &#123;</span><br><span class="line">			for (int j &#x3D; 2; i*j &lt; maxn; j++)</span><br><span class="line">				notp[i*j] &#x3D; 1;</span><br><span class="line">			prime[id++] &#x3D; i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return id;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	int r &#x3D; get_ans();</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		int id &#x3D; 0;</span><br><span class="line">		memset(res, 0, sizeof(res));</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">			if (n%prime[i] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				while (n%prime[i] &#x3D;&#x3D; 0)</span><br><span class="line">				&#123;</span><br><span class="line">					res[id]++;</span><br><span class="line">					n &#x2F;&#x3D; prime[i];</span><br><span class="line">				&#125;</span><br><span class="line">				id++;</span><br><span class="line">			&#125;</span><br><span class="line">			if (n &#x3D;&#x3D; 1) break;</span><br><span class="line">		&#125;</span><br><span class="line">		if (n !&#x3D; 1) res[id++] &#x3D; 1;&#x2F;&#x2F;若测试完2~maxn内的所有素数，n仍未被分解成1</span><br><span class="line">							&#x2F;&#x2F;则剩余的余数是一定大于maxn素因数，幂次只能为1</span><br><span class="line"></span><br><span class="line">		int sum &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; id; i++)</span><br><span class="line">			sum +&#x3D; res[i];</span><br><span class="line">		printf(&quot;%d\n&quot;, sum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>maxn取1e5而不是题干中的1e9是因为，对于每个N至多有一个大于sqrt(n)的素因数，这样只需要将小于sqrt(n)的数都除去，剩下的就是该大素因数了。</li>
</ol>
<h2 id="整除问题"><a class="markdownIt-Anchor" href="#整除问题"></a> 整除问题</h2>
<p>给定n，a求最大的k，使n！可以被a<sup>k整除但不能被a</sup>(k+1)整除。<br />
输入两个整数n(2&lt;=n&lt;=1000)，a(2&lt;=a&lt;=1000)<br />
输出一个整数</p>
<h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3>
<ol>
<li>由于n!和a^k都可能很大，所以不能直接相除来判断</li>
<li>考虑整除的特征：将n!和a分别分解成素因数的乘积。如果a能整除b，则b/a是整数，则说明a和b中的素因数种类应该相同(两个素数互质)，并且b中素因数pi的幂次应该大于等于a中pi的幂次。之后，确定b中该素因数的幂次是a中对应素因数幂次的几倍，这样最小的那个数即为所求的k。</li>
<li>由于n!很大，所以不能对n!进行素因数分解。现在的目标是想确定n!中含有的素因数p对应的幂指数。n!中每一个素因数p的倍数都至少贡献一个p因子，且1到n中p的倍数共有n/p个，则p因子数至少为n/p个。同理有n/(p*p)个整数至少贡献了两个p因子。</li>
<li>统计所有n!因子中幂次最小的即为所求的k</li>
</ol>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">bool notp[maxn];</span><br><span class="line">int prime[maxn];</span><br><span class="line">int res[maxn];</span><br><span class="line">int cnta[maxn];</span><br><span class="line">int get_ans() &#123;&#x2F;&#x2F;求范围内所有的素数</span><br><span class="line">	int id &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 2; i &lt; maxn; i++) &#123;</span><br><span class="line">		if (!notp[i]) &#123;</span><br><span class="line">			for (int j &#x3D; 2; i*j &lt; maxn; j++)</span><br><span class="line">				notp[i*j] &#x3D; 1;</span><br><span class="line">			prime[id++] &#x3D; i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return id;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int a, b;</span><br><span class="line">	int r &#x3D; get_ans();</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;b, &amp;a) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(res, 0, sizeof(res));</span><br><span class="line">		memset(cnta, 0, sizeof(cnta));</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;分解n!</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">			int n &#x3D; b;</span><br><span class="line">			while (n)</span><br><span class="line">			&#123;</span><br><span class="line">				res[i]+&#x3D;n&#x2F;prime[i];</span><br><span class="line">				n &#x2F;&#x3D; prime[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int ans &#x3D; 1e8;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;分解a</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">			if (a%prime[i] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				while (a%prime[i] &#x3D;&#x3D; 0)</span><br><span class="line">				&#123;</span><br><span class="line">					cnta[i]++;</span><br><span class="line">					a &#x2F;&#x3D; prime[i];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if (cnta[i] &#x3D;&#x3D; 0) continue;</span><br><span class="line">			ans &#x3D; min(ans, res[i] &#x2F; cnta[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="约数的个数"><a class="markdownIt-Anchor" href="#约数的个数"></a> 约数的个数</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int get_ans(int n) &#123;</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	int i;</span><br><span class="line">	for (i &#x3D; 1; i*i &lt; n; i++)</span><br><span class="line">		if (n%i &#x3D;&#x3D; 0) ans +&#x3D; 2;</span><br><span class="line">	if (i*i &#x3D;&#x3D; n) ans++;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T,n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		printf(&quot;%d\n&quot;, get_ans(n));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二分求幂"><a class="markdownIt-Anchor" href="#二分求幂"></a> 二分求幂</h1>
<h2 id="人见人爱ab"><a class="markdownIt-Anchor" href="#人见人爱ab"></a> 人见人爱A^B</h2>
<p>求A<sup>B的最后三位数表示的整数。说明：A</sup>B的含义是“A的B次方”</p>
<p>输入数据包含多个测试实例，每个实例占一行，由两个正整数A和B组成（1&lt;=A,B&lt;=10000），如果A=0, B=0，则表示输入数据的结束，不做处理。</p>
<p>对于每个测试实例，请输出A^B的最后三位表示的整数，每个输出占一行。</p>
<h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3>
<ol>
<li>由于a,b比较大，所以不能直接求。注意到A^B的后三位只与A的后三位有关，只存后三位即可。</li>
<li>由于A<sup>j可以由A</sup>i次得到，可以借此减少计算次数。可到的幂次包括1,2,4,8…即a<sup>k次是可以由a的1次不断求平方得到的。我们的目标是即分解a的b次变为若干个a的2</sup>k次的积，并尽可能减少分解结果的个数。指数层面就是若2^k次的和，即二进制。可以将幂次转成二进制数，取那些为1的位</li>
</ol>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int a, b;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;a, &amp;b) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		if (a &#x3D;&#x3D; 0 &amp;&amp; b &#x3D;&#x3D; 0) break;</span><br><span class="line">		int ans &#x3D; 1;</span><br><span class="line">		while (b)</span><br><span class="line">		&#123;</span><br><span class="line">			if (b % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">				ans *&#x3D; a;</span><br><span class="line">				ans %&#x3D; 1000;</span><br><span class="line">			&#125;</span><br><span class="line">			b &#x2F;&#x3D; 2;</span><br><span class="line">			a *&#x3D; a;	&#x2F;&#x2F;更新权重</span><br><span class="line">			a %&#x3D; 1000;	&#x2F;&#x2F;保留后三位</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hdu-2817"><a class="markdownIt-Anchor" href="#hdu-2817"></a> HDU 2817</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1 &lt;&lt; 16;</span><br><span class="line">int a[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	long long a, b, c, k;</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%lld%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c, &amp;k);</span><br><span class="line">		if (b - a &#x3D;&#x3D; c - b) &#123;</span><br><span class="line">			long long tmp &#x3D; (b - a) % 200907;</span><br><span class="line">			a %&#x3D; 200907;</span><br><span class="line">			printf(&quot;%lld\n&quot;, (a + (k - 1)*tmp) % 200907);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;	</span><br><span class="line">			long long ans &#x3D; 1;</span><br><span class="line">			long long t &#x3D; a;</span><br><span class="line">			a &#x3D; b &#x2F; a;</span><br><span class="line">			k--;</span><br><span class="line">			while (k)</span><br><span class="line">			&#123;</span><br><span class="line">				if (k % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">					ans *&#x3D; a;</span><br><span class="line">					ans %&#x3D; 200907;</span><br><span class="line">				&#125;</span><br><span class="line">				k &#x2F;&#x3D; 2;</span><br><span class="line">				a *&#x3D; a;</span><br><span class="line">				a %&#x3D; 200907;</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;%lld\n&quot;,((t% 200907)* ans)% 200907);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="高精度整数"><a class="markdownIt-Anchor" href="#高精度整数"></a> 高精度整数</h1>
<h2 id="大整数类"><a class="markdownIt-Anchor" href="#大整数类"></a> 大整数类</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class BigInteger &#123;</span><br><span class="line">private:</span><br><span class="line">	const static int maxn &#x3D; 1000;</span><br><span class="line">	int digit[maxn];</span><br><span class="line">	int size;	&#x2F;&#x2F;[0,size)</span><br><span class="line"></span><br><span class="line">	void init() &#123;</span><br><span class="line">		memset(digit, 0, sizeof(digit));</span><br><span class="line">		size &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	void set(char s[]) &#123;</span><br><span class="line">		init();</span><br><span class="line">		int len &#x3D; strlen(s);</span><br><span class="line">		for (int i &#x3D; len - 1, j &#x3D; 0, t &#x3D; 0, c &#x3D; 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			t +&#x3D; (s[i] - &#39;0&#39;)*c;</span><br><span class="line">			c *&#x3D; 10;</span><br><span class="line">			j++;</span><br><span class="line">			if (j &#x3D;&#x3D; 4 || i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				digit[size++] &#x3D; t;</span><br><span class="line">				j &#x3D; 0;</span><br><span class="line">				t &#x3D; 0;</span><br><span class="line">				c &#x3D; 1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void output() &#123;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			if (i !&#x3D; size - 1)</span><br><span class="line">				printf(&quot;%04d&quot;, digit[i]);	&#x2F;&#x2F;不是最高位则输出前导0</span><br><span class="line">			else printf(&quot;%d&quot;, digit[i]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BigInteger operator + (const BigInteger A) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; A.size || i &lt; size; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] + A.digit[i] + cf;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BigInteger operator * (const BigInteger &amp;A) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; A.size; j++) &#123;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">				int t &#x3D; digit[i] * A.digit[j] + cf;</span><br><span class="line">				cf &#x3D; t &#x2F; 10000;</span><br><span class="line">				ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool operator &lt; (const BigInteger&amp; A) const &#123;</span><br><span class="line">		if (A.size !&#x3D; size) return size &lt; A.size;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			if (digit[i] !&#x3D; A.digit[i])</span><br><span class="line">				return digit[i] &lt; A.digit[i];</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator &gt; (const BigInteger&amp; A) const &#123; return A &lt; *this; &#125;</span><br><span class="line">	bool operator &lt;&#x3D;(const BigInteger&amp; A) const &#123; return !(A &lt; *this); &#125;</span><br><span class="line">	bool operator &gt;&#x3D;(const BigInteger&amp; A) const &#123; return !(*this &lt; A); &#125;</span><br><span class="line">	bool operator !&#x3D;(const BigInteger&amp; A) const &#123; return *this &lt; A || A &lt; *this; &#125;</span><br><span class="line">	bool operator &#x3D;&#x3D;(const BigInteger&amp; A) const &#123; return !(*this &lt; A) &amp;&amp; !(A &lt; *this); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="n的阶乘"><a class="markdownIt-Anchor" href="#n的阶乘"></a> N的阶乘</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BigInteger operator * (int a) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; size ; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] * a + cf;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;n)&#x3D;&#x3D;1) &#123;</span><br><span class="line">		BigInteger x, y;</span><br><span class="line">		char a[] &#x3D; &quot;1&quot;;</span><br><span class="line">		x.set(a);</span><br><span class="line">		for (int i &#x3D; 2; i &lt;&#x3D; n; i++)</span><br><span class="line">			x&#x3D; x * i;</span><br><span class="line">		x.output();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进制转换清华"><a class="markdownIt-Anchor" href="#进制转换清华"></a> 进制转换(清华)</h2>
<ol>
<li>重载了对整型的除法和取余，注意这两部分写法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">class BigInteger &#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">	void init() &#123;</span><br><span class="line">		memset(digit, 0, sizeof(digit));</span><br><span class="line">		size &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	const static int maxn &#x3D; 10000 + 5;</span><br><span class="line">	int digit[maxn];</span><br><span class="line">	int size;</span><br><span class="line">	void set(char s[]) &#123;</span><br><span class="line">		init();</span><br><span class="line">		int len &#x3D; strlen(s);</span><br><span class="line">		for (int i &#x3D; len - 1, j &#x3D; 0, t &#x3D; 0, c &#x3D; 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			t +&#x3D; (s[i] - &#39;0&#39;)*c;</span><br><span class="line">			c *&#x3D; 10;</span><br><span class="line">			j++;</span><br><span class="line">			if (j &#x3D;&#x3D; 4 || i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				digit[size++] &#x3D; t;</span><br><span class="line">				j &#x3D; 0;</span><br><span class="line">				t &#x3D; 0;</span><br><span class="line">				c &#x3D; 1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void output() &#123;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			if (i !&#x3D; size - 1)</span><br><span class="line">				printf(&quot;%04d&quot;, digit[i]);	&#x2F;&#x2F;不是最高位则输出前导0</span><br><span class="line">			else printf(&quot;%d&quot;, digit[i]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BigInteger operator + (const BigInteger A) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; A.size || i &lt; size; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] + A.digit[i] + cf;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BigInteger operator * (int a) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] * a + cf;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">	BigInteger operator * (const BigInteger &amp;A) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; A.size; j++) &#123;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">				int t &#x3D; digit[i] * A.digit[j] + cf;</span><br><span class="line">				cf &#x3D; t &#x2F; 10000;</span><br><span class="line">				ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对整型除法和取模</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	BigInteger operator &#x2F; (const int a) &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int remain &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			int t &#x3D; (remain * 10000 + digit[i]) &#x2F; a;</span><br><span class="line">			int r &#x3D; (remain * 10000 + digit[i]) % a;</span><br><span class="line">			ret.digit[i] &#x3D; t;</span><br><span class="line">			remain &#x3D; r;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			if (digit[i] !&#x3D; 0) &#123;</span><br><span class="line">				ret.size &#x3D; i;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		ret.size++;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int operator % (int x) const &#123;</span><br><span class="line">		int remain &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			int t &#x3D; (remain * 10000 + digit[i]) &#x2F; x;</span><br><span class="line">			int r &#x3D; (remain * 10000 + digit[i]) % x;</span><br><span class="line">			remain &#x3D; r;</span><br><span class="line">		&#125;</span><br><span class="line">		return remain;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool operator &lt; (const BigInteger&amp; A) const &#123;</span><br><span class="line">		if (A.size !&#x3D; size) return size &lt; A.size;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			if (digit[i] !&#x3D; A.digit[i])</span><br><span class="line">				return digit[i] &lt; A.digit[i];</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator &gt; (const BigInteger&amp; A) const &#123; return A &lt; *this; &#125;</span><br><span class="line">	bool operator &lt;&#x3D;(const BigInteger&amp; A) const &#123; return !(A &lt; *this); &#125;</span><br><span class="line">	bool operator &gt;&#x3D;(const BigInteger&amp; A) const &#123; return !(*this &lt; A); &#125;</span><br><span class="line">	bool operator !&#x3D;(const BigInteger&amp; A) const &#123; return *this &lt; A || A &lt; *this; &#125;</span><br><span class="line">	bool operator &#x3D;&#x3D;(const BigInteger&amp; A) const &#123; return !(*this &lt; A) &amp;&amp; !(A &lt; *this); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">char s[10000];</span><br><span class="line">char ans[10000];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int m, n;</span><br><span class="line">	while (scanf(&quot;%d%d\n&quot;, &amp;m, &amp;n) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">		scanf(&quot;%s&quot;, s);</span><br><span class="line">		BigInteger a, b;</span><br><span class="line">		char s1[] &#x3D; &quot;0&quot;, s2[] &#x3D; &quot;1&quot;;</span><br><span class="line">		a.set(s1);	&#x2F;&#x2F;用来保存m进制转成的十进制数</span><br><span class="line">		b.set(s2);	&#x2F;&#x2F;记录转成10进制时候的权重</span><br><span class="line">		int len &#x3D; strlen(s);</span><br><span class="line">		for (int i &#x3D; len - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			int t;</span><br><span class="line">			if (s[i] &gt;&#x3D; &#39;0&#39;&amp;&amp;s[i] &lt;&#x3D; &#39;9&#39;)</span><br><span class="line">				t &#x3D; s[i] - &#39;0&#39;;</span><br><span class="line">			else t &#x3D; s[i] - &#39;A&#39; + 10;</span><br><span class="line">			a &#x3D; a + b * t;</span><br><span class="line">			b &#x3D; b * m;</span><br><span class="line">		&#125;</span><br><span class="line">		int id &#x3D; 0;</span><br><span class="line">		do &#123;</span><br><span class="line">			int t &#x3D; a % n;</span><br><span class="line">			if (t &gt;&#x3D; 10) ans[id] &#x3D; t - 10 + &#39;a&#39;;</span><br><span class="line">			else ans[id] &#x3D; t + &#39;0&#39;;</span><br><span class="line">			a &#x3D; a &#x2F; n;</span><br><span class="line">			id++;</span><br><span class="line">		&#125; while (a.digit[0] !&#x3D; 0 || a.size !&#x3D; 1);</span><br><span class="line">		for (int i &#x3D; id - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			printf(&quot;%c&quot;, ans[i]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="大整数取余小数简单代码"><a class="markdownIt-Anchor" href="#大整数取余小数简单代码"></a> 大整数取余小数简单代码</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void get_mod(int x) &#123;&#x2F;&#x2F;其中大整数已经由高位到低位依次存在了str中</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; strlen(str); i++) &#123;</span><br><span class="line">		ans *&#x3D; 10;</span><br><span class="line">		ans +&#x3D; str[i] - &#39;0&#39;;</span><br><span class="line">		ans %&#x3D; mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="浮点数加法"><a class="markdownIt-Anchor" href="#浮点数加法"></a> 浮点数加法</h2>
<p>求2个浮点数相加的和 题目中输入输出中出现浮点数都有如下的形式： P1P2…Pi.Q1Q2…Qj 对于整数部分，P1P2…Pi是一个非负整数 对于小数部分，Qj不等于0</p>
<p>输入： 对于每组案例，每组测试数据占2行，分别是两个加数。</p>
<p>输出： 每组案例是n行，每组测试数据有一行输出是相应的和。输出保证一定是一个小数部分不为0的浮点数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在上述BigInteger中加入对整型的重载加法</span><br><span class="line">BigInteger operator + (const int aa) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		int a &#x3D; aa;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] + a + cf;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">			if (!cf) a &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000000;</span><br><span class="line">char a[maxn], b[maxn];</span><br><span class="line">BigInteger a1, a2, b1, b2;</span><br><span class="line"></span><br><span class="line">inline int get_len(int xx) &#123;</span><br><span class="line">	int len &#x3D; 0;</span><br><span class="line">	while (xx)</span><br><span class="line">	&#123;</span><br><span class="line">		len++;</span><br><span class="line">		xx &#x2F;&#x3D; 10;</span><br><span class="line">	&#125;</span><br><span class="line">	return len;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	string x, y;</span><br><span class="line">	while (getline(cin, x)) &#123;</span><br><span class="line">		getline(cin, y);</span><br><span class="line">		int id &#x3D; x.find(&quot;.&quot;);</span><br><span class="line">		int ix &#x3D; y.find(&quot;.&quot;);</span><br><span class="line">		string s1 &#x3D; x.substr(id + 1).c_str();</span><br><span class="line">		string s2 &#x3D; y.substr(ix + 1).c_str();</span><br><span class="line">		int delen &#x3D; abs(int(s1.length() - s2.length()));</span><br><span class="line">		if (delen)&#x2F;&#x2F;将小数部分补齐成相同位数</span><br><span class="line">			if (s1.length() &lt; s2.length())</span><br><span class="line">				for (int i &#x3D; 0; i &lt; delen; i++)</span><br><span class="line">					s1 +&#x3D; &#39;0&#39;;</span><br><span class="line">			else</span><br><span class="line">				for (int i &#x3D; 0; i &lt; delen; i++)</span><br><span class="line">					s2 +&#x3D; &#39;0&#39;;</span><br><span class="line">		strcpy(a, x.substr(0, id).c_str());</span><br><span class="line">		strcpy(b, s1.c_str());</span><br><span class="line">		a1.set(a);</span><br><span class="line">		a2.set(b);</span><br><span class="line">		strcpy(a, y.substr(0, ix).c_str());</span><br><span class="line">		strcpy(b, s2.c_str());</span><br><span class="line">		b1.set(a);</span><br><span class="line">		b2.set(b);</span><br><span class="line"></span><br><span class="line">		BigInteger t &#x3D; a2 + b2;</span><br><span class="line">		int c &#x3D; 0;</span><br><span class="line">		int len &#x3D; 1;</span><br><span class="line">		int l1, l2;</span><br><span class="line">		l1 &#x3D; get_len(a2.digit[a2.size - 1]);</span><br><span class="line">		l1 &#x3D; max(l1, get_len(b2.digit[b2.size - 1]));</span><br><span class="line">		&#x2F;&#x2F;如果小数部分位数增加说明有进位。需要置进位位并在小数高位减去相应的值。</span><br><span class="line">		&#x2F;&#x2F;具体又分为两种情况</span><br><span class="line">		if (t.size &#x3D;&#x3D; a2.size) &#123;</span><br><span class="line">			l2 &#x3D; get_len(t.digit[t.size - 1]);</span><br><span class="line">			if (l1 !&#x3D; l2)</span><br><span class="line">			&#123;</span><br><span class="line">				c &#x3D; 1;</span><br><span class="line">				int xx &#x3D; b2.digit[b2.size - 1];</span><br><span class="line">				while (xx)</span><br><span class="line">				&#123;</span><br><span class="line">					len *&#x3D; 10;</span><br><span class="line">					xx &#x2F;&#x3D; 10;</span><br><span class="line">				&#125;</span><br><span class="line">				t.digit[t.size - 1] -&#x3D; len;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			c &#x3D; 1;</span><br><span class="line">			t.size--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		len &#x3D; l1 - get_len(t.digit[t.size - 1]);&#x2F;&#x2F;用于控制输出小数时的前导0</span><br><span class="line">		a2 &#x3D; a1 + b1;</span><br><span class="line">		a2 &#x3D; a2 + c;</span><br><span class="line">		a2.output();</span><br><span class="line">		printf(&quot;.&quot;);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">			printf(&quot;0&quot;);</span><br><span class="line">		t.output();</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10进制-vs-2进制"><a class="markdownIt-Anchor" href="#10进制-vs-2进制"></a> 10进制 vs 2进制</h2>
<p>代码都是前面提及的。<strong>但是发现在output函数中，可能输出前导0，所以加入判定条件改为：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void output() &#123;</span><br><span class="line">	for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">		if (i !&#x3D; size - 1)</span><br><span class="line">			printf(&quot;%04d&quot;, digit[i]);	&#x2F;&#x2F;不是最高位则输出前导0</span><br><span class="line">		else if(digit[i])</span><br><span class="line">			printf(&quot;%d&quot;, digit[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;本题主函数</span><br><span class="line"></span><br><span class="line">char s[1005];</span><br><span class="line">bool two[1000000000];</span><br><span class="line">int main() &#123;</span><br><span class="line">	scanf(&quot;%s&quot;, s);</span><br><span class="line">	BigInteger a, b;</span><br><span class="line">	a.set(s);</span><br><span class="line">	int id &#x3D; 0;</span><br><span class="line">	do</span><br><span class="line">	&#123;</span><br><span class="line">		two[id++] &#x3D; a % 2;</span><br><span class="line">		a &#x3D; a &#x2F; 2;</span><br><span class="line"></span><br><span class="line">	&#125; while (a.size !&#x3D; 1 || a.digit[0] !&#x3D; 0);</span><br><span class="line">	char xx[] &#x3D; &quot;0&quot;, yy[] &#x3D; &quot;1&quot;;</span><br><span class="line">	a.set(xx);&#x2F;&#x2F;0</span><br><span class="line">	b.set(yy);&#x2F;&#x2F;1</span><br><span class="line">	for (int i &#x3D; id - 1; i &gt;&#x3D; 0;i--) &#123;</span><br><span class="line"></span><br><span class="line">		a &#x3D; a + b * two[i];</span><br><span class="line">		b &#x3D; b * 2;</span><br><span class="line">	&#125;</span><br><span class="line">	a.output();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-数据结构" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"
    >数据结构</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2020-03-30T03:55:19.536Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h1>
<h2 id="括号匹配问题"><a class="markdownIt-Anchor" href="#括号匹配问题"></a> 括号匹配问题</h2>
<p>在某个字符串（长度不超过100）中有左括号、右括号和大小写字母；规定（与常见的算数式子一样）任何一个左括号都从内到外与在它右边且距离最近的右括号匹配。写一个程序，找到无法匹配的左括号和右括号，输出原来字符串，并在下一行标出不能匹配的括号。不能匹配的左括号用&quot;$“标注,不能匹配的右括号用”?&quot;标注。</p>
<h3 id="栈中存索引"><a class="markdownIt-Anchor" href="#栈中存索引"></a> 栈中存索引</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">char s[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%s&quot;, s) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">		printf(&quot;%s\n&quot;, s);</span><br><span class="line">		stack&lt;int&gt; st;</span><br><span class="line">		char ans[maxn];</span><br><span class="line">		for (int i &#x3D; 0;i&lt;strlen(s);i++) &#123;</span><br><span class="line">			if (s[i] &#x3D;&#x3D; &#39;(&#39;) &#123;</span><br><span class="line">				ans[i] &#x3D; &#39; &#39;;</span><br><span class="line">				st.push(i);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			else if (s[i] &#x3D;&#x3D; &#39;)&#39;) &#123;</span><br><span class="line">				if (!st.empty()&amp;&amp;s[st.top()] &#x3D;&#x3D; &#39;(&#39;) &#123;</span><br><span class="line">					ans[i] &#x3D; &#39; &#39;;</span><br><span class="line">					st.pop();</span><br><span class="line">				&#125;</span><br><span class="line">				else </span><br><span class="line">					ans[i] &#x3D; &#39;?&#39;;</span><br><span class="line">			&#125;</span><br><span class="line">			else ans[i] &#x3D; &#39; &#39;;</span><br><span class="line">		&#125;</span><br><span class="line">		while (!st.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			ans[st.top()] &#x3D; &#39;$&#39;;</span><br><span class="line">			st.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		ans[strlen(s)] &#x3D; &#39;\0&#39;;</span><br><span class="line">		printf(&quot;%s\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单计算器"><a class="markdownIt-Anchor" href="#简单计算器"></a> 简单计算器</h2>
<p>读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。</p>
<p>没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。</p>
<p>对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。</p>
<h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3>
<ol>
<li>开一个运算符栈一个操作数栈。主要在于判断各符号间的优先级，当当前读取的符号优先级低于栈顶的时候，应该先把栈顶运算符用了。其他都是小的细节问题。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 200 + 5;</span><br><span class="line">char s[maxn];</span><br><span class="line">bool is_op(char c) &#123; return c &#x3D;&#x3D; &#39;+&#39; || c &#x3D;&#x3D; &#39;-&#39; || c &#x3D;&#x3D; &#39;*&#39; || c &#x3D;&#x3D; &#39;&#x2F;&#39;; &#125;</span><br><span class="line">bool first(char a, char b) &#123;</span><br><span class="line">	if (a &#x3D;&#x3D; &#39;*&#39; || a &#x3D;&#x3D; &#39;&#x2F;&#39;)</span><br><span class="line">		return true;</span><br><span class="line">	else if (a &#x3D;&#x3D; &#39;-&#39; || a &#x3D;&#x3D; &#39;+&#39;) &#123;</span><br><span class="line">		if (b !&#x3D; &#39;*&#39; &amp;&amp; b !&#x3D; &#39;&#x2F;&#39;)</span><br><span class="line">			return true;</span><br><span class="line">		else return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">double calu(double a, double b, char op) &#123;</span><br><span class="line">	switch (op) &#123;</span><br><span class="line">	case &#39;+&#39;:return a + b; break;</span><br><span class="line">	case &#39;-&#39;:return a - b; break;</span><br><span class="line">	case &#39;*&#39;:return a * b; break;</span><br><span class="line">	case &#39;&#x2F;&#39;:return a &#x2F; b; break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (cin.getline(s, 201) &amp;&amp; s[0] !&#x3D; &#39;0&#39;) &#123;</span><br><span class="line">		stack&lt;double&gt; num;</span><br><span class="line">		stack&lt;char&gt; op;</span><br><span class="line">		int index &#x3D; 0;</span><br><span class="line">		while (index &lt; strlen(s)) &#123;</span><br><span class="line">			if (s[index] &#x3D;&#x3D; &#39; &#39;) index++;</span><br><span class="line">			int n &#x3D; 0;</span><br><span class="line">			while (isdigit(s[index]))</span><br><span class="line">			&#123;</span><br><span class="line">				n *&#x3D; 10;</span><br><span class="line">				n +&#x3D; s[index++] - &#39;0&#39;;</span><br><span class="line">			&#125;</span><br><span class="line">			if (n) num.push(n);</span><br><span class="line">			else &#123;</span><br><span class="line">				if (op.empty()) op.push(s[index]);</span><br><span class="line">				else &#123;</span><br><span class="line"></span><br><span class="line">					while (!op.empty() &amp;&amp; first(op.top(), s[index]))</span><br><span class="line">					&#123;</span><br><span class="line">						double a &#x3D; num.top(); num.pop();</span><br><span class="line">						double b &#x3D; num.top(); num.pop();</span><br><span class="line">						char oper;</span><br><span class="line">						oper &#x3D; op.top(); op.pop();</span><br><span class="line">						num.push(calu(b, a, oper));</span><br><span class="line">					&#125;</span><br><span class="line">					op.push(s[index]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">				index++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		while (!op.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			char oper &#x3D; op.top(); op.pop();</span><br><span class="line">			double a &#x3D; num.top(); num.pop();</span><br><span class="line">			double b &#x3D; num.top(); num.pop();</span><br><span class="line">			double ans &#x3D; calu(b, a, oper);</span><br><span class="line">			num.push(ans);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;%.2lf\n&quot;, num.top());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="哈夫曼树"><a class="markdownIt-Anchor" href="#哈夫曼树"></a> 哈夫曼树</h1>
<h2 id="哈夫曼编码"><a class="markdownIt-Anchor" href="#哈夫曼编码"></a> 哈夫曼编码</h2>
<p>使用递减的优先级队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;搬水果</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pq;</span><br><span class="line"></span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n)&#x3D;&#x3D;1 &amp;&amp;n) &#123;</span><br><span class="line">		int x;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">			pq.push(x);</span><br><span class="line">		&#125;</span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		while (pq.size()&gt;1) &#123;</span><br><span class="line">			int a &#x3D; pq.top(); pq.pop();</span><br><span class="line">			int b &#x3D; pq.top(); pq.pop();</span><br><span class="line">			ans +&#x3D; a + b;</span><br><span class="line">			pq.push(a + b);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树"></a> 二叉树</h1>
<h2 id="二叉树遍历-华科"><a class="markdownIt-Anchor" href="#二叉树遍历-华科"></a> 二叉树遍历 华科</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 26 + 1;</span><br><span class="line">char pre[maxn], in[maxn];</span><br><span class="line"></span><br><span class="line">typedef struct node &#123;</span><br><span class="line">	struct node *lchild, *rchild;</span><br><span class="line">	char data;</span><br><span class="line">&#125;node, *ptr;</span><br><span class="line"></span><br><span class="line">ptr create(char *pre, char *in, int n) &#123;</span><br><span class="line">	ptr s;</span><br><span class="line">	if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">		s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">		s-&gt;data &#x3D; *pre;</span><br><span class="line">		s-&gt;rchild &#x3D; s-&gt;lchild &#x3D; NULL;</span><br><span class="line">		return s;</span><br><span class="line">	&#125;</span><br><span class="line">	char *p;</span><br><span class="line">	for (p &#x3D; in; p &lt; in + n; p++)</span><br><span class="line">		if (*p &#x3D;&#x3D; *pre) break;</span><br><span class="line">	int k &#x3D; p - in;</span><br><span class="line"></span><br><span class="line">	s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">	s-&gt;data &#x3D; *p;</span><br><span class="line">	s-&gt;rchild &#x3D; s-&gt;lchild &#x3D; NULL;</span><br><span class="line">	if (k) s-&gt;lchild &#x3D; create(pre + 1, in, k);</span><br><span class="line">	if (n - k - 1) s-&gt;rchild &#x3D; create(pre + k + 1, p + 1, n - k - 1);</span><br><span class="line">	return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void post_order(ptr T) &#123;</span><br><span class="line">	if (T-&gt;lchild) post_order(T-&gt;lchild);</span><br><span class="line">	if (T-&gt;rchild)post_order(T-&gt;rchild);</span><br><span class="line">	printf(&quot;%c&quot;, T-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%s&quot;, pre) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">		scanf(&quot;%s&quot;, in);</span><br><span class="line">		ptr T &#x3D; create(&amp;pre[0], &amp;in[0], strlen(pre));</span><br><span class="line">		post_order(T);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树遍历-清华"><a class="markdownIt-Anchor" href="#二叉树遍历-清华"></a> 二叉树遍历 清华</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 1;</span><br><span class="line">char pre[maxn];</span><br><span class="line">typedef struct node &#123;</span><br><span class="line">	struct node *lchild, *rchild;</span><br><span class="line">	char data;</span><br><span class="line">&#125;node, *ptr;</span><br><span class="line">ptr create(int &amp;cur, const char * pre, int n) &#123;</span><br><span class="line">	if (cur &#x3D;&#x3D; n || pre[cur] &#x3D;&#x3D; &#39;#&#39;) return NULL;</span><br><span class="line"></span><br><span class="line">	ptr s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">	s-&gt;data &#x3D; pre[cur];</span><br><span class="line">	cur++;</span><br><span class="line">	s-&gt;lchild &#x3D; create(cur, pre, n);</span><br><span class="line">	cur++;</span><br><span class="line">	s-&gt;rchild &#x3D; create(cur, pre, n);</span><br><span class="line">	return s;</span><br><span class="line">&#125;</span><br><span class="line">void in_order(ptr T) &#123;</span><br><span class="line">	if (T-&gt;lchild !&#x3D; NULL) in_order(T-&gt;lchild);</span><br><span class="line">	printf(&quot;%c &quot;, T-&gt;data);</span><br><span class="line">	if (T-&gt;rchild !&#x3D; NULL) in_order(T-&gt;rchild);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%s&quot;, pre) &#x3D;&#x3D; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		int a &#x3D; 0;</span><br><span class="line">		ptr T &#x3D; create(a, pre, strlen(pre));</span><br><span class="line">		in_order(T);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉排序树"><a class="markdownIt-Anchor" href="#二叉排序树"></a> 二叉排序树</h1>
<h2 id="创建二叉排序树"><a class="markdownIt-Anchor" href="#创建二叉排序树"></a> 创建二叉排序树</h2>
<p><strong>此处是递归的逐个节点比较。由于二叉排序树的特殊性，也可以使用前中序遍历序列或中后序遍历序列比较</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct node &#123;</span><br><span class="line">	struct node *lchild, *rchild;</span><br><span class="line">	int data;</span><br><span class="line">&#125;node, *ptr;</span><br><span class="line"></span><br><span class="line">ptr insert(ptr T, int x) &#123;</span><br><span class="line">	if (T &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		T &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">		T-&gt;data &#x3D; x;</span><br><span class="line">		T-&gt;lchild &#x3D; T-&gt;rchild &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		if (x &gt; T-&gt;data)</span><br><span class="line">			T-&gt;rchild &#x3D; insert(T-&gt;rchild, x);</span><br><span class="line">		else if (x &lt; T-&gt;data)</span><br><span class="line">			T-&gt;lchild &#x3D; insert(T-&gt;lchild, x);</span><br><span class="line">	&#125;</span><br><span class="line">	return T;</span><br><span class="line">&#125;</span><br><span class="line">void pre_order(ptr T) &#123;</span><br><span class="line">	printf(&quot;%d &quot;, T-&gt;data);</span><br><span class="line">	if (T-&gt;lchild !&#x3D; NULL) pre_order(T-&gt;lchild);</span><br><span class="line">	if (T-&gt;rchild !&#x3D; NULL)pre_order(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void in_order(ptr T) &#123;</span><br><span class="line">	if (T-&gt;lchild !&#x3D; NULL)	in_order(T-&gt;lchild);</span><br><span class="line">	printf(&quot;%d &quot;, T-&gt;data);</span><br><span class="line">	if (T-&gt;rchild !&#x3D; NULL) in_order(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void post_order(ptr T) &#123;</span><br><span class="line">	if (T-&gt;lchild !&#x3D; NULL) post_order(T-&gt;lchild);</span><br><span class="line">	if (T-&gt;rchild !&#x3D; NULL) post_order(T-&gt;rchild);</span><br><span class="line">	printf(&quot;%d &quot;, T-&gt;data);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;n)&#x3D;&#x3D;1)</span><br><span class="line">	&#123;</span><br><span class="line">		ptr T &#x3D; NULL;</span><br><span class="line">		int x;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">			T &#x3D; insert(T, x);</span><br><span class="line">		&#125;</span><br><span class="line">		pre_order(T);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">		in_order(T);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">		post_order(T);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树搜索判断树同构"><a class="markdownIt-Anchor" href="#二叉树搜索判断树同构"></a> 二叉树搜索(判断树同构)</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct node &#123;</span><br><span class="line">	struct node *lchild, *rchild;</span><br><span class="line">	int data;</span><br><span class="line">&#125;node, *ptr;</span><br><span class="line"></span><br><span class="line">ptr insert(ptr T, int x) &#123;</span><br><span class="line">	if (T &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		T &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">		T-&gt;data &#x3D; x;</span><br><span class="line">		T-&gt;lchild &#x3D; T-&gt;rchild &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		if (x &gt; T-&gt;data)</span><br><span class="line">			T-&gt;rchild &#x3D; insert(T-&gt;rchild, x);</span><br><span class="line">		else if (x &lt; T-&gt;data)</span><br><span class="line">			T-&gt;lchild &#x3D; insert(T-&gt;lchild, x);</span><br><span class="line">	&#125;</span><br><span class="line">	return T;</span><br><span class="line">&#125;</span><br><span class="line">bool equal(ptr  T1, ptr T2) &#123;</span><br><span class="line">	if (T1 &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		if (T2 &#x3D;&#x3D; NULL) return true;</span><br><span class="line">		else return false;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (T1-&gt;data &#x3D;&#x3D; T2-&gt;data)</span><br><span class="line">		return equal(T1-&gt;lchild, T2-&gt;lchild) &amp;&amp;</span><br><span class="line">		equal(T1-&gt;rchild, T2-&gt;rchild);</span><br><span class="line"></span><br><span class="line">	return false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		ptr T &#x3D; NULL;</span><br><span class="line">		char x;</span><br><span class="line">		getchar();</span><br><span class="line">		while (scanf(&quot;%c&quot;, &amp;x) &#x3D;&#x3D; 1 &amp;&amp; x !&#x3D; &#39;\n&#39;)</span><br><span class="line">			T &#x3D; insert(T, x - &#39;0&#39;);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			ptr T2 &#x3D; NULL;</span><br><span class="line">			while (scanf(&quot;%c&quot;, &amp;x) &#x3D;&#x3D; 1 &amp;&amp; x !&#x3D; &#39;\n&#39;)</span><br><span class="line">				T2 &#x3D; insert(T2, x - &#39;0&#39;);</span><br><span class="line">			if (equal(T, T2))</span><br><span class="line">				printf(&quot;YES\n&quot;);</span><br><span class="line">			else printf(&quot;NO\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除二叉排序树上的节点"><a class="markdownIt-Anchor" href="#删除二叉排序树上的节点"></a> 删除二叉排序树上的节点</h2>
<ol>
<li>找到这个节点</li>
<li>若该节点为叶子节点，则直接删除，即将其父节点指向其的指针置为空</li>
<li>若该节点仅不存在右子树，那么直接将左子树的根节点替代其位置后，删除该节点。</li>
<li>若该节点存在右子树，那么用其右子树最右下节点(即右子树中序遍历的第一个点)替换，并删除最右下节点。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-考研机试目录" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%80%83%E7%A0%94%E6%9C%BA%E8%AF%95%E7%9B%AE%E5%BD%95/"
    >考研机试目录</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%80%83%E7%A0%94%E6%9C%BA%E8%AF%95%E7%9B%AE%E5%BD%95/" class="article-date">
  <time datetime="2020-03-30T03:55:14.299Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="基础相关"><a class="markdownIt-Anchor" href="#基础相关"></a> <a href="/2020/03/30/%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/">基础相关</a></h2>
<h2 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> <a href="/2020/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></h2>
<h2 id="数学理论"><a class="markdownIt-Anchor" href="#数学理论"></a> <a href="/2020/03/30/%E6%95%B0%E5%AD%A6%E7%90%86%E8%AE%BA/">数学理论</a></h2>
<h2 id="搜索"><a class="markdownIt-Anchor" href="#搜索"></a> <a href="/2020/03/30/%E6%90%9C%E7%B4%A2/">搜索</a></h2>
<h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> <a href="/2020/03/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></h2>
<h2 id="图论"><a class="markdownIt-Anchor" href="#图论"></a> <a href="/2020/03/30/%E5%9B%BE%E8%AE%BA/">图论</a></h2>
<h2 id="其他技巧"><a class="markdownIt-Anchor" href="#其他技巧"></a> <a href="/2020/03/30/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7/">其他技巧</a></h2>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Mysql基本语法" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/Mysql%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"
    >Mysql基本语法</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/Mysql%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" class="article-date">
  <time datetime="2020-03-30T03:50:57.746Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="mysql基础"><a class="markdownIt-Anchor" href="#mysql基础"></a> Mysql基础</h1>
<h2 id="数据库相关概念"><a class="markdownIt-Anchor" href="#数据库相关概念"></a> 数据库相关概念</h2>
<p>一、数据库的好处<br />
1、可以持久化数据到本地<br />
2、结构化查询</p>
<p>二、数据库的常见概念 ★<br />
1、DB：数据库，存储数据的容器<br />
2、DBMS：数据库管理系统，又称为数据库软件或数据库产品，用于创建或管理DB<br />
3、SQL：结构化查询语言，用于和数据库通信的语言，不是某个数据库软件特有的，而是几乎所有的主流数据库软件通用的语言</p>
<p>三、数据库存储数据的特点<br />
1、数据存放到表中，然后表再放到库中<br />
2、一个库中可以有多张表，每张表具有唯一的表名用来标识自己<br />
3、表中有一个或多个列，列又称为“字段”，相当于java中“属性”<br />
4、表中的每一行数据，相当于java中“对象”</p>
<p>四、常见的数据库管理系统<br />
mysql、oracle、db2、sqlserver</p>
<h2 id="mysql介绍"><a class="markdownIt-Anchor" href="#mysql介绍"></a> MySql介绍</h2>
<p>一、MySQL的背景<br />
前身属于瑞典的一家公司，MySQL AB<br />
08年被sun公司收购<br />
09年sun被oracle收购</p>
<p>二、MySQL的优点<br />
1、开源、免费、成本低<br />
2、性能高、移植性也好<br />
3、体积小，便于安装<br />
三、MySQL的安装<br />
属于c/s架构的软件，一般来讲安装服务端<br />
企业版<br />
社区版</p>
<p>5.5<br />
5.6<br />
5.7<br />
8.0</p>
<p>四、MySQL服务的启动和停止<br />
方式一：通过命令行<br />
net start 服务名<br />
net stop 服务名<br />
方式二：计算机——右击——管理——服务</p>
<p>五、MySQL服务的登录和退出</p>
<p>登录：mysql 【-h 主机名 -P 端口号】 -u 用户名 -p密码</p>
<p>退出：exit或ctrl+C</p>
<h1 id="dql语言"><a class="markdownIt-Anchor" href="#dql语言"></a> DQL语言</h1>
<h2 id="基础查询"><a class="markdownIt-Anchor" href="#基础查询"></a> 基础查询</h2>
<p>一、语法<br />
select 查询列表<br />
from 表名;<br />
二、特点<br />
1、查询列表可以是字段、常量、表达式、函数，也可以是多个<br />
2、查询结果是一个虚拟表</p>
<p>三、示例<br />
1、查询单个字段<br />
select 字段名 from 表名;<br />
2、查询多个字段<br />
select 字段名，字段名 from 表名;<br />
3、查询所有字段<br />
select * from 表名<br />
4、查询常量<br />
select 常量值;<br />
注意：字符型和日期型的常量值必须用单引号引起来，数值型不需要<br />
5、查询函数<br />
select 函数名(实参列表);<br />
6、查询表达式<br />
select 100/1234;<br />
7、起别名<br />
①as<br />
②空格<br />
8、去重<br />
select distinct 字段名 from 表名;</p>
<p>9、+<br />
作用：做加法运算<br />
select 数值+数值; 直接运算<br />
select 字符+数值;先试图将字符转换成数值，如果转换成功，则继续运算；否则转换成0，再做运算<br />
select null+值;结果都为null</p>
<p>10、【补充】concat函数<br />
功能：拼接字符<br />
select concat(字符1，字符2，字符3,…);</p>
<p>11、【补充】ifnull函数<br />
功能：判断某字段或表达式是否为null，如果为null 返回指定的值，否则返回原本的值<br />
select ifnull(commission_pct,0) from employees;</p>
<p>12、【补充】isnull函数<br />
功能：判断某字段或表达式是否为null，如果是，则返回1，否则返回0</p>
<h2 id="条件查询"><a class="markdownIt-Anchor" href="#条件查询"></a> 条件查询</h2>
<p>一、语法<br />
select 查询列表<br />
from 表名<br />
where 筛选条件</p>
<p>二、筛选条件的分类<br />
1、简单条件运算符</p>
<blockquote>
<p>&lt; = &lt;&gt; != &gt;= &lt;=  &lt;=&gt;安全等于<br />
2、逻辑运算符<br />
&amp;&amp; and<br />
|| or<br />
!  not<br />
3、模糊查询<br />
like:一般搭配通配符使用，可以判断字符型或数值型<br />
通配符：%任意多个字符，_任意单个字符</p>
</blockquote>
<p>between and<br />
in<br />
is null /is not null：用于判断null值</p>
<p>is null PK &lt;=&gt;<br />
普通类型的数值	null值		可读性<br />
is null		×			√		√<br />
&lt;=&gt;		√			√		×</p>
<h2 id="排序查询"><a class="markdownIt-Anchor" href="#排序查询"></a> 排序查询</h2>
<p>一、语法<br />
select 查询列表<br />
from 表<br />
where 筛选条件<br />
order by 排序列表 【asc}desc】</p>
<p>二、特点<br />
1、asc ：升序，如果不写默认升序<br />
desc：降序</p>
<p>2、排序列表 支持 单个字段、多个字段、函数、表达式、别名</p>
<p>3、order by的位置一般放在查询语句的最后（除limit语句之外）</p>
<h2 id="常见函数"><a class="markdownIt-Anchor" href="#常见函数"></a> 常见函数</h2>
<p>一、概述<br />
功能：类似于java中的方法<br />
好处：提高重用性和隐藏实现细节<br />
调用：select 函数名(实参列表);<br />
二、单行函数<br />
1、字符函数<br />
concat:连接<br />
substr:截取子串<br />
upper:变大写<br />
lower：变小写<br />
replace：替换<br />
length：获取字节长度<br />
trim:去前后空格<br />
lpad：左填充<br />
rpad：右填充<br />
instr:获取子串第一次出现的索引<br />
2、数学函数<br />
ceil:向上取整<br />
round：四舍五入<br />
mod:取模<br />
floor：向下取整<br />
truncate:截断<br />
rand:获取随机数，返回0-1之间的小数</p>
<p>3、日期函数</p>
<p>now：返回当前日期+时间<br />
year:返回年<br />
month：返回月<br />
day:返回日<br />
date_format:将日期转换成字符<br />
curdate:返回当前日期<br />
str_to_date:将字符转换成日期<br />
curtime：返回当前时间<br />
hour:小时<br />
minute:分钟<br />
second：秒<br />
datediff:返回两个日期相差的天数<br />
monthname:以英文形式返回月</p>
<p>4、其他函数<br />
version 当前数据库服务器的版本<br />
database 当前打开的数据库<br />
user当前用户<br />
password(‘字符’)：返回该字符的密码形式<br />
md5(‘字符’):返回该字符的md5加密形式</p>
<p>5、流程控制函数</p>
<p>①if(条件表达式，表达式1，表达式2)：如果条件表达式成立，返回表达式1，否则返回表达式2<br />
②case情况1<br />
case 变量或表达式或字段<br />
when 常量1 then 值1<br />
when 常量2 then 值2<br />
…<br />
else 值n<br />
end</p>
<p>③case情况2<br />
case<br />
when 条件1 then 值1<br />
when 条件2 then 值2<br />
…<br />
else 值n<br />
end</p>
<p>三、分组函数<br />
1、分类<br />
max 最大值<br />
min 最小值<br />
sum 和<br />
avg 平均值<br />
count 计算个数</p>
<p>2、特点</p>
<p>①语法<br />
select max(字段) from 表名;</p>
<p>②支持的类型<br />
sum和avg一般用于处理数值型<br />
max、min、count可以处理任何数据类型</p>
<p>③以上分组函数都忽略null<br />
④都可以搭配distinct使用，实现去重的统计<br />
select sum(distinct 字段) from 表;<br />
⑤count函数<br />
count(字段)：统计该字段非空值的个数<br />
count(*):统计结果集的行数<br />
案例：查询每个部门的员工个数<br />
1 xx    10<br />
2 dd    20<br />
3 mm    20<br />
4 aa    40<br />
5 hh    40</p>
<p>count(1):统计结果集的行数</p>
<p>效率上：<br />
MyISAM存储引擎，count(<em>)最高<br />
InnoDB存储引擎，count(</em>)和count(1)效率&gt;count(字段)</p>
<p>⑥ 和分组函数一同查询的字段，要求是group by后出现的字段</p>
<h2 id="分组查序"><a class="markdownIt-Anchor" href="#分组查序"></a> 分组查序</h2>
<p>一、语法<br />
select 分组函数，分组后的字段<br />
from 表<br />
【where 筛选条件】<br />
group by 分组的字段<br />
【having 分组后的筛选】<br />
【order by 排序列表】</p>
<p>二、特点</p>
<pre><code>		使用关键字		筛选的表	位置
</code></pre>
<p>分组前筛选	where			原始表		group by的前面<br />
分组后筛选	having		分组后的结果	group by 的后面</p>
<h2 id="连接查询"><a class="markdownIt-Anchor" href="#连接查询"></a> 连接查询</h2>
<p>一、含义<br />
当查询中涉及到了多个表的字段，需要使用多表连接<br />
select 字段1，字段2<br />
from 表1，表2,…;</p>
<p>笛卡尔乘积：当查询多个表时，没有添加有效的连接条件，导致多个表所有行实现完全连接<br />
如何解决：添加有效的连接条件</p>
<p>二、分类</p>
<p>按年代分类：<br />
sql92：<br />
等值<br />
非等值<br />
自连接</p>
<pre><code>	也支持一部分外连接（用于oracle、sqlserver，mysql不支持）
sql99【推荐使用】
	内连接
		等值
		非等值
		自连接
	外连接
		左外
		右外
		全外（mysql不支持）
	交叉连接
</code></pre>
<p>三、SQL92语法<br />
1、等值连接<br />
语法：<br />
select 查询列表<br />
from 表1 别名,表2 别名<br />
where 表1.key=表2.key<br />
【and 筛选条件】<br />
【group by 分组字段】<br />
【having 分组后的筛选】<br />
【order by 排序字段】</p>
<p>特点：<br />
① 一般为表起别名<br />
②多表的顺序可以调换<br />
③n表连接至少需要n-1个连接条件<br />
④等值连接的结果是多表的交集部分</p>
<p>2、非等值连接<br />
语法：<br />
select 查询列表<br />
from 表1 别名,表2 别名<br />
where 非等值的连接条件<br />
【and 筛选条件】<br />
【group by 分组字段】<br />
【having 分组后的筛选】<br />
【order by 排序字段】<br />
3、自连接</p>
<p>语法：<br />
select 查询列表<br />
from 表 别名1,表 别名2<br />
where 等值的连接条件<br />
【and 筛选条件】<br />
【group by 分组字段】<br />
【having 分组后的筛选】<br />
【order by 排序字段】</p>
<p>四、SQL99语法<br />
1、内连接<br />
语法：<br />
select 查询列表<br />
from 表1 别名<br />
【inner】 join 表2 别名 on 连接条件<br />
where 筛选条件<br />
group by 分组列表<br />
having 分组后的筛选<br />
order by 排序列表<br />
limit 子句;</p>
<p>特点：<br />
①表的顺序可以调换<br />
②内连接的结果=多表的交集<br />
③n表连接至少需要n-1个连接条件</p>
<p>分类：<br />
等值连接<br />
非等值连接<br />
自连接</p>
<p>2、外连接<br />
语法：<br />
select 查询列表<br />
from 表1 别名<br />
left|right|full【outer】 join 表2 别名 on 连接条件<br />
where 筛选条件<br />
group by 分组列表<br />
having 分组后的筛选<br />
order by 排序列表<br />
limit 子句;<br />
特点：<br />
①查询的结果=主表中所有的行，如果从表和它匹配的将显示匹配行，如果从表没有匹配的则显示null<br />
②left join 左边的就是主表，right join 右边的就是主表<br />
full join 两边都是主表<br />
③一般用于查询除了交集部分的剩余的不匹配的行</p>
<p>3、交叉连接</p>
<p>语法：<br />
select 查询列表<br />
from 表1 别名<br />
cross join 表2 别名;</p>
<p>特点：<br />
类似于笛卡尔乘积</p>
<h2 id="子查询"><a class="markdownIt-Anchor" href="#子查询"></a> 子查询</h2>
<p>一、含义<br />
嵌套在其他语句内部的select语句称为子查询或内查询，<br />
外面的语句可以是insert、update、delete、select等，一般select作为外面语句较多<br />
外面如果为select语句，则此语句称为外查询或主查询</p>
<p>二、分类<br />
1、按出现位置<br />
select后面：<br />
仅仅支持标量子查询<br />
from后面：<br />
表子查询<br />
where或having后面：<br />
标量子查询<br />
列子查询<br />
行子查询<br />
exists后面：<br />
标量子查询<br />
列子查询<br />
行子查询<br />
表子查询</p>
<p>2、按结果集的行列<br />
标量子查询（单行子查询）：结果集为一行一列<br />
列子查询（多行子查询）：结果集为多行一列<br />
行子查询：结果集为多行多列<br />
表子查询：结果集为多行多列</p>
<p>三、示例<br />
where或having后面<br />
1、标量子查询<br />
案例：查询最低工资的员工姓名和工资<br />
①最低工资<br />
select min(salary) from employees</p>
<p>②查询员工的姓名和工资，要求工资=①<br />
select last_name,salary<br />
from employees<br />
where salary=(<br />
select min(salary) from employees<br />
);</p>
<p>2、列子查询<br />
案例：查询所有是领导的员工姓名<br />
①查询所有员工的 manager_id<br />
select manager_id<br />
from employees</p>
<p>②查询姓名，employee_id属于①列表的一个<br />
select last_name<br />
from employees<br />
where employee_id in(<br />
select manager_id<br />
from employees<br />
);</p>
<h2 id="分页查询"><a class="markdownIt-Anchor" href="#分页查询"></a> 分页查询</h2>
<p>一、应用场景<br />
当要查询的条目数太多，一页显示不全<br />
二、语法</p>
<p>select 查询列表<br />
from 表<br />
limit 【offset，】size;<br />
注意：<br />
offset代表的是起始的条目索引，默认从0卡死<br />
size代表的是显示的条目数</p>
<p>公式：<br />
假如要显示的页数为page，每一页条目数为size<br />
select 查询列表<br />
from 表<br />
limit (page-1)*size,size;</p>
<h2 id="联合查询"><a class="markdownIt-Anchor" href="#联合查询"></a> 联合查询</h2>
<p>一、含义<br />
union：合并、联合，将多次查询结果合并成一个结果<br />
二、语法<br />
查询语句1<br />
union 【all】<br />
查询语句2<br />
union 【all】<br />
…</p>
<p>三、意义<br />
1、将一条比较复杂的查询语句拆分成多条语句<br />
2、适用于查询多个表的时候，查询的列基本是一致</p>
<p>四、特点<br />
1、要求多条查询语句的查询列数必须一致<br />
2、要求多条查询语句的查询的各列类型、顺序最好一致<br />
3、union 去重，union all包含重复项</p>
<h2 id="查询总结"><a class="markdownIt-Anchor" href="#查询总结"></a> 查询总结</h2>
<p>语法：<br />
select 查询列表    ⑦<br />
from 表1 别名       ①<br />
连接类型 join 表2   ②<br />
on 连接条件         ③<br />
where 筛选          ④<br />
group by 分组列表   ⑤<br />
having 筛选         ⑥<br />
order by排序列表    ⑧<br />
limit 起始条目索引，条目数;  ⑨</p>
<h1 id="dml语言"><a class="markdownIt-Anchor" href="#dml语言"></a> DML语言</h1>
<h2 id="插入"><a class="markdownIt-Anchor" href="#插入"></a> 插入</h2>
<p>一、方式一<br />
语法：<br />
insert into 表名(字段名,…) values(值,…);<br />
特点：<br />
1、要求值的类型和字段的类型要一致或兼容<br />
2、字段的个数和顺序不一定与原始表中的字段个数和顺序一致<br />
但必须保证值和字段一一对应<br />
3、假如表中有可以为null的字段，注意可以通过以下两种方式插入null值<br />
①字段和值都省略<br />
②字段写上，值使用null<br />
4、字段和值的个数必须一致<br />
5、字段名可以省略，默认所有列</p>
<p>二、方式二<br />
语法：<br />
insert into 表名 set 字段=值,字段=值,…;</p>
<p>两种方式 的区别：<br />
1.方式一支持一次插入多行，语法如下：<br />
insert into 表名【(字段名,…)】 values(值，…),(值，…),…;<br />
2.方式一支持子查询，语法如下：<br />
insert into 表名<br />
查询语句;</p>
<h2 id="修改"><a class="markdownIt-Anchor" href="#修改"></a> 修改</h2>
<p>一、修改单表的记录 ★<br />
语法：update 表名 set 字段=值,字段=值 【where 筛选条件】;</p>
<p>二、修改多表的记录【补充】<br />
语法：<br />
update 表1 别名<br />
left|right|inner join 表2 别名<br />
on 连接条件<br />
set 字段=值,字段=值<br />
【where 筛选条件】;</p>
<h2 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h2>
<p>方式一：使用delete<br />
一、删除单表的记录★<br />
语法：delete from 表名 【where 筛选条件】【limit 条目数】<br />
二、级联删除[补充]<br />
语法：<br />
delete 别名1,别名2 from 表1 别名<br />
inner|left|right join 表2 别名<br />
on 连接条件<br />
【where 筛选条件】</p>
<p>方式二：使用truncate<br />
语法：truncate table 表名</p>
<p>两种方式的区别【面试题】★</p>
<p>1.truncate删除后，如果再插入，标识列从1开始<br />
delete删除后，如果再插入，标识列从断点开始<br />
2.delete可以添加筛选条件<br />
truncate不可以添加筛选条件<br />
3.truncate效率较高<br />
4.truncate没有返回值<br />
delete可以返回受影响的行数<br />
5.truncate不可以回滚<br />
delete可以回滚</p>
<h1 id="ddl语言"><a class="markdownIt-Anchor" href="#ddl语言"></a> DDL语言</h1>
<h2 id="库的管理"><a class="markdownIt-Anchor" href="#库的管理"></a> 库的管理</h2>
<p>一、创建库<br />
create database 【if not exists】 库名【 character set 字符集名】;</p>
<p>二、修改库<br />
alter database 库名 character set 字符集名;<br />
三、删除库<br />
drop database 【if exists】 库名;</p>
<h2 id="表的管理"><a class="markdownIt-Anchor" href="#表的管理"></a> 表的管理</h2>
<p>一、创建表 ★<br />
create table 【if not exists】 表名(<br />
字段名 字段类型 【约束】,<br />
字段名 字段类型 【约束】,<br />
。。。<br />
字段名 字段类型 【约束】</p>
<p>)</p>
<p>二、修改表</p>
<p>1.添加列<br />
alter table 表名 add column 列名 类型 【first|after 字段名】;<br />
2.修改列的类型或约束<br />
alter table 表名 modify column 列名 新类型 【新约束】;<br />
3.修改列名<br />
alter table 表名 change column 旧列名 新列名 类型;<br />
4 .删除列<br />
alter table 表名 drop column 列名;<br />
5.修改表名<br />
alter table 表名 rename 【to】 新表名;</p>
<p>三、删除表<br />
drop table【if exists】 表名;</p>
<p>四、复制表<br />
1、复制表的结构<br />
create table 表名 like 旧表;<br />
2、复制表的结构+数据<br />
create table 表名<br />
select 查询列表 from 旧表【where 筛选】;</p>
<h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2>
<p>一、数值型<br />
1、整型<br />
tinyint、smallint、mediumint、int/integer、bigint<br />
1         2        3          4            8</p>
<p>特点：<br />
①都可以设置无符号和有符号，默认有符号，通过unsigned设置无符号<br />
②如果超出了范围，会报out or range异常，插入临界值<br />
③长度可以不指定，默认会有一个长度<br />
长度代表显示的最大宽度，如果不够则左边用0填充，但需要搭配zerofill，并且默认变为无符号整型</p>
<p>2、浮点型<br />
定点数：decimal(M,D)<br />
浮点数:<br />
float(M,D)   4<br />
double(M,D)  8</p>
<p>特点：<br />
①M代表整数部位+小数部位的个数，D代表小数部位<br />
②如果超出范围，则报out or range异常，并且插入临界值<br />
③M和D都可以省略，但对于定点数，M默认为10，D默认为0<br />
④如果精度要求较高，则优先考虑使用定点数</p>
<p>二、字符型<br />
char、varchar、binary、varbinary、enum、set、text、blob</p>
<p>char：固定长度的字符，写法为char(M)，最大长度不能超过M，其中M可以省略，默认为1<br />
varchar：可变长度的字符，写法为varchar(M)，最大长度不能超过M，其中M不可以省略</p>
<p>三、日期型<br />
year年<br />
date日期<br />
time时间<br />
datetime 日期+时间          8<br />
timestamp 日期+时间         4   比较容易受时区、语法模式、版本的影响，更能反映当前时区的真实时间</p>
<h2 id="常见的约束"><a class="markdownIt-Anchor" href="#常见的约束"></a> 常见的约束</h2>
<p>一、常见的约束<br />
NOT NULL：非空，该字段的值必填<br />
UNIQUE：唯一，该字段的值不可重复<br />
DEFAULT：默认，该字段的值不用手动插入有默认值<br />
CHECK：检查，mysql不支持<br />
PRIMARY KEY：主键，该字段的值不可重复并且非空  unique+not null<br />
FOREIGN KEY：外键，该字段的值引用了另外的表的字段</p>
<p>主键和唯一<br />
1、区别：<br />
①、一个表至多有一个主键，但可以有多个唯一<br />
②、主键不允许为空，唯一可以为空<br />
2、相同点<br />
都具有唯一性<br />
都支持组合键，但不推荐<br />
外键：<br />
1、用于限制两个表的关系，从表的字段值引用了主表的某字段值<br />
2、外键列和主表的被引用列要求类型一致，意义一样，名称无要求<br />
3、主表的被引用列要求是一个key（一般就是主键）<br />
4、插入数据，先插入主表<br />
删除数据，先删除从表<br />
可以通过以下两种方式来删除主表的记录<br />
#方式一：级联删除<br />
ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE;</p>
<p>#方式二：级联置空<br />
ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL;</p>
<p>二、创建表时添加约束<br />
create table 表名(<br />
字段名 字段类型 not null,#非空<br />
字段名 字段类型 primary key,#主键<br />
字段名 字段类型 unique,#唯一<br />
字段名 字段类型 default 值,#默认<br />
constraint 约束名 foreign key(字段名) references 主表（被引用列）</p>
<p>)<br />
注意：<br />
支持类型		可以起约束名			<br />
列级约束		除了外键		不可以<br />
表级约束		除了非空和默认	可以，但对主键无效</p>
<p>列级约束可以在一个字段上追加多个，中间用空格隔开，没有顺序要求</p>
<p>三、修改表时添加或删除约束<br />
1、非空<br />
添加非空<br />
alter table 表名 modify column 字段名 字段类型 not null;<br />
删除非空<br />
alter table 表名 modify column 字段名 字段类型 ;</p>
<p>2、默认<br />
添加默认<br />
alter table 表名 modify column 字段名 字段类型 default 值;<br />
删除默认<br />
alter table 表名 modify column 字段名 字段类型 ;<br />
3、主键<br />
添加主键<br />
alter table 表名 add【 constraint 约束名】 primary key(字段名);<br />
删除主键<br />
alter table 表名 drop primary key;</p>
<p>4、唯一<br />
添加唯一<br />
alter table 表名 add【 constraint 约束名】 unique(字段名);<br />
删除唯一<br />
alter table 表名 drop index 索引名;<br />
5、外键<br />
添加外键<br />
alter table 表名 add【 constraint 约束名】 foreign key(字段名) references 主表（被引用列）;<br />
删除外键<br />
alter table 表名 drop foreign key 约束名;</p>
<p>四、自增长列<br />
特点：<br />
1、不用手动插入值，可以自动提供序列值，默认从1开始，步长为1<br />
auto_increment_increment<br />
如果要更改起始值：手动插入值<br />
如果要更改步长：更改系统变量<br />
set auto_increment_increment=值;<br />
2、一个表至多有一个自增长列<br />
3、自增长列只能支持数值型<br />
4、自增长列必须为一个key</p>
<p>一、创建表时设置自增长列<br />
create table 表(<br />
字段名 字段类型 约束 auto_increment<br />
)<br />
二、修改表时设置自增长列<br />
alter table 表 modify column 字段名 字段类型 约束 auto_increment<br />
三、删除自增长列<br />
alter table 表 modify column 字段名 字段类型 约束</p>
<h1 id="tcl语言"><a class="markdownIt-Anchor" href="#tcl语言"></a> TCL语言</h1>
<p>一、含义<br />
事务：一条或多条sql语句组成一个执行单位，一组sql语句要么都执行要么都不执行<br />
二、特点（ACID）<br />
A 原子性：一个事务是不可再分割的整体，要么都执行要么都不执行<br />
C 一致性：一个事务可以使数据从一个一致状态切换到另外一个一致的状态<br />
I 隔离性：一个事务不受其他事务的干扰，多个事务互相隔离的<br />
D 持久性：一个事务一旦提交了，则永久的持久化到本地</p>
<p>三、事务的使用步骤 ★<br />
了解：<br />
隐式（自动）事务：没有明显的开启和结束，本身就是一条事务可以自动提交，比如insert、update、delete<br />
显式事务：具有明显的开启和结束</p>
<p>使用显式事务：<br />
①开启事务<br />
set autocommit=0;<br />
start transaction;#可以省略</p>
<p>②编写一组逻辑sql语句<br />
注意：sql语句支持的是insert、update、delete</p>
<p>设置回滚点：<br />
savepoint 回滚点名;</p>
<p>③结束事务<br />
提交：commit;<br />
回滚：rollback;<br />
回滚到指定的地方：rollback to 回滚点名;<br />
四、并发事务<br />
1、事务的并发问题是如何发生的？<br />
多个事务 同时 操作 同一个数据库的相同数据时<br />
2、并发问题都有哪些？<br />
脏读：一个事务读取了其他事务还没有提交的数据，读到的是其他事务“更新”的数据<br />
不可重复读：一个事务多次读取，结果不一样<br />
幻读：一个事务读取了其他事务还没有提交的数据，只是读到的是 其他事务“插入”的数据<br />
3、如何解决并发问题<br />
通过设置隔离级别来解决并发问题<br />
4、隔离级别<br />
脏读		不可重复读		幻读<br />
read uncommitted:读未提交     ×                ×              ×<br />
read committed：读已提交      √                ×              ×<br />
repeatable read：可重复读     √                √              ×<br />
serializable：串行化          √                √              √</p>
<h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1>
<h2 id="视图"><a class="markdownIt-Anchor" href="#视图"></a> 视图</h2>
<p>一、含义<br />
mysql5.1版本出现的新特性，本身是一个虚拟表，它的数据来自于表，通过执行时动态生成。<br />
好处：<br />
1、简化sql语句<br />
2、提高了sql的重用性<br />
3、保护基表的数据，提高了安全性<br />
二、创建<br />
create view 视图名<br />
as<br />
查询语句;</p>
<p>三、修改<br />
方式一：<br />
create or replace view 视图名<br />
as<br />
查询语句;<br />
方式二：<br />
alter view 视图名<br />
as<br />
查询语句</p>
<p>四、删除<br />
drop view 视图1，视图2,…;<br />
五、查看<br />
desc 视图名;<br />
show create view 视图名;<br />
六、使用<br />
1.插入<br />
insert<br />
2.修改<br />
update<br />
3.删除<br />
delete<br />
4.查看<br />
select<br />
注意：视图一般用于查询的，而不是更新的，所以具备以下特点的视图都不允许更新<br />
①包含分组函数、group by、distinct、having、union、<br />
②join<br />
③常量视图<br />
④where后的子查询用到了from中的表<br />
⑤用到了不可更新的视图</p>
<p>七、视图和表的对比<br />
关键字		是否占用物理空间			使用<br />
视图	view		占用较小，只保存sql逻辑		一般用于查询<br />
表		table		保存实际的数据			增删改查</p>
<h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2>
<p>分类<br />
一、系统变量<br />
说明：变量由系统提供的，不用自定义<br />
语法：<br />
①查看系统变量<br />
show 【global|session 】variables like ‘’; 如果没有显式声明global还是session，则默认是session<br />
②查看指定的系统变量的值<br />
select @@【global|session】.变量名; 如果没有显式声明global还是session，则默认是session<br />
③为系统变量赋值<br />
方式一：<br />
set 【global|session 】 变量名=值; 如果没有显式声明global还是session，则默认是session<br />
方式二：<br />
set @@global.变量名=值;<br />
set @@变量名=值；</p>
<p>1、全局变量<br />
服务器层面上的，必须拥有super权限才能为系统变量赋值，作用域为整个服务器，也就是针对于所有连接（会话）有效</p>
<p>2、会话变量<br />
服务器为每一个连接的客户端都提供了系统变量，作用域为当前的连接（会话）</p>
<p>二、自定义变量<br />
说明：<br />
1、用户变量<br />
作用域：针对于当前连接（会话）生效<br />
位置：begin end里面，也可以放在外面<br />
使用：</p>
<p>①声明并赋值：<br />
set @变量名=值;或<br />
set @变量名:=值;或<br />
select @变量名:=值;</p>
<p>②更新值<br />
方式一：<br />
set @变量名=值;或<br />
set @变量名:=值;或<br />
select @变量名:=值;<br />
方式二：<br />
select xx into @变量名 from 表;</p>
<p>③使用<br />
select @变量名;</p>
<p>2、局部变量<br />
作用域：仅仅在定义它的begin end中有效<br />
位置：只能放在begin end中，而且只能放在第一句<br />
使用：<br />
①声明<br />
declare 变量名 类型 【default 值】;<br />
②赋值或更新<br />
方式一：<br />
set 变量名=值;或<br />
set 变量名:=值;或<br />
select @变量名:=值;<br />
方式二：<br />
select xx into 变量名 from 表;<br />
③使用<br />
select 变量名;</p>
<h2 id="存储过程和函数"><a class="markdownIt-Anchor" href="#存储过程和函数"></a> 存储过程和函数</h2>
<p>说明：都类似于java中的方法，将一组完成特定功能的逻辑语句包装起来，对外暴露名字<br />
好处：<br />
1、提高重用性<br />
2、sql语句简单<br />
3、减少了和数据库服务器连接的次数，提高了效率</p>
<h3 id="存储过程"><a class="markdownIt-Anchor" href="#存储过程"></a> 存储过程</h3>
<p>一、创建 ★<br />
create procedure 存储过程名(参数模式 参数名 参数类型)<br />
begin<br />
存储过程体<br />
end<br />
注意：<br />
1.参数模式：in、out、inout，其中in可以省略<br />
2.存储过程体的每一条sql语句都需要用分号结尾</p>
<p>二、调用<br />
call 存储过程名(实参列表)<br />
举例：<br />
调用in模式的参数：call sp1（‘值’）;<br />
调用out模式的参数：set @name; call sp1(@name);select @name;<br />
调用inout模式的参数：set @name=值; call sp1(@name); select @name;<br />
三、查看<br />
show create procedure 存储过程名;<br />
四、删除<br />
drop procedure 存储过程名;</p>
<h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3>
<p>一、创建<br />
create function 函数名(参数名 参数类型) returns  返回类型<br />
begin<br />
函数体<br />
end</p>
<p>注意：函数体中肯定需要有return语句<br />
二、调用<br />
select 函数名(实参列表);<br />
三、查看<br />
show create function 函数名;<br />
四、删除<br />
drop function 函数名；</p>
<h2 id="流程控制结构"><a class="markdownIt-Anchor" href="#流程控制结构"></a> 流程控制结构</h2>
<p>说明：<br />
顺序结构：程序从上往下依次执行<br />
分支结构：程序按条件进行选择执行，从两条或多条路径中选择一条执行<br />
循环结构：程序满足一定条件下，重复执行一组语句</p>
<h3 id="分支结构"><a class="markdownIt-Anchor" href="#分支结构"></a> 分支结构</h3>
<p>特点：<br />
1、if函数<br />
功能：实现简单双分支<br />
语法：<br />
if(条件，值1，值2)<br />
位置：<br />
可以作为表达式放在任何位置<br />
2、case结构<br />
功能：实现多分支<br />
语法1：<br />
case 表达式或字段<br />
when 值1 then 语句1;<br />
when 值2 then 语句2；<br />
…<br />
else 语句n;<br />
end [case];</p>
<p>语法2：<br />
case<br />
when 条件1 then 语句1;<br />
when 条件2 then 语句2；<br />
…<br />
else 语句n;<br />
end [case];</p>
<p>位置：<br />
可以放在任何位置，<br />
如果放在begin end 外面，作为表达式结合着其他语句使用<br />
如果放在begin end 里面，一般作为独立的语句使用<br />
3、if结构<br />
功能：实现多分支<br />
语法：<br />
if 条件1 then 语句1;<br />
elseif 条件2 then 语句2;<br />
…<br />
else 语句n;<br />
end if;<br />
位置：<br />
只能放在begin end中</p>
<h3 id="循环结构"><a class="markdownIt-Anchor" href="#循环结构"></a> 循环结构</h3>
<p>位置：<br />
只能放在begin end中</p>
<p>特点：都能实现循环结构</p>
<p>对比：</p>
<p>①这三种循环都可以省略名称，但如果循环中添加了循环控制语句（leave或iterate）则必须添加名称<br />
②<br />
loop 一般用于实现简单的死循环<br />
while 先判断后执行<br />
repeat 先执行后判断，无条件至少执行一次</p>
<p>1、while<br />
语法：<br />
【名称:】while 循环条件 do<br />
循环体<br />
end while 【名称】;<br />
2、loop<br />
语法：<br />
【名称：】loop<br />
循环体<br />
end loop 【名称】;</p>
<p>3、repeat<br />
语法：<br />
【名称:】repeat<br />
循环体<br />
until 结束条件<br />
end repeat 【名称】;</p>
<p>二、循环控制语句<br />
leave：类似于break，用于跳出所在的循环<br />
iterate：类似于continue，用于结束本次循环，继续下一次</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-DB3" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/DB3/"
    >DB3</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/DB3/" class="article-date">
  <time datetime="2020-03-30T03:41:31.616Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <img src="/DB3_img/1.png" style="zoom:80%">
<img src="/DB3_img/2.png" style="zoom:80%">
<img src="/DB3_img/3.png" style="zoom:80%">
<img src="/DB3_img/4.png" style="zoom:80%">
<img src="/DB3_img/5.png" style="zoom:80%">
<h1 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h1>
<h2 id="索引分类"><a class="markdownIt-Anchor" href="#索引分类"></a> 索引分类</h2>
<ol>
<li>
<p>普通索引：索引表的Search-key项中的<strong>每一索引值对应全部取该值的基本表中的记录</strong>。普通索引通过索引<br />
表的指针项指向一个单链表来实现，该链表的每个结点的数<br />
据项指向一条物理记录。</p>
</li>
<li>
<p>单一索引：<strong>每一个索引值只对应唯一的数据记录</strong>。当建立单一索引后，索引项不可以再插入已有值，但可<br />
以插入多个空值，这等同于在建表时对索引列增加一个<br />
UNIQUE约束；同样，当建立单一索引时，如果待索引项存<br />
在相同值则不能建立。</p>
</li>
<li>
<p>聚簇索引：**索引项顺序与表中数据记录的物理顺序一致。**即基本表是按照索引表的Search-key项的排列次序<br />
组织存储的，因此，一个基本表只能建立一个聚簇索引。<br />
注：聚簇索引适应于很少对基本表进行增删操作和对变长列<br />
进行修改操作的情况(?)。</p>
</li>
</ol>
<img src="/DB3_img/6.png" style="zoom:80%">
<img src="/DB3_img/7.png" style="zoom:80%">
<img src="/DB3_img/8.png" style="zoom:80%">
<img src="/DB3_img/9.png" style="zoom:80%">
<img src="/DB3_img/10.png" style="zoom:80%">
<img src="/DB3_img/11.png" style="zoom:80%">
<img src="/DB3_img/12.png" style="zoom:80%">
<img src="/DB3_img/13.png" style="zoom:80%">
<img src="/DB3_img/14.png" style="zoom:80%">
<img src="/DB3_img/15.png" style="zoom:80%">
<img src="/DB3_img/16.png" style="zoom:80%">
<img src="/DB3_img/17.png" style="zoom:80%">
<img src="/DB3_img/18.png" style="zoom:80%">
<img src="/DB3_img/19.png" style="zoom:80%">
<img src="/DB3_img/20.png" style="zoom:80%">
<img src="/DB3_img/21.png" style="zoom:80%">
<img src="/DB3_img/22.png" style="zoom:80%">
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-DB6" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/DB6/"
    >DB6</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/DB6/" class="article-date">
  <time datetime="2020-03-30T03:41:31.616Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="关系模式设计引论"><a class="markdownIt-Anchor" href="#关系模式设计引论"></a> 关系模式设计引论</h1>
<h2 id="关系的外延和内涵"><a class="markdownIt-Anchor" href="#关系的外延和内涵"></a> 关系的外延和内涵</h2>
<ol>
<li>外延：关系模型的值，即关系模型中的数据，是动态的。</li>
<li>内涵：对关系、属性、域的定义和说明，即关系模型的定义。</li>
</ol>
<img src="/DB6_img/1.png" style="zoom:1%">
<h2 id="关系模式的存储异常"><a class="markdownIt-Anchor" href="#关系模式的存储异常"></a> 关系模式的存储异常</h2>
<p>例：描述学校的数据库有如下属性：<br />
学生的学号(Sno)、所在系(Sdept)、系主任姓名(Mname)、课<br />
程名(Cname)、成绩(Grade)<br />
关系模式 ：Student ( Sno, Sdept, Mname, Cname, Grade )</p>
<ol>
<li><strong>问题</strong>：
<ol>
<li>数据冗余太大：每行中系主任的姓名重复出现。</li>
<li>更新异常：假如某系更换主任后，系统必须修改所有与该系相关的学生。</li>
<li>插入异常：对于新成立的系中没有学生，也无法把主任存入。</li>
<li>删除异常：如果某个系学生全部毕业了，删除学生的同时，该系主任也没了。</li>
</ol>
</li>
<li><strong>原因</strong> 由于各属性见存在某些依赖关系</li>
<li><strong>解决</strong> 通过模式分解，分解为两个关系模式Student ( Sno, Sdept,<br />
Cname, Grade )和 Dept ( Sdept, Mname ) 。</li>
</ol>
<h1 id="规范化函数依赖"><a class="markdownIt-Anchor" href="#规范化函数依赖"></a> 规范化（函数依赖)</h1>
<h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2>
<ol>
<li>
<p>函数依赖（简称FD）<br />
设R(U)是一个属性集U上的关系模式，X和Y是U的<br />
子集。若对于R(U)的任意一个可能的关系r，r中不可能<br />
存在两个元组在X上的属性值相等， 而在Y上的属性值<br />
不等， 则称 “X函数确定Y” 或 “Y函数依赖于X”，记<br />
作X→Y(读作X决定Y)。X称为这个函数依赖的决定因素<br />
(Determinant)。</p>
<p>说明：<br />
1. 函数依赖不是指关系模式R的某个或某些关系实例满足的约束条件，而是指R的所有关系实例均要满足的约束条件。<br />
2. 函数依赖是语义范畴的概念。只能根据数据的语义来确定函数依赖。</p>
</li>
<li>
<p><strong>几种特殊的函数依赖</strong>：在关系模式R(U)中，对于U的子集X和Y</p>
<ol>
<li>若X→Y，但Y X，则称X→Y是非平凡的函数依赖</li>
<li>若X→Y，但Y  X，则称X→Y是平凡的函数依赖</li>
<li>若X→Y，并且Y→X，则记为X←→Y。(X与Y相互决定)</li>
<li>若Y不函数依赖于X，则记为X→Y。</li>
</ol>
</li>
<li>
<p><strong>完全函数依赖</strong><br />
<img src="/DB6_img/2.png" style="zoom:1%"></p>
</li>
<li>
<p><strong>传递函数依赖</strong></p>
 <img src="/DB6_img/3.png" style="zoom:1%">
</li>
<li>
<p><strong>候选码</strong>：设K为关系模式R&lt;U, F&gt;中的属性或属性组。若K F<br />
U，则K称为R的一个候选码(Candidate Key)。若关系模<br />
式R有多个候选码，则选定其中的一个做为主码(Primary<br />
key)。候选码常常简称为码。</p>
<ol>
<li>具有决定性和最小性。</li>
<li>主属性：<strong>所有</strong>候选码中出现的属性。</li>
<li>非主属性：不出现在候选码中的属性</li>
<li>全码：由关系模式的所有属性构成的码</li>
</ol>
</li>
<li>
<p><strong>外码</strong>：关系模式 R 中属性或属性组X 并非R 的码，但 X 是<br />
另一个关系模式的码，则称 X 是R 的外部码(Foreign key),<br />
也称外码。</p>
</li>
</ol>
<h2 id="范式"><a class="markdownIt-Anchor" href="#范式"></a> 范式</h2>
<h3 id="一范式-保持列的原子性"><a class="markdownIt-Anchor" href="#一范式-保持列的原子性"></a> 一范式 保持列的原子性</h3>
<p>如果一个关系模式R的所有属性都是不可分的基本<br />
数据项，则称关系R为第一范式的关系模式(First Normal<br />
Form)，简称关系R属于一范式，记为：R∈1NF。</p>
<h3 id="二范式-非主属性都完全依赖于-r-的候选键"><a class="markdownIt-Anchor" href="#二范式-非主属性都完全依赖于-r-的候选键"></a> 二范式 非主属性都完全依赖于 R 的候选键</h3>
<p>若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于R的码，则R∈2NF。</p>
<h3 id="三范式-非主属性都不传递依赖于-r-的候选键"><a class="markdownIt-Anchor" href="#三范式-非主属性都不传递依赖于-r-的候选键"></a> 三范式 非主属性都不传递依赖于 R 的候选键</h3>
<p>属性不依赖于其它非主属性</p>
<p>主键和其他列有直接的联系</p>
<img src="/DB6_img/4.png" style="zoom:1%">
<ol>
<li>
<p>定理：满足三范式，则一定满足二范式。</p>
</li>
<li>
<p>证明</p>
 <img src="/DB6_img/5.png" style="zoom:1%">
</li>
</ol>
<h3 id="bcnf-每个属性都不传递依赖于-r-的候选键"><a class="markdownIt-Anchor" href="#bcnf-每个属性都不传递依赖于-r-的候选键"></a> BCNF 每个属性都不传递依赖于 R 的候选键</h3>
<p>所有函数依赖关系中，自变量皆含有一个及以上的候选键</p>
<ol>
<li>
<p>多值依赖：在关系模式R(X,Y,Z)的任一关系r中，如果存在元组t,s，使得t[X]=s[X]，就必然存在元组w,v∈r，使得w[X]=v[X]=t[X] (=s[X])，而 w[Y]=t[Y], w[Z]=s[Z]; v[Y]=s[Y], v[Z]=t[Z] (即交换t,s在Y上的分量构成的新元组必然在r中)，则称Y多值依赖于X，记为X→→Y。 这里，X、Y、Z是U的子集，且Z=U-X-Y。</p>
<p><strong>没有直接联系、但有间接的联系称为多值依赖的数据依赖。</strong></p>
<ol>
<li>类似于部分函数依赖，但是函数就是唯一确定的关系；多值依赖却不能唯一确定。</li>
<li>若X→→Y，而Z＝Ф，则称X→→Y为平凡的多值依赖，否则称X→→Y为非平凡的多值依赖。</li>
<li><strong>非平凡函数依赖，平凡多值依赖比较好</strong></li>
</ol>
</li>
<li>
<p>多值依赖的性质：</p>
 <img src="/DB6_img/6.png" style="zoom:1%">
 <img src="/DB6_img/7.png" style="zoom:1%">
</li>
<li>
<p>多值依赖 &amp; 函数依赖</p>
 <img src="/DB6_img/8.png" style="zoom:1%">
 <img src="/DB6_img/9.png" style="zoom:1%">
</li>
</ol>
<p><a href="%22https://blog.csdn.net/w2011212787/article/details/52351668%22">函数依赖与多值依赖</a></p>
<img src="/DB6_img/11.png" style="zoom:1%">
<ol start="4">
<li>BCNF</li>
</ol>
<p>不存在任何字段对任一候选关键字段的传递函数依赖</p>
<p>如果有不依赖于候选码的其他函数依赖，则不满足BCNF</p>
<img src="/DB6_img/21.png" style="zoom:1%">
<h3 id="四范式-完全的一一对应"><a class="markdownIt-Anchor" href="#四范式-完全的一一对应"></a> 四范式 完全的一一对应</h3>
<ol start="5">
<li>四范式是BCNF的子集</li>
</ol>
<img src="/DB6_img/10.png" style="zoom:1%">
<h1 id="公理系统"><a class="markdownIt-Anchor" href="#公理系统"></a> 公理系统</h1>
<h2 id="armstrong-公理系统"><a class="markdownIt-Anchor" href="#armstrong-公理系统"></a> Armstrong 公理系统</h2>
<ol>
<li>
<p>公理系统</p>
 <img src="/DB6_img/12.png" style="zoom:1%">
</li>
<li>
<p>定律</p>
<ol>
<li>自反律：X能决定他的子集</li>
<li>增广律：若X-&gt;Y,那么XZ-&gt;YZ</li>
<li>传递律：若X-&gt;Y,Y-&gt;Z，则X-&gt;Z</li>
</ol>
</li>
<li>
<p>推理规则</p>
<ol>
<li>合并规则：若X-&gt;Y,X-&gt;，则X-&gt;YZ</li>
<li>分解规则：若X-&gt;Y,Z是Y的子集，那么X-&gt;Z</li>
<li>伪传递规则：若X-&gt;Y,WY-&gt;Z,则WX-&gt;Z</li>
</ol>
</li>
<li>
<p>定理：X-&gt;A1A2…Ak成立的充分必要条件是X-&gt;Ai成立(i=1,2,…,k)</p>
</li>
</ol>
<h2 id="函数依赖集的闭包"><a class="markdownIt-Anchor" href="#函数依赖集的闭包"></a> 函数依赖集的闭包</h2>
<ol>
<li>定义：在关系模式R&lt;U，F&gt;中为F所逻辑蕴含的函数依<br />
赖的全体叫作 F的闭包(Closure)，记为F<sup>+</sup>。</li>
<li>F<sup>+</sup>的意义：包含了给定函数依赖集F(部分)所蕴含的属性集U上的全部函数依赖。但是依赖信息太多，难于利用。</li>
</ol>
<h2 id="属性集的闭包"><a class="markdownIt-Anchor" href="#属性集的闭包"></a> 属性集的闭包</h2>
<ol>
<li>
<p>定义：设F为属性集U上的一组函数依赖，X是U的子集， X关于<br />
函数依赖集F 的闭包(Closure of X under F ) X<sub>F</sub><sup>+</sup> ={ A |<br />
X→A能由F 根据Armstrong公理导出}。</p>
</li>
<li>
<p>X<sub>F</sub><sup>+</sup>的求法</p>
 <img src="/DB6_img/13.png" style="zoom:1%">
</li>
<li>
<p>定理1：设F为属性集U上的一组函数依赖，X，Y 是U的子集， X→Y能由F 根据Armstrong公理导出的充分必要条件是Y 是X<sub>F</sub><sup>+</sup>的子集。</p>
</li>
<li>
<p>定理2：Armstrong公理系统是有效的、完备的。</p>
</li>
</ol>
<h2 id="最小函数依赖集"><a class="markdownIt-Anchor" href="#最小函数依赖集"></a> 最小函数依赖集</h2>
<ol>
<li>
<p>定义：假设在关系模式R&lt;U, F&gt;上有两个函数依赖集F和 G。如果F＋=G+，则称<strong>F和G是等价的，或称F与G相互覆盖。</strong></p>
</li>
<li>
<p>定理：F<sup>+</sup>=G<sup>+</sup>，当且仅当F是G<sup>+</sup>的子集且G是F<sup>+</sup>的子集。</p>
</li>
<li>
<p>如果函数依赖集F满足下列条件，则称F为一个<strong>极小函数依赖集</strong>。亦称为最小依赖集或最小覆盖。</p>
<ol>
<li>F中任一函数依赖的右部仅含有一个属性；</li>
<li>F中不存在这样的函数依赖X→A，使得F与F－{X→A}等价；(去除多余的函数依赖)</li>
<li>F中不存在这样的函数依赖X→A，X有真子集Z使得 (F－{X→A} )∪{Z→A}与F等价。（去除左部的冗余属性）</li>
</ol>
</li>
<li>
<p>最小函数依赖集的求解算法</p>
 <img src="/DB6_img/14.png" style="zoom:1%">
</li>
<li>
<p>一个给定的函数依赖集F的最小函数集不是唯一的。</p>
</li>
</ol>
<h2 id="候选码求解算法"><a class="markdownIt-Anchor" href="#候选码求解算法"></a> 候选码求解算法</h2>
<ol>
<li>
<p>注意</p>
<ol>
<li>码是可以确定一个元组的所有信息的属性名或属性名组，差不多理解为主键，并且主键加其他任意属性名也是码。</li>
<li>候选码的真子集中不存在码。</li>
<li>主码就是主键的意思，主码是任意一个候选码，注意是任意的一个。而且主码也可能是一个属性名组。</li>
</ol>
</li>
<li>
<p>对于给定的关系模式R&lt;U, F&gt;，依照函数依赖集F将U中的属性分为以下四类：</p>
<ol>
<li><strong>L类属性</strong>: 在F中只出现在函数依赖的左部的属性；</li>
<li><strong>R类属性</strong>: 在F中只出现在函数依赖的右部的属性；</li>
<li><strong>LR类属性</strong>: 分别出现在F中的函数依赖左部和右部的属性；</li>
<li><strong>N类属性</strong>: 不在F中的函数依赖中出现的属性。</li>
</ol>
<p>有<strong>结论</strong></p>
<ol>
<li>L类属性和N类属性必包含于任何候选码中；</li>
<li>R类属性必不包含于任何候选码中；</li>
<li>LR类属性不能确定是否在候选码中。</li>
</ol>
</li>
<li>
<p>算法<br />
<img src="/DB6_img/15.png" style="zoom:1%"></p>
 <img src="/DB6_img/16.png" style="zoom:1%">
 <img src="/DB6_img/17.png" style="zoom:1%">
 <img src="/DB6_img/18.png" style="zoom:1%">
</li>
</ol>
<h1 id="模式分解"><a class="markdownIt-Anchor" href="#模式分解"></a> 模式分解</h1>
<ol>
<li>目的：未来更好的存储，在使用中通过自然连接还原为分解前的关系模式。</li>
</ol>
<h2 id="无损连接性"><a class="markdownIt-Anchor" href="#无损连接性"></a> 无损连接性</h2>
<p>要求自然连接后与原模式相同。</p>
<h3 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h3>
<p>就好像在模拟自然连接</p>
<p>过程见本。</p>
<h3 id="定理"><a class="markdownIt-Anchor" href="#定理"></a> 定理</h3>
<p>用于一分为二判定</p>
<ol>
<li>
<p>R分成R1和R2，具有无损连结性的充要条件是：U1∩U2-&gt;U1-U2属于F<sup>+</sup>或U1∩U2-&gt;U2-U1属于F<sup>+</sup>。</p>
</li>
<li>
<p>关系模式R&lt;U, D&gt;中，D为R中的函数依赖FD和多<br />
值依赖MVD的集合。则X→→Y成立的充要条件是R的<br />
分解ρ={ R1&lt;XY, F1&gt;，R2 &lt;XZ, F2&gt; }具有无损连接性，<br />
其中Z=U－X－Y。</p>
</li>
</ol>
<h2 id="函数依赖性"><a class="markdownIt-Anchor" href="#函数依赖性"></a> 函数依赖性</h2>
<p>若原函数依赖的闭包和分解后函数依赖的闭包的和相等，那么就保持函数依赖性。</p>
<p>例题见本。</p>
<h2 id="模式分解结论"><a class="markdownIt-Anchor" href="#模式分解结论"></a> 模式分解结论</h2>
<ol>
<li>无损连结性和函数依赖性互不包含，可能只能满足其中一个。</li>
<li>无损连结性分解能达到4NF</li>
<li>函数依赖性分解可达到3NF，未必达到BCNF</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-DB7" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/DB7/"
    >DB7</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/DB7/" class="article-date">
  <time datetime="2020-03-30T03:41:31.616Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="数据库的设计方法"><a class="markdownIt-Anchor" href="#数据库的设计方法"></a> 数据库的设计方法</h1>
<ol>
<li>新奥尔良法:将数据库设计分为四个阶段：需求分析、概念设计、逻辑设计和物理设计。</li>
<li>基于ER模型的设计方法：使用ER模型来设计数据库的概念模型。</li>
<li>3NF的设计方法：用关系数据理论指导逻辑模型的设计。</li>
<li>ODL方法：用面向对象的概念和属于来说明数据库结构。</li>
</ol>
<h2 id="数据库设计中的各级模式"><a class="markdownIt-Anchor" href="#数据库设计中的各级模式"></a> 数据库设计中的各级模式</h2>
<img src="/DB7_img/1.png">
<h1 id="需求分析"><a class="markdownIt-Anchor" href="#需求分析"></a> 需求分析</h1>
<p>需求分析的重点是调查、收集与分析用户在数据管理中的信息要求、处理要求、安全性与完整性要求。</p>
<h2 id="需求信息的收集"><a class="markdownIt-Anchor" href="#需求信息的收集"></a> 需求信息的收集</h2>
<p>即了解用户的组织机构设置、主要业务活动和职能及对新系统的要求。</p>
<h2 id="需求信息的分析"><a class="markdownIt-Anchor" href="#需求信息的分析"></a> 需求信息的分析</h2>
<p>步骤</p>
<h3 id="确定系统边界"><a class="markdownIt-Anchor" href="#确定系统边界"></a> 确定系统边界</h3>
<h3 id="业务流程分析"><a class="markdownIt-Anchor" href="#业务流程分析"></a> 业务流程分析</h3>
<p>使用数据流图</p>
<ol>
<li>
<p>表达方式</p>
<ol>
<li>圆圈：表示一次处理过程</li>
<li>有向线：表示数据流</li>
<li>双线段：表示存储的信息</li>
</ol>
 <img src="/DB7_img/2.png">
</li>
<li>
<p>分析方法</p>
<ol>
<li>自顶向下，逐层分解</li>
<li>先主干后分支</li>
</ol>
</li>
<li>
<p>建立<strong>数据字典</strong></p>
<ol>
<li>数据字典是各类数据描述的集合，通常以表格的形式详细地描述业务处理过程中用到的各类数据</li>
<li>数据字典的内容包括数据项、数据结构、数据流、数据存储、处理过程等五部分。</li>
<li>数据流：可以是数据项，也可以是数据结构，表示数据的来源和去向。</li>
<li>数据存储：xx表。包括数据存储名、说明、输入数据流、输出数据流、组成成份、数据量、存取方式、存取频度等。</li>
<li>处理过程：加工处理过程定义和说明。</li>
</ol>
</li>
</ol>
<h1 id="概念结构设计"><a class="markdownIt-Anchor" href="#概念结构设计"></a> 概念结构设计</h1>
<p>概念结构设计就是将现实事物以不依赖于任何数据模<br />
型的方式加以描述，目的在于以符号化的形式正确地反映<br />
现实事物及事物与事物间的联系。概念结构设计的内容就<br />
是建立概念模型。</p>
<h2 id="概念结构设计四种策略"><a class="markdownIt-Anchor" href="#概念结构设计四种策略"></a> 概念结构设计四种策略</h2>
<h3 id="自顶向下"><a class="markdownIt-Anchor" href="#自顶向下"></a> 自顶向下</h3>
<p>即首先定义全局概念结构的框架，然后逐步细化。</p>
<h3 id="自底向上"><a class="markdownIt-Anchor" href="#自底向上"></a> 自底向上</h3>
<p>即首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构。</p>
<h3 id="逐步扩张"><a class="markdownIt-Anchor" href="#逐步扩张"></a> 逐步扩张</h3>
<p>即首先确定核心业务的概念结构，然后以此为中心向外扩张，最终实现全局概念结构。</p>
<h3 id="混合策略"><a class="markdownIt-Anchor" href="#混合策略"></a> 混合策略</h3>
<p>即将自顶向下和自底向上两种策略结合使用，首先确定全局框架，划分为若干个局部概念模型，再采取自底向上的策略实现各局部概念模型，加以合并实现全局概念模型。</p>
<h2 id="抽象现实事物的三种方法"><a class="markdownIt-Anchor" href="#抽象现实事物的三种方法"></a> 抽象现实事物的三种方法</h2>
<p>分类；聚集；概括</p>
<h2 id="设计局部视图"><a class="markdownIt-Anchor" href="#设计局部视图"></a> 设计局部视图</h2>
<p>步骤</p>
<h3 id="选择局部应用"><a class="markdownIt-Anchor" href="#选择局部应用"></a> 选择局部应用</h3>
<h3 id="设计分e-r图"><a class="markdownIt-Anchor" href="#设计分e-r图"></a> 设计分E-R图</h3>
<h2 id="确定实体与属性的两条准则"><a class="markdownIt-Anchor" href="#确定实体与属性的两条准则"></a> 确定实体与属性的两条准则</h2>
<ol>
<li>属性是不可再分的数据项，属性不可以再有属性</li>
<li>属性不能与其他实体发生联系，联系只能存在于实体与<br />
实体之间</li>
<li>例如职工(职工号，姓名，年龄，职称)，其中的职称如果<br />
与工资、住房和福利挂勾(即有联系)，则应该单独作为<br />
实体，而职工与职称间构成联系</li>
</ol>
<h2 id="视图集成"><a class="markdownIt-Anchor" href="#视图集成"></a> 视图集成</h2>
<img src="/DB7_img/4.png">
<p>选择两个具有相同实体的E-R图，通过相同实体将两个ER图连结起来构成一个E-R图，然后再与其它E-R图连结直到将<br />
所有的局部E-R图全部连结成一个E-R图，称为全局E-R图</p>
<h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h3>
<ol>
<li>可以完整地描述企业的信息及其联系</li>
<li>另一方面在集成过程中可以解决冲突和消除冗余。</li>
</ol>
<h3 id="分e-r图之间的三类冲突"><a class="markdownIt-Anchor" href="#分e-r图之间的三类冲突"></a> 分E-R图之间的三类冲突</h3>
<ol>
<li>属性冲突</li>
<li>命名冲突</li>
<li>结构冲突：同一对象在某一分E-R图中被抽象为实体而在另一分E-R图中又被抽象为属性，需要统一。</li>
</ol>
<h3 id="冗余"><a class="markdownIt-Anchor" href="#冗余"></a> 冗余</h3>
<p>注意从一个实体到另一个实体存在多条路的情况，要检查能否消除冗余。</p>
<h1 id="逻辑结构设计"><a class="markdownIt-Anchor" href="#逻辑结构设计"></a> 逻辑结构设计</h1>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/8/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        John Doe
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>