<!DOCTYPE html>


<html lang="en" >


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Hexo
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

  <script type="text/javascript"
	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-滑动窗口最小问题" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%B0%8F%E9%97%AE%E9%A2%98/"
    >滑动窗口最小问题</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%B0%8F%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-03-30T02:15:00.623Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="p1886-滑动窗口最小问题"><a class="markdownIt-Anchor" href="#p1886-滑动窗口最小问题"></a> P1886 滑动窗口最小问题</h1>
<p>有一个长为 nnn 的序列 aaa，以及一个大小为 kkk 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。</p>
<p><img src="/%E8%AE%A1%E5%AE%89%E5%AF%BC_img/5.png" alt="" /></p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>窗口滑动的过程，相当于删除一个元素，再插入一个元素，同时获得最大值或者最小值。相当于一个<strong>优先级队列</strong>，可以使用set来模拟一个优先级队列实现,时间复杂度O((n-k)logk)，其中插入，删除，取极值都是logk,一共需要滑动n-k次。规模大时TLE。</li>
<li>使用<strong>单调队列</strong>：队列中元素顺序与输入相同，而元素的值是有序的。因为每个元素至多被删除依次，所以总的时间复杂度在O(n)。以单调增队列为例
<ol>
<li>如果当前正在扫描的元素比队列队尾元素大，那么直接插入。如果比队尾元素小，则将元素从<strong>队尾出队</strong>，直到队尾元素小于当前元素。</li>
<li>如果插入元素后，有的元素滑动到窗口外，则应该从<strong>队头出队</strong></li>
</ol>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="单调队列"><a class="markdownIt-Anchor" href="#单调队列"></a> 单调队列</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct monotone_queue &#123;</span><br><span class="line">	static const int maxn &#x3D; 1e6+5;</span><br><span class="line">	int n, k, a[maxn];</span><br><span class="line">	int q[maxn], head, tail, p[maxn];&#x2F;&#x2F;q是值的队列,q是编号的队列</span><br><span class="line"></span><br><span class="line">	void read_in() &#123;</span><br><span class="line">		scanf(&quot;%d %d&quot;, &amp;n, &amp;k);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void monotone_min() &#123;</span><br><span class="line">		int head &#x3D; 1;</span><br><span class="line">		int tail &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			while (head &lt;&#x3D; tail &amp;&amp; q[tail] &gt;&#x3D; a[i]) tail--;&#x2F;&#x2F;比当前元素大的全部从队尾出队</span><br><span class="line">			q[++tail] &#x3D; a[i];</span><br><span class="line">			p[tail] &#x3D; i;&#x2F;&#x2F;插入当前元素</span><br><span class="line">			while (p[head] &lt;&#x3D; i - k) head++;&#x2F;&#x2F;窗口外元素从队头出队</span><br><span class="line">			if (i &gt;&#x3D; k) printf(&quot;%d &quot;, q[head]);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void monotone_max() &#123;</span><br><span class="line">		int head &#x3D; 1;</span><br><span class="line">		int tail &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			while (head &lt;&#x3D; tail &amp;&amp; q[tail] &lt;&#x3D; a[i]) tail--;&#x2F;&#x2F;比当前元素小的全部从队尾出队</span><br><span class="line">			q[++tail] &#x3D; a[i];</span><br><span class="line">			p[tail] &#x3D; i;</span><br><span class="line">			while (p[head] &lt;&#x3D; i - k) head++;</span><br><span class="line">			if (i &gt;&#x3D; k) printf(&quot;%d &quot;, q[head]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">monotone_queue mq;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	mq.read_in();</span><br><span class="line">	mq.monotone_min();</span><br><span class="line">	mq.monotone_max();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模拟优先队列"><a class="markdownIt-Anchor" href="#模拟优先队列"></a> 模拟优先队列</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1e6 + 5;</span><br><span class="line"> </span><br><span class="line">set&lt;int, less&lt;int&gt; &gt; s;</span><br><span class="line">int big[maxn], small[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, k;</span><br><span class="line">	scanf(&quot;%d %d&quot;, &amp;n, &amp;k);</span><br><span class="line"></span><br><span class="line">	int a;</span><br><span class="line">	int p1 &#x3D; 0, p2 &#x3D; 0;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">		q.push(a);</span><br><span class="line">		s.insert(a);</span><br><span class="line">		if (q.size() &#x3D;&#x3D; k) &#123;</span><br><span class="line">			int tmp &#x3D; q.front(); q.pop();</span><br><span class="line">			small[p1++] &#x3D; *(s.begin());</span><br><span class="line">			big[p2++] &#x3D; *(s.rbegin());</span><br><span class="line">			s.erase(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; p1; i++)</span><br><span class="line">		printf(&quot;%d &quot;, small[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; p2; i++)</span><br><span class="line">		printf(&quot;%d &quot;, big[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-环形跑道" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E7%8E%AF%E5%BD%A2%E8%B7%91%E9%81%93/"
    >环形跑道</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E7%8E%AF%E5%BD%A2%E8%B7%91%E9%81%93/" class="article-date">
  <time datetime="2020-03-30T02:15:00.623Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-11093-环形跑道"><a class="markdownIt-Anchor" href="#uva-11093-环形跑道"></a> UVA 11093 环形跑道</h1>
<p>环形跑道上有n(1 &lt;= n &lt;= 100000)个加油站，编号为1~n。第i个加油站可以加油pi加仑。从加油站i开到下 一站需要qi加仑汽油。你可以选择一个加油站作为起点，起始油箱为空（但可以立即加油）。你的任务是选 择一个起点，使得可以走完一圈后回到起点。假定油箱中的油量没有上限。如果无解，输出Not possible，否则 输出可以作为起点的最小加油站编号。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>贪心法：从小编号加油站开始尝试，如果能转一圈，那么直接输出。否则，以油量不够的加油站的下一站为起点再进行尝试。</li>
<li>假设尝试从1号加油站开始走，到i号加油站加完油也到不了i+1号加油站。那么从2~i-1号加油站开始也肯定不能到，这是因为从1到2时，油箱中的油量c&gt;=0</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100000 + 5;</span><br><span class="line">int p[maxn], q[maxn];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">void solve();</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	int kase &#x3D; 0;</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Case %d: &quot;, ++kase);</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;p[i]);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;q[i]);</span><br><span class="line">		solve();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="solve-贪心过程"><a class="markdownIt-Anchor" href="#solve-贪心过程"></a> solve 贪心过程</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line"></span><br><span class="line">	int beg &#x3D; 0;&#x2F;&#x2F;beg为起点编号</span><br><span class="line"></span><br><span class="line">	int used[maxn]&#123;&#125;;</span><br><span class="line">	bool flag;</span><br><span class="line"></span><br><span class="line">	do</span><br><span class="line">	&#123;&#x2F;&#x2F;如果试图使用已经尝试过的起点，说明尝试了一圈了</span><br><span class="line"></span><br><span class="line">		while (beg &lt; n&amp;&amp;p[beg] &lt; q[beg]) &#123;&#x2F;&#x2F;掠过若干不可能的起点并标记</span><br><span class="line">			used[beg] &#x3D; 1;</span><br><span class="line">			beg++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		if (beg &gt;&#x3D; n) break;</span><br><span class="line">		int next &#x3D; beg;&#x2F;&#x2F;到下一站耗油量q[next]</span><br><span class="line">		used[beg] &#x3D; 1;</span><br><span class="line"></span><br><span class="line">		int c &#x3D; 0;</span><br><span class="line">		flag &#x3D; true;</span><br><span class="line">		int cnt &#x3D; 0;</span><br><span class="line">		do &#123;</span><br><span class="line">			c +&#x3D; p[next];	&#x2F;&#x2F;加油</span><br><span class="line">			if (c &lt; q[next]) &#123;&#x2F;&#x2F;开不到下一站</span><br><span class="line">				next++;</span><br><span class="line">				flag &#x3D; false;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			else c -&#x3D; q[next];</span><br><span class="line">			next &#x3D; (next + 1) % n;</span><br><span class="line">		&#125; while (next !&#x3D; beg);&#x2F;&#x2F;转一圈结束</span><br><span class="line"></span><br><span class="line">		if (!flag) &#123;</span><br><span class="line">			beg &#x3D; next;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">			break;</span><br><span class="line">	&#125; while (!used[beg]);</span><br><span class="line"></span><br><span class="line">	if (!flag)</span><br><span class="line">		printf(&quot;Not possible\n&quot;);</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;Possible from station %d\n&quot;, beg + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-集合栈计算机" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E9%9B%86%E5%90%88%E6%A0%88%E8%AE%A1%E7%AE%97%E6%9C%BA/"
    >集合栈计算机</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E9%9B%86%E5%90%88%E6%A0%88%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="article-date">
  <time datetime="2020-03-30T02:15:00.623Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva12096-集合栈计算机"><a class="markdownIt-Anchor" href="#uva12096-集合栈计算机"></a> uva12096 ※集合栈计算机※</h1>
<pre><code>Sample Input
2
9
PUSH
DUP
ADD
PUSH
ADD
DUP
ADD
DUP
UNION
5
PUSH
PUSH
ADD
PUSH
INTERSECT

Sample Output
0
0
1
0
1
1
2
***
0
0
1
0
0
</code></pre>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<ol>
<li>首先考虑集合的存储问题：由于有集合作为元素插入到另一个集合的情况，所以不能直接定义集合类型的栈。考虑将集合映射到值(map)，另用一个向量存集合本身。</li>
<li>按照题干输入输出判断操作即可。注意后三种操作可以合并简化代码</li>
</ol>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;iterator&gt;
#include&lt;algorithm&gt;
# define ALL(x) x.begin(),x.end()
# define INS(x) inserter(x,x.begin())
</code></pre>
<blockquote>
<p>INS(x)插入迭代器，插入而非覆盖<br />
<a href="https://blog.csdn.net/m0_37456764/article/details/83019250" target="_blank" rel="noopener">inserter</a>.</p>
</blockquote>
<pre><code>using namespace std;
typedef set&lt;int&gt; Set;
map&lt;Set, int&gt; id;//将每个集合对应一个编号，编号是在向量中的下标
vector&lt;Set&gt; Setcache;
int ID(Set x) {//既是插入又是查询！！
	if (id.count(x)) return id[x];//存在则返回id

	//不存在则添加
	Setcache.push_back(x);
	return id[x] = Setcache.size() - 1;
}
</code></pre>
<p>插入和查询合并简化代码</p>
<pre><code>int main() {
int n;

cin &gt;&gt; n;
while (n--) {
	int m;
	cin &gt;&gt; m;
	stack&lt;int&gt; s;
	while (m--) {
		string op;
		cin &gt;&gt; op;
		if (op[0] == 'P') s.push(ID(Set()));
		//空集入栈，注意此处空集的写法
		else if (op[0] == 'D') s.push(s.top());
		else {
			Set x1 = Setcache[s.top()]; s.pop();
			//不同直接用pop赋值，因为pop的返回值为void
			Set x2 = Setcache[s.top()]; s.pop();
			Set x;
			if (op[0] == 'U') set_union(ALL(x1), ALL(x2), INS(x));
			if (op[0] == 'I') set_intersection(ALL(x1), ALL(x2), INS(x));
			if (op[0] == 'A') { x = x2; x.insert(ID(x1)); }
			s.push(ID(x));
		}
		cout &lt;&lt; Setcache[s.top()].size() &lt;&lt; endl;
	}
	cout &lt;&lt; &quot;***&quot; &lt;&lt; endl;
}
}
</code></pre>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<ol>
<li>本题主要注重多种STL的结合使用，尤其是集合映射为整型的处理方式</li>
<li>记住题中交并集的函数，set_union(参数为5个迭代器),set_intersection(参数为5个迭代器);要配合两处define使用</li>
<li>注意模拟多种操作时提取相同部分简化代码，也降低出错的可能性和调试难度。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-黄金图形" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E9%BB%84%E9%87%91%E5%9B%BE%E5%BD%A2/"
    >黄金图形</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E9%BB%84%E9%87%91%E5%9B%BE%E5%BD%A2/" class="article-date">
  <time datetime="2020-03-30T02:15:00.623Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-225-黄金图形"><a class="markdownIt-Anchor" href="#uva-225-黄金图形"></a> UVA 225 黄金图形</h1>
<p>平面上有k个障碍点。 从(0,0)点出发，第一次走1个单位，第二次走2个单位，……， 第n次走n个单位，恰好回到(0,0)。 要求只能沿着东南西北方向走，且每次必须转弯90°（不能沿着同一个方向继续走，也不能后退）。 走出的图形可以自交，但不能经过障碍点，如图 7-25所示。每个转折点只能走一次。 输入n、k（1≤n≤20，0≤k≤50）和所有障碍点的坐标，输出所有满足要求的移动序列（用 news表示北、东、西、南），按照字典序从小到大排列，最后输出移动序列的总数。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>又要输出所有的路径，所以直观的想到用dfs。dfs中处理好可以移动的方向即可。</li>
<li>本题的特殊之处在于，障碍格可能出现负坐标。由于本题中最长边长n小于等于20，所以采用给(0,0)点以及障碍物点加一个比较大的值来消负号。我是假设n=20，那么一共也就能走1+2+…20/2=105，所以我加了一个120.</li>
<li>注意：卡了很久的原因主要是题干中要求最长边等于n，这条件不仅是限定搜索深度的。他还要求必须包含长度为n的边。</li>
<li>注意每个转折点只能走一次的条件。这个转折点是指每一步走完之后的终点。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<pre><code>#include&lt;bits/stdc++.h&gt;
# pragma warning(disable:4996)
FILE *fin = freopen(&quot;习题7-2in.txt&quot;, &quot;r&quot;, stdin);
FILE *fout = freopen(&quot;习题7-2out.txt&quot;, &quot;w&quot;, stdout);
using namespace std;
const int maxn = 20;
void dfs(int r, int c, int dir, int step);
int dx[] = { 1,0,0,-1 };//东北南西
int dy[] = { 0,1,-1,0 };
int cnt, n;
bool g[maxn * maxn + 1][maxn * maxn + 1];
char direction[] = { 'e','n','s','w' };
int path[maxn*maxn];
bool vis[maxn*maxn + 1][maxn*maxn+ 1];
int stax, stay;
int main() {
int T;
scanf(&quot;%d&quot;, &amp;T);
int k;
while (T--)
{
	int x, y;
	memset(g, 1, sizeof(g));
	memset(path, 0, sizeof(path));
	
	scanf(&quot;%d\n%d&quot;, &amp;n, &amp;k);
	vector&lt;int&gt; tmpx;
	vector&lt;int&gt; tmpy;
	stax = stay = 120;
	cnt = 0;
	while (k--)
	{
		scanf(&quot;%d %d&quot;, &amp;x, &amp;y);
		g[x + stax][y + stay] = 0;
	}

	for (int i = 0; i &lt; 4; i++) {
		memset(vis, 0, sizeof(vis));
		dfs(stax, stay, i, 1);


	}
	printf(&quot;Found %d golygon(s).\n\n&quot;, cnt);
}
}
void dfs(int r, int c, int dir, int step) {
path[step] = dir;
for (int i = 0; i &lt; step; i++) {
	r += dx[dir];
	c += dy[dir];
	if (!g[r][c] || r &lt; 0 || c &lt; 0 ) {
		return;
	}
}
if (vis[r][c]) return;
if (step &gt;= n) {
	if (r == (stax) &amp;&amp; c == (stay)) {
		for (int i = 1; i &lt;= step; i++)
			printf(&quot;%c&quot;, direction[path[i]]);
		printf(&quot;\n&quot;);
		cnt++;
	}
	return;
}

vis[r][c] = 1;
if (dir == 0 || dir == 3) {
	dfs(r, c, 1, step + 1);
	dfs(r, c, 2, step + 1);
}
else {
	dfs(r, c, 0, step + 1);
	dfs(r, c, 3, step + 1);
}
vis[r][c] = 0;
}</code></pre>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-二叉树的重建" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%87%8D%E5%BB%BA/"
    >二叉树的重建</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%87%8D%E5%BB%BA/" class="article-date">
  <time datetime="2020-03-30T02:15:00.607Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-536-二叉树的重建-先中造树"><a class="markdownIt-Anchor" href="#uva-536-二叉树的重建-先中造树"></a> UVA 536 二叉树的重建 (先中造树)</h1>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">   #include&lt;string&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;习题6-3in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;习题6-3out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   typedef struct node &#123;</span><br><span class="line">   	struct node *lchild, *rchild;</span><br><span class="line">   	char data;</span><br><span class="line">   &#125;node, *ptr;</span><br><span class="line">   ptr Create(char *pre, char *in, int n)</span><br><span class="line">   &#123;</span><br><span class="line">   	ptr s;</span><br><span class="line">   </span><br><span class="line">   	if (n &#x3D;&#x3D; 1)</span><br><span class="line">   	&#123;</span><br><span class="line">   		s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">   		s-&gt;data &#x3D; *pre;</span><br><span class="line">   		s-&gt;lchild &#x3D; s-&gt;rchild &#x3D; NULL;</span><br><span class="line">   		return s;</span><br><span class="line">   	&#125;</span><br><span class="line">   	char *p;</span><br><span class="line">   	for (p &#x3D; in; p &lt; in + n; p++)</span><br><span class="line">   		if (*p &#x3D;&#x3D; *pre) break;</span><br><span class="line">   	int k &#x3D; p - in;</span><br><span class="line">   	s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">   	s-&gt;data &#x3D; *p;</span><br><span class="line">   	s-&gt;lchild &#x3D; s-&gt;rchild &#x3D; NULL;</span><br><span class="line">   	if (k) s-&gt;lchild &#x3D; Create(pre + 1, in, k);</span><br><span class="line">   	if (n - k - 1) s-&gt;rchild &#x3D; Create(pre + k + 1, p + 1, n - k - 1);</span><br><span class="line">   	return s;</span><br><span class="line">   &#125;</span><br><span class="line">   int lastorder(ptr T)</span><br><span class="line">   &#123;</span><br><span class="line">   	if (!T) return 0;</span><br><span class="line">   	lastorder(T-&gt;lchild);</span><br><span class="line">   	lastorder(T-&gt;rchild);</span><br><span class="line">   	printf(&quot;%c&quot;, T-&gt;data);</span><br><span class="line">   	return 1;</span><br><span class="line">   &#125;</span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">   </span><br><span class="line">   	string pre, in;</span><br><span class="line">   	while (cin &gt;&gt; pre &gt;&gt; in) &#123;</span><br><span class="line">   		int n &#x3D; pre.length();</span><br><span class="line">   		ptr T &#x3D; Create(&amp;pre[0], &amp;in[0], n);</span><br><span class="line">   		lastorder(T);</span><br><span class="line">   		cout &lt;&lt; endl;</span><br><span class="line">   	&#125;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-分数拆分" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%88%86%E6%95%B0%E6%8B%86%E5%88%86/"
    >分数拆分</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%88%86%E6%95%B0%E6%8B%86%E5%88%86/" class="article-date">
  <time datetime="2020-03-30T02:15:00.607Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-10976-分数拆分"><a class="markdownIt-Anchor" href="#uva-10976-分数拆分"></a> UVA 10976 分数拆分</h1>
<p>输入正整数k，找到所有正整数x&gt;=y,使得1/k=1/x+1/y</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>枚举y，算x。x&gt;=y,1/x&lt;=1/y,则1/k-1/y=1/x&lt;=1/y，则y&lt;=2k</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 10000;</span><br><span class="line">int cnt, n;</span><br><span class="line">int ans[maxn][2];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int x, y;</span><br><span class="line">	int c;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">	cnt &#x3D; 0;</span><br><span class="line">	for (y &#x3D; n + 1; y &lt;&#x3D; 2 * n; y++) &#123;</span><br><span class="line">		if ((n*y % (y - n)))</span><br><span class="line">			continue;</span><br><span class="line">		x &#x3D; (n*y) &#x2F; (y - n);</span><br><span class="line"></span><br><span class="line">		ans[cnt][0] &#x3D; x;</span><br><span class="line">		ans[cnt][1] &#x3D; y;</span><br><span class="line">		cnt++;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;, cnt);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; cnt; i++)</span><br><span class="line">		printf(&quot;1&#x2F;%d &#x3D; 1&#x2F;%d + 1&#x2F;%d\n&quot;, n, ans[i][0], ans[i][1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-反片语" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%8F%8D%E7%89%87%E8%AF%AD/"
    >反片语</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%8F%8D%E7%89%87%E8%AF%AD/" class="article-date">
  <time datetime="2020-03-30T02:15:00.607Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uav156-反片语"><a class="markdownIt-Anchor" href="#uav156-反片语"></a> uav156 反片语</h1>
<p>输入一些单词，找出所有满足如下条件的单词：该单词不能通过字母重排，得到输入文本的另外一个单词。在判断是否满足条件时，字母不分大小写，但在输出时应保留输入中的大小写，按字典序进行排列(所有大写字母在所有小写字母的前面)</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<p>由于单词可以重拍，所有直接对各单词进行标准化，以便于使用map；map<br />
为&lt;string,int&gt;，其中值对应单词出现次数；使用向量word记录原单词，向量ans记录答案序列；</p>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<pre><code>#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
vector&lt;string&gt;word;
map&lt;string, int&gt; cnt;
string standard(const string &amp;in) {
string s = in;
for (int i = 0; i &lt; s.length(); i++) {
	s[i] = tolower(s[i]);
}
</code></pre>
<ol>
<li>此处书上是按上述方式给的，如果形参表写成const string s，之后直接操作s，并且返回s也没发现问题。</li>
<li>注意此处const的用法，编写该模块前如果认定了in仅作为输入，则加上const防止之后错误的操作。</li>
</ol>
<h1 id=""><a class="markdownIt-Anchor" href="#"></a> </h1>
<pre><code>sort(s.begin(), s.end());
return s;
}
int main() {
string s;
while (cin &gt;&gt; s) {
	if (s[0] == '# ')	break;
	word.push_back(s);
	string r = standard(s);
	if (!cnt.count(r)) cnt[r] = 0;
	cnt[r]++;
}
vector&lt;string&gt; ans;
for (int i = 0; i &lt; word.size(); i++) {
	if (cnt[standard(word[i])] == 1) ans.push_back(word[i]);
}
sort(ans.begin(), ans.end());

for (int i = 0; i &lt; ans.size(); i++) {
	cout &lt;&lt; ans[i] &lt;&lt; endl;
}
}
</code></pre>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<ol>
<li>本题主要是map的应用，想要用map，标准化的步骤是关键。</li>
<li>map提供了&quot;[]“运算符，map[键]=值，使得map可以像数组一样使用。事实上，map也成为&quot;关联数组”。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-和为0的4个值" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%92%8C%E4%B8%BA0%E7%9A%844%E4%B8%AA%E5%80%BC/"
    >和为0的4个值</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%92%8C%E4%B8%BA0%E7%9A%844%E4%B8%AA%E5%80%BC/" class="article-date">
  <time datetime="2020-03-30T02:15:00.607Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-1152-和为0的4个值"><a class="markdownIt-Anchor" href="#uva-1152-和为0的4个值"></a> UVA 1152 和为0的4个值</h1>
<p>给出四个集合，从每个集合中任取一个数，问有多少种方案使得四个数和为0</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>最直观的四重循环复杂度O(n<sup>4</sup>)不可能</li>
<li>三重循环计算第四个数，之后查找这个数。如果查找使用二分查找，那么复杂度也在O(n<sup>3</sup>nlogn)</li>
<li><strong>解决</strong> 首先枚举a,b，把所有a+b记录下来放到一个有序数组中，之后枚举c,d，查一查-c-d有多少种方法写成a+b的形式。两个步骤都是n<sup>2</sup>logn，总的也是n<sup>2</sup>logn</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 4000 + 5;</span><br><span class="line">int A[maxn];</span><br><span class="line">int B[maxn];</span><br><span class="line">int C[maxn];</span><br><span class="line">int D[maxn];</span><br><span class="line">int sum[maxn*maxn];</span><br><span class="line">int upper_bound(int x, int y, int v) &#123;</span><br><span class="line">int m;</span><br><span class="line">while (x&lt;y)</span><br><span class="line">&#123;</span><br><span class="line">	m &#x3D; x + (y - x) &#x2F; 2;</span><br><span class="line">	if (sum[m] &lt;&#x3D; v) x &#x3D; m + 1;</span><br><span class="line">	else y &#x3D; m;</span><br><span class="line">&#125;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br><span class="line">int lower_bound(int x, int y, int v) &#123;</span><br><span class="line">int m;</span><br><span class="line">while (x&lt;y)</span><br><span class="line">&#123;</span><br><span class="line">	m &#x3D; x + (y - x) &#x2F; 2;</span><br><span class="line">	if (sum[m] &gt;&#x3D; v) y &#x3D; m;</span><br><span class="line">	else x &#x3D; m + 1;</span><br><span class="line">&#125;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int T;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">while (T--)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">		scanf(&quot;%d %d %d %d&quot;, &amp;A[i], &amp;B[i], &amp;C[i], &amp;D[i]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	int index &#x3D; 0;</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++) </span><br><span class="line">			sum[index++] &#x3D; A[i] + B[j];</span><br><span class="line">	sort(sum, sum + index);</span><br><span class="line">	long long  cnt &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++) </span><br><span class="line">			cnt +&#x3D; upper_bound(0, index, -C[i] - D[j]) - lower_bound(0, index, -C[i] - D[j]);</span><br><span class="line">	printf(&quot;%lld\n&quot;, cnt);</span><br><span class="line">	if (T) printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-古代象形符号" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%8F%A4%E4%BB%A3%E8%B1%A1%E5%BD%A2%E7%AC%A6%E5%8F%B7/"
    >古代象形符号</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%8F%A4%E4%BB%A3%E8%B1%A1%E5%BD%A2%E7%AC%A6%E5%8F%B7/" class="article-date">
  <time datetime="2020-03-30T02:15:00.607Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-1103-古代象形符号"><a class="markdownIt-Anchor" href="#uva-1103-古代象形符号"></a> uva 1103 古代象形符号</h1>
<p>描述： 为了理解早期文明，考古学家经常研究用古代语言编写的文本。在3000多年前的埃及使用的一种语言是基于称为象形文字的字符。如图显示了六个象形文字及其名称，在这个题目中，您需要编写一个程序来识别这六个字。 图c1<br />
输入描述： 输入由几个测试用例组成，每个测试用例描述一个包含一个或多个的图像 象形文字选自图C.1所示的那些。图像以一系列水平扫描线的形式给出，这些水平扫描线由黑色像素（由1表示）和白色像素（由0表示）组成。在输入数据中，每个扫描线以十六进制表示法编码。 例如，序列将表示八个像素10011100（一个黑色像素，后面是两个白色像素，依此类推） 十六进制表示法为9c。 在十六进制中仅使用数字和小写字母a到f 编码。每个测试用例的第一行包含两个整数，H和W.H（0 &lt;H≤200）是 图像中的扫描行数。 W（0 &lt;W≤50）是每个中十六进制字符的数量 线。 接下来的H行包含图像的十六进制字符，从上到下工作。 输入图像符合以下规则： •图像仅包含图C.1中所示的象形文字。 •每个图像至少包含一个有效的象形文字。 •图像中的每个黑色像素都是有效象形文字的一部分。 •每个象形文字由一组连接的黑色像素组成，每个黑色像素至少有一个顶部，底部，左侧或右侧的其他黑色像素。 •象形文字没有触及，另一个象形文字中没有象形文字。 •对角线接触的两个黑色像素将始终具有共同的触摸黑色像素。 •象形文字可能会扭曲，但每个都有一个在拓扑上等同于其中一个的形状 图C.1中的符号。 （如果每个都可以转换，两个数字在拓扑上是等价的 通过伸展而不撕裂进入另一个。） 最后一个测试用例后跟一行包含两个零的行。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<p>本题中的符号可以随意压缩拉伸，所以试图去直接描述其形状是不可取的。<br />
观察到每个符号的空白圈数不同，可以以此特征分辨</p>
<ol>
<li>注意：要先给这个图加上一圈白边，使得所有背景的白色部分可以连接起来。此处可以使用</li>
<li>所以总体来说要进行两次遍历</li>
<li>第一次将背景中的空白遍历</li>
<li>第二次去遍历黑圈，沿途遍历黑色周围未遍历的白色部分，对于每个黑色的连通分量，统计其周围遍历到的白色连通分量数，即白洞数。每次统计完的接完插入到一个向量中。</li>
<li>对向量排序，输出</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<pre><code>#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#include&lt;string.h&gt;
# pragma warning(disable:4996)
# define LOCAL
# ifdef LOCAL
FILE *fin = freopen(&quot;古代象形符号in.txt&quot;, &quot;r&quot;, stdin);
FILE *fout = freopen(&quot;古代象形符号out.txt&quot;, &quot;w&quot;, stdout);
# endif 
using namespace std;
vector&lt;string&gt; g;
int vis[205][205];
string b[] = { &quot;0000&quot;,&quot;0001&quot;,&quot;0010&quot;,&quot;0011&quot;,&quot;0100&quot;,&quot;0101&quot;,&quot;0110&quot;,&quot;0111&quot;,&quot;1000&quot;,&quot;1001&quot;,&quot;1010&quot;,&quot;1011&quot; ,&quot;1100&quot;,&quot;1101&quot;,&quot;1110&quot;,&quot;1111&quot; };
char c[] = { 'W','A','K','J','S','D' };
int dx[] = { -1,0,1,0 };
int dy[] = { 0,-1,0,1 };
struct Node {
	int x, y;
	Node(int x, int y) :x(x), y(y) {}
};
int H, W, cnt, num;
bool notOk(int a, int b) {
	return vis[a][b] || a &lt; 0 || a &gt;= g.size() || b &lt; 0 || b &gt;= g[a].size();
}
void dfs(Node u, char c) {
	vis[u.x][u.y] = 1;
	for (int i = 0; i &lt; 4; i++) {
		int a = u.x + dx[i];
		int b = u.y + dy[i];
		if (notOk(a, b)) continue;
		if (c == '1'&amp;&amp; g[a][b] == '0') {

			cnt++;
			dfs(Node(a, b), '0');
		}
		if (g[a][b] == c) dfs(Node(a, b), c);
	}
}

int main() {
	int kase = 0;
	while (cin &gt;&gt; H &gt;&gt; W &amp;&amp; H) {

		getchar();
		memset(vis, 0, sizeof(vis));
		g.clear();
		g.resize(H + 2);
		g.front() = string(W * 4 + 2, '0');//加一层白边
		for (int i = 1; i &lt;= H; ++i) {//读取输入
			g[i] = &quot;0&quot;;//加一层白边
			string s;
			getline(cin, s);
			for (char c : s)
			{
				if (isdigit(c)) g[i] += b[c - '0'];
				else g[i] += b[c - 'a' + 10];
			}
			g[i] += &quot;0&quot;;//加一层白边
		}
		g.back() = string(W * 4 + 2, '0');//加一层白边


		dfs(Node(0, 0), '0');

		string ans;
		for (int i = 1; i &lt; g.size(); i++) {
			for (int j = 1; j &lt; g[i].size(); j++) {
				if (!vis[i][j] &amp;&amp; g[i][j] == '1') {
					cnt = 0;
					dfs(Node(i, j), '1');
					ans += c[cnt];

				}


			}
		}

		cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++kase &lt;&lt; &quot;: &quot;;

		sort(ans.begin(), ans.end());

		cout &lt;&lt; ans &lt;&lt; endl;

	}

}
</code></pre>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<ol>
<li>注意DRY问题，本题中的dfs的写法非常值得学习</li>
<li>利用向量的直接赋值来添加百变，减少了时间复杂度</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-工人的请愿书" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%B7%A5%E4%BA%BA%E7%9A%84%E8%AF%B7%E6%84%BF%E4%B9%A6/"
    >工人的请愿书</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%B7%A5%E4%BA%BA%E7%9A%84%E8%AF%B7%E6%84%BF%E4%B9%A6/" class="article-date">
  <time datetime="2020-03-30T02:15:00.607Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-12186-工人的请愿书"><a class="markdownIt-Anchor" href="#uva-12186-工人的请愿书"></a> UVA 12186 工人的请愿书</h1>
<p>某公司里有一个老板和n（n≤10^5）个员工组成树状结构，除了老板之外每个员工都有唯 一的直属上司。老板的编号为0，员工编号为1～n。工人们（即没有直接下属的员工）打算 签署一项请愿书递给老板，但是不能跨级递，只能递给直属上司。当一个中级员工（不是工 人的员工）的直属下属中不小于T%的人签字时，他也会签字并且递给他的直属上司。问： 要让公司老板收到请愿书，至少需要多少个工人签字？</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>设d(i)表示让u给上级发信，至少需要多少个工人。</li>
<li>对于i，它至少需要 c = (k*T - 1) / 100 + 1; 个下属发信才行。所以把他的子节点从小到大排序，前c个的和即为d(i)的值</li>
<li>最终答案为d(0)</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="keyword">int</span> n, T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = g[u].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) &#123;</span><br><span class="line">		d.push_back(dp(v));</span><br><span class="line">	&#125;</span><br><span class="line">	sort(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">int</span> c = (k*T - <span class="number">1</span>) / <span class="number">100</span> + <span class="number">1</span>;  <span class="comment">//此处需要注意</span></span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c; i++)</span><br><span class="line">		ans += d[i];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;T)==<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; T == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) g[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">int</span> a;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">			g[a].push_back(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp(<span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/15/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/17/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        John Doe
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>