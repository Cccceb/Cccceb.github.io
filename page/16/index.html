<!DOCTYPE html>


<html lang="cn" >


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

  <script type="text/javascript"
	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/Bg.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/"></a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-网格动物" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E7%BD%91%E6%A0%BC%E5%8A%A8%E7%89%A9/"
    >网格动物</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E7%BD%91%E6%A0%BC%E5%8A%A8%E7%89%A9/" class="article-date">
  <time datetime="2020-03-30T02:15:00.701Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-1602-网格动物"><a class="markdownIt-Anchor" href="#uva-1602-网格动物"></a> UVA 1602 网格动物</h1>
<p>输入n,w,h(1&lt;=n&lt;=10,1&lt;=w,h&lt;=n).求能放在w*h网格里的不同的n连块的个数(平移,旋转,翻转算一种)</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>
<p>如果对于每次的输入计算结果，会超时，所以先打表。</p>
</li>
<li>
<p>题目问有多少种连通块，所以直观的想到不断的在格子周围扩展各自，然后判断是否重复，不重复则加入到集合中。</p>
</li>
<li>
<p>主要的数据结构为set(set(node))[maxn]，点的集合构成一种连通格，相同连通数的图构成i连通块的动物集合。i格连通的动物存在数组下标为i的集合中。使用点集来存图，一方面可以节省空间，另一方面便于实现平移旋转翻转</p>
</li>
<li>
<p>还需要实现平移，旋转，翻转</p>
<ol>
<li>平移：统一平移到原点</li>
<li>旋转：顺时针旋转90度，画个图就明白了</li>
<li>翻转：实现是关于x轴翻转</li>
</ol>
</li>
<li>
<p>打表：打表是一个迭代枚举的过程，后代是对前一代节点周围区域的扩展。由于normal的过程，所以不需要判断越界问题，即使出现负坐标，normal也会将他平移到原点。之后，在循环n,w,h将对应结果存在一个三维数组中即可。</p>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="打表"><a class="markdownIt-Anchor" href="#打表"></a> 打表</h2>
<pre><code>void get_ans() {
g start;
start.insert(node(0, 0));
animals[1].insert(start);
for (int i = 2; i &lt;= maxn; i++)
	for (set&lt;g&gt;::iterator j = animals[i - 1].begin(); j != animals[i - 1].end(); j++)
		for (g::iterator k = (*j).begin(); k != (*j).end(); k++) {
			int r = k-&gt;r, c = k-&gt;c;
			for (int w = 0; w &lt; 4; w++) {
				node nd(r + dx[w], c + dy[w]);
				if (!(*j).count(nd))
					insert(*j, nd);
			}
		}


for (int n = 1; n &lt;= maxn; n++)
	for (int w = 1; w &lt;= maxn; w++)
		for (int h = 1; h &lt;= maxn; h++) {
			int sum = 0;
			for (set&lt;g&gt;::iterator p = animals[n].begin(); p != animals[n].end(); p++) {
				int maxx = 0, maxy = 0;
				for (g::iterator q = (*p).begin(); q != (*p).end(); q++) {
					maxx = max(maxx, q-&gt;r);
					maxy = max(maxy, q-&gt;c);
				}
				if (max(maxx, maxy) &lt; max(w, h) &amp;&amp; min(maxx, maxy) &lt; min(w, h)) sum++;
			}
			ans[n][w][h] = sum;
		}
}
</code></pre>
<h2 id="判重及旋转平移翻转"><a class="markdownIt-Anchor" href="#判重及旋转平移翻转"></a> 判重及旋转,平移，翻转</h2>
<pre><code>g normal(const g&amp; p) {
int minx = p.begin()-&gt;r, miny = p.begin()-&gt;c;
for (g::iterator i = p.begin(); i != p.end(); i++) {
	minx = min(minx, i-&gt;r);
	miny = min(miny, i-&gt;c);
}
g p2;
for (g::iterator i = p.begin(); i != p.end(); i++)
	p2.insert(node(i-&gt;r - minx, i-&gt;c - miny));
return p2;
}
g turn(const g&amp;p) {
g p2;
for (g::iterator i = p.begin(); i != p.end(); i++)
	p2.insert(node(i-&gt;c, -i-&gt;r));
return normal(p2);
}
g filp(const g&amp;p) {
g p2;
for (g::iterator i = p.begin(); i != p.end(); i++)
	p2.insert(node(i-&gt;r, -i-&gt;c));
return normal(p2);
}
void insert(const g&amp; p, node nd) {
g p2 = p;
p2.insert(nd);
p2 = normal(p2);
int n = p2.size();

for (int i = 0; i &lt; 4; i++) {
	if (animals[n].count(p2)) return;
	p2 = turn(p2);
}
p2 = filp(p2);
for (int i = 0; i &lt; 4; i++) {
	if (animals[n].count(p2)) return;
	p2 = turn(p2);
}
animals[n].insert(p2);	
}
</code></pre>
<h2 id="主函数"><a class="markdownIt-Anchor" href="#主函数"></a> 主函数</h2>
<pre><code>struct node {
int r, c;
node(int r = 0, int c = 0) :r(r), c(c) {}
bool operator &lt; (const node &amp;a) const { return r &lt; a.r || r == a.r &amp;&amp; c &lt; a.c; }
};
typedef set&lt;node&gt; g;
const int maxn = 10;
int dx[] = { 1,-1,0,0 };
int dy[] = { 0,0,1,-1 };
g normal(const g&amp; p);
g turn(const g&amp; p);
g filp(const g&amp; p);
void insert(const g&amp; p, node nd);
int main()
{
int n, h, w;
get_ans();
while (cin &gt;&gt; n &gt;&gt; w &gt;&gt; h)
	cout &lt;&lt; ans[n][w][h] &lt;&lt; endl;
return 0;
}	</code></pre>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-数据库" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E6%95%B0%E6%8D%AE%E5%BA%93/"
    >数据库</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="article-date">
  <time datetime="2020-03-30T02:15:00.685Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-1592-数据库"><a class="markdownIt-Anchor" href="#uva-1592-数据库"></a> uva 1592 数据库</h1>
<p>输入一个n行m列的数据库，是否存在两个不同行r1，r2和两个不同列c1，c2，使得这两行和两列相同。（即（r1,c1）和（r2,c1）相同，（r1,c2）和（r2,c2）相同）</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>由于最终要判断是否相同，所以可以将字符串映射为一个值，以减少比较的时间</li>
<li>主循环中，在c1,c2下循环r，并将（r,c1）,(r,c2)存成一个二元组，将二元组映射为当前的行号，如果图中已存在这样的二元组，那么对应的值即为r2，当前行为r1。</li>
<li>由于有以二元组为键类型的图，所以结构体中要重写“&lt;”，否则会报错</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
map&lt;string, int&gt; location;
set&lt;string&gt; same;
vector&lt;int&gt; str[100000];
typedef struct point {
	int x;
	int y;
	point(int x, int y) :x(x), y(y) {}
	bool operator &lt; (const point&amp; r) const { return x &lt; r.x || x == r.x&amp;&amp;y &lt; r.y; }
}point;
</code></pre>
<p>※※注意此处重写“&lt;”的方法</p>
<pre><code>int main() {
int r, c;
while (scanf(&quot;%d%d&quot;, &amp;r, &amp;c) == 2) {
	getchar();
	same.clear();
	location.clear();
	for (int i = 0; i &lt; r; i++) str[i].clear();
	for (int i = 0; i &lt; r; i++) {
		for (int j = 0; j &lt; c; j++) {
			string s;
			char cs = getchar();
			while (cs != ','&amp;&amp;cs != '\n') {
				s += cs;
				cs = getchar();
			}
			if (!same.count(s)) {
				location[s] = i * r + j;
				same.insert(s);
			}
			str[i].push_back(location[s]);
		}
	}
</code></pre>
<p><strong>利用set和map，将每种字符串映射为唯一的值</strong></p>
<pre><code>	map&lt;point, int&gt; data;
	for (int c1 = 0; c1 &lt; c; c1++) {
		for (int c2 = c1 + 1; c2 &lt; c; c2++) {
			data.clear();
			for (int r1 = 0; r1 &lt; r; r1++) {
				int x = str[r1][c1];
				int y = str[r1][c2];
				point p(x, y);
				if (!data.count(p)) data[p] = r1;
				else {
					cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl &lt;&lt; data[p] + 1 &lt;&lt; &quot; &quot; &lt;&lt; r1 + 1 &lt;&lt; endl
						&lt;&lt; c1 + 1 &lt;&lt;&quot; &quot;&lt;&lt; c2 + 1 &lt;&lt; endl;
					goto here;
				}
			}
		}
	}
	cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
	here:;
}
}
</code></pre>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<ol>
<li>本题在循环前的映射与集合栈计算机类似，本题中目的是减少比较时的时间</li>
<li>本题应把两列最为一个整体，否则需要四重循环，会TEL</li>
<li>学习结构体初始化和重写操作符的方法。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-树" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E6%A0%91/"
    >树</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E6%A0%91/" class="article-date">
  <time datetime="2020-03-30T02:15:00.685Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-548-树"><a class="markdownIt-Anchor" href="#uva-548-树"></a> uva 548 树</h1>
<p> 输入一个二叉树的中序和后序遍历，请你输出一个叶子节点，该叶子节点到根的数值总和最小，且这个叶子是编号最小的那个。 输入： 您的程序将从输入文件中读取两行(直到文件结尾)。第一行是树的中序遍历值序列,第二行是树的后序遍历值序列。所有值将不同，大于零且小于或等于10000.二叉树的节1&lt;=N&lt;=10000。 输出： 对于每个树描述，您应该输出最小值路径的叶节点的值。存在多路径最小的情况下，您应该选择终端叶子节点上具有最小值的那条路径，且输出那个最小值的终端叶子。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>根据中序和后序序列构造二叉树</li>
<li>递归遍历二叉树，每一步走左右子树中权值较小的一个</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;sstream&gt;
# pragma warning(disable:4996)
# define LOCAL
# ifdef LOCAL
FILE *fin = freopen(&quot;树in.txt&quot;, &quot;r&quot;, stdin);
FILE *fout = freopen(&quot;树out.txt&quot;, &quot;w&quot;, stdout);
# endif 
using namespace std;
# define maxn 10000
int n = 0;
bool read(int *a) {
</code></pre>
<blockquote>
<p>数组为参数的时候可以用指针，传首地址</p>
</blockquote>
<pre><code>	string s;
	getline(cin, s);
	stringstream ss(s);
</code></pre>
<blockquote>
<p>注意此处，用ss来读取一行不定数量的以空格分隔的数字</p>
</blockquote>
<pre><code>	n = 0;
	int x;
	while (ss &gt;&gt; x) a[n++] = x;
	return n &gt; 0;
}

int post_order[maxn], in_order[maxn],lch[maxn],rch[maxn];
</code></pre>
<blockquote>
<p>其中rch[i]表示编号为i的节点的右孩子<br />
`<br />
int build(int l1, int r1, int l2, int r2) {<br />
if (l1 &gt; r1) return 0;//空树<br />
本题中以权值代表编号，为0表示节点不存在</p>
</blockquote>
<pre><code>	int root = post_order[r2];//后序序列的最后一个
	int p = l1;
	while (in_order[p] != root) p++;
	int cnt = p-l1;//左子树中节点个数
	

	//分别在左右子树中递归遍历
	lch[root] = build(l1, p - 1, l2 , l2 + cnt - 1);
	rch[root] = build(p + 1, r1, l2 + cnt, r2 - 1);
	return root;
}

int best, best_sum;
void dfs(int u, int sum) {
	sum += u;
	if (!lch[u] &amp;&amp; !rch[u]) {//如果u是叶子节点
		if (sum &lt; best_sum || (best_sum == sum &amp;&amp; u &lt; best)) 
		{
			best = u;
			best_sum = sum;
		}
	}

	if (lch[u]) dfs(lch[u], sum);
	if (rch[u]) dfs(rch[u], sum);

}
int main() {
	while (read(in_order)) {
		read(post_order);
		build(0, n - 1, 0, n - 1);
		best_sum = 1e9;//
		dfs(post_order[n - 1], 0);
		cout &lt;&lt; best &lt;&lt; endl;
	}
}
</code></pre>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<ol>
<li>
<p>输入也可以写成子函数的形式</p>
</li>
<li>
<p>学习中后造树和递归遍历二叉树的方法</p>
<pre><code> void dfs(树根指针){
 if(左子树为空（为0）&amp;&amp;右子树为空（为0）)
 	{
 						
 		return 0;
 	}
 if(左孩子不为空) dfs（左孩子）
 if(右孩子不为空) dfs（右孩子）
 }</code></pre>
</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-树的最大独立集" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86/"
    >树的最大独立集</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86/" class="article-date">
  <time datetime="2020-03-30T02:15:00.685Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="树的最大独立集"><a class="markdownIt-Anchor" href="#树的最大独立集"></a> 树的最大独立集</h1>
<p>对于一颗n个节点的无根树，选出尽可能多的节点，使得任何两个结点均不相邻，然后输入n-1条无向边，输出一个最大独立集(如果有多解，则任意输出一组)</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>以d(i)来表示以i为根节点的子树的最大独立集大小。由于本题是无向图，所以没有父子关系，可通过任选一个结点作为根节点使无根树变成有根树。</li>
<li>对于每个结点i，其决策包括选和不选。如果选i，那么不能选i的儿子，那么d(i) = 1+ d(孙子)；如果不选i，那么d(i) = d(儿子)。</li>
<li>这样就需要枚举结点i的所有子孙，很不方便。换一种思路，对每个点i，更新其父节点和祖父结点。这样对于每个结点只需记录其父节点即可，<strong>即刷表法</strong>。</li>
<li><strong>另一种实现见<a href="../Hail-Bula%E7%9A%84%E8%88%9E%E4%BC%9A/">Hail-Bula的舞会</a></strong></li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> s[maxn], gs[maxn], dp[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		dfs(v, u);</span><br><span class="line">		s[u] += dp[v];</span><br><span class="line">		<span class="keyword">if</span> (fa != <span class="number">-1</span>)</span><br><span class="line">			gs[fa] += dp[v];</span><br><span class="line">	&#125;</span><br><span class="line">	dp[u] = <span class="built_in">max</span>(<span class="number">1</span> + gs[u], s[u]);</span><br><span class="line">	<span class="keyword">return</span> dp[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">		g[a].push_back(b);</span><br><span class="line">		g[b].push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">		<span class="built_in">memset</span>(gs, <span class="number">0</span>, <span class="keyword">sizeof</span>(gs));</span><br><span class="line">		<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">		<span class="keyword">int</span> tmp = dfs(i, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> (tmp &gt; ans)</span><br><span class="line">			ans = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-素数环" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E7%B4%A0%E6%95%B0%E7%8E%AF/"
    >素数环</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E7%B4%A0%E6%95%B0%E7%8E%AF/" class="article-date">
  <time datetime="2020-03-30T02:15:00.685Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-524-素数环"><a class="markdownIt-Anchor" href="#uva-524-素数环"></a> UVA 524 素数环</h1>
<p>输入正整数n，把1，2，3，···，n组成一个环，使得相邻两个整数之和均为素数。输出时从整数1开始逆时针排列。同一个环应恰好输出一次。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>直观的考虑，答案应该是1-n的某种排列，但是16！太大了，如果生成排列再测试会导致超时。</li>
<li>因为前面能构成素数也未必能构成素数环，有点局部最优未必是整体最优的感觉。所以考虑回溯法，在当前位置处枚举没用过的数，判断能否与上一位构成素数。</li>
<li>加速：实现打印出素数表，后面直接判断。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="dfs-每一层都在寻找cur位置处能放的数别忘了回溯"><a class="markdownIt-Anchor" href="#dfs-每一层都在寻找cur位置处能放的数别忘了回溯"></a> dfs 每一层都在寻找cur位置处能放的数，别忘了回溯</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void dfs(int cur) &#123;</span><br><span class="line">if (cur &#x3D;&#x3D; n &amp;&amp; isp[A[0] + A[n - 1]]) &#123;</span><br><span class="line">	cout &lt;&lt; A[0];</span><br><span class="line">	for (int i &#x3D; 1; i &lt; n; i++) cout &lt;&lt; &quot; &quot; &lt;&lt; A[i];</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">	for (int j &#x3D; 2; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">		if (!vis[j] &amp;&amp; isp[j + A[cur - 1]]) &#123;</span><br><span class="line">			A[cur] &#x3D; j;</span><br><span class="line">			&#x2F;&#x2F;回溯法</span><br><span class="line">			vis[j] &#x3D; 1;</span><br><span class="line">			dfs(cur + 1);</span><br><span class="line">			vis[j] &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="is_prime-判断i是否是素数固定的"><a class="markdownIt-Anchor" href="#is_prime-判断i是否是素数固定的"></a> is_prime 判断i是否是素数，固定的</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int is_prime(int a) &#123;</span><br><span class="line">for (int i &#x3D; 2; i &lt; a; i++)</span><br><span class="line">	if (a%i &#x3D;&#x3D; 0) return 0;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int n, vis[1000000];</span><br><span class="line">int A[1000000];</span><br><span class="line">int isp[100000];</span><br><span class="line">int main() &#123;</span><br><span class="line">int kase &#x3D; 0;</span><br><span class="line">while (cin &gt;&gt; n) &#123;</span><br><span class="line">	if (kase) cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++kase &lt;&lt; &quot;:&quot; &lt;&lt; endl;</span><br><span class="line">	memset(isp, 0, 2 * n * sizeof(int));</span><br><span class="line">	memset(vis, 0, 2 * n * sizeof(int));</span><br><span class="line">	for (int i &#x3D; 2; i &lt;&#x3D; 2 * n; i++)</span><br><span class="line">		isp[i] &#x3D; is_prime(i);</span><br><span class="line">	isp[1] &#x3D; 1;&#x2F;&#x2F;先构造出素数表，以后方便</span><br><span class="line">	A[0] &#x3D; 1;&#x2F;&#x2F;题干要求从1开始逆序输出</span><br><span class="line">	dfs(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-缩点" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E7%BC%A9%E7%82%B9/"
    >缩点</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E7%BC%A9%E7%82%B9/" class="article-date">
  <time datetime="2020-03-30T02:15:00.685Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="缩点"><a class="markdownIt-Anchor" href="#缩点"></a> 缩点</h1>
<h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2>
<p>给定一个 n个点 m 条边有向图，每个点有一个权值，求一条路径，使路径经过的点权值之和最大。你只需要求出这个权值和。</p>
<p>允许多次经过一条边或者一个点，但是，重复经过的点，权值只计算一次。</p>
<h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2>
<p>第一行两个正整数 n,m</p>
<p>第二行 n 个整数，依次代表点权</p>
<p>第三至 m+2 行，每行两个整数 u,v*，表示一条 u-&gt;v 的有向边。</p>
<h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2>
<p>共一行，最大的点权之和。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>由于经过相同的点的权值只计算一次。一方面，在一个环中反复走没有意义。另一方面，一旦选定环中一个点，就应该选择所有的点。</li>
<li>使用Tarjan算法对原图进行缩点，将强连通分量中的点合并成一个。</li>
<li>之后使用dp求得最优解即可。实现时，还加入了拓扑排序，其实没屁用。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="tarjan"><a class="markdownIt-Anchor" href="#tarjan"></a> tarjan</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 10000 + 5;</span><br><span class="line">int dfn[maxn], instack[maxn], low[maxn],st[maxn];</span><br><span class="line">int Tree[maxn], indegree[maxn],dp[maxn];</span><br><span class="line">int w[maxn];</span><br><span class="line">int sum;</span><br><span class="line">int head[maxn],h[maxn];</span><br><span class="line">struct EDGE</span><br><span class="line">&#123;</span><br><span class="line">	int to; int next; int from;</span><br><span class="line">&#125;edge[maxn * 10], ed[maxn * 10];</span><br><span class="line">int n, m;</span><br><span class="line">int clk &#x3D; 0;</span><br><span class="line">int top;</span><br><span class="line">void tarjan(int u) &#123;</span><br><span class="line">	dfn[u] &#x3D; low[u] &#x3D; ++clk;</span><br><span class="line">	st[++top] &#x3D; u;</span><br><span class="line">	instack[u] &#x3D; 1;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; head[u]; i; i &#x3D; edge[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		int v &#x3D; edge[i].to;</span><br><span class="line">		if (!dfn[v]) &#123;</span><br><span class="line">			tarjan(v);</span><br><span class="line">			low[u] &#x3D; min(low[u], low[v]);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (instack[v])</span><br><span class="line">			low[u] &#x3D; min(low[u], dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	if (low[u] &#x3D;&#x3D; dfn[u]) &#123;</span><br><span class="line">		int tp;</span><br><span class="line">		while (tp &#x3D; st[top--])&#123;</span><br><span class="line">			Tree[tp] &#x3D; u;</span><br><span class="line">			instack[tp] &#x3D; 0;</span><br><span class="line">			if (tp &#x3D;&#x3D; u) break;</span><br><span class="line">			w[u] +&#x3D; w[tp];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dp过程"><a class="markdownIt-Anchor" href="#dp过程"></a> dp过程</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int topo()</span><br><span class="line">&#123;</span><br><span class="line">	queue &lt;int&gt; q;</span><br><span class="line">	int tot &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">		if (Tree[i] &#x3D;&#x3D; i &amp;&amp; !indegree[i])</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			q.push(i);</span><br><span class="line">			dp[i] &#x3D; w[i];</span><br><span class="line">		&#125;</span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		int k &#x3D; q.front(); q.pop();</span><br><span class="line">		for (int i &#x3D; h[k]; i; i &#x3D; ed[i].next)</span><br><span class="line">		&#123;</span><br><span class="line">			int v &#x3D; ed[i].to;</span><br><span class="line">			dp[v] &#x3D; max(dp[v], dp[k] + w[v]);</span><br><span class="line">			indegree[v]--;</span><br><span class="line">			if (indegree[v] &#x3D;&#x3D; 0) q.push(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">		ans &#x3D; max(ans, dp[i]);</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void add(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">	edge[++sum].next &#x3D; head[x];</span><br><span class="line">	edge[sum].from &#x3D; x;</span><br><span class="line">	edge[sum].to &#x3D; y;</span><br><span class="line">	head[x] &#x3D; sum;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">	int a, b;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;w[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">		add(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">		if (!dfn[i]) &#123;</span><br><span class="line">			tarjan(i);</span><br><span class="line">		&#125;</span><br><span class="line">	int s &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int x &#x3D; Tree[edge[i].from], y &#x3D; Tree[edge[i].to];</span><br><span class="line">		if (x !&#x3D; y)</span><br><span class="line">		&#123;</span><br><span class="line">			ed[++s].next &#x3D; h[x];</span><br><span class="line">			ed[s].to &#x3D; y;</span><br><span class="line">			ed[s].from &#x3D; x;</span><br><span class="line">			h[x] &#x3D; s;</span><br><span class="line">			indegree[y]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d&quot;, topo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重写的前向列表法"><a class="markdownIt-Anchor" href="#重写的前向列表法"></a> 重写的前向列表法</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000</span> + <span class="number">15</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line">Edge edge[maxn * <span class="number">10</span>], ed[maxn * <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], st[maxn], low[maxn], dfn[maxn], Tree[maxn], w[maxn], indegree[maxn];</span><br><span class="line"><span class="keyword">int</span> instack[maxn];</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>, clk = <span class="number">0</span>, top = <span class="number">0</span>, n, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	edge[++sum].next = head[a];</span><br><span class="line">	edge[sum].a = a;</span><br><span class="line">	edge[sum].b = b;</span><br><span class="line">	head[a] = sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	low[u] = dfn[u] = ++clk;</span><br><span class="line">	st[++top] = u;</span><br><span class="line">	instack[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = edge[i].next) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].b;</span><br><span class="line">		<span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">			tarjan(v);</span><br><span class="line">			low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (instack[v])</span><br><span class="line">			low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">		<span class="keyword">int</span> tp;</span><br><span class="line">		<span class="keyword">while</span> (tp = st[top--]) &#123;</span><br><span class="line">			Tree[tp] = u;</span><br><span class="line">			instack[tp] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (tp == u) <span class="keyword">break</span>;</span><br><span class="line">			w[u] += w[tp];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[maxn]&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (Tree[i] == i &amp;&amp; indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">			dp[i] = w[i];</span><br><span class="line">			q.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = edge[i].next) &#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].b;</span><br><span class="line">			dp[v] = <span class="built_in">max</span>(dp[v], dp[u] + w[v]);</span><br><span class="line">			indegree[v]--;</span><br><span class="line">			<span class="keyword">if</span> (indegree[v] == <span class="number">0</span>)</span><br><span class="line">				q.push(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (dp[i] &gt; ans)</span><br><span class="line">			ans = dp[i];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">		add_edge(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (!dfn[i])</span><br><span class="line">			tarjan(i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		ed[i] = edge[i];</span><br><span class="line">	<span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">	<span class="comment">//memset(edge, 0, sizeof(edge));</span></span><br><span class="line">	sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> ta = Tree[ed[i].a];</span><br><span class="line">		<span class="keyword">int</span> tb = Tree[ed[i].b];</span><br><span class="line">		<span class="keyword">if</span> (ta != tb) &#123;</span><br><span class="line">			add_edge(ta, tb);</span><br><span class="line">			indegree[tb]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, topo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-切木棍" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%88%87%E6%9C%A8%E6%A3%8D/"
    >切木棍</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%88%87%E6%9C%A8%E6%A3%8D/" class="article-date">
  <time datetime="2020-03-30T02:15:00.670Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-10003-切木棍"><a class="markdownIt-Anchor" href="#uva-10003-切木棍"></a> UVA 10003 切木棍</h1>
<p>有一根长度为L（L＜1000）的棍子，还有n（n＜50）个切割点的位置（按照从小到大排 列）。你的任务是在这些切割点的位置处把棍子切成n＋1部分，使得总切割费用最小。每次 切割的费用等于被切割的木棍长度。例如，L=10，切割点为2, 4, 7。如果按照2, 4, 7的顺序， 费用为10＋8＋6=24，如果按照4, 2, 7的顺序，费用为10＋4＋6=20。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>设d(i,j)为切割小木棍i~j的最优费用，则d(i,j) = min(d(i,k)+d(k,j)|i&lt;k&lt;j)+a[j]-a[i],其中a[j] -a[i]为第一刀的费用</li>
<li>注意这种递归写法，与UVA的巴比伦塔有类似之处</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="dp-注意初值"><a class="markdownIt-Anchor" href="#dp-注意初值"></a> dp 注意初值</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 50 + 5;</span><br><span class="line">int vis[maxn][maxn];</span><br><span class="line">int d[maxn][maxn];</span><br><span class="line">int a[maxn];</span><br><span class="line"></span><br><span class="line">int dp(int i, int j) &#123;</span><br><span class="line">	if (i &gt;&#x3D; j - 1) return 0;</span><br><span class="line">	if (vis[i][j]) return d[i][j];</span><br><span class="line">	vis[i][j] &#x3D; 1;</span><br><span class="line">	int &amp;ans &#x3D; d[i][j];</span><br><span class="line">	ans &#x3D; -1;</span><br><span class="line">	for (int k &#x3D; i + 1; k &lt;&#x3D; j - 1; k++) &#123;</span><br><span class="line">		int v &#x3D; dp(i, k) + dp(k,j) + a[j] - a[i];</span><br><span class="line">		if (ans&lt;0 || ans&gt;v) ans &#x3D; v;</span><br><span class="line">	&#125;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	int L, n;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;L, &amp;n) &#x3D;&#x3D; 2 &amp;&amp; L) &#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">		a[0] &#x3D; 0; a[n + 1] &#x3D; L;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		printf(&quot;The minimum cutting is %d.\n&quot;, dp(0, n + 1));</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-切断圆环链" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%88%87%E6%96%AD%E5%9C%86%E7%8E%AF%E9%93%BE/"
    >切断圆环链</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%88%87%E6%96%AD%E5%9C%86%E7%8E%AF%E9%93%BE/" class="article-date">
  <time datetime="2020-03-30T02:15:00.670Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-818-切断圆环链"><a class="markdownIt-Anchor" href="#uva-818-切断圆环链"></a> UVA 818 切断圆环链</h1>
<p>现在有n个圆环 ，其中可能有些已经连接在一起 现在你想拆开一些圆环与其他圆环连接，使得最后所有圆环都在一条串上 问至少需要拆开几个圆环 (n≤15)</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>应该抽象为图的问题，要解决连通性的问题。</li>
<li>首先，把所有环打开后再扣上一定可以形成一条链。所以不存在无解的情况。</li>
<li></li>
</ol>
<p>然后，我们发现n≤15，所以我们可以用二进制表示这n个环是否被打开。</p>
<ol start="4">
<li>
<p>我们可以遍历所有状态。判断这个状态是否合法即可。如何判断状态合法？我们发现只要一个状态满足一下三条条件就合法。</p>
<ol>
<li>
<p>不能有环</p>
</li>
<li>
<p>一个节点不能有3个及其以上的儿子。即：每个点的度数需要≤2</p>
</li>
<li>
<p>由于每个打开的环只能连接两个未打开的环（即两个连通分量），所以联通分量的个数必须≤要打开的环的个数＋1。</p>
</li>
</ol>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="have_cycle-判断有无环使用递归"><a class="markdownIt-Anchor" href="#have_cycle-判断有无环使用递归"></a> have_cycle 判断有无环(使用递归)</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool have_circle(int s) &#123;&#x2F;&#x2F;判断是否存在环</span><br><span class="line">	memset(used, 0, sizeof(used));</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (!used[i] &amp;&amp; !(s&amp;(1 &lt;&lt; i))) &#123;</span><br><span class="line"></span><br><span class="line">&gt; 此处条件表示i节点没有遍历过，且跳过s代表的状态</span><br><span class="line">&gt; 只有当s&#x3D;&#x3D;(1&lt;&lt;i)时，后面的条件才为假</span><br><span class="line"></span><br><span class="line">			num++;</span><br><span class="line">			if (dfs(i, -1, s))</span><br><span class="line">				return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool dfs(int u, int fa, int s) &#123;</span><br><span class="line">	used[u] &#x3D; 1;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (g[u][i]) &#123;</span><br><span class="line">			if (i &#x3D;&#x3D; fa || (s &amp; (1 &lt;&lt; i))) continue;</span><br><span class="line"></span><br><span class="line">&gt; 状态s下，该边会被切断，所以不能走下去。</span><br><span class="line"></span><br><span class="line">			if (used[i]) return true;</span><br><span class="line">			if (dfs(i, u, s)) return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="above_two-判断是否右节点的度大于二"><a class="markdownIt-Anchor" href="#above_two-判断是否右节点的度大于二"></a> above_two 判断是否右节点的度大于二</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool above_two(int s) &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">	int cnt &#x3D; 0;</span><br><span class="line">	for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">		if (g[i][j] &amp;&amp; !(s&amp;(1 &lt;&lt; i)) &amp;&amp; !(s&amp;(1 &lt;&lt; j))) &#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			if (cnt &gt; 2) return true;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="count-统计s状态打开的环的数量"><a class="markdownIt-Anchor" href="#count-统计s状态打开的环的数量"></a> count 统计s状态打开的环的数量</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int count(int s) &#123;</span><br><span class="line">int cnt &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">	if (s&amp;(1 &lt;&lt; i)) cnt++;</span><br><span class="line">return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 15;</span><br><span class="line">bool dfs(int u, int fa, int s);</span><br><span class="line">bool above_two(int s);</span><br><span class="line">bool have_circle(int s);</span><br><span class="line">int count(int s);</span><br><span class="line">int n, num;</span><br><span class="line">int g[maxn][maxn];</span><br><span class="line">bool used[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">int a, b;</span><br><span class="line">int kase &#x3D; 0;</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	int ans &#x3D; inf;</span><br><span class="line">	memset(g, 0, sizeof(g));</span><br><span class="line">	while (scanf(&quot;%d %d&quot;, &amp;a, &amp;b) &amp;&amp; a !&#x3D; -1) &#123;</span><br><span class="line">		g[a - 1][b - 1] &#x3D; 1;</span><br><span class="line">		g[b - 1][a - 1] &#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; (1 &lt;&lt; n); i++) &#123;</span><br><span class="line">		num &#x3D; 0;</span><br><span class="line">		if (above_two(i) || have_circle(i))</span><br><span class="line">			continue;</span><br><span class="line">		int now &#x3D; count(i);</span><br><span class="line">		if (num - 1 &lt;&#x3D; now)</span><br><span class="line">			ans &#x3D; min(ans, now);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;Set %d: Minimum links to open is %d\n&quot;, ++kase, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-奇怪的气球膨胀" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%A5%87%E6%80%AA%E7%9A%84%E6%B0%94%E7%90%83%E8%86%A8%E8%83%80/"
    >奇怪的气球膨胀</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%A5%87%E6%80%AA%E7%9A%84%E6%B0%94%E7%90%83%E8%86%A8%E8%83%80/" class="article-date">
  <time datetime="2020-03-30T02:15:00.670Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-12627-奇怪的气球膨胀"><a class="markdownIt-Anchor" href="#uva-12627-奇怪的气球膨胀"></a> UVA 12627 奇怪的气球膨胀</h1>
<p>一开始有一个红气球。每小时后,一个红气球会变成3个红气球和一个蓝气球,而一个 蓝气球会变成4个蓝气球。如图，分别是经过0, 1, 2, 3小时后的情况。经过k小时后, 第A~B行一共有多少个红气球?</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<p><img src="/UVA_img/8.png" alt="" /></p>
<ol>
<li>
<p>找规律加分治</p>
</li>
<li>
<p>观察两个图发现，第二章图的前两行是第一张图的平移</p>
</li>
<li>
<p>第二张图的后两行左半部分就是第一张图，右半部分全蓝</p>
</li>
<li>
<p>所以得出函数，第k张图的1~i行s(k,i)</p>
<ol>
<li>当k==0 时，s = 1;</li>
<li>当k&gt;0时
<ol>
<li>当i&lt;=2<sup>k-1</sup>时，s = 2*s(k-1,i)</li>
<li>当i&gt;2<sup>k-1</sup>时，s = s(k-1,i-2<sup>k-1</sup>)+2*红色球总数(k-1)</li>
</ol>
</li>
</ol>
</li>
<li>
<p>最终答案为s(k,B)-s(k,A-1)</p>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">long long A, B, k;</span><br><span class="line"></span><br><span class="line">long long Allred(long long k) &#123; return pow(3, k); &#125;</span><br><span class="line">long long s(long long k, long long i) &#123;</span><br><span class="line">	if (i &lt;&#x3D; 0) return 0;</span><br><span class="line">	if (k &#x3D;&#x3D; 0) return 1;</span><br><span class="line">	if (i &lt;&#x3D; (1 &lt;&lt; k - 1)) return 2 * s(k - 1, i);</span><br><span class="line">	else return s(k - 1, i - (1 &lt;&lt; (k - 1))) + 2 * Allred(k - 1);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	int kase &#x3D; 0;</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Case %d: &quot;, ++kase);</span><br><span class="line">		scanf(&quot;%lld %lld %lld&quot;, &amp;k, &amp;A, &amp;B);</span><br><span class="line">		printf(&quot;%lld\n&quot;, s(k, B) - s(k, A - 1));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-平均值" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%B9%B3%E5%9D%87%E5%80%BC/"
    >平均值</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%B9%B3%E5%9D%87%E5%80%BC/" class="article-date">
  <time datetime="2020-03-30T02:15:00.670Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="uva-1451-平均值"><a class="markdownIt-Anchor" href="#uva-1451-平均值"></a> UVA 1451 平均值</h1>
<p>给定一个长度为 n 的 01 串，选一个长度至少为  的连续子串，使得子串中数字的平均值最大。如果有多解，子串长度应尽量小；如果仍有多解，起点编号尽量小。序列中的字符编号为 1 ~ n，因此 [1,n] 就是完整的字符串。1≤n≤100000</p>
<p>例如，对于如下长度为 171717 的序列00101011011011010，如果 L=7L=7L=7 ，最大平均值为 34\frac 3 443​ （子序列为 [7,14]其长度为 8）；如果 L=5，子序列 [7,11]的平均值最大，为 4/5​。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>
<p>观察目标函数的形式，非常类似sum函数的斜率，其中sum(i)为前i项和，并且相邻两项间都是x+1,y不变或加1。所以问题转化成了寻找两点间斜率的最大值。那么哪种情况斜率最大呢？假设给点一个点Pt，现在要求Pt’使得直线PtPt’斜率最大。</p>
</li>
<li>
<p>假设Pt的x坐标为x0。假设有三个候选点Pi,Pj,Pk 且i&lt;j&lt;k&lt;t</p>
<ol>
<li>若Pj为上凸点。因为t&gt;k，所以yt&gt;=yk，画图可知，忽略点点j不会丢掉最优点。因此，所有的上凸点都可以直接忽略</li>
<li>若Pj为下凹点。那么该点与当前的枚举的结尾点的连线即为可能的最优解。但问题是，新的点的加入可能使原来的点变成上凸点，这时就应该把上凸点删除。被删除的点总时原来的下凹点中最右边的若干连续点(因此可以用栈实现)</li>
</ol>
</li>
<li>
<p>因此，主过程就是枚举终点，计算可能的起始点。对于合法的起始点，更新答案。</p>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="compare_avg-比较平均值-使用通分做差后的分子避免除法误差"><a class="markdownIt-Anchor" href="#compare_avg-比较平均值-使用通分做差后的分子避免除法误差"></a> compare_avg 比较平均值 使用通分做差后的分子避免除法误差</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int compare_avg(int x1, int x2, int x3, int x4) &#123;</span><br><span class="line">	return (sum[x2] - sum[x1-1])*(x4 - x3 + 1) - (sum[x4] - sum[x3-1])*(x2 - x1 + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="solve-枚举终点计算可能的起始点对于合法的起始点更新答案"><a class="markdownIt-Anchor" href="#solve-枚举终点计算可能的起始点对于合法的起始点更新答案"></a> solve 枚举终点，计算可能的起始点，对于合法的起始点，更新答案</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">	int ansL&#x3D;1, ansR &#x3D; L;</span><br><span class="line">	int i &#x3D; 0, j &#x3D; 0;</span><br><span class="line">	for (int t &#x3D; L; t &lt;&#x3D; n; t++) &#123;</span><br><span class="line">		&#x2F;&#x2F;p[i,j)为候选起始点</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;略过上凸点</span><br><span class="line">		while (j - i &gt; 1 &amp;&amp; compare_avg(p[j - 2], t - L, p[j - 1], t - L) &gt;&#x3D; 0) </span><br><span class="line">		&#x2F;&#x2F;当斜率下降过程中出现上升，则停止</span><br><span class="line">		j--; </span><br><span class="line"></span><br><span class="line">		p[j++] &#x3D; t - L + 1;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;找到第一个切点</span><br><span class="line">		while (j - i &gt; 1 &amp;&amp; compare_avg(p[i], t, p[i + 1], t) &lt;&#x3D; 0) i++;	</span><br><span class="line">		&#x2F;&#x2F;当斜率上升过程中出现下降，则停止</span><br><span class="line">	</span><br><span class="line">		int nans &#x3D; compare_avg(p[i], t, ansL, ansR);</span><br><span class="line">			if (nans &gt; 0 || (nans &#x3D;&#x3D; 0 &amp;&amp; t - p[i] &lt; ansR - ansL)) &#123;</span><br><span class="line">				ansL &#x3D; p[i];</span><br><span class="line">				ansR &#x3D; t;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d %d\n&quot;, ansL, ansR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100000 + 5;</span><br><span class="line">int sum[maxn];</span><br><span class="line">char s[maxn];</span><br><span class="line">int p[maxn];</span><br><span class="line">int n, L;</span><br><span class="line"></span><br><span class="line">int compare_avg(int x1, int x2, int x3, int x4);</span><br><span class="line">void solve();</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d\n&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d %d&quot;, &amp;n, &amp;L);</span><br><span class="line">		</span><br><span class="line">		scanf(&quot;%s&quot;, s + 1);</span><br><span class="line">		sum[0] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) sum[i] &#x3D; sum[i - 1] + s[i]-&#39;0&#39;;</span><br><span class="line">		solve();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/15/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/17/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        CuiEnbo
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt=""></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['', '', ''],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: false
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>