<!DOCTYPE html>


<html lang="en" >


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Hexo
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

  <script type="text/javascript"
	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-201412-4" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/201412-4/"
    >201412-4</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/201412-4/" class="article-date">
  <time datetime="2020-03-30T04:00:17.054Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="最优灌溉"><a href="#最优灌溉" class="headerlink" title="最优灌溉"></a>最优灌溉</h1><p><strong>问题描述</strong></p>
<p>　　雷雷承包了很多片麦田，为了灌溉这些麦田，雷雷在第一个麦田挖了一口很深的水井，所有的麦田都从这口井来引水灌溉。<br>　　为了灌溉，雷雷需要建立一些水渠，以连接水井和麦田，雷雷也可以利用部分麦田作为“中转站”，利用水渠连接不同的麦田，这样只要一片麦田能被灌溉，则与其连接的麦田也能被灌溉。<br>　　现在雷雷知道哪些麦田之间可以建设水渠和建设每个水渠所需要的费用（注意不是所有麦田之间都可以建立水渠）。请问灌溉所有麦田最少需要多少费用来修建水渠。</p>
<p><strong>输入格式</strong></p>
<p>　　输入的第一行包含两个正整数n, m，分别表示麦田的片数和雷雷可以建立的水渠的数量。麦田使用1, 2, 3, ……依次标号。<br>　　接下来m行，每行包含三个整数ai, bi, ci，表示第ai片麦田与第bi片麦田之间可以建立一条水渠，所需要的费用为ci。</p>
<p><strong>输出格式</strong></p>
<p>　　输出一行，包含一个整数，表示灌溉所有麦田所需要的最小费用。</p>
<p><strong>样例输入</strong></p>
<p>4 4<br>1 2 1<br>2 3 4<br>2 4 2<br>3 4 3</p>
<p><strong>样例输出</strong></p>
<p>6</p>
<p><strong>样例说明</strong></p>
<p>　　建立以下三条水渠：麦田1与麦田2、麦田2与麦田4、麦田4与麦田3。</p>
<p><strong>评测用例规模与约定</strong></p>
<p>　　前20%的评测用例满足：n≤5。<br>　　前40%的评测用例满足：n≤20。<br>　　前60%的评测用例满足：n≤100。<br>　　所有评测用例都满足：1≤n≤1000，1≤m≤100,000，1≤ci≤10,000。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>最小生成树。前几年是真简单啊</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	edge(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> w):a(a),b(b),w(w)&#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge&amp; x) &#123;</span><br><span class="line">		<span class="keyword">return</span> w &lt; x.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Tree[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Tree[p] == <span class="number">-1</span>) <span class="keyword">return</span> p;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = findroot(Tree[p]);</span><br><span class="line">		Tree[p] = tmp;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">union_</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rp = findroot(p);</span><br><span class="line">	<span class="keyword">int</span> rq = findroot(q);</span><br><span class="line">	<span class="keyword">if</span> (rp != rq) &#123;</span><br><span class="line">		Tree[rq] = rp;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; g;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(Tree, <span class="number">-1</span>, <span class="keyword">sizeof</span>(Tree));</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">int</span> a, b, w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">		g.push_back(edge(a, b, w));</span><br><span class="line">	&#125;</span><br><span class="line">	sort(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a = g[i].a;</span><br><span class="line">		<span class="keyword">int</span> b = g[i].b;</span><br><span class="line">		<span class="keyword">int</span> w = g[i].w;</span><br><span class="line">		<span class="keyword">if</span> (union_(a, b)) &#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			ans += w;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-201503-4" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/201503-4/"
    >201503-4</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/201503-4/" class="article-date">
  <time datetime="2020-03-30T04:00:17.054Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="网络延时"><a href="#网络延时" class="headerlink" title="网络延时"></a>网络延时</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　给定一个公司的网络，由<em>n</em>台交换机和<em>m</em>台终端电脑组成，交换机与交换机、交换机与电脑之间使用网络连接。交换机按层级设置，编号为1的交换机为根交换机，层级为1。其他的交换机都连接到一台比自己上一层的交换机上，其层级为对应交换机的层级加1。所有的终端电脑都直接连接到交换机上。<br>　　当信息在电脑、交换机之间传递时，每一步只能通过自己传递到自己所连接的另一台电脑或交换机。请问，电脑与电脑之间传递消息、或者电脑与交换机之间传递消息、或者交换机与交换机之间传递消息最多需要多少步。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入的第一行包含两个整数<em>n</em>, <em>m</em>，分别表示交换机的台数和终端电脑的台数。<br>　　第二行包含<em>n</em> - 1个整数，分别表示第2、3、……、<em>n</em>台交换机所连接的比自己上一层的交换机的编号。第<em>i</em>台交换机所连接的上一层的交换机编号一定比自己的编号小。<br>　　第三行包含<em>m</em>个整数，分别表示第1、2、……、<em>m</em>台终端电脑所连接的交换机的编号。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出一个整数，表示消息传递最多需要的步数。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>4 2<br>1 1 3<br>2 1</p>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>4</p>
<h2 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h2><p>　　样例的网络连接模式如下，其中圆圈表示交换机，方框表示电脑：<br><img src="http://118.190.20.162/RequireFile.do?fid=F9GfBRHL" alt="img"><br>　　其中电脑1与交换机4之间的消息传递花费的时间最长，为4个单位时间。</p>
<h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><p>4 4<br>1 2 2<br>3 4 4 4</p>
<h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><p>4</p>
<h2 id="样例说明-1"><a href="#样例说明-1" class="headerlink" title="样例说明"></a>样例说明</h2><p>　　样例的网络连接模式如下：<br><img src="http://118.190.20.162/RequireFile.do?fid=LYDFDEbt" alt="img"><br>　　其中电脑1与电脑4之间的消息传递花费的时间最长，为4个单位时间。</p>
<h2 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>　　前30%的评测用例满足：<em>n</em> ≤ 5, <em>m</em> ≤ 5。<br>　　前50%的评测用例满足：<em>n</em> ≤ 20, <em>m</em> ≤ 20。<br>　　前70%的评测用例满足：<em>n</em> ≤ 100, <em>m</em> ≤ 100。<br>　　所有评测用例都满足：1 ≤ <em>n</em> ≤ 10000，1 ≤ <em>m</em> ≤ 10000。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>本题要计算树中两点间的最大距离，<strong>即图的直径</strong></li>
<li>方法是，从任一点出发，用bfs或者dfs求得离该点最远的点，即为树的一个端点。再从这个端点出发，找离他最远的点，为另一个端点。两点间距离即为图的直径</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000</span> + <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> beg)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	q.push(beg);</span><br><span class="line">	dis[beg] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">			dis[v] = dis[u] + <span class="number">1</span>;</span><br><span class="line">			q.push(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> maxx = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> node = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dis[i] &gt; maxx) &#123;</span><br><span class="line">			maxx = dis[i];</span><br><span class="line">			node = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">		g[a].push_back(i);</span><br><span class="line">		g[i].push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">		g[a].push_back(n + i);</span><br><span class="line">		g[n + i].push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> n1 = bfs(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> n2 = bfs(n1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, dis[n2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-图论" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%9B%BE%E8%AE%BA/"
    >图论</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%9B%BE%E8%AE%BA/" class="article-date">
  <time datetime="2020-03-30T03:55:19.552Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="图论基础"><a href="#图论基础" class="headerlink" title="图论基础"></a>图论基础</h1><ol>
<li>邻接矩阵：适用于稠密图和需要频繁判断某特定的结点对是否相邻的情况</li>
<li>邻接链表：适用于需要大量遍历邻接节点而较少判断两个节点间关系时使用</li>
</ol>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const int maxn &#x3D; 10000000 + 5;</span><br><span class="line">int Tree[maxn];</span><br><span class="line">int setRank[maxn];</span><br><span class="line">int findRoot(int x) &#123;</span><br><span class="line">	if (Tree[x] &#x3D;&#x3D; -1) return x;</span><br><span class="line">	else &#123;</span><br><span class="line">		int tmp &#x3D; findRoot(Tree[x]);</span><br><span class="line">		Tree[x] &#x3D; tmp;</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void union_(int p, int q) &#123;</span><br><span class="line">	p &#x3D; findRoot(p);</span><br><span class="line">	q &#x3D; findRoot(q);</span><br><span class="line">	if (p !&#x3D; q)</span><br><span class="line">	&#123;</span><br><span class="line">		Tree[p] &#x3D; q;</span><br><span class="line">		setRank[q] +&#x3D; setRank[p];</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Head-of-a-Gang"><a href="#Head-of-a-Gang" class="headerlink" title="Head of a Gang"></a>Head of a Gang</h2><p>每次输入两个人的名字和通话时长，有联系的两个人属于同一个组织。总的通话时长大于k且总人数大于2的组织称为一个团伙，其中权重最大的那个人是头目。现在要输出团伙总数，及每个团伙的头目，并要求按头目名字降序输出。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>需要计算每个集合的总权重，所以每次都将小树连到大树上，之后统计大树的根所包含的权重是否满足要求。</li>
<li><strong>注意</strong> memset只对0和-1有效。可使用fill实现</li>
</ol>
<blockquote>
<p>memset是一个字节一个字节设置的，取要赋的值的后8位二进制进行赋值。<br>1的二进制是（00000000 00000000 00000000 00000001），取后8位（00000001），int型占4个字节，当初始化为1时，它把一个int的每个字节都设置为1，也就是0x01010101,二进制是00000001 00000001 00000001 00000001，十进制就是16843009。<br>之所以输入0,-1时正确，纯属巧合。<br>0，二进制是（00000000 00000000 00000000 00000000），取后8位（00000000），初始化后00000000 00000000 00000000 00000000结果是0<br>-1，负数在计算机中以补码存储，二进制是（11111111 11111111 11111111 11111111），取后8位（11111111），则是11111111 11111111 11111111 11111111结果也是-1</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">int Tree[maxn];&#x2F;&#x2F;记录根</span><br><span class="line">int setRank[maxn];&#x2F;&#x2F;记录树的大小</span><br><span class="line">int tot[maxn];&#x2F;&#x2F;记录树的权重和</span><br><span class="line">map&lt;int, string&gt; id;&#x2F;&#x2F;记录编号对应的名字</span><br><span class="line">map&lt;string, int&gt; name;&#x2F;&#x2F;记录名字对应的编号</span><br><span class="line">int g[maxn][maxn];&#x2F;&#x2F;记录两点之间的距离，不必要，可以每次union时作为参数传入</span><br><span class="line">int weight[maxn];&#x2F;&#x2F;记录每个节点的权重，每提到一次就加一次</span><br><span class="line"></span><br><span class="line">int findRoot(int x) &#123;</span><br><span class="line">	if (Tree[x] &#x3D;&#x3D; -1) return x;</span><br><span class="line">	else &#123;</span><br><span class="line">		int tmp &#x3D; findRoot(Tree[x]);</span><br><span class="line">		Tree[x] &#x3D; tmp;</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void union_(int p, int q) &#123;</span><br><span class="line">	int rootp &#x3D; findRoot(p);</span><br><span class="line">	int rootq &#x3D; findRoot(q);</span><br><span class="line">	if (rootp !&#x3D; rootq)</span><br><span class="line">	&#123;</span><br><span class="line">		if (tot[rootp] &lt; tot[rootq])&#x2F;&#x2F;每次都将小树加在大树上</span><br><span class="line">			swap(rootp, rootq);</span><br><span class="line">		Tree[rootq] &#x3D; rootp;</span><br><span class="line">		tot[rootp] +&#x3D; tot[rootq] + g[p][q];&#x2F;&#x2F;g[p][q]可以通过参数传入</span><br><span class="line">		setRank[rootp] +&#x3D; setRank[rootq];</span><br><span class="line">	&#125;</span><br><span class="line">	else tot[rootp] +&#x3D; g[q][p];&#x2F;&#x2F;即使已经在一颗树上也要加上内部联系的权重</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, a, b, m, k;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;n, &amp;k) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(Tree, -1, sizeof(Tree));</span><br><span class="line">		memset(tot, 0, sizeof(tot));</span><br><span class="line">		memset(weight, 0, sizeof(weight));</span><br><span class="line">		fill(setRank, setRank + maxn, 1);</span><br><span class="line">		name.clear();</span><br><span class="line">		string n1, n2;</span><br><span class="line">		int t;</span><br><span class="line">		int num &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; t;</span><br><span class="line">			if (!name.count(n1)) &#123;</span><br><span class="line">				name[n1] &#x3D; ++num;</span><br><span class="line">				id[num] &#x3D; n1;</span><br><span class="line">			&#125;</span><br><span class="line">			if (!name.count(n2)) &#123;</span><br><span class="line">				name[n2] &#x3D; ++num;</span><br><span class="line">				id[num] &#x3D; n2;</span><br><span class="line">			&#125;</span><br><span class="line">			int s1 &#x3D; name[n1], s2 &#x3D; name[n2];</span><br><span class="line">			g[s1][s2] &#x3D; g[s2][s1] &#x3D; t;</span><br><span class="line">			weight[s1] +&#x3D; t;</span><br><span class="line">			weight[s2] +&#x3D; t;</span><br><span class="line">			union_(name[n1], name[n2]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		vector&lt;int&gt; ans;&#x2F;&#x2F;存满足条件的集合的根节点</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; num; i++) &#123;</span><br><span class="line">			if (Tree[i] &#x3D;&#x3D; -1 &amp;&amp; tot[i] &gt; k&amp;&amp;setRank[i] &gt; 2) &#123;</span><br><span class="line">				ans.push_back(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans.size() &lt;&lt; endl;</span><br><span class="line">		map&lt;string, int&gt; gang;&#x2F;&#x2F;存满足条件集合的头目名字和集合的大小</span><br><span class="line">		for (int i &#x3D; 0; i &lt; ans.size(); i++) &#123;</span><br><span class="line">			int t &#x3D; ans[i];</span><br><span class="line">			int w &#x3D; 0;</span><br><span class="line">			int iw &#x3D; 0;</span><br><span class="line">			for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">				if ((Tree[j] &#x3D;&#x3D; t||j&#x3D;&#x3D;t) &amp;&amp; weight[j] &gt; w) &#123;</span><br><span class="line">					w &#x3D; weight[j];</span><br><span class="line">					iw &#x3D; j;</span><br><span class="line">				&#125;</span><br><span class="line">			gang[id[iw]] &#x3D; setRank[t];</span><br><span class="line">		&#125;</span><br><span class="line">		for (auto i &#x3D; gang.begin(); i !&#x3D; gang.end(); i++) </span><br><span class="line">			cout &lt;&lt; i-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; i-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h2 id="Kruskal-又是畅通工程"><a href="#Kruskal-又是畅通工程" class="headerlink" title="Kruskal (又是畅通工程)"></a>Kruskal (又是畅通工程)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">int Tree[maxn];&#x2F;&#x2F;记录根</span><br><span class="line">struct node &#123;</span><br><span class="line">	int a, b;</span><br><span class="line">	int w;</span><br><span class="line"></span><br><span class="line">	bool operator &lt; (const node&amp;a)const &#123; return w &lt; a.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int findRoot(int x) &#123;</span><br><span class="line">	if (Tree[x] &#x3D;&#x3D; -1) return x;</span><br><span class="line">	else &#123;</span><br><span class="line">		int tmp &#x3D; findRoot(Tree[x]);</span><br><span class="line">		Tree[x] &#x3D; tmp;</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool union_(int p, int q) &#123;</span><br><span class="line">	int rootp &#x3D; findRoot(p);</span><br><span class="line">	int rootq &#x3D; findRoot(q);</span><br><span class="line">	if (rootp !&#x3D; rootq)</span><br><span class="line">	&#123;</span><br><span class="line">		Tree[rootq] &#x3D; rootp;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">node g[maxn*maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		int m &#x3D; n * (n - 1) &#x2F; 2;</span><br><span class="line">		memset(Tree, -1, sizeof(Tree));</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++)</span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;g[i].a, &amp;g[i].b, &amp;g[i].w);</span><br><span class="line">		sort(g, g + m);</span><br><span class="line"></span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			int a &#x3D; g[i].a;</span><br><span class="line">			int b &#x3D; g[i].b;</span><br><span class="line">			if (union_(a, b))</span><br><span class="line">				ans +&#x3D; g[i].w;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="POJ-2560"><a href="#POJ-2560" class="headerlink" title="POJ 2560"></a>POJ 2560</h2><p>不直接给出边，而是给出点的坐标，实际也是最小生成树问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">int Tree[maxn];&#x2F;&#x2F;记录根</span><br><span class="line">struct point &#123;</span><br><span class="line">	double x, y;</span><br><span class="line">	point()&#123;&#125;</span><br><span class="line">	point(double x, double y) :x(x), y(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int a, b;</span><br><span class="line">	double w;</span><br><span class="line">	node() &#123;&#125;;</span><br><span class="line">	node(int a, int b, double w) :a(a), b(b), w(w) &#123;&#125;</span><br><span class="line">	bool operator &lt; (const node&amp;a)const &#123; return w &lt; a.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int findRoot(int x) &#123;</span><br><span class="line">	if (Tree[x] &#x3D;&#x3D; -1) return x;</span><br><span class="line">	else &#123;</span><br><span class="line">		int tmp &#x3D; findRoot(Tree[x]);</span><br><span class="line">		Tree[x] &#x3D; tmp;</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool union_(int p, int q) &#123;</span><br><span class="line">	int rootp &#x3D; findRoot(p);</span><br><span class="line">	int rootq &#x3D; findRoot(q);</span><br><span class="line">	if (rootp !&#x3D; rootq)</span><br><span class="line">	&#123;</span><br><span class="line">		Tree[rootq] &#x3D; rootp;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline double getDis(point a, point b) &#123;</span><br><span class="line">	return sqrt((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(Tree, -1, sizeof(Tree));	</span><br><span class="line">		node g[maxn*maxn];</span><br><span class="line">		point p[maxn];</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%lf%lf&quot;, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">		&#125;</span><br><span class="line">		int m &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; i + 1; j &lt; n; j++) &#123;</span><br><span class="line">				g[m++] &#x3D; node(i, j, getDis(p[i], p[j]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(g, g + m);</span><br><span class="line">		double ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			int a &#x3D; g[i].a;</span><br><span class="line">			int b &#x3D; g[i].b;</span><br><span class="line">			if (union_(a, b))</span><br><span class="line">				ans +&#x3D; g[i].w;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%.2lf\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><h2 id="Flyod"><a href="#Flyod" class="headerlink" title="Flyod"></a>Flyod</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ol>
<li>每次加入一个节点，并分析对于每一对点，能否使二者间距离变短(不通变通)</li>
<li>使用邻接矩阵存储图</li>
<li>时间复杂度O(n<sup>3</sup>)</li>
<li>一次Floyd之后，图中所有点之间的最短路径都被确定，所以适用于多组查询的情况</li>
<li>注意初始化函数中定义自己到自己的距离为0</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void init(int n) &#123;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">			ans[i][j] &#x3D; -1;</span><br><span class="line">		ans[i][i] &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void Floyd(int n) &#123;</span><br><span class="line"></span><br><span class="line">	for (int k &#x3D; 1; k &lt;&#x3D; n; k++) &#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">				if (ans[i][k] &#x3D;&#x3D; -1 || ans[k][j] &#x3D;&#x3D; -1) continue;</span><br><span class="line">				if (ans[i][j] &#x3D;&#x3D; -1 || ans[i][j] &gt; ans[i][k] + ans[k][j])</span><br><span class="line">					ans[i][j] &#x3D; ans[i][k] + ans[k][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dijkstra-单源最短路"><a href="#Dijkstra-单源最短路" class="headerlink" title="Dijkstra 单源最短路"></a>Dijkstra 单源最短路</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><ol>
<li>按照最短路径长度递增的顺序确定每一个节点的最短路径长度，即先确定的结点的最短路径长度不大于后确定的最短路径长度。这样，当确定一个节点的最短路径长度时，该最短路径上所有中间结点的最短路径长度必然已经确定。</li>
<li>用优先级队列优化后，时间复杂度O(nlogn)</li>
<li>关于实现，由于优先级队列默认调用less，即&lt;号得到递减序列。为了简化代码(其实是懒)，所以将结构体中’&lt;’重载为’&gt;’。当然也可以priority_queue&lt;edge,vector<edge>,greater<edge>&gt;;</li>
</ol>
<h3 id="最短路径问题-浙大"><a href="#最短路径问题-浙大" class="headerlink" title="最短路径问题(浙大)"></a>最短路径问题(浙大)</h3><p>除路长度外增加了一个花费，优先取路径长度最小，对于相同长度的取花费最小。思想一致，只需在板子外再加一个cost数组。与dis数组同理即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">struct edge &#123;</span><br><span class="line">	int to;</span><br><span class="line">	int w;</span><br><span class="line">	int c;</span><br><span class="line">	edge() &#123;&#125;</span><br><span class="line">	edge(int to, int w, int c) :to(to), w(w), c(c) &#123;&#125;</span><br><span class="line">	bool operator &lt;(const edge a) const &#123; return w &gt; a.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt;g[maxn];</span><br><span class="line">int cost[maxn];</span><br><span class="line">int dis[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">void Dij(int beg, int goal, int n) &#123;</span><br><span class="line">	memset(dis, -1, sizeof(dis));</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	memset(cost, 0, sizeof(cost));</span><br><span class="line">	dis[beg] &#x3D; 0;</span><br><span class="line">	priority_queue&lt;edge&gt; pq;</span><br><span class="line">	pq.push(edge(beg, 0, 0));</span><br><span class="line">	while (!pq.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		edge u &#x3D; pq.top(); pq.pop();</span><br><span class="line">		if (u.to &#x3D;&#x3D; goal) return;</span><br><span class="line">		if (vis[u.to]) continue;</span><br><span class="line">		vis[u.to] &#x3D; 1;</span><br><span class="line">		for (edge e : g[u.to]) &#123;</span><br><span class="line">			if (!vis[e.to]) &#123;</span><br><span class="line">				int d1 &#x3D; dis[e.to];</span><br><span class="line">				int d2 &#x3D; dis[u.to];</span><br><span class="line">				if (d1 &#x3D;&#x3D; -1 </span><br><span class="line">					||d1 &gt; d2 + e.w</span><br><span class="line">					|| (d1&#x3D;&#x3D; d2 + e.w &amp;&amp; cost[e.to] &gt; cost[u.to] + e.c)) </span><br><span class="line">				&#123;</span><br><span class="line">					dis[e.to] &#x3D; dis[u.to] + e.w;</span><br><span class="line">					cost[e.to] &#x3D; cost[u.to] + e.c;</span><br><span class="line">					pq.push(edge(e.to, dis[e.to], cost[e.to]));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	int a, b, w, c;</span><br><span class="line">	int s, t;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		if (m &#x3D;&#x3D; 0 &amp;&amp; n &#x3D;&#x3D; 0) break;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)	g[i].clear();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;w, &amp;c);</span><br><span class="line">			g[a].push_back(edge(b, w, c));</span><br><span class="line">			g[b].push_back(edge(a, w, c));</span><br><span class="line">		&#125;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;s, &amp;t);</span><br><span class="line">		Dij(s, t, n);</span><br><span class="line">		printf(&quot;%d %d\n&quot;, dis[t], cost[t]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路径-上交"><a href="#最短路径-上交" class="headerlink" title="最短路径(上交)"></a>最短路径(上交)</h2><p>N个城市，标号从0到N-1，M条道路，第K条道路（K从0开始）的长度为2^K，求编号为0的城市到其他城市的最短距离<br>输入：第一行两个正整数N（2&lt;=N&lt;=100）M(M&lt;=500),表示有N个城市，M条道路。接下来M行两个整数，表示相连的两个城市的编号<br>输出：N-1行，表示0号城市到其他城市的最短路，如果无法到达，输出-1，数值太大的以MOD 100000 的结果输出。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>本题是高精度整数和迪杰斯特拉算法的结合，作为综合练习。</li>
<li>主要注意一下细节问题，主要是% 运算符的重载，一开始写错了。</li>
<li>出现死循环别忘了检查输入的循环，比如是否忘了写scanf()==2<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">class BigInteger &#123;</span><br><span class="line">private:</span><br><span class="line">	const static int maxn &#x3D; 1000 + 5;</span><br><span class="line">	void init() &#123;</span><br><span class="line">		memset(digit, 0, sizeof(digit));</span><br><span class="line">		size &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int digit[maxn];</span><br><span class="line">	int size;</span><br><span class="line">	void set(char str[]) &#123;</span><br><span class="line">		int len &#x3D; strlen(str);</span><br><span class="line">		init();</span><br><span class="line">		for (int i &#x3D; len - 1, j &#x3D; 0, t &#x3D; 0, c &#x3D; 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			t +&#x3D; (str[i] - &#39;0&#39;)*c;</span><br><span class="line">			j++;</span><br><span class="line">			c *&#x3D; 10;</span><br><span class="line">			if (j &#x3D;&#x3D; 4 || i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				digit[size++] &#x3D; t;</span><br><span class="line">				t &#x3D; 0;</span><br><span class="line">				j &#x3D; 0;</span><br><span class="line">				c &#x3D; 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void output() &#123;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			if (i !&#x3D; size - 1)</span><br><span class="line">				printf(&quot;%04d&quot;, digit[i]);</span><br><span class="line">			else if (digit[i])</span><br><span class="line">				printf(&quot;%d&quot;, digit[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	int operator % (int x) const &#123;</span><br><span class="line">		int remain &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--) </span><br><span class="line">			remain &#x3D; (remain * 10000 + digit[i]) % x;</span><br><span class="line">		return remain;</span><br><span class="line">	&#125;</span><br><span class="line">	BigInteger operator * (const int &amp;a) const &#123;</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] * a + cf;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">	BigInteger operator + (const  BigInteger &amp;A) const &#123;</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; size || i &lt; A.size; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] + A.digit[i] + cf;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator &lt;(const BigInteger A) const &#123;</span><br><span class="line">		if (A.size !&#x3D; size) return size &lt; A.size;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			if (digit[i] !&#x3D; A.digit[i])</span><br><span class="line">				return digit[i] &lt; A.digit[i];</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct edge &#123;</span><br><span class="line">	int to;</span><br><span class="line">	BigInteger w;</span><br><span class="line">	edge(int to, BigInteger w) :to(to), w(w) &#123;&#125;</span><br><span class="line">	bool operator &lt; (const edge&amp;a) const &#123; return a.w &lt; w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; g[105];</span><br><span class="line">BigInteger dis[105]&#123;&#125;;</span><br><span class="line">void dij(int beg) &#123;</span><br><span class="line">	priority_queue&lt;edge&gt; pq;</span><br><span class="line">	int vis[105]&#123;&#125;;</span><br><span class="line">	memset(dis, 0, sizeof(dis));</span><br><span class="line">	char s[] &#x3D; &quot;0&quot;;</span><br><span class="line">	BigInteger ss; ss.set(s);</span><br><span class="line">	dis[beg] &#x3D; ss;</span><br><span class="line">	pq.push(edge(beg, dis[beg]));</span><br><span class="line">	while (!pq.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		edge u &#x3D; pq.top(); pq.pop();</span><br><span class="line">		if (vis[u.to]) continue;</span><br><span class="line">		vis[u.to] &#x3D; 1;</span><br><span class="line">		for (edge e : g[u.to]) &#123;</span><br><span class="line">			if (vis[e.to]) continue;</span><br><span class="line">			if (dis[e.to].size &#x3D;&#x3D; 0 || dis[u.to] + e.w &lt; dis[e.to]) &#123;</span><br><span class="line">				dis[e.to] &#x3D; dis[u.to] + e.w;</span><br><span class="line">				pq.push(edge(e.to, dis[e.to]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		char s[] &#x3D; &quot;1&quot;;</span><br><span class="line">		BigInteger c;</span><br><span class="line">		c.set(s);</span><br><span class="line">		int a, b;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">			g[a].push_back(edge(b, c));</span><br><span class="line">			g[b].push_back(edge(a, c));</span><br><span class="line">			c &#x3D; c * 2;</span><br><span class="line">		&#125;</span><br><span class="line">		dij(0);</span><br><span class="line">		for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">			if (dis[i].size)</span><br><span class="line">				printf(&quot;%d\n&quot;, dis[i] % 100000);</span><br><span class="line">			else printf(&quot;-1\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="I-wanna-go-home-POJ-3767"><a href="#I-wanna-go-home-POJ-3767" class="headerlink" title="I wanna go home POJ 3767"></a>I wanna go home POJ 3767</h2>某国出现政治分裂，其中的城市分裂成两派，一派支持领导1，一派支持领导2。你是一名商人，在城市1，想走最短路径回到城市2，要求路径中包含至多一条跨过两个阵营的路径，求最短路径长度。</li>
</ol>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>首先用dij分别求两个阵营内部，从源点1和2出发的最短距离。</li>
<li>然后枚举连接两个阵营的边，对于贯穿两个阵营的路径，尝试更新答案为d1[i]+t[i][j]+d2[j]。</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 600 + 5;</span><br><span class="line">struct edge &#123;</span><br><span class="line">	int to;</span><br><span class="line">	int w;</span><br><span class="line">	edge() &#123;&#125;</span><br><span class="line">	edge(int to, int w) :to(to), w(w) &#123;&#125;</span><br><span class="line">	bool operator &lt;(const edge a) const &#123; return w &gt; a.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt;g[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int t[maxn][maxn];</span><br><span class="line">int flag[maxn];</span><br><span class="line"></span><br><span class="line">void Dij(int beg, int n, int f, int *dis) &#123;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	dis[beg] &#x3D; 0;</span><br><span class="line">	priority_queue&lt;edge&gt; pq;</span><br><span class="line">	pq.push(edge(beg, 0));</span><br><span class="line">	while (!pq.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		edge u &#x3D; pq.top(); pq.pop();</span><br><span class="line">		if (vis[u.to]) continue;</span><br><span class="line">		vis[u.to] &#x3D; 1;</span><br><span class="line">		for (edge e : g[u.to]) &#123;</span><br><span class="line">			if (flag[e.to] !&#x3D; f) continue;</span><br><span class="line">			if (!vis[e.to]) &#123;</span><br><span class="line">				if (dis[e.to] &#x3D;&#x3D; -1 || dis[e.to] &gt; dis[u.to] + e.w)</span><br><span class="line">				&#123;</span><br><span class="line">					dis[e.to] &#x3D; dis[u.to] + e.w;</span><br><span class="line">					pq.push(edge(e.to, dis[e.to]));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	int a, b, w;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;m);</span><br><span class="line">		memset(t, -1, sizeof(t));</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) g[i].clear();</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;w);</span><br><span class="line">			if (t[a][b] &#x3D;&#x3D; -1 || w &lt; t[a][b])</span><br><span class="line">				t[a][b] &#x3D; t[b][a] &#x3D; w;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;flag[i]);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			for (int j &#x3D; 1; j &lt;&#x3D; i; j++) &#123;</span><br><span class="line">				if (t[i][j] !&#x3D; -1) &#123;</span><br><span class="line">					g[i].push_back(edge(j, t[i][j]));</span><br><span class="line">					g[j].push_back(edge(i, t[i][j]));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		int d1[maxn];</span><br><span class="line">		int d2[maxn];</span><br><span class="line">		memset(d1, -1, sizeof(d1));</span><br><span class="line">		memset(d2, -1, sizeof(d2));</span><br><span class="line">		Dij(1, n, 1, d1);</span><br><span class="line">		Dij(2, n, 2, d2);</span><br><span class="line">		int ans &#x3D; d1[2];</span><br><span class="line">		if (ans &#x3D;&#x3D; -1)</span><br><span class="line">			for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">				if (flag[i] &#x3D;&#x3D; 2 || d1[i] &#x3D;&#x3D; -1) continue;</span><br><span class="line">				for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">					if (flag[j] &#x3D;&#x3D; 1 || d2[j] &#x3D;&#x3D; -1) continue;</span><br><span class="line">					if (t[i][j] !&#x3D; -1) &#123;</span><br><span class="line">						if (ans &#x3D;&#x3D; -1 || d1[i] + t[i][j] + d2[j] &lt; ans)</span><br><span class="line">							ans &#x3D; d1[i] + t[i][j] + d2[j];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><h2 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h2><ol>
<li>每次取入度为0的点，并删除之，修改它所连接的点的入读，反复入队入度为0的点。记录总的出队点数。如果等于n说明无环，能构成拓扑序列；否则，不能构成拓扑序列。</li>
<li>时间复杂度O(N+M),其中N为顶点数，M为边数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">const int maxn &#x3D; 500 + 5;</span><br><span class="line">int indegree[maxn];</span><br><span class="line">vector&lt;int&gt; g[maxn];</span><br><span class="line">bool topo(int n) &#123;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	vector&lt;int&gt; ans;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) </span><br><span class="line">		if (indegree[i] &#x3D;&#x3D; 0) q.push(i);</span><br><span class="line"></span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		int u &#x3D; q.front(); q.pop();</span><br><span class="line">		ans.push_back(u);</span><br><span class="line"></span><br><span class="line">		for (int i : g[u]) &#123;</span><br><span class="line">			indegree[i]--;</span><br><span class="line">			if (indegree[i] &#x3D;&#x3D; 0)</span><br><span class="line">				q.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (ans.size() &#x3D;&#x3D; n) return true;</span><br><span class="line">	else return false;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	int a, b;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(indegree, 0, sizeof(indegree));</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)  g[i].clear();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">			g[a].push_back(b);</span><br><span class="line">			indegree[b]++;</span><br><span class="line">		&#125;</span><br><span class="line">		bool flag  &#x3D; topo(n);</span><br><span class="line">		if (flag)</span><br><span class="line">			printf(&quot;YES\n&quot;);</span><br><span class="line">		else printf(&quot;NO\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="产生冠军-HDU-2094"><a href="#产生冠军-HDU-2094" class="headerlink" title="产生冠军 HDU 2094"></a>产生冠军 HDU 2094</h2><p>有一群人，打乒乓球比赛，两两捉对撕杀，每两个人之间最多打一场比赛。<br>球赛的规则如下：<br>如果A打败了B，B又打败了C，而A与C之间没有进行过比赛，那么就认定，A一定能打败C。<br>如果A打败了B，B又打败了C，而且，C又打败了A，那么A、B、C三者都不可能成为冠军。<br>根据这个规则，无需循环较量，或许就能确定冠军。你的任务就是面对一群比赛选手，在经过了若干场撕杀之后，确定是否已经实际上产生了冠军。 </p>
<p>输入含有一些选手群，每群选手都以一个整数n(n&lt;1000)开头，后跟n对选手的比赛结果，比赛结果以一对选手名字（中间隔一空格）表示，前者战胜后者。如果n为0，则表示输入结束。 </p>
<p>对于每个选手群，若你判断出产生了冠军，则在一行中输出“Yes”，否则在一行中输出“No”。 </p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol>
<li>本题技巧在于只需判断初始状态下，入度为0的点是否为1个即可。</li>
</ol>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">int indegree[maxn];</span><br><span class="line">vector&lt;int&gt; g[maxn];</span><br><span class="line">bool topo(int n) &#123;</span><br><span class="line">	int tmp[maxn];</span><br><span class="line">	int tot &#x3D; 0;</span><br><span class="line">	memcpy(tmp, indegree, sizeof(tmp));</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) </span><br><span class="line">		if (indegree[i] &#x3D;&#x3D; 0) tot++;</span><br><span class="line">	return tot&#x3D;&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;string, int&gt; id;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	int a, b;</span><br><span class="line">	while (cin &gt;&gt; m &amp;&amp; m)</span><br><span class="line">	&#123;</span><br><span class="line">		string s, y;</span><br><span class="line">		memset(indegree, 0, sizeof(indegree));</span><br><span class="line">		for (int i &#x3D; 1; i &lt; maxn; i++)  g[i].clear();</span><br><span class="line">		int num &#x3D; 1;</span><br><span class="line">		id.clear();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			cin &gt;&gt; s &gt;&gt; y;</span><br><span class="line">			if (!id.count(s))</span><br><span class="line">				id[s] &#x3D; num++;</span><br><span class="line">			if (!id.count(y))</span><br><span class="line">				id[y] &#x3D; num++;</span><br><span class="line">			a &#x3D; id[s];</span><br><span class="line">			b &#x3D; id[y];</span><br><span class="line">			g[a].push_back(b);</span><br><span class="line">			indegree[b]++;</span><br><span class="line">		&#125;</span><br><span class="line">		bool flag &#x3D; topo(num - 1);</span><br><span class="line"></span><br><span class="line">		if (flag)cout &lt;&lt; &quot;Yes&quot;;</span><br><span class="line">		else cout &lt;&lt; &quot;No&quot;;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-动态规划" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"
    >动态规划</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="article-date">
  <time datetime="2020-03-30T03:55:19.536Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="递推求解"><a href="#递推求解" class="headerlink" title="递推求解"></a>递推求解</h1><p>我理解为已知规模解的递归</p>
<h2 id="N阶楼梯上楼问题"><a href="#N阶楼梯上楼问题" class="headerlink" title="N阶楼梯上楼问题"></a>N阶楼梯上楼问题</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>考虑最后一步，可以从n-2阶迈两步，或者从n-1阶迈一步。这样就将走法分成了两类，总的走法f(n)=f(n-1)+f(n-2)。而f(n-1)就是n-1阶时的走法，又可以分成两类，所以问题是一个递推问题</li>
<li>对于小规模的解，我们是知道的，f(1)=1,f(2)=2，所以递推得解</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">int f(int k) &#123;</span><br><span class="line">	if (k &#x3D;&#x3D; 1) return 1;</span><br><span class="line">	if (k &#x3D;&#x3D; 2) return 2;</span><br><span class="line">	return f(k - 1) + f(k - 2);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int k;</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;k)&#x3D;&#x3D;1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d\n&quot;, f(k));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HDU-1465-不容易系列之一"><a href="#HDU-1465-不容易系列之一" class="headerlink" title="HDU 1465 不容易系列之一"></a>HDU 1465 不容易系列之一</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>考虑n号信封里装着k号信，m号信封里装着n号信。按照k和m是否相等分成两类</p>
<ol>
<li>若k!=m，那么交换两封信后，除n号外，其余n-1封信都是错装。那么n号信有n-1中交换方式使得n号错序。此时f(n)=(n-1)*f(n-1)</li>
<li>若k==m，那么交换之后，有n-2封信错装。m有n-1种交换策略，此时，f(n)=(n-1)*f(n-2)</li>
<li>故<strong>错装公式：f(n)=(n-1)<em>f(n-1)+(n-1)</em>f(n-2)</strong><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">long long f(int n) &#123;</span><br><span class="line">	if (n &#x3D;&#x3D; 1) return 0;</span><br><span class="line">	if (n &#x3D;&#x3D; 2) return 1;</span><br><span class="line">	return (n - 1)*(f(n - 1) + f(n - 2));</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%lld\n&quot;, f(n));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="最长递增子序列-LIS"><a href="#最长递增子序列-LIS" class="headerlink" title="最长递增子序列 LIS"></a>最长递增子序列 LIS</h1><p>用F[i]代表若递增子序列以ai结束时它的最长长度,易知F[1]=1.现假设已知F[1]-F[x-1]，依次比较ax和ai(i&lt;x)，如果ax&lt;ai，那么ax可以接在ai后面，使得子序列长度加1。取这些长度的最大值即为F[x]</p>
<h2 id="拦截导弹"><a href="#拦截导弹" class="headerlink" title="拦截导弹"></a>拦截导弹</h2><p>某国为了防御敌国的导弹袭击，开发出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭，并观测到导弹依次飞来的高度，请计算这套系统最多能拦截多少导弹。拦截来袭导弹时，必须按来袭导弹袭击的时间顺序，不允许先拦截后面的导弹，再拦截前面的导弹。<br>求最多拦截导弹数量</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>本题求的是最长非递增子序列(不需连续)</li>
<li>对于第i个高度，可以将它加在它前面的比他大的序列末尾，并且保证加在最长的那条序列尾部即可</li>
<li>递推公式<ol>
<li>f[1] =1 </li>
<li>f[i] = max(1,f[j]+1) ;j&lt;i&amp;&amp;aj&gt;ai</li>
</ol>
</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 30;</span><br><span class="line">int p[maxn];</span><br><span class="line">int dp[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int k;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;k) &#x3D;&#x3D; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;p[i]);</span><br><span class="line">		fill(dp, dp + k, 0);</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">			int cnt &#x3D; 1;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; i; j++)</span><br><span class="line">				if (p[j] &gt;&#x3D; p[i])</span><br><span class="line">					cnt &#x3D; max(cnt, dp[j] + 1);</span><br><span class="line">			dp[i] &#x3D; cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		int ans &#x3D; 1;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; i++)</span><br><span class="line">			ans &#x3D; max(ans, dp[i]);</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合唱队形"><a href="#合唱队形" class="headerlink" title="合唱队形"></a>合唱队形</h2><p>给出k个同学的身高，问在位置不变的情况下，出队几名同学可以是队列呈现中间高两边低的状态</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol>
<li>分别从两侧求递增子序列，然后求同一位置处两侧序列和最长的，即为结果序列长度</li>
<li>假设第i人满足1中条件，那么第i个人被算了两次，别忘了减去</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100+5;</span><br><span class="line">int p1[maxn];</span><br><span class="line">int p2[maxn];</span><br><span class="line">int dp1[maxn];</span><br><span class="line">int dp2[maxn];</span><br><span class="line">int k;</span><br><span class="line">void update_dp(int* dp, const int*p) &#123;</span><br><span class="line">	fill(dp, dp + k, 0);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">		int cnt &#x3D; 1;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; i; j++)</span><br><span class="line">			if (p[j] &lt; p[i])</span><br><span class="line">				cnt &#x3D; max(cnt, dp[j] + 1);</span><br><span class="line">		dp[i] &#x3D; cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;k) &#x3D;&#x3D; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;p1[i]);</span><br><span class="line">			p2[k - i - 1] &#x3D; p1[i];</span><br><span class="line">		&#125;</span><br><span class="line">		update_dp(dp1, p1);</span><br><span class="line">		update_dp(dp2, p2);</span><br><span class="line"></span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">			if (ans &lt; dp1[i] + dp2[k-i-1])</span><br><span class="line">				ans &#x3D; dp1[i] + dp2[k-i-1];</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, k-ans+1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列 LCS"></a>最长公共子序列 LCS</h1><p>用dp[i][j]表示S1中前i个字符与S2中前j个字符分别组成的两个前缀字符串的最长公共子串，易知dp[0][j] = 0;递推公式为</p>
<ol>
<li>dp[0][j] = dp[i][0] = 0</li>
<li>dp[i][j] = dp[i-1][j-1]+1;S1[i]==S2[j]</li>
<li>dp[i][j] = max{dp[i][j-1],dp[i-1][j]};S1[i]!=S2[j]</li>
<li>最终dp[n][m]即为最长连续字串长</li>
<li>注意循环范围</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">char s1[maxn];</span><br><span class="line">char s2[maxn];</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line">int lcs(const char *s1, const char *s2) &#123;</span><br><span class="line">	memset(dp, 0, sizeof(dp));</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; strlen(s1); i++) &#123;</span><br><span class="line">		for (int j &#x3D; 1; j &lt;&#x3D; strlen(s2); j++) &#123;</span><br><span class="line">			if (s1[i-1] !&#x3D; s2[j-1])</span><br><span class="line">				dp[i][j] &#x3D; max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">			else</span><br><span class="line">				dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return dp[strlen(s1)][strlen(s2)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="状态与状态转移方程"><a href="#状态与状态转移方程" class="headerlink" title="状态与状态转移方程"></a>状态与状态转移方程</h1><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><ol>
<li>是一个数字量</li>
<li>可以描述一个状态的特征而不需要其他的辅助信息</li>
<li>状态间的转移完全依赖于状态本身</li>
</ol>
<h2 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h2><ol>
<li>指由一个或多个状态得到新状态的过程</li>
</ol>
<h1 id="动态规划问题举例"><a href="#动态规划问题举例" class="headerlink" title="动态规划问题举例"></a>动态规划问题举例</h1><h2 id="HDU-1421-搬寝室"><a href="#HDU-1421-搬寝室" class="headerlink" title="HDU 1421 搬寝室"></a>HDU 1421 搬寝室</h2><p>搬寝室是很累的,xhd深有体会.时间追述2006年7月9号,那天xhd迫于无奈要从27号楼搬到3号楼,因为10号要封楼了.看着寝室里的n件物品,xhd开始发呆,因为n是一个小于2000的整数,实在是太多了,于是xhd决定随便搬2<em>k件过去就行了.但还是会很累,因为2</em>k也不小是一个不大于n的整数.幸运的是xhd根据多年的搬东西的经验发现每搬一次的疲劳度是和左右手的物品的重量差的平方成正比(这里补充一句,xhd每次搬两件东西,左手一件右手一件).例如xhd左手拿重量为3的物品,右手拿重量为6的物品,则他搬完这次的疲劳度为(6-3)^2 = 9.现在可怜的xhd希望知道搬完这2*k件物品后的最佳状态是怎样的(也就是最低的疲劳度),请告诉他吧. </p>
<p>每组输入数据有两行,第一行有两个数n,k(2&lt;=2*k&lt;=n&lt;2000).第二行有n个整数分别表示n件物品的重量(重量是一个小于2^15的正整数).</p>
<p>对应每组输入数据,输出数据只有一个表示他的最少的疲劳度,每个一行.</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>设dp[i][j]表示前i件物品组成j对所消耗的体力最小；所以分成了两种情况</p>
<ol>
<li>第j对里含有第i件物品，则dp [i][j] = dp [i-2][j-1] + (a[i]-a[i-1])*(a[i]-a[i-1]);</li>
<li>不含第i件物品则有：dp [i][j] = dp [i-1][j];</li>
</ol>
</li>
<li><p>总上，动态转移方程为:dp[i][j]=min(dp[i-2][j-1]+(a[i]-a[i-1])*(a[i]-a[i-1]), dp[i][j]=dp[i-1][j]);</p>
</li>
</ol>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">int dp[2010][2010], a[2010];</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, k;</span><br><span class="line">	while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;k))</span><br><span class="line">	&#123;</span><br><span class="line">		int i, j;</span><br><span class="line">		memset(a, 0, sizeof(a));</span><br><span class="line">		memset(dp, 0, sizeof(dp));</span><br><span class="line">		for (i &#x3D; 0; i &lt;&#x3D; n; i++)</span><br><span class="line">			for (j &#x3D; 1; j &lt;&#x3D; k; j++)</span><br><span class="line">				dp[i][j] &#x3D; inf;</span><br><span class="line">		for (i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">		sort(a, a + n + 1);</span><br><span class="line">		for (i &#x3D; 2; i &lt;&#x3D; n; i++)</span><br><span class="line">			for (j &#x3D; 1; j * 2 &lt;&#x3D; i; j++)</span><br><span class="line">				dp[i][j] &#x3D; min(dp[i - 1][j], dp[i - 2][j - 1] + (a[i] - a[i - 1])*(a[i] - a[i - 1]));</span><br><span class="line">		printf(&quot;%d\n&quot;, dp[n][k]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HDU-3578-Greedy-Tino"><a href="#HDU-3578-Greedy-Tino" class="headerlink" title="HDU 3578 Greedy Tino"></a>HDU 3578 Greedy Tino</h2><p>未完待续</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define OFFSET 2000&#x2F;&#x2F;因为j有正负，所以添加一个偏移量，方便做题</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line">int wi[101];</span><br><span class="line">int dp[101][4001];</span><br><span class="line">int max(int a, int b, int c)&#123;</span><br><span class="line">    int flag &#x3D; a;</span><br><span class="line">    if(flag &lt; b)&#123;</span><br><span class="line">        flag &#x3D; b;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag &lt; c)&#123;</span><br><span class="line">        flag &#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i&#x3D;0;i&lt;40001;i++)</span><br><span class="line">            dp[0][i] &#x3D; -INF;</span><br><span class="line">    dp[0][OFFSET] &#x3D; 0;&#x2F;&#x2F;core</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t, n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; t; i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        wi[0] &#x3D; 0;</span><br><span class="line">         bool hasZero &#x3D; false;</span><br><span class="line">        int cnt &#x3D; 0;</span><br><span class="line">        for(int j &#x3D; 0; j &lt; n; j++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;wi[++cnt]);</span><br><span class="line">            if(wi[cnt] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                   hasZero &#x3D; true;</span><br><span class="line">                   cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n &#x3D; cnt;</span><br><span class="line">        init();</span><br><span class="line">        for(int j &#x3D; 1; j &lt;&#x3D; n; j++)&#123;</span><br><span class="line">            for(int k &#x3D; -2000; k &lt;&#x3D; 2000; k++)&#123;</span><br><span class="line">                dp[j][k+OFFSET] &#x3D; max(dp[j-1][k-wi[j]+OFFSET]+wi[j], dp[j-1][k+wi[j]+OFFSET]+wi[j], dp[j-1][k+OFFSET]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf (&quot;Case %d: &quot;, i+1);</span><br><span class="line">        if(dp[n][0+OFFSET] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            if(hasZero &#x3D;&#x3D; true)&#123;</span><br><span class="line">                printf(&quot;0\n&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                printf(&quot;-1\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            printf(&quot;%d\n&quot;, dp[n][0+OFFSET]&#x2F;2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h1><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><p>特点是每个物品只能选一件，即每个物品的数量只能出现0和1</p>
<h3 id="OpenJ-Bailian-2726"><a href="#OpenJ-Bailian-2726" class="headerlink" title="OpenJ_Bailian 2726"></a>OpenJ_Bailian 2726</h3><p>辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是辰辰，你能完成这个任务吗？</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ol>
<li>用dp[i][j]表示取前i个物品，重量不超过j时能达到的最大价值。</li>
<li>可以根据第i个物品是否取分成两类<ol>
<li>取第i个物品，那么需要更新所有能再装下一个i的状态，即dp[i-1][j-p[i].w]</li>
<li>不取i，那么dp[i][j]=dp[i-1][j]</li>
</ol>
</li>
<li>综上，递推关系为dp[i][j] = max(dp[i-1][j], dp[i - 1][j - p[i].w] + p[i].v)</li>
<li><strong>注意</strong> 对于dp[i-1][j]下装不下第i个物品的状态，要赋值为dp[i-1][j]</li>
</ol>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line">struct node &#123;</span><br><span class="line">	int w;</span><br><span class="line">	int v;</span><br><span class="line">&#125;;</span><br><span class="line">int s, m;</span><br><span class="line">node p[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;s, &amp;m) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;p[i].w, &amp;p[i].v);</span><br><span class="line"></span><br><span class="line">		memset(dp, 0, sizeof(0));</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">			for (int j &#x3D; s; j &gt;&#x3D; p[i].w; j--) &#123;</span><br><span class="line">				dp[i][j] &#x3D; max(dp[i-1][j], dp[i - 1][j - p[i].w] + p[i].v);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			for (int j &#x3D; p[i].w-1; j &gt;&#x3D; 0; j--)&#x2F;&#x2F;对于p[i].w-1~1的状态只能来自于dp[i-1][j]</span><br><span class="line">				dp[i][j] &#x3D; dp[i-1][j];</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, dp[m][s]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol>
<li>发现新的状态至于最近的一个状态有关，所以可以降维。</li>
<li>状态转移方程为：dp[j]=max{dp[j-p[i].w]+v,dp[i]}</li>
<li><strong>注意</strong> 更新dp时是逆序更新，这是因为在0-1背包问题中每个物品至多放入一次。逆序循环，保证了更新dp[j]时，dp[j-p[i].w]是没有放入i时的数据(dp[i-1][j-p[i].w])</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">	for (int j &#x3D; s; j &gt;&#x3D; p[i].w; j--) &#123;</span><br><span class="line">		dp[j]&#x3D;max(dp[j-p[i].w]+v,dp[i]);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>每种物品的数量可以任意多</p>
<h3 id="HDU-1114-Piggy-Bank"><a href="#HDU-1114-Piggy-Bank" class="headerlink" title="HDU 1114 Piggy-Bank"></a>HDU 1114 Piggy-Bank</h3><p>有个存钱罐，已知空罐质量和满罐质量，以及n种硬币质量和价值，求罐中硬币的最小价值。</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><ol>
<li>完全背包问题的区别在于，每个物品可以被选择很多次，因此dp[j]可以由已放入物品i后的数据dp[j-p[i].w]得来，所以顺序循环</li>
<li>本题求最小值，将max要换成min</li>
<li>由于要求恰好装满，所以初始时只有dp[0]=0，其他状态都不存在</li>
</ol>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 10000+ 5;</span><br><span class="line">int dp[maxn];</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line">struct node &#123;</span><br><span class="line">	int w;</span><br><span class="line">	int v;</span><br><span class="line">&#125;;</span><br><span class="line">int s, m;</span><br><span class="line">node p[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;m, &amp;s);</span><br><span class="line">		s -&#x3D; m;</span><br><span class="line">		int n;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;p[i].v, &amp;p[i].w);</span><br><span class="line">		for (int i &#x3D; 0; i &lt;&#x3D; s; i++)</span><br><span class="line">			dp[i] &#x3D; INF;</span><br><span class="line">		dp[0] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; p[i].w; j &lt;&#x3D; s;j++) &#123;</span><br><span class="line">				if (dp[j - p[i].w] !&#x3D; INF)&#x2F;&#x2F;该状态存在，那么才可以产生新的状态</span><br><span class="line">					dp[j] &#x3D; min(dp[j], dp[j - p[i].w] + p[i].v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (dp[s] !&#x3D; INF)</span><br><span class="line">			printf(&quot;The minimum amount of money in the piggy-bank is %d.\n&quot;, dp[s]);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot;This is impossible.\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><p>介于完全背包问题和0-1背包问题之间，每种物品数量有限。可以将k个物品看作k种物品，在进行0-1背包求解。但是这样会使时间复杂度过大。稍加改变，将该种物品分成很多堆，每堆数量为1~k-2^c+1,其中c为使k-2^c+1大于0的最大整数。</p>
<h3 id="HDU-2191-珍惜现在，感恩生活"><a href="#HDU-2191-珍惜现在，感恩生活" class="headerlink" title="HDU 2191 珍惜现在，感恩生活"></a>HDU 2191 珍惜现在，感恩生活</h3><p>输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1&lt;=n&lt;=100, 1&lt;=m&lt;=100),分别表示经费的金额和大米的种类，然后是m行数据，每行包含3个数p，h和c(1&lt;=p&lt;=20,1&lt;=h&lt;=200,1&lt;=c&lt;=20)，分别表示每袋的价格、每袋的重量以及对应种类大米的袋数。</p>
<p>对于每组测试数据，请输出能够购买大米的最多重量，你可以假设经费买不光所有的大米，并且经费你可以不用完。每个实例的输出占一行。</p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><ol>
<li>先将每个物品分成很多堆，类似二进制拆分</li>
<li>然后进行0-1背包求解</li>
</ol>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 10000 + 5;</span><br><span class="line">int dp[maxn];</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line">struct node &#123;</span><br><span class="line">	int w;</span><br><span class="line">	int v;</span><br><span class="line">&#125;;</span><br><span class="line">int s, m;</span><br><span class="line">node a[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;s, &amp;m);</span><br><span class="line">		int p, h, c;</span><br><span class="line">		int cnt &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;p, &amp;h, &amp;c);</span><br><span class="line">			int t &#x3D; 1;</span><br><span class="line">			while (c &gt; t)</span><br><span class="line">			&#123;</span><br><span class="line">				c -&#x3D; t;</span><br><span class="line">				a[++cnt].w &#x3D; t * p;</span><br><span class="line">				a[cnt].v &#x3D; t * h;</span><br><span class="line">				t *&#x3D; 2;</span><br><span class="line">			&#125;</span><br><span class="line">			a[++cnt].w &#x3D; p * c;</span><br><span class="line">			a[cnt].v &#x3D; h * c;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		memset(dp, 0, sizeof(dp));</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; cnt; i++) &#123;</span><br><span class="line">			for (int j &#x3D; s; j &gt;&#x3D; a[i].w;j--) &#123;</span><br><span class="line">					dp[j] &#x3D; max(dp[j], dp[j - a[i].w] + a[i].v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;%d\n&quot;, dp[s]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-其他技巧" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7/"
    >其他技巧</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7/" class="article-date">
  <time datetime="2020-03-30T03:55:19.536Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="标准模板库"><a href="#标准模板库" class="headerlink" title="标准模板库"></a>标准模板库</h1><h2 id="字符串匹配-北航"><a href="#字符串匹配-北航" class="headerlink" title="字符串匹配(北航)"></a>字符串匹配(北航)</h2><p>读入数据string[ ]，然后读入一个短字符串。要求查找string[ ]中和短字符串的所有匹配，输出行号、匹配字符串。匹配时不区分大小写，并且可以有一个用中括号表示的模式匹配。如“aa[123]bb”，就是说aa1bb、aa2bb、aa3bb都算匹配。</p>
<p>输入有多组数据。<br>每组数据第一行输入n(1&lt;=n&lt;=1000)，从第二行开始输入n个字符串（不含空格），接下来输入一个匹配字符串。</p>
<p>输出匹配到的字符串的行号和该字符串（匹配时不区分大小写）。</p>
<p><strong>注意[]会有多个即可</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1005;</span><br><span class="line">string in[maxn];</span><br><span class="line">vector&lt;string&gt; tep;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (cin &gt;&gt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			cin &gt;&gt; in[i];</span><br><span class="line">		string t;</span><br><span class="line">		cin &gt;&gt; t;</span><br><span class="line">		string s &#x3D; t;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; t.length(); i++)</span><br><span class="line">			s[i] &#x3D; tolower(t[i]);</span><br><span class="line"></span><br><span class="line">		tep.push_back(s);</span><br><span class="line">		int cnt &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; tep.size(); i++) &#123;</span><br><span class="line">			s &#x3D; tep[i];</span><br><span class="line">			int f1 &#x3D; s.find(&#39;[&#39;);</span><br><span class="line">			int f2 &#x3D; s.find(&#39;]&#39;);</span><br><span class="line">			if (f1 !&#x3D; -1) &#123;</span><br><span class="line">				string tp &#x3D; s.substr(f1+1, f2-f1-1);</span><br><span class="line">				cnt +&#x3D; tp.length();</span><br><span class="line">				t &#x3D; s.substr(0, f1);</span><br><span class="line">				s &#x3D; s.substr(f2 + 1);</span><br><span class="line">				for (int i &#x3D; 0; i &lt; tp.length(); i++)</span><br><span class="line">					tep.push_back(t + tp[i] + s);</span><br><span class="line">			&#125;</span><br><span class="line">			else break;</span><br><span class="line">		&#125;</span><br><span class="line">		if (!cnt) cnt &#x3D; 1;</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			t &#x3D; in[i];</span><br><span class="line">			for (int j &#x3D; tep.size()-cnt; j &lt; tep.size(); j++) &#123;</span><br><span class="line">				transform(in[i].begin(), in[i].end(), in[i].begin(), ::tolower);</span><br><span class="line">				if (in[i].find(tep[j]) !&#x3D; -1)</span><br><span class="line">				&#123;</span><br><span class="line">					cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h1><h2 id="手动读入int，double"><a href="#手动读入int，double" class="headerlink" title="手动读入int，double"></a>手动读入int，double</h2><h3 id="readint"><a href="#readint" class="headerlink" title="readint"></a>readint</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool readint(int &amp;ret) &#123;</span><br><span class="line">	int sgn;</span><br><span class="line">	char c;</span><br><span class="line">	c &#x3D; getchar();</span><br><span class="line">	if (c &#x3D;&#x3D; EOF) return false;</span><br><span class="line">	while (c !&#x3D; &#39;-&#39;&amp;&amp;c&lt;&#39;0&#39; || c&gt;&#39;9&#39;) c &#x3D; getchar();</span><br><span class="line">	sgn &#x3D; (c &#x3D;&#x3D; &#39;-&#39;) ? -1 : 1;</span><br><span class="line">	ret &#x3D; (c &#x3D;&#x3D; &#39;-&#39;) ? 0 : (c - &#39;0&#39;);</span><br><span class="line">	while ((c &#x3D; getchar()) &gt;&#x3D; &#39;0&#39;&amp;&amp;c &lt;&#x3D; &#39;9&#39;) ret &#x3D; ret * 10 + (c - &#39;0&#39;);</span><br><span class="line">	ret *&#x3D; sgn;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="readdouble"><a href="#readdouble" class="headerlink" title="readdouble"></a>readdouble</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool readdouble(double &amp;ret) &#123;</span><br><span class="line">	int sgn;</span><br><span class="line">	char c;</span><br><span class="line">	double bit &#x3D; 0.1;&#x2F;&#x2F;小数点后数位的权重</span><br><span class="line">	c &#x3D; getchar();</span><br><span class="line">	if (c &#x3D;&#x3D; EOF) return false;</span><br><span class="line">	while (c !&#x3D; &#39;-&#39;&amp;&amp;c&lt;&#39;0&#39; || c&gt;&#39;9&#39;) c &#x3D; getchar();</span><br><span class="line">	sgn &#x3D; (c &#x3D;&#x3D; &#39;-&#39;) ? -1 : 1;</span><br><span class="line">	ret &#x3D; (c &#x3D;&#x3D; &#39;-&#39;) ? 0 : (c - &#39;0&#39;);</span><br><span class="line">	while ((c &#x3D; getchar()) &gt;&#x3D; &#39;0&#39;&amp;&amp;c &lt;&#x3D; &#39;9&#39;) ret &#x3D; ret * 10 + (c - &#39;0&#39;);</span><br><span class="line">	if (c &#x3D;&#x3D; &#39; &#39; || c &#x3D;&#x3D; &#39;\n&#39;) &#123; ret *&#x3D; sgn; return true; &#125;&#x2F;&#x2F;不存在小数位</span><br><span class="line">	while ((c &#x3D; getchar()) &gt;&#x3D; &#39;0&#39;&amp;&amp;c &lt;&#x3D; &#39;9&#39;) ret +&#x3D; (c - &#39;0&#39;)*bit, bit &#x2F;&#x3D; 10;</span><br><span class="line">	ret *&#x3D; sgn;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="流氓剪枝"><a href="#流氓剪枝" class="headerlink" title="流氓剪枝"></a>流氓剪枝</h2><p>没啥理由的剪枝，以保证不超时</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-数学理论" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E6%95%B0%E5%AD%A6%E7%90%86%E8%AE%BA/"
    >数学理论</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E6%95%B0%E5%AD%A6%E7%90%86%E8%AE%BA/" class="article-date">
  <time datetime="2020-03-30T03:55:19.536Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="数位拆分"><a href="#数位拆分" class="headerlink" title="数位拆分"></a>数位拆分</h1><p>主要注意溢出问题</p>
<h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><h2 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h2><p>将a进制的s转换成b进制输出.输入a,s,b</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000000;</span><br><span class="line">char s[maxn];</span><br><span class="line">char ans[maxn];</span><br><span class="line">const char alp[] &#x3D; &#123; &#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39; &#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">	long long a, b;</span><br><span class="line">	while (scanf(&quot;%lld%s%lld&quot;, &amp;a, s, &amp;b) &#x3D;&#x3D; 3) &#123;</span><br><span class="line">		int cf &#x3D; 1;</span><br><span class="line">		long long ten &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; strlen(s) - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			if (isdigit(s[i])) &#123;</span><br><span class="line">				ten +&#x3D; (s[i] - &#39;0&#39;)*cf;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (s[i] &gt;&#x3D; &#39;a&#39;&amp;&amp;s[i] &lt;&#x3D; &#39;z&#39;) &#123;</span><br><span class="line">				ten +&#x3D; (s[i] - &#39;a&#39;+10)*cf;</span><br><span class="line">			&#125;</span><br><span class="line">			else ten +&#x3D; (s[i] - &#39;A&#39;+10)*cf;</span><br><span class="line">			cf *&#x3D; a;</span><br><span class="line">		&#125;</span><br><span class="line">		int id &#x3D; 0;</span><br><span class="line">		while (ten)</span><br><span class="line">		&#123;</span><br><span class="line">			ans[id++] &#x3D; alp[ten % b];</span><br><span class="line">			ten &#x2F;&#x3D; b;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; id - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			printf(&quot;%c&quot;, ans[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进制转换-1"><a href="#进制转换-1" class="headerlink" title="进制转换"></a>进制转换</h2><p>将不超过30位的非负整数转成二进制</p>
<h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 30 + 5;</span><br><span class="line">char s[maxn];</span><br><span class="line">int ans[20000];</span><br><span class="line">int num[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%s&quot;, s) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; strlen(s); i++)</span><br><span class="line">			num[i] &#x3D; s[i] - &#39;0&#39;;</span><br><span class="line">		int id &#x3D; 0;</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; strlen(s);) &#123;</span><br><span class="line">			int tmp &#x3D; 0, remain &#x3D; 0;</span><br><span class="line">			for (int j &#x3D; i; j &lt; strlen(s); j++) &#123;</span><br><span class="line">				tmp &#x3D; (10 * remain + num[j]) % 2;</span><br><span class="line">				num[j] &#x3D; (10 * remain + num[j]) &#x2F; 2;</span><br><span class="line">				remain &#x3D; tmp;</span><br><span class="line">			&#125;</span><br><span class="line">			ans[id++] &#x3D; remain;</span><br><span class="line">			while (num[i] &#x3D;&#x3D; 0&amp;&amp;i&lt;strlen(s))</span><br><span class="line">				i++;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; id - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			printf(&quot;%d&quot;, ans[i]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="※-Java-※"><a href="#※-Java-※" class="headerlink" title="※ Java ※"></a>※ Java ※</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import  java.util.*;</span><br><span class="line">import java.math.BigInteger;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in&#x3D;new Scanner(System.in);</span><br><span class="line">        while (in.hasNext())&#123;</span><br><span class="line">            String str&#x3D;in.nextLine();</span><br><span class="line">            BigInteger a&#x3D;new BigInteger(str,10);</span><br><span class="line">            System.out.println(a.toString(2));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="补充：求整型a-b并保留任意位小数"><a href="#补充：求整型a-b并保留任意位小数" class="headerlink" title="补充：求整型a/b并保留任意位小数"></a>补充：求整型a/b并保留任意位小数</h3><p>其中res存小数部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int c &#x3D; a % b, cnt &#x3D; 0;</span><br><span class="line">c *&#x3D; 10;</span><br><span class="line">while (cnt &lt; n) &#123;</span><br><span class="line">	res[cnt] &#x3D; c &#x2F; b;</span><br><span class="line">	vis[c] &#x3D; cnt++;</span><br><span class="line">	c %&#x3D; b;</span><br><span class="line">	c *&#x3D; 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h1><h2 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int gcd(int a, int b) &#123;</span><br><span class="line">	if (!b) return a;</span><br><span class="line">	else return gcd(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h1><p>a,b两数的最小公倍数为两数的乘积除以它们的最大公约数</p>
<h2 id="Least-Common-Multiple-EOlymp-1243"><a href="#Least-Common-Multiple-EOlymp-1243" class="headerlink" title="Least Common Multiple EOlymp-1243"></a>Least Common Multiple EOlymp-1243</h2><p>求一系列数的最小公倍数，输入的第一行为测试组数，接下来每行的第一个数为该组数字的个数，数字限定在32bit整型范围内。输出这些数字的最小公倍数。</p>
<p>注意： n等于1直接输出；<strong>尽管a,b都是32bit，但是lcm时，a*b可能大于32b,可以使用long long或者先除法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long </span><br><span class="line">ll gcd(ll a, ll b) &#123;</span><br><span class="line">	if (b &#x3D;&#x3D; 0) return a;</span><br><span class="line">	else return gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	ll a, b, x, n;</span><br><span class="line">	getchar();</span><br><span class="line"></span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		if (n &gt; 1) &#123;</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">			ll  g &#x3D; gcd(a, b);</span><br><span class="line">			ll l &#x3D; a * b &#x2F; g;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; n - 2; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				cin &gt;&gt; x;</span><br><span class="line">				if (l%x &#x3D;&#x3D; 0) continue;</span><br><span class="line">				g &#x3D; gcd(l, x);</span><br><span class="line">				l &#x3D; l * x &#x2F; g;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			cout &lt;&lt; x &lt;&lt; endl;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="素数筛法"><a href="#素数筛法" class="headerlink" title="素数筛法"></a>素数筛法</h1><h2 id="素数判定"><a href="#素数判定" class="headerlink" title="素数判定"></a>素数判定</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool judge(int a) &#123;</span><br><span class="line">	if (a&lt;&#x3D; 1) return false;</span><br><span class="line">	for (int i &#x3D; 2; i &lt; (int)sqrt(a) + 1; i++) &#123;</span><br><span class="line">		if (a%i &#x3D;&#x3D; 0) return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="素数筛法-1"><a href="#素数筛法-1" class="headerlink" title="素数筛法"></a>素数筛法</h2><p>要输出不超过n的所有素数，方法是当我们得到一个素数时，即将它的所有倍数均标记为非素数，这样当我们遍历到每一个数时，它没有被任何其他的素数标记为非素数，则我们确定其为素数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">memset(notp, 0, sizeof(notp));</span><br><span class="line">		for (int i &#x3D;2; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">;			if (!notp[i]) &#123;</span><br><span class="line">				for (int j &#x3D; 2; i*j &lt; n; j++)</span><br><span class="line">					notp[i*j] &#x3D; 1;</span><br><span class="line">				if (i % 10 &#x3D;&#x3D; 1) printf(&quot;%d &quot;, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Goldbach’s-Conjecture"><a href="#Goldbach’s-Conjecture" class="headerlink" title="Goldbach’s Conjecture"></a>Goldbach’s Conjecture</h2><p>别忘了打表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; (1 &lt;&lt; 15) + 5;</span><br><span class="line">bool notp[maxn];</span><br><span class="line">int sum[maxn];</span><br><span class="line">int prime[maxn];</span><br><span class="line">int get_ans() &#123;</span><br><span class="line">	memset(sum, 0, sizeof(sum));</span><br><span class="line">	int id &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 2; i &lt; maxn; i++) &#123;</span><br><span class="line">		if (!notp[i]) &#123;</span><br><span class="line">			for (int j &#x3D; 2; i*j &lt; maxn; j++)</span><br><span class="line">				notp[i*j] &#x3D; 1;</span><br><span class="line">			prime[id++] &#x3D; i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int ix &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; id; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; id; j++) &#123;</span><br><span class="line">			int h &#x3D; prime[i] + prime[j];</span><br><span class="line">			if (h &lt; maxn) &#123;</span><br><span class="line">				sum[h]++;</span><br><span class="line">				if (i &#x3D;&#x3D; j) sum[h]++;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return ix;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	int r &#x3D; get_ans();</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;n)&#x3D;&#x3D;1&amp;&amp;n)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d\n&quot;, sum[n]&#x2F;2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h1><p>1不是N的质因数；若N为质数，N是N的质因数</p>
<h2 id="质因数的个数"><a href="#质因数的个数" class="headerlink" title="质因数的个数"></a>质因数的个数</h2><p>求正整数N(N&gt;1)的质因数的个数。 相同的质因数需要重复计算。如120=2*2*2*3*5，共有5个质因数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100000;</span><br><span class="line">bool notp[maxn];</span><br><span class="line">int prime[maxn];</span><br><span class="line">int res[maxn];</span><br><span class="line">int get_ans() &#123;</span><br><span class="line">	int id &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 2; i &lt; maxn; i++) &#123;</span><br><span class="line">		if (!notp[i]) &#123;</span><br><span class="line">			for (int j &#x3D; 2; i*j &lt; maxn; j++)</span><br><span class="line">				notp[i*j] &#x3D; 1;</span><br><span class="line">			prime[id++] &#x3D; i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return id;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	int r &#x3D; get_ans();</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		int id &#x3D; 0;</span><br><span class="line">		memset(res, 0, sizeof(res));</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">			if (n%prime[i] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				while (n%prime[i] &#x3D;&#x3D; 0)</span><br><span class="line">				&#123;</span><br><span class="line">					res[id]++;</span><br><span class="line">					n &#x2F;&#x3D; prime[i];</span><br><span class="line">				&#125;</span><br><span class="line">				id++;</span><br><span class="line">			&#125;</span><br><span class="line">			if (n &#x3D;&#x3D; 1) break;</span><br><span class="line">		&#125;</span><br><span class="line">		if (n !&#x3D; 1) res[id++] &#x3D; 1;&#x2F;&#x2F;若测试完2~maxn内的所有素数，n仍未被分解成1</span><br><span class="line">							&#x2F;&#x2F;则剩余的余数是一定大于maxn素因数，幂次只能为1</span><br><span class="line"></span><br><span class="line">		int sum &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; id; i++)</span><br><span class="line">			sum +&#x3D; res[i];</span><br><span class="line">		printf(&quot;%d\n&quot;, sum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>maxn取1e5而不是题干中的1e9是因为，对于每个N至多有一个大于sqrt(n)的素因数，这样只需要将小于sqrt(n)的数都除去，剩下的就是该大素因数了。</li>
</ol>
<h2 id="整除问题"><a href="#整除问题" class="headerlink" title="整除问题"></a>整除问题</h2><p>给定n，a求最大的k，使n！可以被a^k整除但不能被a^(k+1)整除。<br>输入两个整数n(2&lt;=n&lt;=1000)，a(2&lt;=a&lt;=1000)<br>输出一个整数</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>由于n!和a^k都可能很大，所以不能直接相除来判断</li>
<li>考虑整除的特征：将n!和a分别分解成素因数的乘积。如果a能整除b，则b/a是整数，则说明a和b中的素因数种类应该相同(两个素数互质)，并且b中素因数pi的幂次应该大于等于a中pi的幂次。之后，确定b中该素因数的幂次是a中对应素因数幂次的几倍，这样最小的那个数即为所求的k。</li>
<li>由于n!很大，所以不能对n!进行素因数分解。现在的目标是想确定n!中含有的素因数p对应的幂指数。n!中每一个素因数p的倍数都至少贡献一个p因子，且1到n中p的倍数共有n/p个，则p因子数至少为n/p个。同理有n/(p*p)个整数至少贡献了两个p因子。</li>
<li>统计所有n!因子中幂次最小的即为所求的k</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">bool notp[maxn];</span><br><span class="line">int prime[maxn];</span><br><span class="line">int res[maxn];</span><br><span class="line">int cnta[maxn];</span><br><span class="line">int get_ans() &#123;&#x2F;&#x2F;求范围内所有的素数</span><br><span class="line">	int id &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 2; i &lt; maxn; i++) &#123;</span><br><span class="line">		if (!notp[i]) &#123;</span><br><span class="line">			for (int j &#x3D; 2; i*j &lt; maxn; j++)</span><br><span class="line">				notp[i*j] &#x3D; 1;</span><br><span class="line">			prime[id++] &#x3D; i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return id;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int a, b;</span><br><span class="line">	int r &#x3D; get_ans();</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;b, &amp;a) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(res, 0, sizeof(res));</span><br><span class="line">		memset(cnta, 0, sizeof(cnta));</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;分解n!</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">			int n &#x3D; b;</span><br><span class="line">			while (n)</span><br><span class="line">			&#123;</span><br><span class="line">				res[i]+&#x3D;n&#x2F;prime[i];</span><br><span class="line">				n &#x2F;&#x3D; prime[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int ans &#x3D; 1e8;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;分解a</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">			if (a%prime[i] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				while (a%prime[i] &#x3D;&#x3D; 0)</span><br><span class="line">				&#123;</span><br><span class="line">					cnta[i]++;</span><br><span class="line">					a &#x2F;&#x3D; prime[i];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if (cnta[i] &#x3D;&#x3D; 0) continue;</span><br><span class="line">			ans &#x3D; min(ans, res[i] &#x2F; cnta[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="约数的个数"><a href="#约数的个数" class="headerlink" title="约数的个数"></a>约数的个数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int get_ans(int n) &#123;</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	int i;</span><br><span class="line">	for (i &#x3D; 1; i*i &lt; n; i++)</span><br><span class="line">		if (n%i &#x3D;&#x3D; 0) ans +&#x3D; 2;</span><br><span class="line">	if (i*i &#x3D;&#x3D; n) ans++;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T,n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		printf(&quot;%d\n&quot;, get_ans(n));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二分求幂"><a href="#二分求幂" class="headerlink" title="二分求幂"></a>二分求幂</h1><h2 id="人见人爱A-B"><a href="#人见人爱A-B" class="headerlink" title="人见人爱A^B"></a>人见人爱A^B</h2><p>求A^B的最后三位数表示的整数。说明：A^B的含义是“A的B次方” </p>
<p>输入数据包含多个测试实例，每个实例占一行，由两个正整数A和B组成（1&lt;=A,B&lt;=10000），如果A=0, B=0，则表示输入数据的结束，不做处理。</p>
<p>对于每个测试实例，请输出A^B的最后三位表示的整数，每个输出占一行。 </p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>由于a,b比较大，所以不能直接求。注意到A^B的后三位只与A的后三位有关，只存后三位即可。</li>
<li>由于A^j可以由A^i次得到，可以借此减少计算次数。可到的幂次包括1,2,4,8…即a^k次是可以由a的1次不断求平方得到的。我们的目标是即分解a的b次变为若干个a的2^k次的积，并尽可能减少分解结果的个数。指数层面就是若2^k次的和，即二进制。可以将幂次转成二进制数，取那些为1的位</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int a, b;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;a, &amp;b) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		if (a &#x3D;&#x3D; 0 &amp;&amp; b &#x3D;&#x3D; 0) break;</span><br><span class="line">		int ans &#x3D; 1;</span><br><span class="line">		while (b)</span><br><span class="line">		&#123;</span><br><span class="line">			if (b % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">				ans *&#x3D; a;</span><br><span class="line">				ans %&#x3D; 1000;</span><br><span class="line">			&#125;</span><br><span class="line">			b &#x2F;&#x3D; 2;</span><br><span class="line">			a *&#x3D; a;	&#x2F;&#x2F;更新权重</span><br><span class="line">			a %&#x3D; 1000;	&#x2F;&#x2F;保留后三位</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HDU-2817"><a href="#HDU-2817" class="headerlink" title="HDU 2817"></a>HDU 2817</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1 &lt;&lt; 16;</span><br><span class="line">int a[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	long long a, b, c, k;</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%lld%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c, &amp;k);</span><br><span class="line">		if (b - a &#x3D;&#x3D; c - b) &#123;</span><br><span class="line">			long long tmp &#x3D; (b - a) % 200907;</span><br><span class="line">			a %&#x3D; 200907;</span><br><span class="line">			printf(&quot;%lld\n&quot;, (a + (k - 1)*tmp) % 200907);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;	</span><br><span class="line">			long long ans &#x3D; 1;</span><br><span class="line">			long long t &#x3D; a;</span><br><span class="line">			a &#x3D; b &#x2F; a;</span><br><span class="line">			k--;</span><br><span class="line">			while (k)</span><br><span class="line">			&#123;</span><br><span class="line">				if (k % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">					ans *&#x3D; a;</span><br><span class="line">					ans %&#x3D; 200907;</span><br><span class="line">				&#125;</span><br><span class="line">				k &#x2F;&#x3D; 2;</span><br><span class="line">				a *&#x3D; a;</span><br><span class="line">				a %&#x3D; 200907;</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;%lld\n&quot;,((t% 200907)* ans)% 200907);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="高精度整数"><a href="#高精度整数" class="headerlink" title="高精度整数"></a>高精度整数</h1><h2 id="大整数类"><a href="#大整数类" class="headerlink" title="大整数类"></a>大整数类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class BigInteger &#123;</span><br><span class="line">private:</span><br><span class="line">	const static int maxn &#x3D; 1000;</span><br><span class="line">	int digit[maxn];</span><br><span class="line">	int size;	&#x2F;&#x2F;[0,size)</span><br><span class="line"></span><br><span class="line">	void init() &#123;</span><br><span class="line">		memset(digit, 0, sizeof(digit));</span><br><span class="line">		size &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	void set(char s[]) &#123;</span><br><span class="line">		init();</span><br><span class="line">		int len &#x3D; strlen(s);</span><br><span class="line">		for (int i &#x3D; len - 1, j &#x3D; 0, t &#x3D; 0, c &#x3D; 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			t +&#x3D; (s[i] - &#39;0&#39;)*c;</span><br><span class="line">			c *&#x3D; 10;</span><br><span class="line">			j++;</span><br><span class="line">			if (j &#x3D;&#x3D; 4 || i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				digit[size++] &#x3D; t;</span><br><span class="line">				j &#x3D; 0;</span><br><span class="line">				t &#x3D; 0;</span><br><span class="line">				c &#x3D; 1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void output() &#123;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			if (i !&#x3D; size - 1)</span><br><span class="line">				printf(&quot;%04d&quot;, digit[i]);	&#x2F;&#x2F;不是最高位则输出前导0</span><br><span class="line">			else printf(&quot;%d&quot;, digit[i]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BigInteger operator + (const BigInteger A) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; A.size || i &lt; size; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] + A.digit[i] + cf;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BigInteger operator * (const BigInteger &amp;A) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; A.size; j++) &#123;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">				int t &#x3D; digit[i] * A.digit[j] + cf;</span><br><span class="line">				cf &#x3D; t &#x2F; 10000;</span><br><span class="line">				ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool operator &lt; (const BigInteger&amp; A) const &#123;</span><br><span class="line">		if (A.size !&#x3D; size) return size &lt; A.size;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			if (digit[i] !&#x3D; A.digit[i])</span><br><span class="line">				return digit[i] &lt; A.digit[i];</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator &gt; (const BigInteger&amp; A) const &#123; return A &lt; *this; &#125;</span><br><span class="line">	bool operator &lt;&#x3D;(const BigInteger&amp; A) const &#123; return !(A &lt; *this); &#125;</span><br><span class="line">	bool operator &gt;&#x3D;(const BigInteger&amp; A) const &#123; return !(*this &lt; A); &#125;</span><br><span class="line">	bool operator !&#x3D;(const BigInteger&amp; A) const &#123; return *this &lt; A || A &lt; *this; &#125;</span><br><span class="line">	bool operator &#x3D;&#x3D;(const BigInteger&amp; A) const &#123; return !(*this &lt; A) &amp;&amp; !(A &lt; *this); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="N的阶乘"><a href="#N的阶乘" class="headerlink" title="N的阶乘"></a>N的阶乘</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BigInteger operator * (int a) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; size ; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] * a + cf;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;n)&#x3D;&#x3D;1) &#123;</span><br><span class="line">		BigInteger x, y;</span><br><span class="line">		char a[] &#x3D; &quot;1&quot;;</span><br><span class="line">		x.set(a);</span><br><span class="line">		for (int i &#x3D; 2; i &lt;&#x3D; n; i++)</span><br><span class="line">			x&#x3D; x * i;</span><br><span class="line">		x.output();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进制转换-清华"><a href="#进制转换-清华" class="headerlink" title="进制转换(清华)"></a>进制转换(清华)</h2><ol>
<li>重载了对整型的除法和取余，注意这两部分写法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">class BigInteger &#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">	void init() &#123;</span><br><span class="line">		memset(digit, 0, sizeof(digit));</span><br><span class="line">		size &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	const static int maxn &#x3D; 10000 + 5;</span><br><span class="line">	int digit[maxn];</span><br><span class="line">	int size;</span><br><span class="line">	void set(char s[]) &#123;</span><br><span class="line">		init();</span><br><span class="line">		int len &#x3D; strlen(s);</span><br><span class="line">		for (int i &#x3D; len - 1, j &#x3D; 0, t &#x3D; 0, c &#x3D; 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			t +&#x3D; (s[i] - &#39;0&#39;)*c;</span><br><span class="line">			c *&#x3D; 10;</span><br><span class="line">			j++;</span><br><span class="line">			if (j &#x3D;&#x3D; 4 || i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				digit[size++] &#x3D; t;</span><br><span class="line">				j &#x3D; 0;</span><br><span class="line">				t &#x3D; 0;</span><br><span class="line">				c &#x3D; 1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void output() &#123;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			if (i !&#x3D; size - 1)</span><br><span class="line">				printf(&quot;%04d&quot;, digit[i]);	&#x2F;&#x2F;不是最高位则输出前导0</span><br><span class="line">			else printf(&quot;%d&quot;, digit[i]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BigInteger operator + (const BigInteger A) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; A.size || i &lt; size; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] + A.digit[i] + cf;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BigInteger operator * (int a) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] * a + cf;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">	BigInteger operator * (const BigInteger &amp;A) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; A.size; j++) &#123;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">				int t &#x3D; digit[i] * A.digit[j] + cf;</span><br><span class="line">				cf &#x3D; t &#x2F; 10000;</span><br><span class="line">				ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对整型除法和取模</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	BigInteger operator &#x2F; (const int a) &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int remain &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			int t &#x3D; (remain * 10000 + digit[i]) &#x2F; a;</span><br><span class="line">			int r &#x3D; (remain * 10000 + digit[i]) % a;</span><br><span class="line">			ret.digit[i] &#x3D; t;</span><br><span class="line">			remain &#x3D; r;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			if (digit[i] !&#x3D; 0) &#123;</span><br><span class="line">				ret.size &#x3D; i;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		ret.size++;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int operator % (int x) const &#123;</span><br><span class="line">		int remain &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			int t &#x3D; (remain * 10000 + digit[i]) &#x2F; x;</span><br><span class="line">			int r &#x3D; (remain * 10000 + digit[i]) % x;</span><br><span class="line">			remain &#x3D; r;</span><br><span class="line">		&#125;</span><br><span class="line">		return remain;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool operator &lt; (const BigInteger&amp; A) const &#123;</span><br><span class="line">		if (A.size !&#x3D; size) return size &lt; A.size;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			if (digit[i] !&#x3D; A.digit[i])</span><br><span class="line">				return digit[i] &lt; A.digit[i];</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator &gt; (const BigInteger&amp; A) const &#123; return A &lt; *this; &#125;</span><br><span class="line">	bool operator &lt;&#x3D;(const BigInteger&amp; A) const &#123; return !(A &lt; *this); &#125;</span><br><span class="line">	bool operator &gt;&#x3D;(const BigInteger&amp; A) const &#123; return !(*this &lt; A); &#125;</span><br><span class="line">	bool operator !&#x3D;(const BigInteger&amp; A) const &#123; return *this &lt; A || A &lt; *this; &#125;</span><br><span class="line">	bool operator &#x3D;&#x3D;(const BigInteger&amp; A) const &#123; return !(*this &lt; A) &amp;&amp; !(A &lt; *this); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">char s[10000];</span><br><span class="line">char ans[10000];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int m, n;</span><br><span class="line">	while (scanf(&quot;%d%d\n&quot;, &amp;m, &amp;n) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">		scanf(&quot;%s&quot;, s);</span><br><span class="line">		BigInteger a, b;</span><br><span class="line">		char s1[] &#x3D; &quot;0&quot;, s2[] &#x3D; &quot;1&quot;;</span><br><span class="line">		a.set(s1);	&#x2F;&#x2F;用来保存m进制转成的十进制数</span><br><span class="line">		b.set(s2);	&#x2F;&#x2F;记录转成10进制时候的权重</span><br><span class="line">		int len &#x3D; strlen(s);</span><br><span class="line">		for (int i &#x3D; len - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			int t;</span><br><span class="line">			if (s[i] &gt;&#x3D; &#39;0&#39;&amp;&amp;s[i] &lt;&#x3D; &#39;9&#39;)</span><br><span class="line">				t &#x3D; s[i] - &#39;0&#39;;</span><br><span class="line">			else t &#x3D; s[i] - &#39;A&#39; + 10;</span><br><span class="line">			a &#x3D; a + b * t;</span><br><span class="line">			b &#x3D; b * m;</span><br><span class="line">		&#125;</span><br><span class="line">		int id &#x3D; 0;</span><br><span class="line">		do &#123;</span><br><span class="line">			int t &#x3D; a % n;</span><br><span class="line">			if (t &gt;&#x3D; 10) ans[id] &#x3D; t - 10 + &#39;a&#39;;</span><br><span class="line">			else ans[id] &#x3D; t + &#39;0&#39;;</span><br><span class="line">			a &#x3D; a &#x2F; n;</span><br><span class="line">			id++;</span><br><span class="line">		&#125; while (a.digit[0] !&#x3D; 0 || a.size !&#x3D; 1);</span><br><span class="line">		for (int i &#x3D; id - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			printf(&quot;%c&quot;, ans[i]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="大整数取余小数简单代码"><a href="#大整数取余小数简单代码" class="headerlink" title="大整数取余小数简单代码"></a>大整数取余小数简单代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void get_mod(int x) &#123;&#x2F;&#x2F;其中大整数已经由高位到低位依次存在了str中</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; strlen(str); i++) &#123;</span><br><span class="line">		ans *&#x3D; 10;</span><br><span class="line">		ans +&#x3D; str[i] - &#39;0&#39;;</span><br><span class="line">		ans %&#x3D; mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="浮点数加法"><a href="#浮点数加法" class="headerlink" title="浮点数加法"></a>浮点数加法</h2><p>求2个浮点数相加的和 题目中输入输出中出现浮点数都有如下的形式： P1P2…Pi.Q1Q2…Qj 对于整数部分，P1P2…Pi是一个非负整数 对于小数部分，Qj不等于0</p>
<p>输入： 对于每组案例，每组测试数据占2行，分别是两个加数。</p>
<p>输出： 每组案例是n行，每组测试数据有一行输出是相应的和。输出保证一定是一个小数部分不为0的浮点数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在上述BigInteger中加入对整型的重载加法</span><br><span class="line">BigInteger operator + (const int aa) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		int a &#x3D; aa;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] + a + cf;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">			if (!cf) a &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000000;</span><br><span class="line">char a[maxn], b[maxn];</span><br><span class="line">BigInteger a1, a2, b1, b2;</span><br><span class="line"></span><br><span class="line">inline int get_len(int xx) &#123;</span><br><span class="line">	int len &#x3D; 0;</span><br><span class="line">	while (xx)</span><br><span class="line">	&#123;</span><br><span class="line">		len++;</span><br><span class="line">		xx &#x2F;&#x3D; 10;</span><br><span class="line">	&#125;</span><br><span class="line">	return len;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	string x, y;</span><br><span class="line">	while (getline(cin, x)) &#123;</span><br><span class="line">		getline(cin, y);</span><br><span class="line">		int id &#x3D; x.find(&quot;.&quot;);</span><br><span class="line">		int ix &#x3D; y.find(&quot;.&quot;);</span><br><span class="line">		string s1 &#x3D; x.substr(id + 1).c_str();</span><br><span class="line">		string s2 &#x3D; y.substr(ix + 1).c_str();</span><br><span class="line">		int delen &#x3D; abs(int(s1.length() - s2.length()));</span><br><span class="line">		if (delen)&#x2F;&#x2F;将小数部分补齐成相同位数</span><br><span class="line">			if (s1.length() &lt; s2.length())</span><br><span class="line">				for (int i &#x3D; 0; i &lt; delen; i++)</span><br><span class="line">					s1 +&#x3D; &#39;0&#39;;</span><br><span class="line">			else</span><br><span class="line">				for (int i &#x3D; 0; i &lt; delen; i++)</span><br><span class="line">					s2 +&#x3D; &#39;0&#39;;</span><br><span class="line">		strcpy(a, x.substr(0, id).c_str());</span><br><span class="line">		strcpy(b, s1.c_str());</span><br><span class="line">		a1.set(a);</span><br><span class="line">		a2.set(b);</span><br><span class="line">		strcpy(a, y.substr(0, ix).c_str());</span><br><span class="line">		strcpy(b, s2.c_str());</span><br><span class="line">		b1.set(a);</span><br><span class="line">		b2.set(b);</span><br><span class="line"></span><br><span class="line">		BigInteger t &#x3D; a2 + b2;</span><br><span class="line">		int c &#x3D; 0;</span><br><span class="line">		int len &#x3D; 1;</span><br><span class="line">		int l1, l2;</span><br><span class="line">		l1 &#x3D; get_len(a2.digit[a2.size - 1]);</span><br><span class="line">		l1 &#x3D; max(l1, get_len(b2.digit[b2.size - 1]));</span><br><span class="line">		&#x2F;&#x2F;如果小数部分位数增加说明有进位。需要置进位位并在小数高位减去相应的值。</span><br><span class="line">		&#x2F;&#x2F;具体又分为两种情况</span><br><span class="line">		if (t.size &#x3D;&#x3D; a2.size) &#123;</span><br><span class="line">			l2 &#x3D; get_len(t.digit[t.size - 1]);</span><br><span class="line">			if (l1 !&#x3D; l2)</span><br><span class="line">			&#123;</span><br><span class="line">				c &#x3D; 1;</span><br><span class="line">				int xx &#x3D; b2.digit[b2.size - 1];</span><br><span class="line">				while (xx)</span><br><span class="line">				&#123;</span><br><span class="line">					len *&#x3D; 10;</span><br><span class="line">					xx &#x2F;&#x3D; 10;</span><br><span class="line">				&#125;</span><br><span class="line">				t.digit[t.size - 1] -&#x3D; len;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			c &#x3D; 1;</span><br><span class="line">			t.size--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		len &#x3D; l1 - get_len(t.digit[t.size - 1]);&#x2F;&#x2F;用于控制输出小数时的前导0</span><br><span class="line">		a2 &#x3D; a1 + b1;</span><br><span class="line">		a2 &#x3D; a2 + c;</span><br><span class="line">		a2.output();</span><br><span class="line">		printf(&quot;.&quot;);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">			printf(&quot;0&quot;);</span><br><span class="line">		t.output();</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10进制-vs-2进制"><a href="#10进制-vs-2进制" class="headerlink" title="10进制 vs 2进制"></a>10进制 vs 2进制</h2><p>代码都是前面提及的。<strong>但是发现在output函数中，可能输出前导0，所以加入判定条件改为：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void output() &#123;</span><br><span class="line">	for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">		if (i !&#x3D; size - 1)</span><br><span class="line">			printf(&quot;%04d&quot;, digit[i]);	&#x2F;&#x2F;不是最高位则输出前导0</span><br><span class="line">		else if(digit[i])</span><br><span class="line">			printf(&quot;%d&quot;, digit[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;本题主函数</span><br><span class="line"></span><br><span class="line">char s[1005];</span><br><span class="line">bool two[1000000000];</span><br><span class="line">int main() &#123;</span><br><span class="line">	scanf(&quot;%s&quot;, s);</span><br><span class="line">	BigInteger a, b;</span><br><span class="line">	a.set(s);</span><br><span class="line">	int id &#x3D; 0;</span><br><span class="line">	do</span><br><span class="line">	&#123;</span><br><span class="line">		two[id++] &#x3D; a % 2;</span><br><span class="line">		a &#x3D; a &#x2F; 2;</span><br><span class="line"></span><br><span class="line">	&#125; while (a.size !&#x3D; 1 || a.digit[0] !&#x3D; 0);</span><br><span class="line">	char xx[] &#x3D; &quot;0&quot;, yy[] &#x3D; &quot;1&quot;;</span><br><span class="line">	a.set(xx);&#x2F;&#x2F;0</span><br><span class="line">	b.set(yy);&#x2F;&#x2F;1</span><br><span class="line">	for (int i &#x3D; id - 1; i &gt;&#x3D; 0;i--) &#123;</span><br><span class="line"></span><br><span class="line">		a &#x3D; a + b * two[i];</span><br><span class="line">		b &#x3D; b * 2;</span><br><span class="line">	&#125;</span><br><span class="line">	a.output();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-数据结构" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"
    >数据结构</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2020-03-30T03:55:19.536Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h2><p>在某个字符串（长度不超过100）中有左括号、右括号和大小写字母；规定（与常见的算数式子一样）任何一个左括号都从内到外与在它右边且距离最近的右括号匹配。写一个程序，找到无法匹配的左括号和右括号，输出原来字符串，并在下一行标出不能匹配的括号。不能匹配的左括号用”$”标注,不能匹配的右括号用”?”标注。 </p>
<h3 id="栈中存索引"><a href="#栈中存索引" class="headerlink" title="栈中存索引"></a>栈中存索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">char s[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%s&quot;, s) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">		printf(&quot;%s\n&quot;, s);</span><br><span class="line">		stack&lt;int&gt; st;</span><br><span class="line">		char ans[maxn];</span><br><span class="line">		for (int i &#x3D; 0;i&lt;strlen(s);i++) &#123;</span><br><span class="line">			if (s[i] &#x3D;&#x3D; &#39;(&#39;) &#123;</span><br><span class="line">				ans[i] &#x3D; &#39; &#39;;</span><br><span class="line">				st.push(i);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			else if (s[i] &#x3D;&#x3D; &#39;)&#39;) &#123;</span><br><span class="line">				if (!st.empty()&amp;&amp;s[st.top()] &#x3D;&#x3D; &#39;(&#39;) &#123;</span><br><span class="line">					ans[i] &#x3D; &#39; &#39;;</span><br><span class="line">					st.pop();</span><br><span class="line">				&#125;</span><br><span class="line">				else </span><br><span class="line">					ans[i] &#x3D; &#39;?&#39;;</span><br><span class="line">			&#125;</span><br><span class="line">			else ans[i] &#x3D; &#39; &#39;;</span><br><span class="line">		&#125;</span><br><span class="line">		while (!st.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			ans[st.top()] &#x3D; &#39;$&#39;;</span><br><span class="line">			st.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		ans[strlen(s)] &#x3D; &#39;\0&#39;;</span><br><span class="line">		printf(&quot;%s\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单计算器"><a href="#简单计算器" class="headerlink" title="简单计算器"></a>简单计算器</h2><p> 读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。</p>
<p>没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。</p>
<p> 对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>开一个运算符栈一个操作数栈。主要在于判断各符号间的优先级，当当前读取的符号优先级低于栈顶的时候，应该先把栈顶运算符用了。其他都是小的细节问题。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 200 + 5;</span><br><span class="line">char s[maxn];</span><br><span class="line">bool is_op(char c) &#123; return c &#x3D;&#x3D; &#39;+&#39; || c &#x3D;&#x3D; &#39;-&#39; || c &#x3D;&#x3D; &#39;*&#39; || c &#x3D;&#x3D; &#39;&#x2F;&#39;; &#125;</span><br><span class="line">bool first(char a, char b) &#123;</span><br><span class="line">	if (a &#x3D;&#x3D; &#39;*&#39; || a &#x3D;&#x3D; &#39;&#x2F;&#39;)</span><br><span class="line">		return true;</span><br><span class="line">	else if (a &#x3D;&#x3D; &#39;-&#39; || a &#x3D;&#x3D; &#39;+&#39;) &#123;</span><br><span class="line">		if (b !&#x3D; &#39;*&#39; &amp;&amp; b !&#x3D; &#39;&#x2F;&#39;)</span><br><span class="line">			return true;</span><br><span class="line">		else return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">double calu(double a, double b, char op) &#123;</span><br><span class="line">	switch (op) &#123;</span><br><span class="line">	case &#39;+&#39;:return a + b; break;</span><br><span class="line">	case &#39;-&#39;:return a - b; break;</span><br><span class="line">	case &#39;*&#39;:return a * b; break;</span><br><span class="line">	case &#39;&#x2F;&#39;:return a &#x2F; b; break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (cin.getline(s, 201) &amp;&amp; s[0] !&#x3D; &#39;0&#39;) &#123;</span><br><span class="line">		stack&lt;double&gt; num;</span><br><span class="line">		stack&lt;char&gt; op;</span><br><span class="line">		int index &#x3D; 0;</span><br><span class="line">		while (index &lt; strlen(s)) &#123;</span><br><span class="line">			if (s[index] &#x3D;&#x3D; &#39; &#39;) index++;</span><br><span class="line">			int n &#x3D; 0;</span><br><span class="line">			while (isdigit(s[index]))</span><br><span class="line">			&#123;</span><br><span class="line">				n *&#x3D; 10;</span><br><span class="line">				n +&#x3D; s[index++] - &#39;0&#39;;</span><br><span class="line">			&#125;</span><br><span class="line">			if (n) num.push(n);</span><br><span class="line">			else &#123;</span><br><span class="line">				if (op.empty()) op.push(s[index]);</span><br><span class="line">				else &#123;</span><br><span class="line"></span><br><span class="line">					while (!op.empty() &amp;&amp; first(op.top(), s[index]))</span><br><span class="line">					&#123;</span><br><span class="line">						double a &#x3D; num.top(); num.pop();</span><br><span class="line">						double b &#x3D; num.top(); num.pop();</span><br><span class="line">						char oper;</span><br><span class="line">						oper &#x3D; op.top(); op.pop();</span><br><span class="line">						num.push(calu(b, a, oper));</span><br><span class="line">					&#125;</span><br><span class="line">					op.push(s[index]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">				index++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		while (!op.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			char oper &#x3D; op.top(); op.pop();</span><br><span class="line">			double a &#x3D; num.top(); num.pop();</span><br><span class="line">			double b &#x3D; num.top(); num.pop();</span><br><span class="line">			double ans &#x3D; calu(b, a, oper);</span><br><span class="line">			num.push(ans);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;%.2lf\n&quot;, num.top());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>使用递减的优先级队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;搬水果</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pq;</span><br><span class="line"></span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n)&#x3D;&#x3D;1 &amp;&amp;n) &#123;</span><br><span class="line">		int x;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">			pq.push(x);</span><br><span class="line">		&#125;</span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		while (pq.size()&gt;1) &#123;</span><br><span class="line">			int a &#x3D; pq.top(); pq.pop();</span><br><span class="line">			int b &#x3D; pq.top(); pq.pop();</span><br><span class="line">			ans +&#x3D; a + b;</span><br><span class="line">			pq.push(a + b);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树遍历-华科"><a href="#二叉树遍历-华科" class="headerlink" title="二叉树遍历 华科"></a>二叉树遍历 华科</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 26 + 1;</span><br><span class="line">char pre[maxn], in[maxn];</span><br><span class="line"></span><br><span class="line">typedef struct node &#123;</span><br><span class="line">	struct node *lchild, *rchild;</span><br><span class="line">	char data;</span><br><span class="line">&#125;node, *ptr;</span><br><span class="line"></span><br><span class="line">ptr create(char *pre, char *in, int n) &#123;</span><br><span class="line">	ptr s;</span><br><span class="line">	if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">		s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">		s-&gt;data &#x3D; *pre;</span><br><span class="line">		s-&gt;rchild &#x3D; s-&gt;lchild &#x3D; NULL;</span><br><span class="line">		return s;</span><br><span class="line">	&#125;</span><br><span class="line">	char *p;</span><br><span class="line">	for (p &#x3D; in; p &lt; in + n; p++)</span><br><span class="line">		if (*p &#x3D;&#x3D; *pre) break;</span><br><span class="line">	int k &#x3D; p - in;</span><br><span class="line"></span><br><span class="line">	s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">	s-&gt;data &#x3D; *p;</span><br><span class="line">	s-&gt;rchild &#x3D; s-&gt;lchild &#x3D; NULL;</span><br><span class="line">	if (k) s-&gt;lchild &#x3D; create(pre + 1, in, k);</span><br><span class="line">	if (n - k - 1) s-&gt;rchild &#x3D; create(pre + k + 1, p + 1, n - k - 1);</span><br><span class="line">	return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void post_order(ptr T) &#123;</span><br><span class="line">	if (T-&gt;lchild) post_order(T-&gt;lchild);</span><br><span class="line">	if (T-&gt;rchild)post_order(T-&gt;rchild);</span><br><span class="line">	printf(&quot;%c&quot;, T-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%s&quot;, pre) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">		scanf(&quot;%s&quot;, in);</span><br><span class="line">		ptr T &#x3D; create(&amp;pre[0], &amp;in[0], strlen(pre));</span><br><span class="line">		post_order(T);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树遍历-清华"><a href="#二叉树遍历-清华" class="headerlink" title="二叉树遍历 清华"></a>二叉树遍历 清华</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 1;</span><br><span class="line">char pre[maxn];</span><br><span class="line">typedef struct node &#123;</span><br><span class="line">	struct node *lchild, *rchild;</span><br><span class="line">	char data;</span><br><span class="line">&#125;node, *ptr;</span><br><span class="line">ptr create(int &amp;cur, const char * pre, int n) &#123;</span><br><span class="line">	if (cur &#x3D;&#x3D; n || pre[cur] &#x3D;&#x3D; &#39;#&#39;) return NULL;</span><br><span class="line"></span><br><span class="line">	ptr s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">	s-&gt;data &#x3D; pre[cur];</span><br><span class="line">	cur++;</span><br><span class="line">	s-&gt;lchild &#x3D; create(cur, pre, n);</span><br><span class="line">	cur++;</span><br><span class="line">	s-&gt;rchild &#x3D; create(cur, pre, n);</span><br><span class="line">	return s;</span><br><span class="line">&#125;</span><br><span class="line">void in_order(ptr T) &#123;</span><br><span class="line">	if (T-&gt;lchild !&#x3D; NULL) in_order(T-&gt;lchild);</span><br><span class="line">	printf(&quot;%c &quot;, T-&gt;data);</span><br><span class="line">	if (T-&gt;rchild !&#x3D; NULL) in_order(T-&gt;rchild);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%s&quot;, pre) &#x3D;&#x3D; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		int a &#x3D; 0;</span><br><span class="line">		ptr T &#x3D; create(a, pre, strlen(pre));</span><br><span class="line">		in_order(T);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><h2 id="创建二叉排序树"><a href="#创建二叉排序树" class="headerlink" title="创建二叉排序树"></a>创建二叉排序树</h2><p><strong>此处是递归的逐个节点比较。由于二叉排序树的特殊性，也可以使用前中序遍历序列或中后序遍历序列比较</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct node &#123;</span><br><span class="line">	struct node *lchild, *rchild;</span><br><span class="line">	int data;</span><br><span class="line">&#125;node, *ptr;</span><br><span class="line"></span><br><span class="line">ptr insert(ptr T, int x) &#123;</span><br><span class="line">	if (T &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		T &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">		T-&gt;data &#x3D; x;</span><br><span class="line">		T-&gt;lchild &#x3D; T-&gt;rchild &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		if (x &gt; T-&gt;data)</span><br><span class="line">			T-&gt;rchild &#x3D; insert(T-&gt;rchild, x);</span><br><span class="line">		else if (x &lt; T-&gt;data)</span><br><span class="line">			T-&gt;lchild &#x3D; insert(T-&gt;lchild, x);</span><br><span class="line">	&#125;</span><br><span class="line">	return T;</span><br><span class="line">&#125;</span><br><span class="line">void pre_order(ptr T) &#123;</span><br><span class="line">	printf(&quot;%d &quot;, T-&gt;data);</span><br><span class="line">	if (T-&gt;lchild !&#x3D; NULL) pre_order(T-&gt;lchild);</span><br><span class="line">	if (T-&gt;rchild !&#x3D; NULL)pre_order(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void in_order(ptr T) &#123;</span><br><span class="line">	if (T-&gt;lchild !&#x3D; NULL)	in_order(T-&gt;lchild);</span><br><span class="line">	printf(&quot;%d &quot;, T-&gt;data);</span><br><span class="line">	if (T-&gt;rchild !&#x3D; NULL) in_order(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void post_order(ptr T) &#123;</span><br><span class="line">	if (T-&gt;lchild !&#x3D; NULL) post_order(T-&gt;lchild);</span><br><span class="line">	if (T-&gt;rchild !&#x3D; NULL) post_order(T-&gt;rchild);</span><br><span class="line">	printf(&quot;%d &quot;, T-&gt;data);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;n)&#x3D;&#x3D;1)</span><br><span class="line">	&#123;</span><br><span class="line">		ptr T &#x3D; NULL;</span><br><span class="line">		int x;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">			T &#x3D; insert(T, x);</span><br><span class="line">		&#125;</span><br><span class="line">		pre_order(T);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">		in_order(T);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">		post_order(T);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树搜索-判断树同构"><a href="#二叉树搜索-判断树同构" class="headerlink" title="二叉树搜索(判断树同构)"></a>二叉树搜索(判断树同构)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct node &#123;</span><br><span class="line">	struct node *lchild, *rchild;</span><br><span class="line">	int data;</span><br><span class="line">&#125;node, *ptr;</span><br><span class="line"></span><br><span class="line">ptr insert(ptr T, int x) &#123;</span><br><span class="line">	if (T &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		T &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">		T-&gt;data &#x3D; x;</span><br><span class="line">		T-&gt;lchild &#x3D; T-&gt;rchild &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		if (x &gt; T-&gt;data)</span><br><span class="line">			T-&gt;rchild &#x3D; insert(T-&gt;rchild, x);</span><br><span class="line">		else if (x &lt; T-&gt;data)</span><br><span class="line">			T-&gt;lchild &#x3D; insert(T-&gt;lchild, x);</span><br><span class="line">	&#125;</span><br><span class="line">	return T;</span><br><span class="line">&#125;</span><br><span class="line">bool equal(ptr  T1, ptr T2) &#123;</span><br><span class="line">	if (T1 &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		if (T2 &#x3D;&#x3D; NULL) return true;</span><br><span class="line">		else return false;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (T1-&gt;data &#x3D;&#x3D; T2-&gt;data)</span><br><span class="line">		return equal(T1-&gt;lchild, T2-&gt;lchild) &amp;&amp;</span><br><span class="line">		equal(T1-&gt;rchild, T2-&gt;rchild);</span><br><span class="line"></span><br><span class="line">	return false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		ptr T &#x3D; NULL;</span><br><span class="line">		char x;</span><br><span class="line">		getchar();</span><br><span class="line">		while (scanf(&quot;%c&quot;, &amp;x) &#x3D;&#x3D; 1 &amp;&amp; x !&#x3D; &#39;\n&#39;)</span><br><span class="line">			T &#x3D; insert(T, x - &#39;0&#39;);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			ptr T2 &#x3D; NULL;</span><br><span class="line">			while (scanf(&quot;%c&quot;, &amp;x) &#x3D;&#x3D; 1 &amp;&amp; x !&#x3D; &#39;\n&#39;)</span><br><span class="line">				T2 &#x3D; insert(T2, x - &#39;0&#39;);</span><br><span class="line">			if (equal(T, T2))</span><br><span class="line">				printf(&quot;YES\n&quot;);</span><br><span class="line">			else printf(&quot;NO\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除二叉排序树上的节点"><a href="#删除二叉排序树上的节点" class="headerlink" title="删除二叉排序树上的节点"></a>删除二叉排序树上的节点</h2><ol>
<li>找到这个节点</li>
<li>若该节点为叶子节点，则直接删除，即将其父节点指向其的指针置为空</li>
<li>若该节点仅不存在右子树，那么直接将左子树的根节点替代其位置后，删除该节点。</li>
<li>若该节点存在右子树，那么用其右子树最右下节点(即右子树中序遍历的第一个点)替换，并删除最右下节点。</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-搜索" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E6%90%9C%E7%B4%A2/"
    >搜索</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E6%90%9C%E7%B4%A2/" class="article-date">
  <time datetime="2020-03-30T03:55:19.536Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><ol>
<li>枚举要关注查找空间，查找目标，查找方式，估计时间复杂度</li>
<li>有时需要注意精度问题</li>
</ol>
<h2 id="SCU-2416"><a href="#SCU-2416" class="headerlink" title="SCU 2416"></a>SCU 2416</h2><p>有一个总价为_XYZ_，_表示看不清的位。现给出火鸡的总数和一个_XYZ_，求最大的火鸡单价是多少，输出这两位和最大的单价。火鸡单价为正整数</p>
<p>枚举两位，判断单价是否为整数即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	int a, b, c;</span><br><span class="line">	int n;</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);</span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		int ansi &#x3D; 0, ansj &#x3D; 0;</span><br><span class="line">		int beg &#x3D; a * 1000 + b * 100 + c * 10;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">			int t &#x3D; i * 10000 + beg;</span><br><span class="line">			for (int j &#x3D; 0; j &lt;&#x3D; 9; j++) &#123;</span><br><span class="line">				int now &#x3D; t + j;</span><br><span class="line">				int xx &#x3D; now &#x2F; n;</span><br><span class="line">				if (xx*n &#x3D;&#x3D; now)</span><br><span class="line">				&#123;</span><br><span class="line">					ansi &#x3D; i;</span><br><span class="line">					ansj &#x3D; j;</span><br><span class="line">					ans &#x3D; xx; </span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (ans)</span><br><span class="line">			printf(&quot;%d %d %d\n&quot;, ansi, ansj, ans);</span><br><span class="line">		else printf(&quot;0\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索 BFS"></a>广度优先搜索 BFS</h1><h2 id="HDU-1253-胜利大逃亡"><a href="#HDU-1253-胜利大逃亡" class="headerlink" title="HDU 1253 胜利大逃亡"></a>HDU 1253 胜利大逃亡</h2><p>大意是问能否在T时间内从(0,0,0)走到(A-1,B-1,C-1),且正好等于T时到达出口也可</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>三维隐式图最短路问题，使用bfs求解即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 50 + 5;</span><br><span class="line">int dx[] &#x3D; &#123; 1,-1,0,0, 0,0 &#125;;</span><br><span class="line">int dy[] &#x3D; &#123; 0,0,1,-1,0,0 &#125;;</span><br><span class="line">int dz[] &#x3D; &#123; 0,0,0,0,1,-1 &#125;;</span><br><span class="line">int A, B, C, T;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int x, y, z;</span><br><span class="line">	int t;</span><br><span class="line">	node(int x, int y, int z, int t) :x(x), y(y), z(z), t(t) &#123;&#125;</span><br><span class="line">	bool operator &#x3D;&#x3D; (const node&amp;a) const</span><br><span class="line">	&#123;</span><br><span class="line">		return x &#x3D;&#x3D; a.x&amp;&amp;y &#x3D;&#x3D; a.y&amp;&amp;z &#x3D;&#x3D; a.z;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int g[maxn][maxn][maxn];</span><br><span class="line">bool vis[maxn][maxn][maxn];</span><br><span class="line">inline bool ok(int x, int y, int z) &#123;</span><br><span class="line">	return x &gt;&#x3D; 0 &amp;&amp; x &lt; A</span><br><span class="line">		&amp;&amp;y &gt;&#x3D; 0 &amp;&amp; y &lt; B</span><br><span class="line">		&amp;&amp;z &gt;&#x3D; 0 &amp;&amp; z &lt; C;</span><br><span class="line">&#125;</span><br><span class="line">bool bfs() &#123;</span><br><span class="line">	node beg(0, 0, 0, 0);</span><br><span class="line">	node goal(A - 1, B - 1, C - 1, 0);</span><br><span class="line">	queue&lt;node&gt; q;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	q.push(beg);</span><br><span class="line">	vis[0][0][0] &#x3D; 1;</span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		node u &#x3D; q.front(); q.pop();</span><br><span class="line">		if (u &#x3D;&#x3D; goal) &#123;</span><br><span class="line">			printf(&quot;%d\n&quot;, u.t);</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		if (u.t &gt; T) &#123;</span><br><span class="line">			printf(&quot;-1\n&quot;);</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 6; i++) &#123;</span><br><span class="line">			int newx &#x3D; u.x + dx[i];</span><br><span class="line">			int newy &#x3D; u.y + dy[i];</span><br><span class="line">			int newz &#x3D; u.z + dz[i];</span><br><span class="line">			if (ok(newx, newy, newz))</span><br><span class="line">				if (!vis[newx][newy][newz] &amp;&amp; !g[newx][newy][newz]) &#123;</span><br><span class="line">					q.push(node(newx, newy, newz, u.t + 1));</span><br><span class="line">					vis[newx][newy][newz] &#x3D; 1;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;-1\n&quot;);</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int kase;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;kase);</span><br><span class="line">	while (kase--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d%d%d%d&quot;, &amp;A, &amp;B, &amp;C, &amp;T);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; A; i++)</span><br><span class="line">			for (int j &#x3D; 0; j &lt; B; j++)</span><br><span class="line">				for (int k &#x3D; 0; k &lt; C; k++)</span><br><span class="line">					scanf(&quot;%d&quot;, &amp;g[i][j][k]);</span><br><span class="line">		bfs();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非常可乐"><a href="#非常可乐" class="headerlink" title="非常可乐"></a>非常可乐</h2><p>大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升　(正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出”NO”。 </p>
<p>三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以”0 0 0”结束。</p>
<p>如果能平分的话请输出最少要倒的次数，否则输出”NO”。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>隐式图最短路，详细可看UVA习题中<strong>倒水问题</strong></li>
<li>值得注意的是<ol>
<li>由于是倒水次数最小，所以不需要使用优先级队列</li>
<li>由于总水量一定，所以vis开二维足够</li>
<li>如果初始水量为奇数，一定不成功。</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int c[3];</span><br><span class="line">	int t;</span><br><span class="line">&#125;;</span><br><span class="line">bool vis[maxn][maxn];</span><br><span class="line">int cap[3];</span><br><span class="line">void bfs() &#123;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	int s &#x3D; cap[0];</span><br><span class="line">	node beg;</span><br><span class="line">	beg.c[0] &#x3D; s;	beg.c[1] &#x3D; 0;	beg.c[2] &#x3D; 0;</span><br><span class="line">	beg.t &#x3D; 0;</span><br><span class="line">	vis[s][0] &#x3D; 1;</span><br><span class="line">	queue&lt;node&gt; q;</span><br><span class="line">	q.push(beg);</span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		node u &#x3D; q.front(); q.pop();</span><br><span class="line">		if ((2 * u.c[0] &#x3D;&#x3D; s &amp;&amp; 2 * u.c[1] &#x3D;&#x3D; s)</span><br><span class="line">			|| (2 * u.c[0] &#x3D;&#x3D; s &amp;&amp; 2 * u.c[2] &#x3D;&#x3D; s)</span><br><span class="line">			|| (2 * u.c[1] &#x3D;&#x3D; s &amp;&amp; 2 * u.c[2] &#x3D;&#x3D; s)) &#123;</span><br><span class="line">			printf(&quot;%d\n&quot;, u.t);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 3; i++) &#123;&#x2F;&#x2F;i向j倒水</span><br><span class="line">			if (u.c[i] &#x3D;&#x3D; 0) continue;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 3; j++) &#123;</span><br><span class="line">				if (i !&#x3D; j) &#123;</span><br><span class="line">					node v &#x3D; u;</span><br><span class="line">					int delta &#x3D; min(cap[j], v.c[i] + v.c[j]) - v.c[j];</span><br><span class="line">					v.c[i] -&#x3D; delta;</span><br><span class="line">					v.c[j] +&#x3D; delta;</span><br><span class="line">					v.t +&#x3D; 1;</span><br><span class="line">					if (!vis[v.c[0]][v.c[1]]) &#123;</span><br><span class="line">						vis[v.c[0]][v.c[1]] &#x3D; 1;</span><br><span class="line">						q.push(v);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;NO\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d%d%d&quot;, &amp;cap[0], &amp;cap[1], &amp;cap[2]) &#x3D;&#x3D; 3)</span><br><span class="line">	&#123;</span><br><span class="line">		if (cap[0] &#x3D;&#x3D; 0 &amp;&amp; cap[1] &#x3D;&#x3D; 0 &amp;&amp; cap[2] &#x3D;&#x3D; 0) break;</span><br><span class="line">		if (cap[0] % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">			printf(&quot;NO\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		bfs();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>每次都需要借助第2个柱子将前K-1小的转移到3上.具体来说是先将k-1个盘子移动到3上，再将最大的移到2上，再将k-1个移动到1上，再将最大的移动到3上，再将k-1个移动到3上。</li>
<li>设总的移动次数为F(k)=3*F(k-1)+2</li>
</ol>
<h1 id="递归的应用"><a href="#递归的应用" class="headerlink" title="递归的应用"></a>递归的应用</h1><h2 id="素数环"><a href="#素数环" class="headerlink" title="素数环"></a>素数环</h2><p><a href="https://cccceb.github.io/2020/01/24/%E7%B4%A0%E6%95%B0%E7%8E%AF/" target="_blank" rel="noopener">详情见UVA习题素数环</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 16 + 5;</span><br><span class="line">int A[maxn];</span><br><span class="line">bool isp[10000000];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int n;</span><br><span class="line">bool is_prime(int a) &#123;</span><br><span class="line">	for (int i &#x3D; 2; i &lt; a; i++)</span><br><span class="line">		if (a%i &#x3D;&#x3D; 0) return 0;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int cur) &#123;</span><br><span class="line">	if (cur &#x3D;&#x3D; n &amp;&amp; isp[A[0] + A[cur - 1]]) &#123;</span><br><span class="line">		cout &lt;&lt; A[0];</span><br><span class="line">		for (int i &#x3D; 1; i &lt; n; i++) cout &lt;&lt; &quot; &quot; &lt;&lt; A[i];</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		for (int j &#x3D; 2; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">			if (!vis[j] &amp;&amp; isp[A[cur - 1] + j]) &#123;</span><br><span class="line">				A[cur] &#x3D; j;</span><br><span class="line">				vis[j] &#x3D; 1;</span><br><span class="line">				dfs(cur + 1);</span><br><span class="line"></span><br><span class="line">				A[cur] &#x3D; 0;</span><br><span class="line">				vis[j] &#x3D; 0;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int kase &#x3D; 0;</span><br><span class="line">	while (cin &gt;&gt; n) &#123;</span><br><span class="line">		if (kase) cout &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++kase &lt;&lt; &quot;:&quot; &lt;&lt; endl;</span><br><span class="line">		memset(vis, 0,  sizeof(vis));</span><br><span class="line">		memset(isp, 0,  sizeof(isp));</span><br><span class="line">		for (int i &#x3D; 2; i &lt;&#x3D; 2 * n; i++)</span><br><span class="line">			isp[i] &#x3D; is_prime(i);</span><br><span class="line">		A[0] &#x3D; 1;</span><br><span class="line">		isp[1] &#x3D; 1;</span><br><span class="line">		dfs(1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="油田"><a href="#油田" class="headerlink" title="油田"></a>油田</h2><p>给出一个图，判断其中有多少个@的连通块。正方向和对角线都算相连</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol>
<li>直接深搜即可</li>
<li>走的方向i,j不同时为0，简化代码为i||j</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">char g[maxn][maxn];</span><br><span class="line">int r, c;</span><br><span class="line">int vis[maxn][maxn];</span><br><span class="line">int num;</span><br><span class="line">void dfs(int x, int y) &#123;</span><br><span class="line">	if (g[x][y] !&#x3D; &#39;@&#39; || vis[x][y]) return;</span><br><span class="line">	if (x &lt; 0 || x &gt;&#x3D; r || y &lt; 0 || y &gt;&#x3D; c) return;</span><br><span class="line">	vis[x][y] &#x3D; num;</span><br><span class="line">	for (int i &#x3D; -1; i &lt;&#x3D; 1; i++) &#123;</span><br><span class="line">		for (int j &#x3D; -1; j &lt;&#x3D; 1; j++) &#123;</span><br><span class="line">			if (i || j)</span><br><span class="line">				dfs(x + i, y + j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d%d\n&quot;, &amp;r, &amp;c) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		if (r &#x3D;&#x3D; 0 &amp;&amp; c &#x3D;&#x3D; 0) break;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; c; j++)</span><br><span class="line">				scanf(&quot;%c&quot;, &amp;g[i][j]);</span><br><span class="line">			getchar();</span><br><span class="line">		&#125;</span><br><span class="line">		num &#x3D; 1;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; c; j++)</span><br><span class="line">				if (g[i][j] &#x3D;&#x3D; &#39;@&#39;&amp;&amp;!vis[i][j])</span><br><span class="line">				&#123;</span><br><span class="line">					dfs(i, j);</span><br><span class="line">					num++;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, num-1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="OpenJ-Bailian-4070-全排列"><a href="#OpenJ-Bailian-4070-全排列" class="headerlink" title="OpenJ_Bailian - 4070 全排列"></a>OpenJ_Bailian - 4070 全排列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const int maxn &#x3D; 8;</span><br><span class="line">int p[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			p[i] &#x3D; i + 1;</span><br><span class="line">		sort(p, p + n);</span><br><span class="line">		do &#123;</span><br><span class="line">			printf(&quot;%d&quot;, p[0]);</span><br><span class="line">			for (int i &#x3D; 1; i &lt; n; i++)</span><br><span class="line">				printf(&quot; %d&quot;, p[i]);</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125; while (next_permutation(p, p + n));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索 DFS"></a>深度优先搜索 DFS</h1><h2 id="temple-of-the-bone"><a href="#temple-of-the-bone" class="headerlink" title="temple of the bone"></a>temple of the bone</h2><p>S是起点，D是终点，X是墙，.是地面，问能否在T时间内到达D。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 8;</span><br><span class="line">char g[maxn][maxn];</span><br><span class="line">bool vis[maxn][maxn];</span><br><span class="line">int maxr, maxc,T;</span><br><span class="line">int dx[] &#x3D; &#123; 1,-1,0,0 &#125;;</span><br><span class="line">int dy[] &#x3D; &#123; 0,0,1,-1 &#125;;</span><br><span class="line">bool dfs(int x,int y,int t) &#123;</span><br><span class="line">	if (x &lt; 0 || x &gt;&#x3D; maxr || y &lt; 0 || y &gt;&#x3D; maxc) return false;</span><br><span class="line">	if (g[x][y] &#x3D;&#x3D; &#39;D&#39;) &#123;</span><br><span class="line">		printf(&quot;YES\n&quot;);</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	if (t &gt; T) return false;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">		int newx &#x3D; x + dx[i];</span><br><span class="line">		int newy &#x3D; y + dy[i];</span><br><span class="line">		if (vis[newx][newy]||g[newx][newy]&#x3D;&#x3D;&#39;X&#39;) continue;</span><br><span class="line">		vis[newx][newy] &#x3D; 1;</span><br><span class="line">		if (dfs(newx, newy, t + 1)) return true;</span><br><span class="line">		vis[newx][newy] &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int begx, begy;</span><br><span class="line"></span><br><span class="line">	while(scanf(&quot;%d%d%d\n&quot;,&amp;maxr,&amp;maxc,&amp;T)&#x3D;&#x3D;3)&#123;</span><br><span class="line">		if (maxr &#x3D;&#x3D; 0 &amp;&amp; maxc &#x3D;&#x3D; 0 &amp;&amp; T&#x3D;&#x3D;0) break;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		for(int i &#x3D; 0; i &lt; maxr; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; maxc; j++) &#123;</span><br><span class="line">				scanf(&quot;%c&quot;, &amp;g[i][j]);</span><br><span class="line">				if (g[i][j] &#x3D;&#x3D; &#39;S&#39;) &#123;</span><br><span class="line">					begx &#x3D; i;</span><br><span class="line">					begy &#x3D; j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			getchar();</span><br><span class="line">		&#125;</span><br><span class="line">		if (!dfs(begx, begy, 0))</span><br><span class="line">			printf(&quot;NO\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HDU-1421-搬寝室"><a href="#HDU-1421-搬寝室" class="headerlink" title="HDU 1421 搬寝室"></a>HDU 1421 搬寝室</h2><p>搬寝室是很累的,xhd深有体会.时间追述2006年7月9号,那天xhd迫于无奈要从27号楼搬到3号楼,因为10号要封楼了.看着寝室里的n件物品,xhd开始发呆,因为n是一个小于2000的整数,实在是太多了,于是xhd决定随便搬2<em>k件过去就行了.但还是会很累,因为2</em>k也不小是一个不大于n的整数.幸运的是xhd根据多年的搬东西的经验发现每搬一次的疲劳度是和左右手的物品的重量差的平方成正比(这里补充一句,xhd每次搬两件东西,左手一件右手一件).例如xhd左手拿重量为3的物品,右手拿重量为6的物品,则他搬完这次的疲劳度为(6-3)^2 = 9.现在可怜的xhd希望知道搬完这2*k件物品后的最佳状态是怎样的(也就是最低的疲劳度),请告诉他吧. </p>
<p>每组输入数据有两行,第一行有两个数n,k(2&lt;=2*k&lt;=n&lt;2000).第二行有n个整数分别表示n件物品的重量(重量是一个小于2^15的正整数).</p>
<p>对应每组输入数据,输出数据只有一个表示他的最少的疲劳度,每个一行.</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>设dp[i][j]表示前i件物品组成j对所消耗的体力最小；所以分成了两种情况</p>
<ol>
<li>第j对里含有第i件物品，则dp [i][j] = dp [i-2][j-1] + (a[i]-a[i-1])*(a[i]-a[i-1]);</li>
<li>不含第i件物品则有：dp [i][j] = dp [i-1][j];</li>
</ol>
</li>
<li><p>总上，动态转移方程为:dp[i][j]=min(dp[i-2][j-1]+(a[i]-a[i-1])*(a[i]-a[i-1]), dp[i][j]=dp[i-1][j]);</p>
</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">int dp[2010][2010], a[2010];</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, k;</span><br><span class="line">	while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;k))</span><br><span class="line">	&#123;</span><br><span class="line">		int i, j;</span><br><span class="line">		memset(a, 0, sizeof(a));</span><br><span class="line">		memset(dp, 0, sizeof(dp));</span><br><span class="line">		for (i &#x3D; 0; i &lt;&#x3D; n; i++)</span><br><span class="line">			for (j &#x3D; 1; j &lt;&#x3D; k; j++)</span><br><span class="line">				dp[i][j] &#x3D; inf;</span><br><span class="line">		for (i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">		sort(a, a + n + 1);</span><br><span class="line">		for (i &#x3D; 2; i &lt;&#x3D; n; i++)</span><br><span class="line">			for (j &#x3D; 1; j * 2 &lt;&#x3D; i; j++)</span><br><span class="line">				dp[i][j] &#x3D; min(dp[i - 1][j], dp[i - 2][j - 1] + (a[i] - a[i - 1])*(a[i] - a[i - 1]));</span><br><span class="line">		printf(&quot;%d\n&quot;, dp[n][k]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HDU-3578-Greedy-Tino"><a href="#HDU-3578-Greedy-Tino" class="headerlink" title="HDU 3578 Greedy Tino"></a>HDU 3578 Greedy Tino</h2><p>未完待续</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define OFFSET 2000&#x2F;&#x2F;因为j有正负，所以添加一个偏移量，方便做题</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line">int wi[101];</span><br><span class="line">int dp[101][4001];</span><br><span class="line">int max(int a, int b, int c)&#123;</span><br><span class="line">    int flag &#x3D; a;</span><br><span class="line">    if(flag &lt; b)&#123;</span><br><span class="line">        flag &#x3D; b;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag &lt; c)&#123;</span><br><span class="line">        flag &#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i&#x3D;0;i&lt;40001;i++)</span><br><span class="line">            dp[0][i] &#x3D; -INF;</span><br><span class="line">    dp[0][OFFSET] &#x3D; 0;&#x2F;&#x2F;core</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t, n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; t; i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        wi[0] &#x3D; 0;</span><br><span class="line">         bool hasZero &#x3D; false;</span><br><span class="line">        int cnt &#x3D; 0;</span><br><span class="line">        for(int j &#x3D; 0; j &lt; n; j++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;wi[++cnt]);</span><br><span class="line">            if(wi[cnt] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                   hasZero &#x3D; true;</span><br><span class="line">                   cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n &#x3D; cnt;</span><br><span class="line">        init();</span><br><span class="line">        for(int j &#x3D; 1; j &lt;&#x3D; n; j++)&#123;</span><br><span class="line">            for(int k &#x3D; -2000; k &lt;&#x3D; 2000; k++)&#123;</span><br><span class="line">                dp[j][k+OFFSET] &#x3D; max(dp[j-1][k-wi[j]+OFFSET]+wi[j], dp[j-1][k+wi[j]+OFFSET]+wi[j], dp[j-1][k+OFFSET]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf (&quot;Case %d: &quot;, i+1);</span><br><span class="line">        if(dp[n][0+OFFSET] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            if(hasZero &#x3D;&#x3D; true)&#123;</span><br><span class="line">                printf(&quot;0\n&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                printf(&quot;-1\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            printf(&quot;%d\n&quot;, dp[n][0+OFFSET]&#x2F;2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h1><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><p>特点是每个物品只能选一件，即每个物品的数量只能出现0和1</p>
<h3 id="OpenJ-Bailian-2726"><a href="#OpenJ-Bailian-2726" class="headerlink" title="OpenJ_Bailian 2726"></a>OpenJ_Bailian 2726</h3><p>辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是辰辰，你能完成这个任务吗？</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ol>
<li>用dp[i][j]表示取前i个物品，重量不超过j时能达到的最大价值。</li>
<li>可以根据第i个物品是否取分成两类<ol>
<li>取第i个物品，那么需要更新所有能再装下一个i的状态，即dp[i-1][j-p[i].w]</li>
<li>不取i，那么dp[i][j]=dp[i-1][j]</li>
</ol>
</li>
<li>综上，递推关系为dp[i][j] = max(dp[i-1][j], dp[i - 1][j - p[i].w] + p[i].v)</li>
<li><strong>注意</strong> 对于dp[i-1][j]下装不下第i个物品的状态，要赋值为dp[i-1][j]</li>
</ol>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line">struct node &#123;</span><br><span class="line">	int w;</span><br><span class="line">	int v;</span><br><span class="line">&#125;;</span><br><span class="line">int s, m;</span><br><span class="line">node p[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;s, &amp;m) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;p[i].w, &amp;p[i].v);</span><br><span class="line"></span><br><span class="line">		memset(dp, 0, sizeof(0));</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">			for (int j &#x3D; s; j &gt;&#x3D; p[i].w; j--) &#123;</span><br><span class="line">				dp[i][j] &#x3D; max(dp[i-1][j], dp[i - 1][j - p[i].w] + p[i].v);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			for (int j &#x3D; p[i].w-1; j &gt;&#x3D; 0; j--)&#x2F;&#x2F;对于p[i].w-1~1的状态只能来自于dp[i-1][j]</span><br><span class="line">				dp[i][j] &#x3D; dp[i-1][j];</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, dp[m][s]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol>
<li>发现新的状态至于最近的一个状态有关，所以可以降维。</li>
<li>状态转移方程为：dp[j]=max{dp[j-p[i].w]+v,dp[i]}</li>
<li><strong>注意</strong> 更新dp时是逆序更新，这是因为在0-1背包问题中每个物品至多放入一次。逆序循环，保证了更新dp[j]时，dp[j-p[i].w]是没有放入i时的数据(dp[i-1][j-p[i].w])</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">	for (int j &#x3D; s; j &gt;&#x3D; p[i].w; j--) &#123;</span><br><span class="line">		dp[j]&#x3D;max(dp[j-p[i].w]+v,dp[i]);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>每种物品的数量可以任意多</p>
<h3 id="HDU-1114-Piggy-Bank"><a href="#HDU-1114-Piggy-Bank" class="headerlink" title="HDU 1114 Piggy-Bank"></a>HDU 1114 Piggy-Bank</h3><p>有个存钱罐，已知空罐质量和满罐质量，以及n种硬币质量和价值，求罐中硬币的最小价值。</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><ol>
<li>完全背包问题的区别在于，每个物品可以被选择很多次，因此dp[j]可以由已放入物品i后的数据dp[j-p[i].w]得来，所以顺序循环</li>
<li>本题求最小值，将max要换成min</li>
<li>由于要求恰好装满，所以初始时只有dp[0]=0，其他状态都不存在</li>
</ol>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 10000+ 5;</span><br><span class="line">int dp[maxn];</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line">struct node &#123;</span><br><span class="line">	int w;</span><br><span class="line">	int v;</span><br><span class="line">&#125;;</span><br><span class="line">int s, m;</span><br><span class="line">node p[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;m, &amp;s);</span><br><span class="line">		s -&#x3D; m;</span><br><span class="line">		int n;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;p[i].v, &amp;p[i].w);</span><br><span class="line">		for (int i &#x3D; 0; i &lt;&#x3D; s; i++)</span><br><span class="line">			dp[i] &#x3D; INF;</span><br><span class="line">		dp[0] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; p[i].w; j &lt;&#x3D; s;j++) &#123;</span><br><span class="line">				if (dp[j - p[i].w] !&#x3D; INF)&#x2F;&#x2F;该状态存在，那么才可以产生新的状态</span><br><span class="line">					dp[j] &#x3D; min(dp[j], dp[j - p[i].w] + p[i].v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (dp[s] !&#x3D; INF)</span><br><span class="line">			printf(&quot;The minimum amount of money in the piggy-bank is %d.\n&quot;, dp[s]);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot;This is impossible.\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><p>介于完全背包问题和0-1背包问题之间，每种物品数量有限。可以将k个物品看作k种物品，在进行0-1背包求解。但是这样会使时间复杂度过大。稍加改变，将该种物品分成很多堆，每堆数量为1~k-2^c+1,其中c为使k-2^c+1大于0的最大整数。</p>
<h3 id="HDU-2191-珍惜现在，感恩生活"><a href="#HDU-2191-珍惜现在，感恩生活" class="headerlink" title="HDU 2191 珍惜现在，感恩生活"></a>HDU 2191 珍惜现在，感恩生活</h3><p>输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1&lt;=n&lt;=100, 1&lt;=m&lt;=100),分别表示经费的金额和大米的种类，然后是m行数据，每行包含3个数p，h和c(1&lt;=p&lt;=20,1&lt;=h&lt;=200,1&lt;=c&lt;=20)，分别表示每袋的价格、每袋的重量以及对应种类大米的袋数。</p>
<p>对于每组测试数据，请输出能够购买大米的最多重量，你可以假设经费买不光所有的大米，并且经费你可以不用完。每个实例的输出占一行。</p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><ol>
<li>先将每个物品分成很多堆，类似二进制拆分</li>
<li>然后进行0-1背包求解</li>
</ol>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 10000 + 5;</span><br><span class="line">int dp[maxn];</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line">struct node &#123;</span><br><span class="line">	int w;</span><br><span class="line">	int v;</span><br><span class="line">&#125;;</span><br><span class="line">int s, m;</span><br><span class="line">node a[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;s, &amp;m);</span><br><span class="line">		int p, h, c;</span><br><span class="line">		int cnt &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;p, &amp;h, &amp;c);</span><br><span class="line">			int t &#x3D; 1;</span><br><span class="line">			while (c &gt; t)</span><br><span class="line">			&#123;</span><br><span class="line">				c -&#x3D; t;</span><br><span class="line">				a[++cnt].w &#x3D; t * p;</span><br><span class="line">				a[cnt].v &#x3D; t * h;</span><br><span class="line">				t *&#x3D; 2;</span><br><span class="line">			&#125;</span><br><span class="line">			a[++cnt].w &#x3D; p * c;</span><br><span class="line">			a[cnt].v &#x3D; h * c;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		memset(dp, 0, sizeof(dp));</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; cnt; i++) &#123;</span><br><span class="line">			for (int j &#x3D; s; j &gt;&#x3D; a[i].w;j--) &#123;</span><br><span class="line">					dp[j] &#x3D; max(dp[j], dp[j - a[i].w] + a[i].v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;%d\n&quot;, dp[s]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-基础相关" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/"
    >基础相关</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/" class="article-date">
  <time datetime="2020-03-30T03:55:19.536Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h1><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const static int Month[13][2] &#x3D; &#123;</span><br><span class="line">	&#123;0,0&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;28,29&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;30,30&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;30,30&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;30,30&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;30,30&#125;,</span><br><span class="line">	&#123;31,31&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct  Date</span><br><span class="line">&#123;</span><br><span class="line">	int year;</span><br><span class="line">	int month;</span><br><span class="line">	int day;</span><br><span class="line"></span><br><span class="line">	Date(int d, int m, int y) :year(y), day(d), month(m) &#123;&#125;;</span><br><span class="line">	bool isLeap(int year) &#123;</span><br><span class="line">		return year % 100 !&#x3D; 0 &amp;&amp; year % 4 &#x3D;&#x3D; 0 || year % 400 &#x3D;&#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void nextDay() &#123;</span><br><span class="line">		day++;</span><br><span class="line">		if (day &gt; Month[month][isLeap(year)]) &#123;</span><br><span class="line">			day &#x3D; 1;</span><br><span class="line">			month++;</span><br><span class="line">			if (month &gt; 12) &#123;</span><br><span class="line">				month &#x3D; 1;</span><br><span class="line">				year++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="打表"><a href="#打表" class="headerlink" title="打表"></a>打表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int cnt &#x3D; 0;</span><br><span class="line">	Date tmp(1,1,0) ;</span><br><span class="line">	while (tmp.year&lt;&#x3D;5000)</span><br><span class="line">	&#123;</span><br><span class="line">		buf[tmp.year][tmp.month][tmp.day]  &#x3D; cnt;</span><br><span class="line">		tmp.nextDay();</span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求两个日期间隔多少天-日期差值"><a href="#求两个日期间隔多少天-日期差值" class="headerlink" title="求两个日期间隔多少天 日期差值"></a>求两个日期间隔多少天 日期差值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	</span><br><span class="line">	int y1, m1, d1;</span><br><span class="line">	int y2, m2, d2;</span><br><span class="line">	while (scanf(&quot;%4d %2d %2d&quot;,&amp;y1,&amp;m1,&amp;d1))</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%4d %2d %2d&quot;, &amp;y2, &amp;m2, &amp;d2);</span><br><span class="line">		printf(&quot;%d\n&quot;, abs(buf[y1][m1][d1] - buf[y2][m2][d2])+1);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>注意输入%xd的方法。+1别忘了</li>
<li>将输入日期统一到0年1月1日为起点</li>
</ol>
<h3 id="求给定日期是星期几-Day-of-Week"><a href="#求给定日期是星期几-Day-of-Week" class="headerlink" title="求给定日期是星期几 Day of Week"></a>求给定日期是星期几 Day of Week</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">const static char NMonth[13][20] &#x3D; &#123;</span><br><span class="line">	&quot;&quot;,</span><br><span class="line">	&quot;January&quot;,</span><br><span class="line">	&quot;February&quot;,</span><br><span class="line">	&quot;March&quot;,</span><br><span class="line">	&quot;April&quot;,</span><br><span class="line">	&quot;May&quot;,</span><br><span class="line">	&quot;June&quot;,</span><br><span class="line">	&quot;July&quot;,</span><br><span class="line">	&quot;August&quot;,</span><br><span class="line">	&quot;September&quot;,</span><br><span class="line">	&quot;October&quot;,</span><br><span class="line">	&quot;November&quot;,</span><br><span class="line">	&quot;December&quot;</span><br><span class="line">&#125;;</span><br><span class="line">const static char week[7][20] &#x3D; &#123;</span><br><span class="line">	&quot;Sunday&quot;,</span><br><span class="line">	&quot;Monday&quot;,</span><br><span class="line">	&quot;Tuesday&quot;,</span><br><span class="line">	&quot;Wednesday&quot;,</span><br><span class="line">	&quot;Thursday&quot;,</span><br><span class="line">	&quot;Friday&quot;,</span><br><span class="line">	&quot;Saturday&quot;</span><br><span class="line">&#125;;</span><br><span class="line">int y, d;</span><br><span class="line">char month[20];</span><br><span class="line">while (scanf(&quot;%d%s%4d&quot;, &amp;d, month, &amp;y) !&#x3D; EOF)</span><br><span class="line">&#123;</span><br><span class="line">	int m;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; 12; i++)</span><br><span class="line">		if (!strcmp(month, NMonth[i])) &#123;</span><br><span class="line">			m &#x3D; i;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	int days &#x3D; buf[y][m][d] - buf[2020][2][5];</span><br><span class="line">	days +&#x3D; 3;</span><br><span class="line">	printf(&quot;%s\n&quot;, week[(days % 7 + 7) % 7]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure>
<ol>
<li>也是将输入日期统一到0年1月1日为起点</li>
<li>然后计算与今天的差，</li>
</ol>
<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><h2 id="输出前m大的数"><a href="#输出前m大的数" class="headerlink" title="输出前m大的数"></a>输出前m大的数</h2><p>将数值看成数组下标，从数组尾部开始输出m个存在的数字。</p>
<h2 id="其他使用"><a href="#其他使用" class="headerlink" title="其他使用"></a>其他使用</h2><ol>
<li>主要是记录每个数字出现的次数的思想</li>
</ol>
<h1 id="排版题"><a href="#排版题" class="headerlink" title="排版题"></a>排版题</h1><h2 id="输出梯形"><a href="#输出梯形" class="headerlink" title="输出梯形"></a>输出梯形</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">#pragma warning(disable:4996)</span><br><span class="line">const int maxn &#x3D; 1005;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">	&#123;</span><br><span class="line">		int m &#x3D; n + 2 * (n - 1);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; m-n-2*i; j++) &#123;</span><br><span class="line">				printf(&quot; &quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; n+i*2; j++) &#123;</span><br><span class="line">				printf(&quot;*&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="叠筐-HDU2074"><a href="#叠筐-HDU2074" class="headerlink" title="叠筐 HDU2074"></a>叠筐 HDU2074</h2><p>需要的时候，就把一个个大小差一圈的筐叠上去，使得从上往下看时，边筐花色交错。这个工作现在要让计算机来完成，得看你的了。<br>输入是一个个的三元组，分别是，外筐尺寸n（n为满足0&lt;n&lt;80的奇整数），中心花色字符，外筐花色字符，后二者都为ASCII可见字符；<br>输出叠在一起的筐图案，中心花色与外筐花色字符从内层起交错相叠，多筐相叠时，最外筐的角总是被打磨掉。叠筐与叠筐之间应有一行间隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 80 + 5;</span><br><span class="line">char g[maxn][maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	char a, b;</span><br><span class="line">	int first &#x3D; 1;</span><br><span class="line">	while (scanf(&quot;%d %c %c\n&quot;, &amp;n, &amp;b, &amp;a) &#x3D;&#x3D; 3)</span><br><span class="line">	&#123;</span><br><span class="line">		if (((n - 1) &#x2F; 2) % 2 &#x3D;&#x3D; 0) std::swap(a, b);</span><br><span class="line">		memset(g, b, sizeof(g));</span><br><span class="line">		if (first) first &#x3D; 0;</span><br><span class="line">		else printf(&quot;\n&quot;);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i +&#x3D; 2) &#123;</span><br><span class="line">			for (int j &#x3D; i; j &lt; n - 2 * i + i; j++) &#123;</span><br><span class="line">				g[i][j] &#x3D; g[n - i - 1][j] &#x3D; a;</span><br><span class="line">				g[j][i] &#x3D; g[j][n - i - 1] &#x3D; a;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (n !&#x3D; 1)</span><br><span class="line">			g[0][0] &#x3D; g[0][n - 1] &#x3D; g[n - 1][0] &#x3D; g[n - 1][n - 1] &#x3D; &#39; &#39;;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">				printf(&quot;%c&quot;, g[i][j]);</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Repeater"><a href="#Repeater" class="headerlink" title="Repeater"></a>Repeater</h2><p>Harmony is indispensible in our daily life and no one can live without it—-may be Facer is the only exception. One day it is rumored that repeat painting will create harmony and then hundreds of people started their endless drawing. Their paintings were based on a small template and a simple method of duplicating. Though Facer can easily imagine the style of the whole picture, but he cannot find the essential harmony. Now you need to help Facer by showing the picture on computer. You will be given a template containing only one kind of character and spaces, and the template shows how the endless picture is created—-use the characters as basic elements and put them in the right position to form a bigger template, and then repeat and repeat doing that. Here is an example. # #  #      &lt;-template # # So the Level 1 picture will be # #  # # # Level 2 picture will be # #     # #  #         # # #     # #      # #         #         # #   # #    # #  #        # # #    # #</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 3000 + 5;</span><br><span class="line">char g[maxn][maxn];</span><br><span class="line">char tmp[maxn][maxn];</span><br><span class="line">char tmp2[maxn][maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int p, q;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;p) &#x3D;&#x3D; 1 &amp;&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		getchar();</span><br><span class="line">		memset(g, &#39; &#39;, sizeof(g));</span><br><span class="line">		for (int i &#x3D; 0; i &lt; p; i++)</span><br><span class="line">			std::cin.getline(g[i], 6);</span><br><span class="line"></span><br><span class="line">		scanf(&quot;%d&quot;, &amp;q);</span><br><span class="line"></span><br><span class="line">		memcpy(tmp, g, sizeof(g));</span><br><span class="line">		if (q !&#x3D; 1)</span><br><span class="line">			for (int scale &#x3D; 2; scale &lt;&#x3D; q; scale++) &#123;&#x2F;&#x2F;代</span><br><span class="line">				memset(tmp2, &#39; &#39;, sizeof(tmp2));</span><br><span class="line">				int r , c ;</span><br><span class="line">				int oldr, oldc;</span><br><span class="line">				oldr &#x3D; oldc &#x3D; pow(p, scale - 1);</span><br><span class="line">				for (int i &#x3D; 0; i &lt; p; i++) &#123;</span><br><span class="line">					for (int j &#x3D; 0; j &lt; p; j++) &#123;&#x2F;&#x2F;初代模板</span><br><span class="line">						r &#x3D; i * oldr;</span><br><span class="line">						c &#x3D; j * oldc;</span><br><span class="line">						if (g[i][j] !&#x3D; &#39; &#39;) &#123;</span><br><span class="line">							for (int k &#x3D; 0; k &lt; oldr; k++) &#123;&#x2F;&#x2F;在元素处复制模板</span><br><span class="line">								for (int f &#x3D; 0; f &lt; oldc; f++)</span><br><span class="line">									tmp2[r + k][c + f] &#x3D; tmp[k][f];</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				memcpy(tmp, tmp2,sizeof(tmp2));</span><br><span class="line">			&#125;</span><br><span class="line">		for (int k &#x3D; 0; k &lt; pow(p, q); k++) &#123;</span><br><span class="line">			for (int f &#x3D; 0; f &lt; pow(p, q); f++) &#123;</span><br><span class="line"></span><br><span class="line">				printf(&quot;%c&quot;, tmp[k][f]);</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="查找学生信息-二分查找"><a href="#查找学生信息-二分查找" class="headerlink" title="查找学生信息 二分查找"></a>查找学生信息 二分查找</h2><p>输入N个学生的信息，然后进行查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">	int no;</span><br><span class="line">	string name;</span><br><span class="line">	string sex;</span><br><span class="line">	int age;</span><br><span class="line">	node() &#123;&#125;;</span><br><span class="line">	node(int no, string name, string sex, int age)</span><br><span class="line">		:no(no), name(name), sex(sex), age(age) &#123;&#125;;</span><br><span class="line">	bool operator &lt; (const node &amp;a) const &#123;</span><br><span class="line">		return no &lt; a.no;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">node stu[maxn];</span><br><span class="line">int bsearch(int l, int r, int q) &#123;</span><br><span class="line">	while (l &lt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		int m &#x3D; l + (r - l) &#x2F; 2;</span><br><span class="line">		if (stu[m].no &#x3D;&#x3D; q) return m;</span><br><span class="line">		else if (stu[m].no &gt; q) r &#x3D; m;</span><br><span class="line">		else l &#x3D; m + 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (cin&gt;&gt;n&amp;&amp;n) &#123;</span><br><span class="line">		string  b, c;</span><br><span class="line">		int a,d;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">			stu[i] &#x3D; node(a, b, c, d);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(stu, stu + n);</span><br><span class="line">		int m;</span><br><span class="line">		cin &gt;&gt; m;</span><br><span class="line">		int que;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			cin &gt;&gt; que;</span><br><span class="line">			int ans &#x3D; bsearch(0, n, que);</span><br><span class="line">			ans !&#x3D; -1 ? cout &lt;&lt; stu[ans].no&lt;&lt;&quot; &quot;&lt;&lt;stu[ans].name&lt;&lt;&quot; &quot;&lt;&lt;stu[ans].sex&lt;&lt;&quot; &quot;&lt;&lt;stu[ans].age &lt;&lt; endl </span><br><span class="line">				: cout &lt;&lt; &quot;No Answer!&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打印极值点下标"><a href="#打印极值点下标" class="headerlink" title="打印极值点下标"></a>打印极值点下标</h2><p>在一个整数数组上，对于下标为i的整数，如果它大于所有它相邻的整数， 或者小于所有它相邻的整数，则称为该整数为一个极值点，极值点的下标就是i。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 80 + 5;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line"></span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n)&#x3D;&#x3D;1&amp;&amp;n)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		int x;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		if (n &gt; 2) &#123;</span><br><span class="line">			if (a[2] &gt; a[1]) a[0] &#x3D; a[1] + 1;</span><br><span class="line">			else if(a[2] &lt; a[1]) a[0] &#x3D; a[1] - 1;</span><br><span class="line">			else a[0] &#x3D; a[1];</span><br><span class="line">		&#125;</span><br><span class="line">		if (a[n - 1] &lt; a[n]) a[n + 1] &#x3D; a[n] - 1;</span><br><span class="line">		else if (a[n - 1] &gt; a[n]) a[n + 1] &#x3D; a[n] + 1;</span><br><span class="line">		else a[n + 1] &#x3D; a[n];</span><br><span class="line"></span><br><span class="line">		int first &#x3D; 1;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			int x &#x3D; a[i] - a[i - 1];</span><br><span class="line">			int y &#x3D; a[i] - a[i + 1];</span><br><span class="line">			</span><br><span class="line">			if (x*y &gt; 0) &#123;</span><br><span class="line">				if (first) first &#x3D; 0;</span><br><span class="line">				else printf(&quot; &quot;);</span><br><span class="line">				printf(&quot;%d&quot;, i-1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><p>读入一组字符串（待操作的），再读入一个int n记录记下来有几条命令，总共有2中命令：1、翻转  从下标为i的字符开始到i+len-1之间的字符串倒序；2、替换  命中如果第一位为1，用命令的第四位开始到最后的字符串替换原读入的字符串下标 i 到 i+len-1的字符串。每次执行一条命令后新的字符串代替旧的字符串（即下一条命令在作用在得到的新字符串上）。     命令格式：第一位0代表翻转，1代表替换；第二位代表待操作的字符串的起始下标int i；第三位表示需要操作的字符串长度int len。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">char s[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%s&quot;,s)&#x3D;&#x3D;1)</span><br><span class="line">	&#123;</span><br><span class="line">		int n;</span><br><span class="line">		int first &#x3D; 1;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		int op, index, len;</span><br><span class="line">		char ex[maxn];</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%1d%1d%1d&quot;, &amp;op, &amp;index, &amp;len);</span><br><span class="line">			if (op) scanf(&quot;%s&quot;,ex);</span><br><span class="line">			if (op &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				for (int j &#x3D; 0; 2*j &lt; len; j++) &#123;</span><br><span class="line">					swap(s[index + j], s[index + len - j-1]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				char tmp[maxn]&#123;&#39;\0&#39;&#125;;</span><br><span class="line">				for (int j &#x3D; 0; j &lt; index; j++) tmp[j] &#x3D; s[j];</span><br><span class="line">				for (int j &#x3D; 0; j &lt; strlen(ex); j++)</span><br><span class="line">					tmp[j + index] &#x3D; ex[j];</span><br><span class="line">				for (int j &#x3D; index; j &lt; strlen(s); j++)</span><br><span class="line">					tmp[j+strlen(ex)] &#x3D; s[j+len];</span><br><span class="line"></span><br><span class="line">				memcpy(s, tmp, sizeof(tmp));</span><br><span class="line">			&#125;</span><br><span class="line">			if (first) first &#x3D; 0;</span><br><span class="line">			else printf(&quot;\n&quot;);</span><br><span class="line">			printf(&quot;%s&quot;, s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="FatMouse’s-Trade"><a href="#FatMouse’s-Trade" class="headerlink" title="FatMouse’s Trade"></a>FatMouse’s Trade</h2><p>FatMouse prepared M pounds of cat food, ready to trade with the cats guarding the warehouse containing his favorite food, JavaBean.<br>The warehouse has N rooms. The i-th room contains J[i] pounds of JavaBeans and requires F[i] pounds of cat food. FatMouse does not have to trade for all the JavaBeans in the room, instead, he may get J[i]* a% pounds of JavaBeans if he pays F[i]* a% pounds of cat food. Here a is a real number. Now he is assigning this homework to you: tell him the maximum amount of JavaBeans he can obtain. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int j;</span><br><span class="line">	int f;</span><br><span class="line">	double v;</span><br><span class="line">	bool operator &lt;(const node &amp;a) const &#123; return v &lt; a.v; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node a[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int m, n;</span><br><span class="line">	int j, f;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;m, &amp;n) &amp;&amp; m !&#x3D; -1 &amp;&amp; n !&#x3D; -1) &#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;j, &amp;f);</span><br><span class="line">			a[i].f &#x3D; f;</span><br><span class="line">			a[i].j &#x3D; j;</span><br><span class="line">			a[i].v &#x3D; double(j) &#x2F; f;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a, a + n);</span><br><span class="line">		double ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			if (m &gt; a[i].f) &#123;</span><br><span class="line">				m -&#x3D; a[i].f;</span><br><span class="line">				ans +&#x3D; a[i].j;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				ans +&#x3D; double(m) * a[i].j &#x2F; a[i].f;</span><br><span class="line">				m &#x3D; 0;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (m &lt;&#x3D; 0) break;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%.3f\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择不连续区间问题"><a href="#选择不连续区间问题" class="headerlink" title="选择不连续区间问题"></a>选择不连续区间问题</h2><h2 id="迷瘴"><a href="#迷瘴" class="headerlink" title="迷瘴"></a>迷瘴</h2><p>通过悬崖的yifenfei，又面临着幽谷的考验——<br>幽谷周围瘴气弥漫，静的可怕，隐约可见地上堆满了骷髅。由于此处长年不见天日，导致空气中布满了毒素，一旦吸入体内，便会全身溃烂而死。<br>幸好yifenfei早有防备，提前备好了解药材料（各种浓度的万能药水）。现在只需按照配置成不同比例的浓度。<br>现已知yifenfei随身携带有n种浓度的万能药水，体积V都相同，浓度则分别为Pi%。并且知道，针对当时幽谷的瘴气情况，只需选择部分或者全部的万能药水，然后配置出浓度不大于 W%的药水即可解毒。<br>现在的问题是：如何配置此药，能得到最大体积的当前可用的解药呢？<br>特别说明：由于幽谷内设备的限制,只允许把一种已有的药全部混入另一种之中（即：不能出现对一种药只取它的一部分这样的操作）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">int a[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	int n, v, w;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, &amp;n, &amp;v, &amp;w);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a, a + n);</span><br><span class="line"></span><br><span class="line">		double nw &#x3D; 0;</span><br><span class="line">		int nv &#x3D; 0;</span><br><span class="line">		double tmp;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			tmp &#x3D; (nw  * nv + a[i] * v) &#x2F; (v + nv);</span><br><span class="line">			if (tmp &lt;&#x3D; w) &#123;</span><br><span class="line">				nw &#x3D; tmp;</span><br><span class="line">				nv +&#x3D; v;</span><br><span class="line">			&#125;</span><br><span class="line">			else break;</span><br><span class="line">		&#125;</span><br><span class="line">		if(nv&#x3D;&#x3D;0)</span><br><span class="line">			printf(&quot;0 0.00\n&quot;);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot;%d %.2lf\n&quot;, nv, nw&#x2F;100);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>我的实现全部使用整型避免了浮点数误差。关于<a href="https://www.cnblogs.com/crazyacking/p/4668471.html" target="_blank" rel="noopener">浮点数误差</a></li>
</ol>
<h2 id="To-Fill-or-Not-to-Fill"><a href="#To-Fill-or-Not-to-Fill" class="headerlink" title="To Fill or Not to Fill"></a>To Fill or Not to Fill</h2><p>With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go.</p>
<p>For each case, the first line contains 4 positive numbers: Cmax (&lt;= 100), the maximum capacity of the tank; D (&lt;=30000), the distance between Hangzhou and the destination city; Davg (&lt;=20), the average distance per unit gas that the car can run; and N (&lt;= 500), the total number of gas stations. Then N lines follow, each contains a pair of non-negative numbers: Pi, the unit gas price, and Di (&lt;=D), the distance between this station and Hangzhou, for i=1,…N. All the numbers in a line are separated by a space.</p>
<p>For each test case, print the cheapest price in a line, accurate up to 2 decimal places. It is assumed that the tank is empty at the beginning. If it is impossible to reach the destination, print “The maximum travel distance = X” where X is the maximum possible distance the car can run, accurate up to 2 decimal places.</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>在每一站处，查找能到达的站中油价比当前站便宜的站。如果没有，则找一个相对最便宜的。</p>
<ol>
<li>如果找到了比当前站便宜的，那么在本站只需要加油到刚好到达最便宜的站。</li>
<li>如果没有比当前更便宜的，那么把油箱加满，并直接开到这个相对最便宜的站。</li>
</ol>
</li>
<li><p>如果在当前的站处能够到达的最大范围内都没有站</p>
<ol>
<li>如果能到达终点，那么输出总价</li>
<li>否则计算出走的最大长度，加上当前站的位置即为最大移动距离</li>
</ol>
</li>
<li><p>这样保证了每次都是朝着油价最便宜的站进发，同时油箱里的油比沿路的站都便宜。</p>
</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 500 + 5;</span><br><span class="line">struct node &#123;</span><br><span class="line">	double price;</span><br><span class="line">	double dis;</span><br><span class="line">	bool operator &lt; (const node&amp;a) const &#123;</span><br><span class="line">		return dis &lt; a.dis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int ns &#x3D; 0;</span><br><span class="line"></span><br><span class="line">node a[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	double c, dis, cost;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%lf%lf%lf%d&quot;, &amp;c, &amp;dis, &amp;cost, &amp;n) &#x3D;&#x3D; 4)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			scanf(&quot;%lf%lf&quot;, &amp;a[i].price, &amp;a[i].dis);</span><br><span class="line">		&#x2F;&#x2F;a[n].price &#x3D; 0;</span><br><span class="line">		&#x2F;&#x2F;a[n].dis &#x3D; dis;</span><br><span class="line">		sort(a, a + n);</span><br><span class="line">		double maxd &#x3D; c * cost;</span><br><span class="line">		double nc &#x3D; 0;</span><br><span class="line">		double no &#x3D; 0;</span><br><span class="line">		int ns &#x3D; 0;</span><br><span class="line">		if (dis&#x3D;&#x3D; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;0.00\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		if (a[0].dis !&#x3D; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;The maximum travel distance &#x3D; 0.00\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		while (ns &lt; n) &#123;</span><br><span class="line">			&#x2F;&#x2F;printf(&quot;%d\n&quot;, ns);</span><br><span class="line">			double minc &#x3D; 100000;</span><br><span class="line">			int index;</span><br><span class="line">			bool havenx &#x3D; false;</span><br><span class="line">			bool cheaper &#x3D; false;</span><br><span class="line">			for (int i &#x3D; ns + 1; i &lt; n; i++) &#123;</span><br><span class="line">				if ((a[i].dis - a[ns].dis) &lt;&#x3D; maxd) &#123;&#x2F;&#x2F;有更便宜的</span><br><span class="line">					havenx &#x3D; true;</span><br><span class="line">					if (a[i].price &lt; a[ns].price) &#123;</span><br><span class="line">						cheaper &#x3D; true;</span><br><span class="line">						double d &#x3D; a[i].dis - a[ns].dis;</span><br><span class="line">						nc +&#x3D; a[ns].price*(d &#x2F; cost - no);</span><br><span class="line">						no &#x3D; 0;</span><br><span class="line">						ns &#x3D; i;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					else if (a[i].price &lt; minc) &#123;&#x2F;&#x2F;目前没有更便宜的，则记录一下相对最便宜的</span><br><span class="line">						minc &#x3D; a[i].price;</span><br><span class="line">						index &#x3D; i;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				else break;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (!cheaper &amp;&amp; (maxd &gt;&#x3D; (dis - a[ns].dis))) &#123;</span><br><span class="line">				</span><br><span class="line">				&#x2F;&#x2F;没有更便宜的，但是能直接走到终点，那么直接走</span><br><span class="line">				double d &#x3D; dis - a[ns].dis;</span><br><span class="line">				nc +&#x3D; (d &#x2F; cost - no)*a[ns].price;</span><br><span class="line">				printf(&quot;%.2lf\n&quot;, nc);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			if (!cheaper &amp;&amp; havenx) &#123;</span><br><span class="line">			</span><br><span class="line">				&#x2F;&#x2F;范围内有站，但是没有更便宜的</span><br><span class="line">				nc +&#x3D; (c - no)*a[ns].price;</span><br><span class="line">				double d &#x3D; a[index].dis - a[ns].dis;</span><br><span class="line">				no &#x3D; c - d &#x2F; cost;</span><br><span class="line">				ns &#x3D; index;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (!havenx) &#123;</span><br><span class="line">			</span><br><span class="line">				&#x2F;&#x2F;没有站也到不了终点</span><br><span class="line">				printf(&quot;The maximum travel distance &#x3D; %.2lf\n&quot;,</span><br><span class="line">					a[ns].dis + maxd);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-考研机试目录" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/30/%E8%80%83%E7%A0%94%E6%9C%BA%E8%AF%95%E7%9B%AE%E5%BD%95/"
    >考研机试目录</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/30/%E8%80%83%E7%A0%94%E6%9C%BA%E8%AF%95%E7%9B%AE%E5%BD%95/" class="article-date">
  <time datetime="2020-03-30T03:55:14.299Z" itemprop="datePublished">2020-03-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h2 id="基础相关"><a href="#基础相关" class="headerlink" title="基础相关"></a><a href="/2020/03/30/基础相关/">基础相关</a></h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><a href="/2020/03/30/数据结构/">数据结构</a></h2><h2 id="数学理论"><a href="#数学理论" class="headerlink" title="数学理论"></a><a href="/2020/03/30/数学理论/">数学理论</a></h2><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a><a href="/2020/03/30/搜索/">搜索</a></h2><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a><a href="/2020/03/30/动态规划/">动态规划</a></h2><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a><a href="/2020/03/30/图论/">图论</a></h2><h2 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a><a href="/2020/03/30/其他技巧/">其他技巧</a></h2>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hide/" rel="tag">hide</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/6/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        John Doe
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>