<!DOCTYPE html>


<html lang="en" >


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    操作系统 |  Hexo
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

  <script type="text/javascript"
	src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      <section class="outer">
  <article id="post-操作系统" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  操作系统
</h1>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/06/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time datetime="2020-06-20T04:24:31.124Z" itemprop="datePublished">2020-06-20</time>
</a>
      
      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">10.3k字</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">35分钟</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1>
<h2 id="基本特征"><a class="markdownIt-Anchor" href="#基本特征"></a> 基本特征</h2>
<h3 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h3>
<ol>
<li><strong>并发</strong>是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令</li>
<li>硬件上需要多流水线，多核处理器或者分布式计算机系统</li>
<li>操作系统上需要引入进程和线程，使得程序能够并发执行</li>
</ol>
<h3 id="共享"><a class="markdownIt-Anchor" href="#共享"></a> 共享</h3>
<ol>
<li>包括互斥共享和同时共享</li>
</ol>
<h3 id="虚拟"><a class="markdownIt-Anchor" href="#虚拟"></a> 虚拟</h3>
<ol>
<li><strong>虚拟技术</strong>：把一个物理实体转换为多个逻辑实体</li>
<li><strong>主要技术</strong>包括：
<ol>
<li>时分复用技术：多个进程再同一个处理器上并发执行，每个进程轮流占用处理器</li>
<li>空分复用技术：如虚拟内存技术。将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</li>
</ol>
</li>
</ol>
<h3 id="异步"><a class="markdownIt-Anchor" href="#异步"></a> 异步</h3>
<p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p>
<h2 id="基本功能"><a class="markdownIt-Anchor" href="#基本功能"></a> 基本功能</h2>
<h3 id="进程管理"><a class="markdownIt-Anchor" href="#进程管理"></a> 进程管理</h3>
<p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p>
<h3 id="内存管理"><a class="markdownIt-Anchor" href="#内存管理"></a> 内存管理</h3>
<p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p>
<h3 id="文件管理"><a class="markdownIt-Anchor" href="#文件管理"></a> 文件管理</h3>
<p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p>
<h3 id="设备管理"><a class="markdownIt-Anchor" href="#设备管理"></a> 设备管理</h3>
<p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p>
<p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p>
<h2 id="大内核和微内核"><a class="markdownIt-Anchor" href="#大内核和微内核"></a> 大内核和微内核</h2>
<img src="D:\MyBlog\source\MyImages\image-20200410143512321.png" alt="image-20200410143512321" style="zoom:80%;" />
<h3 id="大内核"><a class="markdownIt-Anchor" href="#大内核"></a> 大内核</h3>
<p>大内核是将操作系统功能作为一个紧密结合的整体放到内核。</p>
<p>由于各模块共享信息，因此有很高的性能。</p>
<h3 id="微内核"><a class="markdownIt-Anchor" href="#微内核"></a> 微内核</h3>
<p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p>
<p>在微内核结构下，操作系统被划分成小的、定义良好的模块，<strong>只有微内核这一个模块运行在内核态，其余模块运行在用户态。</strong></p>
<p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p>
<h2 id="中断分类"><a class="markdownIt-Anchor" href="#中断分类"></a> 中断分类</h2>
<ul>
<li>
<p>中断”是让操作系统内核夺回CPU使用权的唯一途径</p>
</li>
<li>
<p>过程：</p>
<ul>
<li>内核态-&gt;用户态：执行一条特权指令——修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权</li>
<li>用户态-&gt;内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权</li>
</ul>
</li>
<li>
<p>分类</p>
<img src="D:\MyBlog\source\MyImages\image-20200410132435683.png" alt="image-20200410132435683" style="zoom: 80%;" />
<ul>
<li>内中断比如除0；有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令——陷入指令，该指令会引发一个内部中断信号</li>
<li>外中断比如时钟中断</li>
</ul>
<img src="D:\MyBlog\source\MyImages\image-20200410142357027.png" alt="image-20200410142357027" style="zoom: 80%;" />
</li>
<li>
<p>基本原理:不同的中断信号，需要用不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置。</p>
</li>
</ul>
<h2 id="系统调用"><a class="markdownIt-Anchor" href="#系统调用"></a> 系统调用</h2>
<ul>
<li>
<p><strong>什么时候用到系统调</strong>用：系统中的各种共享资源都由操作系统内核统一掌管，因此<strong>凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式</strong>向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</p>
</li>
<li>
<p>分类</p>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200410142827633.png" alt="image-20200410142827633" /></p>
</li>
<li>
<p>系统调用过程</p>
<ul>
<li>
<p>程序执行陷入指令</p>
</li>
<li>
<p>引发内中断：该中断由陷入指令 引发，因此转入相 应的中断处理程 序——即 系统调用 的入口程序</p>
</li>
<li>
<p>根据寄存器中的参数判断用户需要那种系统调用服务</p>
</li>
<li>
<p>传递系统调用参数</p>
<p>-&gt; 执行陷入指令（用户态）</p>
<p>-&gt; 执行相应的内请求核程序处理系统调用（核心态）</p>
<p>-&gt;  返回应用程序</p>
</li>
</ul>
</li>
</ul>
<h1 id="进程管理-2"><a class="markdownIt-Anchor" href="#进程管理-2"></a> 进程管理</h1>
<h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2>
<ul>
<li>
<p>进程的组成：</p>
<ul>
<li>
<p><strong>PCB 进程控制块</strong>，但凡管理时所需要的信息，都会被放在PCB中</p>
<img src="D:\MyBlog\source\MyImages\image-20200410143922690.png" alt="image-20200410143922690" style="zoom:80%;" />
<p><strong>PCB 是给操作系统用的。</strong></p>
</li>
<li>
<p><strong>程序段、数据段</strong>是给进程自己用的。</p>
</li>
</ul>
</li>
<li>
<p>**进程实体（进程映像）**由PCB、程序段、数据段组成。进程是动态的，进程实体（进程映像）是静态的。</p>
</li>
<li>
<p><strong>进程的特征</strong></p>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200410144454179.png" alt="image-20200410144454179" /></p>
</li>
</ul>
<h2 id="进程和线程"><a class="markdownIt-Anchor" href="#进程和线程"></a> 进程和线程</h2>
<h3 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h3>
<p><strong>进程是资源分配的基本单位。</strong></p>
<p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p>
<h3 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h3>
<p><strong>线程是独立调度的基本单位</strong></p>
<p>一个进程中可以有<strong>多个线程</strong>，它们<strong>共享进程资源。</strong></p>
<p>QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p>
<h3 id="区别"><a class="markdownIt-Anchor" href="#区别"></a> 区别</h3>
<ol>
<li>
<p>资源</p>
<p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p>
</li>
<li>
<p>调度</p>
<p><strong>线程是独立调度的基本单位</strong>，在<strong>同一进程中，线程的切换不会引起进程切换</strong>，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p>
</li>
<li>
<p>系统开销</p>
<p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p>
</li>
<li>
<p>通信方面</p>
<p><strong>线程</strong>间<strong>可以通过直接读写同一进程中的数据进行通信</strong>，但是进程通信需要借助 IPC。</p>
</li>
</ol>
<h2 id="进程的组织形式"><a class="markdownIt-Anchor" href="#进程的组织形式"></a> 进程的组织形式</h2>
<img src="D:\MyBlog\source\MyImages\image-20200410150055787.png" alt="image-20200410150055787" style="zoom:80%;" />
<ul>
<li>
<p>链接方式</p>
<img src="D:\MyBlog\source\MyImages\image-20200410150137085.png" alt="image-20200410150137085" style="zoom:80%;" />
</li>
<li>
<p>索引方式</p>
<img src="D:\MyBlog\source\MyImages\image-20200410150259354.png" alt="image-20200410150259354" style="zoom:80%;" />
</li>
</ul>
<h2 id="进程控制"><a class="markdownIt-Anchor" href="#进程控制"></a> 进程控制</h2>
<h3 id="进程状态的切换"><a class="markdownIt-Anchor" href="#进程状态的切换"></a> 进程状态的切换</h3>
<img src="D:\MyBlog\source\MyImages\image-20200410150355564.png" alt="image-20200410150355564" style="zoom:80%;" />
<p>注意：</p>
<ol>
<li>
<p><strong>只有就绪态和运行态可以相互转换</strong>，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</p>
</li>
<li>
<p><strong>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间</strong>，缺少 CPU 时间会从运行态转换为就绪态。</p>
</li>
<li>
<p>实现进程控制—原语</p>
<ul>
<li>
<p>原语是一种特殊的程序， 它的执行具有原子性。 也就是说，这段程序的 运行必须一气呵成，<strong>不可中断</strong></p>
</li>
<li>
<p>如果不能“一气呵成”，就有可能导致操作系</p>
<p>统中的某些关键数据结构信息不统一的情况，</p>
<p>这会影响操作系统进行别的管理工作</p>
</li>
</ul>
</li>
<li>
<p><strong>原语</strong></p>
<ul>
<li>原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断。 可以用 <strong>“关中断指令”和“开中断指令”<strong>这两个特权指令</strong>实现原子性</strong></li>
</ul>
</li>
</ol>
<h3 id="进程控制原语"><a class="markdownIt-Anchor" href="#进程控制原语"></a> 进程控制原语</h3>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200410151119920.png" alt="image-20200410151119920" /></p>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200410151130433.png" alt="image-20200410151130433" /></p>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200410151140239.png" alt="image-20200410151140239" /></p>
<img src="D:\MyBlog\source\MyImages\image-20200410151152896.png" alt="image-20200410151152896" style="zoom: 67%;" />
<h2 id="进程调度"><a class="markdownIt-Anchor" href="#进程调度"></a> 进程调度</h2>
<h3 id="进程调度算法"><a class="markdownIt-Anchor" href="#进程调度算法"></a> 进程调度算法</h3>
<h4 id="批处理系统"><a class="markdownIt-Anchor" href="#批处理系统"></a> 批处理系统</h4>
<ol>
<li><strong>先来先服务</strong>：利于长作业，而不利于短作业</li>
<li><strong>短作业优先</strong>：非抢占式调度，按估计的运行时间最短顺序调度；利于短作业，不利于长作业。</li>
<li><strong>最短剩余时间优先</strong>：抢占式的最短作业优先。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</li>
</ol>
<h4 id="交互式系统"><a class="markdownIt-Anchor" href="#交互式系统"></a> 交互式系统</h4>
<ol>
<li>
<p><strong>时间片轮转</strong>：实际的效率与时间片的大小有很大关系</p>
<ol>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果<strong>时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间</strong>。</li>
<li>而如果时间片过长，那么实时性就不能得到保证。</li>
</ol>
</li>
<li>
<p><strong>优先级调度</strong>：为每个进程分配一个优先级，按优先级进行调度。</p>
<p><strong>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</strong></p>
</li>
<li>
<p><strong>多级反馈队列</strong></p>
<img src="D:\MyBlog\source\MyImages\image-20200604234940574.png" alt="image-20200604234940574" style="zoom: 67%;" />
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,…。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>
<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
</li>
</ol>
<h4 id="实时系统"><a class="markdownIt-Anchor" href="#实时系统"></a> 实时系统</h4>
<p>实时系统要求一个请求在一个确定时间内得到响应。</p>
<p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<h2 id="进程同步"><a class="markdownIt-Anchor" href="#进程同步"></a> 进程同步</h2>
<h3 id="临界区"><a class="markdownIt-Anchor" href="#临界区"></a> 临界区</h3>
<p>对临界资源进行访问的那段代码称为临界区。</p>
<p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p>
<h3 id="同步与互斥"><a class="markdownIt-Anchor" href="#同步与互斥"></a> 同步与互斥</h3>
<ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li>
</ul>
<h3 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h3>
<p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
<ul>
<li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>
<li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>
</ul>
<p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p>
<h3 id="管程"><a class="markdownIt-Anchor" href="#管程"></a> 管程</h3>
<ul>
<li>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而<strong>管程把控制的代码独立出来</strong>，不仅不容易出错，也使得客户端代码调用更容易。</li>
<li>管程有一个重要特性：**在一个时刻只能有一个进程使用管程。**进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</li>
<li>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</li>
</ul>
<h3 id="经典同步问题"><a class="markdownIt-Anchor" href="#经典同步问题"></a> 经典同步问题</h3>
<h4 id="哲学家问题"><a class="markdownIt-Anchor" href="#哲学家问题"></a> 哲学家问题</h4>
<p>为了防止死锁的发生，可以设置两个条件：</p>
<ul>
<li>必须同时拿起左右两根筷子；</li>
<li>只有在两个邻居都没有进餐的情况下才允许进餐。</li>
</ul>
<h4 id="读者-写者问题"><a class="markdownIt-Anchor" href="#读者-写者问题"></a> 读者-写者问题</h4>
<ul>
<li>
<p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p>
</li>
<li>
<p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">        <span class="built_in">read</span>();</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        <span class="built_in">write</span>();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进程通信"><a class="markdownIt-Anchor" href="#进程通信"></a> 进程通信</h2>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200410151426847.png" alt="image-20200410151426847" /></p>
<h3 id="进程通信-进程同步"><a class="markdownIt-Anchor" href="#进程通信-进程同步"></a> 进程通信 &amp; 进程同步</h3>
<p>进程同步与进程通信很容易混淆，它们的区别在于：</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行；</li>
<li>进程通信：进程间传输信息。</li>
</ul>
<p><strong>进程通信是一种手段，而进程同步是一种目的</strong>。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<h3 id="管道"><a class="markdownIt-Anchor" href="#管道"></a> 管道</h3>
<p>它具有以下限制：</p>
<ul>
<li>只支持半双工通信（单向交替传输）；</li>
<li><strong>只能在父子进程或者兄弟进程中使用</strong>。</li>
<li>各进程要<strong>互斥</strong>地访问管道。</li>
<li>数据以<strong>字符流</strong>的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据<strong>全部取走后</strong>，管道变空，此时读进程的read()系统调用将被阻塞。</li>
<li><strong>如果没写满，就不允许读。如果没读空，就不允许写</strong>。</li>
<li><strong>数据一旦被读出，就从管道中被抛弃</strong>，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。</li>
</ul>
<h3 id="fifo"><a class="markdownIt-Anchor" href="#fifo"></a> FIFO</h3>
<ul>
<li>又称有名管道</li>
<li>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</li>
</ul>
<h3 id="消息队列"><a class="markdownIt-Anchor" href="#消息队列"></a> 消息队列</h3>
<ul>
<li>进程间的数据交换以<strong>格式化的消息</strong>（Message）为单位。进程通过操作系统提供的“<strong>发送消息/接收消息</strong>”两个<strong>原语</strong>进行数据交换</li>
</ul>
<ul>
<li>消息队列<strong>可以独立于读写进程存在</strong>，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li>
<li><strong>读进程可以根据消息类型有选择地接收消息</strong>，而不像 FIFO 那样只能默认地接收。</li>
</ul>
<h3 id="信号量-2"><a class="markdownIt-Anchor" href="#信号量-2"></a> 信号量</h3>
<p><strong>它是一个计数器</strong>，用于为多个进程提供对共享数据对象的访问。</p>
<h3 id="共享存储"><a class="markdownIt-Anchor" href="#共享存储"></a> 共享存储</h3>
<p>两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现）</p>
<ul>
<li>
<p><strong>基于数据结构的共享</strong>：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式</p>
</li>
<li>
<p><strong>基于存储区的共享</strong>：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制， 而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。</p>
</li>
</ul>
<p>允许多个进程共享一个给定的存储区。<strong>因为数据不需要在进程之间复制</strong>，所以这是<strong>最快</strong>的一种 IPC。</p>
<p>需要<strong>使用信号量用来同步对共享存储的访问</strong>。</p>
<p>多个进程<strong>可以将同一个文件映射到它们的地址空间从而实现共享内存</strong>。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p>
<h3 id="套接字"><a class="markdownIt-Anchor" href="#套接字"></a> 套接字</h3>
<p>与其它通信机制不同的是，它可用于<strong>不同机器间的进程通信</strong>。</p>
<h2 id="线程-2"><a class="markdownIt-Anchor" href="#线程-2"></a> 线程</h2>
<ul>
<li>线程是一个基本的CPU执行单元，也是程序执行流的最小单位
<ul>
<li>进程是系统分配资源的基本单位，线程是系统调度的基本单位。从属于同一进程的各个线程共享进程的资源。</li>
</ul>
</li>
<li>优点
<ul>
<li>线程间并发，开销更小(不需要操作系统调度)</li>
<li>在多CPU环境下，各个线程也可以分派到不同的CPU上并发执行</li>
<li>增加系统的并发度</li>
</ul>
</li>
</ul>
<h3 id="线程的实现方式"><a class="markdownIt-Anchor" href="#线程的实现方式"></a> 线程的实现方式</h3>
<h4 id="用户级线程"><a class="markdownIt-Anchor" href="#用户级线程"></a> 用户级线程</h4>
<img src="D:\MyBlog\source\MyImages\image-20200410154146273.png" alt="image-20200410154146273" style="zoom:80%;" />
<ul>
<li>用户级线程由应用程序通过线程库实现。 所有的线程管理工作都由应用程序负责（包括线程切换）</li>
<li>用户级线程中，线程切换可以在用户态下即可完成，<strong>无需操作系统干预</strong>。</li>
<li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在（用户级线程对用户不透明，对操作系统透明）</li>
</ul>
<h4 id="内核级线程"><a class="markdownIt-Anchor" href="#内核级线程"></a> 内核级线程</h4>
<img src="D:\MyBlog\source\MyImages\image-20200410154205246.png" alt="image-20200410154205246" style="zoom:80%;" />
<ul>
<li>内核级线程的管理工作<strong>由操作系统内核完成</strong>。 线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</li>
<li>可以这样理解，<strong>“内核级线程”就是“从操作系统内核视角看能看到的线程</strong>”</li>
</ul>
<h4 id="综合方式"><a class="markdownIt-Anchor" href="#综合方式"></a> 综合方式</h4>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200410154424552.png" alt="image-20200410154424552" /></p>
<ul>
<li>在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将n个用户级线程映射到m个内核级线程上（ n &gt;= m）</li>
<li><strong>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位</strong></li>
</ul>
<h3 id="多线程模型"><a class="markdownIt-Anchor" href="#多线程模型"></a> 多线程模型</h3>
<h4 id="一对多模型"><a class="markdownIt-Anchor" href="#一对多模型"></a> 一对多模型</h4>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200410154521212.png" alt="image-20200410154521212" /></p>
<ul>
<li>一对多模型：将多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程</li>
<li><strong>优点</strong>：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li>
<li><strong>缺点</strong>：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</li>
</ul>
<h4 id="一对一模型"><a class="markdownIt-Anchor" href="#一对一模型"></a> 一对一模型</h4>
<img src="D:\MyBlog\source\MyImages\image-20200410154858257.png" alt="image-20200410154858257" style="zoom:80%;" />
<ul>
<li>一对一模型：一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</li>
<li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核 处理机上并行执行。</li>
<li>缺点：一个用户进程会占用多个内核级线程， 线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li>
</ul>
<h4 id="多对多模型"><a class="markdownIt-Anchor" href="#多对多模型"></a> 多对多模型</h4>
<ul>
<li>多对多模型：n 用户及线程映射到 m 个内核级线程（n &gt;= m）。每个用户进程对应 m 个内核级线程。</li>
<li>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内 核级线程，开销太大的缺点。</li>
</ul>
<h1 id="进程调度-2"><a class="markdownIt-Anchor" href="#进程调度-2"></a> 进程调度</h1>
<img src="D:\MyBlog\source\MyImages\image-20200410160026896.png" alt="image-20200410160026896" style="zoom:80%;" />
<h3 id="基本概念-2"><a class="markdownIt-Anchor" href="#基本概念-2"></a> 基本概念</h3>
<ul>
<li>处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</li>
</ul>
<h4 id="高级调度作业调度"><a class="markdownIt-Anchor" href="#高级调度作业调度"></a> 高级调度(作业调度)</h4>
<ul>
<li>按一定的原则从外存上处于<strong>后备队列的作业中挑选一个（或多个）作业</strong>， 给他们分配内存等必要资源，<strong>并建立相应的进程</strong>（建立PCB），以使它（们）获得竞争处理机的权利。</li>
<li>作业调入时会建立相应的PCB，作业调出时才撤销PCB</li>
</ul>
<h4 id="中级调度内存调度"><a class="markdownIt-Anchor" href="#中级调度内存调度"></a> 中级调度(内存调度)</h4>
<ul>
<li>引入了虚拟存储技术之后，可<strong>将暂时不能运行的进程调至外存等待</strong>。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。这么做的<strong>目的是为了提高内存利用率和系统吞吐量</strong>。</li>
<li>PCB常驻内存。被挂起的进程PCB会被放到的挂起队列中。</li>
</ul>
<h4 id="低级调度进程调度"><a class="markdownIt-Anchor" href="#低级调度进程调度"></a> 低级调度(进程调度)</h4>
<ul>
<li>其主要任务是按照某种方法和策略<strong>从就绪队列中选取一个进程，将处理机分配给它。</strong></li>
</ul>
<h4 id="对比"><a class="markdownIt-Anchor" href="#对比"></a> 对比</h4>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200410160541491.png" alt="image-20200410160541491" /></p>
<h3 id="调度算法"><a class="markdownIt-Anchor" href="#调度算法"></a> 调度算法</h3>
<h4 id="先来先服务"><a class="markdownIt-Anchor" href="#先来先服务"></a> 先来先服务</h4>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200410161834179.png" alt="image-20200410161834179" /></p>
<h4 id="最短作业优先"><a class="markdownIt-Anchor" href="#最短作业优先"></a> 最短作业优先</h4>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200410162007371.png" alt="image-20200410162007371" /></p>
<h4 id="最高响应比优先"><a class="markdownIt-Anchor" href="#最高响应比优先"></a> 最高响应比优先</h4>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200410162044259.png" alt="image-20200410162044259" /></p>
<h4 id="对比-2"><a class="markdownIt-Anchor" href="#对比-2"></a> 对比</h4>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200410162106676.png" alt="image-20200410162106676" /></p>
<h3 id="评价指标"><a class="markdownIt-Anchor" href="#评价指标"></a> 评价指标</h3>
<h4 id="cpu利用率"><a class="markdownIt-Anchor" href="#cpu利用率"></a> CPU利用率</h4>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200410161213084.png" alt="image-20200410161213084" /></p>
<h4 id="系统吞吐量"><a class="markdownIt-Anchor" href="#系统吞吐量"></a> 系统吞吐量</h4>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200410161234338.png" alt="image-20200410161234338" /></p>
<h4 id="周转时间"><a class="markdownIt-Anchor" href="#周转时间"></a> 周转时间</h4>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200410161257474.png" alt="image-20200410161257474" /></p>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200410161312274.png" alt="image-20200410161312274" /></p>
<h4 id="等待时间"><a class="markdownIt-Anchor" href="#等待时间"></a> 等待时间</h4>
<p>等待时间，指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低</p>
<ul>
<li>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。</li>
<li>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间</li>
</ul>
<h4 id="响应时间"><a class="markdownIt-Anchor" href="#响应时间"></a> 响应时间</h4>
<p>响应时间，指从用户提交请求到首次产生响应所用的时间。</p>
<h1 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h1>
<h2 id="必要条件"><a class="markdownIt-Anchor" href="#必要条件"></a> 必要条件</h2>
<ol>
<li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li>
<li>不可剥夺：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li>
<li>请求和保持：已经得到了某个资源的进程可以再请求新的资源。</li>
<li>循环等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ol>
<h2 id="处理方法"><a class="markdownIt-Anchor" href="#处理方法"></a> 处理方法</h2>
<h3 id="鸵鸟策略"><a class="markdownIt-Anchor" href="#鸵鸟策略"></a> 鸵鸟策略</h3>
<p>不管</p>
<h3 id="死锁的检测与恢复"><a class="markdownIt-Anchor" href="#死锁的检测与恢复"></a> 死锁的检测与恢复</h3>
<ol>
<li>
<p><strong>单个资源的死锁检测</strong>：使用资源分配图，看是否存在环</p>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200410164200804.png" alt="image-20200410164200804" /></p>
<ol>
<li>在资源分配图中，找出既不阻塞又不是孤点的进程 Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。如下图中，R1没有空闲资源，R2有 一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配变，使之称为孤立的结点。在下图中，P1 是满足这一条件的进程结点，于是将P1的所有边消去。</li>
<li>进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变 为非阻塞进程。在下图中，P2 就满足这样的条件。根据 1）中的方法进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的。</li>
</ol>
</li>
<li>
<p><strong>多个资源的死锁检测</strong>：银行家算法，判断能否寻找到一个不会发生死锁的资源分配序列。</p>
<p><strong><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200611154613285.png" alt="image-20200611154613285" /></strong></p>
</li>
<li>
<p><strong>死锁恢复</strong></p>
<ul>
<li><strong>资源剥夺法</strong>挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li>
<li><strong>撤销进程法</strong>（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行 了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li>
<li><strong>进程回退法</strong>。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li>
</ul>
</li>
</ol>
<h3 id="预防死锁"><a class="markdownIt-Anchor" href="#预防死锁"></a> 预防死锁</h3>
<ol>
<li><strong>破坏互斥条件</strong>
<ul>
<li>只有对必须互斥使用的资源的争抢才会导致死锁。</li>
<li>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如: SPOOLing技术：将一台物理设备虚拟成多个逻辑设备</li>
<li>缺点：并不是所有的资源都可以改造成可共享使用的资源</li>
</ul>
</li>
<li><strong>破坏请求和保持条件</strong>
<ul>
<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
<li>破坏：可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前， 不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</li>
</ul>
</li>
<li><strong>破坏不可剥夺条件</strong>
<ul>
<li>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</li>
<li>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</li>
</ul>
</li>
<li><strong>破坏循环等待条件</strong>：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。
<ul>
<li>破坏：可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。</li>
</ul>
</li>
</ol>
<h3 id="避免死锁"><a class="markdownIt-Anchor" href="#避免死锁"></a> 避免死锁</h3>
<p>银行家算法</p>
<h1 id="内存管理-2"><a class="markdownIt-Anchor" href="#内存管理-2"></a> 内存管理</h1>
<h2 id="内存的装入方式"><a class="markdownIt-Anchor" href="#内存的装入方式"></a> 内存的装入方式</h2>
<h3 id="绝对装入"><a class="markdownIt-Anchor" href="#绝对装入"></a> 绝对装入</h3>
<ul>
<li>绝对装入：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。 装入程序按照装入模块中的地址，将程序和数据装入内存。</li>
<li>只适用于单道程序环境</li>
</ul>
<h3 id="静态重定位"><a class="markdownIt-Anchor" href="#静态重定位"></a> 静态重定位</h3>
<ul>
<li>又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，<strong>指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址</strong>。可根据内存的当前情况，将装入模块装入到内存的适当位置。<strong>装入时对地址进行“重定位</strong>”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）</li>
<li>作业装入内存时，必须分配其要求的全部内存空间</li>
</ul>
<h3 id="动态重定位"><a class="markdownIt-Anchor" href="#动态重定位"></a> 动态重定位</h3>
<ul>
<li>又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，<strong>并不会立即把逻辑地址转换为物理地址</strong>，而是把<strong>地址转换推迟到程序真正要执行 时才进行</strong>。因此装入内存后所有的地址依然是逻辑地址。这种方式<strong>需要一个重定位寄存器的支持</strong>。</li>
</ul>
<h2 id="内存保护"><a class="markdownIt-Anchor" href="#内存保护"></a> 内存保护</h2>
<ul>
<li><strong>在CPU中设置一对上、下限寄存器</strong>，存放进程的上、下限地址。进程的指令要访问某个地址 时，CPU检查是否越界。</li>
<li>采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定 位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。</li>
</ul>
<h2 id="内存空间的扩展"><a class="markdownIt-Anchor" href="#内存空间的扩展"></a> 内存空间的扩展</h2>
<h3 id="覆盖技术"><a class="markdownIt-Anchor" href="#覆盖技术"></a> 覆盖技术</h3>
<ul>
<li>将程序分为多个段（多个模块）。 常用的段常驻内存，不常用的段在需要时调入内存。
<ul>
<li>需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）</li>
<li>不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存</li>
</ul>
</li>
<li>必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点：对用户不透明，增加了用户编程负担</li>
</ul>
<h3 id="交换技术"><a class="markdownIt-Anchor" href="#交换技术"></a> 交换技术</h3>
<ul>
<li>内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）</li>
<li>对应中级调度</li>
<li>PCB常驻内存</li>
</ul>
<h3 id="虚拟存储技术"><a class="markdownIt-Anchor" href="#虚拟存储技术"></a> 虚拟存储技术</h3>
<h2 id="内存的分配和回收"><a class="markdownIt-Anchor" href="#内存的分配和回收"></a> 内存的分配和回收</h2>
<h3 id="连续分配方式"><a class="markdownIt-Anchor" href="#连续分配方式"></a> 连续分配方式</h3>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200411171523066.png" alt="image-20200411171523066" /></p>
<h4 id="单一连续分配"><a class="markdownIt-Anchor" href="#单一连续分配"></a> 单一连续分配</h4>
<ul>
<li>内存分为系统区和用户区</li>
<li>内存中只能有一道用户程序，用户程序独占整个用户区空间</li>
</ul>
<h4 id="固定分区分配"><a class="markdownIt-Anchor" href="#固定分区分配"></a> 固定分区分配</h4>
<ul>
<li>将用户空间划分为若干个固定大小的分区，在每个分区中转入一道作业</li>
<li>分区大小不同，有分区大小相等的和分区大小不等的</li>
<li>需要一张分区说明表</li>
<li>有内碎片而没有外碎片</li>
</ul>
<h4 id="动态分区分配"><a class="markdownIt-Anchor" href="#动态分区分配"></a> 动态分区分配</h4>
<ul>
<li>不预先划分内存分区，而是程序进入内存时，根据进程的大小动态建立分区</li>
<li>需要空闲分区表和空闲分区链</li>
<li>没有内碎片，有外碎片</li>
<li>外碎片可以用紧缩技术解决</li>
</ul>
<h3 id="非连续分配方式"><a class="markdownIt-Anchor" href="#非连续分配方式"></a> 非连续分配方式</h3>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200411172728382.png" alt="image-20200411172728382" /></p>
<h4 id="基本分页"><a class="markdownIt-Anchor" href="#基本分页"></a> 基本分页</h4>
<ul>
<li>
<p>页表：记录页面和实际存放的内存块之间的映射关系</p>
<ul>
<li>一个进程对应一张页表</li>
<li>进程的每个页面对应一个页表项</li>
<li>每个页表项的长度是相同的</li>
</ul>
</li>
<li>
<p>地址转换</p>
<ul>
<li>
<p>确定逻辑地址A 对应的“页号”P</p>
</li>
<li>
<p>找到P号页面在内存中的起始地址（需要查页表）</p>
</li>
<li>
<p>确定逻辑地址A 的“页内偏移量”W</p>
</li>
<li>
<p>逻辑地址A 对应的物理地址 = P号页面在内存中的起始地址+页内偏移量W</p>
</li>
</ul>
</li>
</ul>
<h4 id="两级页表"><a class="markdownIt-Anchor" href="#两级页表"></a> 两级页表</h4>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200411175101753.png" alt="image-20200411175101753" /></p>
<h4 id="基本分段"><a class="markdownIt-Anchor" href="#基本分段"></a> 基本分段</h4>
<ul>
<li>
<p>进程地址空间按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址</p>
</li>
<li>
<p>段表</p>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200411175252974.png" alt="image-20200411175252974" /></p>
</li>
<li>
<p>地址变换</p>
<img src="D:\MyBlog\source\MyImages\image-20200411180247662.png" alt="image-20200411180247662" style="zoom: 67%;" />
</li>
</ul>
<h4 id="段页式管理"><a class="markdownIt-Anchor" href="#段页式管理"></a> 段页式管理</h4>
<h2 id="动态分区分配算法"><a class="markdownIt-Anchor" href="#动态分区分配算法"></a> 动态分区分配算法</h2>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200411172221938.png" alt="image-20200411172221938" /></p>
<h3 id="首次适应算法"><a class="markdownIt-Anchor" href="#首次适应算法"></a> 首次适应算法</h3>
<ul>
<li>每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</li>
<li><strong>实现</strong>空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链</li>
</ul>
<h3 id="最佳适应算法"><a class="markdownIt-Anchor" href="#最佳适应算法"></a> 最佳适应算法</h3>
<ul>
<li>每次选浪费最小的分区，从小容量的分区开始查找</li>
<li><strong>实现</strong>：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链，找到大小能满足要求的第一个空闲分区。</li>
</ul>
<h3 id="最坏适应算法"><a class="markdownIt-Anchor" href="#最坏适应算法"></a> 最坏适应算法</h3>
<ul>
<li>先用大空间的分区</li>
<li><strong>实现</strong>：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</li>
</ul>
<h3 id="近邻适应算法"><a class="markdownIt-Anchor" href="#近邻适应算法"></a> 近邻适应算法</h3>
<ul>
<li>每次都从上次查找结束的位置开始检索</li>
<li><strong>实现</strong>：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li>
</ul>
<h2 id="虚拟内存"><a class="markdownIt-Anchor" href="#虚拟内存"></a> 虚拟内存</h2>
<h3 id="局部性原理"><a class="markdownIt-Anchor" href="#局部性原理"></a> 局部性原理</h3>
<ul>
<li><strong>时间局部性</strong>：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）</li>
<li><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</li>
</ul>
<h3 id="虚拟内存-2"><a class="markdownIt-Anchor" href="#虚拟内存-2"></a> 虚拟内存</h3>
<ul>
<li>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存， 就可以让程序开始执行</li>
<li>主要特征
<ul>
<li>多次性：作业分成多次调入内存</li>
<li>对换性：作业无需常驻内存</li>
<li>虚拟性：从逻辑上扩展内存</li>
</ul>
</li>
</ul>
<h2 id="虚拟页式"><a class="markdownIt-Anchor" href="#虚拟页式"></a> 虚拟页式</h2>
<ul>
<li>在基本页式管理的基础上增加请求分页功能。在内存空间不够时，实现页面置换</li>
</ul>
<h3 id="缺页中断机构"><a class="markdownIt-Anchor" href="#缺页中断机构"></a> 缺页中断机构</h3>
<ul>
<li>当要访问的页面不存在时，产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断</li>
<li>此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列
<ul>
<li>如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。</li>
<li>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。</li>
</ul>
</li>
</ul>
<h3 id="地址变换"><a class="markdownIt-Anchor" href="#地址变换"></a> 地址变换</h3>
<img src="D:\MyBlog\source\MyImages\image-20200411183214560.png" alt="image-20200411183214560" style="zoom:80%;" />
<h2 id="页面置换算法"><a class="markdownIt-Anchor" href="#页面置换算法"></a> 页面置换算法</h2>
<img src="D:\MyBlog\source\MyImages\image-20200411183432240.png" alt="image-20200411183432240" style="zoom:80%;" />
<h3 id="最佳置换算法"><a class="markdownIt-Anchor" href="#最佳置换算法"></a> 最佳置换算法</h3>
<ul>
<li>每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。</li>
<li>无法实现</li>
</ul>
<h3 id="先进先出置换算法"><a class="markdownIt-Anchor" href="#先进先出置换算法"></a> 先进先出置换算法</h3>
<ul>
<li>每次选择淘汰的页面是最早进入内存的页面</li>
</ul>
<h3 id="最近最久未使用置换算法-lru"><a class="markdownIt-Anchor" href="#最近最久未使用置换算法-lru"></a> 最近最久未使用置换算法 LRU</h3>
<ul>
<li>每次淘汰的页面是最近最久未使用的页面</li>
<li><strong>实现</strong>：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。</li>
</ul>
<h3 id="最近未使用-nru"><a class="markdownIt-Anchor" href="#最近未使用-nru"></a> 最近未使用 NRU</h3>
<p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p>
<ul>
<li>R=0，M=0</li>
<li>R=0，M=1</li>
<li>R=1，M=0</li>
<li>R=1，M=1</li>
</ul>
<p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p>
<p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p>
<h3 id="时钟置换算法"><a class="markdownIt-Anchor" href="#时钟置换算法"></a> 时钟置换算法</h3>
<ul>
<li>为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫 ᧿中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫᧿（第二轮扫᧿中一定会有访问位为0的页面，因此简单的CLOCK 算法选择一个淘汰页面最多会经过两轮扫᧿）</li>
</ul>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200411183845299.png" alt="image-20200411183845299" /></p>
<h2 id="分页与分段的比较"><a class="markdownIt-Anchor" href="#分页与分段的比较"></a> 分页与分段的比较</h2>
<ul>
<li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li>
<li>地址空间的维度：分页是一维地址空间，分段是二维的。</li>
<li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li>
<li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li>
</ul>
<h1 id="设备管理-2"><a class="markdownIt-Anchor" href="#设备管理-2"></a> 设备管理</h1>
<h2 id="磁盘结构"><a class="markdownIt-Anchor" href="#磁盘结构"></a> 磁盘结构</h2>
<ul>
<li>盘面（Platter）：一个磁盘有多个盘面；</li>
<li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li>
<li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li>
<li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li>
<li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li>
<li>主轴（Spindle）：使整个盘面转动。</li>
</ul>
<img src="D:\MyBlog\source\MyImages\image-20200612195239615.png" alt="image-20200612195239615" style="zoom:80%;" />
<h2 id="磁盘调度算法"><a class="markdownIt-Anchor" href="#磁盘调度算法"></a> 磁盘调度算法</h2>
<p>影响因素</p>
<ul>
<li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li>
<li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li>
<li>实际的数据传输时间</li>
</ul>
<p>其中，寻道时间最长，因此磁盘调度的<strong>主要目标是使磁盘的平均寻道时间最短</strong></p>
<h3 id="先来先服务-2"><a class="markdownIt-Anchor" href="#先来先服务-2"></a> 先来先服务</h3>
<p><strong>按照磁盘请求的顺序进行调度</strong></p>
<p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使<strong>平均寻道时间可能较长。</strong></p>
<h3 id="最短寻道时间优先"><a class="markdownIt-Anchor" href="#最短寻道时间优先"></a> 最短寻道时间优先</h3>
<p><strong>优先调度与当前磁头所在磁道距离最近的磁道。</strong></p>
<p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p>
<h3 id="电梯算法"><a class="markdownIt-Anchor" href="#电梯算法"></a> 电梯算法</h3>
<p><strong>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</strong></p>
<p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p>
<p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p>
<h1 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h1>
<h2 id="编译系统"><a class="markdownIt-Anchor" href="#编译系统"></a> 编译系统</h2>
<img src="D:\MyBlog\source\MyImages\image-20200612201710989.png" alt="image-20200612201710989" style="zoom:67%;" />
<ul>
<li>预处理阶段：处理以 # 开头的预处理命令；</li>
<li>编译阶段：翻译成汇编文件；</li>
<li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li>
<li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</li>
</ul>
<h2 id="静态链接"><a class="markdownIt-Anchor" href="#静态链接"></a> 静态链接</h2>
<p><strong>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出</strong>。链接器主要完成以下两个任务：</p>
<ul>
<li>符号解析：<strong>每个符号对应于一个函数、一个全局变量或一个静态变量</strong>，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li>
<li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li>
</ul>
<h2 id="目标文件"><a class="markdownIt-Anchor" href="#目标文件"></a> 目标文件</h2>
<ul>
<li>可执行目标文件：可以直接在内存中执行；</li>
<li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li>
<li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；</li>
</ul>
<h2 id="动态链接"><a class="markdownIt-Anchor" href="#动态链接"></a> 动态链接</h2>
<p>静态库有以下两个问题：</p>
<ul>
<li>当静态库更新时那么整个程序都要重新进行链接；</li>
<li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li>
</ul>
<p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p>
<ul>
<li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li>
<li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li>
</ul>

      
      <!-- reward -->
      
      <div id="reward-btn">
        打赏
      </div>
      
    </div>
    
    
      <!-- copyright -->
      
        <div class="declare">
          <ul class="post-copyright">
            <li>
              <i class="ri-copyright-line"></i>
              <strong>版权声明： </strong s>
              本博客所有文章除特别声明外，均采用 <a href="https://www.apache.org/licenses/LICENSE-2.0.html" rel="external nofollow"
                target="_blank">Apache License 2.0</a> 许可协议。转载请注明出处！
            </li>
          </ul>
        </div>
        
    <footer class="article-footer">
      
          
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://github.com/Cccceb/Cccceb.github.io.git/2020/06/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>
      
      

    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            数据库系统
          
        </div>
      </a>
    
    
      <a href="/2020/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">计算机组成原理</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        app_id: '',
        app_key: '',
        path: window.location.pathname,
        notify: 'false',
        verify: 'false',
        avatar: 'mp',
        placeholder: '给我的文章加点评论吧~',
        recordIP: true
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        John Doe
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="http://shenyu-vip.lofter.com" target="_blank" rel="noopener">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>




<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>



<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>