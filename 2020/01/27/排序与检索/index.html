<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://github.com/Cccceb/Cccceb.github.io').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="归并排序 O(nlogn)基本步骤 划分问题： 把序列分成元素个数尽量相等的两半 递归求解： 把两半元素分别排序 合并问题： 把两个有序表合并成一个  代码123456789101112131415161718void merge_sort(int *A,int x,int y,int* T)&amp;#123;if(y-x&gt;1)&amp;#123;	int m &#x3D; x+(y-x)&#x2F;2;">
<meta property="og:type" content="article">
<meta property="og:title" content="排序与检索">
<meta property="og:url" content="https://github.com/Cccceb/Cccceb.github.io/2020/01/27/%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%A3%80%E7%B4%A2/index.html">
<meta property="og:site_name" content="Ceb">
<meta property="og:description" content="归并排序 O(nlogn)基本步骤 划分问题： 把序列分成元素个数尽量相等的两半 递归求解： 把两半元素分别排序 合并问题： 把两个有序表合并成一个  代码123456789101112131415161718void merge_sort(int *A,int x,int y,int* T)&amp;#123;if(y-x&gt;1)&amp;#123;	int m &#x3D; x+(y-x)&#x2F;2;">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-01-27T01:49:29.296Z">
<meta property="article:modified_time" content="2020-02-08T12:09:56.896Z">
<meta property="article:author" content="Cuienbo">
<meta property="article:tag" content="hide">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/27/%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%A3%80%E7%B4%A2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>排序与检索 | Ceb</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a href="https://github.com/you"><img style="position:absolute;" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_left_gray_6d6d6d.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>  
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ceb</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/27/%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%A3%80%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          排序与检索
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-27 09:49:29" itemprop="dateCreated datePublished" datetime="2020-01-27T09:49:29+08:00">2020-01-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-08 20:09:56" itemprop="dateModified" datetime="2020-02-08T20:09:56+08:00">2020-02-08</time>
              </span>

          
          <div>
            
                
            
          </div>
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="归并排序-O-nlogn"><a href="#归并排序-O-nlogn" class="headerlink" title="归并排序 O(nlogn)"></a>归并排序 O(nlogn)</h1><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ol>
<li>划分问题： 把序列分成元素个数尽量相等的两半</li>
<li>递归求解： 把两半元素分别排序</li>
<li>合并问题： 把两个有序表合并成一个</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void merge_sort(int *A,int x,int y,int* T)&#123;</span><br><span class="line">if(y-x&gt;1)&#123;</span><br><span class="line">	int m &#x3D; x+(y-x)&#x2F;2;</span><br><span class="line">	int p &#x3D; x,q &#x3D; m,i &#x3D; x; </span><br><span class="line">	merge_sort(A,x,m,T);</span><br><span class="line">	merge_sort(A,m,y,T);</span><br><span class="line">	while(p&lt;m||q&lt;y)&#123;</span><br><span class="line">		if(q&gt;&#x3D;y||(p&lt;m&amp;&amp;A[p]&lt;&#x3D;A[q]))</span><br><span class="line">		&#x2F;&#x2F;如果右侧表为空而左表非空或者左表元素小于右表元素，那么将左表复制到临时表</span><br><span class="line">			T[i++] &#x3D; A[p++];</span><br><span class="line">		else&#123;</span><br><span class="line">			 T[i++] &#x3D; A[q++];</span><br><span class="line">			 &#x2F;&#x2F;cnt+&#x3D;m-p;	可以统计逆序对的个数</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(i &#x3D; x;i&lt;y;i++) A[i] &#x3D; T[i]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>加入cnt+=m-p可以统计序列中逆序对的个数。</strong>这是因为合并的时候是按从小到大的顺序进行，当执行else语句时，说明此时右侧元素更小，此时左边还没来得及复制的元素就是左边所有比A[j]大的数，m-p即为他的个数。</li>
</ol>
<h1 id="快速排序-O-nlogn"><a href="#快速排序-O-nlogn" class="headerlink" title="快速排序 O(nlogn)"></a>快速排序 O(nlogn)</h1><ol>
<li>划分问题： 把数组的各个元素重排后分成左右两部分，使得左边的任意元素都小于或等于右边的任意元素</li>
<li>递归求解： 把左右两部分分别划分</li>
<li>合并问题： 不用合并，因为此时数组已经完全有序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void QSort( SqList &amp;L,  int  low,  int high) &#123;</span><br><span class="line">   if( low &lt; high)&#123;</span><br><span class="line">          pivotloc &#x3D; Partition( L, low, high);</span><br><span class="line">          QSort( L, low, pivotloc – 1);</span><br><span class="line">          QSort( L, pivotloc + 1, high);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Partition( SqList &amp;L,  int low,  int high)</span><br><span class="line">&#123; </span><br><span class="line">   L.r[0] &#x3D; L.r[low];</span><br><span class="line">   pivotkey &#x3D; L.r[low].key;</span><br><span class="line">   while( low &lt; high)&#123;</span><br><span class="line">        while( low &lt; high &amp;&amp; L.r[high].key &gt;&#x3D; pivotkey)  --high;</span><br><span class="line">        L.r[low] &#x3D; L.r[high];</span><br><span class="line">        while( low &lt; high &amp;&amp; L.r[low].key &lt;&#x3D; pivotkey)  ++low;</span><br><span class="line">        L.r[high] &#x3D; L.r[low];</span><br><span class="line">   &#125;</span><br><span class="line">   L.r[low] &#x3D; L.r[0];   </span><br><span class="line">   return low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol>
<li>可以解决的问题：选择出第k大的数。序列划分成A[low,pivotkey]和A[pivotkey+1,high]两部分，比较左侧元素个数q-p+1和k的大小关系，选择在左半部递归还是在右半部递归。</li>
</ol>
<h1 id="二分查找-适用于有序序列"><a href="#二分查找-适用于有序序列" class="headerlink" title="二分查找 适用于有序序列"></a>二分查找 适用于有序序列</h1><ol>
<li>划分问题： 将序列分成尽量相等的两份</li>
<li>递归求解： 在左半部分或者右半部分搜素</li>
<li>合并问题： 无需合并</li>
</ol>
<h2 id="迭代-常用"><a href="#迭代-常用" class="headerlink" title="迭代(常用)"></a>迭代(常用)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">int bsearch(int* A,int x,int y,int v)&#123;</span><br><span class="line">while(x&lt;y)&#123;</span><br><span class="line">	m &#x3D; x + (y-x)&#x2F;2;</span><br><span class="line">	if(A[m]&#x3D;&#x3D;v) return m;</span><br><span class="line">	else if(A[m]&gt;v) y &#x3D; m;</span><br><span class="line">	else x &#x3D; m+1;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">int bsearch(int l,int r)&#123;</span><br><span class="line">	int m &#x3D; l+(r-l)&#x2F;2;</span><br><span class="line">	if(A[m]&#x3D;&#x3D;goal) return m;</span><br><span class="line">	else if(goal&lt;A[m])</span><br><span class="line">		return bsearch(l,m);</span><br><span class="line">	else return bsearch(m+1,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="考虑新问题："><a href="#考虑新问题：" class="headerlink" title="考虑新问题："></a>考虑新问题：</h2><p>如果数组中有多个goal，如果返回目标值的完整区间(上例程序返回中间那一个的索引)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int lower_bound(int* A,int x,int y,int v)&#123;</span><br><span class="line">int m;</span><br><span class="line">while(x&lt;y)&#123;</span><br><span class="line">	m &#x3D; x + (y-x)&#x2F;2;</span><br><span class="line">	if(A[m]&gt;&#x3D;v) y &#x3D; m;</span><br><span class="line">	else x &#x3D; m+1;</span><br><span class="line">&#125;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>上述程序返回v的第一个出现位置或者是返回一个下标i，在i处插入v，后面的序列仍然有序。</li>
<li>虽然搜索的区间是[x,y)，但是v可能比A[y-1]要大，所以返回值的取值范围在[x,y]。A[m]和v的关系的影响包括：<ol>
<li>A[m]==v 时，至少找到了一个，但是左边可能还有，搜索区间变成[x,m]</li>
<li>A[m]&gt;v 时，所求位置不可能在后面，但可能是m，因此区间变成[x,m]</li>
<li>A[m]&lt;v 时，区间变成[m+1,y]</li>
</ol>
</li>
<li>相应的可以写出upper_bound，共同构成    [L,R)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int upper_bound(int* A,int x,int y,int v)&#123;</span><br><span class="line">int m;</span><br><span class="line">while(x&lt;y)&#123;</span><br><span class="line">	m &#x3D; x+(y-x)&#x2F;2;</span><br><span class="line">	if(A[m]&lt;&#x3D;v) x &#x3D; m+1;</span><br><span class="line">	else y &#x3D; m;</span><br><span class="line">&#125;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-中"><a href="#C-中" class="headerlink" title="C++中"></a>C++中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;lower_bound(起始地址，结束地址，要查找的数值) 返回大于或等于val的第一个元素位置，返回类型为迭代器</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;upper_bound(起始地址，结束地址，要查找的数值)返回大于val的第一个元素位置，返回迭代器</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;binary_search(起始地址，结束地址，要查找的数值)  返回的是是否存在这么一个数，是一个bool值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; t;</span><br><span class="line">    t.push_back(1);</span><br><span class="line">    t.push_back(2);</span><br><span class="line">    t.push_back(3);</span><br><span class="line">    t.push_back(5);</span><br><span class="line">    t.push_back(5);</span><br><span class="line">    t.push_back(7);</span><br><span class="line">    t.push_back(8);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    int low&#x3D;lower_bound(t.begin(),t.end(),5) - t.begin();</span><br><span class="line">    int upp&#x3D;upper_bound(t.begin(),t.end(),5) - t.begin();</span><br><span class="line">    cout&lt;&lt;low&lt;&lt;endl;&#x2F;&#x2F;3</span><br><span class="line">    cout&lt;&lt;upp&lt;&lt;endl;&#x2F;&#x2F;5</span><br><span class="line"></span><br><span class="line">    return 0；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="递归与分支"><a href="#递归与分支" class="headerlink" title="递归与分支"></a>递归与分支</h1><h2 id="棋盘覆盖问题"><a href="#棋盘覆盖问题" class="headerlink" title="棋盘覆盖问题"></a>棋盘覆盖问题</h2><p>有一个2<sup>k</sup>×2<sup>k</sup>的方格棋盘，恰有一个方格是黑色的，其他是白色的。你的任务是用包含3个方格的L型牌覆盖所有白色方格。黑色方格不能被覆盖，且任意一个白色方格不能同时被两个或更多牌覆盖。问至少要用多少L型牌。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>分治法，每次将棋盘分割成4块，每块都是2<sup>k-1</sup>×2<sup>k-1</sup>。</li>
<li>对于有黑格子的块使用递归解决，没有黑格子的块构造出一个黑格子。</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;（tr,tc)表示棋盘左上角坐标 (dr,dc)表示黑块坐标</span><br><span class="line">void ChessBoard(int tr,int tc,int dr,int dc,int size)</span><br><span class="line">&#123;</span><br><span class="line">    if(size&#x3D;&#x3D;1) return;</span><br><span class="line">    int t&#x3D;tile++,s&#x3D;size&#x2F;2;</span><br><span class="line"></span><br><span class="line">    if(dr&lt;tr+s &amp;&amp; dc&lt;tc+s)&#x2F;&#x2F;&#x2F;在左上角区域内</span><br><span class="line">    	ChessBoard(tr,tc,dr,dc,s);</span><br><span class="line">    else&#x2F;&#x2F;&#x2F;不在左上角区域内</span><br><span class="line">    &#123;</span><br><span class="line">        Board[tr+s-1][tc+s-1]&#x3D;t;&#x2F;&#x2F;&#x2F;用t号(用一个数字表示)L型骨牌覆盖右下角</span><br><span class="line">        ChessBoard(tr,tc,tr+s-1,tc+s-1,s);&#x2F;&#x2F;&#x2F;覆盖剩余方格</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(dr&lt;tr+s &amp;&amp; dc&gt;&#x3D;tc+s)&#x2F;&#x2F;&#x2F;在右上角区域内</span><br><span class="line">        ChessBoard(tr,tc+s,dr,dc,s);</span><br><span class="line">    else&#x2F;&#x2F;&#x2F;不在右上角的区域内</span><br><span class="line">    &#123;</span><br><span class="line">        Board[tr+s-1][tc+s]&#x3D;t;</span><br><span class="line">        ChessBoard(tr,tc+s,tr+s-1,tc+s,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(dr&gt;&#x3D;tr+s &amp;&amp; dc&lt;tc+s)</span><br><span class="line">        ChessBoard(tr+s,tc,dr,dc,s);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Board[tr+s][tc+s-1]&#x3D;t;</span><br><span class="line">        ChessBoard(tr+s,tc,tr+s,tc+s-1,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(dr&gt;&#x3D;tr+s &amp;&amp; dc&gt;&#x3D;tc+s)</span><br><span class="line">        ChessBoard(tr+s,tc+s,dr,dc,s);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Board[tr+s][tc+s]&#x3D;t;</span><br><span class="line">        ChessBoard(tr+s,tc+s,tr+s,tc+s,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环日程表问题"><a href="#循环日程表问题" class="headerlink" title="循环日程表问题"></a>循环日程表问题</h2><p>有n=2<sup>k</sup>个运动员进行网球循环赛，需要设计比赛日程表。每个选手必须与其他n-1个选手各赛一次：每个选手每天只能赛一次，循环赛一共进行n-1天。按此要求设计一张比赛日程表，该表用n行和n-1列，第i行j列为第i个选手第j天遇到的选手。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>观察紫书P230页给出的样例结果，发现结果是对称矩阵，且每一个小块处都是对称的，所以考虑使用分治法。</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; (1 &lt;&lt; 10);</span><br><span class="line">int table[maxn][maxn];</span><br><span class="line">void fill(int x, int y, int n);&#x2F;&#x2F;填充左上角为x,y的，长度为n的方格</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	table[0][0] &#x3D; 1;</span><br><span class="line">	fill(0, 0, n);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">			printf(&quot;%d &quot;, table[i][j]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void fill(int x, int y, int n) &#123;</span><br><span class="line">	if (n &#x3D;&#x3D; 1) return;</span><br><span class="line">	int half &#x3D; n &#x2F; 2;</span><br><span class="line"></span><br><span class="line">	table[x + half][y + half] &#x3D; table[x][y];</span><br><span class="line">	table[x + half][y] &#x3D; table[x][y + half] &#x3D; table[x][y] + half;</span><br><span class="line">	fill(x, y, half);</span><br><span class="line">	fill(x + half, y, half);</span><br><span class="line">	fill(x, y + half, half);</span><br><span class="line">	fill(x + half, y + half, half);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="巨人与鬼"><a href="#巨人与鬼" class="headerlink" title="巨人与鬼"></a>巨人与鬼</h2><p>在平面上有n个巨人和n个鬼，没有三者在同一条直线上。每个巨人需要选择一个不同的鬼，向其发送质子流消灭它，质子流呈直线。质子流不能交叉，要求设计一种巨人和鬼的配对方法。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>使用分治法，以连线两侧内的巨人和鬼的数量相等来分割，然后递归解决。</li>
<li>考虑最左下角的点，假设它是一个巨人，然后将其余的点按照极角从小到大排列依次检查<ol>
<li>如果第一个点是鬼，则匹配完成，剩下的鬼和巨人一样多</li>
<li>如果第一个点是巨人，那么继续检查知道鬼和巨人一样多。</li>
<li>以这个连线为分界，分割问题，递归解决。</li>
</ol>
</li>
</ol>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">int x, y, flag, id;</span><br><span class="line">&#125;;</span><br><span class="line">node p[1000], base;</span><br><span class="line">int ans[1000];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void go(int l, int r);&#x2F;&#x2F;在数组中的左右边界</span><br><span class="line">bool cmp1(node &amp;a, node&amp;b) &#123; return a.y &lt; b.y || a.y &#x3D;&#x3D; b.y&amp;&amp;a.x &lt; b.x; &#125;</span><br><span class="line">bool cmp2(node &amp;a, node &amp;b) &#123;</span><br><span class="line">	return atan2((a.y - base.y), (a.x - base.x)) &lt; atan2((b.y - base.y), (b.x - base.x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int T;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">while (T--)</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d %d %d&quot;, &amp;p[i].flag, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">		p[i].id &#x3D; i + 1;</span><br><span class="line">	&#125;</span><br><span class="line">	go(0, n - 1);</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D;n; i++)</span><br><span class="line">		printf(&quot;%d &quot;, ans[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void go(int l, int r) &#123;</span><br><span class="line">if (l &gt; r)</span><br><span class="line">	return;</span><br><span class="line">sort(p + l, p + r + 1, cmp1);</span><br><span class="line">base &#x3D; p[l];</span><br><span class="line">sort(p + l + 1, p + r + 1, cmp2);</span><br><span class="line">int c1 &#x3D; 0, c2 &#x3D; 0;</span><br><span class="line">int k &#x3D; r;</span><br><span class="line">while (!(p[k].flag !&#x3D; base.flag&amp;&amp;c1 &#x3D;&#x3D; c2))</span><br><span class="line">&#123;</span><br><span class="line">	if (p[k].flag &#x3D;&#x3D; base.flag) c1++;&#x2F;&#x2F;巨人</span><br><span class="line">	else c2++;</span><br><span class="line">	k--;</span><br><span class="line">&#125;</span><br><span class="line">ans[p[k].id] &#x3D; base.id;</span><br><span class="line">ans[base.id] &#x3D; p[k].id;</span><br><span class="line">go(l + 1, k - 1);</span><br><span class="line">go(k + 1, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h1><h2 id="乘船问题"><a href="#乘船问题" class="headerlink" title="乘船问题"></a>乘船问题</h2><p>第一行输入s,表示测试数据的组数；<br>每组数据的第一行包括两个整数w，n，80&lt;=w&lt;=200,1&lt;=n&lt;=300，w为一条独木舟的最大承载量,n为人数；<br>接下来的一组数据为每个人的重量（不能大于船的承载量）；<br>输出<br>每组人数所需要的最少独木舟的条数。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol>
<li>贪心法：给最轻的人i找最重j的匹配，如果仍然超重，那么这个重人只能单独坐船。</li>
<li>证明：使用反证法<ol>
<li>如果目前i单独乘船，那么令j和他同乘不会使总的乘船数量增多。</li>
<li>如果目前i和k同乘，那么根据假设，k应该比j轻，那么k和j交换之后k所在的船仍然不会超重。按照贪心法的过程，交换后j所在船也不会超重。</li>
<li>因此，这样贪心不会丢失最优解</li>
</ol>
</li>
</ol>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 305;</span><br><span class="line">int weight[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int T, c, n;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">while (T--)</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d %d&quot;, &amp;c, &amp;n);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;weight[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int l &#x3D; 0, r &#x3D; n - 1;</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	sort(weight, weight + n);</span><br><span class="line">	while (l &lt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		if (weight[l] + weight[r] &lt;&#x3D; c)</span><br><span class="line">			l++;</span><br><span class="line">		ans++;</span><br><span class="line">		r--;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择不相交区间"><a href="#选择不相交区间" class="headerlink" title="选择不相交区间"></a>选择不相交区间</h2><p>输入n个区间，从中选出尽量多的不相交区间。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>首先，最明显的是如果区间A完全包含于区间B，那么应该选择区间A。所以贪心的策略是一定要选择第一个区间</p>
</li>
<li><p>证明： 首先对区间进行排序，b已经有序，观察a的关系</p>
<ol>
<li>如果a1&gt;a2，那么区间2包含了区间1，则应该选择区间1(依据1中讨论),并且以后的所有选中的区间i都要满足a1&lt;ai</li>
<li>在1的条件下，则a也有序。如果区间2和区间1完全不相交，那么没有影响；否则区间1和区间2只能保留一个。</li>
<li>考虑临近的区间3，区间1和区间3的重叠部分被区间2所包含，根据1中讨论，应该保留区间1。这也就说明不能因为其他区间的影响而不选择区间1，所以贪心策略成立。</li>
</ol>
</li>
<li><p>选择区间1后要把所有和区间1相交的区间排除在外，需要记录上一个被选择的区间编号。</p>
</li>
</ol>
<h3 id="代码-NBUT-今年暑假不AC"><a href="#代码-NBUT-今年暑假不AC" class="headerlink" title="代码 NBUT 今年暑假不AC"></a>代码 NBUT 今年暑假不AC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int a, b;</span><br><span class="line">	bool operator &lt; (const node&amp;x) const &#123; return b &lt; x.b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node g[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;g[i].a, &amp;g[i].b);</span><br><span class="line">			if (g[i].a &gt; g[i].b)</span><br><span class="line">				swap(g[i].a, g[i].b);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sort(g, g + n);</span><br><span class="line"></span><br><span class="line">		int r &#x3D; -1;</span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			if (g[i].a &gt;&#x3D; r) &#123;&#x2F;&#x2F;此处是否取等取决于题目中端点共有算几次</span><br><span class="line">				ans++;</span><br><span class="line">				r &#x3D; g[i].b;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间选点问题"><a href="#区间选点问题" class="headerlink" title="区间选点问题"></a>区间选点问题</h2><p>在数轴上有n个闭区间[a,b]，要求去尽量少的点，使得每个区间内都有至少一个点</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ol>
<li>如果区间1被区间2完全包含，那么在区间1内取的点必定在区间2中。</li>
<li>如果区间1和区间2部分相交，且区间2在后面，那么在区间1的尾部取点最可能在区间2中。</li>
<li>所以贪心策略是取最后一个点</li>
<li>所以首先对b进行排序，每次取最后一个点，如果某个区间的起始点超过了最后一个点的坐标，那么要更新最后一个点的位置。</li>
</ol>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><p>其实和选择不相交区间是一样的,此处留下一个板子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1005;</span><br><span class="line">struct node &#123;</span><br><span class="line">int a, b;</span><br><span class="line">bool operator &lt; (const node &amp;x)const &#123; return b &lt; x.b || b &#x3D;&#x3D; x.b&amp;&amp;a &lt; x.a; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node p[maxn];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;n)&#x3D;&#x3D;1)</span><br><span class="line">&#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d %d&quot;, &amp;p[i].a, &amp;p[i].b);</span><br><span class="line">		if (p[i].a &gt; p[i].b)</span><br><span class="line">			swap(p[i].a, p[i].b);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(p, p + n);</span><br><span class="line">	int r &#x3D; -1;&#x2F;&#x2F;此处也可以设置为p[0].b，同时ans&#x3D;1</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (p[i].a &gt; r) &#123;</span><br><span class="line">			ans++;</span><br><span class="line">			r &#x3D; p[i].b;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;ans: %d\n&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间覆盖问题"><a href="#区间覆盖问题" class="headerlink" title="区间覆盖问题"></a>区间覆盖问题</h2><p>从n个区间中选择尽量少的区间覆盖目标区间[s,t]。代码对应覆盖[0,t]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1005;</span><br><span class="line">int n;</span><br><span class="line">struct node &#123;</span><br><span class="line">int a, b;</span><br><span class="line">bool operator &lt; (const node &amp;x)const &#123; return a &lt; x.a || a &#x3D;&#x3D; x.a &amp;&amp; b&gt;x.b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node p[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int T;</span><br><span class="line">int s, t;</span><br><span class="line">s &#x3D; 0;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">while (T--)</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">	n &#x3D; 0;</span><br><span class="line">	while (scanf(&quot;%d %d&quot;, &amp;p[n].a, &amp;p[n].b) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">		if (p[n].a &#x3D;&#x3D; 0 &amp;&amp; p[n].b &#x3D;&#x3D; 0)</span><br><span class="line">			break;</span><br><span class="line">		if (p[n].a &gt; p[n].b)</span><br><span class="line">			swap(p[n].a, p[n].b);</span><br><span class="line">		if (p[n].b &lt; t || p[n].b &lt; s) continue;</span><br><span class="line">		p[n].a &#x3D; max(p[n].a, s);</span><br><span class="line">		p[n].b &#x3D; min(p[n].b, t);</span><br><span class="line">		if (p[n].a &lt; p[n].b)</span><br><span class="line">			n++;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(p, p + n);</span><br><span class="line">	if (!n||p[0].a !&#x3D; s)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;ans: 0\n&quot;);</span><br><span class="line">		continue;</span><br><span class="line">	&#125;</span><br><span class="line">	int r &#x3D; s;</span><br><span class="line">	int ans &#x3D;0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (p[i].b &gt; r) &#123;</span><br><span class="line">			r &#x3D; p[i].b;</span><br><span class="line">			ans++;</span><br><span class="line">			printf(&quot;%d %d\n&quot;, p[i].a, p[i].b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;ans: %d\n\n&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Huffman-编码"><a href="#Huffman-编码" class="headerlink" title="Huffman 编码"></a>Huffman 编码</h1><h2 id="Huffman-树"><a href="#Huffman-树" class="headerlink" title="Huffman 树"></a>Huffman 树</h2><ol>
<li>n个叶子的二叉树一定对应一个前缀码。如果编码a是编码b的前缀，则a所对应的结点一定为b所对应节点的先祖，而两个叶子不会有先祖后代的关系。</li>
<li>最优前缀码一定可以写成二叉树</li>
</ol>
<h2 id="Huffman-算法-O-nlogn"><a href="#Huffman-算法-O-nlogn" class="headerlink" title="Huffman 算法 O(nlogn)"></a>Huffman 算法 O(nlogn)</h2><p>把每个字符看作一个单结点子树放在一个树集合中，每颗子树的权值等于相应字符的频率。每次取权值最小的两颗紫书合并成一颗新树，并重新放到集合中。新树的权值等于两颗子树权值之和。</p>
<h2 id="相关问题-UVA10954"><a href="#相关问题-UVA10954" class="headerlink" title="相关问题 UVA10954"></a>相关问题 UVA10954</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, x;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">			pq.push(x);</span><br><span class="line">		&#125;</span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">			int a &#x3D; pq.top(); pq.pop();</span><br><span class="line">			int b &#x3D; pq.top(); pq.pop();</span><br><span class="line">			ans +&#x3D; a + b;</span><br><span class="line">			pq.push(a + b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    
    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>
      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/hide/" rel="tag"># hide</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/24/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C%E9%97%AE%E9%A2%98/" rel="prev" title="最大连续和问题">
      <i class="fa fa-chevron-left"></i> 最大连续和问题
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/29/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%B0%8F%E9%97%AE%E9%A2%98/" rel="next" title="滑动窗口最小问题">
      滑动窗口最小问题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#归并排序-O-nlogn"><span class="nav-number">1.</span> <span class="nav-text">归并排序 O(nlogn)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本步骤"><span class="nav-number">1.1.</span> <span class="nav-text">基本步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码"><span class="nav-number">1.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#快速排序-O-nlogn"><span class="nav-number">2.</span> <span class="nav-text">快速排序 O(nlogn)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二分查找-适用于有序序列"><span class="nav-number">3.</span> <span class="nav-text">二分查找 适用于有序序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代-常用"><span class="nav-number">3.1.</span> <span class="nav-text">迭代(常用)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归"><span class="nav-number">3.2.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#考虑新问题："><span class="nav-number">3.3.</span> <span class="nav-text">考虑新问题：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-中"><span class="nav-number">3.4.</span> <span class="nav-text">C++中</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#递归与分支"><span class="nav-number">4.</span> <span class="nav-text">递归与分支</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#棋盘覆盖问题"><span class="nav-number">4.1.</span> <span class="nav-text">棋盘覆盖问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路"><span class="nav-number">4.1.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码-1"><span class="nav-number">4.1.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环日程表问题"><span class="nav-number">4.2.</span> <span class="nav-text">循环日程表问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路-1"><span class="nav-number">4.2.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码-2"><span class="nav-number">4.2.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#巨人与鬼"><span class="nav-number">4.3.</span> <span class="nav-text">巨人与鬼</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路-2"><span class="nav-number">4.3.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码-3"><span class="nav-number">4.3.2.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#贪心法"><span class="nav-number">5.</span> <span class="nav-text">贪心法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#乘船问题"><span class="nav-number">5.1.</span> <span class="nav-text">乘船问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路-3"><span class="nav-number">5.1.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码-4"><span class="nav-number">5.1.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择不相交区间"><span class="nav-number">5.2.</span> <span class="nav-text">选择不相交区间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路-4"><span class="nav-number">5.2.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码-NBUT-今年暑假不AC"><span class="nav-number">5.2.2.</span> <span class="nav-text">代码 NBUT 今年暑假不AC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#区间选点问题"><span class="nav-number">5.3.</span> <span class="nav-text">区间选点问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路-5"><span class="nav-number">5.3.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码-5"><span class="nav-number">5.3.2.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#区间覆盖问题"><span class="nav-number">5.4.</span> <span class="nav-text">区间覆盖问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Huffman-编码"><span class="nav-number">6.</span> <span class="nav-text">Huffman 编码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Huffman-树"><span class="nav-number">6.1.</span> <span class="nav-text">Huffman 树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Huffman-算法-O-nlogn"><span class="nav-number">6.2.</span> <span class="nav-text">Huffman 算法 O(nlogn)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#相关问题-UVA10954"><span class="nav-number">6.3.</span> <span class="nav-text">相关问题 UVA10954</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cuienbo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">159</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cuienbo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.0
  </div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
  
</body>
</html>
