<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://github.com/Cccceb/Cccceb.github.io').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="第一章 Java程序设计概述第二章 Java程序设计环境体系结构中立 JAVA编译器生成与特定的计算机体系结构无关的字节码指令来实现体系结构中立。 字节码可以在任何机器上解释执行，而且可以动态翻译成本地机器代码，即即时编译  可移植性 JAVA中数据类型具有固定的大小，如int永远32位。字符串用标准Unicode存储。 除了与用户界面有关的库，所有其他的JAVA库都能很好的支持平台的独立性。">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA核心技术卷一">
<meta property="og:url" content="https://github.com/Cccceb/Cccceb.github.io/2020/01/22/JAVA%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E4%B8%80/index.html">
<meta property="og:site_name" content="Ceb">
<meta property="og:description" content="第一章 Java程序设计概述第二章 Java程序设计环境体系结构中立 JAVA编译器生成与特定的计算机体系结构无关的字节码指令来实现体系结构中立。 字节码可以在任何机器上解释执行，而且可以动态翻译成本地机器代码，即即时编译  可移植性 JAVA中数据类型具有固定的大小，如int永远32位。字符串用标准Unicode存储。 除了与用户界面有关的库，所有其他的JAVA库都能很好的支持平台的独立性。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/1.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/2.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/3.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/4.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/5.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/6.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/7.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/9.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/8.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/10.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/11.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/12.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/13.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/14.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/15.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/16.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/17.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/18.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/19.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/20.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/21.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/22.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/23.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/24.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/25.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/26.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/27.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/28.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/29.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/30.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/31.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/32.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/33.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/34.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/35.png">
<meta property="og:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/36.png">
<meta property="og:image" content="https://github.com/AVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/37.png">
<meta property="article:published_time" content="2020-01-22T10:49:39.622Z">
<meta property="article:modified_time" content="2020-01-31T05:25:22.607Z">
<meta property="article:author" content="Cuienbo">
<meta property="article:tag" content="hide">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/1.png">

<link rel="canonical" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/22/JAVA%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E4%B8%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>JAVA核心技术卷一 | Ceb</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
    <a href="https://github.com/you"><img style="position:absolute;" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_left_gray_6d6d6d.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>  
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ceb</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/Cccceb/Cccceb.github.io/2020/01/22/JAVA%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Cuienbo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ceb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JAVA核心技术卷一
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-22 18:49:39" itemprop="dateCreated datePublished" datetime="2020-01-22T18:49:39+08:00">2020-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-01-31 13:25:22" itemprop="dateModified" datetime="2020-01-31T13:25:22+08:00">2020-01-31</time>
              </span>

          
          <div>
            
                
            
          </div>
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第一章-Java程序设计概述"><a href="#第一章-Java程序设计概述" class="headerlink" title="第一章 Java程序设计概述"></a>第一章 Java程序设计概述</h1><h1 id="第二章-Java程序设计环境"><a href="#第二章-Java程序设计环境" class="headerlink" title="第二章 Java程序设计环境"></a>第二章 Java程序设计环境</h1><h2 id="体系结构中立"><a href="#体系结构中立" class="headerlink" title="体系结构中立"></a>体系结构中立</h2><ol>
<li>JAVA编译器生成与特定的计算机体系结构无关的字节码指令来实现体系结构中立。</li>
<li>字节码可以在任何机器上解释执行，而且可以动态翻译成本地机器代码，即<strong>即时编译</strong></li>
</ol>
<h2 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h2><ol>
<li>JAVA中数据类型具有固定的大小，如int永远32位。字符串用标准Unicode存储。</li>
<li>除了与用户界面有关的库，所有其他的JAVA库都能很好的支持平台的独立性。</li>
</ol>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h2 id="动态性"><a href="#动态性" class="headerlink" title="动态性"></a>动态性</h2><ol>
<li>JAVA的库中可以自由的添加新方法和实例变量，而对客户端没有任何影响。</li>
</ol>
<h2 id="applet和Internet"><a href="#applet和Internet" class="headerlink" title="applet和Internet"></a>applet和Internet</h2><ol>
<li>在网页中运行的Java称为applet。要使用applet，需要启用Java 的 Web 浏览器执行字节码，而不<br>需要安装任何软件。由于虚拟机的安全性，也不必担心恶意软件攻击。可以实现动态网页。<h2 id="常见术语解释"><a href="#常见术语解释" class="headerlink" title="常见术语解释"></a>常见术语解释</h2></li>
<li>JDK：编写java程序的程序员使用的软件。</li>
<li>JRE：运行Java程序的用户使用的软件。包含虚拟机而不包含编译器。</li>
<li>SE： 用于桌面或简单服务器应用的Java 平台</li>
<li>EE ：用于复杂服务器应用的 Java 平台</li>
<li>ME：用于手机和 其他小搜设备的 Java 平台。</li>
</ol>
<h2 id="使用命令工具"><a href="#使用命令工具" class="headerlink" title="使用命令工具"></a>使用命令工具</h2><ol>
<li>javac xxx.java//javac是一个java编译器，将java文件编译成class文件</li>
<li>java xxx//java程序启动java虚拟机，虚拟机执行class中的字节码</li>
</ol>
<h1 id="第三章-Java的基本程序设计结构"><a href="#第三章-Java的基本程序设计结构" class="headerlink" title="第三章 Java的基本程序设计结构"></a>第三章 Java的基本程序设计结构</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ol>
<li>可作为一个加载程序逻辑的容器，程序逻辑定义了应用程序的行为。</li>
<li>类名必须是大写字母开头的名词。如果有多个单词，那么每个单词的第一个字母都要大写。源代码的文件名必须与公共类的名字相同。</li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li><p>8种基本类型：4种整型，2种浮点型，1种字符类型，一种布尔型。</p>
</li>
<li><p>整型：</p>
<ol start="4">
<li>BYTE 1B</li>
<li>short 2B</li>
<li>int 4B</li>
<li>long 8B</li>
</ol>
</li>
<li><p>表示</p>
<ol>
<li>长整型有后缀L</li>
<li>十六进制加前缀0x</li>
<li>八进制加前缀0</li>
<li>二进制加前缀0b</li>
<li>JAVA 7开始，允许数字中加下划线。</li>
</ol>
</li>
<li><p>浮点型</p>
<ol>
<li>float 4B 有效位6-7位</li>
<li>double 8B 有效位约15位</li>
</ol>
</li>
<li><p>表示</p>
<ol>
<li>单精度加后缀F</li>
<li>双精度加后缀D</li>
</ol>
</li>
<li><p>特殊常量</p>
<ol>
<li>Double.POSITIVE_INFINITY</li>
<li>Double.NEGATIVE_INFINITY</li>
<li>Double.NaN</li>
<li>注意：所有的非数都认为是不相等的。</li>
<li><strong>注意</strong>：浮点数值不适用于无法受舍入误差的金融计算。如2.0-1.1 = 0.899999999，这是因为二进制系统无法精确的表示1/10.如果不允许有任何舍入误差，则应该使用BigDecimal类</li>
</ol>
</li>
<li><p>char类型</p>
<ol>
<li><p>转义序列会在解析代码之前得到处理</p>
<img src="/JAVA核心卷1_img/1.png">
</li>
<li><p>JAVA解决Unicode-16不够用的问题–&gt;码点：是指与一个编码表中的某个字符对应的代码值。</p>
</li>
</ol>
</li>
<li><p>boolean </p>
<ol>
<li>整型与布尔型间不可转换</li>
</ol>
</li>
<li><p>变量名：以字母开头并由字母或数字构成的序列。 </p>
</li>
<li><p>常量：使用final声明。如果经常希望某个常量可以在一个类中的多个方法中使用，通常使用static final 声明。</p>
</li>
</ol>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ol>
<li><p>对于浮点数运算，为了实现可移植性，JAVA虚拟机最初规范所有中间的计算结果必须进行截断。但是截断会影响速度，所以后来允许对中间的计算结果扩展精度。对于使用strictfp标记的方法必须使用严格的浮点数运算来生成可再生的结果。</p>
</li>
<li><p>整型提升</p>
<img src="/JAVA核心卷1_img/2.png"></li>
<li><p>强制转型</p>
<ol>
<li>浮点型变整型：通过截断小数部分；若要舍入，则使用Math.round()方法</li>
<li>要注意是否超出目标类型的表示范围</li>
<li>布尔型转整型 b?1:0</li>
</ol>
</li>
<li><p>移位操作符：移位运算符的右操作数要完成模 32 的运算（除非左操作数是 long 类型， 在这种情况下需要对右操作數模 64 )。例如， 1 «35 的值等同于 1 «3 或 8。</p>
</li>
<li><p>枚举类型 </p>
 <img src="/JAVA核心卷1_img/3.png">

</li>
</ol>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol>
<li><p>substring(int a,int b) 第二个参数是不想复制的第一个位置，截得的字串长度为b-a。</p>
</li>
<li><p>join方法可以将多个字符串放在一起，用一个定界符隔开。String all = String.join(“ / “, “S”, “M”, “L”, “XL”); // all is the string “S / H / L / XL”</p>
</li>
<li><p>String为不可变字符串，优点是编译器可以让字符串共享(只有字符串常量是共享的)。可以想象将各种字符串放在公共的存储池中，字符串变量指向存储池中相应的位置，如果复制一个字符串变量，原始字符串与复制的字符串共享相同的字符。</p>
</li>
<li><p>JAVA的String类完全不同于字符数组，大致类似于char*指针</p>
</li>
<li><p>equal() <strong>用于判断相等</strong>。</p>
</li>
<li><p>null 不等同于空串</p>
<ol>
<li>空串是长度为0的字符串。</li>
<li>null指的是没有任何对象与该变量关联。如果在一个null值上调用方法，会抛出异常</li>
</ol>
</li>
<li><p>码点与代码单元</p>
<ol>
<li>码点表示一个字符。通过codepoints函数计算。</li>
<li>代码单元表示2个字节。通过length计算</li>
<li>如果想要遍历一个字符串，并且依次查看每一个码点，可以使用intp[] codePoints = str.codePoints().toArray();反之，如果想要将一个码点数组转换为一个字符串，可以使用String str = new String(codePoints,0,codePoints.length);<h3 id="String-API"><a href="#String-API" class="headerlink" title="String API"></a>String API</h3></li>
</ol>
</li>
</ol>
<img src="/JAVA核心卷1_img/4.png">

<img src="/JAVA核心卷1_img/5.png">

<img src="/JAVA核心卷1_img/6.png">

<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><ol>
<li>用于将许多字符串进行连接的情况</li>
<li>可以通过调用append方法修改原串</li>
<li>可以通过toString方法转换为字符串</li>
</ol>
<img src="/JAVA核心卷1_img/7.png">

<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><ol>
<li><p>使用Scanner类对象，定义在java.util包中。由于输入是可见的所以不适用于读取密码</p>
 <img src="/JAVA核心卷1_img/9.png">    
</li>
<li><p>Console类可以读取密码.</p>
 <img src="/JAVA核心卷1_img/8.png">

<p> 使用Console对象每次只能读取一行</p>
 <img src="/JAVA核心卷1_img/10.png">


</li>
</ol>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><ol>
<li><p>沿用了printf方法进行格式化输出</p>
<ol>
<li><p>转义符</p>
<img src="/JAVA核心卷1_img/11.png">

<p>注意可以使用s转换符格式化任何字符串。如果实现了Formattable接口，调用formatTo方法    ；否则，调用toString方法</p>
</li>
<li><p>标志</p>
<img src="/JAVA核心卷1_img/12.png">
</li>
</ol>
</li>
<li><p>文件输入与输出</p>
<ol>
<li>读入 Scanner in = new Scanner(Paths.get(“c:\mydirectory\myfile.txt ”), “UTF-8”);</li>
<li>写出 PrintWriter out = new PrintlulriterC’myfile.txt”, “UTF-8”);</li>
<li>注意 如果使用相对路径，JAVA会根据虚拟机启动路径的相对路径。可以使用System.getProperty(“user.dir”);得到</li>
<li>注意 如果路径不存在则会抛出异常，throw IOException</li>
</ol>
</li>
</ol>
<h2 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h2><ol>
<li><p>switch语句</p>
<ol>
<li>case后的类型可以是char,byte,int，枚举常量，string</li>
</ol>
</li>
<li><p>带标签的break：在外层循环开始处加上标签，比如read_data，然后break read_data</p>
</li>
</ol>
<h2 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h2><p>在java.math包中，包含Biginteger,BigDecimal两个类。</p>
<ol>
<li>使用静态方法valueof将普通的数值转换成大数值。</li>
<li>使用add，subtract,multiply，divide进行加减乘除。</li>
<li>取模mod(),比较compareTo()</li>
</ol>
<img src="/JAVA核心卷1_img/13.png">

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol>
<li>数组长度不要求是常量，初始所有元素为0；boolean型的初始为false；对象数组初始化为null，表示还没存放任何对象</li>
</ol>
<h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><ol>
<li>语法for (variable : collection) statement。其中collection这一集合表达式必须是一个数组或者是一个实现了Iterator接口的类对象</li>
</ol>
<h3 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h3><ol>
<li>使用Arrays.copyOf(arrayname,arraylength)方法。常用来增加数组的大小。</li>
</ol>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><ol>
<li>使用Array.sort()方法，实现采用快排。</li>
</ol>
<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><img src="/JAVA核心卷1_img/14.png">

<img src="/JAVA核心卷1_img/15.png">


<ol>
<li>打印数组Arrays.toString();Arrays.deepToString();</li>
</ol>
<h3 id="不规则数组"><a href="#不规则数组" class="headerlink" title="不规则数组"></a>不规则数组</h3><ol>
<li>JAVA中的高维数组其实是数组的数组</li>
<li>创建不规则数组：假设建一个下三角数组</li>
</ol>
<p><code>i n t[][] odds = new int[NMAX + 1] [] ;</code></p>
<p><code>for (int n = 0; n &lt;= NMAX ; n++)</code></p>
<p><code>odds [n] = new int[n + 1];</code></p>
<h1 id="第四章-对象和类"><a href="#第四章-对象和类" class="headerlink" title="第四章 对象和类"></a>第四章 对象和类</h1><h2 id="面向对象程序设计概述"><a href="#面向对象程序设计概述" class="headerlink" title="面向对象程序设计概述"></a>面向对象程序设计概述</h2><ol>
<li><p>封装（ encapsulation , 有时称为数据隐藏） 是与对象有关的一个重要概念。从形式上看，<br>封装不过是将数据和行为组合在一个包中， 并对对象的使用者隐藏了数据的实现方式。对象<br>中的数据称为实例域（ instance field ), 操纵数据的过程称为方法（ method 。) 对于每个特定的<br>类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前状态（ state )。<br>无论何时，只要向对象发送一个消息，它的状态就有可能发生改变。</p>
</li>
<li><p>对象的三个主要特性</p>
<ol>
<li>对象的行为：操作对象的方法</li>
<li>对象的状态：操作之后对象的响应</li>
<li>对象标识：如何区分具有相同行为和状态的不同对象</li>
</ol>
</li>
<li><p>类之间的关系：可以用UML绘制类图</p>
<ol>
<li><p>依赖</p>
</li>
<li><p>聚合</p>
</li>
<li><p>继承</p>
<img src="/JAVA核心卷1_img/16.png">

</li>
</ol>
</li>
</ol>
<h2 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h2><ol>
<li><p><strong>所有的Java对象都存储在堆中</strong>，当一个对象包含另一个对象变量时，这个变量依然包含指向另一个堆对象的指针。</p>
</li>
<li><p>时间类</p>
<ol>
<li><p>Date类</p>
</li>
<li><p>LocalDate类：用LocalDate.now()来创建对象；或者指定时间的对象，用LocalDate.of(1999,8,3);</p>
</li>
<li><p>可以使用getYear,getMonthValue,getDayOfMonth获取年月日。</p>
</li>
<li><p>使用plusDays(int x)得到距离当前对象x天的新日期</p>
<img src="/JAVA核心卷1_img/17.png">

<img src="/JAVA核心卷1_img/18.png">

</li>
</ol>
</li>
</ol>
<h2 id="用户自定义类"><a href="#用户自定义类" class="headerlink" title="用户自定义类"></a>用户自定义类</h2><ol>
<li><p>在一个源文件中，只能有一个公有类，但可以有若干非公有类。源文件名必须与public类的名字相匹配。编译时，公有类和非公有类都生成class文件。</p>
</li>
<li><p>隐式参数：调用方法的对象，可以用this指代;显式参数：方法的参数列表中的参数。</p>
</li>
<li><p><strong>警告</strong>：注意不要编写返回引用可变对象的访问器方法，否则会破坏封装性。</p>
 <img src="/JAVA核心卷1_img/19.png">

<p> 如果一定要返回一个可变对象的引用，可以返回对他的克隆。对象克隆是指存放在另一个位置上的对象副本。</p>
</li>
<li><p>如果类中包含final域，那么在构造器中必须设置该项的值。</p>
<ol>
<li><strong>注意</strong> 如果用final修饰引用，那么仅仅表示该引用不能指向别的对象，但是对象本身是可以更改的。</li>
</ol>
</li>
</ol>
<h3 id="静态域和静态方法"><a href="#静态域和静态方法" class="headerlink" title="静态域和静态方法"></a>静态域和静态方法</h3><ol>
<li>静态域，每个类中只有一个这样的域。即使没有对象，静态域也存在。</li>
<li>静态变量：如out，不能将其他打印流赋给他。</li>
<li>静态方法：不能向对象实时操作的方法。因此，静态方法不能操作对象，但是静态方法可以访问类中的静态域，因为他不属于对象而属于类。</li>
</ol>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>有些时候使用构造器不能实现目的，所以引入工厂函数。例如对于NumberFormat类</p>
<ol>
<li>无法命名构造器。构造器的名字必须与类名相同。但是， 这里希望将得到的货币实例<br>和百分比实例采用不用的名字。</li>
<li>当使用构造器时，无法改变所构造的对象类型。而 Factory 方法将返回一个 DecimalFormat<br>类对象，这是NumberFormat 的子类</li>
</ol>
<h3 id="main-方法"><a href="#main-方法" class="headerlink" title="main 方法"></a>main 方法</h3><ol>
<li><strong>每个类</strong>都可以有一个main方法</li>
</ol>
<h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><ol>
<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）</li>
<li>一个方法可以改变一个对象参数的状态。 </li>
<li>一个方法不能让对象参数引用一个新的对象。</li>
</ol>
<h2 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h2><ol>
<li>如果没有显式的写出一个无参构造器，那么系统会默认将实例域中的数值型数据设置为0，布尔型设置为false，对象变量置为null</li>
</ol>
<h3 id="显式域初始化"><a href="#显式域初始化" class="headerlink" title="显式域初始化"></a>显式域初始化</h3><ol>
<li><p>可以在类定义时，直接将一个值赋给任何域</p>
</li>
<li><p>构造器内部可以调用另一个构造器，使用this</p>
 <img src="/JAVA核心卷1_img/20.png">

</li>
</ol>
<h3 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h3><ol>
<li>在一个类声明中，可以包含多个代码块，只要构造类的对象，这些块就会被执行。首先运行初始化块，然后才运行构造函数的主体部分。</li>
</ol>
<h3 id="构造器具体处理步骤"><a href="#构造器具体处理步骤" class="headerlink" title="构造器具体处理步骤"></a>构造器具体处理步骤</h3><ol>
<li>所有数据域被初始化为默认值（0、false 或 null。)</li>
<li>按照在类声明中出现的次序， 依次执行所有域初始化语句和初始化块。</li>
<li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体</li>
<li>执行这个构造器的主体.</li>
</ol>
<h3 id="静态初始化块"><a href="#静态初始化块" class="headerlink" title="静态初始化块"></a>静态初始化块</h3><ol>
<li>如果对类的静态域进行初始化的代码比较复杂，那么可以使用静态的初始化块。</li>
<li>所有的静态初始化语句以及静态初始<br>化块都将依照类定义的顺序执行。</li>
</ol>
<h3 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h3><ol>
<li>用于人工回收除内存外的其他资源，比如文件或者使用了系统资源的另一个对象的句柄。</li>
<li>实际中不要依赖finalize方法回收短缺资源，因为不能确定该方法何时被调用。</li>
</ol>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ol>
<li>用于组织类，确保类名的唯一性。</li>
<li>JAVA包应该具有一定的层次结构。所有的标准Java包都处于java和javax包层次中</li>
<li>一个类可以使用所属包中的所有类，以及其他包中的公有类；</li>
</ol>
<h3 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h3><ol>
<li>可以使用import语句导入类，静态方法和静态域。</li>
<li>如import static java.lang.System.*;后可直接调用out.println();</li>
<li>如import import static java.lang.Math.*;后可直接sqrt();</li>
</ol>
<h3 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h3><ol>
<li><p>如果没有public或者private修饰，那么这个部分可以被同一个包中所有方法访问。一般来说变量都要指明作用域。</p>
</li>
<li><p>可以通过包密封机制来解决各种包混杂在一起的问题</p>
<h2 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h2></li>
<li><p>类文件也可以储存在JAR文件中。在一个JAR文件中，可以包含多个压缩形式的类文件和子目录。</p>
</li>
<li><p>设置类路径：java -classpath 绝对路径</p>
</li>
</ol>
<h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><ol>
<li>使用/<em>*开头，以</em>/结束。</li>
<li>使用Javadoc自动抽取注释形成文档。</li>
</ol>
<h3 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h3><p>在import语句之后，在类定义之前。</p>
<h3 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h3><ol>
<li>@parma变量描述</li>
<li>@return描述</li>
<li>@throws描述</li>
</ol>
<h3 id="域注释"><a href="#域注释" class="headerlink" title="域注释"></a>域注释</h3><p>只需要对公有域建立文档(通常是静态变量)</p>
<h3 id="通用注释"><a href="#通用注释" class="headerlink" title="通用注释"></a>通用注释</h3><ol>
<li>@author 姓名</li>
<li>@version 文本</li>
<li>@since 文本，对引入特性的版本的描述</li>
<li>@deprecated 文本，不再使用的。</li>
<li>@see 引用，后面跟一个类，方法，或者变量，javadoc后会形成一个超链接。<strong>注意</strong>一定要使用# 分割类名域方法名，或类名与变量名。@see后也可以使用html语法指定任何一个URL</li>
</ol>
<h2 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h2><ol>
<li><p>一定保证数据私有</p>
</li>
<li><p>一定要对数据初始化</p>
</li>
<li><p>不要在类中使用过多的基本类型。</p>
 <img src="/JAVA核心卷1_img/21.png"></li>
<li><p>不是所有的域都需要独立的域访问器和域更改器</p>
</li>
<li><p>将职责过多的类进行分解</p>
</li>
<li><p>类名和方法名能够体现他们的职责</p>
</li>
<li><p>优先使用不可变的类</p>
</li>
</ol>
<h1 id="第五章-继承"><a href="#第五章-继承" class="headerlink" title="第五章 继承"></a>第五章 继承</h1><h2 id="类、超类和子类"><a href="#类、超类和子类" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h2><h3 id="定义子类"><a href="#定义子类" class="headerlink" title="定义子类"></a>定义子类</h3><ol>
<li>extends关键字标识</li>
<li>Java中所有继承都是公有继承</li>
</ol>
<h3 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h3><ol>
<li>注意父类的私有域子类不能直接访问。如果一定要访问，则必须借助于公有接口。</li>
<li>使用super调用父类的同名方法</li>
<li>super &amp; this。super不是一个对象的引用，不能将super赋给另一个对象变量，他只是一个指示编译器调用超类方法的特殊关键字</li>
<li>方法的名字和参数列表称为方法的签名。如果在子类中定义了一个与超类签名相同的方法，那么子类中的这一个方法就覆盖了超类中的这个相同签名的方法。</li>
<li>返回值类型不是签名的一部分，因此，在覆盖方法时，要保证返回类型的兼容性。</li>
</ol>
<h3 id="子类构造器"><a href="#子类构造器" class="headerlink" title="子类构造器"></a>子类构造器</h3><ol>
<li>由于子类不能访问符类的私有域，所以子类构造器需要先通过super调用父类构造器。<strong>如果没有显式调用，则自动调用父类无参构造器</strong> （如果没有，则会报错）</li>
<li><strong>多态</strong> 一个对象变量可以指示多种实际类型的现象称为多态。</li>
<li><strong>动态绑定</strong> 在运行时能够自动的选择调用哪个方法的现象称为动态绑定。调用的方法依赖于隐式参数的实际类型。<ol>
<li>动态绑定下，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。如假设x是D类型，D是C的子类。如果D类定义了f方法，则直接调用，否则在D的父类中找f方法。</li>
<li>实现动态绑定时，为了加快速度，会维护一张方法表。</li>
<li>动态绑定有一个非常重要的特性： 无需对现存的代码进行修改，就可以对程序进行扩展。假设增加一个新类 Executive, 并且变量 e 有可能引用这个类的对象， 我们不需要对包含调用<br>e.getSalary() 的代码进行重新编译。如果 e 恰好引用一个 Executive 类的对象，就会自动地调<br>用 Executive.getSalaryO 方法</li>
</ol>
</li>
<li><strong>静态绑定</strong> 如果是private方法，static方法，final方法或者构造器，那么编译器可以准确的知道应该调用哪个方法，这种调用方式称为静态绑定。</li>
<li>父类引用也可以指向子类对象。调用实际指向对象的函数</li>
</ol>
<h3 id="阻止继承：final类和方法"><a href="#阻止继承：final类和方法" class="headerlink" title="阻止继承：final类和方法"></a>阻止继承：final类和方法</h3><ol>
<li>final类不可被继承</li>
<li>final方法不可被覆盖。final类中方法都是final方法</li>
<li>final域不可改变值final类中的域<strong>不是</strong>final域</li>
</ol>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ol>
<li>目的：暂时忽视对象的实际类型之后，使用对象的全部功能。</li>
<li>将一个超类的引用赋给一个子类变量时，必须进行类型转换。</li>
<li><strong>注意</strong> 好的习惯是在进行类型转换之前，先查看一下是否能够成功的转换。使用instanceof操作就可以实现。(如果x.instanceof，而x是null，则会返回false)<ol>
<li>否则可能抛出ClassCastException异常</li>
</ol>
</li>
</ol>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ol>
<li>使用abstract 关键字</li>
<li>包含一个或多个抽象方法的类本身必须被声明为抽象的。</li>
<li>抽象类不能被实例化，但是可以定义抽象类的变量来引用非抽象类的对象。</li>
<li>扩展抽象类的两种方法<ol>
<li>一种是在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类；</li>
<li>另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。</li>
</ol>
</li>
</ol>
<h3 id="受保护的访问"><a href="#受保护的访问" class="headerlink" title="受保护的访问"></a>受保护的访问</h3><ol>
<li>任何声明为private的内容对其他的类都是不可见的。</li>
<li><strong>protected</strong> 修饰只允许子类访问的内容</li>
</ol>
<h2 id="Object-所有类的超类"><a href="#Object-所有类的超类" class="headerlink" title="Object 所有类的超类"></a>Object 所有类的超类</h2><h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><ol>
<li><p>特殊情况</p>
<ol>
<li>如果一个为null，则返回false</li>
<li>如果都为null，则返回true</li>
</ol>
</li>
<li><p>子类中定义equals方法时，首先调用超类的equals，如果检测失败，则对象不可能相等</p>
</li>
<li><p>重写equal方法的正确姿势</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public boolean equals(Object otherObject) &#123;</span><br><span class="line">	if(this&#x3D;&#x3D;otherObject) return true;</span><br><span class="line">	if (getClass() !&#x3D; otherObject.getClass()) return false;</span><br><span class="line">	if (!(otherObject instanceof ClassName)) return false;</span><br><span class="line">	ClassName other &#x3D; (ClassName) otherObject</span><br><span class="line">			</span><br><span class="line">	return fieldl &#x3D;&#x3D; other.field</span><br><span class="line">			&amp;&amp; Objects.equa1s(fie1d2, other.field2)</span><br><span class="line">			&amp;&amp; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode 方法"></a>hashCode 方法</h3><p><img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/22.png" alt=""></p>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString 方法"></a>toString 方法</h3><ol>
<li>通用的写法<br><img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/23.png" alt=""></li>
<li>子类的写法<br><img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/24.png" alt=""></li>
<li>只要对象与一个字符串通过操作符“+”连接起来，Java编译就会自动的调用toString方法</li>
<li><strong>注意</strong> 数组可以使用Arrays.toString(数组名)来打印一维数组；使用Arrays.deepToString方法打印多维数组。</li>
</ol>
<h3 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h3><ol>
<li><p>Employee类<br><img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/25.png" alt=""></p>
</li>
<li><p>Manager类<br><img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/26.png" alt=""></p>
</li>
<li><p>相关函数<br><img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/27.png" alt=""></p>
</li>
</ol>
<h2 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ol>
<li><p>可以动态的改变数组的大小，如果在填充之前就可以确定数组的大小</p>
<ol>
<li>可以使用ensureCapacity方法。</li>
<li><code>ArrayList&lt;Employee&gt; staff = new ArrayListo(lOO);</code></li>
</ol>
</li>
<li><p>声明和构造</p>
<p> <code>ArrayList&lt;Employee&gt; staff = new ArrayListoQ；</code></p>
</li>
<li><p>添加元素 add</p>
<p> <code>staff.add(new Employee(&quot;Harry Hacker&quot;,···));</code></p>
</li>
<li><p><strong>注意</strong> 预先确定容量的数组列表与数组也不同。</p>
<ol>
<li>对于数组，如果分配了100个空间，数组就有100个空位置可以使用。</li>
<li>对于数组列表，容量为100的数组列表只是拥有保存100个元素的潜力。但是在初始化后，数组列表中不包含任何元素。</li>
</ol>
</li>
<li><p>size方法，返回实际元素数目.<strong>一旦数组列表的不再变化，就可以调用trimToSize</strong>将存储区域大小调整为当前元素数量所需要的存储空间数目，之后垃圾回收机制自动回收多余空间。</p>
</li>
</ol>
<p><img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/28.png" alt=""></p>
<h3 id="访问数组列表元素"><a href="#访问数组列表元素" class="headerlink" title="访问数组列表元素"></a>访问数组列表元素</h3><ol>
<li><p>set(i,x) 设置第i个元素(从1开始)</p>
</li>
<li><p>get(i) 获得第i个元素。</p>
</li>
<li><p>技巧：</p>
<p> ``</p>
<pre><code>ArrayList&lt;X&gt; list = new ArrayListoQ;
while (. . .) { 
x = . .
list.add(x); 
}
X[] a = new XPtst.sizeO];
list.toArray(a);</code></pre><p> ``</p>
</li>
<li><p>remove(i) 删除第i个元素</p>
</li>
<li><p>for each</p>
<p> ``</p>
<pre><code>for (Employee e : staff)
    dosomethingwith e</code></pre><p> ``</p>
</li>
</ol>
<h3 id="类型化与原始数组列表的兼容性"><a href="#类型化与原始数组列表的兼容性" class="headerlink" title="类型化与原始数组列表的兼容性"></a>类型化与原始数组列表的兼容性</h3><ol>
<li>将类型化数组列表传给没有类型的参数不会报错，反之不然。(<strong>有警告时可尝试使用强制类型转换</strong>)</li>
<li><strong>注意</strong> 鉴于兼容性的考虑， 编译<br>器在对类型转换进行检査之后， 如果没有发现违反规则的现象，就将所有的类型化数组列表<br>转换成原始 ArrayList 对象。 在程序运行时，所有的数组列表都是一样的，即没有虚拟机中<br>的类型参数。 因此， 类型转换（ ArrayList) 和 ( ArrayList<Employee> ) 将执行相同的运行时<br>检查。</li>
<li>如果能够确定这个警告问题不大，可以用@SuppressWamings(“unchecked”) 标注来标记。</li>
</ol>
<h2 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h2><h3 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h3><ol>
<li><p>包装类是final，即一旦构造了包装器，就不允许更改包装在其中的值。同时也不可被继承。</p>
</li>
<li><p><strong>自动装箱</strong> 有需要时，基本类型自动转成相应的包装类。相应的，也存在自动拆箱。</p>
<ol>
<li>自动装箱规范要求 boolean、byte、char 127， 介于 -128 ~ 127 之间的 short 和int 被包装到固定的对象中。</li>
<li>由于包装器类引用可以为 null, 所以自动装箱有可能会抛出一个NullPointerException 异常</li>
</ol>
</li>
<li><p>如果一个表达式中混合使用了Integer和Double，那么Integer会先拆箱，再提升为double，再装箱为Double</p>
</li>
<li><p>这些过程时编译器做的，虚拟机只是执行这些字节码</p>
</li>
</ol>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ol>
<li><strong>注意</strong> Integer对象是不可变的：包含在包装器中的内容不会改变。不能使用这些包装器类创建修改数值参数的方法</li>
<li>Integer.parseInt(s) 将一个字符串转成整型</li>
</ol>
<p><img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/29.png" alt=""></p>
<p><img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/30.png" alt=""></p>
<h2 id="参数数量可变的方法"><a href="#参数数量可变的方法" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h2><h3 id="printf-函数"><a href="#printf-函数" class="headerlink" title="printf 函数"></a>printf 函数</h3><p>``</p>
<pre><code>public PrintStream printf(String fmt , Object... args) { return format(fmt, args); }</code></pre><p>``</p>
<ol>
<li><p>…是Java代码的一部分，Object… 相当于 Object[]</p>
</li>
<li><p>编译器需要对 printf 的每次调用进行转换， 以便将参数绑定到数组上，并在必要的时候<br>进行自动装箱：</p>
<p> ``</p>
<pre><code>System.out.printf(&quot;M Xs&quot;, new ObjectO { new Integer(n), &quot;widgets&quot; } );</code></pre><p> ``</p>
<h3 id="自定义多参数函数"><a href="#自定义多参数函数" class="headerlink" title="自定义多参数函数"></a>自定义多参数函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static double max (double... values) &#123;</span><br><span class="line">double largest &#x3D; Double.NECATIVEJNFINITY;</span><br><span class="line">for (double v : values) </span><br><span class="line">	if (v &gt; largest) largest &#x3D; v;</span><br><span class="line">return largest; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>允许将一个数组传递给可变参数方法的最后一个参数。</p>
</li>
</ol>
<p>``</p>
<pre><code>public static void main(String... args)</code></pre><p>``</p>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><ol>
<li><p>使用enum修饰</p>
<p> ``</p>
<pre><code>public enuni Size { SMALL , MEDIUM, LARGE, EXTRAJARGE };</code></pre><p> ``</p>
<ol>
<li>定义了一个类，它有4个实例</li>
</ol>
</li>
<li><p>比较两个枚举类型时，直接 == 即可</p>
</li>
<li><p>所有的枚举类型都是enum类的子类，它们继承了这个类的许多方法。</p>
</li>
<li><p>toString方法可以返回枚举常量名</p>
</li>
<li><p>valueOf方法时toString方法的逆方法</p>
</li>
<li><p>每个枚举类型都有一个静态的values方法， 它将返回一个包含全部枚举值的数组。</p>
</li>
</ol>
<p>``</p>
<pre><code>Size[] values = Size.values();</code></pre><p>``</p>
<ol start="7">
<li>ordinal 方法 返回enum声明中枚举常量的位置，位置从0开始计数。</li>
</ol>
<p><img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/31.png" alt=""></p>
<h3 id="枚举类举例"><a href="#枚举类举例" class="headerlink" title="枚举类举例"></a>枚举类举例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	public enum Day2 &#123;</span><br><span class="line">    MONDAY(&quot;星期一&quot;),</span><br><span class="line">    TUESDAY(&quot;星期二&quot;),</span><br><span class="line">    WEDNESDAY(&quot;星期三&quot;),</span><br><span class="line">    THURSDAY(&quot;星期四&quot;),</span><br><span class="line">    FRIDAY(&quot;星期五&quot;),</span><br><span class="line">    SATURDAY(&quot;星期六&quot;),</span><br><span class="line">    SUNDAY(&quot;星期日&quot;);&#x2F;&#x2F;记住要用分号结束</span><br><span class="line"></span><br><span class="line">    private String desc;&#x2F;&#x2F;中文描述</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 私有构造,防止被外部调用</span><br><span class="line">     * @param desc</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Day2(String desc)&#123;</span><br><span class="line">        this.desc&#x3D;desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义方法,返回描述,跟常规类的定义没区别</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public String getDesc()&#123;</span><br><span class="line">        return desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        for (Day2 day:Day2.values()) &#123;</span><br><span class="line">            System.out.println(&quot;name:&quot;+day.name()+</span><br><span class="line">                    &quot;,desc:&quot;+day.getDesc());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     输出结果:</span><br><span class="line">     name:MONDAY,desc:星期一</span><br><span class="line">     name:TUESDAY,desc:星期二</span><br><span class="line">     name:WEDNESDAY,desc:星期三</span><br><span class="line">     name:THURSDAY,desc:星期四</span><br><span class="line">     name:FRIDAY,desc:星期五</span><br><span class="line">     name:SATURDAY,desc:星期六</span><br><span class="line">     name:SUNDAY,desc:星期日</span><br><span class="line">     *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><ol>
<li>反射库：提供了一个非常丰富且精心设计的工具集， 以便编写能够动<br>态操纵 Java 代码的程序。大量地应用于 JavaBeans 中， 它是 Java组件的体系结构。</li>
<li>反射：能够分析类能力的程序称为反射。可以用于<ol>
<li>在运行时分析类的能力</li>
<li>在运行时查看对象</li>
<li>实现通用的数组操作代码</li>
<li>利用Method对象，这个对象很像C++中的函数指针</li>
</ol>
</li>
</ol>
<h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><ol>
<li><p>一个Class对象标识一个特定类的属性。</p>
<ol>
<li>使用getClass()返回一个Class类型的实例</li>
<li>使用getName()返回类的名字</li>
</ol>
</li>
<li><p>newInstance()方法，可以用来动态的创建一个类的实例。</p>
<p> ``</p>
<pre><code>e.getClass.newInstance();</code></pre><p> ``</p>
<ol>
<li>newlnstance方法调用默认的构造器（没有参数的构<br>造器）初始化新创建的对象。如果这个类没有默认的构造器， 就会抛出一个异常。</li>
</ol>
</li>
<li><p><strong>技巧</strong> 将 forName 与 newlnstance 配合起来使用， 可以根据存储在字符串中的类名创建一个对象</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String s &#x3D; &quot;java.util .Random&quot;;</span><br><span class="line">Object m &#x3D; Cl ass.forName (s) .newlnstance();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><ol>
<li><p>分为未检查异常和已检查异常。</p>
<ol>
<li>对于已检查异常， 编译器将会检查是否提<br>供了处理器。</li>
<li>对于未检查异常，编译<br>器不会査看是否为这些错误提供了处理器。毕竟，应该精心地编写代码来避免这些错误的发<br>生， 而不要将精力花在编写异常处理器上。</li>
</ol>
</li>
<li><p>常用方法</p>
</li>
</ol>
<p><img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/32.png" alt=""></p>
<h3 id="利用反射分析类的能力"><a href="#利用反射分析类的能力" class="headerlink" title="利用反射分析类的能力"></a>利用反射分析类的能力</h3><ol>
<li><p>java.lang.reflect 包中有三个类 Field、 Method 和 Constructor分别用于描述类的域、 方<br>法和构造器。</p>
<ol>
<li>Held 类有一<br>个 getType 方法， 用来返回描述域所属类型的 Class 对象。</li>
<li>Method 和 Constructor 类有能够<br>报告参数类型的方法，Method 类还有一个可以报告返回类型的方法。</li>
<li>这三个类还有一个叫<br>做 getModifiers 的方法， 它将返回一个整型数值，用不同的位开关描述 public 和 static 这样<br>的修饰符使用状况。</li>
<li>可以利用java.lang.refleCt 包中的 Modifiei•类的静态方法分析<br>getModifiers 返回的整型数值。例如， 可以使用 Modifier 类中的 isPublic、 isPrivate 或 isFinal<br>判断方法或构造器是否是 public、 private 或 final。</li>
</ol>
</li>
<li><p>Class类中的 </p>
<ol>
<li>getFields、 getMethods 和 getConstructors 方 法 将 分 别 返 回 类 提 供 的<br>public 域、 方法和构造器数组， 其中包括超类的公有成员。</li>
<li>getDeclareFields、<br>getDeclareMethods 和 getDeclaredConstructors 方法将分别返回类中声明的全部域、 方法和构<br>造器， 其中包括私有和受保护成员，但不包括超类的成员。</li>
</ol>
</li>
<li><p>访问示例</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">package reflection;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * This program uses reflection to print all features of a class.</span><br><span class="line"> * @version 1.1 2004-02-21</span><br><span class="line"> * @author Cay Horstmann</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ReflectionTest</span><br><span class="line">&#123;</span><br><span class="line">   public static void main(String[] args)</span><br><span class="line">   &#123;</span><br><span class="line">      &#x2F;&#x2F; read class name from command line args or user input</span><br><span class="line">      String name;</span><br><span class="line">      if (args.length &gt; 0) name &#x3D; args[0];</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">         Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">         System.out.println(&quot;Enter class name (e.g. java.util.Date): &quot;);</span><br><span class="line">         name &#x3D; in.next();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      try</span><br><span class="line">      &#123;</span><br><span class="line">         &#x2F;&#x2F; print class name and superclass name (if !&#x3D; Object)</span><br><span class="line">         Class cl &#x3D; Class.forName(name);</span><br><span class="line">         Class supercl &#x3D; cl.getSuperclass();</span><br><span class="line">         String modifiers &#x3D; Modifier.toString(cl.getModifiers());</span><br><span class="line">         if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;);</span><br><span class="line">         System.out.print(&quot;class &quot; + name);</span><br><span class="line">         if (supercl !&#x3D; null &amp;&amp; supercl !&#x3D; Object.class) System.out.print(&quot; extends &quot;</span><br><span class="line">               + supercl.getName());</span><br><span class="line"></span><br><span class="line">         System.out.print(&quot;\n&#123;\n&quot;);</span><br><span class="line">         printConstructors(cl);</span><br><span class="line">         System.out.println();</span><br><span class="line">         printMethods(cl);</span><br><span class="line">         System.out.println();</span><br><span class="line">         printFields(cl);</span><br><span class="line">         System.out.println(&quot;&#125;&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      catch (ClassNotFoundException e)</span><br><span class="line">      &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      System.exit(0);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Prints all constructors of a class</span><br><span class="line">    * @param cl a class</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public static void printConstructors(Class cl)</span><br><span class="line">   &#123;</span><br><span class="line">      Constructor[] constructors &#x3D; cl.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line">      for (Constructor c : constructors)</span><br><span class="line">      &#123;</span><br><span class="line">         String name &#x3D; c.getName();</span><br><span class="line">         System.out.print(&quot;   &quot;);</span><br><span class="line">         String modifiers &#x3D; Modifier.toString(c.getModifiers());</span><br><span class="line">         if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;);         </span><br><span class="line">         System.out.print(name + &quot;(&quot;);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; print parameter types</span><br><span class="line">         Class[] paramTypes &#x3D; c.getParameterTypes();</span><br><span class="line">         for (int j &#x3D; 0; j &lt; paramTypes.length; j++)</span><br><span class="line">         &#123;</span><br><span class="line">            if (j &gt; 0) System.out.print(&quot;, &quot;);</span><br><span class="line">            System.out.print(paramTypes[j].getName());</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(&quot;);&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Prints all methods of a class</span><br><span class="line">    * @param cl a class</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public static void printMethods(Class cl)</span><br><span class="line">   &#123;</span><br><span class="line">      Method[] methods &#x3D; cl.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">      for (Method m : methods)</span><br><span class="line">      &#123;</span><br><span class="line">         Class retType &#x3D; m.getReturnType();</span><br><span class="line">         String name &#x3D; m.getName();</span><br><span class="line"></span><br><span class="line">         System.out.print(&quot;   &quot;);</span><br><span class="line">         &#x2F;&#x2F; print modifiers, return type and method name</span><br><span class="line">         String modifiers &#x3D; Modifier.toString(m.getModifiers());</span><br><span class="line">         if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;);         </span><br><span class="line">         System.out.print(retType.getName() + &quot; &quot; + name + &quot;(&quot;);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; print parameter types</span><br><span class="line">         Class[] paramTypes &#x3D; m.getParameterTypes();</span><br><span class="line">         for (int j &#x3D; 0; j &lt; paramTypes.length; j++)</span><br><span class="line">         &#123;</span><br><span class="line">            if (j &gt; 0) System.out.print(&quot;, &quot;);</span><br><span class="line">            System.out.print(paramTypes[j].getName());</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(&quot;);&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Prints all fields of a class</span><br><span class="line">    * @param cl a class</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public static void printFields(Class cl)</span><br><span class="line">   &#123;</span><br><span class="line">      Field[] fields &#x3D; cl.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">      for (Field f : fields)</span><br><span class="line">      &#123;</span><br><span class="line">         Class type &#x3D; f.getType();</span><br><span class="line">         String name &#x3D; f.getName();</span><br><span class="line">         System.out.print(&quot;   &quot;);</span><br><span class="line">         String modifiers &#x3D; Modifier.toString(f.getModifiers());</span><br><span class="line">         if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;);         </span><br><span class="line">         System.out.println(type.getName() + &quot; &quot; + name + &quot;;&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>获得对应的Class对象</li>
<li>通过Class对象调用getDeclaredFields</li>
</ol>
</li>
<li><p>常用函数</p>
<p> <img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/33.png" alt=""></p>
<p> <img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/34.png" alt=""></p>
<p> <img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/35.png" alt=""></p>
</li>
</ol>
<h3 id="运行时使用反射分析对象"><a href="#运行时使用反射分析对象" class="headerlink" title="运行时使用反射分析对象"></a>运行时使用反射分析对象</h3><ol>
<li><p>获取某个域当前内容的步骤</p>
<ol>
<li><p>获得Class对象</p>
</li>
<li><p>用Class对象得到Field对象</p>
</li>
<li><p>用get获得域的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Employee harry &#x3D; new Employee(&quot;Harry Hacker&quot;, 35000, 10, 1, 1989);</span><br><span class="line">Class cl &#x3D; harry.getClass0； &#x2F;&#x2F; the class object representing Employee</span><br><span class="line">Field f &#x3D; cl .getDeclaredFieldC&#39;name&quot;): &#x2F;&#x2F; the name field of the Employee class</span><br><span class="line">Object v &#x3D; f.get(harry); &#x2F;&#x2F; the value of the name field of the harry object , i .e., the String object &quot;Harry Hacker&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>涉及三种异常NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException。</p>
</li>
<li><p>只有利用 get 方法才能得到可访问域的值。除非拥有访问权限，否则<br>Java 安全机制只允许査看任意对象有哪些域， 而不允许读取它们的值。</p>
</li>
<li><p>可使用Field、 Method 或<br>Constructor 对象的 setAccessible 方法来覆盖访问控制。setAccessible 方法是 AccessibleObject 类中的一个方法， 它是 Field、 Method 和 Constructor<br>类的公共超类。</p>
</li>
<li><p>可以通过f.set(obj，value) 可以将 obj 对象的 f 域设置成新值。</p>
</li>
<li><p>常用方法</p>
 <img src="/JAVA核心卷1_img/36.png"></li>
<li><p>toString()通用写法</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">package objectAnalyzer;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.AccessibleObject;</span><br><span class="line">import java.lang.reflect.Array;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.Modifier;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class ObjectAnalyzer</span><br><span class="line">&#123;</span><br><span class="line">   private ArrayList&lt;Object&gt; visited &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Converts an object to a string representation that lists all fields.</span><br><span class="line">    * @param obj an object</span><br><span class="line">    * @return a string with the object&#39;s class name and all field names and</span><br><span class="line">    * values</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public String toString(Object obj)</span><br><span class="line">   &#123;</span><br><span class="line">      if (obj &#x3D;&#x3D; null) return &quot;null&quot;;</span><br><span class="line">      if (visited.contains(obj)) return &quot;...&quot;;</span><br><span class="line">      visited.add(obj);</span><br><span class="line">      Class cl &#x3D; obj.getClass();</span><br><span class="line">      if (cl &#x3D;&#x3D; String.class) return (String) obj;</span><br><span class="line">      if (cl.isArray())</span><br><span class="line">      &#123;</span><br><span class="line">         String r &#x3D; cl.getComponentType() + &quot;[]&#123;&quot;;</span><br><span class="line">         for (int i &#x3D; 0; i &lt; Array.getLength(obj); i++)</span><br><span class="line">         &#123;</span><br><span class="line">            if (i &gt; 0) r +&#x3D; &quot;,&quot;;</span><br><span class="line">            Object val &#x3D; Array.get(obj, i);</span><br><span class="line">            if (cl.getComponentType().isPrimitive()) r +&#x3D; val;</span><br><span class="line">            else r +&#x3D; toString(val);</span><br><span class="line">         &#125;</span><br><span class="line">         return r + &quot;&#125;&quot;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      String r &#x3D; cl.getName();</span><br><span class="line">      &#x2F;&#x2F; inspect the fields of this class and all superclasses</span><br><span class="line">      do</span><br><span class="line">      &#123;</span><br><span class="line">         r +&#x3D; &quot;[&quot;;</span><br><span class="line">         Field[] fields &#x3D; cl.getDeclaredFields();</span><br><span class="line">         AccessibleObject.setAccessible(fields, true);</span><br><span class="line">         &#x2F;&#x2F; get the names and values of all fields</span><br><span class="line">         for (Field f : fields)</span><br><span class="line">         &#123;</span><br><span class="line">            if (!Modifier.isStatic(f.getModifiers()))</span><br><span class="line">            &#123;</span><br><span class="line">               if (!r.endsWith(&quot;[&quot;)) r +&#x3D; &quot;,&quot;;</span><br><span class="line">               r +&#x3D; f.getName() + &quot;&#x3D;&quot;;</span><br><span class="line">               try</span><br><span class="line">               &#123;</span><br><span class="line">                  Class t &#x3D; f.getType();</span><br><span class="line">                  Object val &#x3D; f.get(obj);</span><br><span class="line">                  if (t.isPrimitive()) r +&#x3D; val;</span><br><span class="line">                  else r +&#x3D; toString(val);</span><br><span class="line">               &#125;</span><br><span class="line">               catch (Exception e)</span><br><span class="line">               &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         r +&#x3D; &quot;]&quot;;</span><br><span class="line">         cl &#x3D; cl.getSuperclass();</span><br><span class="line">      &#125;</span><br><span class="line">      while (cl !&#x3D; null);</span><br><span class="line"></span><br><span class="line">      return r;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">package com.corejava.reflection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">public class ObjectAnalyzerTest &#123;</span><br><span class="line"> </span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; squares &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">		for (int i &#x3D; 1; i &lt; 5; i++)</span><br><span class="line">			squares.add(i * i);</span><br><span class="line">		System.out.println(new ObjectAnalyzer().toString(squares));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="使用反射编写泛型数组代码"><a href="#使用反射编写泛型数组代码" class="headerlink" title="使用反射编写泛型数组代码"></a>使用反射编写泛型数组代码</h3><ol>
<li><p>步骤</p>
<ol>
<li>首先获得a数组的类对象</li>
<li>确认它是一个数组</li>
<li>使用Class类的getComponentType方法确定数组对应的类型</li>
<li>注 数组的长度可以通过Array的getLength获得</li>
</ol>
</li>
<li><p>代码</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">public static Object goodCopyOf(Object a, int newLength) &#123;</span><br><span class="line">Class cl &#x3D; a.getClassO；</span><br><span class="line">if (Icl .isArrayO) return null ;</span><br><span class="line">Class componentType &#x3D; cl .getComponentType0；</span><br><span class="line">int length &#x3D; Array.getLength(a);</span><br><span class="line">Object newArray &#x3D; Array.newlnstance(componentType, newLength):</span><br><span class="line">System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength));</span><br><span class="line">return newArray; &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>注意 参数中a没有定义为Object[]，这是因为像int[]可以被转成Object，但是不能转成对象数组</li>
</ol>
</li>
<li><p>CopyTest</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package arrays;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * This program demonstrates the use of reflection for manipulating arrays.</span><br><span class="line"> * @version 1.2 2012-05-04</span><br><span class="line"> * @author Cay Horstmann</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CopyOfTest</span><br><span class="line">&#123;</span><br><span class="line">   public static void main(String[] args)</span><br><span class="line">   &#123;</span><br><span class="line">      int[] a &#x3D; &#123; 1, 2, 3 &#125;;</span><br><span class="line">      a &#x3D; (int[]) goodCopyOf(a, 10);</span><br><span class="line">      System.out.println(Arrays.toString(a));</span><br><span class="line"></span><br><span class="line">      String[] b &#x3D; &#123; &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot; &#125;;</span><br><span class="line">      b &#x3D; (String[]) goodCopyOf(b, 10);</span><br><span class="line">      System.out.println(Arrays.toString(b));</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;The following call will generate an exception.&quot;);</span><br><span class="line">      b &#x3D; (String[]) badCopyOf(b, 10);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * This method attempts to grow an array by allocating a new array and copying all elements.</span><br><span class="line">    * @param a the array to grow</span><br><span class="line">    * @param newLength the new length</span><br><span class="line">    * @return a larger array that contains all elements of a. However, the returned array has </span><br><span class="line">    * type Object[], not the same type as a</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public static Object[] badCopyOf(Object[] a, int newLength) &#x2F;&#x2F; not useful</span><br><span class="line">   &#123;</span><br><span class="line">      Object[] newArray &#x3D; new Object[newLength];</span><br><span class="line">      System.arraycopy(a, 0, newArray, 0, Math.min(a.length, newLength));</span><br><span class="line">      return newArray;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * This method grows an array by allocating a new array of the same type and</span><br><span class="line">    * copying all elements.</span><br><span class="line">    * @param a the array to grow. This can be an object array or a primitive</span><br><span class="line">    * type array</span><br><span class="line">    * @return a larger array that contains all elements of a.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public static Object goodCopyOf(Object a, int newLength) </span><br><span class="line">   &#123;</span><br><span class="line">      Class cl &#x3D; a.getClass();</span><br><span class="line">      if (!cl.isArray()) return null;</span><br><span class="line">      Class componentType &#x3D; cl.getComponentType();</span><br><span class="line">      int length &#x3D; Array.getLength(a);</span><br><span class="line">      Object newArray &#x3D; Array.newInstance(componentType, newLength);</span><br><span class="line">      System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength));</span><br><span class="line">      return newArray;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>常用方法</p>
<p> <img src="/AVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/37.png" alt=""></p>
</li>
</ol>
<h3 id="调用任意方法"><a href="#调用任意方法" class="headerlink" title="调用任意方法"></a>调用任意方法</h3><ol>
<li><p>利用反射实现C++的传递函数参数的功能</p>
</li>
<li><p>使用Method 类中有一个 invoke 方法， 它允许调用包装在当前 Method 对象中<br>的方法。</p>
</li>
<li><p>Object invoke(Object obj, Object… args)</p>
</li>
<li><p>获取Method对象</p>
<ol>
<li>可以通过调用 getDeclareMethods 方法， 然后对返回<br>的 Method 对象数组进行查找， 直到发现想要的方法为止。</li>
<li>也可以通过调用 Class类中的<br>getMethod方法得到想要的方法。但是要注意可能存在很多同名方法，所以还需压迫提供想要的方法的参数类型。</li>
</ol>
</li>
<li><p>通用制表例</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package methods;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * This program shows how to invoke methods through reflection.</span><br><span class="line"> * @version 1.2 2012-05-04</span><br><span class="line"> * @author Cay Horstmann</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MethodTableTest</span><br><span class="line">&#123;</span><br><span class="line">   public static void main(String[] args) throws Exception</span><br><span class="line">   &#123;</span><br><span class="line">      &#x2F;&#x2F; get method pointers to the square and sqrt methods</span><br><span class="line">      Method square &#x3D; MethodTableTest.class.getMethod(&quot;square&quot;, double.class);</span><br><span class="line">      Method sqrt &#x3D; Math.class.getMethod(&quot;sqrt&quot;, double.class);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; print tables of x- and y-values</span><br><span class="line"></span><br><span class="line">      printTable(1, 10, 10, square);</span><br><span class="line">      printTable(1, 10, 10, sqrt);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Returns the square of a number</span><br><span class="line">    * @param x a number</span><br><span class="line">    * @return x squared</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public static double square(double x)</span><br><span class="line">   &#123;</span><br><span class="line">      return x * x;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Prints a table with x- and y-values for a method</span><br><span class="line">    * @param from the lower bound for the x-values</span><br><span class="line">    * @param to the upper bound for the x-values</span><br><span class="line">    * @param n the number of rows in the table</span><br><span class="line">    * @param f a method with a double parameter and double return value</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public static void printTable(double from, double to, int n, Method f)</span><br><span class="line">   &#123;</span><br><span class="line">      &#x2F;&#x2F; print out the method as table header</span><br><span class="line">      System.out.println(f);</span><br><span class="line"></span><br><span class="line">      double dx &#x3D; (to - from) &#x2F; (n - 1);</span><br><span class="line"></span><br><span class="line">      for (double x &#x3D; from; x &lt;&#x3D; to; x +&#x3D; dx)</span><br><span class="line">      &#123;</span><br><span class="line">         try</span><br><span class="line">         &#123;</span><br><span class="line">            double y &#x3D; (Double) f.invoke(null, x);</span><br><span class="line">            System.out.printf(&quot;%10.4f | %10.4f%n&quot;, x, y);</span><br><span class="line">         &#125;</span><br><span class="line">         catch (Exception e)</span><br><span class="line">         &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>问题</strong></p>
<ol>
<li>invoke 的参数和返回值必须是 Object 类型的。这就意味着必须进行多次的类型转<br>换。</li>
<li>用反射获得方法指针的代码要比仅仅直接调用方<br>法明显慢一些</li>
</ol>
</li>
</ol>
<h2 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h2><ol>
<li><p>将公共操作和域放在超类</p>
</li>
<li><p>不要使用受保护的域。主要原因有</p>
<ol>
<li>子类集合是无限制的， 任何一个人都能够由某个类派生一个子类，并<br>编写代码以直接访问 protected 的实例域， 从而破坏了封装性。</li>
<li>在 Java 程序设计语言<br>中，在同一个包中的所有类都可以访问 proteced 域，而不管它是否为这个类的子类。</li>
<li>protected 方法对于指示那些不提供一般用途而应在子类中重新定义的方法很有用。</li>
</ol>
</li>
<li><p>使用继承实现“ is-a” 关系。如果B不包含A中某些域，那么一般就不是is-a关系</p>
</li>
<li><p>除非所有继承的方法都有以以，否则不要使用继承</p>
</li>
<li><p>在覆盖方法时，不要改变预期的行为</p>
</li>
<li><p>使用多态，而非类型信息</p>
</li>
<li><p>不要过多的使用反射</p>
</li>
</ol>

    </div>

    
    
    
    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>
      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/hide/" rel="tag"># hide</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/22/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/" rel="prev" title="python数据分析与挖掘实战笔记">
      <i class="fa fa-chevron-left"></i> python数据分析与挖掘实战笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/23/%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%B0%83%E5%BA%A6/" rel="next" title="流水线调度">
      流水线调度 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一章-Java程序设计概述"><span class="nav-number">1.</span> <span class="nav-text">第一章 Java程序设计概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二章-Java程序设计环境"><span class="nav-number">2.</span> <span class="nav-text">第二章 Java程序设计环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#体系结构中立"><span class="nav-number">2.1.</span> <span class="nav-text">体系结构中立</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可移植性"><span class="nav-number">2.2.</span> <span class="nav-text">可移植性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程"><span class="nav-number">2.3.</span> <span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态性"><span class="nav-number">2.4.</span> <span class="nav-text">动态性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#applet和Internet"><span class="nav-number">2.5.</span> <span class="nav-text">applet和Internet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见术语解释"><span class="nav-number">2.6.</span> <span class="nav-text">常见术语解释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用命令工具"><span class="nav-number">2.7.</span> <span class="nav-text">使用命令工具</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三章-Java的基本程序设计结构"><span class="nav-number">3.</span> <span class="nav-text">第三章 Java的基本程序设计结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类"><span class="nav-number">3.1.</span> <span class="nav-text">类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据类型"><span class="nav-number">3.2.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运算符"><span class="nav-number">3.3.</span> <span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串"><span class="nav-number">3.4.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String-API"><span class="nav-number">3.4.1.</span> <span class="nav-text">String API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuilder"><span class="nav-number">3.4.2.</span> <span class="nav-text">StringBuilder</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入输出"><span class="nav-number">3.5.</span> <span class="nav-text">输入输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#输入"><span class="nav-number">3.5.1.</span> <span class="nav-text">输入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输出"><span class="nav-number">3.5.2.</span> <span class="nav-text">输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制流程"><span class="nav-number">3.6.</span> <span class="nav-text">控制流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#大数值"><span class="nav-number">3.7.</span> <span class="nav-text">大数值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">3.8.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#增强for循环"><span class="nav-number">3.8.1.</span> <span class="nav-text">增强for循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组拷贝"><span class="nav-number">3.8.2.</span> <span class="nav-text">数组拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组排序"><span class="nav-number">3.8.3.</span> <span class="nav-text">数组排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Arrays"><span class="nav-number">3.8.4.</span> <span class="nav-text">Arrays</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不规则数组"><span class="nav-number">3.8.5.</span> <span class="nav-text">不规则数组</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四章-对象和类"><span class="nav-number">4.</span> <span class="nav-text">第四章 对象和类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象程序设计概述"><span class="nav-number">4.1.</span> <span class="nav-text">面向对象程序设计概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预定义类"><span class="nav-number">4.2.</span> <span class="nav-text">预定义类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户自定义类"><span class="nav-number">4.3.</span> <span class="nav-text">用户自定义类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#静态域和静态方法"><span class="nav-number">4.3.1.</span> <span class="nav-text">静态域和静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工厂方法"><span class="nav-number">4.3.2.</span> <span class="nav-text">工厂方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#main-方法"><span class="nav-number">4.3.3.</span> <span class="nav-text">main 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法参数"><span class="nav-number">4.3.4.</span> <span class="nav-text">方法参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象构造"><span class="nav-number">4.4.</span> <span class="nav-text">对象构造</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#显式域初始化"><span class="nav-number">4.4.1.</span> <span class="nav-text">显式域初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化块"><span class="nav-number">4.4.2.</span> <span class="nav-text">初始化块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造器具体处理步骤"><span class="nav-number">4.4.3.</span> <span class="nav-text">构造器具体处理步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态初始化块"><span class="nav-number">4.4.4.</span> <span class="nav-text">静态初始化块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finalize方法"><span class="nav-number">4.4.5.</span> <span class="nav-text">finalize方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#包"><span class="nav-number">4.5.</span> <span class="nav-text">包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#静态导入"><span class="nav-number">4.5.1.</span> <span class="nav-text">静态导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包作用域"><span class="nav-number">4.5.2.</span> <span class="nav-text">包作用域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类路径"><span class="nav-number">4.6.</span> <span class="nav-text">类路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文档注释"><span class="nav-number">4.7.</span> <span class="nav-text">文档注释</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类注释"><span class="nav-number">4.7.1.</span> <span class="nav-text">类注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法注释"><span class="nav-number">4.7.2.</span> <span class="nav-text">方法注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#域注释"><span class="nav-number">4.7.3.</span> <span class="nav-text">域注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通用注释"><span class="nav-number">4.7.4.</span> <span class="nav-text">通用注释</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类设计技巧"><span class="nav-number">4.8.</span> <span class="nav-text">类设计技巧</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五章-继承"><span class="nav-number">5.</span> <span class="nav-text">第五章 继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#类、超类和子类"><span class="nav-number">5.1.</span> <span class="nav-text">类、超类和子类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义子类"><span class="nav-number">5.1.1.</span> <span class="nav-text">定义子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#覆盖方法"><span class="nav-number">5.1.2.</span> <span class="nav-text">覆盖方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子类构造器"><span class="nav-number">5.1.3.</span> <span class="nav-text">子类构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阻止继承：final类和方法"><span class="nav-number">5.1.4.</span> <span class="nav-text">阻止继承：final类和方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#强制类型转换"><span class="nav-number">5.1.5.</span> <span class="nav-text">强制类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类"><span class="nav-number">5.1.6.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#受保护的访问"><span class="nav-number">5.1.7.</span> <span class="nav-text">受保护的访问</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-所有类的超类"><span class="nav-number">5.2.</span> <span class="nav-text">Object 所有类的超类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#equals方法"><span class="nav-number">5.2.1.</span> <span class="nav-text">equals方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashCode-方法"><span class="nav-number">5.2.2.</span> <span class="nav-text">hashCode 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#toString-方法"><span class="nav-number">5.2.3.</span> <span class="nav-text">toString 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#例程"><span class="nav-number">5.2.4.</span> <span class="nav-text">例程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型数组列表"><span class="nav-number">5.3.</span> <span class="nav-text">泛型数组列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList"><span class="nav-number">5.3.1.</span> <span class="nav-text">ArrayList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问数组列表元素"><span class="nav-number">5.3.2.</span> <span class="nav-text">访问数组列表元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型化与原始数组列表的兼容性"><span class="nav-number">5.3.3.</span> <span class="nav-text">类型化与原始数组列表的兼容性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象包装器与自动装箱"><span class="nav-number">5.4.</span> <span class="nav-text">对象包装器与自动装箱</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自动装箱"><span class="nav-number">5.4.1.</span> <span class="nav-text">自动装箱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用方法"><span class="nav-number">5.4.2.</span> <span class="nav-text">常用方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参数数量可变的方法"><span class="nav-number">5.5.</span> <span class="nav-text">参数数量可变的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#printf-函数"><span class="nav-number">5.5.1.</span> <span class="nav-text">printf 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义多参数函数"><span class="nav-number">5.5.2.</span> <span class="nav-text">自定义多参数函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#枚举类"><span class="nav-number">5.6.</span> <span class="nav-text">枚举类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举类举例"><span class="nav-number">5.6.1.</span> <span class="nav-text">枚举类举例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反射"><span class="nav-number">5.7.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Class类"><span class="nav-number">5.7.1.</span> <span class="nav-text">Class类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#捕获异常"><span class="nav-number">5.7.2.</span> <span class="nav-text">捕获异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用反射分析类的能力"><span class="nav-number">5.7.3.</span> <span class="nav-text">利用反射分析类的能力</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时使用反射分析对象"><span class="nav-number">5.7.4.</span> <span class="nav-text">运行时使用反射分析对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用反射编写泛型数组代码"><span class="nav-number">5.7.5.</span> <span class="nav-text">使用反射编写泛型数组代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调用任意方法"><span class="nav-number">5.7.6.</span> <span class="nav-text">调用任意方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承的设计技巧"><span class="nav-number">5.8.</span> <span class="nav-text">继承的设计技巧</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Cuienbo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">159</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Cuienbo</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.7.0
  </div>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
  
</body>
</html>
