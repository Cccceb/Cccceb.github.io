<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>201604-4</title>
    <url>/2020/03/02/201604-4/</url>
    <content><![CDATA[<h1 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　小明在玩一个电脑游戏，游戏在一个<em>n</em>×<em>m</em>的方格图上进行，小明控制的角色开始的时候站在第一行第一列，目标是前往第<em>n</em>行第<em>m</em>列。<br> 　方格图上有一些方格是始终安全的，有一些在一段时间是危险的，如果小明控制的角色到达一个方格的时候方格是危险的，则小明输掉了游戏，如果小明的角色到达了第<em>n</em>行第<em>m</em>列，则小明过关。第一行第一列和第<em>n</em>行第<em>m</em>列永远都是安全的。<br> 　每个单位时间，小明的角色必须向上下左右四个方向相邻的方格中的一个移动一格。<br> 　经过很多次尝试，小明掌握了方格图的安全和危险的规律：每一个方格出现危险的时间一定是连续的。并且，小明还掌握了每个方格在哪段时间是危险的。<br> 　现在，小明想知道，自己最快经过几个时间单位可以达到第<em>n</em>行第<em>m</em>列过关。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入的第一行包含三个整数<em>n</em>, <em>m</em>, <em>t</em>，用一个空格分隔，表示方格图的行数<em>n</em>、列数<em>m</em>，以及方格图中有危险的方格数量。<br> 　接下来<em>t</em>行，每行4个整数<em>r</em>, <em>c</em>, <em>a</em>, <em>b</em>，表示第<em>r</em>行第<em>c</em>列的方格在第<em>a</em>个时刻到第<em>b</em>个时刻之间是危险的，包括<em>a</em>和<em>b</em>。游戏开始时的时刻为0。输入数据保证<em>r</em>和<em>c</em>不同时为1，而且当<em>r</em>为<em>n</em>时<em>c</em>不为<em>m</em>。一个方格只有一段时间是危险的（或者说不会出现两行拥有相同的<em>r</em>和<em>c</em>）。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出一个整数，表示小明最快经过几个时间单位可以过关。输入数据保证小明一定可以过关。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>3 3 3<br> 2 1 1 1<br> 1 3 2 10<br> 2 2 2 10</p>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>6</p>
<h2 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h2><p>　　第2行第1列时刻1是危险的，因此第一步必须走到第1行第2列。<br> 　第二步可以走到第1行第1列，第三步走到第2行第1列，后面经过第3行第1列、第3行第2列到达第3行第3列。</p>
<p>评测用例规模与约定</p>
<p>　　前30%的评测用例满足：0 &lt; <em>n</em>, <em>m</em> ≤ 10，0 ≤ <em>t</em> &lt; 99。<br> 　所有评测用例满足：0 &lt; <em>n</em>, <em>m</em> ≤ 100，0 ≤ <em>t</em> &lt; 9999，1 ≤ <em>r</em> ≤ <em>n</em>，1 ≤ <em>c</em> ≤ <em>m</em>，0 ≤ <em>a</em> ≤ <em>b</em> ≤ 100。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>将边权看作1，则本题是无向图最短路问题</li>
<li>根据测试例可以发现，题中允许重复访问点。但是同一个时间点不能反复经过一个点，因为没有意义。所以vis数组应该为三位</li>
<li>使用bfs来求最短路径即可</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">int dx[] &#x3D; &#123; 1,0,-1,0 &#125;;</span><br><span class="line">int dy[] &#x3D; &#123; 0,-1,0,1 &#125;;</span><br><span class="line">int a[maxn][maxn];</span><br><span class="line">int b[maxn][maxn];</span><br><span class="line">int vis[maxn][maxn][300];</span><br><span class="line">int dis[maxn][maxn];</span><br><span class="line">int change[1000000];</span><br><span class="line">struct node &#123;</span><br><span class="line">	int x, y, t;</span><br><span class="line">	node(int x,int y,int t):x(x),y(y),t(t)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int n, m;</span><br><span class="line">int ans;</span><br><span class="line">void bfs() &#123;</span><br><span class="line">	queue&lt;node&gt; q;</span><br><span class="line">	node beg(1, 1, 0);</span><br><span class="line">	q.push(beg);</span><br><span class="line">	vis[1][1][0] &#x3D; 1;</span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		node f &#x3D; q.front(); q.pop();</span><br><span class="line">		int x &#x3D; f.x;</span><br><span class="line">		int y &#x3D; f.y;</span><br><span class="line">		&#x2F;&#x2F;printf(&quot;%d %d %d\n&quot;, x, y, f.t);</span><br><span class="line">		if (x &#x3D;&#x3D; n &amp;&amp; y &#x3D;&#x3D; m) &#123;</span><br><span class="line">			ans &#x3D; f.t;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">			int newx &#x3D; x + dx[i];</span><br><span class="line">			int newy &#x3D; y + dy[i];</span><br><span class="line">			int newt &#x3D; f.t + 1;</span><br><span class="line">			if (newx&lt;1 || newx&gt;n || newy&lt;1 || newy&gt;m) continue;</span><br><span class="line">			if (vis[newx][newy][f.t + 1]) continue;</span><br><span class="line">			if (newt&lt;a[newx][newy] || newt&gt;b[newx][newy]) &#123;</span><br><span class="line">				vis[newx][newy][newt] &#x3D; 1;</span><br><span class="line">				q.push(node(newx, newy, newt));</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int t;</span><br><span class="line">	int x, y, xa, xb;</span><br><span class="line">	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t);</span><br><span class="line">	memset(a, -1, sizeof(a));</span><br><span class="line">	memset(b, -1, sizeof(b));</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	memset(change, 0, sizeof(change));</span><br><span class="line">	for (int i &#x3D; 0; i &lt; t; i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d%d%d&quot;, &amp;x, &amp;y, &amp;xa, &amp;xb);</span><br><span class="line">		change[xa] &#x3D; change[xb] &#x3D; 1;</span><br><span class="line">		a[x][y] &#x3D; xa;</span><br><span class="line">		b[x][y] &#x3D; xb;</span><br><span class="line">	&#125;</span><br><span class="line">	bfs();</span><br><span class="line">	printf(&quot;%d&quot;, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201312-4</title>
    <url>/2020/03/02/201312-4/</url>
    <content><![CDATA[<h1 id="有趣的数"><a href="#有趣的数" class="headerlink" title="有趣的数"></a>有趣的数</h1><p><strong>问题描述</strong></p>
<p>　　我们把一个数称为有趣的，当且仅当：<br>　　1. 它的数字只包含0, 1, 2, 3，且这四个数字都出现过至少一次。<br>　　2. 所有的0都出现在所有的1之前，而所有的2都出现在所有的3之前。<br>　　3. 最高位数字不为0。<br>　　因此，符合我们定义的最小的有趣的数是2013。除此以外，4位的有趣的数还有两个：2031和2301。<br>　　请计算恰好有n位的有趣的数的个数。由于答案可能非常大，只需要输出答案除以1000000007的余数。</p>
<p><strong>输入格式</strong></p>
<p>　　输入只有一行，包括恰好一个正整数n (4 ≤ n ≤ 1000)。</p>
<p><strong>输出格式</strong></p>
<p>　　输出只有一行，包括恰好n 位的整数中有趣的数的个数除以1000000007的余数。</p>
<p><strong>样例输入</strong></p>
<p>4</p>
<p><strong>样例输出</strong></p>
<p>3</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>由于规则限制，每一位能选的数都与之前位的状态有关，所以是个dp问题</p>
</li>
<li><p>将状态进行分类可得，前i位数字使用情况包括</p>
<ol>
<li>只含2</li>
<li>只含2、0</li>
<li>只含2、3</li>
<li>只含2、0、3</li>
<li>只含2、0、1</li>
<li>含4种数字。</li>
</ol>
</li>
<li><p>如果现在要尝试填充第i位，第i位则有6中状态。以状态5为例,设j = i - 1。则第i位的来源包括</p>
<ol>
<li>第j位的状态5扩展，在第i位填1或2</li>
<li>从j位的专题2扩展，在第i位填1</li>
<li>dp[i][4] = (dp[i - 1][1] + dp[i - 1][4] * 2) % Mod; </li>
</ol>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[maxn][<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> Mod = <span class="number">1000000007</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="comment">/*6种状态</span></span><br><span class="line"><span class="comment">	1、只含2</span></span><br><span class="line"><span class="comment">	2、只含2、0</span></span><br><span class="line"><span class="comment">	3、只含2、3</span></span><br><span class="line"><span class="comment">	4、只含2、0、3</span></span><br><span class="line"><span class="comment">	5、只含2、0、1</span></span><br><span class="line"><span class="comment">	6、含4种数字。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">		dp[i][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line">		dp[i][<span class="number">1</span>] = (dp[i - <span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">1</span>] * <span class="number">2</span>) % Mod;   <span class="comment">// 0 2 （状态0第i位只能为2，状态1第i位可以为0或2，所以要乘2，后面以此类推）</span></span><br><span class="line">		dp[i][<span class="number">2</span>] = (dp[i - <span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">2</span>]) % Mod;     <span class="comment">// 2 3</span></span><br><span class="line">		dp[i][<span class="number">3</span>] = (dp[i - <span class="number">1</span>][<span class="number">1</span>] + dp[i - <span class="number">1</span>][<span class="number">2</span>] + dp[i - <span class="number">1</span>][<span class="number">3</span>] * <span class="number">2</span>) % Mod;   <span class="comment">// 0 2 3</span></span><br><span class="line">		dp[i][<span class="number">4</span>] = (dp[i - <span class="number">1</span>][<span class="number">1</span>] + dp[i - <span class="number">1</span>][<span class="number">4</span>] * <span class="number">2</span>) % Mod;  <span class="comment">// 0 1 2</span></span><br><span class="line">		dp[i][<span class="number">5</span>] = (dp[i - <span class="number">1</span>][<span class="number">3</span>] + dp[i - <span class="number">1</span>][<span class="number">4</span>] + dp[i - <span class="number">1</span>][<span class="number">5</span>] * <span class="number">2</span>) % Mod; <span class="comment">// 0 1 2 3</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, dp[n][<span class="number">5</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201403-4</title>
    <url>/2020/03/02/201403-4/</url>
    <content><![CDATA[<h1 id="无线网络"><a href="#无线网络" class="headerlink" title="无线网络"></a>无线网络</h1><p><strong>问题描述</strong></p>
<p>　　目前在一个很大的平面房间里有 n 个无线路由器,每个无线路由器都固定在某个点上。任何两个无线路由器只要距离不超过 r 就能互相建立网络连接。<br>　　除此以外,另有 m 个可以摆放无线路由器的位置。你可以在这些位置中选择至多 k 个增设新的路由器。<br>　　你的目标是使得第 1 个路由器和第 2 个路由器之间的网络连接经过尽量少的中转路由器。请问在最优方案下中转路由器的最少个数是多少?</p>
<p><strong>输入格式</strong></p>
<p>　　第一行包含四个正整数 n,m,k,r。(2 ≤ n ≤ 100,1 ≤ k ≤ m ≤ 100, 1 ≤ r ≤ 108)。<br>　　接下来 n 行,每行包含两个整数 xi 和 yi,表示一个已经放置好的无线 路由器在 (xi, yi) 点处。输入数据保证第 1 和第 2 个路由器在仅有这 n 个路由器的情况下已经可以互相连接(经过一系列的中转路由器)。<br>　　接下来 m 行,每行包含两个整数 xi 和 yi,表示 (xi, yi) 点处可以增设 一个路由器。<br>　　输入中所有的坐标的绝对值不超过 108,保证输入中的坐标各不相同。</p>
<p><strong>输出格式</strong></p>
<p>　　输出只有一个数,即在指定的位置中增设 k 个路由器后,从第 1 个路 由器到第 2 个路由器最少经过的中转路由器的个数。</p>
<p><strong>样例输入</strong></p>
<p>5 3 1 3<br>0 0<br>5 5<br>0 3<br>0 5<br>3 5<br>3 3<br>4 4<br>3 0</p>
<p><strong>样例输出</strong></p>
<p>2</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>将坐标 构建成图，然后bfs即可</li>
<li>构建图时，借助t数组使得i j 间距离和j i间距离，只计算一次</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">bool</span> t[maxn][maxn];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p pair<span class="meta-string">&lt;ll,ll&gt;;</span></span></span><br><span class="line">ll r;</span><br><span class="line">pair&lt;ll, ll&gt; node[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">step</span>[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(<span class="built_in">step</span>, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="built_in">step</span>));</span><br><span class="line">	<span class="keyword">int</span> beg = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> goal = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="built_in">step</span>[beg] = <span class="number">0</span>;</span><br><span class="line">	q.push(beg);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">if</span> (u == goal) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">step</span>[v] == <span class="number">-1</span> || <span class="built_in">step</span>[v] &gt; <span class="built_in">step</span>[u] + <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="built_in">step</span>[v] = <span class="built_in">step</span>[u] + <span class="number">1</span>;</span><br><span class="line">				q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">step</span>[goal]<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%lld"</span>, &amp;n, &amp;m, &amp;k, &amp;r);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;node[i].first, &amp;node[i].second);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= m + n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;node[i].first, &amp;node[i].second);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (t[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">sqrt</span>((node[i].first - node[j].first)*(node[i].first - node[j].first)</span><br><span class="line">				+ (node[i].second - node[j].second)*(node[i].second - node[j].second)) &gt; r) <span class="keyword">continue</span>;</span><br><span class="line">			g[i].push_back(j);</span><br><span class="line">			g[j].push_back(i);</span><br><span class="line">			t[i][j] = t[j][i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, bfs());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201412-4</title>
    <url>/2020/03/02/201412-4/</url>
    <content><![CDATA[<h1 id="最优灌溉"><a href="#最优灌溉" class="headerlink" title="最优灌溉"></a>最优灌溉</h1><p><strong>问题描述</strong></p>
<p>　　雷雷承包了很多片麦田，为了灌溉这些麦田，雷雷在第一个麦田挖了一口很深的水井，所有的麦田都从这口井来引水灌溉。<br>　　为了灌溉，雷雷需要建立一些水渠，以连接水井和麦田，雷雷也可以利用部分麦田作为“中转站”，利用水渠连接不同的麦田，这样只要一片麦田能被灌溉，则与其连接的麦田也能被灌溉。<br>　　现在雷雷知道哪些麦田之间可以建设水渠和建设每个水渠所需要的费用（注意不是所有麦田之间都可以建立水渠）。请问灌溉所有麦田最少需要多少费用来修建水渠。</p>
<p><strong>输入格式</strong></p>
<p>　　输入的第一行包含两个正整数n, m，分别表示麦田的片数和雷雷可以建立的水渠的数量。麦田使用1, 2, 3, ……依次标号。<br>　　接下来m行，每行包含三个整数ai, bi, ci，表示第ai片麦田与第bi片麦田之间可以建立一条水渠，所需要的费用为ci。</p>
<p><strong>输出格式</strong></p>
<p>　　输出一行，包含一个整数，表示灌溉所有麦田所需要的最小费用。</p>
<p><strong>样例输入</strong></p>
<p>4 4<br>1 2 1<br>2 3 4<br>2 4 2<br>3 4 3</p>
<p><strong>样例输出</strong></p>
<p>6</p>
<p><strong>样例说明</strong></p>
<p>　　建立以下三条水渠：麦田1与麦田2、麦田2与麦田4、麦田4与麦田3。</p>
<p><strong>评测用例规模与约定</strong></p>
<p>　　前20%的评测用例满足：n≤5。<br>　　前40%的评测用例满足：n≤20。<br>　　前60%的评测用例满足：n≤100。<br>　　所有评测用例都满足：1≤n≤1000，1≤m≤100,000，1≤ci≤10,000。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>最小生成树。前几年是真简单啊</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	edge(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> w):a(a),b(b),w(w)&#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge&amp; x) &#123;</span><br><span class="line">		<span class="keyword">return</span> w &lt; x.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Tree[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Tree[p] == <span class="number">-1</span>) <span class="keyword">return</span> p;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = findroot(Tree[p]);</span><br><span class="line">		Tree[p] = tmp;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">union_</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rp = findroot(p);</span><br><span class="line">	<span class="keyword">int</span> rq = findroot(q);</span><br><span class="line">	<span class="keyword">if</span> (rp != rq) &#123;</span><br><span class="line">		Tree[rq] = rp;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; g;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(Tree, <span class="number">-1</span>, <span class="keyword">sizeof</span>(Tree));</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">int</span> a, b, w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">		g.push_back(edge(a, b, w));</span><br><span class="line">	&#125;</span><br><span class="line">	sort(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a = g[i].a;</span><br><span class="line">		<span class="keyword">int</span> b = g[i].b;</span><br><span class="line">		<span class="keyword">int</span> w = g[i].w;</span><br><span class="line">		<span class="keyword">if</span> (union_(a, b)) &#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			ans += w;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201409-4</title>
    <url>/2020/03/02/201409-4/</url>
    <content><![CDATA[<h1 id="最优配餐"><a href="#最优配餐" class="headerlink" title="最优配餐"></a>最优配餐</h1><p><strong>问题描述</strong></p>
<p>　　栋栋最近开了一家餐饮连锁店，提供外卖服务。随着连锁店越来越多，怎么合理的给客户送餐成为了一个急需解决的问题。<br>　　栋栋的连锁店所在的区域可以看成是一个n×n的方格图（如下图所示），方格的格点上的位置上可能包含栋栋的分店（绿色标注）或者客户（蓝色标注），有一些格点是不能经过的（红色标注）。<br>　　方格图中的线表示可以行走的道路，相邻两个格点的距离为1。栋栋要送餐必须走可以行走的道路，而且不能经过红色标注的点。</p>
<p><img src="http://118.190.20.162/RequireFile.do?fid=383qHJjQ" alt="img"><br>　　送餐的主要成本体现在路上所花的时间，每一份餐每走一个单位的距离需要花费1块钱。每个客户的需求都可以由栋栋的任意分店配送，每个分店没有配送总量的限制。<br>　　现在你得到了栋栋的客户的需求，请问在最优的送餐方式下，送这些餐需要花费多大的成本。</p>
<p><strong>输入格式</strong></p>
<p>　　输入的第一行包含四个整数n, m, k, d，分别表示方格图的大小、栋栋的分店数量、客户的数量，以及不能经过的点的数量。<br>　　接下来m行，每行两个整数xi, yi，表示栋栋的一个分店在方格图中的横坐标和纵坐标。<br>　　接下来k行，每行三个整数xi, yi, ci，分别表示每个客户在方格图中的横坐标、纵坐标和订餐的量。（注意，可能有多个客户在方格图中的同一个位置）<br>　　接下来d行，每行两个整数，分别表示每个不能经过的点的横坐标和纵坐标。</p>
<p><strong>输出格式</strong></p>
<p>　　输出一个整数，表示最优送餐方式下所需要花费的成本。</p>
<p><strong>样例输入</strong></p>
<p>10 2 3 3<br>1 1<br>8 8<br>1 5 1<br>2 3 3<br>6 7 2<br>1 2<br>2 2<br>6 8</p>
<p><strong>样例输出</strong></p>
<p>29</p>
<p><strong>评测用例规模与约定</strong></p>
<p>　　前30%的评测用例满足：1&lt;=n &lt;=20。<br>　　前60%的评测用例满足：1&lt;=n&lt;=100。<br>　　所有评测用例都满足：1&lt;=n&lt;=1000，1&lt;=m, k, d&lt;=n^2。可能有多个客户在同一个格点上。每个客户的订餐量不超过1000，每个客户所需要的餐都能被送到。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>把每个分店看作一个起点。对图进行 bfs</li>
<li>由于是无权图，所以先到客户位置的一定是离他最近的分店。</li>
<li><strong>注意 结果可能会超过int的范围</strong></li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	ll <span class="built_in">step</span>;</span><br><span class="line">	node(<span class="keyword">int</span> x, <span class="keyword">int</span> y, ll <span class="built_in">step</span> = <span class="number">0</span>) :x(x), y(y), <span class="built_in">step</span>(<span class="built_in">step</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123; <span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line"><span class="keyword">int</span> goal[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, k, d;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(goal, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;k, &amp;d);</span><br><span class="line">	<span class="keyword">int</span> a, b,w;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">		q.push(node(a, b));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">		goal[a][b] += w;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">		vis[a][b] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		node u = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">if</span> (vis[u.x][u.y]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[u.x][u.y] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">step</span> = u.<span class="built_in">step</span>;</span><br><span class="line">		ans += goal[u.x][u.y] * <span class="built_in">step</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> newx = u.x + dx[i];</span><br><span class="line">			<span class="keyword">int</span> newy = u.y + dy[i];</span><br><span class="line">			<span class="keyword">if</span> (vis[newx][newy]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (newx&lt;<span class="number">1</span> || newx&gt;n || newy&lt;<span class="number">1</span> || newy&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">			q.push(node(newx, newy, <span class="built_in">step</span> + <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201509-4</title>
    <url>/2020/03/02/201509-4/</url>
    <content><![CDATA[<h1 id="高速公路"><a href="#高速公路" class="headerlink" title="高速公路"></a>高速公路</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　某国有<em>n</em>个城市，为了使得城市间的交通更便利，该国国王打算在城市之间修一些高速公路，由于经费限制，国王打算第一阶段先在部分城市之间修一些单向的高速公路。<br>　　现在，大臣们帮国王拟了一个修高速公路的计划。看了计划后，国王发现，有些城市之间可以通过高速公路直接（不经过其他城市）或间接（经过一个或多个其他城市）到达，而有的却不能。如果城市A可以通过高速公路到达城市B，而且城市B也可以通过高速公路到达城市A，则这两个城市被称为便利城市对。<br>　　国王想知道，在大臣们给他的计划中，有多少个便利城市对。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入的第一行包含两个整数<em>n</em>, <em>m</em>，分别表示城市和单向高速公路的数量。<br>　　接下来<em>m</em>行，每行两个整数<em>a</em>, <em>b</em>，表示城市<em>a</em>有一条单向的高速公路连向城市<em>b</em>。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出一行，包含一个整数，表示便利城市对的数量。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>5 5<br>1 2<br>2 3<br>3 4<br>4 2<br>3 5</p>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>3</p>
<h2 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h2><p><img src="http://118.190.20.162/RequireFile.do?fid=4HG9GgbF" alt="img"><br>　　城市间的连接如图所示。有3个便利城市对，它们分别是(2, 3), (2, 4), (3, 4)，请注意(2, 3)和(3, 2)看成同一个便利城市对。</p>
<h2 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>　　前30%的评测用例满足1 ≤ <em>n</em> ≤ 100, 1 ≤ <em>m</em> ≤ 1000；<br>　　前60%的评测用例满足1 ≤ <em>n</em> ≤ 1000, 1 ≤ <em>m</em> ≤ 10000；<br>　　所有评测用例满足1 ≤ <em>n</em> ≤ 10000, 1 ≤ <em>m</em> ≤ 100000。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>本题在求强连通分量数，使用Tarjan算法</li>
<li>关于tarjan算法<ol>
<li>大体思路是在深度搜索的过程中，给遍历到的结点一个编号，用dfn记录。</li>
<li>如果遍历过程中遍历到重复的点，说明出现了环。以low[i]记录第i个节点所在连通分量的根节点(取该连通分量中编号的最小值)</li>
<li>过程中用一个栈来记录形成环前所遍历的所有结点</li>
<li>走了一圈回来，仍能保持自身dfn==low的点即为该连通分量的根</li>
<li>学习用前向链表存图</li>
</ol>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 10000 + 5;</span><br><span class="line">int m, n;</span><br><span class="line">vector&lt;int&gt; g[maxn];</span><br><span class="line">bool instack[maxn];&#x2F;&#x2F;instack[i]表示i是否还在栈里</span><br><span class="line">int dfn[maxn];&#x2F;&#x2F;dfn[]表示是否被dfs过</span><br><span class="line">int low[maxn];&#x2F;&#x2F;该子树中，且仍在栈中的最小时间戳</span><br><span class="line">int clk &#x3D; 0;</span><br><span class="line">int ans &#x3D; 0;</span><br><span class="line">stack&lt;int&gt; s;</span><br><span class="line">void tarjan(int u) &#123;</span><br><span class="line">	low[u] &#x3D; dfn[u] &#x3D; ++clk;</span><br><span class="line">	s.push(u);</span><br><span class="line">	instack[u] &#x3D; 1;</span><br><span class="line">	for (int v : g[u]) &#123;</span><br><span class="line">		if (!dfn[v]) &#123;</span><br><span class="line">			tarjan(v);</span><br><span class="line">			low[u] &#x3D; min(low[u], low[v]);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (instack[v])</span><br><span class="line">			low[u] &#x3D; min(low[u], dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	if (low[u] &#x3D;&#x3D; dfn[u]) &#123;</span><br><span class="line">		int cnt &#x3D; 0;</span><br><span class="line">		while (1)</span><br><span class="line">		&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			int tp &#x3D; s.top(); s.pop();</span><br><span class="line">			instack[tp] &#x3D; 0;</span><br><span class="line">			if (tp &#x3D;&#x3D; u) break;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cnt &gt; 1) ans +&#x3D; cnt * (cnt - 1) &#x2F; 2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">	int a, b;</span><br><span class="line">	memset(dfn, 0, sizeof(dfn));</span><br><span class="line">	memset(instack, 0, sizeof(instack));</span><br><span class="line">	for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">		g[a].push_back(b);</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; ++i)</span><br><span class="line">		if (!dfn[i])</span><br><span class="line">			tarjan(i);</span><br><span class="line">	printf(&quot;%d&quot;, ans);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前向链表存图"><a href="#前向链表存图" class="headerlink" title="前向链表存图"></a>前向链表存图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct EDGE</span><br><span class="line">&#123;</span><br><span class="line">    int to;int next;int from;</span><br><span class="line">&#125;edge[maxn*10],ed[maxn*10];</span><br><span class="line">void add(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    edge[++sum].next&#x3D;head[x];</span><br><span class="line">    edge[sum].from&#x3D;x;</span><br><span class="line">    edge[sum].to&#x3D;y;</span><br><span class="line">    head[x]&#x3D;sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201503-4</title>
    <url>/2020/03/02/201503-4/</url>
    <content><![CDATA[<h1 id="网络延时"><a href="#网络延时" class="headerlink" title="网络延时"></a>网络延时</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　给定一个公司的网络，由<em>n</em>台交换机和<em>m</em>台终端电脑组成，交换机与交换机、交换机与电脑之间使用网络连接。交换机按层级设置，编号为1的交换机为根交换机，层级为1。其他的交换机都连接到一台比自己上一层的交换机上，其层级为对应交换机的层级加1。所有的终端电脑都直接连接到交换机上。<br>　　当信息在电脑、交换机之间传递时，每一步只能通过自己传递到自己所连接的另一台电脑或交换机。请问，电脑与电脑之间传递消息、或者电脑与交换机之间传递消息、或者交换机与交换机之间传递消息最多需要多少步。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入的第一行包含两个整数<em>n</em>, <em>m</em>，分别表示交换机的台数和终端电脑的台数。<br>　　第二行包含<em>n</em> - 1个整数，分别表示第2、3、……、<em>n</em>台交换机所连接的比自己上一层的交换机的编号。第<em>i</em>台交换机所连接的上一层的交换机编号一定比自己的编号小。<br>　　第三行包含<em>m</em>个整数，分别表示第1、2、……、<em>m</em>台终端电脑所连接的交换机的编号。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出一个整数，表示消息传递最多需要的步数。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>4 2<br>1 1 3<br>2 1</p>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>4</p>
<h2 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h2><p>　　样例的网络连接模式如下，其中圆圈表示交换机，方框表示电脑：<br><img src="http://118.190.20.162/RequireFile.do?fid=F9GfBRHL" alt="img"><br>　　其中电脑1与交换机4之间的消息传递花费的时间最长，为4个单位时间。</p>
<h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><p>4 4<br>1 2 2<br>3 4 4 4</p>
<h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><p>4</p>
<h2 id="样例说明-1"><a href="#样例说明-1" class="headerlink" title="样例说明"></a>样例说明</h2><p>　　样例的网络连接模式如下：<br><img src="http://118.190.20.162/RequireFile.do?fid=LYDFDEbt" alt="img"><br>　　其中电脑1与电脑4之间的消息传递花费的时间最长，为4个单位时间。</p>
<h2 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>　　前30%的评测用例满足：<em>n</em> ≤ 5, <em>m</em> ≤ 5。<br>　　前50%的评测用例满足：<em>n</em> ≤ 20, <em>m</em> ≤ 20。<br>　　前70%的评测用例满足：<em>n</em> ≤ 100, <em>m</em> ≤ 100。<br>　　所有评测用例都满足：1 ≤ <em>n</em> ≤ 10000，1 ≤ <em>m</em> ≤ 10000。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>本题要计算树中两点间的最大距离，<strong>即图的直径</strong></li>
<li>方法是，从任一点出发，用bfs或者dfs求得离该点最远的点，即为树的一个端点。再从这个端点出发，找离他最远的点，为另一个端点。两点间距离即为图的直径</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000</span> + <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> beg)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	q.push(beg);</span><br><span class="line">	dis[beg] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">			dis[v] = dis[u] + <span class="number">1</span>;</span><br><span class="line">			q.push(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> maxx = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> node = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dis[i] &gt; maxx) &#123;</span><br><span class="line">			maxx = dis[i];</span><br><span class="line">			node = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">		g[a].push_back(i);</span><br><span class="line">		g[i].push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">		g[a].push_back(n + i);</span><br><span class="line">		g[n + i].push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> n1 = bfs(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> n2 = bfs(n1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, dis[n2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201612-4</title>
    <url>/2020/02/25/201612-4/</url>
    <content><![CDATA[<h1 id="压缩编码"><a href="#压缩编码" class="headerlink" title="压缩编码"></a>压缩编码</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　给定一段文字，已知单词<em>a</em>1, <em>a</em>2, …, <em>an<em>出现的频率分别</em>t<em>1, *t</em>2, …, <em>tn</em>。可以用01串给这些单词编码，即将每个单词与一个01串对应，使得任何一个单词的编码（对应的01串）不是另一个单词编码的前缀，这种编码称为前缀码。<br> 　使用前缀码编码一段文字是指将这段文字中的每个单词依次对应到其编码。一段文字经过前缀编码后的长度为：<br> 　*L</em>=<em>a</em>1的编码长度×<em>t</em>1+<em>a</em>2的编码长度×<em>t</em>2+…+ <em>an<em>的编码长度×</em>tn*。<br> 　定义一个前缀编码为字典序编码，指对于1 ≤ *i</em> &lt; <em>n</em>，<em>ai<em>的编码（对应的01串）的字典序在</em>ai</em>+1编码之前，即<em>a</em>1, <em>a</em>2, …, <em>an</em>的编码是按字典序升序排列的。<br> 　例如，文字E A E C D E B C C E C B D B E中， 5个单词A、B、C、D、E出现的频率分别为1, 3, 4, 2,  5，则一种可行的编码方案是A:000, B:001, C:01, D:10,  E:11，对应的编码后的01串为1100011011011001010111010011000111，对应的长度<em>L</em>为3×1+3×3+2×4+2×2+2×5=34。<br> 　在这个例子中，如果使用哈夫曼(Huffman)编码，对应的编码方案是A:000, B:01, C:10, D:001, E:11，虽然最终文字编码后的总长度只有33，但是这个编码不满足字典序编码的性质，比如C的编码的字典序不在D的编码之前。<br> 　在这个例子中，有些人可能会想的另一个字典序编码是A:000, B:001, C:010, D:011, E:1，编码后的文字长度为35。<br> 　请找出一个字典序编码，使得文字经过编码后的长度<em>L</em>最小。在输出时，你只需要输出最小的长度<em>L</em>，而不需要输出具体的方案。在上面的例子中，最小的长度<em>L</em>为34。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入的第一行包含一个整数<em>n</em>，表示单词的数量。<br> 　第二行包含<em>n</em>个整数，用空格分隔，分别表示<em>a</em>1, <em>a</em>2, …, <em>an</em>出现的频率，即<em>t</em>1, <em>t</em>2, …, <em>tn</em>。请注意<em>a</em>1, <em>a</em>2, …, <em>an</em>具体是什么单词并不影响本题的解，所以没有输入<em>a</em>1, <em>a</em>2, …, <em>an</em>。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出一个整数，表示文字经过编码后的长度<em>L</em>的最小值。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>5<br> 1 3 4 2 5</p>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>34</p>
<h2 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h2><p>　　这个样例就是问题描述中的例子。如果你得到了35，说明你算得有问题，请自行检查自己的算法而不要怀疑是样例输出写错了。</p>
<p>评测用例规模与约定</p>
<p>　　对于30%的评测用例，1 ≤ <em>n</em> ≤ 10，1 ≤ <em>ti</em> ≤ 20；<br> 　对于60%的评测用例，1 ≤ <em>n</em> ≤ 100，1 ≤ <em>ti</em> ≤ 100；<br> 　对于100%的评测用例，1 ≤ <em>n</em> ≤ 1000，1 ≤ <em>ti</em> ≤ 10000。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>首先想到haffman，但是不能保证字典序。因此，不能取权重最小的两堆和并，而是要取相邻的两堆合并。</li>
<li>目标是选取相邻的两堆合在一起使得操作的花费最小，也就是石子问题</li>
<li>石子dp问题<ol>
<li>用dp[i][j]表示将第i堆和第j堆合并的最小花销。</li>
<li>设存在一个k，有dp[i][k]+dp[k+1][j]使得dp[i][j]取了最小值，那么p[i][j] = k</li>
<li>用sum[i]表示形成第i堆石子的花费</li>
</ol>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">const int inf &#x3D; 0x08080808;</span><br><span class="line">int sum[maxn];</span><br><span class="line">int p[maxn][maxn];</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line">int a[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	sum[0] &#x3D; 0;</span><br><span class="line">	memset(dp, inf, sizeof(dp));</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	sum[0] &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">		dp[i][i] &#x3D; 0;</span><br><span class="line">		p[i][i] &#x3D; i;</span><br><span class="line">		sum[i] &#x3D; sum[i - 1] + a[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int len &#x3D; 2; len &lt;&#x3D; n; len++) &#123;</span><br><span class="line">		for (int i &#x3D; 1; i + len - 1 &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			int j &#x3D; i + len - 1;</span><br><span class="line">			for (int k &#x3D; p[i][j - 1]; k &lt;&#x3D; p[i + 1][j]; ++k) &#123;</span><br><span class="line">				int val &#x3D; dp[i][k] + dp[k+1][j] + sum[j] - sum[i - 1];</span><br><span class="line">				if (dp[i][j] &gt; val) &#123;</span><br><span class="line">					dp[i][j] &#x3D; val;</span><br><span class="line">					p[i][j] &#x3D; k;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;%d&quot;, dp[1][n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201609-4</title>
    <url>/2020/02/25/201609-4/</url>
    <content><![CDATA[<h1 id="交通规划"><a href="#交通规划" class="headerlink" title="交通规划"></a>交通规划</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　G国国王来中国参观后，被中国的高速铁路深深的震撼，决定为自己的国家也建设一个高速铁路系统。<br> 　建设高速铁路投入非常大，为了节约建设成本，G国国王决定不新建铁路，而是将已有的铁路改造成高速铁路。现在，请你为G国国王提供一个方案，将现有的一部分铁路改造成高速铁路，使得任何两个城市间都可以通过高速铁路到达，而且从所有城市乘坐高速铁路到首都的最短路程和原来一样长。请你告诉G国国王在这些条件下最少要改造多长的铁路。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入的第一行包含两个整数<em>n</em>, <em>m</em>，分别表示G国城市的数量和城市间铁路的数量。所有的城市由1到<em>n</em>编号，首都为1号。<br> 　接下来<em>m</em>行，每行三个整数<em>a</em>, <em>b</em>, <em>c</em>，表示城市<em>a</em>和城市<em>b</em>之间有一条长度为<em>c</em>的双向铁路。这条铁路不会经过<em>a</em>和<em>b</em>以外的城市。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出一行，表示在满足条件的情况下最少要改造的铁路长度。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>4 5<br> 1 2 4<br> 1 3 5<br> 2 3 2<br> 2 4 3<br> 3 4 2</p>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>11</p>
<h2 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>　　对于20%的评测用例，1 ≤ <em>n</em> ≤ 10，1 ≤ <em>m</em> ≤ 50；<br> 　对于50%的评测用例，1 ≤ <em>n</em> ≤ 100，1 ≤ <em>m</em> ≤ 5000；<br> 　对于80%的评测用例，1 ≤ <em>n</em> ≤ 1000，1 ≤ <em>m</em> ≤ 50000；<br> 　对于100%的评测用例，1 ≤ <em>n</em> ≤ 10000，1 ≤ <em>m</em> ≤ 100000，1 ≤ <em>a</em>, <em>b</em> ≤ n，1 ≤ <em>c</em> ≤ 1000。输入保证每个城市都可以通过铁路达到首都。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>由于要保证最短路径不变，所以考虑使用dij来保证是最短路径</li>
<li>对于相同长度的路径，可以将这一步可能走的最小值记录在cost里</li>
<li>最后统计到所有点的cost的和</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 10000 + 5;</span><br><span class="line">struct edge &#123;</span><br><span class="line">	int to;</span><br><span class="line">	int w;</span><br><span class="line">	edge(int to, int w) :to(to), w(w) &#123;&#125;</span><br><span class="line">	bool operator &lt; (const edge &amp; a)const &#123;</span><br><span class="line">		return w &gt; a.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; g[maxn];</span><br><span class="line">int dis[maxn];</span><br><span class="line">int vis[maxn];</span><br><span class="line">int cost[maxn];</span><br><span class="line">void dij() &#123;</span><br><span class="line">	memset(dis, -1, sizeof(dis));</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	memset(cost, -1, sizeof(cost));</span><br><span class="line">	edge beg(1, 0);</span><br><span class="line">	dis[1] &#x3D; 0;</span><br><span class="line">	cost[1] &#x3D; 0;</span><br><span class="line">	priority_queue&lt;edge&gt; pq;</span><br><span class="line">	pq.push(beg);</span><br><span class="line">	while (!pq.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		edge x &#x3D; pq.top(); pq.pop();</span><br><span class="line">		int u &#x3D; x.to;</span><br><span class="line">		if (vis[u]) continue;</span><br><span class="line">		vis[u] &#x3D; 1;</span><br><span class="line">		for (edge y : g[u]) &#123;</span><br><span class="line">			int v &#x3D; y.to;</span><br><span class="line">			if (vis[v]) continue;</span><br><span class="line">			if (dis[v] &#x3D;&#x3D; -1 || dis[v] &gt; dis[u] + y.w)</span><br><span class="line">				dis[v] &#x3D; dis[u] + y.w;</span><br><span class="line">			if (cost[v] &#x3D;&#x3D; -1 || (dis[v] &#x3D;&#x3D; dis[u] + y.w&amp;&amp;cost[v] &gt; y.w))</span><br><span class="line">				cost[v] &#x3D; y.w;</span><br><span class="line">			pq.push(edge(v, dis[v]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">	int a, b, w;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;w);</span><br><span class="line">		g[a].push_back(edge(b, w));</span><br><span class="line">		g[b].push_back(edge(a, w));</span><br><span class="line">	&#125;</span><br><span class="line">	dij();</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">		ans +&#x3D; cost[i];</span><br><span class="line">	printf(&quot;%d&quot;, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201909-4</title>
    <url>/2020/02/25/201909-4/</url>
    <content><![CDATA[<h1 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h1><p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5Cccf%5Cccf_img%5C1.png" alt=""></p>
<p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5Cccf%5Cccf_img%5C2.png" alt=""></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>主要问题在于按照三种属性排序会导致超时，所以疯狂的空间换时间，才勉强通过。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">int limit[55];</span><br><span class="line">#define rint register int</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">	int id;</span><br><span class="line">	int type;</span><br><span class="line">	node(int type, int id) :type(type), id(id) &#123;&#125;</span><br><span class="line">	bool operator &lt; (const node&amp;a) const &#123;</span><br><span class="line">		return type &lt; a.type || type &#x3D;&#x3D; a.type&amp;&amp;id &lt; a.id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;int, set&lt;node&gt;, greater&lt;int&gt;&gt; a;</span><br><span class="line">map&lt;node, int&gt; lab;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;&#x2F;&#x2F;m类商品</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;m, &amp;n);</span><br><span class="line">	int id, score;</span><br><span class="line">	for (rint i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;id, &amp;score);</span><br><span class="line">		for (rint j &#x3D; 0; j &lt; m; j++) &#123;</span><br><span class="line">			a[score].insert(node(j, id));</span><br><span class="line">			lab[node(j, id)] &#x3D; score;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int opnum;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;opnum);</span><br><span class="line">	int op;</span><br><span class="line">	int type, comm;</span><br><span class="line">	for (rint iii &#x3D; 0; iii &lt; opnum; iii++) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;op);</span><br><span class="line"></span><br><span class="line">		if (op &#x3D;&#x3D; 1) &#123;</span><br><span class="line">			</span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;type, &amp;comm, &amp;score);</span><br><span class="line">			a[score].insert(node(type, comm));</span><br><span class="line">			lab[node(type, comm)] &#x3D; score;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (op &#x3D;&#x3D; 2) &#123;</span><br><span class="line">			</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;type, &amp;comm);</span><br><span class="line">			node label &#x3D; node(type, comm);</span><br><span class="line">			score &#x3D; lab[label];</span><br><span class="line">			a[score].erase(node(type, comm));</span><br><span class="line">			lab.erase(label);</span><br><span class="line">			if (a[score].empty()) </span><br><span class="line">				a.erase(score);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		else if (op &#x3D;&#x3D; 3) &#123;</span><br><span class="line">			int maxt;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;maxt);</span><br><span class="line">			for (rint j &#x3D; 0; j &lt; m; ++j)</span><br><span class="line">				scanf(&quot;%d&quot;, &amp;limit[j]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			vector&lt;vector&lt;int&gt;&gt; top(m);</span><br><span class="line">			for (auto i &#x3D; a.begin(); i !&#x3D; a.end() &amp;&amp; maxt &gt; 0; ++i) &#123;</span><br><span class="line">				for (auto j &#x3D; i-&gt;second.begin(); j !&#x3D; i-&gt;second.end() &amp;&amp; maxt &gt; 0; ++j) &#123;</span><br><span class="line">					if (limit[j-&gt;type] &lt;&#x3D; 0)  continue;</span><br><span class="line">					--limit[j-&gt;type];</span><br><span class="line">					top[j-&gt;type].push_back(j-&gt;id);</span><br><span class="line">					--maxt;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			for (rint i &#x3D; 0; i &lt; m; ++i) &#123;</span><br><span class="line">				if (top[i].empty()) printf(&quot;-1\n&quot;);</span><br><span class="line">				else &#123;</span><br><span class="line">					for (rint j &#x3D; 0; j &lt; top[i].size(); ++j) &#123;</span><br><span class="line">						printf(&quot;%d &quot;, top[i][j]);</span><br><span class="line">					&#125;</span><br><span class="line">					printf(&quot;\n&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201903-4</title>
    <url>/2020/02/25/201903-4/</url>
    <content><![CDATA[<h1 id="消息传递接口"><a href="#消息传递接口" class="headerlink" title="消息传递接口"></a>消息传递接口</h1><p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5Cccf%5Cccf_img%5C5.png" alt=""></p>
<p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5Cccf%5Cccf_img%5C6.png" alt=""></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>直接用队列会超时，所以用数组模拟队列，以beg[i]记录第i个程序下一步应该执行的指令，以over[i]表示第i个程序的最后一条指令。</li>
<li>主要过程是遍历所有程序，依次尝试出队，如果能对应上，才真正出队。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 10000 + 5;</span><br><span class="line">int T, n;</span><br><span class="line">struct opt &#123;</span><br><span class="line">	char op;</span><br><span class="line">	int n;</span><br><span class="line">&#125;;</span><br><span class="line">opt oper[maxn][9];</span><br><span class="line">int beg[maxn];</span><br><span class="line">int over[maxn];</span><br><span class="line">bool front(int id, opt &amp;x) &#123;</span><br><span class="line">	int a &#x3D; beg[id];</span><br><span class="line">	int b &#x3D; over[id];</span><br><span class="line">	if (a &gt;&#x3D; b)  return false;</span><br><span class="line">	x &#x3D; oper[id][a];</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">int vis[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;T, &amp;n);</span><br><span class="line">	getchar();</span><br><span class="line">	string line;</span><br><span class="line">	opt t;</span><br><span class="line"></span><br><span class="line">	int ed;</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			ed &#x3D; 0;</span><br><span class="line">			getline(cin, line);</span><br><span class="line">			stringstream ss(line);</span><br><span class="line">			while (ss &gt;&gt; t.op) &#123;</span><br><span class="line">				ss &gt;&gt; t.n;</span><br><span class="line">				oper[i][ed++] &#x3D; t;</span><br><span class="line">			&#125;</span><br><span class="line">			beg[i] &#x3D; 0;</span><br><span class="line">			over[i] &#x3D; ed;</span><br><span class="line">		&#125;</span><br><span class="line">		bool flag;</span><br><span class="line">		int done &#x3D; 0;</span><br><span class="line">		do</span><br><span class="line">		&#123;</span><br><span class="line">			flag &#x3D; false;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">				opt a, b;</span><br><span class="line">				if (!front(i, a)) &#123;</span><br><span class="line">					if (!vis[i]) &#123;</span><br><span class="line">						done++;</span><br><span class="line">						vis[i] &#x3D; 1;</span><br><span class="line">					&#125;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">				int x &#x3D; a.n;</span><br><span class="line">				if (!front(x, b)) break;</span><br><span class="line">				if (b.n !&#x3D; i) continue;</span><br><span class="line">				if (a.op &#x3D;&#x3D; b.op) continue;</span><br><span class="line">				beg[i]++;</span><br><span class="line">				beg[x]++;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; while (flag);</span><br><span class="line">		if (flag || done &#x3D;&#x3D; n) printf(&quot;0\n&quot;);</span><br><span class="line">		else printf(&quot;1\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201903-3</title>
    <url>/2020/02/25/201903-3/</url>
    <content><![CDATA[<h1 id="损坏的RAID5"><a href="#损坏的RAID5" class="headerlink" title="损坏的RAID5"></a>损坏的RAID5</h1><p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5Cccf%5Cccf_img%5C3.png" alt=""></p>
<p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5Cccf%5Cccf_img%5C4.png" alt=""></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>本题的关键在于推出第x行j列的磁盘编号是 disk = (n - k % (n + 1) + y % n + 1) % (n + 1) </p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int N &#x3D; 1e3 + 7;</span><br><span class="line">const string base &#x3D; &quot;0123456789ABCDEF&quot;;</span><br><span class="line">string dt[N];</span><br><span class="line">int n, s, l, max_k;</span><br><span class="line">int to_int(char ch) &#123;</span><br><span class="line">	if (ch &gt;&#x3D; &#39;0&#39; &amp;&amp; ch &lt;&#x3D; &#39;9&#39;) return ch - &#39;0&#39;;</span><br><span class="line">	else  return ch - &#39;A&#39; + 10;</span><br><span class="line">&#125;</span><br><span class="line">void _xor(string&amp; ans, string str) &#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; str.size(); i++) &#123;</span><br><span class="line">		int x &#x3D; to_int(ans[i]);</span><br><span class="line">		int y &#x3D; to_int(str[i]);</span><br><span class="line">		ans[i] &#x3D; base[(x ^ y)];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">string get_xor(int disk, int _start) &#123;</span><br><span class="line">	string ans(8, &#39;0&#39;);</span><br><span class="line">	for (int i &#x3D; 0; i &lt;&#x3D; n; i++)</span><br><span class="line">		if (i !&#x3D; disk)</span><br><span class="line">			_xor(ans, dt[i].substr(_start, 8));</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios::sync_with_stdio(false);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; s &gt;&gt; l;</span><br><span class="line">	n -&#x3D; 1; &#x2F;&#x2F; (n块数据,1块冗余)</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; l; i++) &#123;</span><br><span class="line">		int id;</span><br><span class="line">		cin &gt;&gt; id;</span><br><span class="line">		cin &gt;&gt; dt[id];</span><br><span class="line">		&#x2F;&#x2F; cin&gt;&gt;id&gt;&gt;dt[id]; 这样不知道为啥错误</span><br><span class="line">		max_k &#x3D; dt[id].size() &#x2F; 8 &#x2F; s;</span><br><span class="line">	&#125;</span><br><span class="line">	int m; cin &gt;&gt; m;</span><br><span class="line">	while (m--) &#123;</span><br><span class="line">		int x; cin &gt;&gt; x;</span><br><span class="line">		int y &#x3D; x &#x2F; s;</span><br><span class="line">		int k &#x3D; y &#x2F; n;</span><br><span class="line">		int disk &#x3D; (n - k % (n + 1) + y % n + 1) % (n + 1);</span><br><span class="line">		if (k &gt;&#x3D; max_k) cout &lt;&lt; &quot;-\n&quot;;</span><br><span class="line">		else  if (dt[disk].size() !&#x3D; 0) &#123;</span><br><span class="line">			int _start &#x3D; 8 * (k * s + x % s);</span><br><span class="line">			cout &lt;&lt; dt[disk].substr(_start, 8) &lt;&lt; &quot;\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (dt[disk].size() &#x3D;&#x3D; 0 &amp;&amp; l &#x3D;&#x3D; n) &#123;</span><br><span class="line">			int _start &#x3D; 8 * (k * s + x % s);</span><br><span class="line">			cout &lt;&lt; get_xor(disk, _start) &lt;&lt; &quot;\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		else  cout &lt;&lt; &quot;-\n&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201812-4</title>
    <url>/2020/02/25/201812-4/</url>
    <content><![CDATA[<h1 id="数据中心"><a href="#数据中心" class="headerlink" title="数据中心"></a>数据中心</h1><p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5Cccf%5Cccf_img%5C7.png" alt=""></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>典型的 最小生成树问题，采用kruskal算法，保留所有生成边中的最大值</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100000 + 5;</span><br><span class="line">struct edge &#123;</span><br><span class="line">	int a,b;</span><br><span class="line">	int w;</span><br><span class="line">	bool operator &lt; (const edge &amp;a) const &#123; return w &lt; a.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">edge g[maxn];</span><br><span class="line">int Tree[maxn];</span><br><span class="line">int ans;</span><br><span class="line">int root(int p) &#123;</span><br><span class="line">	if (Tree[p] &#x3D;&#x3D; -1) return p;</span><br><span class="line">	else &#123;</span><br><span class="line">		int tmp &#x3D; root(Tree[p]);</span><br><span class="line">		Tree[p] &#x3D; tmp;</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">inline bool union_(int p,int q)&#123;</span><br><span class="line">	int rp &#x3D; root(p);</span><br><span class="line">	int rq &#x3D; root(q);</span><br><span class="line">	if (rp &#x3D;&#x3D; rq) return false;</span><br><span class="line">	Tree[rq] &#x3D; rp;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	int beg;</span><br><span class="line">	ans &#x3D; 0;</span><br><span class="line">	memset(Tree, -1, sizeof(Tree));</span><br><span class="line">	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;beg);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, &amp;g[i].a, &amp;g[i].b, &amp;g[i].w);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(g, g + m);</span><br><span class="line">	int bian &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">		int a &#x3D; g[i].a;</span><br><span class="line">		int b &#x3D; g[i].b;</span><br><span class="line">		if (union_(a, b)) &#123;</span><br><span class="line">			bian++;</span><br><span class="line">			if (ans &lt; g[i].w)</span><br><span class="line">				ans &#x3D; g[i].w;</span><br><span class="line">			if (bian &#x3D;&#x3D; n - 1) break;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d&quot;,ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201803-4</title>
    <url>/2020/02/25/201803-4/</url>
    <content><![CDATA[<h1 id="棋局评估"><a href="#棋局评估" class="headerlink" title="棋局评估"></a>棋局评估</h1><p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5Cccf%5Cccf_img%5C8.png" alt=""></p>
<p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5Cccf%5Cccf_img%5C9.png" alt=""></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>这是一个博弈论问题，一方想要让得分尽可能高，另一方想要令得分尽可能低（因为是负的）</li>
<li>以dfs(t)表示每一步棋，t=1或2.当t=1时，返回局面的最大值，当t=2时，返回局面的最小值。每下一步，就要判断是否因为走了这一步赢得比赛。如果赢了，则return；否则换手走下一步</li>
<li>注意判断初始情况是否已经结束</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 3;</span><br><span class="line">int g[maxn][maxn];</span><br><span class="line">int anst;</span><br><span class="line">inline int count() &#123;</span><br><span class="line">	int cnt &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; maxn; i++)</span><br><span class="line">		for (int j &#x3D; 0; j &lt; maxn; j++)</span><br><span class="line">			if (g[i][j] &#x3D;&#x3D; 0)</span><br><span class="line">				cnt++;</span><br><span class="line">	return cnt;</span><br><span class="line">&#125;</span><br><span class="line">inline int is_over(int i, int j, int t) &#123;</span><br><span class="line">	bool flag &#x3D; false;</span><br><span class="line">	if (g[0][j] &#x3D;&#x3D; t &amp;&amp; g[1][j] &#x3D;&#x3D; t &amp;&amp; g[2][j] &#x3D;&#x3D; t)</span><br><span class="line">		flag &#x3D; true;</span><br><span class="line">	if (g[i][0] &#x3D;&#x3D; t &amp;&amp; g[i][1] &#x3D;&#x3D; t &amp;&amp; g[i][2] &#x3D;&#x3D; t) flag &#x3D; true;</span><br><span class="line">	if (g[0][0] &#x3D;&#x3D; t &amp;&amp; g[1][1] &#x3D;&#x3D; t &amp;&amp; g[2][2] &#x3D;&#x3D; t) flag &#x3D; true;</span><br><span class="line">	if (g[0][2] &#x3D;&#x3D; t &amp;&amp; g[1][1] &#x3D;&#x3D; t &amp;&amp; g[2][0] &#x3D;&#x3D; t) flag &#x3D; true;</span><br><span class="line">	if (flag)</span><br><span class="line">		if (t &#x3D;&#x3D; 1)</span><br><span class="line">			return count() + 1;</span><br><span class="line">		else</span><br><span class="line">			return -(count() + 1);</span><br><span class="line">	else return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dfs(int t) &#123;</span><br><span class="line">	if (count() &#x3D;&#x3D; 0) return 0;</span><br><span class="line">	int maxx &#x3D; -10, minn &#x3D; 10;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 3; i++)</span><br><span class="line">		for (int j &#x3D; 0; j &lt; 3; j++) &#123;</span><br><span class="line">			if (g[i][j] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				g[i][j] &#x3D; t;</span><br><span class="line">				int w &#x3D; is_over(i, j, t);</span><br><span class="line">				if (w) &#123;&#x2F;&#x2F;因为这一步赢了，则返回</span><br><span class="line">						g[i][j] &#x3D; 0;</span><br><span class="line">						return t &#x3D;&#x3D; 1 ? max(maxx, w) : min(minn, w);</span><br><span class="line">				&#125;</span><br><span class="line">				if (t &#x3D;&#x3D; 1) maxx &#x3D; max(dfs(2), maxx);</span><br><span class="line">				else  minn &#x3D; min(dfs(1), minn);</span><br><span class="line">				g[i][j] &#x3D; 0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	return t &#x3D;&#x3D; 1 ? maxx : minn;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 3; i++)</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 3; j++)</span><br><span class="line">				scanf(&quot;%d&quot;, &amp;g[i][j]);</span><br><span class="line">		bool flag &#x3D; false;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 3; i++)</span><br><span class="line">			if (is_over(i, i, 1)) &#123;</span><br><span class="line">				anst &#x3D; 1;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		if (!flag)</span><br><span class="line">			for (int i &#x3D; 0; i &lt; 3; i++)</span><br><span class="line">				if (is_over(i, i, 2)) &#123;</span><br><span class="line">					anst &#x3D; 2;</span><br><span class="line">					flag &#x3D; true;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">		if (flag) &#123;</span><br><span class="line">			if (anst &#x3D;&#x3D; 2) printf(&quot;-&quot;);</span><br><span class="line">			printf(&quot;%d\n&quot;, count()+1);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			printf(&quot;%d\n&quot;, dfs(1));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201803-3</title>
    <url>/2020/02/25/201803-3/</url>
    <content><![CDATA[<h1 id="URL映射"><a href="#URL映射" class="headerlink" title="URL映射"></a>URL映射</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　URL 映射是诸如 Django、Ruby on Rails 等网页框架 (web frameworks) 的一个重要组件。对于从浏览器发来的 HTTP 请求，URL  映射模块会解析请求中的 URL 地址，并将其分派给相应的处理代码。现在，请你来实现一个简单的 URL 映射功能。<br> 　本题中 URL 映射功能的配置由若干条 URL 映射规则组成。当一个请求到达时，URL 映射功能会将请求中的 URL  地址按照配置的先后顺序逐一与这些规则进行匹配。当遇到第一条完全匹配的规则时，匹配成功，得到匹配的规则以及匹配的参数。若不能匹配任何一条规则，则匹配失败。<br> 　本题输入的 URL 地址是以斜杠 / 作为分隔符的路径，保证以斜杠开头。其他合法字符还包括大小写英文字母、阿拉伯数字、减号 -、下划线 _  和小数点 .。例如，/person/123/ 是一个合法的 URL 地址，而 /person/123? 则不合法（存在不合法的字符问号  ?）。另外，英文字母区分大小写，因此 /case/ 和 /CAse/ 是不同的 URL 地址。<br> 　对于 URL 映射规则，同样是以斜杠开始。除了可以是正常的 URL 地址外，还可以包含参数，有以下 3 种：<br> 　字符串 <str>：用于匹配一段字符串，注意字符串里不能包含斜杠。例如，abcde0123。<br> 　整数 <int>：用于匹配一个不带符号的整数，全部由阿拉伯数字组成。例如，01234。<br> 　路径 <path>：用于匹配一段字符串，字符串可以包含斜杠。例如，abcd/0123/。<br> 　以上 3 种参数都必须匹配非空的字符串。简便起见，题目规定规则中 <str> 和 <int>  前面一定是斜杠，后面要么是斜杠，要么是规则的结束（也就是该参数是规则的最后一部分）。而 <path>  的前面一定是斜杠，后面一定是规则的结束。无论是 URL 地址还是规则，都不会出现连续的斜杠。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入第一行是两个正整数 <em>n</em> 和 <em>m</em>，分别表示 URL 映射的规则条数和待处理的 URL 地址个数，中间用一个空格字符分隔。<br> 　第 2 行至第 <em>n</em>+1 行按匹配的先后顺序描述 URL 映射规则的配置信息。第 <em>i</em>+1 行包含两个字符串 <em>pi</em> 和 <em>ri*，其中 *pi</em> 表示 URL 匹配的规则，<em>ri</em> 表示这条 URL 匹配的名字。两个字符串都非空，且不包含空格字符，两者中间用一个空格字符分隔。<br> 　第 <em>n</em>+2 行至第 <em>n</em>+<em>m</em>+1 行描述待处理的 URL 地址。第 <em>n</em>+1+<em>i</em> 行包含一个字符串 <em>qi</em>，表示待处理的 URL 地址，字符串中不包含空格字符。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输入共 <em>m</em> 行，第 <em>i</em> 行表示 <em>qi</em> 的匹配结果。如果匹配成功，设匹配了规则 <em>pj</em> ，则输出对应的 <em>rj</em>。同时，如果规则中有参数，则在同一行内依次输出匹配后的参数。注意整数参数输出时要把前导零去掉。相邻两项之间用一个空格字符分隔。如果匹配失败，则输出 404。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>5 4<br> /articles/2003/ special_case_2003<br> /articles/<int>/ year_archive<br> /articles/<int>/<int>/ month_archive<br> /articles/<int>/<int>/<str>/ article_detail<br> /static/<path> static_serve<br> /articles/2004/<br> /articles/1985/09/aloha/<br> /articles/hello/<br> /static/js/jquery.js</p>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>year_archive 2004<br> article_detail 1985 9 aloha<br> 404<br> static_serve js/jquery.js</p>
<h2 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h2><p>　　对于第 1 个地址 /articles/2004/，无法匹配第 1 条规则，可以匹配第 2 条规则，参数为 2004。<br> 　对于第 2 个地址 /articles/1985/09/aloha/，只能匹配第 4 条规则，参数依次为 1985、9（已经去掉前导零）和 aloha。<br> 　对于第 3 个地址 /articles/hello/，无法匹配任何一条规则。<br> 　对于第 4 个地址 /static/js/jquery.js，可以匹配最后一条规则，参数为 js/jquery.js。</p>
<h2 id="数据规模和约定"><a href="#数据规模和约定" class="headerlink" title="数据规模和约定"></a>数据规模和约定</h2><p>　　1 ≤ <em>n</em> ≤ 100，1 ≤ <em>m</em> ≤ 100。<br> 　所有输入行的长度不超过 100 个字符（不包含换行符）。<br> 　保证输入的规则都是合法的。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>疯狂拆分字符串即可</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">string get_in;</span><br><span class="line">map&lt;string, vector&lt;string&gt;&gt; dir;</span><br><span class="line">vector&lt;string&gt; cmp;</span><br><span class="line">vector&lt;string&gt; ans;</span><br><span class="line">void turn(string s) &#123;</span><br><span class="line">	int nn &#x3D; s.find(&#39; &#39;);</span><br><span class="line">	string  name &#x3D; s.substr(nn + 1);</span><br><span class="line">	s &#x3D; s.substr(0, nn+1);</span><br><span class="line">	s &#x3D; s.substr(1);</span><br><span class="line">	int pos &#x3D; 0;</span><br><span class="line">	vector&lt;string&gt; tmp;</span><br><span class="line">	while ((pos &#x3D; s.find(&#39;&#x2F;&#39;)) !&#x3D; -1 || (pos &#x3D; s.find(&#39; &#39;)) !&#x3D; -1) &#123;</span><br><span class="line">		if (pos)</span><br><span class="line">			tmp.push_back(s.substr(0, pos));</span><br><span class="line">		s &#x3D; s.substr(pos + 1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dir[name] &#x3D; tmp;</span><br><span class="line">&#125;</span><br><span class="line">void turn_1(string s) &#123;</span><br><span class="line">	if (s[s.length() - 1] !&#x3D; &#39;&#x2F;&#39;)s +&#x3D; &quot;&#x2F;&quot;;</span><br><span class="line">	s &#x3D; s.substr(1);</span><br><span class="line">	int pos &#x3D; 0;</span><br><span class="line">	cmp.clear();</span><br><span class="line">	while ((pos &#x3D; s.find(&#39;&#x2F;&#39;)) !&#x3D; -1) &#123;</span><br><span class="line">		cmp.push_back(s.substr(0, pos));</span><br><span class="line">		s &#x3D; s.substr(pos + 1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool dig(string s) &#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; s.length(); i++) </span><br><span class="line">		if (!isdigit(s[i])) return false;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">bool alp(string s) &#123;</span><br><span class="line">	int len &#x3D; s.length();</span><br><span class="line">	for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (s[i] &gt;&#x3D; &#39;A&#39;&amp;&amp;s[i] &lt;&#x3D; &#39;Z&#39;) continue;</span><br><span class="line">		else if (s[i] &gt;&#x3D; &#39;a&#39;&amp;&amp;s[i] &lt;&#x3D; &#39;z&#39;) continue;</span><br><span class="line">		else if (s[i] &gt;&#x3D; &#39;0&#39;&amp;&amp;s[i] &lt;&#x3D; &#39;9&#39;) continue;</span><br><span class="line">		else if (s[i] &#x3D;&#x3D; &#39;-&#39; || s[i] &#x3D;&#x3D; &#39;.&#39; || s[i] &#x3D;&#x3D; &#39;_&#39;) continue;</span><br><span class="line">		else if (s[i] &#x3D;&#x3D; &#39;&#x2F;&#39;) continue;</span><br><span class="line">		else return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">bool compare() &#123;</span><br><span class="line">	for (auto i &#x3D; dir.begin(); i !&#x3D; dir.end(); i++) &#123;</span><br><span class="line">		int now &#x3D; 0;</span><br><span class="line">		vector&lt;string&gt; c &#x3D; i-&gt;second;</span><br><span class="line">		int j;</span><br><span class="line">		for (j &#x3D; 0; j &lt; c.size() &amp;&amp; now &lt; cmp.size(); j++) &#123;</span><br><span class="line">			if (cmp[now] &#x3D;&#x3D; c[j]) &#123; now++; continue; &#125;</span><br><span class="line">			else if (c[j] &#x3D;&#x3D; &quot;&lt;int&gt;&quot;&amp;&amp;dig(cmp[now])) &#123; ans.push_back(cmp[now]); now++; continue; &#125;</span><br><span class="line">			else if (c[j] &#x3D;&#x3D; &quot;&lt;str&gt;&quot;&amp;&amp;alp(cmp[now])) &#123; ans.push_back(cmp[now]); now++; continue; &#125;</span><br><span class="line">			else if (c[j] &#x3D;&#x3D; &quot;&lt;path&gt;&quot;) &#123;</span><br><span class="line">				if (!now)</span><br><span class="line">					ans.push_back(get_in);</span><br><span class="line"></span><br><span class="line">				else &#123;</span><br><span class="line">					int p &#x3D; get_in.find(cmp[now - 1]);</span><br><span class="line">					ans.push_back(get_in.substr(p + cmp[now - 1].length() + 1));</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				cout &lt;&lt; i-&gt;first;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				now &#x3D; 0;</span><br><span class="line">				ans.clear();</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (now &#x3D;&#x3D; cmp.size() &amp;&amp; j &#x3D;&#x3D; c.size()) &#123;</span><br><span class="line">			cout &lt;&lt; i-&gt;first;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		ans.clear();</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	int n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	string s;</span><br><span class="line">	getline(cin, s);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		getline(cin, s);</span><br><span class="line">		turn(s);</span><br><span class="line">	&#125;</span><br><span class="line">	for (int j &#x3D; 0; j &lt; m; j++) &#123;</span><br><span class="line">		getline(cin, get_in);</span><br><span class="line">		turn_1(get_in);</span><br><span class="line">		bool flag &#x3D; compare();</span><br><span class="line">		if (!ans.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			for (int k &#x3D; 0; k &lt; ans.size(); k++)</span><br><span class="line">			&#123;</span><br><span class="line">				if (dig(ans[k])) &#123;</span><br><span class="line">					if (ans[k] &#x3D;&#x3D; &quot;0&quot;) &#123;</span><br><span class="line">						cout &lt;&lt; &quot; 0&quot;;</span><br><span class="line">						continue;</span><br><span class="line">					&#125;</span><br><span class="line">					int kk;</span><br><span class="line">					for (kk &#x3D; 0; kk &lt; ans[k].size() &amp;&amp; ans[k][kk] &#x3D;&#x3D; &#39;0&#39;; kk++);</span><br><span class="line">					cout &lt;&lt; &quot; &quot; &lt;&lt; ans[k].substr(kk);</span><br><span class="line">				&#125;</span><br><span class="line">				else cout &lt;&lt; &quot; &quot; &lt;&lt; ans[k];</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">			ans.clear();</span><br><span class="line">		&#125;</span><br><span class="line">		else if (!flag) cout &lt;&lt; &quot;404&quot; &lt;&lt; endl;</span><br><span class="line">		else cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201712-4</title>
    <url>/2020/02/25/201712-4/</url>
    <content><![CDATA[<h1 id="行车路线"><a href="#行车路线" class="headerlink" title="行车路线"></a>行车路线</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　小明和小芳出去乡村玩，小明负责开车，小芳来导航。<br> 　小芳将可能的道路分为大道和小道。大道比较好走，每走1公里小明会增加1的疲劳度。小道不好走，如果连续走小道，小明的疲劳值会快速增加，连续走<em>s</em>公里小明会增加<em>s</em>2的疲劳度。<br> 　例如：有5个路口，1号路口到2号路口为小道，2号路口到3号路口为小道，3号路口到4号路口为大道，4号路口到5号路口为小道，相邻路口之间的距离都是2公里。如果小明从1号路口到5号路口，则总疲劳值为(2+2)2+2+22=16+2+4=22。<br> 　现在小芳拿到了地图，请帮助她规划一个开车的路线，使得按这个路线开车小明的疲劳度最小。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入的第一行包含两个整数<em>n</em>, <em>m</em>，分别表示路口的数量和道路的数量。路口由1至<em>n</em>编号，小明需要开车从1号路口到<em>n</em>号路口。<br> 　接下来<em>m</em>行描述道路，每行包含四个整数<em>t</em>, <em>a</em>, <em>b</em>, <em>c</em>，表示一条类型为<em>t</em>，连接<em>a</em>与<em>b</em>两个路口，长度为<em>c</em>公里的双向道路。其中<em>t</em>为0表示大道，<em>t</em>为1表示小道。保证1号路口和<em>n</em>号路口是连通的。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出一个整数，表示最优路线下小明的疲劳度。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>6 7<br> 1 1 2 3<br> 1 2 3 2<br> 0 1 3 30<br> 0 3 4 20<br> 0 4 5 30<br> 1 3 5 6<br> 1 5 6 1</p>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>76</p>
<h2 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h2><p>　　从1走小道到2，再走小道到3，疲劳度为52=25；然后从3走大道经过4到达5，疲劳度为20+30=50；最后从5走小道到6，疲劳度为1。总共为76。</p>
<h2 id="数据规模和约定"><a href="#数据规模和约定" class="headerlink" title="数据规模和约定"></a>数据规模和约定</h2><p>　　对于30%的评测用例，1 ≤ <em>n</em> ≤ 8，1 ≤ <em>m</em> ≤ 10；<br> 　对于另外20%的评测用例，不存在小道；<br> 　对于另外20%的评测用例，所有的小道不相交；<br> 　对于所有评测用例，1 ≤ <em>n</em> ≤ 500，1 ≤ <em>m</em> ≤ 105，1 ≤ <em>a</em>, <em>b</em> ≤ <em>n</em>，<em>t</em>是0或1，<em>c</em> ≤ 105。保证答案不超过106。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>基本思路是dij算法，由于小路的存在，花费的计算需要特殊处理</li>
<li>结构体中xw表示目前累计的小路的疲劳值，如果xw不为0<ol>
<li>如果接下来要走的也是小路，那么(a+b+c)<sup>2</sup> = ((a+b)<sup>2</sup>)<sup>2</sup>+c<sup>2</sup>+2(a+b)c</li>
<li>如果接下来要走的是大路，那么xw=0</li>
</ol>
</li>
<li>由于小路的疲劳值有累积效应，所以相同疲劳值而沿着大路和小路到达同一地点也不是一个情况。因此vis和dis都是二维的</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 500 + 5;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int to;</span><br><span class="line">	int w;</span><br><span class="line">	int t;</span><br><span class="line">	int xw;</span><br><span class="line">	node(int to, int w, int t, int xw &#x3D; 0) :to(to), w(w), t(t), xw(xw) &#123;&#125;</span><br><span class="line">	bool operator &lt; (const node&amp;a) const &#123; return w &gt; a.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt; g[maxn];</span><br><span class="line">int bfs();</span><br><span class="line">int n, m;</span><br><span class="line">int main() &#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">	int t, a, b, w;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d%d%d&quot;, &amp;t, &amp;a, &amp;b, &amp;w);</span><br><span class="line">		g[a].push_back(node(b, w, t));</span><br><span class="line">		g[b].push_back(node(a, w, t));</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d&quot;, bfs());</span><br><span class="line">&#125;</span><br><span class="line">int vis[maxn][2];</span><br><span class="line">int dis[maxn][2];</span><br><span class="line">int bfs() &#123;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	memset(dis, -1, sizeof(dis));</span><br><span class="line">	priority_queue&lt;node&gt; pq;</span><br><span class="line">	node beg(1, 0, 0);</span><br><span class="line">	pq.push(beg);</span><br><span class="line">	dis[1][0] &#x3D; 0;</span><br><span class="line">	dis[1][1] &#x3D; 0;</span><br><span class="line">	while (!pq.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		node u &#x3D; pq.top(); pq.pop();</span><br><span class="line">		int now &#x3D; u.to;</span><br><span class="line">		if (vis[now][u.t]) continue;</span><br><span class="line">		vis[now][u.t] &#x3D; 1;</span><br><span class="line">		for (node i : g[now]) &#123;</span><br><span class="line">			int next &#x3D; i.to;</span><br><span class="line">			int w &#x3D; 0;</span><br><span class="line">			if (!vis[next][i.t]) &#123;</span><br><span class="line">				if (i.t &#x3D;&#x3D; 0)  w &#x3D; i.w;</span><br><span class="line">				else if (i.t &#x3D;&#x3D; 1) &#123;</span><br><span class="line">					if (u.t &#x3D;&#x3D; 1)</span><br><span class="line">						w &#x3D; i.w * i.w + 2 * i.w*sqrt(u.xw);</span><br><span class="line">					else w &#x3D; i.w*i.w;</span><br><span class="line">				&#125;</span><br><span class="line">				if (w &gt; 1e6 || w &lt; 0) continue;</span><br><span class="line">				if (dis[next][i.t] &#x3D;&#x3D; -1 || dis[next][i.t] &gt; dis[now][u.t] + w) &#123;</span><br><span class="line">					dis[next][i.t] &#x3D; dis[now][u.t] + w;</span><br><span class="line">					node nt(next, dis[next][i.t], i.t);</span><br><span class="line">					if (i.t &#x3D;&#x3D; 1)</span><br><span class="line">						nt.xw &#x3D; u.xw + w;</span><br><span class="line">					pq.push(nt);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (dis[n][0] &#x3D;&#x3D; -1) return dis[n][1];</span><br><span class="line">	else if (dis[n][1] &#x3D;&#x3D; -1) return dis[n][0];</span><br><span class="line">	else return min(dis[n][1], dis[n][0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201709-4</title>
    <url>/2020/02/25/201709-4/</url>
    <content><![CDATA[<h1 id="通信网络"><a href="#通信网络" class="headerlink" title="通信网络"></a>通信网络</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　某国的军队由<em>N</em>个部门组成，为了提高安全性，部门之间建立了<em>M</em>条通路，每条通路只能单向传递信息，即一条从部门<em>a</em>到部门<em>b</em>的通路只能由<em>a</em>向<em>b</em>传递信息。信息可以通过中转的方式进行传递，即如果<em>a</em>能将信息传递到<em>b</em>，<em>b</em>又能将信息传递到<em>c</em>，则<em>a</em>能将信息传递到<em>c</em>。一条信息可能通过多次中转最终到达目的地。<br> 　由于保密工作做得很好，并不是所有部门之间都互相知道彼此的存在。只有当两个部门之间可以直接或间接传递信息时，他们才彼此知道对方的存在。部门之间不会把自己知道哪些部门告诉其他部门。<br> <img src="http://118.190.20.162/RequireFile.do?fid=yHg9gf9q" alt="img"><br> 　上图中给了一个4个部门的例子，图中的单向边表示通路。部门1可以将消息发送给所有部门，部门4可以接收所有部门的消息，所以部门1和部门4知道所有其他部门的存在。部门2和部门3之间没有任何方式可以发送消息，所以部门2和部门3互相不知道彼此的存在。<br> 　现在请问，有多少个部门知道所有<em>N</em>个部门的存在。或者说，有多少个部门所知道的部门数量（包括自己）正好是<em>N</em>。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入的第一行包含两个整数<em>N</em>, <em>M</em>，分别表示部门的数量和单向通路的数量。所有部门从1到<em>N</em>标号。<br> 　接下来<em>M</em>行，每行两个整数<em>a</em>, <em>b</em>，表示部门<em>a</em>到部门<em>b</em>有一条单向通路。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出一行，包含一个整数，表示答案。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>4 4<br> 1 2<br> 1 3<br> 2 4<br> 3 4</p>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>2</p>
<h2 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h2><p>　　部门1和部门4知道所有其他部门的存在。</p>
<h2 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>　　对于30%的评测用例，1 ≤ <em>N</em> ≤ 10，1 ≤ <em>M</em> ≤ 20；<br> 　对于60%的评测用例，1 ≤ <em>N</em> ≤ 100，1 ≤ <em>M</em> ≤ 1000；<br> 　对于100%的评测用例，1 ≤ <em>N</em> ≤ 1000，1 ≤ <em>M</em> ≤ 10000。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>分别以每个点为起点进行深度搜索，将能到达的点进行标记</li>
<li>遍历连接矩阵connect[][]</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1100;</span><br><span class="line">vector&lt;int&gt; g[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">bool connect[maxn][maxn];</span><br><span class="line">int n, m;</span><br><span class="line">void init() &#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">	int a, b;</span><br><span class="line">	memset(connect, 0, sizeof(connect));</span><br><span class="line">	for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">		g[a].push_back(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int u, int v) &#123;</span><br><span class="line">	if (vis[v]) return;</span><br><span class="line">	vis[v] &#x3D; 1;</span><br><span class="line">	connect[u][v] &#x3D; connect[v][u] &#x3D; 1;</span><br><span class="line">	for (int i : g[v]) &#123;</span><br><span class="line">		dfs(u, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	init();</span><br><span class="line">	int cnt &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		dfs(i, i);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">		int j;</span><br><span class="line">		for (j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">			if (!connect[i][j]) break;</span><br><span class="line">		if (j &#x3D;&#x3D; n + 1) cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d&quot;, cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201703-4</title>
    <url>/2020/02/25/201703-4/</url>
    <content><![CDATA[<h1 id="地铁修建"><a href="#地铁修建" class="headerlink" title="地铁修建"></a>地铁修建</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　A市有n个交通枢纽，其中1号和n号非常重要，为了加强运输能力，A市决定在1号到n号枢纽间修建一条地铁。<br> 　地铁由很多段隧道组成，每段隧道连接两个交通枢纽。经过勘探，有m段隧道作为候选，两个交通枢纽之间最多只有一条候选的隧道，没有隧道两端连接着同一个交通枢纽。<br> 　现在有n家隧道施工的公司，每段候选的隧道只能由一个公司施工，每家公司施工需要的天数一致。而每家公司最多只能修建一条候选隧道。所有公司同时开始施工。<br> 　作为项目负责人，你获得了候选隧道的信息，现在你可以按自己的想法选择一部分隧道进行施工，请问修建整条地铁最少需要多少天。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入的第一行包含两个整数<em>n</em>, <em>m</em>，用一个空格分隔，分别表示交通枢纽的数量和候选隧道的数量。<br> 　第2行到第<em>m</em>+1行，每行包含三个整数<em>a</em>, <em>b</em>, <em>c</em>，表示枢纽<em>a</em>和枢纽<em>b</em>之间可以修建一条隧道，需要的时间为<em>c</em>天。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出一个整数，修建整条地铁线路最少需要的天数。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>6 6<br> 1 2 4<br> 2 3 4<br> 3 6 7<br> 1 4 2<br> 4 5 5<br> 5 6 6</p>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>6</p>
<h2 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h2><p>　　可以修建的线路有两种。<br> 　第一种经过的枢纽依次为1, 2, 3, 6，所需要的时间分别是4, 4, 7，则整条地铁线需要7天修完；<br> 　第二种经过的枢纽依次为1, 4, 5, 6，所需要的时间分别是2, 5, 6，则整条地铁线需要6天修完。<br> 　第二种方案所用的天数更少。</p>
<h2 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>　 对于20%的评测用例，1 ≤ <em>n</em> ≤ 10，1 ≤ <em>m</em> ≤ 20；<br> 　对于40%的评测用例，1 ≤ <em>n</em> ≤ 100，1 ≤ <em>m</em> ≤ 1000；<br> 　对于60%的评测用例，1 ≤ <em>n</em> ≤ 1000，1 ≤ <em>m</em> ≤ 10000，1 ≤ <em>c</em> ≤ 1000；<br> 　对于80%的评测用例，1 ≤ <em>n</em> ≤ 10000，1 ≤ <em>m</em> ≤ 100000；<br> 　对于100%的评测用例，1 ≤ <em>n</em> ≤ 100000，1 ≤ <em>m</em> ≤ 200000，1 ≤ <em>a</em>, <em>b</em> ≤ <em>n</em>，1 ≤ <em>c</em> ≤ 1000000。</p>
<p> 　所有评测用例保证在所有候选隧道都修通时1号枢纽可以通过隧道到达其他所有枢纽。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>由于需要取最大值最小的情况，所以想到用kruskal算法</li>
<li>之后就是在kruskal中，加入判断，当1和n连通时退出即可</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 200000 + 5;</span><br><span class="line">#define inf  1e6+5</span><br><span class="line">int n, m;</span><br><span class="line">struct edge &#123;</span><br><span class="line">	int a,b;</span><br><span class="line">	int w;</span><br><span class="line">	edge(int a, int b, int w) :a(a), b(b), w(w) &#123;&#125;</span><br><span class="line">	bool operator &lt; (const edge&amp; a) const &#123; return w &lt; a.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; g;</span><br><span class="line">int Tree[maxn];</span><br><span class="line">int findroot(int p) &#123;</span><br><span class="line">	if (Tree[p] &#x3D;&#x3D; -1) return p;</span><br><span class="line">	else &#123;</span><br><span class="line">		int tmp &#x3D; findroot(Tree[p]);</span><br><span class="line">		Tree[p] &#x3D; tmp;</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool union_(int p, int q) &#123;</span><br><span class="line">	int rp &#x3D; findroot(p);</span><br><span class="line">	int rq &#x3D; findroot(q);</span><br><span class="line">	if (rp !&#x3D; rq) &#123;</span><br><span class="line">		Tree[rp] &#x3D; rq;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">	int a, b, w;</span><br><span class="line">	memset(Tree, -1, sizeof(Tree));</span><br><span class="line">	for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;w);</span><br><span class="line">		g.push_back(edge(a, b, w));</span><br><span class="line">	&#125;</span><br><span class="line">	sort(g.begin(), g.end());</span><br><span class="line">	int maxx &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; g.size(); i++) &#123;</span><br><span class="line">		int a &#x3D; g[i].a;</span><br><span class="line">		int b &#x3D; g[i].b;</span><br><span class="line">		int w &#x3D; g[i].w;</span><br><span class="line">		if (union_(a, b)) &#123;</span><br><span class="line">			if (maxx &lt; w) maxx &#x3D; w;</span><br><span class="line">			if (findroot(1) &#x3D;&#x3D; findroot(n)) break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d&quot;, maxx);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>ccf</title>
    <url>/2020/02/25/ccf/</url>
    <content><![CDATA[<h2 id="201312-4"><a href="#201312-4" class="headerlink" title="201312-4"></a><a href="/2020/03/02/201312-4/">201312-4</a></h2><h2 id="201403-4"><a href="#201403-4" class="headerlink" title="201403-4"></a><a href="/2020/03/02/201403-4/">201403-4</a></h2><h2 id="201409-4"><a href="#201409-4" class="headerlink" title="201409-4"></a><a href="/2020/03/02/201409-4/">201409-4</a></h2><h2 id="201412-4"><a href="#201412-4" class="headerlink" title="201412-4"></a><a href="/2020/03/02/201412-4/">201412-4</a></h2><h2 id="201503-4"><a href="#201503-4" class="headerlink" title="201503-4"></a><a href="/2020/03/02/201503-4/">201503-4</a></h2><h2 id="201509-4"><a href="#201509-4" class="headerlink" title="201509-4"></a><a href="/2020/03/02/201509-4/">201509-4</a></h2><h2 id="201604-4"><a href="#201604-4" class="headerlink" title="201604-4"></a><a href="/2020/03/02/201604-4/">201604-4</a></h2><h2 id="201609-4"><a href="#201609-4" class="headerlink" title="201609-4"></a><a href="/2020/02/25/201609-4/">201609-4</a></h2><h2 id="201612-4"><a href="#201612-4" class="headerlink" title="201612-4"></a><a href="/2020/02/25/201612-4/">201612-4</a></h2><h2 id="201703-4"><a href="#201703-4" class="headerlink" title="201703-4"></a><a href="/2020/02/25/201703-4/">201703-4</a></h2><h2 id="201709-4"><a href="#201709-4" class="headerlink" title="201709-4"></a><a href="/2020/02/25/201709-4/">201709-4</a></h2><h2 id="201712-4"><a href="#201712-4" class="headerlink" title="201712-4"></a><a href="/2020/02/25/201712-4/">201712-4</a></h2><h2 id="201803-3"><a href="#201803-3" class="headerlink" title="201803-3"></a><a href="/2020/02/25/201803-3/">201803-3</a></h2><h2 id="201803-4"><a href="#201803-4" class="headerlink" title="201803-4"></a><a href="/2020/02/25/201803-4/">201803-4</a></h2><h2 id="201812-4"><a href="#201812-4" class="headerlink" title="201812-4"></a><a href="/2020/02/25/201812-4/">201812-4</a></h2><h2 id="201903-3"><a href="#201903-3" class="headerlink" title="201903-3"></a><a href="/2020/02/25/201903-3/">201903-3</a></h2><h2 id="201903-4"><a href="#201903-4" class="headerlink" title="201903-4"></a><a href="/2020/02/25/201903-4/">201903-4</a></h2><h2 id="201909-4"><a href="#201909-4" class="headerlink" title="201909-4"></a><a href="/2020/02/25/201909-4/">201909-4</a></h2>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib基础</title>
    <url>/2020/02/21/matplotlib%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>一、数据挖掘基础环境安装与使用<br>1.1 库的安装<br>    matplotlib==2.2.2<br>    numpy==1.14.2<br>    pandas==0.20.3<br>    TA-Lib==0.4.16 技术指标库<br>    tables==3.4.2 hdf5<br>    jupyter==1.0.0 数据分析与展示的平台<br>1.2 Jupyter Notebook使用<br>    1.2.1 Jupyter Notebook介绍<br>        1）web版的ipython<br>        2）名字<br>        ju - Julia<br>        py - Python<br>        ter - R<br>        Jupiter 木星 宙斯<br>        3）编程、写文档、记笔记、展示<br>        4）.ipynb<br>    1.2.2 为什么使用Jupyter Notebook?<br>        1）画图方面的优势<br>        2）数据展示方面的优势<br>    1.2.3 Jupyter Notebook的使用-helloworld<br>        1 界面启动、创建文件<br>            在终端输入jupyter notebook / ipython notebook<br>            快速上手的方法：<br>                快捷键<br>                    运行代码 shift + enter<br>        2 cell操作<br>            cell：一对In Out会话被视作一个代码单元，称为cell<br>            编辑模式：<br>                enter<br>                鼠标直接点<br>            命令模式：<br>                esc<br>                鼠标在本单元格之外点一下<br>            2）快捷键操作<br>                执行代码：shift + enter<br>                命令模式：<br>                A，在当前cell的上面添加cell<br>                B，在当前cell的下面添加cell<br>                双击D：删除当前cell<br>                编辑模式：<br>                多光标操作：Ctrl键点击鼠标（Mac:CMD+点击鼠标）<br>                回退：Ctrl+Z（Mac:CMD+Z）<br>                补全代码：变量、方法后跟Tab键<br>                为一行或多行代码添加/取消注释：Ctrl+/（Mac:CMD+/）<br>            3 markdown演示<br>                # 一级标题<br>                - 缩进<br>二、Matplotlib<br>                2.1 Matplotlib之HelloWorld<br>                                2.1.1 什么是Matplotlib - 画二维图表的python库<br>                        mat - matrix 矩阵<br>                                二维数据 - 二维图表<br>                        plot - 画图<br>                        lib - library 库<br>                        matlab 矩阵实验室<br>                                mat - matrix<br>                                lab 实验室<br>                                2.1.2 为什么要学习Matplotlib - 画图<br>                        数据可视化 - 帮助理解数据，方便选择更合适的分析方法<br>                        js库 - D3 echarts<br>                        奥卡姆剃刀原理 - 如无必要勿增实体<br>                                2.1.3 实现一个简单的Matplotlib画图<br>                                2.1.4 认识Matplotlib图像结构<br>                                2.1.5 拓展知识点：Matplotlib三层结构<br>                        1）容器层<br>                                画板层Canvas<br>                                画布层Figure plt.figure()<br>                                绘图区/坐标系 plt.subplots()<br>                    x、y轴张成的区域<br>                        2）辅助显示层<br>                        3）图像层<br>                2.2 折线图(plot)与基础绘图功能<br>                                2.2.1 折线图绘制与保存图片<br>                        3 设置画布属性与图片保存<br>                                figsize : 画布大小<br>                                dpi : dot per inch 图像的清晰度<br>                        3 中文显示问题解决<br>                                mac的一次配置，一劳永逸<br>                                ubantu每创建一次新的虚拟环境，需要重新配置<br>                                windows<br>                                1）安装字体<br>                    mac/wins：双击安装<br>                    ubantu：双击安装<br>                                2）删除matplotlib缓存文件<br>                                3）配置文件<br>                                2.2.4 多个坐标系显示-plt.subplots(面向对象的画图方法)<br>                        figure, axes = plt.subplots(nrows=1, ncols=2, **fig_kw)<br>                        axes[0].方法名()<br>                        axes[1]<br>                                2.2.5 折线图的应用场景<br>                        某事物、某指标随时间的变化状况<br>                        拓展：画各种数学函数图像<br>2.3.1 常见图形种类及意义<br>                折线图plot<br>                散点图scatter<br>                                关系/规律<br>                柱状图bar<br>                                统计/对比<br>                直方图histogram<br>                                分布状况<br>                饼图pie π<br>                                占比(一般来说，超过9类就不适合用饼图了，建议使用柱状图)<br>                2.3.2 散点图绘制<br>                2.4 柱状图(bar)<br>                                2.4.1 柱状图绘制<br>                2.5 直方图(histogram)<br>                                2.5.1 直方图介绍<br>                        组数：在统计数据时，我们把数据按照不同的范围分成几个组，分成的组的个数称为组数<br>                        组距：每一组两个端点的差<br>                        已知 最高175.5 最矮150.5 组距5<br>                        求 组数：(175.5 - 150.5) / 5 = 5<br>                                2.5.2 直方图与柱状图的对比<br>            1. 直方图展示数据的分布，柱状图比较数据的大小。<br>                        2. 直方图X轴为定量数据，柱状图X轴为分类数据。<br>                        3. 直方图柱子无间隔，柱状图柱子有间隔<br>                                    4. 直方图柱子宽度可不一，柱状图柱子宽度须一致<br>                        2.5.3 直方图绘制<br>                                        x = time<br>                                        bins 组数 = (max(time) - min(time)) // 组距<br>                                        3 直方图注意点<br>                            2.6 饼图(pie)<br>                        %1.2f%%<br>                        print(“%1.2f%%”)</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>Python数据可视化</title>
    <url>/2020/02/20/Python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<h1 id="MatPlotLib基础"><a href="#MatPlotLib基础" class="headerlink" title="MatPlotLib基础"></a><a href="/Python可视化/matplotlib基础/">MatPlotLib基础</a></h1><h1 id="MatPlotLib代码示例"><a href="#MatPlotLib代码示例" class="headerlink" title="MatPlotLib代码示例"></a><a href="/Python可视化/matplotlib代码示例/">MatPlotLib代码示例</a></h1><h1 id="Numpy基础"><a href="#Numpy基础" class="headerlink" title="Numpy基础"></a><a href="/Python可视化/numpy基础/">Numpy基础</a></h1><h1 id="Numpy代码示例"><a href="#Numpy代码示例" class="headerlink" title="Numpy代码示例"></a><a href="/Python可视化/numpy代码示例/">Numpy代码示例</a></h1><h1 id="Pandas基础"><a href="#Pandas基础" class="headerlink" title="Pandas基础"></a><a href="/Python可视化/pandas基础/">Pandas基础</a></h1><h1 id="Pandas代码示例"><a href="#Pandas代码示例" class="headerlink" title="Pandas代码示例"></a><a href="/Python可视化/pandas代码示例/">Pandas代码示例</a></h1><h1 id="Pandas高级"><a href="#Pandas高级" class="headerlink" title="Pandas高级"></a><a href="/Python可视化/pandas高级/">Pandas高级</a></h1><h1 id="Pandas高级代码示例"><a href="#Pandas高级代码示例" class="headerlink" title="Pandas高级代码示例"></a><a href="/Python可视化/pandas高级代码示例/">Pandas高级代码示例</a></h1>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计安导报告</title>
    <url>/2020/02/20/%E8%AE%A1%E5%AE%89%E5%AF%BC%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="第1章-绪-论"><a href="#第1章-绪-论" class="headerlink" title="第1章  绪 论"></a>第1章  绪 论</h1><h2 id="1-1-区块链起源"><a href="#1-1-区块链起源" class="headerlink" title="1.1  区块链起源"></a>1.1  区块链起源</h2><p>2008年中本聪综合前人在加密货币上的成果提出了比特币的概念，并于2009年1月3日挖出了创世区块，实现了数字世界的价值表示与价值转移，也引发了人们对其底层技术–区块链技术的探索。在比特币之前就有很多专家进行过加密货币的研究，并给出了自己方案，如亚当·贝克的哈希现金，哈尔·芬妮的比特黄金，戴伟的B-Money等。他们的方案存在着一个共同点，就是要通过计算机的计算来创造电子现金。在这种思想的基础上，中本聪融合前人观点，设计了基于工作量证明的共识机制，使得去中心化成为可能，最终解决了数字现金的问题。</p>
<h2 id="1-2-以太坊"><a href="#1-2-以太坊" class="headerlink" title="1.2  以太坊"></a>1.2  以太坊</h2><p>以太坊创始人维塔利克分析了比特币系统，在比特币系统的四点不足上建立以太坊。其目标是建立一个新的区块链，内设有成熟的图灵完备的语言，可以利用这种语言来编写代码，创建合约，实现任意的状态转换。</p>
<p>以太坊的突出贡献在于实现了智能合约，使区块链技术从数字货币向数字资产转变。对于由智能合约来控制的实体资产，引用萨博的例子来说明：&quot;例如，为了防止一部车被偷窃，除非确定拥有者完成正确的&quot;挑战响应协议&quot;，否则车是不会启动激活的。例如，如果车是贷款买的，当拥有者无法偿还贷款时，智能合约将会自动启动扣押令，并将车钥匙的控制权交给银行。一旦拥有者还清贷款，智能合约就移除扣押令。&quot;总而言之，以太坊的出现使得创造通证变得简单。随着物联网技术的发展，越来越多的机器需要通证，基于区块链技术，为机器设计专用的钱包和通证将成为未来物联网发展的又一可能。</p>
<h2 id="1-3-EOS"><a href="#1-3-EOS" class="headerlink" title="1.3  EOS"></a>1.3  EOS</h2><p>在《区块链革命》中，商业思想家唐·塔普斯科特这样写道：&quot;区块链上运行的所有计算资源可以在整体上视为一台计算机。&quot;。仔细考虑使用一条区块链所需要的资源，包括带宽资源（相当于硬盘）、计算资源（相当于CPU）、        状态资源（相当于RAM），确实和一台计算机十分相似。以太坊曾把自己定位为一台&quot;全球分布式计算机&quot;，那么EOS就是建立在这台计算机上的软件系统，他代表了区块链应用的一种发展方向，即开发一条通用的基础公链，实现一切去中心化。通过相关资料，我发现EOS已经在许多方面大异于比特币和以太坊，比如他的共识机制、        区块产生方式，账户等，并且开创性的提出了基于角色的权限系统。目前来说，区块链技术想要落地应用还有很多问题没有解决，哪条路才是切实有效的也没有定论，未来等着我们去探索。</p>
<h2 id="1-4-结构安排"><a href="#1-4-结构安排" class="headerlink" title="1.4  结构安排"></a>1.4  结构安排</h2><p>本文共分为三大部分，首先从比特币说起，讲述我学习到的比特币系统，阐述其数据结构、共识机制，分析安全性等。之后，讨论代表区块链2.0的以太坊，由于他的共识机制基本与比特币相同，所以主要阐述了以太坊的三种主要的数据结构。第三部分，阐述了区块链应用的可能方向以及一款基于功能类公链的应用实例–Steemit。</p>
<h1 id="第2章-比特币系统的技术原理及安全分析"><a href="#第2章-比特币系统的技术原理及安全分析" class="headerlink" title="第2章 比特币系统的技术原理及安全分析"></a>第2章 比特币系统的技术原理及安全分析</h1><p>在比特币系统中第一次给出了区块链技术的定义：&quot;区块链是数字世界中进行价值表示和价值转移的技术。&quot;而比特币作为区块链硬币，他的一面是表示价值的加密数字货币或通证，另一面是进行价值转移的分布式账本与去中心网络。本章将从分布式账本与去中心网络及数据结构的角度讨论比特币系统，并分析其安全性。</p>
<h2 id="2-1分布式账本与去中心网络"><a href="#2-1分布式账本与去中心网络" class="headerlink" title="2.1分布式账本与去中心网络"></a>2.1分布式账本与去中心网络</h2><p>威廉·穆贾雅在《商业区块链》中将比特币总结为四个要点分别是：点对点电子交易；不需要金融机构；加密证据而不是中心化信用；信用存在于网络，而不是某个中心机构。</p>
<p>现如今的数字世界中的货币有三种存在形式，包括中心化的在线支付，如微信、支付宝等；中心化互联网积分，如Q币等；去中心化的电子现金。在中心化的在线支付系统中流转的货币是各种法币的映射，这些映射来的&quot;数字货币&quot;本身没有价值，其价值依赖于法币本身的购买力。同样中心化的互联网积分，其价值不与任何法币想关联，        完全由发行公司决定，且只能用于购买这家公司的服务和产品。对于比特币系统的去中心网络比特币的价值由其算法保证，即使整体的算力出现波动，算法也能在至多2016个区块后通过调整目标阈值来调整挖矿难度，从而使得比特币系统的平均出块间隔维持在10分钟左右，以此保证了比特币系统内部比特币的价值稳定（与法币的汇率不是由比特币系统决定的）。比特币的以上优点很大程度上是得益于其分布式账本和去中心网络。</p>
<p>比特币的去中心网络由由众多轻节点和全结点组成，其中全节点包含所有比特币区块链的区块数据，轻节点仅包含自己相关的数据。并且比特币网络是开放的，任何服务器都可以加入成为全结点，共同维护这个去中心网络。由于网络没有一个类似于&quot;央行&quot;的中心化组织存储信息，所以所有用户持有的比特币信息都存在一个分布式账本中，可以认为同时存储在所有全结点中。</p>
<h2 id="2-2比特币系统的加密体制"><a href="#2-2比特币系统的加密体制" class="headerlink" title="2.2比特币系统的加密体制"></a>2.2比特币系统的加密体制</h2><p>比特币与密码学是密不可分的，从比特币&quot;账户&quot;（实际是地址）产生就使用了非对称密码体制，到每次交易签名，再到区块链内部的梅克尔树，以及区块链间的哈希指针都反应了密码学原理。</p>
<p>首先，在生成一个比特币账户时，实际上我们得到的一对公私钥对，其中公钥的哈希值即为比特币地址，作为转账交易的收付款地址；而私钥用于对我支付的每一笔交易进行签名。当我发起一笔交易时，我将用我的私钥对这笔交易记录进行签名， 同时广播出我的公钥以便其他的节点能够验证这笔交易的合法性，同时我还要为这笔交易付一点&quot;小费&quot;。这样操作下来，再等上一段时间，我的交易就会被写入区块链中成为不可逆的交易。</p>
<p>比特币系统使用的哈希函数是 SHA-256。除了哈希函数本身的抗碰撞性和单向性外，应用于比特币系统的哈希值还有puzzle friendly的性质，即要求块头的哈希值小于某个目标阈值。以及难于计算，但易于验证的性质。这些性质一方面保证了区块链上数据的不可篡改性，另一方面也为各个节点达成共识提供了基础保障。</p>
<p>此外，这种密码体制的安全性还建立在一个好的随机源上，这样才能确保有足够大的搜索空间来保证安全性。</p>
<h2 id="2-3比特币区块链的数据结构"><a href="#2-3比特币区块链的数据结构" class="headerlink" title="2.3比特币区块链的数据结构"></a>2.3比特币区块链的数据结构</h2><p>比特币区块链是一条通过哈希指针连接起来的链表。后一的区块的哈希指针是通过前一区块的全部内容(包括前一区块的哈希指针)计算出来的。这样从最后一个区块就能知道前面的区块是否被修改，使得系统中的某些节点不需要保存全部区块信息。</p>
<p>每个区块中的数据是被打包进这个区块的一系列交易，这些交易按规则形成一颗梅克尔树。梅克尔树是一颗由哈希指针连接起来的哈希树，其中叶子节点是要打包进区块的交易信息，非叶子节点是由叶子节点计算而来的哈希值。这样设计有很多好处，比如一个轻节点如果想知道自己的交易(位于第n层)是否已经被打包进区块链中，那么他只需要向全节点请求他不在的那条路径上非叶子节点的哈希值。之后，它就可以先计算要验证交易的哈希值（这一定是已知的），再将这个哈希与全节点给出的第（n-1）层的哈希值共同计算(n-2)层的哈希值，如此迭代下去，最终可以求得这笔交易所在的梅克尔树的根哈希值。将这个根哈希值与全节点给出的根哈希值比较即可验证交易。这样设计使得更多的节点能够低门槛的连入比特币系统，增加了比特币系统的活跃程度。</p>
<p>此外，区块头部中也包含着很多的重要信息，比如比特币版本协议信息，指向前一个区块的指针，梅克尔树的根哈希值，挖矿的难度目标阈值，随机数等。这些信息对于比特币系统达成共识有着至关重要的作用。</p>
<h2 id="2-4比特币系统的共识机制"><a href="#2-4比特币系统的共识机制" class="headerlink" title="2.4比特币系统的共识机制"></a>2.4比特币系统的共识机制</h2><p>所谓共识机制，指的是众多互不相识、互不信任的节点之间就交易的合法性达成一致意见。这对于比特币这样一个去中心化的网络十分重要，只有确保了共识机制，才能保证不同账本节点上数据的一致性和正确性。</p>
<p>比特币系统所采用的策略是工作量证明。简单来说就是通过求解一个随机数来使得块头的哈希值小于一个给定的目标阈值，这个过程也称为挖矿。从概率学的角度来说，每次实验都可以看作是一次伯努利实验。当试验次数很多，而成功概率很小的时候，我们就可以用泊松分布来近似。也就是说，在比特币系统中，想要得到记账权没有任何捷径可走，只能单纯的通过反复尝试不同的随机数来求解。这也就保证了每个挖出区块的节点都是做了大量的工作来维护这条区块链，从而保证了区块链上数据的一致性。</p>
<p>比特币系统在共识机制做出了两点创新。其一是引入了奖励机制，通过比特币奖励使得区块链上节点愿意打包交易，主动维护账本，加快了一致性的达成。其二是引入了随机性的概念，尽管比特币系统不是完全可靠的，但是一般来说经过6个区块后，出问题的概率会呈指数级下降。</p>
<p>实际上，共识机制的形成过程是一个投票过程，只不过比特币系统是通过算力进行投票。拥有较大算力的节点能够优先把自己认为合法的交易打包进区块中，即通过算力给这些交易投票。</p>
<h2 id="2-5-比特币系统的安全分析"><a href="#2-5-比特币系统的安全分析" class="headerlink" title="2.5 比特币系统的安全分析"></a>2.5 比特币系统的安全分析</h2><p>首先通过一个例子来简单的说一下比特币的转账过程。假设现在甲要向乙进行转账，那么甲会发起一个转账交易，并用自己的私钥进行签名，同时将收款人的姓名写为乙的地址，并发布出去。听到这个交易的节点，首先验证nbits域的设置是否符合难度要求；验证头的哈希是否小于等于目标阈值。然后验证body中的交易是否有甲的合法签名，这笔钱以前是否被花过。第三要验证这个区块是否是连在最长合法链上。假设这个区块已经被打包进了区块链中，那么沿着这个区块继续挖的区块也会来验证这笔交易。一般来说，经过6个区块后这笔交易就可以认为是这笔交易不可篡改。针对比特币的转账过程，我探究了以下几种安全问题。</p>
<h3 id="2-5-1-伪造转账交易"><a href="#2-5-1-伪造转账交易" class="headerlink" title="2.5.1 伪造转账交易"></a>2.5.1 伪造转账交易</h3><p>首先，考虑攻击者能否转走别人账户上的比特币。这是不可能的。第一，因为比特币系统中合法交易需要交易发起方用自己的私钥进行签名，而私钥无法伪造，所以不能成功。第二，如果恶意节点强行将交易写入区块中，那么诚实的节点也不会认可这笔交易，同时攻击者也损失了一笔出块奖励，同样说明这种攻击难以实现。</p>
<p>一般情况下，发起交易的一方要广播自己公钥来让其他节点可以验证自己的签名合法性。假设现在有一个攻击者想要转走A账户上的比特币，那么他先伪造一笔A转出的转账交易，并用自己的私钥进行签名，同时广播自己的公钥说成是A的公钥。这样能否转走A账户上的比特币呢？也是不可能的，因为A账户上的比特币一定来自之前的某一笔交易，而之前交易的收款人地址正是A的公钥的哈希。由于攻击者的公钥哈希与这个收款地址哈希对不上，其他节点就不把他作为合法交易，也不会写进区块链中。</p>
<h3 id="2-5-2回滚交易数据"><a href="#2-5-2回滚交易数据" class="headerlink" title="2.5.2回滚交易数据"></a>2.5.2回滚交易数据</h3><p>假设现在A要向B转账5个比特币，A签名了这个交易并发布到网络上，表面看起来B已经得到这笔交易的输出。但是如果攻击者立即发布一笔交易将这5个比特币转给自己，由于两笔交易都有A的合法签名，所以两者都会被作为合法交易打包进区块链中。同时如果攻击者具有足够多的算力将回滚交易所在的链拓展成最长链，那么交易就会被回滚。这种通过向区块链中间插入某个区块来回滚某个已经发生的交易，又称为分叉攻击。防范这种攻击的简单方式是等待六个区块的确认，这样拓展回滚交易所在的链的难度就会大大增加。</p>
<p>分叉的原因有很多，实际上，即使完全正常运作的比特币系统中也会存在分叉。可能有两个节点几乎同时挖出了新的区块，并把它广播出去。由于网络延迟和节点间距离的差异最终导致不同的节点收到了不同的合法区块。按照比特币协议，一个节点只会接受第一个收到的合法区块，所以最终会导致区块链出现分叉。但这种分叉只是暂时的，随着时间的推移，两条分叉上的算力互相竞争，最终会以一方称为绝对的最长合法链而告终。</p>
<h3 id="2-5-3掌控最长合法链"><a href="#2-5-3掌控最长合法链" class="headerlink" title="2.5.3掌控最长合法链"></a>2.5.3掌控最长合法链</h3><p>我们知道，新的区块的内容中包含前一区块的哈希值。也就是说，在正常情况下没有前一个区块就不能产生新的区块。并且比特币系统中，合法的区块应该是位于最长合法链上。现在如果有一个恶意节点想要掌握最长合法链，当他挖出一个区块后，先不广播，而是在这个区块的基础上接着挖下一个。直到自己手里这条链变成绝对的最长合法链再一起发布出去，从而使得其中的非法交易合法化。这种攻击很难奏效，因为比特币系统是基于算力进行投票的，所以攻击者想要将自己的链变成最长合法链有很大难度。</p>
<p>挖出区块而不广播的理由可能还包括盈利目的。假设某个节点挖出了第n+1个区块，但是不立即广播，然后接着这个区块继续挖第n+2块。当有其他节点挖出第n+1块时，他立即广播第n+1和n+2块。那么由他记账的区块链就变成了最长合法链，同时得到这两个区块的出块奖励，看起来就像是一步领先，步步领先。</p>
<p>但实际上，在比特币系统中，这种行为很难成功。这样做的成功前提是在别的节点挖出一个区块的时间里，他能保证挖出两个以上区块。这样做存在很大风险，有可能一个出块奖励也得不到。</p>
<h3 id="2-5-4比特币的匿名性"><a href="#2-5-4比特币的匿名性" class="headerlink" title="2.5.4比特币的匿名性"></a>2.5.4比特币的匿名性</h3><p>比特币系统的匿名性是很难以维护的，因为区块链是公开的，并且区块链具有不可修改性。一旦有一次交易暴露了身份，那么这个影响将是永久性的。并且比特币作为一种虚拟货币，最终会和法币相关联，一旦与实体世界发生关系，那么就可能在用比特币支付和进行资金转入转出时发生隐私的泄漏。如果先不考虑与实体世界的联系，我们可以每次转账交易都生成一个新的地址，采用多路径转发的方式，使得从交易推理出身份的难度增大，从而加强匿名性。此外，市面上还出现了牺牲性能而增强匿名性的货币，如零币零钞等基于零知识证明的加密货币。但是由于普通用户对匿名性的要求并不高，所以并未被广泛使用。</p>
<h2 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a>2.6 总结</h2><p>以上就是我对一些感兴趣的攻击比特币系统的手段分析。上述分析基础是比特币网络中大部分节点都是诚实的，恶意节点只是少数，不会占据51%以上的算力。然而近些年出现的矿场使得算力更加聚集，历史上就曾经出现过大型矿场占据51%以上的算力的情况(他们为了防止引起恐慌，自行分解了算力)。这说明比特币系统的安全性是相对的，想要持久的维护比特币系统的安全性就要维持比特币社区的活跃度，使得诚实的节点永远占据大多数。</p>
<h1 id="第3章-以太坊"><a href="#第3章-以太坊" class="headerlink" title="第3章 以太坊"></a>第3章 以太坊</h1><p>维塔利克在分析了比特币系统的缺陷的基础上提出了以太坊。目标是提供一个区块链，内置有成熟的图灵完备的编程语言，用这种语言可以创建合约来编码，实现任意状态转换功能。通过这种语言，按照ERC标准，我们可以编写出自己的智能合约，进行区块链上的状态转换，进行链上数字资产的转移。其开创性的智能合约使得区块链技术从数字现金向数字资产转移，为日后的应用奠定了基础。接下来的一部分主要描述一些关于以太坊的数据结构。</p>
<h2 id="3-1以太坊的数据结构"><a href="#3-1以太坊的数据结构" class="headerlink" title="3.1以太坊的数据结构"></a>3.1以太坊的数据结构</h2><p>首先，以太坊区别于比特币系统，设置了账户系统。在比特币系统中，每次交易都会把余额转到另一个零钱地址中。而以太坊中为了支持智能合约，就需要参与方有相对稳定的身份，所以改用账户系统，每次交易直接增删余额。以太坊被看作是由交易驱动的状态机，所以在以太坊中要保存状态和交易。因此，以太坊设置了三种树，分别是状态树，交易树，和收据树。</p>
<h3 id="3-3-1状态树、交易树、收据树"><a href="#3-3-1状态树、交易树、收据树" class="headerlink" title="3.3.1状态树、交易树、收据树"></a>3.3.1状态树、交易树、收据树</h3><p>建立状态树的目的是要建立一个从账户到状态的映射。其中以太坊账户为40位十六进制数，状态中包括余额，交易次数，如果是合约账户还包括代码和存储的变量。同时，要求这颗树上的数据不可篡改，便于查找，增加，删除，同时节省存储空间。此外，应该令轻节点易于验证某个键值对是否存在。于是以太坊在传统的Trie树的基础上，压缩路径，增加哈希指针得到了Modified Merkle Partricia Tree。</p>
<p>首先说Trie树，它常被用来存储单词，进行多模式串的模式匹配。在以太坊中，由于账户是由40位十六进制数构成，所以每个节点的分支最多有17种可能（加一个结束标志）。Trie树的优点是无需排序，即使插入顺序不一样，得到的结构也是一样的；同时它还具有很好的更新局部性，由于每个区块中涉及发生的交易是少数的，采用这种结构不需要去管其他的分支，增强了修改的性能。</p>
<p>Trie树的缺点也很明显，它有很大的存储浪费，并且实际的查找效率与树的深度有关。于是进一步的考虑Partricia tree，一种路径压缩的trie树。对于基数树的每个节点，如果该节点是唯一的儿子的话，就和父节点合并。当键值分布较为稀疏的时候，更新时需要打开压缩部分的概率就比较低，性能也就更好。而以太坊的地址就恰好是这种结构。</p>
<p>借鉴比特币系统的思想，将树中指针全部换成哈希指针得到了Merkle Partricia Tree(MPT)树。而以太坊系统中使用的是略作修改的MPT树，本质上没有改变。</p>
<p>以太坊的结构是一颗大的MPT树中包含很多小的MPT树，每个小的MPT就是一个合约账户。对于全节点来说，他维护的也不是一颗MPT，而是每产生一个新的区块就新建一颗MPT，这些树中大部分节点是共享的，只有少数更新的节点可能要新建分支。</p>
<p>我通过与比特币系统的对比，发现比特币系统中不需要保存历史状态，而是通过UTXO的输入输出计算得来。但是以太坊不同，由于账户的设计，智能合约的出现，每个交易被打包进区块链的时候，其账户余额也被改变。这样设计的优点是天然的防范了双花攻击。但是如果某个交易所在区块不在最长合法链上，为了保持账户余额和合法链上得到的交易的结果是一致的，就需要对分叉部分进行回滚。我认为这就是需要保存历史状态的原因。</p>
<p>至于交易树和收据树，他们本身也是一颗MPT树。每个交易执行完，会形成一颗收据树，记录这个交易的相关信息。交易树和收据树上的节点是一一对应的。但每个区块的交易树和收据树又是相互独立的。他们发布的交易本身也被认为是相互独立的。</p>
<h3 id="3-3-2bloom-filter"><a href="#3-3-2bloom-filter" class="headerlink" title="3.3.2bloom filter"></a>3.3.2bloom filter</h3><p>以太坊为了支持一些复杂的查询的查询操作，比如查询近十天里和某个智能合约相关的交易而设计了这个数据结构。对于这个问题，可能最开始的想法就是遍历这个链将符合规则的区块挑出来，但是对于轻节点来说，他不能保存所有区块的信息，同时也存在查找效率低下的问题。</p>
<p>而bloom filter结构可以理解为一个大的向量，称为摘要。是将每个元素取一个哈希，形成的一个向量，其中某位为1代表对应该哈希值的元素存在。假如现在要查找过去十天发生的和某个智能合约相关的交易。首先，查找区块块头的bloom filter，看看哪个块头的bloom fikter里有我要的交易类型。如果某个块头里有，再去相应的收据树的bloom filter中查找。每一步轻节点都可以向全节点请求少量的信息就可以查询下去，很好的解决了问题。即使考虑哈希碰撞，那么也只会出现误报，而不会出现漏报。而误报情况可以在逐渐细化的查询中被发现。</p>
<h3 id="3-3-3cache与DAG"><a href="#3-3-3cache与DAG" class="headerlink" title="3.3.3cache与DAG"></a>3.3.3cache与DAG</h3><p>比特币的挖矿设备从最初的CPU，转向GPU，再到现在的ASIC芯片挖矿，设备趋向于专业化，挖矿门槛越来越高。这样不利于比特币系统的安全稳定，只有当算力足够分散的时候，发动51%以上算力的攻击才很困难。为了做到杜绝ASIC芯片，以太坊在莱特币的基础上改进了挖矿算法，使得求解从纯粹的算力竞争上转向内存竞争。</p>
<p>莱特币曾经是市值仅次于比特币的一种加密货币。他首先将内存引入了挖矿算法。他基于Scrypt加密算法，需要用大的内存来保存这个数组，否则每次都要重新计算。简单来说，Scrypt算法是先通过一个种子取哈希得到数组中的第一个元素，之后再将这个元素取哈希得到第二个，反复迭代得到后面的元素。但是对于轻节点来说，他只是想验证某个区块的合法性，却需要和矿工等量的计算。这与区块链的基本理念:难于计算，易于验证相悖。考虑到这个原因，莱特币只将这个数组设置为128K，这显然太小了，对于矿机来说，完全可以通过计算来弥补内存的薄弱。</p>
<p>以太坊在莱特币的基础上进行了改进。他规定了两个数据集，16M的cache和1G的DAG，其中DAG是通过cache计算得来。轻节点只需要保存cache即可验证区块，矿工通过DAG来计算随机数使最后的哈希值低于目标阈值。</p>
<p>Cache的形成与莱特币类似，也是从一个种子节点开始依次取哈希来填充数组。对于DAG，他首先从cache里随机读一个数，然后进行哈希计算，得到下一个要读取的数的位置。然后用cache中这个位置的数和当前的哈希值再计算出一个哈希。反复迭代256次，将最终得到的数填充到DAG的第一个位置。</p>
<p>对于矿工来说，在挖矿的时候，先根据块头和nonce值计算一个哈希，这个哈希映射到数组中的某一个位置。通过这个位置和其相邻位置的元素进行运算得到下一个要计算哈希的位置。反复迭代64次，最后得到的哈希值与目标阈值比较，看一下是否满足要求，不成功则换下一个nonce尝试。</p>
<p>对于轻节点，想要验证一个区块是否符合要求，他需要这个区块的nonce以及cache数组。验证的过程与挖矿类似，只是轻节点没有保存DAG中的元素，所以用到的部分需要从cache中重新计算生成。</p>
<h2 id="3-2智能合约"><a href="#3-2智能合约" class="headerlink" title="3.2智能合约"></a>3.2智能合约</h2><p>关于智能合约，其智能可以理解为是一段自动执行的代码，无需外界干预，自动自治进行，运行在以太坊虚拟机中；合约可以看作一个管家，一个&quot;自治代理&quot;，它拥有自己的账户，交易发生时自动执行一段代码。借用V神的话就是&quot;他们收到交易信息后就相当于被捅了一下，然后自动执行一段代码&quot;。</p>
<p>如果说区块链存储的是状态，那么智能合约就是用于状态转换的方式。它像是一个特别的时钟，把世界从同步转向异步。</p>
<p>智能合约的出现使得创建通证变得简单。Komhar公司曾给出过ERC20通证发行过程，大体可以表述为：一个项目通过智能合约创建通证，这个通证是实体资产或线上资产的价值表示物。投资者（用户）发起交易，向智能合约转入以太币（ETH），智能合约自动运转，在满足一定规则后，它向投资者账户转入相应数量的通证。这里的通证大多对应以太坊区块链之外的资产。因此，以太坊的出现对区块链技术转向数字资产做出了巨大贡献。</p>
<h2 id="3-3以太坊共识机制与GHOST协议"><a href="#3-3以太坊共识机制与GHOST协议" class="headerlink" title="3.3以太坊共识机制与GHOST协议"></a>3.3以太坊共识机制与GHOST协议</h2><p>在比特币系统中，只有在最长合法链上挖出来的区块才有出块奖励。这使得挖出分叉的节点不甘心放弃自己链，对于大的矿池来说，他很有可能不顾一切的去挖自己的链使他成为最长链。这样做的优点是便于确认区块的合法性，也在一定程度上避免了双花。但是对于以太坊来说，这样做并不合适。以太坊设有账户系统，可以杜绝双花，而且以太坊的平均出块时间设定为15秒，分叉也会成为常态。因此，以太坊引入了GHOST协议，目的是在出现分叉后及时合并。</p>
<p>GHOST协议的核心思想是对没有竞争成为最长合法链的区块也发放一定的出块奖励。同时下一&quot;代&quot;区块要包含所有的叔父区块，并得到1/32个出块奖励的额外报酬。为了防止在挖矿难度较低的时候产生叔父而不当获利，以太坊规定叔父必须是7代以内。并且叔父区块中的交易不执行，因此也不检查交易合法性，只检查这个区块是否符合挖矿难度。</p>
<p>GHOST协议一方面保证了分叉及时被合并，另一方面也减少了ASIC矿机挖矿的必要性，有利于维持分布式账本和区中心化的稳定。在回避ASIC的问题的问题上，以太坊另一个做法是每年都宣称自己即将从工作量证明转为权益证明，从而有效的将以太坊挖矿限制在GPU挖矿的级别。</p>
<h1 id="第4章-区块链的应用与Steemit博客"><a href="#第4章-区块链的应用与Steemit博客" class="headerlink" title="第4章 区块链的应用与Steemit博客"></a>第4章 区块链的应用与Steemit博客</h1><h2 id="4-1-区块链的性质"><a href="#4-1-区块链的性质" class="headerlink" title="4.1 区块链的性质"></a>4.1 区块链的性质</h2><p>想要将区块链投入应用，首先要明确区块链有什么用。有人总结区块链的性质总结为以下四条。</p>
<ol>
<li><p>第一，是不可篡改性。要修改一个区块中的数据，那么就要修改后面所有的所有区块。而共识机制的存在使得修改大量区块的成本极高，因此篡改几乎不可能实现。2018 年3 月，在网络零售集团京东发布的《区块链技术实践白皮书》中，京东认为，&quot;区块链技术（分布式账本）的三种应用场景是：跨主体协作，需要低成本信任，存在长周期交易链条。这三个应用场景所利用的都是区块链的不可篡改特性。多主体在一个不可篡改的账本上协作，降低了信任成本。区块链账本中存储的是状态，未被涉及的数据的状态不会发生变化，且越早前的数据越难被篡改，这使得它适用于长周期交易。&quot;</p>
</li>
<li><p>第二，是表示价值所需要的唯一性。比特币的出现使得数字世界中出现了一种不可复制的&quot;文件&quot;。腾讯CEO马化腾说&quot;区块链确实是一项具有创新性的技术，用数字化表达唯一性，区块链可以模拟现实中的实物唯一性。&quot;百度CEO 李彦宏说：&quot;区块链到来之后，可以真正使虚拟物品变得唯一，这样的互联网跟以前的互联网会是非常不一样的。&quot;</p>
</li>
<li><p>第三，是智能合约。智能合约的出现使区块链上可以进行更加复杂的交易，并且交易本身也不可篡改。在以太坊白皮书中，维塔利克写道：&quot;（合约）应被看成存在于以太坊执行环境中的&quot;自治代理&quot;，它拥有自己的以太坊账户，收到交易信息，它们就相当于被捅了一下，然后它就自动执行一段代码。&quot;</p>
</li>
<li><p>第四，是去中心自组织。在《去中心化应用》一书中，作者西拉杰·拉瓦尔（Siraj Raval）从两个维度看现有的互联网技术产品：一个维度是，在组织上是中心化的，还是去中心化的；另一个维度是，在逻辑上是中心化的，还是去中心化的。在他看来比特币在组织上是去中心化的，在逻辑上是集中的。</p>
</li>
</ol>
<p>根据这些性质，有人总结了五条区块链通向应用平台的可能路径。分别是通用类基础公链，功能类基础公链，行业类基础公链，联盟类基础公链，基础服务。在我看来，开发专用于某个功能的基础公链更可行，接下来通过Steemit来谈一谈区块链的应用。</p>
<h2 id="4-2-Steemit"><a href="#4-2-Steemit" class="headerlink" title="4.2 Steemit"></a>4.2 Steemit</h2><p>Steemit是基于steem公链平台的社交软件，类似于博客。可以通过发文章，写评论来赚钱，但没人直接付钱。这个平台促进内容生产者发布更加优质的内容，同时屏蔽掉劣质内容。</p>
<p>Steem链中有三种代币，分别是steem，steem power,steem dollar。其中，Steem币是Steem链的基础代币。Steem Power 相当于股权，只能持有不能买卖。Steem Dollar是公链中稳定代币，无论何时，SBD只能兑换成价值一美元的Steem币，维持内部代币价格稳定。</p>
<p>当作者发布一篇文章时，并不马上得到收益。其收益真正来源于持有SP用户的点赞，这点类似于EOS的权益证明。拥有SP越多的用户点赞带来的收益也越多，同时点赞用户也会得到一部分收益，类似于矿工打包交易时的得到的手续费。此外，SP用户还可点踩，当点踩的人足够多时，Steemit会隐藏这些内容。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，区块链很有可能成为互联网上的新层次，专门用于进行价值表示和价值转移。 在其上可以建立区块链应用，以利用区块链的价值表示和价值转移特性，在链上进行数字资产的转移。同时这些数字资产被映射成链上原生资产，线上资产或线下资产，从而改变目前人类的生成生活方式，影响金融、军事、教育乃至生活的方方面面。</p>
<p>通过本次大作业的机会，我充分学习了关于区块链的内容。区块链的诸多性质中，去中心化的性质尤其吸引我。在中心化的网络中，我们的数据是不安全的，每天倡导安全的组织却能轻易掌握我们的数据；我们的思想可能是被蓄意引导的；努力工作得到的货币也未必是保值的；同时，离开中心我们也是生存不下去的。也许去中心化的系统中存在着混乱，比如区块链中的分叉，但是我认为混乱也是一种自治，或许目前的去中心化的结构还不完善，性能还不够强大，但我相信在不远的将来，我们就可以在生活的方方面面感受到去中心后的便利。</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>巴比伦塔</title>
    <url>/2020/02/16/%E5%B7%B4%E6%AF%94%E4%BC%A6%E5%A1%94/</url>
    <content><![CDATA[<h1 id="UVA-437-巴比伦塔"><a href="#UVA-437-巴比伦塔" class="headerlink" title="UVA 437 巴比伦塔"></a>UVA 437 巴比伦塔</h1><p>你可能已经听说过巴比伦塔的传说。现在这个传说的许多细节已经被遗忘。所以本着本场比赛的教育性质，我们现在会告诉你整个传说：</p>
<p>巴比伦人有n种长方形方块，每种有无限个，第i种方块的三边边长是xi,yi,zi。对于每一个方块，你可以任意选择一面作为底，这样高就随着确定了。举个例子，同一种方块，可能其中一个是竖着放的，一个是侧着放的，一个是横着放的。</p>
<p>他们想要用堆方块的方式建尽可能高的塔。问题是，只有一个方块的底的两条边严格小于另一个方块的底的两条边，这个方块才能堆在另一个上面。这意味着，一个方块甚至不能堆在一个底的尺寸与它一样的方块的上面。</p>
<p>你的任务是编写一个程序，计算出这个塔可以建出的最高的高度。</p>
<p>输入会包含至少一组数据，每组数据的第一行是一个整数n(n&lt;=30)，表示方块的种类数。 这组数据接下来的n行，每行有三个整数，表示xi,yi,zi。 输入数据会以0结束。</p>
<p>对于每组数据，输出一行，其中包含组号(从1开始)和塔最高的高度。按以下格式： Case : maximum height = __</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol start="3">
<li>每次决策的影响因素只有顶面尺寸</li>
<li>每次的顶面长宽都会严格减小，所以状态图是一个有向无环图，所以问题转换成了求DAG上的最长路径问题</li>
<li>关于状态的存储。如果使用(a,b)表示顶面面积a*b，由于ab可能很大是，所以不可行；如果用(idx,k)表示以第idx号立方体的第k号边为高，则可行。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="get-wl-将以b号边为高的第a号矩形的长宽填入数组v"><a href="#get-wl-将以b号边为高的第a号矩形的长宽填入数组v" class="headerlink" title="get_wl 将以b号边为高的第a号矩形的长宽填入数组v"></a>get_wl 将以b号边为高的第a号矩形的长宽填入数组v</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void get_wl(int *v, int a, int b) &#123;&#x2F;&#x2F;将长宽填入数组</span><br><span class="line">	int idx &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 3; i++)</span><br><span class="line">		if (i !&#x3D; b)</span><br><span class="line">			v[idx++] &#x3D; block[a][i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dp-尝试填充d数组"><a href="#dp-尝试填充d数组" class="headerlink" title="dp 尝试填充d数组"></a>dp 尝试填充d数组</h2><p>d[i][j]表示以第i个立方体的第j条边，能达到的最大高度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int dp(int i, int j) &#123;</span><br><span class="line">	int &amp;ans &#x3D; d[i][j];</span><br><span class="line">	if (ans &gt; 0)  return ans;</span><br><span class="line">	ans &#x3D; 0;</span><br><span class="line">	int v1[2], v2[2];</span><br><span class="line">	get_wl(v1, i, j);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; 3; j++) &#123;</span><br><span class="line">			get_wl(v2, i, j);</span><br><span class="line">			if (v1[0] &gt; v2[0] &amp;&amp; v1[1] &gt; v2[1])</span><br><span class="line">				ans &#x3D; max(ans, dp(i, j));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans +&#x3D; block[i][j];</span><br><span class="line">	return ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	int kase &#x3D; 0;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 3; j++)</span><br><span class="line">				scanf(&quot;%d&quot;, &amp;block[i][j]);</span><br><span class="line">			sort(block[i], block[i] + 3);</span><br><span class="line">		&#125;</span><br><span class="line">		memset(d, 0, sizeof(d));</span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 3; j++)</span><br><span class="line">				ans &#x3D; max(ans, dp(i, j));</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;Case %d: maximum height &#x3D; %d\n&quot;, ++kase, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>旅行</title>
    <url>/2020/02/16/%E6%97%85%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="UV1-1347-旅行"><a href="#UV1-1347-旅行" class="headerlink" title="UV1 1347 旅行"></a>UV1 1347 旅行</h1><p>John Doe想用最小的路程游览完所有目的地。每个目的地都用坐标xi,yi表示。任何两目的地的xi都不相同。两目的地之间的路程是两点之间的直线距离。John是这样走的：他从最左边的点开始，然后只能向右走，走到最右边的点，然后他只能向左走，回到最开始的点。每个点都要走到，并且除了出发点以外每个点只能经过一次。</p>
<p>请写出一个程序求符合要求的最小路程。</p>
<p>输入： 每组数据有很多组。每组第一行的数是这一组的点数。接下来每一行代表一个点，左边是xi，右边是yi。这些行表示的点的xi是升序的。空格会在输入中随意出现。输入数据是正确的。</p>
<p>输出： 每组数据的答案占一行，答案在小数点后保留两位。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>用d(i,j)表示1~max(i,j)全部走过，且两个人的当前位置分别是i和j，还需要走多长的距离。dp(i,j)==dp(j,i)，所以规定i&gt;j</li>
<li>在每个状态下的决策是让谁走出一步</li>
<li>因为不能走相同的点，所以不管是哪个人，下一步只能走i+1,i+2,i+3…但是如果一个人走到i+2，那么就变成了1~i和i+2被走过，那么i+1没走过就无法表示成状态，因此规定只允许其中一个人走到i+1。因此状态d(i,j)只能转移到d(i+1,j)和d(i+1,i)。</li>
<li>这样规定不会丢失解，因为如果第一个人走到i+2个点，那么只能让第二个人走到第i+1个点，因此，先择让第二个人走到i+1个点不会丢解</li>
<li>边界条件：d(n-1,j) = dist(n-1,n)+dist(j,n)，其中dist(a,b)表示a,b之间的距离</li>
<li>所求结果是dist(1,2)+d(2,1)。这是因为第一步一定是某个人走到的第二个点，根据规定即d(2,1)</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 50 + 5;</span><br><span class="line">double x[maxn], y[maxn], dist[maxn][maxn], d[maxn][maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%lf%lf&quot;, &amp;x[i], &amp;y[i]);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">				dist[i][j] &#x3D; sqrt((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]));</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; n - 1; i &gt;&#x3D; 2; i--)</span><br><span class="line">			for (int j &#x3D; 1; j &lt; i; j++) &#123;</span><br><span class="line">				if (i &#x3D;&#x3D; n - 1) d[i][j] &#x3D; dist[i][n] + dist[j][n]; &#x2F;&#x2F; 边界</span><br><span class="line">				else d[i][j] &#x3D; min(dist[i][i + 1] + d[i + 1][j], dist[j][i + 1] + d[i + 1][i]);</span><br><span class="line">			&#125;</span><br><span class="line">		printf(&quot;%.2lf\n&quot;, dist[1][2] + d[2][1]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>单向TSP</title>
    <url>/2020/02/16/%E5%8D%95%E5%90%91TSP/</url>
    <content><![CDATA[<h1 id="UVA-116-单向TSP"><a href="#UVA-116-单向TSP" class="headerlink" title="UVA 116 单向TSP"></a>UVA 116 单向TSP</h1><p>给一个m行n列（m≤10，n≤100）的整数矩阵，从第一列任何一个位置出发每次往右、右上、右下走一格，最终到达最后一列。要求经过的整数之和最小。整个矩阵是环形的，即第一行的上一行是最后一行，最后一行的下一行是第一行。输出路径上每列的行号。多解时输出字典序最小的。</p>
<p>输入：有若干组数据：每组的第1行：m和n，分别为行数和列数。每组的第2~m+1行：每行n个数，用空格分开，代表整数矩阵。</p>
<p>输出：每组有两行，第一行是每列的行号，第二行是路径的经过的整数之和。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>定义dp(i,j)为从(i,j)格除法到最后一行的最小开销。易知边界条件为dp(r-1,j) = a[r-1][j]，因此从后往前遍历，即从底边走到顶边</li>
<li>关于决策：在每一种状态dp，可能的方案有，直行，右上和右下</li>
<li>计算dp(i,j)的过程中要同时记录下一刻的行号的最小值(保证最优的条件下)。并记录达到顶边时最小的开销对应的列号列号</li>
<li>最终的答案是依据next中记录的路径进行遍历得到</li>
<li>是一个多阶段决策问题，每一列是一个阶段，每个阶段都有3种决策。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">int p[maxn][maxn];</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line">int next[maxn][maxn];</span><br><span class="line">#define inf 10000000</span><br><span class="line">int main() &#123;</span><br><span class="line">	int r, c;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;r, &amp;c) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++)</span><br><span class="line">			for (int j &#x3D; 0; j &lt; c; j++)</span><br><span class="line">				scanf(&quot;%d&quot;, &amp;p[i][j]);</span><br><span class="line"></span><br><span class="line">		int ans &#x3D; inf, first &#x3D; 0;</span><br><span class="line">		for (int j &#x3D; c - 1; j &gt;&#x3D; 0; j--) &#123; &#x2F;&#x2F;注意逆序</span><br><span class="line">			for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">				if (j &#x3D;&#x3D; c - 1) dp[i][j] &#x3D; p[i][j];&#x2F;&#x2F;边界</span><br><span class="line">				else &#123;</span><br><span class="line">					int row[3] &#x3D; &#123; i,i - 1 ,i + 1 &#125;;&#x2F;&#x2F;此处比较细节</span><br><span class="line">					if (i &#x3D;&#x3D; 0) row[1] &#x3D; r - 1;</span><br><span class="line">					if (i &#x3D;&#x3D; r - 1) row[2] &#x3D; 0;</span><br><span class="line">					sort(row, row + 3);&#x2F;&#x2F;为了字典序</span><br><span class="line"></span><br><span class="line">					dp[i][j] &#x3D; inf;</span><br><span class="line">					for (int k &#x3D; 0; k &lt; 3; k++) &#123;</span><br><span class="line">						int nv &#x3D; dp[row[k]][j + 1] + p[i][j];</span><br><span class="line">						if (nv &lt; dp[i][j]) &#123;&#x2F;&#x2F;填充dp，记录后继点</span><br><span class="line">							dp[i][j] &#x3D; nv;</span><br><span class="line">							::next[i][j] &#x3D; row[k];</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				if (j &#x3D;&#x3D; 0 &amp;&amp; dp[i][j] &lt; ans) &#123;&#x2F;&#x2F;更新答案，记录路径起始点</span><br><span class="line">					ans &#x3D; dp[i][j];</span><br><span class="line">					first &#x3D; i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;%d&quot;, first + 1);</span><br><span class="line">		for (int i &#x3D; ::next[first][0], j &#x3D; 1; j &lt; c; i &#x3D; ::next[i][j], j++)</span><br><span class="line">			printf(&quot; %d&quot;, i + 1);</span><br><span class="line">		printf(&quot;\n%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>劲歌金曲</title>
    <url>/2020/02/16/%E5%8A%B2%E6%AD%8C%E9%87%91%E6%9B%B2/</url>
    <content><![CDATA[<h1 id="UVA-12563-劲歌金曲"><a href="#UVA-12563-劲歌金曲" class="headerlink" title="UVA 12563 劲歌金曲"></a>UVA 12563 劲歌金曲</h1><p>(如果当你看到这个标题的时候笑了，那么这个问题是为你准备的ヽ(￣▽￣)ﾉ)<br>如果问一个麦霸：“你在KTV里必唱的曲目有哪些？”得到的答案通常都会包含一首“神曲”：古巨基的《劲歌金曲》。为什么呢？一般来说，KTV不会在“时间到”的时候鲁莽地把正在唱的歌切掉，而是会等它放完。例如：在还有15秒时再唱一首2分钟的歌，则实际上多唱了105秒。但是融合了37首歌曲的《劲歌金曲》长达11分18秒，如果唱这首，则相当于多长了663秒！<br>假设你正在唱KTV，还剩t秒时间。你决定接下来只唱你最爱的n首歌（不含《劲歌金曲》）中的一些，在时间结束之前再唱一个《劲歌金曲》，使得唱的总曲目尽量多（包含《劲歌金曲》），在此前提下尽量晚的离开KTV。<br>输入n(n&lt;=50)，t(t&lt;=10的9次方)和每首歌的长度(保证不超过3分钟)，输出唱的总曲目以及时间总长度。输入保证所有n+1首曲子的总长度严格大于t。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>0-1背包问题</li>
<li>设f[i]表示t容量的包内(时间内)总体积为i时，物品的数量(歌的数量),可以在每次输入新的歌曲时，更新那些能够“装下”这首歌的状态。</li>
<li>注意最后要留一秒来唱劲歌金曲</li>
<li>做的时候蒙住了。f[t-1]不一定是所有状态下的最大值，因为可能达不到刚好装满t-1的状态</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 50 + 5;</span><br><span class="line">const int INF &#x3D; 1000000000;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; d[i][j]: maximal number of songs from first i songs, whose total length is exactly j</span><br><span class="line">int f[maxn * 180 + 678];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	int n, t, ti;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	for (int kase &#x3D; 1; kase &lt;&#x3D; T; kase++) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;n, &amp;t);</span><br><span class="line">		memset(f, -1, sizeof(f));</span><br><span class="line">		f[0] &#x3D; 0;</span><br><span class="line">		for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;ti);</span><br><span class="line">			for (int j &#x3D; t - 1; j &gt;&#x3D; ti; j--)</span><br><span class="line">				f[j] &#x3D; max(f[j], f[j - ti] + 1);</span><br><span class="line">		&#125;</span><br><span class="line">		int ans &#x3D; t - 1;</span><br><span class="line">		for (int i &#x3D; t - 1; i &gt;&#x3D; 0; i--)&#123;</span><br><span class="line">			if (f[i] &gt; f[ans])</span><br><span class="line">				ans &#x3D; i;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line">		printf(&quot;Case %d: %d %d\n&quot;, kase, f[ans] + 1, ans + 678);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="附上刘老师的代码"><a href="#附上刘老师的代码" class="headerlink" title="附上刘老师的代码"></a>附上刘老师的代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int maxn &#x3D; 50 + 5;</span><br><span class="line">const int INF &#x3D; 1000000000;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; d[i][j]: maximal number of songs from first i songs, whose total length is exactly j</span><br><span class="line">int n, t, len[maxn], d[2][maxn*180+678]; </span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int T;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">  for(int kase &#x3D; 1; kase &lt;&#x3D; T; kase++) &#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;t);</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;len[i]);</span><br><span class="line"></span><br><span class="line">    for(int i &#x3D; 0; i &lt; t; i++) d[0][i] &#x3D; -1;</span><br><span class="line">    d[0][0] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    int p &#x3D; 1, ans &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">      for(int j &#x3D; 0; j &lt; t; j++) &#123;</span><br><span class="line">        d[p][j] &#x3D; d[p^1][j];</span><br><span class="line">        if(j &gt;&#x3D; len[i] &amp;&amp; d[p^1][j - len[i]] &gt;&#x3D; 0)</span><br><span class="line">          d[p][j] &#x3D; max(d[p][j], d[p^1][j - len[i]] + 1);</span><br><span class="line">        ans &#x3D; max(ans, d[p][j]);</span><br><span class="line">      &#125;</span><br><span class="line">      p ^&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i &#x3D; t-1; i &gt;&#x3D; 0; i--)</span><br><span class="line">      if(d[p^1][i] &#x3D;&#x3D; ans) &#123;</span><br><span class="line">        printf(&quot;Case %d: %d %d\n&quot;, kase, ans + 1, i + 678);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>照明系统设计</title>
    <url>/2020/02/16/%E7%85%A7%E6%98%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="UVA-11400-照明系统设计"><a href="#UVA-11400-照明系统设计" class="headerlink" title="UVA 11400 照明系统设计"></a>UVA 11400 照明系统设计</h1><p>题意: 给定n(n≤1000)种类型灯泡，每个灯泡给出其电压v(v≤132000)，电源花费k(k≤1000)，每个灯的花费c(c≤10) 和需求量l(1≤l≤100)l。现在通过用电压大的灯泡替换某些电压小的灯泡来减小总花费，求最小的花费。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>首先有结论，每种电压的灯泡要么全换，要么全部不换。这是因为，如果因为换1个降低成本，那么换2个也降低成本…全换了还剩一个电源钱，就很棒。</li>
<li>其次，由于题干要求只能换成电压更大的灯泡，所以先将所有种类的灯泡按电压从小到大排序。顺次遍历，对于更大电压的灯泡，依次尝试替换比他电压小的灯泡，更新状态。</li>
<li>设d(i)表示灯泡1~i的最小开销</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">struct Lamp &#123;</span><br><span class="line">	int v, k, c, l;</span><br><span class="line">	bool operator &lt; (const Lamp&amp;x)const &#123; return v &lt; x.v; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Lamp lamp[maxn];</span><br><span class="line">int d[maxn];</span><br><span class="line">int s[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d%d%d%d&quot;, &amp;lamp[i].v, &amp;lamp[i].k, &amp;lamp[i].c, &amp;lamp[i].l);</span><br><span class="line"></span><br><span class="line">		sort(lamp + 1, lamp + 1 + n);</span><br><span class="line">		s[0] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) s[i] &#x3D; s[i - 1] + lamp[i].l;</span><br><span class="line">		d[0] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			d[i] &#x3D; s[i] * lamp[i].c + lamp[i].k; </span><br><span class="line">			for (int j &#x3D; 1; j &lt;&#x3D; i; j++)</span><br><span class="line">				d[i] &#x3D; min(d[i], d[j] + (s[i] - s[j]) * lamp[i].c + lamp[i].k);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; d[n] &lt;&lt; &quot;\n&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>划分成回文串</title>
    <url>/2020/02/16/%E5%88%92%E5%88%86%E6%88%90%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="UVA-11584-划分成回文串"><a href="#UVA-11584-划分成回文串" class="headerlink" title="UVA 11584 划分成回文串"></a>UVA 11584 划分成回文串</h1><p>当一个字符串正序和反序是完全相同时，我们称之为“回文串”。例如“racecar”就是一个回文串，而“fastcar”就不是。现在给一个字符串s，把它分割成若干个互不相交的回文子串，求分割的回文子串的最少个数。</p>
<p>第一行为正整数t(≤10)，表示数据组数；接下来t行，每行一个完全由小写字母组成的字符串，长度不超过1000。</p>
<p>对于每组数据，输出最少回文子串数。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>设d[i]表示在i之前最少能构成多少回文串</li>
<li>要做的是对于每个i，在0-i中寻找j，使得[j+1,i]是个回文串。对于合法的j，更新d[i]，d[i] = min(d[i], d[j] + 1)。</li>
<li>判断回文串可以采用递归的方法</li>
<li>注意一些初值的选择</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000+5;</span><br><span class="line">char s[maxn];</span><br><span class="line">int vis[maxn][maxn];</span><br><span class="line">int p[maxn][maxn];</span><br><span class="line">int d[maxn];</span><br><span class="line">bool is_pali(int l, int r) &#123;</span><br><span class="line">	if (l &gt;&#x3D; r) return true;</span><br><span class="line">	if (s[l] !&#x3D; s[r]) return false;</span><br><span class="line">	if (vis[l][r]) return p[l][r];</span><br><span class="line"></span><br><span class="line">	vis[l][r] &#x3D; 1;</span><br><span class="line"></span><br><span class="line">	p[l][r] &#x3D; is_pali(l + 1, r - 1);</span><br><span class="line">	return p[l][r];</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%s&quot;, s + 1);</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		d[0] &#x3D; 0;</span><br><span class="line">		int n &#x3D; strlen(s + 1);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			d[i] &#x3D; i + 1; &#x2F;&#x2F;至多就是前面每个字符自己是一个回文串</span><br><span class="line">			for (int j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">				if (is_pali(j+1, i))</span><br><span class="line">					d[i] &#x3D; min(d[i], d[j] + 1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, d[n]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>颜色的长度</title>
    <url>/2020/02/16/%E9%A2%9C%E8%89%B2%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="UVA-1625-颜色的长度"><a href="#UVA-1625-颜色的长度" class="headerlink" title="UVA 1625 颜色的长度"></a>UVA 1625 颜色的长度</h1><p>输入两个长度分别是n和m(n,m&lt;=5000)的颜色序列，要求按顺序合并成同一个序列，即每次可以把一个序列开头的颜色放到新序列的尾部。</p>
<p>例如，两个颜色序列GBBY和YRRGB，至少有两种合并结果：GBYBRYRGB和YRRGGBBYB。对于每种颜色来说其跨度L(c)等于最大位置和最小位置之差。例如，对于上面两种合并结果，每种颜色的L(c)和所有L(c)的总和如图</p>
<p><img src="/img_UVA%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/9.png" alt=""></p>
<p>你的任务是找一种合并方式，使得所有L(c)的总和最小</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>收到lcs的启发，考虑使用d[i][j]来表示第一个序列使用了前i个字符，第j个序列使用了前j个字符时的最小花费。问题在于，如果每次更新的时候屈计算l(c)会导致时间复杂度过高。</li>
<li>关于L(c)的计算：需要知道的刚刚移入最终序列的字符是否已经全部用完，并且要知道他最早在最终序列中出现的位置。如果记录每个颜色第一次出现的位置，状态会变得很复杂。所以尝试转换思路，不是等一个颜色全部移完再计算。而是每次累加。即，当把一个颜色移动到最终序列前，需要把所有已经出现但是还没结束的颜色的L(c)+1。也就是说，并不关心每种颜色的L(c)，只需要知道有多少种颜色已经开始但尚未结束</li>
<li>欲实现上述操作，则需要记录每种元素(26个大写字母)第一次和最后一次出现的位置</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000;</span><br><span class="line">#define inf 1000000</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line">int much[maxn][maxn];&#x2F;&#x2F;记录[i][j]状态下总的L(c)</span><br><span class="line">char ts[2][maxn];	&#x2F;&#x2F;输入字符串</span><br><span class="line">int s[2][maxn];		&#x2F;&#x2F;输入字符串-&#39;A&#39;</span><br><span class="line">int first[2][26];	&#x2F;&#x2F;每个颜色第一次出现的位置</span><br><span class="line">int last[2][26];	&#x2F;&#x2F;每个颜色最后一次出现的位置</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d\n&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%s\n%s\n&quot;, ts[0] + 1, ts[1] + 1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		int len1 &#x3D; strlen(ts[0] + 1);</span><br><span class="line">		int len2 &#x3D; strlen(ts[1] + 1);</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; len1; i++) s[0][i] &#x3D; ts[0][i] - &#39;A&#39;;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; len2; i++) s[1][i] &#x3D; ts[1][i] - &#39;A&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; 2; i++)</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 26; j++) &#123;</span><br><span class="line">				first[i][j] &#x3D; inf;</span><br><span class="line">				last[i][j] &#x3D; -1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; 2; i++) &#123;</span><br><span class="line">			int len &#x3D; strlen(ts[i] + 1);</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 26; j++) &#123;</span><br><span class="line"></span><br><span class="line">				for (int k &#x3D; 1; k &lt;&#x3D; len; k++)</span><br><span class="line">					if (s[i][k] &#x3D;&#x3D; j) &#123;</span><br><span class="line">						first[i][j] &#x3D; k;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				for (int k &#x3D; len; k &gt;&#x3D; 1; k--)</span><br><span class="line">					if (s[i][k] &#x3D;&#x3D; j) &#123;</span><br><span class="line">						last[i][j] &#x3D; k;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dp过程"><a href="#dp过程" class="headerlink" title="dp过程"></a>dp过程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">much[0][0] &#x3D; 0;</span><br><span class="line">		dp[0][0] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt;&#x3D; len1; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt;&#x3D; len2; j++) &#123;</span><br><span class="line">				if (!i &amp;&amp; !j) continue;</span><br><span class="line">				dp[i][j] &#x3D; inf;</span><br><span class="line">				if (i) &#123;&#x2F;&#x2F;d[i][j]可能是由d[i-1][j]从第一个串中取一个元素而来</span><br><span class="line">					dp[i][j] &#x3D; min(dp[i][j], dp[i - 1][j] + much[i - 1][j]);</span><br><span class="line"></span><br><span class="line">					&#x2F;&#x2F;判断s1[i]是否是已经出现但尚未用完的元素</span><br><span class="line">					much[i][j] &#x3D; much[i - 1][j];</span><br><span class="line">					int c &#x3D; s[0][i];</span><br><span class="line">					if (i &#x3D;&#x3D; first[0][c] &amp;&amp; j &lt; first[1][c])&#x2F;&#x2F;是第一次出现，则+1</span><br><span class="line">						much[i][j]++;</span><br><span class="line">					if (i &#x3D;&#x3D; last[0][c] &amp;&amp; j &gt;&#x3D; last[1][c])&#x2F;&#x2F;是最后一次出现，则-1</span><br><span class="line">						much[i][j]--;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">				if (j) &#123;&#x2F;&#x2F;与上述对称</span><br><span class="line">					dp[i][j] &#x3D; min(dp[i][j], dp[i][j - 1] + much[i][j - 1]);</span><br><span class="line">					much[i][j] &#x3D; much[i][j - 1];</span><br><span class="line">					int c &#x3D; s[1][j];</span><br><span class="line"></span><br><span class="line">					if (i &lt; first[0][c] &amp;&amp; j &#x3D;&#x3D; first[1][c])</span><br><span class="line">						much[i][j]++;</span><br><span class="line">					if (i &gt;&#x3D; last[0][c] &amp;&amp; j &#x3D;&#x3D; last[1][c])</span><br><span class="line">						much[i][j]--;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;%d\n&quot;, dp[len1][len2]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>理想路径</title>
    <url>/2020/02/16/%E7%90%86%E6%83%B3%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="UVA-1599-理想路径"><a href="#UVA-1599-理想路径" class="headerlink" title="UVA 1599 理想路径"></a>UVA 1599 理想路径</h1><p>给定一个n个点m条边的无向图，每条边上都涂有1种颜色。求11到点n的一条路径，使得经过的边数最少，在此前提下，经过边的颜色序列最小。可能有自环与重边。输入保证至少存在一条连接1和n的道路。</p>
<p>输入共m+1行：</p>
<p>第一行2个空格整数：n和m</p>
<p>以后m行，每行空格隔开的3个整数ai,bi,ci表示在ai,bi之间有一条颜色为ci的道路。</p>
<p>输出路径序列</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>整体来说，还是无向图最短路问题，使用bfs求解。</li>
<li>问题在于路径选择需要选择字典序最小的序列，而bfs过程中并不能知道哪条路是最短的，所以无法一次性求解。</li>
<li>解决方法是从n点开始bfs，记录到其余各点的最小距离。之后再从头进行一次bfs，每次只走距离n点距离恰好减一的点走，并在其中选择字典序最小的走，这样一定走的是最短路，并且路径字典序最小。</li>
<li>为了减少队列占用的空间，实现是队列中存的是边的序号，应该关注这种写法</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="addEdge-给新加入的边一个序号"><a href="#addEdge-给新加入的边一个序号" class="headerlink" title="addEdge 给新加入的边一个序号"></a>addEdge 给新加入的边一个序号</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;edge&gt; E;</span><br><span class="line">vector&lt;int&gt; g[maxn];</span><br><span class="line">void addEdge(int u, int v, int w) &#123;</span><br><span class="line">	E.push_back(edge(u, v, w));</span><br><span class="line">	int size &#x3D; E.size() - 1;</span><br><span class="line">	g[u].push_back(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bfs-end-从尾部开始的bfs，常规"><a href="#bfs-end-从尾部开始的bfs，常规" class="headerlink" title="bfs_end 从尾部开始的bfs，常规"></a>bfs_end 从尾部开始的bfs，常规</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool vis[maxn];</span><br><span class="line">int d[maxn];</span><br><span class="line">void bfs_end() &#123;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	d[n] &#x3D; 0;</span><br><span class="line">	vis[n] &#x3D; 1;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	q.push(n);</span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		int u &#x3D; q.front(); q.pop();</span><br><span class="line">		for (int i : g[u]) &#123;</span><br><span class="line">			int v &#x3D; E[i].b;</span><br><span class="line">			if (!vis[v])</span><br><span class="line">			&#123;</span><br><span class="line">				vis[v] &#x3D; 1;</span><br><span class="line">				d[v] &#x3D; d[u] + 1;</span><br><span class="line">				q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bfs-sta-从正向开始bfs"><a href="#bfs-sta-从正向开始bfs" class="headerlink" title="bfs_sta 从正向开始bfs"></a>bfs_sta 从正向开始bfs</h2><p>此处tmp中包含了字典序最小的点，只有当真正走出这一步时，vis[i]才置1(即入队的时候)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; ans;</span><br><span class="line">void bfs_sta() &#123;</span><br><span class="line">	ans.clear();</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	vis[1] &#x3D; 1;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	q.push(1);</span><br><span class="line">	vector&lt;int&gt; tmp;</span><br><span class="line">	int minn;</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		minn &#x3D; inf;</span><br><span class="line">		tmp.clear();</span><br><span class="line">		while (!q.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			int u &#x3D; q.front(); q.pop();</span><br><span class="line">			if (u &#x3D;&#x3D; n) return;</span><br><span class="line">			for (int i : g[u]) &#123;</span><br><span class="line">				int v &#x3D; E[i].b;</span><br><span class="line">				if (d[v] &#x3D;&#x3D; d[u] - 1) &#123;</span><br><span class="line">					if (E[i].w &lt;&#x3D; minn) &#123;</span><br><span class="line">						minn &#x3D; E[i].w;</span><br><span class="line">						tmp.push_back(i);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ans.push_back(minn);</span><br><span class="line"></span><br><span class="line">		for (int i : tmp) &#123;</span><br><span class="line">			int v &#x3D; E[i].b;</span><br><span class="line">			if (!vis[v] &amp;&amp; E[i].w &#x3D;&#x3D; minn) &#123;</span><br><span class="line">				q.push(v);</span><br><span class="line">				vis[v] &#x3D; 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100000 + 5;</span><br><span class="line">#define inf 1000000000</span><br><span class="line">int n, m;</span><br><span class="line">struct edge &#123;</span><br><span class="line">	int a;</span><br><span class="line">	int b;</span><br><span class="line">	int w;</span><br><span class="line">	edge(int a, int b, int w) :a(a), b(b), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &#x3D;&#x3D; 2) &#123;</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) g[i].clear();</span><br><span class="line">		E.clear();</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			int u, v, w;</span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">			addEdge(u, v, w);</span><br><span class="line">			addEdge(v, u, w);</span><br><span class="line">		&#125;</span><br><span class="line">		bfs_end();</span><br><span class="line">		bfs_sta();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		printf(&quot;%d\n%d&quot;, ans.size(), ans[0]);</span><br><span class="line">		for (int i &#x3D; 1; i &lt; ans.size(); i++)</span><br><span class="line">			printf(&quot; %d&quot;, ans[i]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>城市里的间谍</title>
    <url>/2020/02/16/%E5%9F%8E%E5%B8%82%E9%87%8C%E7%9A%84%E9%97%B4%E8%B0%8D/</url>
    <content><![CDATA[<h1 id="UVA-1025-城市里的间谍"><a href="#UVA-1025-城市里的间谍" class="headerlink" title="UVA 1025 城市里的间谍"></a>UVA 1025 城市里的间谍</h1><p>某城市地铁是线性的,有n（2≤n≤50）个车站,从左到右编号1~n。有M1辆列车从第1站开始往右开,还有M2辆列车从第n站开始往左开。列车在相邻站台间所需的运行时间是固定的，因为所有列车的运行速度是相同的。在时刻0,Mario从第1站出发,目的在时刻T（0≤T≤200）会见车站n的一个间谍。在车站等车时容易被抓，所以她决定尽量躲在开动的火车上,让在车站等待的时间尽量短。列车靠站停车时间忽略不计,且Mario身手敏捷,即时两辆方向不同的列车在同一时间靠站,Mario也能完成换乘。 【输入格式】 输入文件包含数种情况，每一种情况包含以下7行：</p>
<p>第一行是一个正整数n，表示有n个车站 第二行是为T，表示Mario在时刻T见车站n的间谍 第三行有n-1个整数t1,t2,…,tn-1,其中ti表示地铁从车站i到i+1的行驶时间 第四行为M1，及从第一站出发向右开的列车数目 第五行包含M1个正整数a1,a2,…,aM1，即个列车出发的时间 第六行为M2，及从第一站出发向右开的列车数目 第七行包含M2个正整数b1,b2,…,bM2，即个列车出发的时间</p>
<p>最后一种情况以一行0结尾。</p>
<p>输出最少等待时间，如果无解则输出impossible</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>时间自然有序，所以沿着时间轴考虑问题。在每一个时刻，决策的影响因素只有当前所处的站，所以用d(i,j)表示在时刻i，车站j，最少还需要等待多少时间。易知边界条件d(T,n) = 0，其他为正无穷</li>
<li>在每个点处，有三种决策<ol>
<li>等1分钟</li>
<li>搭乘往右开的车</li>
<li>搭乘往左开的车</li>
</ol>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 50 + 5;</span><br><span class="line">const int maxt &#x3D; 200 + 5;</span><br><span class="line">#define inf 1000000000</span><br><span class="line">int t[maxn];</span><br><span class="line">int havetrain[maxt][maxn][2];</span><br><span class="line">int dp[maxt][maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	int T;</span><br><span class="line">	int kase &#x3D; 0;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;n, &amp;T) &amp;&amp; n) &#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;t[i]);</span><br><span class="line">		memset(havetrain, 0, sizeof(havetrain));</span><br><span class="line">		int m1;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;m1);</span><br><span class="line">		int d;</span><br><span class="line">		while (m1--) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;d);</span><br><span class="line">			for (int j &#x3D; 1; j &lt; n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				if (d &lt;&#x3D; T)  havetrain[d][j][0] &#x3D; 1;</span><br><span class="line">				d +&#x3D; t[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int m2;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;m2);</span><br><span class="line">		while (m2--) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;d);</span><br><span class="line">			for (int j &#x3D; n - 1; j &gt;&#x3D; 1; j--)</span><br><span class="line">			&#123;</span><br><span class="line">				if (d &lt;&#x3D; T)  havetrain[d][j+1][1] &#x3D; 1;</span><br><span class="line">				d +&#x3D; t[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n-1; i++)	dp[T][i] &#x3D; inf;</span><br><span class="line"></span><br><span class="line">		dp[T][n] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; T - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">				dp[i][j] &#x3D; dp[i + 1][j] + 1;</span><br><span class="line">				if (j &lt; n &amp;&amp; havetrain[i][j][0] &amp;&amp; i + t[j] &lt;&#x3D; T)</span><br><span class="line">					dp[i][j] &#x3D; min(dp[i][j], dp[i + t[j]][j + 1]); &#x2F;&#x2F; 鍙?</span><br><span class="line">				if (j &gt; 1 &amp;&amp; havetrain[i][j][1] &amp;&amp; i + t[j - 1] &lt;&#x3D; T)</span><br><span class="line">					dp[i][j] &#x3D; min(dp[i][j], dp[i + t[j - 1]][j - 1]);	&#x2F;&#x2F;左</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;Case Number %d: &quot;, ++kase);</span><br><span class="line">		if (dp[0][1] &gt;&#x3D; inf) printf(&quot;impossible\n&quot;);</span><br><span class="line">		else printf(&quot;%d\n&quot;, dp[0][1]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>其他技巧</title>
    <url>/2020/02/13/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="标准模板库"><a href="#标准模板库" class="headerlink" title="标准模板库"></a>标准模板库</h1><h2 id="字符串匹配-北航"><a href="#字符串匹配-北航" class="headerlink" title="字符串匹配(北航)"></a>字符串匹配(北航)</h2><p>读入数据string[ ]，然后读入一个短字符串。要求查找string[ ]中和短字符串的所有匹配，输出行号、匹配字符串。匹配时不区分大小写，并且可以有一个用中括号表示的模式匹配。如“aa[123]bb”，就是说aa1bb、aa2bb、aa3bb都算匹配。</p>
<p>输入有多组数据。<br>每组数据第一行输入n(1&lt;=n&lt;=1000)，从第二行开始输入n个字符串（不含空格），接下来输入一个匹配字符串。</p>
<p>输出匹配到的字符串的行号和该字符串（匹配时不区分大小写）。</p>
<p><strong>注意[]会有多个即可</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1005;</span><br><span class="line">string in[maxn];</span><br><span class="line">vector&lt;string&gt; tep;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (cin &gt;&gt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			cin &gt;&gt; in[i];</span><br><span class="line">		string t;</span><br><span class="line">		cin &gt;&gt; t;</span><br><span class="line">		string s &#x3D; t;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; t.length(); i++)</span><br><span class="line">			s[i] &#x3D; tolower(t[i]);</span><br><span class="line"></span><br><span class="line">		tep.push_back(s);</span><br><span class="line">		int cnt &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; tep.size(); i++) &#123;</span><br><span class="line">			s &#x3D; tep[i];</span><br><span class="line">			int f1 &#x3D; s.find(&#39;[&#39;);</span><br><span class="line">			int f2 &#x3D; s.find(&#39;]&#39;);</span><br><span class="line">			if (f1 !&#x3D; -1) &#123;</span><br><span class="line">				string tp &#x3D; s.substr(f1+1, f2-f1-1);</span><br><span class="line">				cnt +&#x3D; tp.length();</span><br><span class="line">				t &#x3D; s.substr(0, f1);</span><br><span class="line">				s &#x3D; s.substr(f2 + 1);</span><br><span class="line">				for (int i &#x3D; 0; i &lt; tp.length(); i++)</span><br><span class="line">					tep.push_back(t + tp[i] + s);</span><br><span class="line">			&#125;</span><br><span class="line">			else break;</span><br><span class="line">		&#125;</span><br><span class="line">		if (!cnt) cnt &#x3D; 1;</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			t &#x3D; in[i];</span><br><span class="line">			for (int j &#x3D; tep.size()-cnt; j &lt; tep.size(); j++) &#123;</span><br><span class="line">				transform(in[i].begin(), in[i].end(), in[i].begin(), ::tolower);</span><br><span class="line">				if (in[i].find(tep[j]) !&#x3D; -1)</span><br><span class="line">				&#123;</span><br><span class="line">					cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h1><h2 id="手动读入int，double"><a href="#手动读入int，double" class="headerlink" title="手动读入int，double"></a>手动读入int，double</h2><h3 id="readint"><a href="#readint" class="headerlink" title="readint"></a>readint</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool readint(int &amp;ret) &#123;</span><br><span class="line">	int sgn;</span><br><span class="line">	char c;</span><br><span class="line">	c &#x3D; getchar();</span><br><span class="line">	if (c &#x3D;&#x3D; EOF) return false;</span><br><span class="line">	while (c !&#x3D; &#39;-&#39;&amp;&amp;c&lt;&#39;0&#39; || c&gt;&#39;9&#39;) c &#x3D; getchar();</span><br><span class="line">	sgn &#x3D; (c &#x3D;&#x3D; &#39;-&#39;) ? -1 : 1;</span><br><span class="line">	ret &#x3D; (c &#x3D;&#x3D; &#39;-&#39;) ? 0 : (c - &#39;0&#39;);</span><br><span class="line">	while ((c &#x3D; getchar()) &gt;&#x3D; &#39;0&#39;&amp;&amp;c &lt;&#x3D; &#39;9&#39;) ret &#x3D; ret * 10 + (c - &#39;0&#39;);</span><br><span class="line">	ret *&#x3D; sgn;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="readdouble"><a href="#readdouble" class="headerlink" title="readdouble"></a>readdouble</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool readdouble(double &amp;ret) &#123;</span><br><span class="line">	int sgn;</span><br><span class="line">	char c;</span><br><span class="line">	double bit &#x3D; 0.1;&#x2F;&#x2F;小数点后数位的权重</span><br><span class="line">	c &#x3D; getchar();</span><br><span class="line">	if (c &#x3D;&#x3D; EOF) return false;</span><br><span class="line">	while (c !&#x3D; &#39;-&#39;&amp;&amp;c&lt;&#39;0&#39; || c&gt;&#39;9&#39;) c &#x3D; getchar();</span><br><span class="line">	sgn &#x3D; (c &#x3D;&#x3D; &#39;-&#39;) ? -1 : 1;</span><br><span class="line">	ret &#x3D; (c &#x3D;&#x3D; &#39;-&#39;) ? 0 : (c - &#39;0&#39;);</span><br><span class="line">	while ((c &#x3D; getchar()) &gt;&#x3D; &#39;0&#39;&amp;&amp;c &lt;&#x3D; &#39;9&#39;) ret &#x3D; ret * 10 + (c - &#39;0&#39;);</span><br><span class="line">	if (c &#x3D;&#x3D; &#39; &#39; || c &#x3D;&#x3D; &#39;\n&#39;) &#123; ret *&#x3D; sgn; return true; &#125;&#x2F;&#x2F;不存在小数位</span><br><span class="line">	while ((c &#x3D; getchar()) &gt;&#x3D; &#39;0&#39;&amp;&amp;c &lt;&#x3D; &#39;9&#39;) ret +&#x3D; (c - &#39;0&#39;)*bit, bit &#x2F;&#x3D; 10;</span><br><span class="line">	ret *&#x3D; sgn;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="流氓剪枝"><a href="#流氓剪枝" class="headerlink" title="流氓剪枝"></a>流氓剪枝</h2><p>没啥理由的剪枝，以保证不超时</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2020/02/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="递推求解"><a href="#递推求解" class="headerlink" title="递推求解"></a>递推求解</h1><p>我理解为已知小规模解的递归</p>
<h2 id="N阶楼梯上楼问题"><a href="#N阶楼梯上楼问题" class="headerlink" title="N阶楼梯上楼问题"></a>N阶楼梯上楼问题</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>考虑最后一步，可以从n-2阶迈两步，或者从n-1阶迈一步。这样就将走法分成了两类，总的走法f(n)=f(n-1)+f(n-2)。而f(n-1)就是n-1阶时的走法，又可以分成两类，所以问题是一个递推问题</li>
<li>对于小规模的解，我们是知道的，f(1)=1,f(2)=2，所以递推得解</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">int f(int k) &#123;</span><br><span class="line">	if (k &#x3D;&#x3D; 1) return 1;</span><br><span class="line">	if (k &#x3D;&#x3D; 2) return 2;</span><br><span class="line">	return f(k - 1) + f(k - 2);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int k;</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;k)&#x3D;&#x3D;1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d\n&quot;, f(k));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HDU-1465-不容易系列之一"><a href="#HDU-1465-不容易系列之一" class="headerlink" title="HDU 1465 不容易系列之一"></a>HDU 1465 不容易系列之一</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>考虑n号信封里装着k号信，m号信封里装着n号信。按照k和m是否相等分成两类</p>
<ol>
<li>若k!=m，那么交换两封信后，除n号外，其余n-1封信都是错装。那么n号信有n-1中交换方式使得n号错序。此时f(n)=(n-1)*f(n-1)</li>
<li>若k==m，那么交换之后，有n-2封信错装。m有n-1种交换策略，此时，f(n)=(n-1)*f(n-2)</li>
<li>故<strong>错装公式：f(n)=(n-1)<em>f(n-1)+(n-1)</em>f(n-2)</strong><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">long long f(int n) &#123;</span><br><span class="line">	if (n &#x3D;&#x3D; 1) return 0;</span><br><span class="line">	if (n &#x3D;&#x3D; 2) return 1;</span><br><span class="line">	return (n - 1)*(f(n - 1) + f(n - 2));</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%lld\n&quot;, f(n));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="最长递增子序列-LIS"><a href="#最长递增子序列-LIS" class="headerlink" title="最长递增子序列 LIS"></a>最长递增子序列 LIS</h1><p>用F[i]代表若递增子序列以ai结束时它的最长长度,易知F[1]=1.现假设已知F[1]-F[x-1]，依次比较ax和ai(i&lt;x)，如果ax&lt;ai，那么ax可以接在ai后面，使得子序列长度加1。取这些长度的最大值即为F[x]</p>
<h2 id="拦截导弹"><a href="#拦截导弹" class="headerlink" title="拦截导弹"></a>拦截导弹</h2><p>某国为了防御敌国的导弹袭击，开发出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭，并观测到导弹依次飞来的高度，请计算这套系统最多能拦截多少导弹。拦截来袭导弹时，必须按来袭导弹袭击的时间顺序，不允许先拦截后面的导弹，再拦截前面的导弹。<br>求最多拦截导弹数量</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>本题求的是最长非递增子序列(不需连续)</li>
<li>对于第i个高度，可以将它加在它前面的比他大的序列末尾，并且保证加在最长的那条序列尾部即可</li>
<li>递推公式<ol>
<li>f[1] =1 </li>
<li>f[i] = max(1,f[j]+1) ;j&lt;i&amp;&amp;aj&gt;ai</li>
</ol>
</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 30;</span><br><span class="line">int p[maxn];</span><br><span class="line">int dp[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int k;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;k) &#x3D;&#x3D; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;p[i]);</span><br><span class="line">		fill(dp, dp + k, 0);</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">			int cnt &#x3D; 1;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; i; j++)</span><br><span class="line">				if (p[j] &gt;&#x3D; p[i])</span><br><span class="line">					cnt &#x3D; max(cnt, dp[j] + 1);</span><br><span class="line">			dp[i] &#x3D; cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		int ans &#x3D; 1;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; i++)</span><br><span class="line">			ans &#x3D; max(ans, dp[i]);</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合唱队形"><a href="#合唱队形" class="headerlink" title="合唱队形"></a>合唱队形</h2><p>给出k个同学的身高，问在位置不变的情况下，出队几名同学可以是队列呈现中间高两边低的状态</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol>
<li>分别从两侧求递增子序列，然后求同一位置处两侧序列和最长的，即为结果序列长度</li>
<li>假设第i人满足1中条件，那么第i个人被算了两次，别忘了减去</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100+5;</span><br><span class="line">int p1[maxn];</span><br><span class="line">int p2[maxn];</span><br><span class="line">int dp1[maxn];</span><br><span class="line">int dp2[maxn];</span><br><span class="line">int k;</span><br><span class="line">void update_dp(int* dp, const int*p) &#123;</span><br><span class="line">	fill(dp, dp + k, 0);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">		int cnt &#x3D; 1;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; i; j++)</span><br><span class="line">			if (p[j] &lt; p[i])</span><br><span class="line">				cnt &#x3D; max(cnt, dp[j] + 1);</span><br><span class="line">		dp[i] &#x3D; cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;k) &#x3D;&#x3D; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;p1[i]);</span><br><span class="line">			p2[k - i - 1] &#x3D; p1[i];</span><br><span class="line">		&#125;</span><br><span class="line">		update_dp(dp1, p1);</span><br><span class="line">		update_dp(dp2, p2);</span><br><span class="line"></span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">			if (ans &lt; dp1[i] + dp2[k-i-1])</span><br><span class="line">				ans &#x3D; dp1[i] + dp2[k-i-1];</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, k-ans+1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列 LCS"></a>最长公共子序列 LCS</h1><p>用dp[i][j]表示S1中前i个字符与S2中前j个字符分别组成的两个前缀字符串的最长公共子串，易知dp[0][j] = 0;递推公式为</p>
<ol>
<li>dp[0][j] = dp[i][0] = 0</li>
<li>dp[i][j] = dp[i-1][j-1]+1;S1[i]==S2[j]</li>
<li>dp[i][j] = max{dp[i][j-1],dp[i-1][j]};S1[i]!=S2[j]</li>
<li>最终dp[n][m]即为最长连续字串长</li>
<li>注意循环范围</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">char s1[maxn];</span><br><span class="line">char s2[maxn];</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line">int lcs(const char *s1, const char *s2) &#123;</span><br><span class="line">	memset(dp, 0, sizeof(dp));</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; strlen(s1); i++) &#123;</span><br><span class="line">		for (int j &#x3D; 1; j &lt;&#x3D; strlen(s2); j++) &#123;</span><br><span class="line">			if (s1[i-1] !&#x3D; s2[j-1])</span><br><span class="line">				dp[i][j] &#x3D; max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">			else</span><br><span class="line">				dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return dp[strlen(s1)][strlen(s2)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="状态与状态转移方程"><a href="#状态与状态转移方程" class="headerlink" title="状态与状态转移方程"></a>状态与状态转移方程</h1><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><ol>
<li>是一个数字量</li>
<li>可以描述一个状态的特征而不需要其他的辅助信息</li>
<li>状态间的转移完全依赖于状态本身</li>
</ol>
<h2 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h2><ol>
<li>指由一个或多个状态得到新状态的过程</li>
</ol>
<h1 id="动态规划问题举例"><a href="#动态规划问题举例" class="headerlink" title="动态规划问题举例"></a>动态规划问题举例</h1><h2 id="HDU-1421-搬寝室"><a href="#HDU-1421-搬寝室" class="headerlink" title="HDU 1421 搬寝室"></a>HDU 1421 搬寝室</h2><p>搬寝室是很累的,xhd深有体会.时间追述2006年7月9号,那天xhd迫于无奈要从27号楼搬到3号楼,因为10号要封楼了.看着寝室里的n件物品,xhd开始发呆,因为n是一个小于2000的整数,实在是太多了,于是xhd决定随便搬2<em>k件过去就行了.但还是会很累,因为2</em>k也不小是一个不大于n的整数.幸运的是xhd根据多年的搬东西的经验发现每搬一次的疲劳度是和左右手的物品的重量差的平方成正比(这里补充一句,xhd每次搬两件东西,左手一件右手一件).例如xhd左手拿重量为3的物品,右手拿重量为6的物品,则他搬完这次的疲劳度为(6-3)^2 = 9.现在可怜的xhd希望知道搬完这2*k件物品后的最佳状态是怎样的(也就是最低的疲劳度),请告诉他吧. </p>
<p>每组输入数据有两行,第一行有两个数n,k(2&lt;=2*k&lt;=n&lt;2000).第二行有n个整数分别表示n件物品的重量(重量是一个小于2^15的正整数).</p>
<p>对应每组输入数据,输出数据只有一个表示他的最少的疲劳度,每个一行.</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>设dp[i][j]表示前i件物品组成j对所消耗的体力最小；所以分成了两种情况</p>
<ol>
<li>第j对里含有第i件物品，则dp [i][j] = dp [i-2][j-1] + (a[i]-a[i-1])*(a[i]-a[i-1]);</li>
<li>不含第i件物品则有：dp [i][j] = dp [i-1][j];</li>
</ol>
</li>
<li><p>总上，动态转移方程为:dp[i][j]=min(dp[i-2][j-1]+(a[i]-a[i-1])*(a[i]-a[i-1]), dp[i][j]=dp[i-1][j]);</p>
</li>
</ol>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">int dp[2010][2010], a[2010];</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, k;</span><br><span class="line">	while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;k))</span><br><span class="line">	&#123;</span><br><span class="line">		int i, j;</span><br><span class="line">		memset(a, 0, sizeof(a));</span><br><span class="line">		memset(dp, 0, sizeof(dp));</span><br><span class="line">		for (i &#x3D; 0; i &lt;&#x3D; n; i++)</span><br><span class="line">			for (j &#x3D; 1; j &lt;&#x3D; k; j++)</span><br><span class="line">				dp[i][j] &#x3D; inf;</span><br><span class="line">		for (i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">		sort(a, a + n + 1);</span><br><span class="line">		for (i &#x3D; 2; i &lt;&#x3D; n; i++)</span><br><span class="line">			for (j &#x3D; 1; j * 2 &lt;&#x3D; i; j++)</span><br><span class="line">				dp[i][j] &#x3D; min(dp[i - 1][j], dp[i - 2][j - 1] + (a[i] - a[i - 1])*(a[i] - a[i - 1]));</span><br><span class="line">		printf(&quot;%d\n&quot;, dp[n][k]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HDU-3578-Greedy-Tino"><a href="#HDU-3578-Greedy-Tino" class="headerlink" title="HDU 3578 Greedy Tino"></a>HDU 3578 Greedy Tino</h2><p>未完待续</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define OFFSET 2000&#x2F;&#x2F;因为j有正负，所以添加一个偏移量，方便做题</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line">int wi[101];</span><br><span class="line">int dp[101][4001];</span><br><span class="line">int max(int a, int b, int c)&#123;</span><br><span class="line">    int flag &#x3D; a;</span><br><span class="line">    if(flag &lt; b)&#123;</span><br><span class="line">        flag &#x3D; b;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag &lt; c)&#123;</span><br><span class="line">        flag &#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i&#x3D;0;i&lt;40001;i++)</span><br><span class="line">            dp[0][i] &#x3D; -INF;</span><br><span class="line">    dp[0][OFFSET] &#x3D; 0;&#x2F;&#x2F;core</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t, n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; t; i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        wi[0] &#x3D; 0;</span><br><span class="line">         bool hasZero &#x3D; false;</span><br><span class="line">        int cnt &#x3D; 0;</span><br><span class="line">        for(int j &#x3D; 0; j &lt; n; j++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;wi[++cnt]);</span><br><span class="line">            if(wi[cnt] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                   hasZero &#x3D; true;</span><br><span class="line">                   cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n &#x3D; cnt;</span><br><span class="line">        init();</span><br><span class="line">        for(int j &#x3D; 1; j &lt;&#x3D; n; j++)&#123;</span><br><span class="line">            for(int k &#x3D; -2000; k &lt;&#x3D; 2000; k++)&#123;</span><br><span class="line">                dp[j][k+OFFSET] &#x3D; max(dp[j-1][k-wi[j]+OFFSET]+wi[j], dp[j-1][k+wi[j]+OFFSET]+wi[j], dp[j-1][k+OFFSET]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf (&quot;Case %d: &quot;, i+1);</span><br><span class="line">        if(dp[n][0+OFFSET] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            if(hasZero &#x3D;&#x3D; true)&#123;</span><br><span class="line">                printf(&quot;0\n&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                printf(&quot;-1\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            printf(&quot;%d\n&quot;, dp[n][0+OFFSET]&#x2F;2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h1><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><p>特点是每个物品只能选一件，即每个物品的数量只能出现0和1</p>
<h3 id="OpenJ-Bailian-2726"><a href="#OpenJ-Bailian-2726" class="headerlink" title="OpenJ_Bailian 2726"></a>OpenJ_Bailian 2726</h3><p>辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是辰辰，你能完成这个任务吗？</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ol>
<li>用dp[i][j]表示取前i个物品，重量不超过j时能达到的最大价值。</li>
<li>可以根据第i个物品是否取分成两类<ol>
<li>取第i个物品，那么需要更新所有能再装下一个i的状态，即dp[i-1][j-p[i].w]</li>
<li>不取i，那么dp[i][j]=dp[i-1][j]</li>
</ol>
</li>
<li>综上，递推关系为dp[i][j] = max(dp[i-1][j], dp[i - 1][j - p[i].w] + p[i].v)</li>
<li><strong>注意</strong> 对于dp[i-1][j]下装不下第i个物品的状态，要赋值为dp[i-1][j]</li>
</ol>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line">struct node &#123;</span><br><span class="line">	int w;</span><br><span class="line">	int v;</span><br><span class="line">&#125;;</span><br><span class="line">int s, m;</span><br><span class="line">node p[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;s, &amp;m) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;p[i].w, &amp;p[i].v);</span><br><span class="line"></span><br><span class="line">		memset(dp, 0, sizeof(0));</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">			for (int j &#x3D; s; j &gt;&#x3D; p[i].w; j--) &#123;</span><br><span class="line">				dp[i][j] &#x3D; max(dp[i-1][j], dp[i - 1][j - p[i].w] + p[i].v);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			for (int j &#x3D; p[i].w-1; j &gt;&#x3D; 0; j--)&#x2F;&#x2F;对于p[i].w-1~1的状态只能来自于dp[i-1][j]</span><br><span class="line">				dp[i][j] &#x3D; dp[i-1][j];</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, dp[m][s]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol>
<li>发现新的状态至于最近的一个状态有关，所以可以降维。</li>
<li>状态转移方程为：dp[j]=max{dp[j-p[i].w]+v,dp[i]}</li>
<li><strong>注意</strong> 更新dp时是逆序更新，这是因为在0-1背包问题中每个物品至多放入一次。逆序循环，保证了更新dp[j]时，dp[j-p[i].w]是没有放入i时的数据(dp[i-1][j-p[i].w])</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">	for (int j &#x3D; s; j &gt;&#x3D; p[i].w; j--) &#123;</span><br><span class="line">		dp[j]&#x3D;max(dp[j-p[i].w]+v,dp[i]);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>每种物品的数量可以任意多</p>
<h3 id="HDU-1114-Piggy-Bank"><a href="#HDU-1114-Piggy-Bank" class="headerlink" title="HDU 1114 Piggy-Bank"></a>HDU 1114 Piggy-Bank</h3><p>有个存钱罐，已知空罐质量和满罐质量，以及n种硬币质量和价值，求罐中硬币的最小价值。</p>
<h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><ol>
<li>完全背包问题的区别在于，每个物品可以被选择很多次，因此dp[j]可以由已放入物品i后的数据dp[j-p[i].w]得来，所以顺序循环</li>
<li>本题求最小值，将max要换成min</li>
<li>由于要求恰好装满，所以初始时只有dp[0]=0，其他状态都不存在</li>
</ol>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 10000+ 5;</span><br><span class="line">int dp[maxn];</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line">struct node &#123;</span><br><span class="line">	int w;</span><br><span class="line">	int v;</span><br><span class="line">&#125;;</span><br><span class="line">int s, m;</span><br><span class="line">node p[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;m, &amp;s);</span><br><span class="line">		s -&#x3D; m;</span><br><span class="line">		int n;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;p[i].v, &amp;p[i].w);</span><br><span class="line">		for (int i &#x3D; 0; i &lt;&#x3D; s; i++)</span><br><span class="line">			dp[i] &#x3D; INF;</span><br><span class="line">		dp[0] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; p[i].w; j &lt;&#x3D; s;j++) &#123;</span><br><span class="line">				if (dp[j - p[i].w] !&#x3D; INF)&#x2F;&#x2F;该状态存在，那么才可以产生新的状态</span><br><span class="line">					dp[j] &#x3D; min(dp[j], dp[j - p[i].w] + p[i].v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (dp[s] !&#x3D; INF)</span><br><span class="line">			printf(&quot;The minimum amount of money in the piggy-bank is %d.\n&quot;, dp[s]);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot;This is impossible.\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><p>介于完全背包问题和0-1背包问题之间，每种物品数量有限。可以将k个物品看作k种物品，在进行0-1背包求解。但是这样会使时间复杂度过大。稍加改变，将该种物品分成很多堆，每堆数量为1~k-2^c+1,其中c为使k-2^c+1大于0的最大整数。</p>
<h3 id="HDU-2191-珍惜现在，感恩生活"><a href="#HDU-2191-珍惜现在，感恩生活" class="headerlink" title="HDU 2191 珍惜现在，感恩生活"></a>HDU 2191 珍惜现在，感恩生活</h3><p>输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1&lt;=n&lt;=100, 1&lt;=m&lt;=100),分别表示经费的金额和大米的种类，然后是m行数据，每行包含3个数p，h和c(1&lt;=p&lt;=20,1&lt;=h&lt;=200,1&lt;=c&lt;=20)，分别表示每袋的价格、每袋的重量以及对应种类大米的袋数。</p>
<p>对于每组测试数据，请输出能够购买大米的最多重量，你可以假设经费买不光所有的大米，并且经费你可以不用完。每个实例的输出占一行。</p>
<h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><ol>
<li>先将每个物品分成很多堆，类似二进制拆分</li>
<li>然后进行0-1背包求解</li>
</ol>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 10000 + 5;</span><br><span class="line">int dp[maxn];</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line">struct node &#123;</span><br><span class="line">	int w;</span><br><span class="line">	int v;</span><br><span class="line">&#125;;</span><br><span class="line">int s, m;</span><br><span class="line">node a[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;s, &amp;m);</span><br><span class="line">		int p, h, c;</span><br><span class="line">		int cnt &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;p, &amp;h, &amp;c);</span><br><span class="line">			int t &#x3D; 1;</span><br><span class="line">			while (c &gt; t)</span><br><span class="line">			&#123;</span><br><span class="line">				c -&#x3D; t;</span><br><span class="line">				a[++cnt].w &#x3D; t * p;</span><br><span class="line">				a[cnt].v &#x3D; t * h;</span><br><span class="line">				t *&#x3D; 2;</span><br><span class="line">			&#125;</span><br><span class="line">			a[++cnt].w &#x3D; p * c;</span><br><span class="line">			a[cnt].v &#x3D; h * c;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		memset(dp, 0, sizeof(dp));</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; cnt; i++) &#123;</span><br><span class="line">			for (int j &#x3D; s; j &gt;&#x3D; a[i].w;j--) &#123;</span><br><span class="line">					dp[j] &#x3D; max(dp[j], dp[j - a[i].w] + a[i].v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;%d\n&quot;, dp[s]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索</title>
    <url>/2020/02/12/%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><ol>
<li>枚举要关注查找空间，查找目标，查找方式，估计时间复杂度</li>
<li>有时需要注意精度问题</li>
</ol>
<h2 id="SCU-2416"><a href="#SCU-2416" class="headerlink" title="SCU 2416"></a>SCU 2416</h2><p>有一个总价为_XYZ_，_表示看不清的位。现给出火鸡的总数和一个_XYZ_，求最大的火鸡单价是多少，输出这两位和最大的单价。火鸡单价为正整数</p>
<p>枚举两位，判断单价是否为整数即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	int a, b, c;</span><br><span class="line">	int n;</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);</span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		int ansi &#x3D; 0, ansj &#x3D; 0;</span><br><span class="line">		int beg &#x3D; a * 1000 + b * 100 + c * 10;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">			int t &#x3D; i * 10000 + beg;</span><br><span class="line">			for (int j &#x3D; 0; j &lt;&#x3D; 9; j++) &#123;</span><br><span class="line">				int now &#x3D; t + j;</span><br><span class="line">				int xx &#x3D; now &#x2F; n;</span><br><span class="line">				if (xx*n &#x3D;&#x3D; now)</span><br><span class="line">				&#123;</span><br><span class="line">					ansi &#x3D; i;</span><br><span class="line">					ansj &#x3D; j;</span><br><span class="line">					ans &#x3D; xx; </span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (ans)</span><br><span class="line">			printf(&quot;%d %d %d\n&quot;, ansi, ansj, ans);</span><br><span class="line">		else printf(&quot;0\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索 BFS"></a>广度优先搜索 BFS</h1><h2 id="HDU-1253-胜利大逃亡"><a href="#HDU-1253-胜利大逃亡" class="headerlink" title="HDU 1253 胜利大逃亡"></a>HDU 1253 胜利大逃亡</h2><p>大意是问能否在T时间内从(0,0,0)走到(A-1,B-1,C-1),且正好等于T时到达出口也可</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>三维隐式图最短路问题，使用bfs求解即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 50 + 5;</span><br><span class="line">int dx[] &#x3D; &#123; 1,-1,0,0, 0,0 &#125;;</span><br><span class="line">int dy[] &#x3D; &#123; 0,0,1,-1,0,0 &#125;;</span><br><span class="line">int dz[] &#x3D; &#123; 0,0,0,0,1,-1 &#125;;</span><br><span class="line">int A, B, C, T;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int x, y, z;</span><br><span class="line">	int t;</span><br><span class="line">	node(int x, int y, int z, int t) :x(x), y(y), z(z), t(t) &#123;&#125;</span><br><span class="line">	bool operator &#x3D;&#x3D; (const node&amp;a) const</span><br><span class="line">	&#123;</span><br><span class="line">		return x &#x3D;&#x3D; a.x&amp;&amp;y &#x3D;&#x3D; a.y&amp;&amp;z &#x3D;&#x3D; a.z;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int g[maxn][maxn][maxn];</span><br><span class="line">bool vis[maxn][maxn][maxn];</span><br><span class="line">inline bool ok(int x, int y, int z) &#123;</span><br><span class="line">	return x &gt;&#x3D; 0 &amp;&amp; x &lt; A</span><br><span class="line">		&amp;&amp;y &gt;&#x3D; 0 &amp;&amp; y &lt; B</span><br><span class="line">		&amp;&amp;z &gt;&#x3D; 0 &amp;&amp; z &lt; C;</span><br><span class="line">&#125;</span><br><span class="line">bool bfs() &#123;</span><br><span class="line">	node beg(0, 0, 0, 0);</span><br><span class="line">	node goal(A - 1, B - 1, C - 1, 0);</span><br><span class="line">	queue&lt;node&gt; q;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	q.push(beg);</span><br><span class="line">	vis[0][0][0] &#x3D; 1;</span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		node u &#x3D; q.front(); q.pop();</span><br><span class="line">		if (u &#x3D;&#x3D; goal) &#123;</span><br><span class="line">			printf(&quot;%d\n&quot;, u.t);</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		if (u.t &gt; T) &#123;</span><br><span class="line">			printf(&quot;-1\n&quot;);</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 6; i++) &#123;</span><br><span class="line">			int newx &#x3D; u.x + dx[i];</span><br><span class="line">			int newy &#x3D; u.y + dy[i];</span><br><span class="line">			int newz &#x3D; u.z + dz[i];</span><br><span class="line">			if (ok(newx, newy, newz))</span><br><span class="line">				if (!vis[newx][newy][newz] &amp;&amp; !g[newx][newy][newz]) &#123;</span><br><span class="line">					q.push(node(newx, newy, newz, u.t + 1));</span><br><span class="line">					vis[newx][newy][newz] &#x3D; 1;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;-1\n&quot;);</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int kase;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;kase);</span><br><span class="line">	while (kase--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d%d%d%d&quot;, &amp;A, &amp;B, &amp;C, &amp;T);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; A; i++)</span><br><span class="line">			for (int j &#x3D; 0; j &lt; B; j++)</span><br><span class="line">				for (int k &#x3D; 0; k &lt; C; k++)</span><br><span class="line">					scanf(&quot;%d&quot;, &amp;g[i][j][k]);</span><br><span class="line">		bfs();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非常可乐"><a href="#非常可乐" class="headerlink" title="非常可乐"></a>非常可乐</h2><p>大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升　(正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出”NO”。 </p>
<p>三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以”0 0 0”结束。</p>
<p>如果能平分的话请输出最少要倒的次数，否则输出”NO”。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>隐式图最短路，详细可看UVA习题中<strong>倒水问题</strong></li>
<li>值得注意的是<ol>
<li>由于是倒水次数最小，所以不需要使用优先级队列</li>
<li>由于总水量一定，所以vis开二维足够</li>
<li>如果初始水量为奇数，一定不成功。</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int c[3];</span><br><span class="line">	int t;</span><br><span class="line">&#125;;</span><br><span class="line">bool vis[maxn][maxn];</span><br><span class="line">int cap[3];</span><br><span class="line">void bfs() &#123;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	int s &#x3D; cap[0];</span><br><span class="line">	node beg;</span><br><span class="line">	beg.c[0] &#x3D; s;	beg.c[1] &#x3D; 0;	beg.c[2] &#x3D; 0;</span><br><span class="line">	beg.t &#x3D; 0;</span><br><span class="line">	vis[s][0] &#x3D; 1;</span><br><span class="line">	queue&lt;node&gt; q;</span><br><span class="line">	q.push(beg);</span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		node u &#x3D; q.front(); q.pop();</span><br><span class="line">		if ((2 * u.c[0] &#x3D;&#x3D; s &amp;&amp; 2 * u.c[1] &#x3D;&#x3D; s)</span><br><span class="line">			|| (2 * u.c[0] &#x3D;&#x3D; s &amp;&amp; 2 * u.c[2] &#x3D;&#x3D; s)</span><br><span class="line">			|| (2 * u.c[1] &#x3D;&#x3D; s &amp;&amp; 2 * u.c[2] &#x3D;&#x3D; s)) &#123;</span><br><span class="line">			printf(&quot;%d\n&quot;, u.t);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 3; i++) &#123;&#x2F;&#x2F;i向j倒水</span><br><span class="line">			if (u.c[i] &#x3D;&#x3D; 0) continue;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 3; j++) &#123;</span><br><span class="line">				if (i !&#x3D; j) &#123;</span><br><span class="line">					node v &#x3D; u;</span><br><span class="line">					int delta &#x3D; min(cap[j], v.c[i] + v.c[j]) - v.c[j];</span><br><span class="line">					v.c[i] -&#x3D; delta;</span><br><span class="line">					v.c[j] +&#x3D; delta;</span><br><span class="line">					v.t +&#x3D; 1;</span><br><span class="line">					if (!vis[v.c[0]][v.c[1]]) &#123;</span><br><span class="line">						vis[v.c[0]][v.c[1]] &#x3D; 1;</span><br><span class="line">						q.push(v);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;NO\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d%d%d&quot;, &amp;cap[0], &amp;cap[1], &amp;cap[2]) &#x3D;&#x3D; 3)</span><br><span class="line">	&#123;</span><br><span class="line">		if (cap[0] &#x3D;&#x3D; 0 &amp;&amp; cap[1] &#x3D;&#x3D; 0 &amp;&amp; cap[2] &#x3D;&#x3D; 0) break;</span><br><span class="line">		if (cap[0] % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">			printf(&quot;NO\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		bfs();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>每次都需要借助第2个柱子将前K-1小的转移到3上.具体来说是先将k-1个盘子移动到3上，再将最大的移到2上，再将k-1个移动到1上，再将最大的移动到3上，再将k-1个移动到3上。</li>
<li>设总的移动次数为F(k)=3*F(k-1)+2</li>
</ol>
<h1 id="递归的应用"><a href="#递归的应用" class="headerlink" title="递归的应用"></a>递归的应用</h1><h2 id="素数环"><a href="#素数环" class="headerlink" title="素数环"></a>素数环</h2><p><a href="https://cccceb.github.io/2020/01/24/%E7%B4%A0%E6%95%B0%E7%8E%AF/" target="_blank" rel="noopener">详情见UVA习题素数环</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 16 + 5;</span><br><span class="line">int A[maxn];</span><br><span class="line">bool isp[10000000];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int n;</span><br><span class="line">bool is_prime(int a) &#123;</span><br><span class="line">	for (int i &#x3D; 2; i &lt; a; i++)</span><br><span class="line">		if (a%i &#x3D;&#x3D; 0) return 0;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int cur) &#123;</span><br><span class="line">	if (cur &#x3D;&#x3D; n &amp;&amp; isp[A[0] + A[cur - 1]]) &#123;</span><br><span class="line">		cout &lt;&lt; A[0];</span><br><span class="line">		for (int i &#x3D; 1; i &lt; n; i++) cout &lt;&lt; &quot; &quot; &lt;&lt; A[i];</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		for (int j &#x3D; 2; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">			if (!vis[j] &amp;&amp; isp[A[cur - 1] + j]) &#123;</span><br><span class="line">				A[cur] &#x3D; j;</span><br><span class="line">				vis[j] &#x3D; 1;</span><br><span class="line">				dfs(cur + 1);</span><br><span class="line"></span><br><span class="line">				A[cur] &#x3D; 0;</span><br><span class="line">				vis[j] &#x3D; 0;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int kase &#x3D; 0;</span><br><span class="line">	while (cin &gt;&gt; n) &#123;</span><br><span class="line">		if (kase) cout &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++kase &lt;&lt; &quot;:&quot; &lt;&lt; endl;</span><br><span class="line">		memset(vis, 0,  sizeof(vis));</span><br><span class="line">		memset(isp, 0,  sizeof(isp));</span><br><span class="line">		for (int i &#x3D; 2; i &lt;&#x3D; 2 * n; i++)</span><br><span class="line">			isp[i] &#x3D; is_prime(i);</span><br><span class="line">		A[0] &#x3D; 1;</span><br><span class="line">		isp[1] &#x3D; 1;</span><br><span class="line">		dfs(1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="油田"><a href="#油田" class="headerlink" title="油田"></a>油田</h2><p>给出一个图，判断其中有多少个@的连通块。正方向和对角线都算相连</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol>
<li>直接深搜即可</li>
<li>走的方向i,j不同时为0，简化代码为i||j</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">char g[maxn][maxn];</span><br><span class="line">int r, c;</span><br><span class="line">int vis[maxn][maxn];</span><br><span class="line">int num;</span><br><span class="line">void dfs(int x, int y) &#123;</span><br><span class="line">	if (g[x][y] !&#x3D; &#39;@&#39; || vis[x][y]) return;</span><br><span class="line">	if (x &lt; 0 || x &gt;&#x3D; r || y &lt; 0 || y &gt;&#x3D; c) return;</span><br><span class="line">	vis[x][y] &#x3D; num;</span><br><span class="line">	for (int i &#x3D; -1; i &lt;&#x3D; 1; i++) &#123;</span><br><span class="line">		for (int j &#x3D; -1; j &lt;&#x3D; 1; j++) &#123;</span><br><span class="line">			if (i || j)</span><br><span class="line">				dfs(x + i, y + j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d%d\n&quot;, &amp;r, &amp;c) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		if (r &#x3D;&#x3D; 0 &amp;&amp; c &#x3D;&#x3D; 0) break;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; c; j++)</span><br><span class="line">				scanf(&quot;%c&quot;, &amp;g[i][j]);</span><br><span class="line">			getchar();</span><br><span class="line">		&#125;</span><br><span class="line">		num &#x3D; 1;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; c; j++)</span><br><span class="line">				if (g[i][j] &#x3D;&#x3D; &#39;@&#39;&amp;&amp;!vis[i][j])</span><br><span class="line">				&#123;</span><br><span class="line">					dfs(i, j);</span><br><span class="line">					num++;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, num-1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="OpenJ-Bailian-4070-全排列"><a href="#OpenJ-Bailian-4070-全排列" class="headerlink" title="OpenJ_Bailian - 4070 全排列"></a>OpenJ_Bailian - 4070 全排列</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int maxn &#x3D; 8;</span><br><span class="line">int p[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			p[i] &#x3D; i + 1;</span><br><span class="line">		sort(p, p + n);</span><br><span class="line">		do &#123;</span><br><span class="line">			printf(&quot;%d&quot;, p[0]);</span><br><span class="line">			for (int i &#x3D; 1; i &lt; n; i++)</span><br><span class="line">				printf(&quot; %d&quot;, p[i]);</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125; while (next_permutation(p, p + n));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索 DFS"></a>深度优先搜索 DFS</h1><h2 id="temple-of-the-bone"><a href="#temple-of-the-bone" class="headerlink" title="temple of the bone"></a>temple of the bone</h2><p>S是起点，D是终点，X是墙，.是地面，问能否在T时间内到达D。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 8;</span><br><span class="line">char g[maxn][maxn];</span><br><span class="line">bool vis[maxn][maxn];</span><br><span class="line">int maxr, maxc,T;</span><br><span class="line">int dx[] &#x3D; &#123; 1,-1,0,0 &#125;;</span><br><span class="line">int dy[] &#x3D; &#123; 0,0,1,-1 &#125;;</span><br><span class="line">bool dfs(int x,int y,int t) &#123;</span><br><span class="line">	if (x &lt; 0 || x &gt;&#x3D; maxr || y &lt; 0 || y &gt;&#x3D; maxc) return false;</span><br><span class="line">	if (g[x][y] &#x3D;&#x3D; &#39;D&#39;) &#123;</span><br><span class="line">		printf(&quot;YES\n&quot;);</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	if (t &gt; T) return false;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">		int newx &#x3D; x + dx[i];</span><br><span class="line">		int newy &#x3D; y + dy[i];</span><br><span class="line">		if (vis[newx][newy]||g[newx][newy]&#x3D;&#x3D;&#39;X&#39;) continue;</span><br><span class="line">		vis[newx][newy] &#x3D; 1;</span><br><span class="line">		if (dfs(newx, newy, t + 1)) return true;</span><br><span class="line">		vis[newx][newy] &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int begx, begy;</span><br><span class="line"></span><br><span class="line">	while(scanf(&quot;%d%d%d\n&quot;,&amp;maxr,&amp;maxc,&amp;T)&#x3D;&#x3D;3)&#123;</span><br><span class="line">		if (maxr &#x3D;&#x3D; 0 &amp;&amp; maxc &#x3D;&#x3D; 0 &amp;&amp; T&#x3D;&#x3D;0) break;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		for(int i &#x3D; 0; i &lt; maxr; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; maxc; j++) &#123;</span><br><span class="line">				scanf(&quot;%c&quot;, &amp;g[i][j]);</span><br><span class="line">				if (g[i][j] &#x3D;&#x3D; &#39;S&#39;) &#123;</span><br><span class="line">					begx &#x3D; i;</span><br><span class="line">					begy &#x3D; j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			getchar();</span><br><span class="line">		&#125;</span><br><span class="line">		if (!dfs(begx, begy, 0))</span><br><span class="line">			printf(&quot;NO\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>图论</title>
    <url>/2020/02/11/%E5%9B%BE%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="图论基础"><a href="#图论基础" class="headerlink" title="图论基础"></a>图论基础</h1><ol>
<li>邻接矩阵：适用于稠密图和需要频繁判断某特定的结点对是否相邻的情况</li>
<li>邻接链表：适用于需要大量遍历邻接节点而较少判断两个节点间关系时使用</li>
</ol>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int maxn &#x3D; 10000000 + 5;</span><br><span class="line">int Tree[maxn];</span><br><span class="line">int setRank[maxn];</span><br><span class="line">int findRoot(int x) &#123;</span><br><span class="line">	if (Tree[x] &#x3D;&#x3D; -1) return x;</span><br><span class="line">	else &#123;</span><br><span class="line">		int tmp &#x3D; findRoot(Tree[x]);</span><br><span class="line">		Tree[x] &#x3D; tmp;</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void union_(int p, int q) &#123;</span><br><span class="line">	p &#x3D; findRoot(p);</span><br><span class="line">	q &#x3D; findRoot(q);</span><br><span class="line">	if (p !&#x3D; q)</span><br><span class="line">	&#123;</span><br><span class="line">		Tree[p] &#x3D; q;</span><br><span class="line">		setRank[q] +&#x3D; setRank[p];</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Head-of-a-Gang"><a href="#Head-of-a-Gang" class="headerlink" title="Head of a Gang"></a>Head of a Gang</h2><p>每次输入两个人的名字和通话时长，有联系的两个人属于同一个组织。总的通话时长大于k且总人数大于2的组织称为一个团伙，其中权重最大的那个人是头目。现在要输出团伙总数，及每个团伙的头目，并要求按头目名字降序输出。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>需要计算每个集合的总权重，所以每次都将小树连到大树上，之后统计大树的根所包含的权重是否满足要求。</li>
<li><strong>注意</strong> memset只对0和-1有效。可使用fill实现</li>
</ol>
<blockquote>
<p>memset是一个字节一个字节设置的，取要赋的值的后8位二进制进行赋值。<br>1的二进制是（00000000 00000000 00000000 00000001），取后8位（00000001），int型占4个字节，当初始化为1时，它把一个int的每个字节都设置为1，也就是0x01010101,二进制是00000001 00000001 00000001 00000001，十进制就是16843009。<br>之所以输入0,-1时正确，纯属巧合。<br>0，二进制是（00000000 00000000 00000000 00000000），取后8位（00000000），初始化后00000000 00000000 00000000 00000000结果是0<br>-1，负数在计算机中以补码存储，二进制是（11111111 11111111 11111111 11111111），取后8位（11111111），则是11111111 11111111 11111111 11111111结果也是-1</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">int Tree[maxn];&#x2F;&#x2F;记录根</span><br><span class="line">int setRank[maxn];&#x2F;&#x2F;记录树的大小</span><br><span class="line">int tot[maxn];&#x2F;&#x2F;记录树的权重和</span><br><span class="line">map&lt;int, string&gt; id;&#x2F;&#x2F;记录编号对应的名字</span><br><span class="line">map&lt;string, int&gt; name;&#x2F;&#x2F;记录名字对应的编号</span><br><span class="line">int g[maxn][maxn];&#x2F;&#x2F;记录两点之间的距离，不必要，可以每次union时作为参数传入</span><br><span class="line">int weight[maxn];&#x2F;&#x2F;记录每个节点的权重，每提到一次就加一次</span><br><span class="line"></span><br><span class="line">int findRoot(int x) &#123;</span><br><span class="line">	if (Tree[x] &#x3D;&#x3D; -1) return x;</span><br><span class="line">	else &#123;</span><br><span class="line">		int tmp &#x3D; findRoot(Tree[x]);</span><br><span class="line">		Tree[x] &#x3D; tmp;</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void union_(int p, int q) &#123;</span><br><span class="line">	int rootp &#x3D; findRoot(p);</span><br><span class="line">	int rootq &#x3D; findRoot(q);</span><br><span class="line">	if (rootp !&#x3D; rootq)</span><br><span class="line">	&#123;</span><br><span class="line">		if (tot[rootp] &lt; tot[rootq])&#x2F;&#x2F;每次都将小树加在大树上</span><br><span class="line">			swap(rootp, rootq);</span><br><span class="line">		Tree[rootq] &#x3D; rootp;</span><br><span class="line">		tot[rootp] +&#x3D; tot[rootq] + g[p][q];&#x2F;&#x2F;g[p][q]可以通过参数传入</span><br><span class="line">		setRank[rootp] +&#x3D; setRank[rootq];</span><br><span class="line">	&#125;</span><br><span class="line">	else tot[rootp] +&#x3D; g[q][p];&#x2F;&#x2F;即使已经在一颗树上也要加上内部联系的权重</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, a, b, m, k;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;n, &amp;k) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(Tree, -1, sizeof(Tree));</span><br><span class="line">		memset(tot, 0, sizeof(tot));</span><br><span class="line">		memset(weight, 0, sizeof(weight));</span><br><span class="line">		fill(setRank, setRank + maxn, 1);</span><br><span class="line">		name.clear();</span><br><span class="line">		string n1, n2;</span><br><span class="line">		int t;</span><br><span class="line">		int num &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; t;</span><br><span class="line">			if (!name.count(n1)) &#123;</span><br><span class="line">				name[n1] &#x3D; ++num;</span><br><span class="line">				id[num] &#x3D; n1;</span><br><span class="line">			&#125;</span><br><span class="line">			if (!name.count(n2)) &#123;</span><br><span class="line">				name[n2] &#x3D; ++num;</span><br><span class="line">				id[num] &#x3D; n2;</span><br><span class="line">			&#125;</span><br><span class="line">			int s1 &#x3D; name[n1], s2 &#x3D; name[n2];</span><br><span class="line">			g[s1][s2] &#x3D; g[s2][s1] &#x3D; t;</span><br><span class="line">			weight[s1] +&#x3D; t;</span><br><span class="line">			weight[s2] +&#x3D; t;</span><br><span class="line">			union_(name[n1], name[n2]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		vector&lt;int&gt; ans;&#x2F;&#x2F;存满足条件的集合的根节点</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; num; i++) &#123;</span><br><span class="line">			if (Tree[i] &#x3D;&#x3D; -1 &amp;&amp; tot[i] &gt; k&amp;&amp;setRank[i] &gt; 2) &#123;</span><br><span class="line">				ans.push_back(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans.size() &lt;&lt; endl;</span><br><span class="line">		map&lt;string, int&gt; gang;&#x2F;&#x2F;存满足条件集合的头目名字和集合的大小</span><br><span class="line">		for (int i &#x3D; 0; i &lt; ans.size(); i++) &#123;</span><br><span class="line">			int t &#x3D; ans[i];</span><br><span class="line">			int w &#x3D; 0;</span><br><span class="line">			int iw &#x3D; 0;</span><br><span class="line">			for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">				if ((Tree[j] &#x3D;&#x3D; t||j&#x3D;&#x3D;t) &amp;&amp; weight[j] &gt; w) &#123;</span><br><span class="line">					w &#x3D; weight[j];</span><br><span class="line">					iw &#x3D; j;</span><br><span class="line">				&#125;</span><br><span class="line">			gang[id[iw]] &#x3D; setRank[t];</span><br><span class="line">		&#125;</span><br><span class="line">		for (auto i &#x3D; gang.begin(); i !&#x3D; gang.end(); i++) </span><br><span class="line">			cout &lt;&lt; i-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; i-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h2 id="Kruskal-又是畅通工程"><a href="#Kruskal-又是畅通工程" class="headerlink" title="Kruskal (又是畅通工程)"></a>Kruskal (又是畅通工程)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">int Tree[maxn];&#x2F;&#x2F;记录根</span><br><span class="line">struct node &#123;</span><br><span class="line">	int a, b;</span><br><span class="line">	int w;</span><br><span class="line"></span><br><span class="line">	bool operator &lt; (const node&amp;a)const &#123; return w &lt; a.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int findRoot(int x) &#123;</span><br><span class="line">	if (Tree[x] &#x3D;&#x3D; -1) return x;</span><br><span class="line">	else &#123;</span><br><span class="line">		int tmp &#x3D; findRoot(Tree[x]);</span><br><span class="line">		Tree[x] &#x3D; tmp;</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool union_(int p, int q) &#123;</span><br><span class="line">	int rootp &#x3D; findRoot(p);</span><br><span class="line">	int rootq &#x3D; findRoot(q);</span><br><span class="line">	if (rootp !&#x3D; rootq)</span><br><span class="line">	&#123;</span><br><span class="line">		Tree[rootq] &#x3D; rootp;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">node g[maxn*maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		int m &#x3D; n * (n - 1) &#x2F; 2;</span><br><span class="line">		memset(Tree, -1, sizeof(Tree));</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++)</span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;g[i].a, &amp;g[i].b, &amp;g[i].w);</span><br><span class="line">		sort(g, g + m);</span><br><span class="line"></span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			int a &#x3D; g[i].a;</span><br><span class="line">			int b &#x3D; g[i].b;</span><br><span class="line">			if (union_(a, b))</span><br><span class="line">				ans +&#x3D; g[i].w;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="POJ-2560"><a href="#POJ-2560" class="headerlink" title="POJ 2560"></a>POJ 2560</h2><p>不直接给出边，而是给出点的坐标，实际也是最小生成树问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">int Tree[maxn];&#x2F;&#x2F;记录根</span><br><span class="line">struct point &#123;</span><br><span class="line">	double x, y;</span><br><span class="line">	point()&#123;&#125;</span><br><span class="line">	point(double x, double y) :x(x), y(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int a, b;</span><br><span class="line">	double w;</span><br><span class="line">	node() &#123;&#125;;</span><br><span class="line">	node(int a, int b, double w) :a(a), b(b), w(w) &#123;&#125;</span><br><span class="line">	bool operator &lt; (const node&amp;a)const &#123; return w &lt; a.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int findRoot(int x) &#123;</span><br><span class="line">	if (Tree[x] &#x3D;&#x3D; -1) return x;</span><br><span class="line">	else &#123;</span><br><span class="line">		int tmp &#x3D; findRoot(Tree[x]);</span><br><span class="line">		Tree[x] &#x3D; tmp;</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool union_(int p, int q) &#123;</span><br><span class="line">	int rootp &#x3D; findRoot(p);</span><br><span class="line">	int rootq &#x3D; findRoot(q);</span><br><span class="line">	if (rootp !&#x3D; rootq)</span><br><span class="line">	&#123;</span><br><span class="line">		Tree[rootq] &#x3D; rootp;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline double getDis(point a, point b) &#123;</span><br><span class="line">	return sqrt((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(Tree, -1, sizeof(Tree));	</span><br><span class="line">		node g[maxn*maxn];</span><br><span class="line">		point p[maxn];</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%lf%lf&quot;, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">		&#125;</span><br><span class="line">		int m &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; i + 1; j &lt; n; j++) &#123;</span><br><span class="line">				g[m++] &#x3D; node(i, j, getDis(p[i], p[j]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(g, g + m);</span><br><span class="line">		double ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			int a &#x3D; g[i].a;</span><br><span class="line">			int b &#x3D; g[i].b;</span><br><span class="line">			if (union_(a, b))</span><br><span class="line">				ans +&#x3D; g[i].w;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%.2lf\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><h2 id="Flyod"><a href="#Flyod" class="headerlink" title="Flyod"></a>Flyod</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ol>
<li>每次加入一个节点，并分析对于每一对点，能否使二者间距离变短(不通变通)</li>
<li>使用邻接矩阵存储图</li>
<li>时间复杂度O(n<sup>3</sup>)</li>
<li>一次Floyd之后，图中所有点之间的最短路径都被确定，所以适用于多组查询的情况</li>
<li>注意初始化函数中定义自己到自己的距离为0</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void init(int n) &#123;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">			ans[i][j] &#x3D; -1;</span><br><span class="line">		ans[i][i] &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void Floyd(int n) &#123;</span><br><span class="line"></span><br><span class="line">	for (int k &#x3D; 1; k &lt;&#x3D; n; k++) &#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">				if (ans[i][k] &#x3D;&#x3D; -1 || ans[k][j] &#x3D;&#x3D; -1) continue;</span><br><span class="line">				if (ans[i][j] &#x3D;&#x3D; -1 || ans[i][j] &gt; ans[i][k] + ans[k][j])</span><br><span class="line">					ans[i][j] &#x3D; ans[i][k] + ans[k][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dijkstra-单源最短路"><a href="#Dijkstra-单源最短路" class="headerlink" title="Dijkstra 单源最短路"></a>Dijkstra 单源最短路</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><ol>
<li>按照最短路径长度递增的顺序确定每一个节点的最短路径长度，即先确定的结点的最短路径长度不大于后确定的最短路径长度。这样，当确定一个节点的最短路径长度时，该最短路径上所有中间结点的最短路径长度必然已经确定。</li>
<li>用优先级队列优化后，时间复杂度O(nlogn)</li>
<li>关于实现，由于优先级队列默认调用less，即&lt;号得到递减序列。为了简化代码(其实是懒)，所以将结构体中’&lt;’重载为’&gt;’。当然也可以priority_queue&lt;edge,vector<edge>,greater<edge>&gt;;</li>
</ol>
<h3 id="最短路径问题-浙大"><a href="#最短路径问题-浙大" class="headerlink" title="最短路径问题(浙大)"></a>最短路径问题(浙大)</h3><p>除路长度外增加了一个花费，优先取路径长度最小，对于相同长度的取花费最小。思想一致，只需在板子外再加一个cost数组。与dis数组同理即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">struct edge &#123;</span><br><span class="line">	int to;</span><br><span class="line">	int w;</span><br><span class="line">	int c;</span><br><span class="line">	edge() &#123;&#125;</span><br><span class="line">	edge(int to, int w, int c) :to(to), w(w), c(c) &#123;&#125;</span><br><span class="line">	bool operator &lt;(const edge a) const &#123; return w &gt; a.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt;g[maxn];</span><br><span class="line">int cost[maxn];</span><br><span class="line">int dis[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">void Dij(int beg, int goal, int n) &#123;</span><br><span class="line">	memset(dis, -1, sizeof(dis));</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	memset(cost, 0, sizeof(cost));</span><br><span class="line">	dis[beg] &#x3D; 0;</span><br><span class="line">	priority_queue&lt;edge&gt; pq;</span><br><span class="line">	pq.push(edge(beg, 0, 0));</span><br><span class="line">	while (!pq.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		edge u &#x3D; pq.top(); pq.pop();</span><br><span class="line">		if (u.to &#x3D;&#x3D; goal) return;</span><br><span class="line">		if (vis[u.to]) continue;</span><br><span class="line">		vis[u.to] &#x3D; 1;</span><br><span class="line">		for (edge e : g[u.to]) &#123;</span><br><span class="line">			if (!vis[e.to]) &#123;</span><br><span class="line">				int d1 &#x3D; dis[e.to];</span><br><span class="line">				int d2 &#x3D; dis[u.to];</span><br><span class="line">				if (d1 &#x3D;&#x3D; -1 </span><br><span class="line">					||d1 &gt; d2 + e.w</span><br><span class="line">					|| (d1&#x3D;&#x3D; d2 + e.w &amp;&amp; cost[e.to] &gt; cost[u.to] + e.c)) </span><br><span class="line">				&#123;</span><br><span class="line">					dis[e.to] &#x3D; dis[u.to] + e.w;</span><br><span class="line">					cost[e.to] &#x3D; cost[u.to] + e.c;</span><br><span class="line">					pq.push(edge(e.to, dis[e.to], cost[e.to]));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	int a, b, w, c;</span><br><span class="line">	int s, t;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		if (m &#x3D;&#x3D; 0 &amp;&amp; n &#x3D;&#x3D; 0) break;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)	g[i].clear();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;w, &amp;c);</span><br><span class="line">			g[a].push_back(edge(b, w, c));</span><br><span class="line">			g[b].push_back(edge(a, w, c));</span><br><span class="line">		&#125;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;s, &amp;t);</span><br><span class="line">		Dij(s, t, n);</span><br><span class="line">		printf(&quot;%d %d\n&quot;, dis[t], cost[t]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路径-上交"><a href="#最短路径-上交" class="headerlink" title="最短路径(上交)"></a>最短路径(上交)</h2><p>N个城市，标号从0到N-1，M条道路，第K条道路（K从0开始）的长度为2^K，求编号为0的城市到其他城市的最短距离<br>输入：第一行两个正整数N（2&lt;=N&lt;=100）M(M&lt;=500),表示有N个城市，M条道路。接下来M行两个整数，表示相连的两个城市的编号<br>输出：N-1行，表示0号城市到其他城市的最短路，如果无法到达，输出-1，数值太大的以MOD 100000 的结果输出。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>本题是高精度整数和迪杰斯特拉算法的结合，作为综合练习。</li>
<li>主要注意一下细节问题，主要是% 运算符的重载，一开始写错了。</li>
<li>出现死循环别忘了检查输入的循环，比如是否忘了写scanf()==2<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">class BigInteger &#123;</span><br><span class="line">private:</span><br><span class="line">	const static int maxn &#x3D; 1000 + 5;</span><br><span class="line">	void init() &#123;</span><br><span class="line">		memset(digit, 0, sizeof(digit));</span><br><span class="line">		size &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int digit[maxn];</span><br><span class="line">	int size;</span><br><span class="line">	void set(char str[]) &#123;</span><br><span class="line">		int len &#x3D; strlen(str);</span><br><span class="line">		init();</span><br><span class="line">		for (int i &#x3D; len - 1, j &#x3D; 0, t &#x3D; 0, c &#x3D; 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			t +&#x3D; (str[i] - &#39;0&#39;)*c;</span><br><span class="line">			j++;</span><br><span class="line">			c *&#x3D; 10;</span><br><span class="line">			if (j &#x3D;&#x3D; 4 || i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				digit[size++] &#x3D; t;</span><br><span class="line">				t &#x3D; 0;</span><br><span class="line">				j &#x3D; 0;</span><br><span class="line">				c &#x3D; 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void output() &#123;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			if (i !&#x3D; size - 1)</span><br><span class="line">				printf(&quot;%04d&quot;, digit[i]);</span><br><span class="line">			else if (digit[i])</span><br><span class="line">				printf(&quot;%d&quot;, digit[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	int operator % (int x) const &#123;</span><br><span class="line">		int remain &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--) </span><br><span class="line">			remain &#x3D; (remain * 10000 + digit[i]) % x;</span><br><span class="line">		return remain;</span><br><span class="line">	&#125;</span><br><span class="line">	BigInteger operator * (const int &amp;a) const &#123;</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] * a + cf;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">	BigInteger operator + (const  BigInteger &amp;A) const &#123;</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; size || i &lt; A.size; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] + A.digit[i] + cf;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator &lt;(const BigInteger A) const &#123;</span><br><span class="line">		if (A.size !&#x3D; size) return size &lt; A.size;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			if (digit[i] !&#x3D; A.digit[i])</span><br><span class="line">				return digit[i] &lt; A.digit[i];</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct edge &#123;</span><br><span class="line">	int to;</span><br><span class="line">	BigInteger w;</span><br><span class="line">	edge(int to, BigInteger w) :to(to), w(w) &#123;&#125;</span><br><span class="line">	bool operator &lt; (const edge&amp;a) const &#123; return a.w &lt; w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; g[105];</span><br><span class="line">BigInteger dis[105]&#123;&#125;;</span><br><span class="line">void dij(int beg) &#123;</span><br><span class="line">	priority_queue&lt;edge&gt; pq;</span><br><span class="line">	int vis[105]&#123;&#125;;</span><br><span class="line">	memset(dis, 0, sizeof(dis));</span><br><span class="line">	char s[] &#x3D; &quot;0&quot;;</span><br><span class="line">	BigInteger ss; ss.set(s);</span><br><span class="line">	dis[beg] &#x3D; ss;</span><br><span class="line">	pq.push(edge(beg, dis[beg]));</span><br><span class="line">	while (!pq.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		edge u &#x3D; pq.top(); pq.pop();</span><br><span class="line">		if (vis[u.to]) continue;</span><br><span class="line">		vis[u.to] &#x3D; 1;</span><br><span class="line">		for (edge e : g[u.to]) &#123;</span><br><span class="line">			if (vis[e.to]) continue;</span><br><span class="line">			if (dis[e.to].size &#x3D;&#x3D; 0 || dis[u.to] + e.w &lt; dis[e.to]) &#123;</span><br><span class="line">				dis[e.to] &#x3D; dis[u.to] + e.w;</span><br><span class="line">				pq.push(edge(e.to, dis[e.to]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		char s[] &#x3D; &quot;1&quot;;</span><br><span class="line">		BigInteger c;</span><br><span class="line">		c.set(s);</span><br><span class="line">		int a, b;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">			g[a].push_back(edge(b, c));</span><br><span class="line">			g[b].push_back(edge(a, c));</span><br><span class="line">			c &#x3D; c * 2;</span><br><span class="line">		&#125;</span><br><span class="line">		dij(0);</span><br><span class="line">		for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">			if (dis[i].size)</span><br><span class="line">				printf(&quot;%d\n&quot;, dis[i] % 100000);</span><br><span class="line">			else printf(&quot;-1\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="I-wanna-go-home-POJ-3767"><a href="#I-wanna-go-home-POJ-3767" class="headerlink" title="I wanna go home POJ 3767"></a>I wanna go home POJ 3767</h2>某国出现政治分裂，其中的城市分裂成两派，一派支持领导1，一派支持领导2。你是一名商人，在城市1，想走最短路径回到城市2，要求路径中包含至多一条跨过两个阵营的路径，求最短路径长度。</li>
</ol>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>首先用dij分别求两个阵营内部，从源点1和2出发的最短距离。</li>
<li>然后枚举连接两个阵营的边，对于贯穿两个阵营的路径，尝试更新答案为d1[i]+t[i][j]+d2[j]。</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 600 + 5;</span><br><span class="line">struct edge &#123;</span><br><span class="line">	int to;</span><br><span class="line">	int w;</span><br><span class="line">	edge() &#123;&#125;</span><br><span class="line">	edge(int to, int w) :to(to), w(w) &#123;&#125;</span><br><span class="line">	bool operator &lt;(const edge a) const &#123; return w &gt; a.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt;g[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int t[maxn][maxn];</span><br><span class="line">int flag[maxn];</span><br><span class="line"></span><br><span class="line">void Dij(int beg, int n, int f, int *dis) &#123;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	dis[beg] &#x3D; 0;</span><br><span class="line">	priority_queue&lt;edge&gt; pq;</span><br><span class="line">	pq.push(edge(beg, 0));</span><br><span class="line">	while (!pq.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		edge u &#x3D; pq.top(); pq.pop();</span><br><span class="line">		if (vis[u.to]) continue;</span><br><span class="line">		vis[u.to] &#x3D; 1;</span><br><span class="line">		for (edge e : g[u.to]) &#123;</span><br><span class="line">			if (flag[e.to] !&#x3D; f) continue;</span><br><span class="line">			if (!vis[e.to]) &#123;</span><br><span class="line">				if (dis[e.to] &#x3D;&#x3D; -1 || dis[e.to] &gt; dis[u.to] + e.w)</span><br><span class="line">				&#123;</span><br><span class="line">					dis[e.to] &#x3D; dis[u.to] + e.w;</span><br><span class="line">					pq.push(edge(e.to, dis[e.to]));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	int a, b, w;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;m);</span><br><span class="line">		memset(t, -1, sizeof(t));</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) g[i].clear();</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;w);</span><br><span class="line">			if (t[a][b] &#x3D;&#x3D; -1 || w &lt; t[a][b])</span><br><span class="line">				t[a][b] &#x3D; t[b][a] &#x3D; w;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;flag[i]);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			for (int j &#x3D; 1; j &lt;&#x3D; i; j++) &#123;</span><br><span class="line">				if (t[i][j] !&#x3D; -1) &#123;</span><br><span class="line">					g[i].push_back(edge(j, t[i][j]));</span><br><span class="line">					g[j].push_back(edge(i, t[i][j]));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		int d1[maxn];</span><br><span class="line">		int d2[maxn];</span><br><span class="line">		memset(d1, -1, sizeof(d1));</span><br><span class="line">		memset(d2, -1, sizeof(d2));</span><br><span class="line">		Dij(1, n, 1, d1);</span><br><span class="line">		Dij(2, n, 2, d2);</span><br><span class="line">		int ans &#x3D; d1[2];</span><br><span class="line">		if (ans &#x3D;&#x3D; -1)</span><br><span class="line">			for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">				if (flag[i] &#x3D;&#x3D; 2 || d1[i] &#x3D;&#x3D; -1) continue;</span><br><span class="line">				for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">					if (flag[j] &#x3D;&#x3D; 1 || d2[j] &#x3D;&#x3D; -1) continue;</span><br><span class="line">					if (t[i][j] !&#x3D; -1) &#123;</span><br><span class="line">						if (ans &#x3D;&#x3D; -1 || d1[i] + t[i][j] + d2[j] &lt; ans)</span><br><span class="line">							ans &#x3D; d1[i] + t[i][j] + d2[j];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><h2 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h2><ol>
<li>每次取入度为0的点，并删除之，修改它所连接的点的入读，反复入队入度为0的点。记录总的出队点数。如果等于n说明无环，能构成拓扑序列；否则，不能构成拓扑序列。</li>
<li>时间复杂度O(N+M),其中N为顶点数，M为边数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int maxn &#x3D; 500 + 5;</span><br><span class="line">int indegree[maxn];</span><br><span class="line">vector&lt;int&gt; g[maxn];</span><br><span class="line">bool topo(int n) &#123;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	vector&lt;int&gt; ans;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) </span><br><span class="line">		if (indegree[i] &#x3D;&#x3D; 0) q.push(i);</span><br><span class="line"></span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		int u &#x3D; q.front(); q.pop();</span><br><span class="line">		ans.push_back(u);</span><br><span class="line"></span><br><span class="line">		for (int i : g[u]) &#123;</span><br><span class="line">			indegree[i]--;</span><br><span class="line">			if (indegree[i] &#x3D;&#x3D; 0)</span><br><span class="line">				q.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (ans.size() &#x3D;&#x3D; n) return true;</span><br><span class="line">	else return false;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	int a, b;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(indegree, 0, sizeof(indegree));</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)  g[i].clear();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">			g[a].push_back(b);</span><br><span class="line">			indegree[b]++;</span><br><span class="line">		&#125;</span><br><span class="line">		bool flag  &#x3D; topo(n);</span><br><span class="line">		if (flag)</span><br><span class="line">			printf(&quot;YES\n&quot;);</span><br><span class="line">		else printf(&quot;NO\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="产生冠军-HDU-2094"><a href="#产生冠军-HDU-2094" class="headerlink" title="产生冠军 HDU 2094"></a>产生冠军 HDU 2094</h2><p>有一群人，打乒乓球比赛，两两捉对撕杀，每两个人之间最多打一场比赛。<br>球赛的规则如下：<br>如果A打败了B，B又打败了C，而A与C之间没有进行过比赛，那么就认定，A一定能打败C。<br>如果A打败了B，B又打败了C，而且，C又打败了A，那么A、B、C三者都不可能成为冠军。<br>根据这个规则，无需循环较量，或许就能确定冠军。你的任务就是面对一群比赛选手，在经过了若干场撕杀之后，确定是否已经实际上产生了冠军。 </p>
<p>输入含有一些选手群，每群选手都以一个整数n(n&lt;1000)开头，后跟n对选手的比赛结果，比赛结果以一对选手名字（中间隔一空格）表示，前者战胜后者。如果n为0，则表示输入结束。 </p>
<p>对于每个选手群，若你判断出产生了冠军，则在一行中输出“Yes”，否则在一行中输出“No”。 </p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol>
<li>本题技巧在于只需判断初始状态下，入度为0的点是否为1个即可。</li>
</ol>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">int indegree[maxn];</span><br><span class="line">vector&lt;int&gt; g[maxn];</span><br><span class="line">bool topo(int n) &#123;</span><br><span class="line">	int tmp[maxn];</span><br><span class="line">	int tot &#x3D; 0;</span><br><span class="line">	memcpy(tmp, indegree, sizeof(tmp));</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) </span><br><span class="line">		if (indegree[i] &#x3D;&#x3D; 0) tot++;</span><br><span class="line">	return tot&#x3D;&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;string, int&gt; id;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	int a, b;</span><br><span class="line">	while (cin &gt;&gt; m &amp;&amp; m)</span><br><span class="line">	&#123;</span><br><span class="line">		string s, y;</span><br><span class="line">		memset(indegree, 0, sizeof(indegree));</span><br><span class="line">		for (int i &#x3D; 1; i &lt; maxn; i++)  g[i].clear();</span><br><span class="line">		int num &#x3D; 1;</span><br><span class="line">		id.clear();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			cin &gt;&gt; s &gt;&gt; y;</span><br><span class="line">			if (!id.count(s))</span><br><span class="line">				id[s] &#x3D; num++;</span><br><span class="line">			if (!id.count(y))</span><br><span class="line">				id[y] &#x3D; num++;</span><br><span class="line">			a &#x3D; id[s];</span><br><span class="line">			b &#x3D; id[y];</span><br><span class="line">			g[a].push_back(b);</span><br><span class="line">			indegree[b]++;</span><br><span class="line">		&#125;</span><br><span class="line">		bool flag &#x3D; topo(num - 1);</span><br><span class="line"></span><br><span class="line">		if (flag)cout &lt;&lt; &quot;Yes&quot;;</span><br><span class="line">		else cout &lt;&lt; &quot;No&quot;;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>数学理论</title>
    <url>/2020/02/10/%E6%95%B0%E5%AD%A6%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="数位拆分"><a href="#数位拆分" class="headerlink" title="数位拆分"></a>数位拆分</h1><p>主要注意溢出问题</p>
<h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><h2 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h2><p>将a进制的s转换成b进制输出.输入a,s,b</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000000;</span><br><span class="line">char s[maxn];</span><br><span class="line">char ans[maxn];</span><br><span class="line">const char alp[] &#x3D; &#123; &#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39; &#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">	long long a, b;</span><br><span class="line">	while (scanf(&quot;%lld%s%lld&quot;, &amp;a, s, &amp;b) &#x3D;&#x3D; 3) &#123;</span><br><span class="line">		int cf &#x3D; 1;</span><br><span class="line">		long long ten &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; strlen(s) - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			if (isdigit(s[i])) &#123;</span><br><span class="line">				ten +&#x3D; (s[i] - &#39;0&#39;)*cf;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (s[i] &gt;&#x3D; &#39;a&#39;&amp;&amp;s[i] &lt;&#x3D; &#39;z&#39;) &#123;</span><br><span class="line">				ten +&#x3D; (s[i] - &#39;a&#39;+10)*cf;</span><br><span class="line">			&#125;</span><br><span class="line">			else ten +&#x3D; (s[i] - &#39;A&#39;+10)*cf;</span><br><span class="line">			cf *&#x3D; a;</span><br><span class="line">		&#125;</span><br><span class="line">		int id &#x3D; 0;</span><br><span class="line">		while (ten)</span><br><span class="line">		&#123;</span><br><span class="line">			ans[id++] &#x3D; alp[ten % b];</span><br><span class="line">			ten &#x2F;&#x3D; b;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; id - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			printf(&quot;%c&quot;, ans[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进制转换-1"><a href="#进制转换-1" class="headerlink" title="进制转换"></a>进制转换</h2><p>将不超过30位的非负整数转成二进制</p>
<h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 30 + 5;</span><br><span class="line">char s[maxn];</span><br><span class="line">int ans[20000];</span><br><span class="line">int num[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%s&quot;, s) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; strlen(s); i++)</span><br><span class="line">			num[i] &#x3D; s[i] - &#39;0&#39;;</span><br><span class="line">		int id &#x3D; 0;</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; strlen(s);) &#123;</span><br><span class="line">			int tmp &#x3D; 0, remain &#x3D; 0;</span><br><span class="line">			for (int j &#x3D; i; j &lt; strlen(s); j++) &#123;</span><br><span class="line">				tmp &#x3D; (10 * remain + num[j]) % 2;</span><br><span class="line">				num[j] &#x3D; (10 * remain + num[j]) &#x2F; 2;</span><br><span class="line">				remain &#x3D; tmp;</span><br><span class="line">			&#125;</span><br><span class="line">			ans[id++] &#x3D; remain;</span><br><span class="line">			while (num[i] &#x3D;&#x3D; 0&amp;&amp;i&lt;strlen(s))</span><br><span class="line">				i++;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; id - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			printf(&quot;%d&quot;, ans[i]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="※-Java-※"><a href="#※-Java-※" class="headerlink" title="※ Java ※"></a>※ Java ※</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import  java.util.*;</span><br><span class="line">import java.math.BigInteger;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in&#x3D;new Scanner(System.in);</span><br><span class="line">        while (in.hasNext())&#123;</span><br><span class="line">            String str&#x3D;in.nextLine();</span><br><span class="line">            BigInteger a&#x3D;new BigInteger(str,10);</span><br><span class="line">            System.out.println(a.toString(2));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="补充：求整型a-b并保留任意位小数"><a href="#补充：求整型a-b并保留任意位小数" class="headerlink" title="补充：求整型a/b并保留任意位小数"></a>补充：求整型a/b并保留任意位小数</h3><p>其中res存小数部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int c &#x3D; a % b, cnt &#x3D; 0;</span><br><span class="line">c *&#x3D; 10;</span><br><span class="line">while (cnt &lt; n) &#123;</span><br><span class="line">	res[cnt] &#x3D; c &#x2F; b;</span><br><span class="line">	vis[c] &#x3D; cnt++;</span><br><span class="line">	c %&#x3D; b;</span><br><span class="line">	c *&#x3D; 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h1><h2 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int gcd(int a, int b) &#123;</span><br><span class="line">	if (!b) return a;</span><br><span class="line">	else return gcd(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h1><p>a,b两数的最小公倍数为两数的乘积除以它们的最大公约数</p>
<h2 id="Least-Common-Multiple-EOlymp-1243"><a href="#Least-Common-Multiple-EOlymp-1243" class="headerlink" title="Least Common Multiple EOlymp-1243"></a>Least Common Multiple EOlymp-1243</h2><p>求一系列数的最小公倍数，输入的第一行为测试组数，接下来每行的第一个数为该组数字的个数，数字限定在32bit整型范围内。输出这些数字的最小公倍数。</p>
<p>注意： n等于1直接输出；<strong>尽管a,b都是32bit，但是lcm时，a*b可能大于32b,可以使用long long或者先除法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long </span><br><span class="line">ll gcd(ll a, ll b) &#123;</span><br><span class="line">	if (b &#x3D;&#x3D; 0) return a;</span><br><span class="line">	else return gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	ll a, b, x, n;</span><br><span class="line">	getchar();</span><br><span class="line"></span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		if (n &gt; 1) &#123;</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">			ll  g &#x3D; gcd(a, b);</span><br><span class="line">			ll l &#x3D; a * b &#x2F; g;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; n - 2; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				cin &gt;&gt; x;</span><br><span class="line">				if (l%x &#x3D;&#x3D; 0) continue;</span><br><span class="line">				g &#x3D; gcd(l, x);</span><br><span class="line">				l &#x3D; l * x &#x2F; g;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			cout &lt;&lt; x &lt;&lt; endl;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="素数筛法"><a href="#素数筛法" class="headerlink" title="素数筛法"></a>素数筛法</h1><h2 id="素数判定"><a href="#素数判定" class="headerlink" title="素数判定"></a>素数判定</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool judge(int a) &#123;</span><br><span class="line">	if (a&lt;&#x3D; 1) return false;</span><br><span class="line">	for (int i &#x3D; 2; i &lt; (int)sqrt(a) + 1; i++) &#123;</span><br><span class="line">		if (a%i &#x3D;&#x3D; 0) return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="素数筛法-1"><a href="#素数筛法-1" class="headerlink" title="素数筛法"></a>素数筛法</h2><p>要输出不超过n的所有素数，方法是当我们得到一个素数时，即将它的所有倍数均标记为非素数，这样当我们遍历到每一个数时，它没有被任何其他的素数标记为非素数，则我们确定其为素数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">memset(notp, 0, sizeof(notp));</span><br><span class="line">		for (int i &#x3D;2; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">;			if (!notp[i]) &#123;</span><br><span class="line">				for (int j &#x3D; 2; i*j &lt; n; j++)</span><br><span class="line">					notp[i*j] &#x3D; 1;</span><br><span class="line">				if (i % 10 &#x3D;&#x3D; 1) printf(&quot;%d &quot;, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Goldbach’s-Conjecture"><a href="#Goldbach’s-Conjecture" class="headerlink" title="Goldbach’s Conjecture"></a>Goldbach’s Conjecture</h2><p>别忘了打表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; (1 &lt;&lt; 15) + 5;</span><br><span class="line">bool notp[maxn];</span><br><span class="line">int sum[maxn];</span><br><span class="line">int prime[maxn];</span><br><span class="line">int get_ans() &#123;</span><br><span class="line">	memset(sum, 0, sizeof(sum));</span><br><span class="line">	int id &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 2; i &lt; maxn; i++) &#123;</span><br><span class="line">		if (!notp[i]) &#123;</span><br><span class="line">			for (int j &#x3D; 2; i*j &lt; maxn; j++)</span><br><span class="line">				notp[i*j] &#x3D; 1;</span><br><span class="line">			prime[id++] &#x3D; i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int ix &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; id; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; id; j++) &#123;</span><br><span class="line">			int h &#x3D; prime[i] + prime[j];</span><br><span class="line">			if (h &lt; maxn) &#123;</span><br><span class="line">				sum[h]++;</span><br><span class="line">				if (i &#x3D;&#x3D; j) sum[h]++;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return ix;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	int r &#x3D; get_ans();</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;n)&#x3D;&#x3D;1&amp;&amp;n)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d\n&quot;, sum[n]&#x2F;2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h1><p>1不是N的质因数；若N为质数，N是N的质因数</p>
<h2 id="质因数的个数"><a href="#质因数的个数" class="headerlink" title="质因数的个数"></a>质因数的个数</h2><p>求正整数N(N&gt;1)的质因数的个数。 相同的质因数需要重复计算。如120=2*2*2*3*5，共有5个质因数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100000;</span><br><span class="line">bool notp[maxn];</span><br><span class="line">int prime[maxn];</span><br><span class="line">int res[maxn];</span><br><span class="line">int get_ans() &#123;</span><br><span class="line">	int id &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 2; i &lt; maxn; i++) &#123;</span><br><span class="line">		if (!notp[i]) &#123;</span><br><span class="line">			for (int j &#x3D; 2; i*j &lt; maxn; j++)</span><br><span class="line">				notp[i*j] &#x3D; 1;</span><br><span class="line">			prime[id++] &#x3D; i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return id;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	int r &#x3D; get_ans();</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		int id &#x3D; 0;</span><br><span class="line">		memset(res, 0, sizeof(res));</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">			if (n%prime[i] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				while (n%prime[i] &#x3D;&#x3D; 0)</span><br><span class="line">				&#123;</span><br><span class="line">					res[id]++;</span><br><span class="line">					n &#x2F;&#x3D; prime[i];</span><br><span class="line">				&#125;</span><br><span class="line">				id++;</span><br><span class="line">			&#125;</span><br><span class="line">			if (n &#x3D;&#x3D; 1) break;</span><br><span class="line">		&#125;</span><br><span class="line">		if (n !&#x3D; 1) res[id++] &#x3D; 1;&#x2F;&#x2F;若测试完2~maxn内的所有素数，n仍未被分解成1</span><br><span class="line">							&#x2F;&#x2F;则剩余的余数是一定大于maxn素因数，幂次只能为1</span><br><span class="line"></span><br><span class="line">		int sum &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; id; i++)</span><br><span class="line">			sum +&#x3D; res[i];</span><br><span class="line">		printf(&quot;%d\n&quot;, sum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>maxn取1e5而不是题干中的1e9是因为，对于每个N至多有一个大于sqrt(n)的素因数，这样只需要将小于sqrt(n)的数都除去，剩下的就是该大素因数了。</li>
</ol>
<h2 id="整除问题"><a href="#整除问题" class="headerlink" title="整除问题"></a>整除问题</h2><p>给定n，a求最大的k，使n！可以被a^k整除但不能被a^(k+1)整除。<br>输入两个整数n(2&lt;=n&lt;=1000)，a(2&lt;=a&lt;=1000)<br>输出一个整数</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>由于n!和a^k都可能很大，所以不能直接相除来判断</li>
<li>考虑整除的特征：将n!和a分别分解成素因数的乘积。如果a能整除b，则b/a是整数，则说明a和b中的素因数种类应该相同(两个素数互质)，并且b中素因数pi的幂次应该大于等于a中pi的幂次。之后，确定b中该素因数的幂次是a中对应素因数幂次的几倍，这样最小的那个数即为所求的k。</li>
<li>由于n!很大，所以不能对n!进行素因数分解。现在的目标是想确定n!中含有的素因数p对应的幂指数。n!中每一个素因数p的倍数都至少贡献一个p因子，且1到n中p的倍数共有n/p个，则p因子数至少为n/p个。同理有n/(p*p)个整数至少贡献了两个p因子。</li>
<li>统计所有n!因子中幂次最小的即为所求的k</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">bool notp[maxn];</span><br><span class="line">int prime[maxn];</span><br><span class="line">int res[maxn];</span><br><span class="line">int cnta[maxn];</span><br><span class="line">int get_ans() &#123;&#x2F;&#x2F;求范围内所有的素数</span><br><span class="line">	int id &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 2; i &lt; maxn; i++) &#123;</span><br><span class="line">		if (!notp[i]) &#123;</span><br><span class="line">			for (int j &#x3D; 2; i*j &lt; maxn; j++)</span><br><span class="line">				notp[i*j] &#x3D; 1;</span><br><span class="line">			prime[id++] &#x3D; i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return id;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int a, b;</span><br><span class="line">	int r &#x3D; get_ans();</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;b, &amp;a) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(res, 0, sizeof(res));</span><br><span class="line">		memset(cnta, 0, sizeof(cnta));</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;分解n!</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">			int n &#x3D; b;</span><br><span class="line">			while (n)</span><br><span class="line">			&#123;</span><br><span class="line">				res[i]+&#x3D;n&#x2F;prime[i];</span><br><span class="line">				n &#x2F;&#x3D; prime[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int ans &#x3D; 1e8;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;分解a</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">			if (a%prime[i] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				while (a%prime[i] &#x3D;&#x3D; 0)</span><br><span class="line">				&#123;</span><br><span class="line">					cnta[i]++;</span><br><span class="line">					a &#x2F;&#x3D; prime[i];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if (cnta[i] &#x3D;&#x3D; 0) continue;</span><br><span class="line">			ans &#x3D; min(ans, res[i] &#x2F; cnta[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="约数的个数"><a href="#约数的个数" class="headerlink" title="约数的个数"></a>约数的个数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int get_ans(int n) &#123;</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	int i;</span><br><span class="line">	for (i &#x3D; 1; i*i &lt; n; i++)</span><br><span class="line">		if (n%i &#x3D;&#x3D; 0) ans +&#x3D; 2;</span><br><span class="line">	if (i*i &#x3D;&#x3D; n) ans++;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T,n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		printf(&quot;%d\n&quot;, get_ans(n));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二分求幂"><a href="#二分求幂" class="headerlink" title="二分求幂"></a>二分求幂</h1><h2 id="人见人爱A-B"><a href="#人见人爱A-B" class="headerlink" title="人见人爱A^B"></a>人见人爱A^B</h2><p>求A^B的最后三位数表示的整数。说明：A^B的含义是“A的B次方” </p>
<p>输入数据包含多个测试实例，每个实例占一行，由两个正整数A和B组成（1&lt;=A,B&lt;=10000），如果A=0, B=0，则表示输入数据的结束，不做处理。</p>
<p>对于每个测试实例，请输出A^B的最后三位表示的整数，每个输出占一行。 </p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>由于a,b比较大，所以不能直接求。注意到A^B的后三位只与A的后三位有关，只存后三位即可。</li>
<li>由于A^j可以由A^i次得到，可以借此减少计算次数。可到的幂次包括1,2,4,8…即a^k次是可以由a的1次不断求平方得到的。我们的目标是即分解a的b次变为若干个a的2^k次的积，并尽可能减少分解结果的个数。指数层面就是若2^k次的和，即二进制。可以将幂次转成二进制数，取那些为1的位</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int a, b;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;a, &amp;b) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		if (a &#x3D;&#x3D; 0 &amp;&amp; b &#x3D;&#x3D; 0) break;</span><br><span class="line">		int ans &#x3D; 1;</span><br><span class="line">		while (b)</span><br><span class="line">		&#123;</span><br><span class="line">			if (b % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">				ans *&#x3D; a;</span><br><span class="line">				ans %&#x3D; 1000;</span><br><span class="line">			&#125;</span><br><span class="line">			b &#x2F;&#x3D; 2;</span><br><span class="line">			a *&#x3D; a;	&#x2F;&#x2F;更新权重</span><br><span class="line">			a %&#x3D; 1000;	&#x2F;&#x2F;保留后三位</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HDU-2817"><a href="#HDU-2817" class="headerlink" title="HDU 2817"></a>HDU 2817</h2><p>Xinlv wrote some sequences on the paper a long time ago, they might be arithmetic or geometric sequences. The numbers are not very clear now, and only the first three numbers of each sequence are recognizable. Xinlv wants to know some numbers in these sequences, and he needs your help. </p>
<p><strong>input</strong>:The first line contains an integer N, indicting that there are N sequences. Each of the following N lines contain four integers. The first three indicating the first three numbers of the sequence, and the last one is K, indicating that we want to know the K-th numbers of the sequence.</p>
<p>You can assume 0 &lt; K &lt;= 10^9, and the other three numbers are in the range [0, 2^63). All the numbers of the sequences are integers. And the sequences are non-decreasing. </p>
<p><strong>output</strong> Output one line for each test case, that is, the K-th number module (%) 200907.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1 &lt;&lt; 16;</span><br><span class="line">int a[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	long long a, b, c, k;</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%lld%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c, &amp;k);</span><br><span class="line">		if (b - a &#x3D;&#x3D; c - b) &#123;</span><br><span class="line">			long long tmp &#x3D; (b - a) % 200907;</span><br><span class="line">			a %&#x3D; 200907;</span><br><span class="line">			printf(&quot;%lld\n&quot;, (a + (k - 1)*tmp) % 200907);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;	</span><br><span class="line">			long long ans &#x3D; 1;</span><br><span class="line">			long long t &#x3D; a;</span><br><span class="line">			a &#x3D; b &#x2F; a;</span><br><span class="line">			k--;</span><br><span class="line">			while (k)</span><br><span class="line">			&#123;</span><br><span class="line">				if (k % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">					ans *&#x3D; a;</span><br><span class="line">					ans %&#x3D; 200907;</span><br><span class="line">				&#125;</span><br><span class="line">				k &#x2F;&#x3D; 2;</span><br><span class="line">				a *&#x3D; a;</span><br><span class="line">				a %&#x3D; 200907;</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;%lld\n&quot;,((t% 200907)* ans)% 200907);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="高精度整数"><a href="#高精度整数" class="headerlink" title="高精度整数"></a>高精度整数</h1><h2 id="大整数类"><a href="#大整数类" class="headerlink" title="大整数类"></a>大整数类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BigInteger &#123;</span><br><span class="line">private:</span><br><span class="line">	const static int maxn &#x3D; 1000;</span><br><span class="line">	int digit[maxn];</span><br><span class="line">	int size;	&#x2F;&#x2F;[0,size)</span><br></pre></td></tr></table></figure>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void init() &#123;</span><br><span class="line">	memset(digit, 0, sizeof(digit));</span><br><span class="line">	size &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public:</span><br><span class="line">	void set(char s[]) &#123;</span><br><span class="line">		init();</span><br><span class="line">		int len &#x3D; strlen(s);</span><br><span class="line">		for (int i &#x3D; len - 1, j &#x3D; 0, t &#x3D; 0, c &#x3D; 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			t +&#x3D; (s[i] - &#39;0&#39;)*c;</span><br><span class="line">			c *&#x3D; 10;</span><br><span class="line">			j++;</span><br><span class="line">			if (j &#x3D;&#x3D; 4 || i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				digit[size++] &#x3D; t;</span><br><span class="line">				j &#x3D; 0;</span><br><span class="line">				t &#x3D; 0;</span><br><span class="line">				c &#x3D; 1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void output() &#123;</span><br><span class="line">	for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">		if (i !&#x3D; size - 1)</span><br><span class="line">			printf(&quot;%04d&quot;, digit[i]);	&#x2F;&#x2F;不是最高位则输出前导0</span><br><span class="line">		else printf(&quot;%d&quot;, digit[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id=""><a href="#" class="headerlink" title="+"></a>+</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BigInteger operator + (const BigInteger A) const &#123;</span><br><span class="line">	BigInteger ret;</span><br><span class="line">	ret.init();</span><br><span class="line">	int cf &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; A.size || i &lt; size; i++) &#123;</span><br><span class="line">		int t &#x3D; digit[i] + A.digit[i] + cf;</span><br><span class="line">		cf &#x3D; t &#x2F; 10000;</span><br><span class="line">		ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">	&#125;</span><br><span class="line">	if (cf)</span><br><span class="line">		ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="-1"><a href="#-1" class="headerlink" title="*"></a>*</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BigInteger operator * (const BigInteger &amp;A) const &#123;</span><br><span class="line">	BigInteger ret;</span><br><span class="line">	ret.init();</span><br><span class="line">	int cf &#x3D; 0;</span><br><span class="line">	for (int j &#x3D; 0; j &lt; A.size; j++) &#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] * A.digit[j] + cf;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (cf)</span><br><span class="line">		ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	bool operator &lt; (const BigInteger&amp; A) const &#123;</span><br><span class="line">		if (A.size !&#x3D; size) return size &lt; A.size;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			if (digit[i] !&#x3D; A.digit[i])</span><br><span class="line">				return digit[i] &lt; A.digit[i];</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator &gt; (const BigInteger&amp; A) const &#123; return A &lt; *this; &#125;</span><br><span class="line">	bool operator &lt;&#x3D;(const BigInteger&amp; A) const &#123; return !(A &lt; *this); &#125;</span><br><span class="line">	bool operator &gt;&#x3D;(const BigInteger&amp; A) const &#123; return !(*this &lt; A); &#125;</span><br><span class="line">	bool operator !&#x3D;(const BigInteger&amp; A) const &#123; return *this &lt; A || A &lt; *this; &#125;</span><br><span class="line">	bool operator &#x3D;&#x3D;(const BigInteger&amp; A) const &#123; return !(*this &lt; A) &amp;&amp; !(A &lt; *this); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="N的阶乘"><a href="#N的阶乘" class="headerlink" title="N的阶乘"></a>N的阶乘</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BigInteger operator * (int a) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; size ; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] * a + cf;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;n)&#x3D;&#x3D;1) &#123;</span><br><span class="line">		BigInteger x, y;</span><br><span class="line">		char a[] &#x3D; &quot;1&quot;;</span><br><span class="line">		x.set(a);</span><br><span class="line">		for (int i &#x3D; 2; i &lt;&#x3D; n; i++)</span><br><span class="line">			x&#x3D; x * i;</span><br><span class="line">		x.output();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进制转换-清华"><a href="#进制转换-清华" class="headerlink" title="进制转换(清华)"></a>进制转换(清华)</h2><p>将m进制大整数转成n进制</p>
<ol>
<li>重载了对整型的除法和取余，注意这两部分写法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">class BigInteger &#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">	void init() &#123;</span><br><span class="line">		memset(digit, 0, sizeof(digit));</span><br><span class="line">		size &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	const static int maxn &#x3D; 10000 + 5;</span><br><span class="line">	int digit[maxn];</span><br><span class="line">	int size;</span><br><span class="line">	void set(char s[]) &#123;</span><br><span class="line">		init();</span><br><span class="line">		int len &#x3D; strlen(s);</span><br><span class="line">		for (int i &#x3D; len - 1, j &#x3D; 0, t &#x3D; 0, c &#x3D; 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			t +&#x3D; (s[i] - &#39;0&#39;)*c;</span><br><span class="line">			c *&#x3D; 10;</span><br><span class="line">			j++;</span><br><span class="line">			if (j &#x3D;&#x3D; 4 || i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				digit[size++] &#x3D; t;</span><br><span class="line">				j &#x3D; 0;</span><br><span class="line">				t &#x3D; 0;</span><br><span class="line">				c &#x3D; 1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void output() &#123;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			if (i !&#x3D; size - 1)</span><br><span class="line">				printf(&quot;%04d&quot;, digit[i]);	&#x2F;&#x2F;不是最高位则输出前导0</span><br><span class="line">			else printf(&quot;%d&quot;, digit[i]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BigInteger operator + (const BigInteger A) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; A.size || i &lt; size; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] + A.digit[i] + cf;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BigInteger operator * (int a) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] * a + cf;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">	BigInteger operator * (const BigInteger &amp;A) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; A.size; j++) &#123;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">				int t &#x3D; digit[i] * A.digit[j] + cf;</span><br><span class="line">				cf &#x3D; t &#x2F; 10000;</span><br><span class="line">				ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对整型除法和取模"><a href="#对整型除法和取模" class="headerlink" title="对整型除法和取模"></a>对整型除法和取模</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	BigInteger operator &#x2F; (const int a) &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int remain &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			int t &#x3D; (remain * 10000 + digit[i]) &#x2F; a;</span><br><span class="line">			int r &#x3D; (remain * 10000 + digit[i]) % a;</span><br><span class="line">			ret.digit[i] &#x3D; t;</span><br><span class="line">			remain &#x3D; r;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			if (digit[i] !&#x3D; 0) &#123;</span><br><span class="line">				ret.size &#x3D; i;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		ret.size++;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int operator % (int x) const &#123;</span><br><span class="line">		int remain &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--) </span><br><span class="line">			remain &#x3D; (remain * 10000 + digit[i]) % x;</span><br><span class="line">		return remain;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool operator &lt; (const BigInteger&amp; A) const &#123;</span><br><span class="line">		if (A.size !&#x3D; size) return size &lt; A.size;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			if (digit[i] !&#x3D; A.digit[i])</span><br><span class="line">				return digit[i] &lt; A.digit[i];</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator &gt; (const BigInteger&amp; A) const &#123; return A &lt; *this; &#125;</span><br><span class="line">	bool operator &lt;&#x3D;(const BigInteger&amp; A) const &#123; return !(A &lt; *this); &#125;</span><br><span class="line">	bool operator &gt;&#x3D;(const BigInteger&amp; A) const &#123; return !(*this &lt; A); &#125;</span><br><span class="line">	bool operator !&#x3D;(const BigInteger&amp; A) const &#123; return *this &lt; A || A &lt; *this; &#125;</span><br><span class="line">	bool operator &#x3D;&#x3D;(const BigInteger&amp; A) const &#123; return !(*this &lt; A) &amp;&amp; !(A &lt; *this); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">char s[10000];</span><br><span class="line">char ans[10000];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int m, n;</span><br><span class="line">	while (scanf(&quot;%d%d\n&quot;, &amp;m, &amp;n) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">		scanf(&quot;%s&quot;, s);</span><br><span class="line">		BigInteger a, b;</span><br><span class="line">		char s1[] &#x3D; &quot;0&quot;, s2[] &#x3D; &quot;1&quot;;</span><br><span class="line">		a.set(s1);	&#x2F;&#x2F;用来保存m进制转成的十进制数</span><br><span class="line">		b.set(s2);	&#x2F;&#x2F;记录转成10进制时候的权重</span><br><span class="line">		int len &#x3D; strlen(s);</span><br><span class="line">		for (int i &#x3D; len - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			int t;</span><br><span class="line">			if (s[i] &gt;&#x3D; &#39;0&#39;&amp;&amp;s[i] &lt;&#x3D; &#39;9&#39;)</span><br><span class="line">				t &#x3D; s[i] - &#39;0&#39;;</span><br><span class="line">			else t &#x3D; s[i] - &#39;A&#39; + 10;</span><br><span class="line">			a &#x3D; a + b * t;</span><br><span class="line">			b &#x3D; b * m;</span><br><span class="line">		&#125;</span><br><span class="line">		int id &#x3D; 0;</span><br><span class="line">		do &#123;</span><br><span class="line">			int t &#x3D; a % n;</span><br><span class="line">			if (t &gt;&#x3D; 10) ans[id] &#x3D; t - 10 + &#39;a&#39;;</span><br><span class="line">			else ans[id] &#x3D; t + &#39;0&#39;;</span><br><span class="line">			a &#x3D; a &#x2F; n;</span><br><span class="line">			id++;</span><br><span class="line">		&#125; while (a.digit[0] !&#x3D; 0 || a.size !&#x3D; 1);</span><br><span class="line">		for (int i &#x3D; id - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			printf(&quot;%c&quot;, ans[i]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="大整数取余小数简单代码"><a href="#大整数取余小数简单代码" class="headerlink" title="大整数取余小数简单代码"></a>大整数取余小数简单代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void get_mod(int x) &#123;&#x2F;&#x2F;其中大整数已经由高位到低位依次存在了str中</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; strlen(str); i++) &#123;</span><br><span class="line">		ans *&#x3D; 10;</span><br><span class="line">		ans +&#x3D; str[i] - &#39;0&#39;;</span><br><span class="line">		ans %&#x3D; mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="浮点数加法"><a href="#浮点数加法" class="headerlink" title="浮点数加法"></a>浮点数加法</h2><p>求2个浮点数相加的和 题目中输入输出中出现浮点数都有如下的形式： P1P2…Pi.Q1Q2…Qj 对于整数部分，P1P2…Pi是一个非负整数 对于小数部分，Qj不等于0</p>
<p>输入： 对于每组案例，每组测试数据占2行，分别是两个加数。</p>
<p>输出： 每组案例是n行，每组测试数据有一行输出是相应的和。输出保证一定是一个小数部分不为0的浮点数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;在上述BigInteger中加入对整型的重载加法</span><br><span class="line">BigInteger operator + (const int aa) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		int a &#x3D; aa;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] + a + cf;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">			if (!cf) a &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000000;</span><br><span class="line">char a[maxn], b[maxn];</span><br><span class="line">BigInteger a1, a2, b1, b2;</span><br><span class="line"></span><br><span class="line">inline int get_len(int xx) &#123;</span><br><span class="line">	int len &#x3D; 0;</span><br><span class="line">	while (xx)</span><br><span class="line">	&#123;</span><br><span class="line">		len++;</span><br><span class="line">		xx &#x2F;&#x3D; 10;</span><br><span class="line">	&#125;</span><br><span class="line">	return len;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	string x, y;</span><br><span class="line">	while (getline(cin, x)) &#123;</span><br><span class="line">		getline(cin, y);</span><br><span class="line">		int id &#x3D; x.find(&quot;.&quot;);</span><br><span class="line">		int ix &#x3D; y.find(&quot;.&quot;);</span><br><span class="line">		string s1 &#x3D; x.substr(id + 1).c_str();</span><br><span class="line">		string s2 &#x3D; y.substr(ix + 1).c_str();</span><br><span class="line">		int delen &#x3D; abs(int(s1.length() - s2.length()));</span><br><span class="line">		if (delen)&#x2F;&#x2F;将小数部分补齐成相同位数</span><br><span class="line">			if (s1.length() &lt; s2.length())</span><br><span class="line">				for (int i &#x3D; 0; i &lt; delen; i++)</span><br><span class="line">					s1 +&#x3D; &#39;0&#39;;</span><br><span class="line">			else</span><br><span class="line">				for (int i &#x3D; 0; i &lt; delen; i++)</span><br><span class="line">					s2 +&#x3D; &#39;0&#39;;</span><br><span class="line">		strcpy(a, x.substr(0, id).c_str());</span><br><span class="line">		strcpy(b, s1.c_str());</span><br><span class="line">		a1.set(a);</span><br><span class="line">		a2.set(b);</span><br><span class="line">		strcpy(a, y.substr(0, ix).c_str());</span><br><span class="line">		strcpy(b, s2.c_str());</span><br><span class="line">		b1.set(a);</span><br><span class="line">		b2.set(b);</span><br><span class="line"></span><br><span class="line">		BigInteger t &#x3D; a2 + b2;</span><br><span class="line">		int c &#x3D; 0;</span><br><span class="line">		int len &#x3D; 1;</span><br><span class="line">		int l1, l2;</span><br><span class="line">		l1 &#x3D; get_len(a2.digit[a2.size - 1]);</span><br><span class="line">		l1 &#x3D; max(l1, get_len(b2.digit[b2.size - 1]));</span><br><span class="line">		&#x2F;&#x2F;如果小数部分位数增加说明有进位。需要置进位位并在小数高位减去相应的值。</span><br><span class="line">		&#x2F;&#x2F;具体又分为两种情况</span><br><span class="line">		if (t.size &#x3D;&#x3D; a2.size) &#123;</span><br><span class="line">			l2 &#x3D; get_len(t.digit[t.size - 1]);</span><br><span class="line">			if (l1 !&#x3D; l2)</span><br><span class="line">			&#123;</span><br><span class="line">				c &#x3D; 1;</span><br><span class="line">				int xx &#x3D; b2.digit[b2.size - 1];</span><br><span class="line">				while (xx)</span><br><span class="line">				&#123;</span><br><span class="line">					len *&#x3D; 10;</span><br><span class="line">					xx &#x2F;&#x3D; 10;</span><br><span class="line">				&#125;</span><br><span class="line">				t.digit[t.size - 1] -&#x3D; len;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			c &#x3D; 1;</span><br><span class="line">			t.size--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		len &#x3D; l1 - get_len(t.digit[t.size - 1]);&#x2F;&#x2F;用于控制输出小数时的前导0</span><br><span class="line">		a2 &#x3D; a1 + b1;</span><br><span class="line">		a2 &#x3D; a2 + c;</span><br><span class="line">		a2.output();</span><br><span class="line">		printf(&quot;.&quot;);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">			printf(&quot;0&quot;);</span><br><span class="line">		t.output();</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10进制-vs-2进制"><a href="#10进制-vs-2进制" class="headerlink" title="10进制 vs 2进制"></a>10进制 vs 2进制</h2><p>要求将十进制大整数转成二进制，将二进制序列逆序之后转成十进制输出。</p>
<p>代码都是前面提及的。<strong>但是发现在output函数中，可能输出前导0，所以加入判定条件改为：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void output() &#123;</span><br><span class="line">	for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">		if (i !&#x3D; size - 1)</span><br><span class="line">			printf(&quot;%04d&quot;, digit[i]);	&#x2F;&#x2F;不是最高位则输出前导0</span><br><span class="line">		else if(digit[i])</span><br><span class="line">			printf(&quot;%d&quot;, digit[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;本题主函数</span><br><span class="line"></span><br><span class="line">char s[1005];</span><br><span class="line">bool two[1000000000];</span><br><span class="line">int main() &#123;</span><br><span class="line">	scanf(&quot;%s&quot;, s);</span><br><span class="line">	BigInteger a, b;</span><br><span class="line">	a.set(s);</span><br><span class="line">	int id &#x3D; 0;</span><br><span class="line">	do</span><br><span class="line">	&#123;</span><br><span class="line">		two[id++] &#x3D; a % 2;</span><br><span class="line">		a &#x3D; a &#x2F; 2;</span><br><span class="line"></span><br><span class="line">	&#125; while (a.size !&#x3D; 1 || a.digit[0] !&#x3D; 0);</span><br><span class="line">	char xx[] &#x3D; &quot;0&quot;, yy[] &#x3D; &quot;1&quot;;</span><br><span class="line">	a.set(xx);&#x2F;&#x2F;0</span><br><span class="line">	b.set(yy);&#x2F;&#x2F;1</span><br><span class="line">	for (int i &#x3D; id - 1; i &gt;&#x3D; 0;i--) &#123;</span><br><span class="line"></span><br><span class="line">		a &#x3D; a + b * two[i];</span><br><span class="line">		b &#x3D; b * 2;</span><br><span class="line">	&#125;</span><br><span class="line">	a.output();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2020/02/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h2><p>在某个字符串（长度不超过100）中有左括号、右括号和大小写字母；规定（与常见的算数式子一样）任何一个左括号都从内到外与在它右边且距离最近的右括号匹配。写一个程序，找到无法匹配的左括号和右括号，输出原来字符串，并在下一行标出不能匹配的括号。不能匹配的左括号用”$”标注,不能匹配的右括号用”?”标注。 </p>
<h3 id="栈中存索引"><a href="#栈中存索引" class="headerlink" title="栈中存索引"></a>栈中存索引</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">char s[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%s&quot;, s) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">		printf(&quot;%s\n&quot;, s);</span><br><span class="line">		stack&lt;int&gt; st;</span><br><span class="line">		char ans[maxn];</span><br><span class="line">		for (int i &#x3D; 0;i&lt;strlen(s);i++) &#123;</span><br><span class="line">			if (s[i] &#x3D;&#x3D; &#39;(&#39;) &#123;</span><br><span class="line">				ans[i] &#x3D; &#39; &#39;;</span><br><span class="line">				st.push(i);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			else if (s[i] &#x3D;&#x3D; &#39;)&#39;) &#123;</span><br><span class="line">				if (!st.empty()&amp;&amp;s[st.top()] &#x3D;&#x3D; &#39;(&#39;) &#123;</span><br><span class="line">					ans[i] &#x3D; &#39; &#39;;</span><br><span class="line">					st.pop();</span><br><span class="line">				&#125;</span><br><span class="line">				else </span><br><span class="line">					ans[i] &#x3D; &#39;?&#39;;</span><br><span class="line">			&#125;</span><br><span class="line">			else ans[i] &#x3D; &#39; &#39;;</span><br><span class="line">		&#125;</span><br><span class="line">		while (!st.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			ans[st.top()] &#x3D; &#39;$&#39;;</span><br><span class="line">			st.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		ans[strlen(s)] &#x3D; &#39;\0&#39;;</span><br><span class="line">		printf(&quot;%s\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单计算器"><a href="#简单计算器" class="headerlink" title="简单计算器"></a>简单计算器</h2><p> 读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。</p>
<p>没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。</p>
<p> 对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>开一个运算符栈一个操作数栈。主要在于判断各符号间的优先级，当当前读取的符号优先级低于栈顶的时候，应该先把栈顶运算符用了。其他都是小的细节问题。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 200 + 5;</span><br><span class="line">char s[maxn];</span><br><span class="line">bool is_op(char c) &#123; return c &#x3D;&#x3D; &#39;+&#39; || c &#x3D;&#x3D; &#39;-&#39; || c &#x3D;&#x3D; &#39;*&#39; || c &#x3D;&#x3D; &#39;&#x2F;&#39;; &#125;</span><br><span class="line">bool first(char a, char b) &#123;</span><br><span class="line">	if (a &#x3D;&#x3D; &#39;*&#39; || a &#x3D;&#x3D; &#39;&#x2F;&#39;)</span><br><span class="line">		return true;</span><br><span class="line">	else if (a &#x3D;&#x3D; &#39;-&#39; || a &#x3D;&#x3D; &#39;+&#39;) &#123;</span><br><span class="line">		if (b !&#x3D; &#39;*&#39; &amp;&amp; b !&#x3D; &#39;&#x2F;&#39;)</span><br><span class="line">			return true;</span><br><span class="line">		else return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">double calu(double a, double b, char op) &#123;</span><br><span class="line">	switch (op) &#123;</span><br><span class="line">	case &#39;+&#39;:return a + b; break;</span><br><span class="line">	case &#39;-&#39;:return a - b; break;</span><br><span class="line">	case &#39;*&#39;:return a * b; break;</span><br><span class="line">	case &#39;&#x2F;&#39;:return a &#x2F; b; break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (cin.getline(s, 201) &amp;&amp; s[0] !&#x3D; &#39;0&#39;) &#123;</span><br><span class="line">		stack&lt;double&gt; num;</span><br><span class="line">		stack&lt;char&gt; op;</span><br><span class="line">		int index &#x3D; 0;</span><br><span class="line">		while (index &lt; strlen(s)) &#123;</span><br><span class="line">			if (s[index] &#x3D;&#x3D; &#39; &#39;) index++;</span><br><span class="line">			int n &#x3D; 0;</span><br><span class="line">			while (isdigit(s[index]))</span><br><span class="line">			&#123;</span><br><span class="line">				n *&#x3D; 10;</span><br><span class="line">				n +&#x3D; s[index++] - &#39;0&#39;;</span><br><span class="line">			&#125;</span><br><span class="line">			if (n) num.push(n);</span><br><span class="line">			else &#123;</span><br><span class="line">				if (op.empty()) op.push(s[index]);</span><br><span class="line">				else &#123;</span><br><span class="line"></span><br><span class="line">					while (!op.empty() &amp;&amp; first(op.top(), s[index]))</span><br><span class="line">					&#123;</span><br><span class="line">						double a &#x3D; num.top(); num.pop();</span><br><span class="line">						double b &#x3D; num.top(); num.pop();</span><br><span class="line">						char oper;</span><br><span class="line">						oper &#x3D; op.top(); op.pop();</span><br><span class="line">						num.push(calu(b, a, oper));</span><br><span class="line">					&#125;</span><br><span class="line">					op.push(s[index]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">				index++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		while (!op.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			char oper &#x3D; op.top(); op.pop();</span><br><span class="line">			double a &#x3D; num.top(); num.pop();</span><br><span class="line">			double b &#x3D; num.top(); num.pop();</span><br><span class="line">			double ans &#x3D; calu(b, a, oper);</span><br><span class="line">			num.push(ans);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;%.2lf\n&quot;, num.top());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><h2 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h2><p>使用递减的优先级队列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;搬水果</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pq;</span><br><span class="line"></span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n)&#x3D;&#x3D;1 &amp;&amp;n) &#123;</span><br><span class="line">		int x;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">			pq.push(x);</span><br><span class="line">		&#125;</span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		while (pq.size()&gt;1) &#123;</span><br><span class="line">			int a &#x3D; pq.top(); pq.pop();</span><br><span class="line">			int b &#x3D; pq.top(); pq.pop();</span><br><span class="line">			ans +&#x3D; a + b;</span><br><span class="line">			pq.push(a + b);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树遍历-华科"><a href="#二叉树遍历-华科" class="headerlink" title="二叉树遍历 华科"></a>二叉树遍历 华科</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 26 + 1;</span><br><span class="line">char pre[maxn], in[maxn];</span><br><span class="line"></span><br><span class="line">typedef struct node &#123;</span><br><span class="line">	struct node *lchild, *rchild;</span><br><span class="line">	char data;</span><br><span class="line">&#125;node, *ptr;</span><br><span class="line"></span><br><span class="line">ptr create(char *pre, char *in, int n) &#123;</span><br><span class="line">	ptr s;</span><br><span class="line">	if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">		s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">		s-&gt;data &#x3D; *pre;</span><br><span class="line">		s-&gt;rchild &#x3D; s-&gt;lchild &#x3D; NULL;</span><br><span class="line">		return s;</span><br><span class="line">	&#125;</span><br><span class="line">	char *p;</span><br><span class="line">	for (p &#x3D; in; p &lt; in + n; p++)</span><br><span class="line">		if (*p &#x3D;&#x3D; *pre) break;</span><br><span class="line">	int k &#x3D; p - in;</span><br><span class="line"></span><br><span class="line">	s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">	s-&gt;data &#x3D; *p;</span><br><span class="line">	s-&gt;rchild &#x3D; s-&gt;lchild &#x3D; NULL;</span><br><span class="line">	if (k) s-&gt;lchild &#x3D; create(pre + 1, in, k);</span><br><span class="line">	if (n - k - 1) s-&gt;rchild &#x3D; create(pre + k + 1, p + 1, n - k - 1);</span><br><span class="line">	return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void post_order(ptr T) &#123;</span><br><span class="line">	if (T-&gt;lchild) post_order(T-&gt;lchild);</span><br><span class="line">	if (T-&gt;rchild)post_order(T-&gt;rchild);</span><br><span class="line">	printf(&quot;%c&quot;, T-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%s&quot;, pre) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">		scanf(&quot;%s&quot;, in);</span><br><span class="line">		ptr T &#x3D; create(&amp;pre[0], &amp;in[0], strlen(pre));</span><br><span class="line">		post_order(T);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树遍历-清华"><a href="#二叉树遍历-清华" class="headerlink" title="二叉树遍历 清华"></a>二叉树遍历 清华</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 1;</span><br><span class="line">char pre[maxn];</span><br><span class="line">typedef struct node &#123;</span><br><span class="line">	struct node *lchild, *rchild;</span><br><span class="line">	char data;</span><br><span class="line">&#125;node, *ptr;</span><br><span class="line">ptr create(int &amp;cur, const char * pre, int n) &#123;</span><br><span class="line">	if (cur &#x3D;&#x3D; n || pre[cur] &#x3D;&#x3D; &#39;#&#39;) return NULL;</span><br><span class="line"></span><br><span class="line">	ptr s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">	s-&gt;data &#x3D; pre[cur];</span><br><span class="line">	cur++;</span><br><span class="line">	s-&gt;lchild &#x3D; create(cur, pre, n);</span><br><span class="line">	cur++;</span><br><span class="line">	s-&gt;rchild &#x3D; create(cur, pre, n);</span><br><span class="line">	return s;</span><br><span class="line">&#125;</span><br><span class="line">void in_order(ptr T) &#123;</span><br><span class="line">	if (T-&gt;lchild !&#x3D; NULL) in_order(T-&gt;lchild);</span><br><span class="line">	printf(&quot;%c &quot;, T-&gt;data);</span><br><span class="line">	if (T-&gt;rchild !&#x3D; NULL) in_order(T-&gt;rchild);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%s&quot;, pre) &#x3D;&#x3D; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		int a &#x3D; 0;</span><br><span class="line">		ptr T &#x3D; create(a, pre, strlen(pre));</span><br><span class="line">		in_order(T);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><h2 id="创建二叉排序树"><a href="#创建二叉排序树" class="headerlink" title="创建二叉排序树"></a>创建二叉排序树</h2><p><strong>此处是递归的逐个节点比较。由于二叉排序树的特殊性，也可以使用前中序遍历序列或中后序遍历序列比较</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct node &#123;</span><br><span class="line">	struct node *lchild, *rchild;</span><br><span class="line">	int data;</span><br><span class="line">&#125;node, *ptr;</span><br><span class="line"></span><br><span class="line">ptr insert(ptr T, int x) &#123;</span><br><span class="line">	if (T &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		T &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">		T-&gt;data &#x3D; x;</span><br><span class="line">		T-&gt;lchild &#x3D; T-&gt;rchild &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		if (x &gt; T-&gt;data)</span><br><span class="line">			T-&gt;rchild &#x3D; insert(T-&gt;rchild, x);</span><br><span class="line">		else if (x &lt; T-&gt;data)</span><br><span class="line">			T-&gt;lchild &#x3D; insert(T-&gt;lchild, x);</span><br><span class="line">	&#125;</span><br><span class="line">	return T;</span><br><span class="line">&#125;</span><br><span class="line">void pre_order(ptr T) &#123;</span><br><span class="line">	printf(&quot;%d &quot;, T-&gt;data);</span><br><span class="line">	if (T-&gt;lchild !&#x3D; NULL) pre_order(T-&gt;lchild);</span><br><span class="line">	if (T-&gt;rchild !&#x3D; NULL)pre_order(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void in_order(ptr T) &#123;</span><br><span class="line">	if (T-&gt;lchild !&#x3D; NULL)	in_order(T-&gt;lchild);</span><br><span class="line">	printf(&quot;%d &quot;, T-&gt;data);</span><br><span class="line">	if (T-&gt;rchild !&#x3D; NULL) in_order(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void post_order(ptr T) &#123;</span><br><span class="line">	if (T-&gt;lchild !&#x3D; NULL) post_order(T-&gt;lchild);</span><br><span class="line">	if (T-&gt;rchild !&#x3D; NULL) post_order(T-&gt;rchild);</span><br><span class="line">	printf(&quot;%d &quot;, T-&gt;data);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;n)&#x3D;&#x3D;1)</span><br><span class="line">	&#123;</span><br><span class="line">		ptr T &#x3D; NULL;</span><br><span class="line">		int x;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">			T &#x3D; insert(T, x);</span><br><span class="line">		&#125;</span><br><span class="line">		pre_order(T);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">		in_order(T);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">		post_order(T);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树搜索-判断树同构"><a href="#二叉树搜索-判断树同构" class="headerlink" title="二叉树搜索(判断树同构)"></a>二叉树搜索(判断树同构)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct node &#123;</span><br><span class="line">	struct node *lchild, *rchild;</span><br><span class="line">	int data;</span><br><span class="line">&#125;node, *ptr;</span><br><span class="line"></span><br><span class="line">ptr insert(ptr T, int x) &#123;</span><br><span class="line">	if (T &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		T &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">		T-&gt;data &#x3D; x;</span><br><span class="line">		T-&gt;lchild &#x3D; T-&gt;rchild &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		if (x &gt; T-&gt;data)</span><br><span class="line">			T-&gt;rchild &#x3D; insert(T-&gt;rchild, x);</span><br><span class="line">		else if (x &lt; T-&gt;data)</span><br><span class="line">			T-&gt;lchild &#x3D; insert(T-&gt;lchild, x);</span><br><span class="line">	&#125;</span><br><span class="line">	return T;</span><br><span class="line">&#125;</span><br><span class="line">bool equal(ptr  T1, ptr T2) &#123;</span><br><span class="line">	if (T1 &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		if (T2 &#x3D;&#x3D; NULL) return true;</span><br><span class="line">		else return false;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (T1-&gt;data &#x3D;&#x3D; T2-&gt;data)</span><br><span class="line">		return equal(T1-&gt;lchild, T2-&gt;lchild) &amp;&amp;</span><br><span class="line">		equal(T1-&gt;rchild, T2-&gt;rchild);</span><br><span class="line"></span><br><span class="line">	return false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		ptr T &#x3D; NULL;</span><br><span class="line">		char x;</span><br><span class="line">		getchar();</span><br><span class="line">		while (scanf(&quot;%c&quot;, &amp;x) &#x3D;&#x3D; 1 &amp;&amp; x !&#x3D; &#39;\n&#39;)</span><br><span class="line">			T &#x3D; insert(T, x - &#39;0&#39;);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			ptr T2 &#x3D; NULL;</span><br><span class="line">			while (scanf(&quot;%c&quot;, &amp;x) &#x3D;&#x3D; 1 &amp;&amp; x !&#x3D; &#39;\n&#39;)</span><br><span class="line">				T2 &#x3D; insert(T2, x - &#39;0&#39;);</span><br><span class="line">			if (equal(T, T2))</span><br><span class="line">				printf(&quot;YES\n&quot;);</span><br><span class="line">			else printf(&quot;NO\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除二叉排序树上的节点"><a href="#删除二叉排序树上的节点" class="headerlink" title="删除二叉排序树上的节点"></a>删除二叉排序树上的节点</h2><ol>
<li>找到这个节点</li>
<li>若该节点为叶子节点，则直接删除，即将其父节点指向其的指针置为空</li>
<li>若该节点仅不存在右子树，那么直接将左子树的根节点替代其位置后，删除该节点。</li>
<li>若该节点存在右子树，那么用其右子树最右下节点(即右子树中序遍历的第一个点)替换，并删除最右下节点。</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>基础相关</title>
    <url>/2020/02/07/%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h1><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const static int Month[13][2] &#x3D; &#123;</span><br><span class="line">	&#123;0,0&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;28,29&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;30,30&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;30,30&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;30,30&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;30,30&#125;,</span><br><span class="line">	&#123;31,31&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct  Date</span><br><span class="line">&#123;</span><br><span class="line">	int year;</span><br><span class="line">	int month;</span><br><span class="line">	int day;</span><br><span class="line"></span><br><span class="line">	Date(int d, int m, int y) :year(y), day(d), month(m) &#123;&#125;;</span><br><span class="line">	bool isLeap(int year) &#123;</span><br><span class="line">		return year % 100 !&#x3D; 0 &amp;&amp; year % 4 &#x3D;&#x3D; 0 || year % 400 &#x3D;&#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void nextDay() &#123;</span><br><span class="line">		day++;</span><br><span class="line">		if (day &gt; Month[month][isLeap(year)]) &#123;</span><br><span class="line">			day &#x3D; 1;</span><br><span class="line">			month++;</span><br><span class="line">			if (month &gt; 12) &#123;</span><br><span class="line">				month &#x3D; 1;</span><br><span class="line">				year++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="打表"><a href="#打表" class="headerlink" title="打表"></a>打表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int cnt &#x3D; 0;</span><br><span class="line">	Date tmp(1,1,0) ;</span><br><span class="line">	while (tmp.year&lt;&#x3D;5000)</span><br><span class="line">	&#123;</span><br><span class="line">		buf[tmp.year][tmp.month][tmp.day]  &#x3D; cnt;</span><br><span class="line">		tmp.nextDay();</span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求两个日期间隔多少天-日期差值"><a href="#求两个日期间隔多少天-日期差值" class="headerlink" title="求两个日期间隔多少天 日期差值"></a>求两个日期间隔多少天 日期差值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	</span><br><span class="line">	int y1, m1, d1;</span><br><span class="line">	int y2, m2, d2;</span><br><span class="line">	while (scanf(&quot;%4d %2d %2d&quot;,&amp;y1,&amp;m1,&amp;d1))</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%4d %2d %2d&quot;, &amp;y2, &amp;m2, &amp;d2);</span><br><span class="line">		printf(&quot;%d\n&quot;, abs(buf[y1][m1][d1] - buf[y2][m2][d2])+1);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>注意输入%xd的方法。+1别忘了</li>
<li>将输入日期统一到0年1月1日为起点</li>
</ol>
<h3 id="求给定日期是星期几-Day-of-Week"><a href="#求给定日期是星期几-Day-of-Week" class="headerlink" title="求给定日期是星期几 Day of Week"></a>求给定日期是星期几 Day of Week</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const static char NMonth[13][20] &#x3D; &#123;</span><br><span class="line">	&quot;&quot;,</span><br><span class="line">	&quot;January&quot;,</span><br><span class="line">	&quot;February&quot;,</span><br><span class="line">	&quot;March&quot;,</span><br><span class="line">	&quot;April&quot;,</span><br><span class="line">	&quot;May&quot;,</span><br><span class="line">	&quot;June&quot;,</span><br><span class="line">	&quot;July&quot;,</span><br><span class="line">	&quot;August&quot;,</span><br><span class="line">	&quot;September&quot;,</span><br><span class="line">	&quot;October&quot;,</span><br><span class="line">	&quot;November&quot;,</span><br><span class="line">	&quot;December&quot;</span><br><span class="line">&#125;;</span><br><span class="line">const static char week[7][20] &#x3D; &#123;</span><br><span class="line">	&quot;Sunday&quot;,</span><br><span class="line">	&quot;Monday&quot;,</span><br><span class="line">	&quot;Tuesday&quot;,</span><br><span class="line">	&quot;Wednesday&quot;,</span><br><span class="line">	&quot;Thursday&quot;,</span><br><span class="line">	&quot;Friday&quot;,</span><br><span class="line">	&quot;Saturday&quot;</span><br><span class="line">&#125;;</span><br><span class="line">int y, d;</span><br><span class="line">char month[20];</span><br><span class="line">while (scanf(&quot;%d%s%4d&quot;, &amp;d, month, &amp;y) !&#x3D; EOF)</span><br><span class="line">&#123;</span><br><span class="line">	int m;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; 12; i++)</span><br><span class="line">		if (!strcmp(month, NMonth[i])) &#123;</span><br><span class="line">			m &#x3D; i;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	int days &#x3D; buf[y][m][d] - buf[2020][2][5];</span><br><span class="line">	days +&#x3D; 3;</span><br><span class="line">	printf(&quot;%s\n&quot;, week[(days % 7 + 7) % 7]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure>
<ol>
<li>也是将输入日期统一到0年1月1日为起点</li>
<li>然后计算与今天的差，</li>
</ol>
<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><h2 id="输出前m大的数"><a href="#输出前m大的数" class="headerlink" title="输出前m大的数"></a>输出前m大的数</h2><p>将数值看成数组下标，从数组尾部开始输出m个存在的数字。</p>
<h2 id="其他使用"><a href="#其他使用" class="headerlink" title="其他使用"></a>其他使用</h2><ol>
<li>主要是记录每个数字出现的次数的思想</li>
</ol>
<h1 id="排版题"><a href="#排版题" class="headerlink" title="排版题"></a>排版题</h1><h2 id="输出梯形"><a href="#输出梯形" class="headerlink" title="输出梯形"></a>输出梯形</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">#pragma warning(disable:4996)</span><br><span class="line">const int maxn &#x3D; 1005;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">	&#123;</span><br><span class="line">		int m &#x3D; n + 2 * (n - 1);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; m-n-2*i; j++) &#123;</span><br><span class="line">				printf(&quot; &quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; n+i*2; j++) &#123;</span><br><span class="line">				printf(&quot;*&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="叠筐-HDU2074"><a href="#叠筐-HDU2074" class="headerlink" title="叠筐 HDU2074"></a>叠筐 HDU2074</h2><p>需要的时候，就把一个个大小差一圈的筐叠上去，使得从上往下看时，边筐花色交错。这个工作现在要让计算机来完成，得看你的了。<br>输入是一个个的三元组，分别是，外筐尺寸n（n为满足0&lt;n&lt;80的奇整数），中心花色字符，外筐花色字符，后二者都为ASCII可见字符；<br>输出叠在一起的筐图案，中心花色与外筐花色字符从内层起交错相叠，多筐相叠时，最外筐的角总是被打磨掉。叠筐与叠筐之间应有一行间隔。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 80 + 5;</span><br><span class="line">char g[maxn][maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	char a, b;</span><br><span class="line">	int first &#x3D; 1;</span><br><span class="line">	while (scanf(&quot;%d %c %c\n&quot;, &amp;n, &amp;b, &amp;a) &#x3D;&#x3D; 3)</span><br><span class="line">	&#123;</span><br><span class="line">		if (((n - 1) &#x2F; 2) % 2 &#x3D;&#x3D; 0) std::swap(a, b);</span><br><span class="line">		memset(g, b, sizeof(g));</span><br><span class="line">		if (first) first &#x3D; 0;</span><br><span class="line">		else printf(&quot;\n&quot;);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i +&#x3D; 2) &#123;</span><br><span class="line">			for (int j &#x3D; i; j &lt; n - 2 * i + i; j++) &#123;</span><br><span class="line">				g[i][j] &#x3D; g[n - i - 1][j] &#x3D; a;</span><br><span class="line">				g[j][i] &#x3D; g[j][n - i - 1] &#x3D; a;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (n !&#x3D; 1)</span><br><span class="line">			g[0][0] &#x3D; g[0][n - 1] &#x3D; g[n - 1][0] &#x3D; g[n - 1][n - 1] &#x3D; &#39; &#39;;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">				printf(&quot;%c&quot;, g[i][j]);</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Repeater"><a href="#Repeater" class="headerlink" title="Repeater"></a>Repeater</h2><p>Harmony is indispensible in our daily life and no one can live without it—-may be Facer is the only exception. One day it is rumored that repeat painting will create harmony and then hundreds of people started their endless drawing. Their paintings were based on a small template and a simple method of duplicating. Though Facer can easily imagine the style of the whole picture, but he cannot find the essential harmony. Now you need to help Facer by showing the picture on computer. You will be given a template containing only one kind of character and spaces, and the template shows how the endless picture is created—-use the characters as basic elements and put them in the right position to form a bigger template, and then repeat and repeat doing that. Here is an example. # #  #      &lt;-template # # So the Level 1 picture will be # #  # # # Level 2 picture will be # #     # #  #         # # #     # #      # #         #         # #   # #    # #  #        # # #    # #</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 3000 + 5;</span><br><span class="line">char g[maxn][maxn];</span><br><span class="line">char tmp[maxn][maxn];</span><br><span class="line">char tmp2[maxn][maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int p, q;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;p) &#x3D;&#x3D; 1 &amp;&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		getchar();</span><br><span class="line">		memset(g, &#39; &#39;, sizeof(g));</span><br><span class="line">		for (int i &#x3D; 0; i &lt; p; i++)</span><br><span class="line">			std::cin.getline(g[i], 6);</span><br><span class="line"></span><br><span class="line">		scanf(&quot;%d&quot;, &amp;q);</span><br><span class="line"></span><br><span class="line">		memcpy(tmp, g, sizeof(g));</span><br><span class="line">		if (q !&#x3D; 1)</span><br><span class="line">			for (int scale &#x3D; 2; scale &lt;&#x3D; q; scale++) &#123;&#x2F;&#x2F;代</span><br><span class="line">				memset(tmp2, &#39; &#39;, sizeof(tmp2));</span><br><span class="line">				int r , c ;</span><br><span class="line">				int oldr, oldc;</span><br><span class="line">				oldr &#x3D; oldc &#x3D; pow(p, scale - 1);</span><br><span class="line">				for (int i &#x3D; 0; i &lt; p; i++) &#123;</span><br><span class="line">					for (int j &#x3D; 0; j &lt; p; j++) &#123;&#x2F;&#x2F;初代模板</span><br><span class="line">						r &#x3D; i * oldr;</span><br><span class="line">						c &#x3D; j * oldc;</span><br><span class="line">						if (g[i][j] !&#x3D; &#39; &#39;) &#123;</span><br><span class="line">							for (int k &#x3D; 0; k &lt; oldr; k++) &#123;&#x2F;&#x2F;在元素处复制模板</span><br><span class="line">								for (int f &#x3D; 0; f &lt; oldc; f++)</span><br><span class="line">									tmp2[r + k][c + f] &#x3D; tmp[k][f];</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				memcpy(tmp, tmp2,sizeof(tmp2));</span><br><span class="line">			&#125;</span><br><span class="line">		for (int k &#x3D; 0; k &lt; pow(p, q); k++) &#123;</span><br><span class="line">			for (int f &#x3D; 0; f &lt; pow(p, q); f++) &#123;</span><br><span class="line"></span><br><span class="line">				printf(&quot;%c&quot;, tmp[k][f]);</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="查找学生信息-二分查找"><a href="#查找学生信息-二分查找" class="headerlink" title="查找学生信息 二分查找"></a>查找学生信息 二分查找</h2><p>输入N个学生的信息，然后进行查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">	int no;</span><br><span class="line">	string name;</span><br><span class="line">	string sex;</span><br><span class="line">	int age;</span><br><span class="line">	node() &#123;&#125;;</span><br><span class="line">	node(int no, string name, string sex, int age)</span><br><span class="line">		:no(no), name(name), sex(sex), age(age) &#123;&#125;;</span><br><span class="line">	bool operator &lt; (const node &amp;a) const &#123;</span><br><span class="line">		return no &lt; a.no;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">node stu[maxn];</span><br><span class="line">int bsearch(int l, int r, int q) &#123;</span><br><span class="line">	while (l &lt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		int m &#x3D; l + (r - l) &#x2F; 2;</span><br><span class="line">		if (stu[m].no &#x3D;&#x3D; q) return m;</span><br><span class="line">		else if (stu[m].no &gt; q) r &#x3D; m;</span><br><span class="line">		else l &#x3D; m + 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (cin&gt;&gt;n&amp;&amp;n) &#123;</span><br><span class="line">		string  b, c;</span><br><span class="line">		int a,d;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">			stu[i] &#x3D; node(a, b, c, d);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(stu, stu + n);</span><br><span class="line">		int m;</span><br><span class="line">		cin &gt;&gt; m;</span><br><span class="line">		int que;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			cin &gt;&gt; que;</span><br><span class="line">			int ans &#x3D; bsearch(0, n, que);</span><br><span class="line">			ans !&#x3D; -1 ? cout &lt;&lt; stu[ans].no&lt;&lt;&quot; &quot;&lt;&lt;stu[ans].name&lt;&lt;&quot; &quot;&lt;&lt;stu[ans].sex&lt;&lt;&quot; &quot;&lt;&lt;stu[ans].age &lt;&lt; endl </span><br><span class="line">				: cout &lt;&lt; &quot;No Answer!&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打印极值点下标"><a href="#打印极值点下标" class="headerlink" title="打印极值点下标"></a>打印极值点下标</h2><p>在一个整数数组上，对于下标为i的整数，如果它大于所有它相邻的整数， 或者小于所有它相邻的整数，则称为该整数为一个极值点，极值点的下标就是i。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 80 + 5;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line"></span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n)&#x3D;&#x3D;1&amp;&amp;n)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		int x;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		if (n &gt; 2) &#123;</span><br><span class="line">			if (a[2] &gt; a[1]) a[0] &#x3D; a[1] + 1;</span><br><span class="line">			else if(a[2] &lt; a[1]) a[0] &#x3D; a[1] - 1;</span><br><span class="line">			else a[0] &#x3D; a[1];</span><br><span class="line">		&#125;</span><br><span class="line">		if (a[n - 1] &lt; a[n]) a[n + 1] &#x3D; a[n] - 1;</span><br><span class="line">		else if (a[n - 1] &gt; a[n]) a[n + 1] &#x3D; a[n] + 1;</span><br><span class="line">		else a[n + 1] &#x3D; a[n];</span><br><span class="line"></span><br><span class="line">		int first &#x3D; 1;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			int x &#x3D; a[i] - a[i - 1];</span><br><span class="line">			int y &#x3D; a[i] - a[i + 1];</span><br><span class="line">			</span><br><span class="line">			if (x*y &gt; 0) &#123;</span><br><span class="line">				if (first) first &#x3D; 0;</span><br><span class="line">				else printf(&quot; &quot;);</span><br><span class="line">				printf(&quot;%d&quot;, i-1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><p>读入一组字符串（待操作的），再读入一个int n记录记下来有几条命令，总共有2中命令：1、翻转  从下标为i的字符开始到i+len-1之间的字符串倒序；2、替换  命中如果第一位为1，用命令的第四位开始到最后的字符串替换原读入的字符串下标 i 到 i+len-1的字符串。每次执行一条命令后新的字符串代替旧的字符串（即下一条命令在作用在得到的新字符串上）。     命令格式：第一位0代表翻转，1代表替换；第二位代表待操作的字符串的起始下标int i；第三位表示需要操作的字符串长度int len。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">char s[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%s&quot;,s)&#x3D;&#x3D;1)</span><br><span class="line">	&#123;</span><br><span class="line">		int n;</span><br><span class="line">		int first &#x3D; 1;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		int op, index, len;</span><br><span class="line">		char ex[maxn];</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%1d%1d%1d&quot;, &amp;op, &amp;index, &amp;len);</span><br><span class="line">			if (op) scanf(&quot;%s&quot;,ex);</span><br><span class="line">			if (op &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				for (int j &#x3D; 0; 2*j &lt; len; j++) &#123;</span><br><span class="line">					swap(s[index + j], s[index + len - j-1]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				char tmp[maxn]&#123;&#39;\0&#39;&#125;;</span><br><span class="line">				for (int j &#x3D; 0; j &lt; index; j++) tmp[j] &#x3D; s[j];</span><br><span class="line">				for (int j &#x3D; 0; j &lt; strlen(ex); j++)</span><br><span class="line">					tmp[j + index] &#x3D; ex[j];</span><br><span class="line">				for (int j &#x3D; index; j &lt; strlen(s); j++)</span><br><span class="line">					tmp[j+strlen(ex)] &#x3D; s[j+len];</span><br><span class="line"></span><br><span class="line">				memcpy(s, tmp, sizeof(tmp));</span><br><span class="line">			&#125;</span><br><span class="line">			if (first) first &#x3D; 0;</span><br><span class="line">			else printf(&quot;\n&quot;);</span><br><span class="line">			printf(&quot;%s&quot;, s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="FatMouse’s-Trade"><a href="#FatMouse’s-Trade" class="headerlink" title="FatMouse’s Trade"></a>FatMouse’s Trade</h2><p>FatMouse prepared M pounds of cat food, ready to trade with the cats guarding the warehouse containing his favorite food, JavaBean.<br>The warehouse has N rooms. The i-th room contains J[i] pounds of JavaBeans and requires F[i] pounds of cat food. FatMouse does not have to trade for all the JavaBeans in the room, instead, he may get J[i]* a% pounds of JavaBeans if he pays F[i]* a% pounds of cat food. Here a is a real number. Now he is assigning this homework to you: tell him the maximum amount of JavaBeans he can obtain. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int j;</span><br><span class="line">	int f;</span><br><span class="line">	double v;</span><br><span class="line">	bool operator &lt;(const node &amp;a) const &#123; return v &lt; a.v; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node a[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int m, n;</span><br><span class="line">	int j, f;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;m, &amp;n) &amp;&amp; m !&#x3D; -1 &amp;&amp; n !&#x3D; -1) &#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;j, &amp;f);</span><br><span class="line">			a[i].f &#x3D; f;</span><br><span class="line">			a[i].j &#x3D; j;</span><br><span class="line">			a[i].v &#x3D; double(j) &#x2F; f;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a, a + n);</span><br><span class="line">		double ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			if (m &gt; a[i].f) &#123;</span><br><span class="line">				m -&#x3D; a[i].f;</span><br><span class="line">				ans +&#x3D; a[i].j;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				ans +&#x3D; double(m) * a[i].j &#x2F; a[i].f;</span><br><span class="line">				m &#x3D; 0;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (m &lt;&#x3D; 0) break;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%.3f\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择不连续区间问题"><a href="#选择不连续区间问题" class="headerlink" title="选择不连续区间问题"></a>选择不连续区间问题</h2><h2 id="迷瘴"><a href="#迷瘴" class="headerlink" title="迷瘴"></a>迷瘴</h2><p>通过悬崖的yifenfei，又面临着幽谷的考验——<br>幽谷周围瘴气弥漫，静的可怕，隐约可见地上堆满了骷髅。由于此处长年不见天日，导致空气中布满了毒素，一旦吸入体内，便会全身溃烂而死。<br>幸好yifenfei早有防备，提前备好了解药材料（各种浓度的万能药水）。现在只需按照配置成不同比例的浓度。<br>现已知yifenfei随身携带有n种浓度的万能药水，体积V都相同，浓度则分别为Pi%。并且知道，针对当时幽谷的瘴气情况，只需选择部分或者全部的万能药水，然后配置出浓度不大于 W%的药水即可解毒。<br>现在的问题是：如何配置此药，能得到最大体积的当前可用的解药呢？<br>特别说明：由于幽谷内设备的限制,只允许把一种已有的药全部混入另一种之中（即：不能出现对一种药只取它的一部分这样的操作）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">int a[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	int n, v, w;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, &amp;n, &amp;v, &amp;w);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a, a + n);</span><br><span class="line"></span><br><span class="line">		double nw &#x3D; 0;</span><br><span class="line">		int nv &#x3D; 0;</span><br><span class="line">		double tmp;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			tmp &#x3D; (nw  * nv + a[i] * v) &#x2F; (v + nv);</span><br><span class="line">			if (tmp &lt;&#x3D; w) &#123;</span><br><span class="line">				nw &#x3D; tmp;</span><br><span class="line">				nv +&#x3D; v;</span><br><span class="line">			&#125;</span><br><span class="line">			else break;</span><br><span class="line">		&#125;</span><br><span class="line">		if(nv&#x3D;&#x3D;0)</span><br><span class="line">			printf(&quot;0 0.00\n&quot;);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot;%d %.2lf\n&quot;, nv, nw&#x2F;100);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>我的实现全部使用整型避免了浮点数误差。关于<a href="https://www.cnblogs.com/crazyacking/p/4668471.html" target="_blank" rel="noopener">浮点数误差</a></li>
</ol>
<h2 id="To-Fill-or-Not-to-Fill"><a href="#To-Fill-or-Not-to-Fill" class="headerlink" title="To Fill or Not to Fill"></a>To Fill or Not to Fill</h2><p>With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go.</p>
<p>For each case, the first line contains 4 positive numbers: Cmax (&lt;= 100), the maximum capacity of the tank; D (&lt;=30000), the distance between Hangzhou and the destination city; Davg (&lt;=20), the average distance per unit gas that the car can run; and N (&lt;= 500), the total number of gas stations. Then N lines follow, each contains a pair of non-negative numbers: Pi, the unit gas price, and Di (&lt;=D), the distance between this station and Hangzhou, for i=1,…N. All the numbers in a line are separated by a space.</p>
<p>For each test case, print the cheapest price in a line, accurate up to 2 decimal places. It is assumed that the tank is empty at the beginning. If it is impossible to reach the destination, print “The maximum travel distance = X” where X is the maximum possible distance the car can run, accurate up to 2 decimal places.</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>在每一站处，查找能到达的站中油价比当前站便宜的站。如果没有，则找一个相对最便宜的。</p>
<ol>
<li>如果找到了比当前站便宜的，那么在本站只需要加油到刚好到达最便宜的站。</li>
<li>如果没有比当前更便宜的，那么把油箱加满，并直接开到这个相对最便宜的站。</li>
</ol>
</li>
<li><p>如果在当前的站处能够到达的最大范围内都没有站</p>
<ol>
<li>如果能到达终点，那么输出总价</li>
<li>否则计算出走的最大长度，加上当前站的位置即为最大移动距离</li>
</ol>
</li>
<li><p>这样保证了每次都是朝着油价最便宜的站进发，同时油箱里的油比沿路的站都便宜。</p>
</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 500 + 5;</span><br><span class="line">struct node &#123;</span><br><span class="line">	double price;</span><br><span class="line">	double dis;</span><br><span class="line">	bool operator &lt; (const node&amp;a) const &#123;</span><br><span class="line">		return dis &lt; a.dis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int ns &#x3D; 0;</span><br><span class="line"></span><br><span class="line">node a[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	double c, dis, cost;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%lf%lf%lf%d&quot;, &amp;c, &amp;dis, &amp;cost, &amp;n) &#x3D;&#x3D; 4)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			scanf(&quot;%lf%lf&quot;, &amp;a[i].price, &amp;a[i].dis);</span><br><span class="line">		&#x2F;&#x2F;a[n].price &#x3D; 0;</span><br><span class="line">		&#x2F;&#x2F;a[n].dis &#x3D; dis;</span><br><span class="line">		sort(a, a + n);</span><br><span class="line">		double maxd &#x3D; c * cost;</span><br><span class="line">		double nc &#x3D; 0;</span><br><span class="line">		double no &#x3D; 0;</span><br><span class="line">		int ns &#x3D; 0;</span><br><span class="line">		if (dis&#x3D;&#x3D; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;0.00\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		if (a[0].dis !&#x3D; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;The maximum travel distance &#x3D; 0.00\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		while (ns &lt; n) &#123;</span><br><span class="line">			&#x2F;&#x2F;printf(&quot;%d\n&quot;, ns);</span><br><span class="line">			double minc &#x3D; 100000;</span><br><span class="line">			int index;</span><br><span class="line">			bool havenx &#x3D; false;</span><br><span class="line">			bool cheaper &#x3D; false;</span><br><span class="line">			for (int i &#x3D; ns + 1; i &lt; n; i++) &#123;</span><br><span class="line">				if ((a[i].dis - a[ns].dis) &lt;&#x3D; maxd) &#123;&#x2F;&#x2F;有更便宜的</span><br><span class="line">					havenx &#x3D; true;</span><br><span class="line">					if (a[i].price &lt; a[ns].price) &#123;</span><br><span class="line">						cheaper &#x3D; true;</span><br><span class="line">						double d &#x3D; a[i].dis - a[ns].dis;</span><br><span class="line">						nc +&#x3D; a[ns].price*(d &#x2F; cost - no);</span><br><span class="line">						no &#x3D; 0;</span><br><span class="line">						ns &#x3D; i;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					else if (a[i].price &lt; minc) &#123;&#x2F;&#x2F;目前没有更便宜的，则记录一下相对最便宜的</span><br><span class="line">						minc &#x3D; a[i].price;</span><br><span class="line">						index &#x3D; i;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				else break;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (!cheaper &amp;&amp; (maxd &gt;&#x3D; (dis - a[ns].dis))) &#123;</span><br><span class="line">				</span><br><span class="line">				&#x2F;&#x2F;没有更便宜的，但是能直接走到终点，那么直接走</span><br><span class="line">				double d &#x3D; dis - a[ns].dis;</span><br><span class="line">				nc +&#x3D; (d &#x2F; cost - no)*a[ns].price;</span><br><span class="line">				printf(&quot;%.2lf\n&quot;, nc);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			if (!cheaper &amp;&amp; havenx) &#123;</span><br><span class="line">			</span><br><span class="line">				&#x2F;&#x2F;范围内有站，但是没有更便宜的</span><br><span class="line">				nc +&#x3D; (c - no)*a[ns].price;</span><br><span class="line">				double d &#x3D; a[index].dis - a[ns].dis;</span><br><span class="line">				no &#x3D; c - d &#x2F; cost;</span><br><span class="line">				ns &#x3D; index;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (!havenx) &#123;</span><br><span class="line">			</span><br><span class="line">				&#x2F;&#x2F;没有站也到不了终点</span><br><span class="line">				printf(&quot;The maximum travel distance &#x3D; %.2lf\n&quot;,</span><br><span class="line">					a[ns].dis + maxd);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>考研机试</title>
    <url>/2020/02/07/%E8%80%83%E7%A0%94%E6%9C%BA%E8%AF%95/</url>
    <content><![CDATA[<h1 id="基础相关"><a href="#基础相关" class="headerlink" title="基础相关"></a><a href="/2020/02/07/基础相关/">基础相关</a></h1><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><a href="/2020/02/07/数据结构/">数据结构</a></h1><h1 id="数学理论"><a href="#数学理论" class="headerlink" title="数学理论"></a><a href="/2020/02/10/数学理论/">数学理论</a></h1><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a><a href="/2020/02/11/图论/">图论</a></h1><h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a><a href="/2020/02/12/搜索/">搜索</a></h1><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a><a href="/2020/02/12/动态规划/">动态规划</a></h1><h1 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a><a href="/2020/02/13/其他技巧/">其他技巧</a></h1>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>与非门电路</title>
    <url>/2020/02/04/%E4%B8%8E%E9%9D%9E%E9%97%A8%E7%94%B5%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="UVA-1607-与非门电路"><a href="#UVA-1607-与非门电路" class="headerlink" title="UVA 1607 与非门电路"></a>UVA 1607 与非门电路</h1><p>可以用与非门（NAND）来设计逻辑电路，每个NAND门有两个输入端，输出为两个输入端与非运算的结果。也就是说 两个输入都是1是输出是0，其他输入输出都是1，给出一个由m（m&lt;=200000）个NAND组成的无环电路，电路的所有n个输入（n&lt;=100000）全部连接到一个相同的输入x,请把其中的一些输入设置为常数，用最少的x完成相同功能。输出任意方案即可。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>因为只有一个输入x，所以输出只有四种可能，0,1,x,x’</li>
<li>首先令输出全0和全1，比较二者结果，如果相等，那么说明输出与x无关 ，整个电路肯定是常数。</li>
<li>否则说明与x有关。不妨设x=0时输出0，x=1时输出1。假设现在把输入从00000改成10000，如果输出为1，那么可以得到一个解x0000，否则继续尝试11000，如果输出为1，则得到一个解1x000…直到输入全1时输出为1。</li>
<li>由于m很大，所以采用二分法，二分1的个数，再计算输出。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="output-计算0-k出入为0时的输出"><a href="#output-计算0-k出入为0时的输出" class="headerlink" title="output 计算0~k出入为0时的输出"></a>output 计算0~k出入为0时的输出</h2><ol>
<li>注 输入格式中，负数代表从门输入，正数代表从其他门的输出来输入。数字绝对值代表门或输入的编号。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int output(int k) &#123;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">		int a &#x3D; gate[i].a;</span><br><span class="line">		int b &#x3D; gate[i].b;</span><br><span class="line">		int va &#x3D; a&lt;0 ? -a&gt;k:gate[a].o; </span><br><span class="line">		int vb &#x3D; b&lt;0 ? -b&gt;k:gate[b].o;</span><br><span class="line"></span><br><span class="line">		gate[i].o &#x3D; !(va&amp;&amp;vb);</span><br><span class="line">	&#125;</span><br><span class="line">	return gate[m].o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sovle-二分查找过程"><a href="#sovle-二分查找过程" class="headerlink" title="sovle 二分查找过程"></a>sovle 二分查找过程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int solve(int vn) &#123;</span><br><span class="line">	int L &#x3D; 1, R &#x3D; n;</span><br><span class="line">	while (L&lt;R)</span><br><span class="line">	&#123;</span><br><span class="line">		int m &#x3D; L + (R - L) &#x2F; 2;</span><br><span class="line">		if (output(m) &#x3D;&#x3D; vn) R &#x3D; m;</span><br><span class="line">		else L &#x3D; m+1;</span><br><span class="line">	&#125;</span><br><span class="line">	return L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxm &#x3D; 200000 + 5;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line">struct Gates &#123;</span><br><span class="line">	int a, b, o;</span><br><span class="line">&#125; gate[maxm];</span><br><span class="line"></span><br><span class="line">inline int output(int k);</span><br><span class="line">inline int solve(int);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d  %d&quot;, &amp;n, &amp;m);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">			scanf(&quot;%d  %d&quot;, &amp;gate[i].a, &amp;gate[i].b);</span><br><span class="line">		int v0, vn;</span><br><span class="line">		v0 &#x3D; output(0);</span><br><span class="line">		vn &#x3D; output(n);</span><br><span class="line">		if (v0 &#x3D;&#x3D; vn) &#123;</span><br><span class="line">			for (int i &#x3D; 1; i &lt;&#x3D; n; i++) printf(&quot;0&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			int ix &#x3D; solve(vn);</span><br><span class="line">			for (int i &#x3D; 1; i &lt; ix; i++) printf(&quot;0&quot;);</span><br><span class="line">			printf(&quot;x&quot;);</span><br><span class="line">			for (int i &#x3D; ix + 1; i &lt;&#x3D; n; i++) printf(&quot;1&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>奇怪的气球膨胀</title>
    <url>/2020/02/04/%E5%A5%87%E6%80%AA%E7%9A%84%E6%B0%94%E7%90%83%E8%86%A8%E8%83%80/</url>
    <content><![CDATA[<h1 id="UVA-12627-奇怪的气球膨胀"><a href="#UVA-12627-奇怪的气球膨胀" class="headerlink" title="UVA 12627 奇怪的气球膨胀"></a>UVA 12627 奇怪的气球膨胀</h1><p>一开始有一个红气球。每小时后,一个红气球会变成3个红气球和一个蓝气球,而一个 蓝气球会变成4个蓝气球。如图，分别是经过0, 1, 2, 3小时后的情况。经过k小时后, 第A~B行一共有多少个红气球?</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><img src="/img_UVA%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/8.png" alt=""></p>
<ol>
<li><p>找规律加分治</p>
</li>
<li><p>观察两个图发现，第二章图的前两行是第一张图的平移</p>
</li>
<li><p>第二张图的后两行左半部分就是第一张图，右半部分全蓝</p>
</li>
<li><p>所以得出函数，第k张图的1~i行s(k,i)</p>
<ol>
<li>当k==0 时，s = 1;</li>
<li>当k&gt;0时<ol>
<li>当i&lt;=2<sup>k-1</sup>时，s = 2*s(k-1,i)</li>
<li>当i&gt;2<sup>k-1</sup>时，s = s(k-1,i-2<sup>k-1</sup>)+2*红色球总数(k-1)</li>
</ol>
</li>
</ol>
</li>
<li><p>最终答案为s(k,B)-s(k,A-1)</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">long long A, B, k;</span><br><span class="line"></span><br><span class="line">long long Allred(long long k) &#123; return pow(3, k); &#125;</span><br><span class="line">long long s(long long k, long long i) &#123;</span><br><span class="line">	if (i &lt;&#x3D; 0) return 0;</span><br><span class="line">	if (k &#x3D;&#x3D; 0) return 1;</span><br><span class="line">	if (i &lt;&#x3D; (1 &lt;&lt; k - 1)) return 2 * s(k - 1, i);</span><br><span class="line">	else return s(k - 1, i - (1 &lt;&lt; (k - 1))) + 2 * Allred(k - 1);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	int kase &#x3D; 0;</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Case %d: &quot;, ++kase);</span><br><span class="line">		scanf(&quot;%lld %lld %lld&quot;, &amp;k, &amp;A, &amp;B);</span><br><span class="line">		printf(&quot;%lld\n&quot;, s(k, B) - s(k, A - 1));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>平均值</title>
    <url>/2020/02/04/%E5%B9%B3%E5%9D%87%E5%80%BC/</url>
    <content><![CDATA[<h1 id="UVA-1451-平均值"><a href="#UVA-1451-平均值" class="headerlink" title="UVA 1451 平均值"></a>UVA 1451 平均值</h1><p>给定一个长度为 n 的 01 串，选一个长度至少为  的连续子串，使得子串中数字的平均值最大。如果有多解，子串长度应尽量小；如果仍有多解，起点编号尽量小。序列中的字符编号为 1 ~ n，因此 [1,n] 就是完整的字符串。1≤n≤100000</p>
<p>例如，对于如下长度为 171717 的序列00101011011011010，如果 L=7L=7L=7 ，最大平均值为 34\frac 3 443​ （子序列为 [7,14]其长度为 8）；如果 L=5，子序列 [7,11]的平均值最大，为 4/5​。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>观察目标函数的形式，非常类似sum函数的斜率，其中sum(i)为前i项和，并且相邻两项间都是x+1,y不变或加1。所以问题转化成了寻找两点间斜率的最大值。那么哪种情况斜率最大呢？假设给点一个点Pt，现在要求Pt’使得直线PtPt’斜率最大。</p>
</li>
<li><p>假设Pt的x坐标为x0。假设有三个候选点Pi,Pj,Pk 且i&lt;j&lt;k&lt;t</p>
<ol>
<li>若Pj为上凸点。因为t&gt;k，所以yt&gt;=yk，画图可知，忽略点点j不会丢掉最优点。因此，所有的上凸点都可以直接忽略</li>
<li>若Pj为下凹点。那么该点与当前的枚举的结尾点的连线即为可能的最优解。但问题是，新的点的加入可能使原来的点变成上凸点，这时就应该把上凸点删除。被删除的点总时原来的下凹点中最右边的若干连续点(因此可以用栈实现)</li>
</ol>
</li>
<li><p>因此，主过程就是枚举终点，计算可能的起始点。对于合法的起始点，更新答案。</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="compare-avg-比较平均值-使用通分做差后的分子避免除法误差"><a href="#compare-avg-比较平均值-使用通分做差后的分子避免除法误差" class="headerlink" title="compare_avg 比较平均值 使用通分做差后的分子避免除法误差"></a>compare_avg 比较平均值 使用通分做差后的分子避免除法误差</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int compare_avg(int x1, int x2, int x3, int x4) &#123;</span><br><span class="line">	return (sum[x2] - sum[x1-1])*(x4 - x3 + 1) - (sum[x4] - sum[x3-1])*(x2 - x1 + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="solve-枚举终点，计算可能的起始点，对于合法的起始点，更新答案"><a href="#solve-枚举终点，计算可能的起始点，对于合法的起始点，更新答案" class="headerlink" title="solve 枚举终点，计算可能的起始点，对于合法的起始点，更新答案"></a>solve 枚举终点，计算可能的起始点，对于合法的起始点，更新答案</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">	int ansL&#x3D;1, ansR &#x3D; L;</span><br><span class="line">	int i &#x3D; 0, j &#x3D; 0;</span><br><span class="line">	for (int t &#x3D; L; t &lt;&#x3D; n; t++) &#123;</span><br><span class="line">		&#x2F;&#x2F;p[i,j)为候选起始点</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;略过上凸点</span><br><span class="line">		while (j - i &gt; 1 &amp;&amp; compare_avg(p[j - 2], t - L, p[j - 1], t - L) &gt;&#x3D; 0) </span><br><span class="line">		&#x2F;&#x2F;当斜率下降过程中出现上升，则停止</span><br><span class="line">		j--; </span><br><span class="line"></span><br><span class="line">		p[j++] &#x3D; t - L + 1;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;找到第一个切点</span><br><span class="line">		while (j - i &gt; 1 &amp;&amp; compare_avg(p[i], t, p[i + 1], t) &lt;&#x3D; 0) i++;	</span><br><span class="line">		&#x2F;&#x2F;当斜率上升过程中出现下降，则停止</span><br><span class="line">	</span><br><span class="line">		int nans &#x3D; compare_avg(p[i], t, ansL, ansR);</span><br><span class="line">			if (nans &gt; 0 || (nans &#x3D;&#x3D; 0 &amp;&amp; t - p[i] &lt; ansR - ansL)) &#123;</span><br><span class="line">				ansL &#x3D; p[i];</span><br><span class="line">				ansR &#x3D; t;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d %d\n&quot;, ansL, ansR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100000 + 5;</span><br><span class="line">int sum[maxn];</span><br><span class="line">char s[maxn];</span><br><span class="line">int p[maxn];</span><br><span class="line">int n, L;</span><br><span class="line"></span><br><span class="line">int compare_avg(int x1, int x2, int x3, int x4);</span><br><span class="line">void solve();</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d\n&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d %d&quot;, &amp;n, &amp;L);</span><br><span class="line">		</span><br><span class="line">		scanf(&quot;%s&quot;, s + 1);</span><br><span class="line">		sum[0] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) sum[i] &#x3D; sum[i - 1] + s[i]-&#39;0&#39;;</span><br><span class="line">		solve();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>环形跑道</title>
    <url>/2020/02/04/%E7%8E%AF%E5%BD%A2%E8%B7%91%E9%81%93/</url>
    <content><![CDATA[<h1 id="UVA-11093-环形跑道"><a href="#UVA-11093-环形跑道" class="headerlink" title="UVA 11093 环形跑道"></a>UVA 11093 环形跑道</h1><p>环形跑道上有n(1 &lt;= n &lt;= 100000)个加油站，编号为1~n。第i个加油站可以加油pi加仑。从加油站i开到下 一站需要qi加仑汽油。你可以选择一个加油站作为起点，起始油箱为空（但可以立即加油）。你的任务是选 择一个起点，使得可以走完一圈后回到起点。假定油箱中的油量没有上限。如果无解，输出Not possible，否则 输出可以作为起点的最小加油站编号。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>贪心法：从小编号加油站开始尝试，如果能转一圈，那么直接输出。否则，以油量不够的加油站的下一站为起点再进行尝试。</li>
<li>假设尝试从1号加油站开始走，到i号加油站加完油也到不了i+1号加油站。那么从2~i-1号加油站开始也肯定不能到，这是因为从1到2时，油箱中的油量c&gt;=0</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100000 + 5;</span><br><span class="line">int p[maxn], q[maxn];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">void solve();</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	int kase &#x3D; 0;</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Case %d: &quot;, ++kase);</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;p[i]);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;q[i]);</span><br><span class="line">		solve();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="solve-贪心过程"><a href="#solve-贪心过程" class="headerlink" title="solve 贪心过程"></a>solve 贪心过程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line"></span><br><span class="line">	int beg &#x3D; 0;&#x2F;&#x2F;beg为起点编号</span><br><span class="line"></span><br><span class="line">	int used[maxn]&#123;&#125;;</span><br><span class="line">	bool flag;</span><br><span class="line"></span><br><span class="line">	do</span><br><span class="line">	&#123;&#x2F;&#x2F;如果试图使用已经尝试过的起点，说明尝试了一圈了</span><br><span class="line"></span><br><span class="line">		while (beg &lt; n&amp;&amp;p[beg] &lt; q[beg]) &#123;&#x2F;&#x2F;掠过若干不可能的起点并标记</span><br><span class="line">			used[beg] &#x3D; 1;</span><br><span class="line">			beg++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		if (beg &gt;&#x3D; n) break;</span><br><span class="line">		int next &#x3D; beg;&#x2F;&#x2F;到下一站耗油量q[next]</span><br><span class="line">		used[beg] &#x3D; 1;</span><br><span class="line"></span><br><span class="line">		int c &#x3D; 0;</span><br><span class="line">		flag &#x3D; true;</span><br><span class="line">		int cnt &#x3D; 0;</span><br><span class="line">		do &#123;</span><br><span class="line">			c +&#x3D; p[next];	&#x2F;&#x2F;加油</span><br><span class="line">			if (c &lt; q[next]) &#123;&#x2F;&#x2F;开不到下一站</span><br><span class="line">				next++;</span><br><span class="line">				flag &#x3D; false;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			else c -&#x3D; q[next];</span><br><span class="line">			next &#x3D; (next + 1) % n;</span><br><span class="line">		&#125; while (next !&#x3D; beg);&#x2F;&#x2F;转一圈结束</span><br><span class="line"></span><br><span class="line">		if (!flag) &#123;</span><br><span class="line">			beg &#x3D; next;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">			break;</span><br><span class="line">	&#125; while (!used[beg]);</span><br><span class="line"></span><br><span class="line">	if (!flag)</span><br><span class="line">		printf(&quot;Not possible\n&quot;);</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;Possible from station %d\n&quot;, beg + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>防线</title>
    <url>/2020/02/04/%E9%98%B2%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="UVA-1471-防线"><a href="#UVA-1471-防线" class="headerlink" title="UVA 1471 防线"></a>UVA 1471 防线</h1><p>给一个长度为 n(n≤200000)的序列，你的任务是删除一个连续子序列，使得剩下的序列中有一个长度最大的连续递增子序列。例如，将序列{5,3,4,9,2,8,6,7,1}中的{9,2,8}删除，得到的序列{5,3,4,6,7,1}中包含一个长度为4的连续递增子序列{3,4,6,7}。序列中每个数均为不超过 10^9的正整数。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>最直观的，枚举i和j，对于所有满足A[j]&lt;A[i]的分别向左右扩展，统计有序序列能扩展多长，复杂度O(n<sup>3</sup>)</li>
<li>可以预先计算出以第i个元素为起点的最长序列长f(i)以及以第i个元素为终点的最长序列长g(i)。然后枚举i,j，对于满足A[j]&lt;A[i]的ij，答案为g[j]+f[i]。复杂度O(n<sup>2</sup>)，可惜仍然超时了…</li>
<li>枚举i是必须的。但是随着i的向后移动，不是所有的j都是有用的了。所以可以首先排除一些肯定不是最优值的j。例如，若有j’满足A[j’]&lt;=A[j]且g(j’)&gt;g(j)，则j不是最优的，因为j’不仅是一个更长的序列的末尾，而且它还更容易插入。因此，操作涉及动态维护一个有序表，涉及大量插入删除，所以不能用排序加二分查找，而选择使用set。</li>
<li>具体实现时，应该首先找到这个元素的插入位置，根据插入位置前一个元素判断是否需要保留。如果需要保留，还要将插入位置后面的不可能成为最优解的元素删除掉。插入删除查询都是set的操作，复杂度都为O(logn)，总的时间复杂度为O(nlogn)。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="get-fg-填充f-g数组"><a href="#get-fg-填充f-g数组" class="headerlink" title="get_fg 填充f g数组"></a>get_fg 填充f g数组</h2><h3 id="迭代写法-更快-440ms"><a href="#迭代写法-更快-440ms" class="headerlink" title="迭代写法(更快) 440ms"></a>迭代写法(更快) 440ms</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void get_fg() &#123;</span><br><span class="line">	g[0] &#x3D; 1;</span><br><span class="line">	for (int i &#x3D; 1; i &lt; n; i++)</span><br><span class="line">		if (in[i - 1] &lt; in[i]) g[i] &#x3D; g[i - 1] + 1;</span><br><span class="line">		else g[i] &#x3D; 1;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; f[i] is the length of longest increasing continuous subsequence starting from i</span><br><span class="line">	f[n - 1] &#x3D; 1;</span><br><span class="line">	for (int i &#x3D; n - 2; i &gt;&#x3D; 0; i--)</span><br><span class="line">		if (in[i] &lt; in[i + 1]) f[i] &#x3D; f[i + 1] + 1;</span><br><span class="line">		else f[i] &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="直接写的-460ms"><a href="#直接写的-460ms" class="headerlink" title="直接写的 460ms"></a>直接写的 460ms</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void get_fg() &#123;</span><br><span class="line">memset(f, 0, sizeof(f));</span><br><span class="line">memset(g, 0, sizeof(g));</span><br><span class="line">int beg &#x3D; 0;</span><br><span class="line">for (int last &#x3D; 1; last &lt; n; last++) &#123;</span><br><span class="line">	g[last - 1] &#x3D; last - beg;</span><br><span class="line">	if (in[last] &lt;&#x3D; in[last - 1]) &#123;</span><br><span class="line">		for (; beg &lt; last; beg++)</span><br><span class="line">			f[beg] &#x3D; last - beg;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!g[n - 1]) g[n - 1] &#x3D; n - beg;</span><br><span class="line">for (; beg &lt; n; beg++)</span><br><span class="line">	f[beg] &#x3D; n - beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="solve-枚举i动态修改有序表计算j"><a href="#solve-枚举i动态修改有序表计算j" class="headerlink" title="solve 枚举i动态修改有序表计算j"></a>solve 枚举i动态修改有序表计算j</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int solve() &#123;</span><br><span class="line">	get_fg();</span><br><span class="line">	int ans &#x3D; 1;</span><br><span class="line">	s.clear();</span><br><span class="line">	s.insert(node(in[0], g[0]));</span><br><span class="line">	for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">		node c (in[i], g[i]);</span><br><span class="line">		set&lt;node&gt; ::iterator it &#x3D; s.lower_bound(c);</span><br><span class="line">		bool keep &#x3D; true;</span><br><span class="line">		if (it !&#x3D; s.begin()) &#123;</span><br><span class="line">			node last &#x3D; *(--it);</span><br><span class="line">			int len &#x3D; f[i] + last.v;</span><br><span class="line">			ans &#x3D; max(ans, len);</span><br><span class="line">			if (c.v &lt;&#x3D; last.v) keep &#x3D; false;</span><br><span class="line">		&#125;</span><br><span class="line">		if (keep) &#123;</span><br><span class="line">			s.erase(c);</span><br><span class="line">			s.insert(c);</span><br><span class="line">			it &#x3D; s.find(c);</span><br><span class="line">			it++;</span><br><span class="line">			while (it !&#x3D; s.end() &amp;&amp; it-&gt;num &gt; c.num&amp;&amp;it-&gt;v &lt;&#x3D; c.v)</span><br><span class="line">				s.erase(it++);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 200005;</span><br><span class="line">int in[maxn];</span><br><span class="line">int g[maxn], f[maxn];&#x2F;&#x2F;g(i)表示以第i个元素结尾的最长序列长度，f(i)表示以第i个元素开始最长序列长度</span><br><span class="line">struct node &#123;</span><br><span class="line">	int v, num;</span><br><span class="line">	node(int num, int v) :num(num), v(v) &#123;&#125;</span><br><span class="line">	bool operator &lt; (const node&amp;a) const &#123; return num &lt; a.num; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int n;</span><br><span class="line">set&lt;node&gt; s;</span><br><span class="line"></span><br><span class="line">inline void get_fg();</span><br><span class="line">inline int solve();</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;in[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		if (n &#x3D;&#x3D; 1) &#123; printf(&quot;1\n&quot;); continue; &#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, solve());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>抄书</title>
    <url>/2020/02/04/%E6%8A%84%E4%B9%A6/</url>
    <content><![CDATA[<h1 id="UVA-714-抄书"><a href="#UVA-714-抄书" class="headerlink" title="UVA 714 抄书"></a>UVA 714 抄书</h1><p>把一个包含m个正整数的划分成k个(1&lt;=k&lt;=m&lt;=500)非空的连续子序列，使得每个正整数恰好属于一个序列。设第i个序列的各数之和为S(i)，你的任务是让max{S(i)}最小，输出依次个数字最小的情况。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>本题的优化目标是使最大值尽量小。设P(x)表示将输入序列分成m个连续的子序列，使得所有S(i)不超过x。则本题的目标使求得使P(x)为真的最小的x</li>
<li>现在考虑x可能取值，x至少是序列中的最大元素，最大是所有序列和，那么我们可以猜一个x，然后判断是否所有的子序列和都小于这个值。沿着这个思路想到用二分法，此题得解。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="below-判断是否所有子序列的和都小于p"><a href="#below-判断是否所有子序列的和都小于p" class="headerlink" title="below 判断是否所有子序列的和都小于p"></a>below 判断是否所有子序列的和都小于p</h2><ol>
<li>每次尽量往右划分即可。第j个元素在合法情况下，放在第i个序列和第i+1个序列的区别会导致隔板数不同。但是此时我只需要知道最小的序列和，之后再贪心的输出即可。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool below(long long p) &#123;</span><br><span class="line">	int d &#x3D; 0;</span><br><span class="line">	int beg &#x3D; 1;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">		if (sum[i] - sum[beg - 1] &gt; p) &#123;</span><br><span class="line">			d++;</span><br><span class="line">			beg &#x3D; i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (a[n] &gt; p) d++;</span><br><span class="line">	&#x2F;&#x2F;printf(&quot;%d\n&quot;, p);</span><br><span class="line">	if (d &lt;&#x3D; k - 1)</span><br><span class="line">		return true;</span><br><span class="line"></span><br><span class="line">	else  return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="solve-进行二分查找，并贪心输出结果"><a href="#solve-进行二分查找，并贪心输出结果" class="headerlink" title="solve 进行二分查找，并贪心输出结果"></a>solve 进行二分查找，并贪心输出结果</h2><ol>
<li>主要是贪心过程，因为题干要求当最大值一样小的时候，要求输出S(i)较小的。所以贪心策略是从尾部开始插入隔板，这样保证头部尽量少留元素。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">	bool cir;</span><br><span class="line">	memset(print, 0, sizeof(print));</span><br><span class="line">	while (mins &lt; maxs)</span><br><span class="line">	&#123;</span><br><span class="line">		int p &#x3D; (mins + maxs) &#x2F; 2;</span><br><span class="line">		cir &#x3D; below(p);</span><br><span class="line">		if (cir) maxs &#x3D; p;</span><br><span class="line">		else mins &#x3D; p + 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ans &#x3D; mins;</span><br><span class="line">	&#x2F;&#x2F;printf(&quot;ans &#x3D; %d\n&quot;, ans);</span><br><span class="line">	int s &#x3D; 0;</span><br><span class="line">	int need &#x3D; k;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; n; i &gt;&#x3D; 1; i--) &#123;</span><br><span class="line">		if (s + a[i] &gt; ans || i &lt; need) &#123;&#x2F;&#x2F;注意此处剩余插入位置i不能少于待插入隔板数</span><br><span class="line">			print[i] &#x3D; 1;</span><br><span class="line">			need--;</span><br><span class="line">			s &#x3D; a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		else s +&#x3D; a[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">		printf(&quot;%d &quot;, a[i]);</span><br><span class="line">		if (print[i]) printf(&quot;&#x2F; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;, a[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 500 + 5;</span><br><span class="line">int n, k;</span><br><span class="line">long long a[maxn];</span><br><span class="line">long long sum[maxn];</span><br><span class="line">int print[maxn];</span><br><span class="line">long long ans;</span><br><span class="line">long long maxs, mins;</span><br><span class="line"></span><br><span class="line">bool below(long long p);</span><br><span class="line">void solve();</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d %d&quot;, &amp;n, &amp;k);</span><br><span class="line">		mins &#x3D; -1;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%lld&quot;, &amp;a[i]);</span><br><span class="line">			mins &#x3D; max(mins, a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		sum[0] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			sum[i] &#x3D; sum[i - 1] + a[i];</span><br><span class="line">		maxs &#x3D; sum[n];</span><br><span class="line">		solve();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>不无聊的序列</title>
    <url>/2020/02/04/%E4%B8%8D%E6%97%A0%E8%81%8A%E7%9A%84%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="UVA-1608-不无聊的序列"><a href="#UVA-1608-不无聊的序列" class="headerlink" title="UVA 1608 不无聊的序列"></a>UVA 1608 不无聊的序列</h1><p>如果一个序列的任意连续子序列都至少有一个元素唯一，则称这个序列“不无聊”，否则称这个序列“无聊”。给定T个序列，求是否“无聊”。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>分治加中途相遇</li>
<li>如果在序列中A[i]只出现了一次，那么只需检查A[1…P-1]和A[p+1…n]是否满足条件。这是因为所有包含A[p]的子序列都是符合条件的，不需要检查。</li>
<li>想要直到每个元素值是否在区间内不重，可以记录这个值临近的两个值的出现位置，并与区间端点比较。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="main-填充pre和next数组"><a href="#main-填充pre和next数组" class="headerlink" title="main 填充pre和next数组"></a>main 填充pre和next数组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 200000 + 5;</span><br><span class="line">int n;</span><br><span class="line">int a[maxn];</span><br><span class="line">int pre[maxn], nex[maxn];</span><br><span class="line">map&lt;int, int&gt; last;</span><br><span class="line">inline bool unique(int L, int r, int v);</span><br><span class="line">bool bsearch(int l, int r);</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	int x;</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		last.clear();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">			a[i] &#x3D; x;</span><br><span class="line">			if (!last.count(x))</span><br><span class="line">				pre[i] &#x3D; -1;</span><br><span class="line">			else</span><br><span class="line">				pre[i] &#x3D; last[x];</span><br><span class="line">			last[x] &#x3D; i;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		last.clear();</span><br><span class="line">		for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			if (!last.count(a[i]))</span><br><span class="line">				nex[i] &#x3D; n;</span><br><span class="line">			else nex[i] &#x3D; last[a[i]];</span><br><span class="line">			last[a[i]] &#x3D; i;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (bsearch(0, n - 1)) printf(&quot;non-boring\n&quot;);</span><br><span class="line">		else printf(&quot;boring\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="solve-中途相遇过程，注意循环和递归条件"><a href="#solve-中途相遇过程，注意循环和递归条件" class="headerlink" title="solve 中途相遇过程，注意循环和递归条件"></a>solve 中途相遇过程，注意循环和递归条件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool bsearch(int l, int r) &#123;</span><br><span class="line">	if (l &gt;&#x3D; r)  return true;</span><br><span class="line">	for (int d &#x3D; 0; l + d &lt;&#x3D; r - d; d++) &#123;</span><br><span class="line">		if (unique(l, r, l + d))</span><br><span class="line">			return bsearch(l, l + d - 1) &amp;&amp; bsearch(l + d + 1, r);</span><br><span class="line"></span><br><span class="line">		if (l + d &#x3D;&#x3D; r - d) break;</span><br><span class="line"></span><br><span class="line">		if (unique(l, r, r - d))</span><br><span class="line">			return bsearch(l, r - d - 1) &amp;&amp; bsearch(r - d + 1, r);</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="unique-判断区间内是否有重复"><a href="#unique-判断区间内是否有重复" class="headerlink" title="unique 判断区间内是否有重复"></a>unique 判断区间内是否有重复</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool unique(int L, int R, int v) &#123;</span><br><span class="line">	return L &gt; pre[v] &amp;&amp; R &lt; nex[v];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>不公平竞赛</title>
    <url>/2020/02/04/%E4%B8%8D%E5%85%AC%E5%B9%B3%E7%AB%9E%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="UVA-1609-不公平竞赛"><a href="#UVA-1609-不公平竞赛" class="headerlink" title="UVA 1609 不公平竞赛"></a>UVA 1609 不公平竞赛</h1><p>n支队伍(2≤n≤1024,且n是2的整数幂)打淘汰赛，每轮都是两两配对，胜者进入下一轮，如PDF中的图所示。</p>
<p>每支队伍的实力固定，并且已知每两支队伍之间的一场比赛结果（“实力固定”是指：例如，队伍1曾经胜过队伍2，则二者在今后的交锋中队伍1总获胜）。你喜欢1号队。虽然它不一定是最强的，但是它可以直接打败其他队伍中至少一半，并且对于每支1号队不能直接打败的队伍t，总是存在一支1号队能直接打败的队伍t’使得t’能直接打败t。问是否存在一种比赛安排，使得1号队夺冠？</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>要想让1队获胜，就要让所有1打不过的t与1能打过的t’先进行比赛(t’能打过t)。每一轮比赛的过程安排分一下三步（其中黑队表示1打不过的队伍，灰队表示1能打过的队伍，灰队中不都能打过黑队）</li>
<li>首先，尽量给所有的黑队匹配灰队，要求匹配的灰队能打赢黑队。打赢的灰队直接进入下一轮待用；没有匹配的黑队留在final中，看看有没有剩下的黑队能内斗一下</li>
<li>之后，给1队分配一个灰队。并将剩余的没用到的灰队放入final中待用</li>
<li>最后final中队伍任意配对即可。因为final中的黑队全都强于灰队，而胜出的黑队到底是哪一个并不重要。</li>
<li>这样做是对的，这是因为<ol>
<li>起初1队能战胜一半的队伍，当循环一轮之后，总队伍数减少一半，黑队数也至少减少一半(自相残杀阶段),所以条件仍满足。</li>
<li>步骤1中灰色队伍联合起来可以打败所有黑色队伍，而这些灰队全部晋级，所以这样做一定有解</li>
</ol>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="main-统计初始灰队和黑队，注意不要把1队算进去"><a href="#main-统计初始灰队和黑队，注意不要把1队算进去" class="headerlink" title="main 统计初始灰队和黑队，注意不要把1队算进去"></a>main 统计初始灰队和黑队，注意不要把1队算进去</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1024 + 5;</span><br><span class="line">char team[maxn][maxn];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; black;</span><br><span class="line">vector&lt;int&gt; gray;</span><br><span class="line"></span><br><span class="line">void solve();</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%s&quot;, team[i]+1);</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 2; i &lt;&#x3D; n; i++)</span><br><span class="line">			if (team[1][i] &#x3D;&#x3D; &#39;0&#39;)</span><br><span class="line">				black.push_back(i);</span><br><span class="line">			else gray.push_back(i);</span><br><span class="line"></span><br><span class="line">		solve();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="solve-执行三个阶段"><a href="#solve-执行三个阶段" class="headerlink" title="solve 执行三个阶段"></a>solve 执行三个阶段</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line"></span><br><span class="line">	while (n &gt; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		vector&lt;int&gt; tgray;</span><br><span class="line">		vector&lt;int&gt; tblack;</span><br><span class="line">		vector&lt;int&gt; final;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;U1</span><br><span class="line">		for (int i &#x3D; 0; i &lt; black.size(); i++) &#123;</span><br><span class="line">			int nb &#x3D; black[i];</span><br><span class="line">			int graywin &#x3D; false;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; gray.size(); j++) &#123;</span><br><span class="line">				int &amp;ng &#x3D; gray[j];</span><br><span class="line">				if (ng &gt; 0 &amp;&amp; team[ng][nb] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">					printf(&quot;%d %d\n&quot;, ng, nb);</span><br><span class="line">					tgray.push_back(ng);</span><br><span class="line">					ng &#x3D; 0;</span><br><span class="line">					graywin &#x3D; true;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (!graywin) final.push_back(nb);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;U2</span><br><span class="line">		bool first &#x3D; true;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; gray.size(); i++) &#123;</span><br><span class="line">			int ng &#x3D; gray[i];</span><br><span class="line">			if (ng &gt; 0) &#123;</span><br><span class="line">				if (first) &#123;</span><br><span class="line">					printf(&quot;1 %d\n&quot;, ng);</span><br><span class="line">					first &#x3D; false;</span><br><span class="line">				&#125;</span><br><span class="line">				else final.push_back(ng);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;U3</span><br><span class="line">		for (int i &#x3D; 0; i &lt; (int)final.size(); i +&#x3D; 2) &#123;</span><br><span class="line">			printf(&quot;%d %d\n&quot;, final[i], final[i + 1]);</span><br><span class="line">			int keep &#x3D; final[i];</span><br><span class="line">			if (team[final[i + 1]][keep] &#x3D;&#x3D; &#39;1&#39;)</span><br><span class="line">				keep &#x3D; final[i + 1];</span><br><span class="line">			if (team[1][keep] &#x3D;&#x3D; &#39;1&#39;)</span><br><span class="line">				tgray.push_back(keep);</span><br><span class="line">			else tblack.push_back(keep);</span><br><span class="line">		&#125;</span><br><span class="line">		black &#x3D; tblack;</span><br><span class="line">		gray &#x3D; tgray;</span><br><span class="line">		n &gt;&gt;&#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>Shuffle的播放记录</title>
    <url>/2020/02/04/Shuffle%E7%9A%84%E6%92%AD%E6%94%BE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="UVA-12174-Shuffle的播放记录"><a href="#UVA-12174-Shuffle的播放记录" class="headerlink" title="UVA 12174 Shuffle的播放记录"></a>UVA 12174 Shuffle的播放记录</h1><p>音乐播放器有一个所谓乱序播放功能，假设一共有s首歌，一开始会给这些歌随机排序，全部播放完毕后再随机排序，继续播放，以此类推。注：当s首歌播完前不会重新排序，所以播放记录里每s首歌都是1~s的排列.给出一个长度为n（1&lt;=s,n&lt;=100000) 的播放记录（不一定从最开始记录）xi（1&lt;=xi&lt;=s).统计下一次随机排序所发生的时间有多少种可能性。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>统计可能性，就是统计当前序列有多少种分法。</li>
<li>连续s个数是一段，想到滑动窗口问题，并且这个题的窗口大小相对固定。需要做的是找到所有可能的段的起始点，再验证哪些能作为整体的划分的开头。</li>
<li>段的起始点，有三种情况<ol>
<li>位于播放列表开头的不完整段。这时判断条件是开头i个元素都是不重复的</li>
<li>完整的段。要求窗口内没有重复的数字</li>
<li>位于结尾的不完整的段。与开头的类似，只是判断条件为n+s-i个元素都是不重复的。等价于后面i个元素都是不重复的。</li>
</ol>
</li>
<li>本题还要注意一些边界条件和数组大小</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h2><ol>
<li>先找到段的起始点，用ok[i]表示，再依次判断每个段起始点能否成为整个划分的开头</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">	int tot &#x3D; 0;&#x2F;&#x2F;记录不重复数字总数</span><br><span class="line">	fill(cnt + 1, cnt + s + 1, 0); &#x2F;&#x2F;cnt[i]表示值i出现的次数</span><br><span class="line">	fill(ok, ok + n + s + 1, 0);   &#x2F;&#x2F;ok[i]&#x3D;&#x3D;1表示第i个窗口内没有重复元素</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n+s+1; i++) &#123;</span><br><span class="line">		if (tot &#x3D;&#x3D; s) ok[i] &#x3D; 1;</span><br><span class="line">		if (i &lt; s&amp;&amp;tot &#x3D;&#x3D; i) </span><br><span class="line">			ok[i] &#x3D; 1;</span><br><span class="line">		if (i &gt; n&amp;&amp;tot &#x3D;&#x3D; n+s-i) </span><br><span class="line">			ok[i] &#x3D; 1;&#x2F;&#x2F;n+s-i 从后往前数的第i个</span><br><span class="line"></span><br><span class="line">		if (i &#x3D;&#x3D; n + s) break;;</span><br><span class="line">		if (a[i] !&#x3D; -1 &amp;&amp; --cnt[a[i]] &#x3D;&#x3D; 0) tot--;</span><br><span class="line">		if (a[i + s] !&#x3D; -1 &amp;&amp; cnt[a[i+s]]++ &#x3D;&#x3D; 0) tot++;&#x2F;&#x2F;窗口滑动一格</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;验证每个起始点</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; s; i++) &#123;</span><br><span class="line">		int valid &#x3D; 1;</span><br><span class="line">		for (int j &#x3D; i; j &lt; n + s + 1; j +&#x3D; s)</span><br><span class="line">			if (!ok[j]) valid &#x3D; 0;;</span><br><span class="line">		if (valid) ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	if (ans &#x3D;&#x3D; n + 1) ans &#x3D; s; &#x2F;&#x2F; special case</span><br><span class="line">	printf(&quot;%d\n&quot;, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100000 + 5;</span><br><span class="line"></span><br><span class="line">int s, n;</span><br><span class="line">int a[maxn*3+1];&#x2F;&#x2F;前后各空出s的空间，防止溢出</span><br><span class="line">int cnt[maxn];&#x2F;&#x2F;记录每个数字的出现次数</span><br><span class="line">int ok[maxn*3+1];&#x2F;&#x2F;ok[i]&#x3D;&#x3D;1表示第i个滑动窗口中没有重复数字</span><br><span class="line"></span><br><span class="line">void solve();</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d %d&quot;, &amp;s, &amp;n);</span><br><span class="line">		fill(a, a + n + 2 * s, -1);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i+s]);</span><br><span class="line">		solve();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>Gergovia的酒交易</title>
    <url>/2020/01/29/Gergovia%E7%9A%84%E9%85%92%E4%BA%A4%E6%98%93/</url>
    <content><![CDATA[<h1 id="UVA-11054-Gergovia的酒交易"><a href="#UVA-11054-Gergovia的酒交易" class="headerlink" title="UVA 11054 Gergovia的酒交易"></a>UVA 11054 Gergovia的酒交易</h1><p>n个等距村庄,每个村庄要么买酒要么卖酒,把k个单位的酒运到相邻村庄去需要k*酒的需求的劳动力,问最少需要多少劳动力才能满足所有的村庄的要求。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>等价转换，考虑最左侧的村庄<ol>
<li>假设a1&gt;0,则需要从其他的村庄向1运a1单位的酒，等价于只有村庄2-n，且第二个村庄的需求量为a1+a2。</li>
<li>再举个例子，如果a1&lt;0,a2&gt;0，由于供需平衡，a1的酒需要全部运出，耗费劳动力|a1|，剩余的酒从a2运走需要||a1|-a2| = a1+a2</li>
</ol>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">		long long ans &#x3D; 0, left &#x3D; 0, a;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%lld&quot;, &amp;a);</span><br><span class="line">			ans +&#x3D; abs(left);</span><br><span class="line">			left +&#x3D; a;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>传说中的车</title>
    <url>/2020/01/29/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E8%BD%A6/</url>
    <content><![CDATA[<h1 id="UVA-11134-传说中的车"><a href="#UVA-11134-传说中的车" class="headerlink" title="UVA 11134 传说中的车"></a>UVA 11134 传说中的车</h1><p>在一个n*n的棋盘上有n个车，并且每辆车有一个矩形的出现范围。要求安排这n辆车，使得任意两辆车不在同行或同列。如果无解输出IMPOSSIBLE，否则输出n行，为每个车的坐标。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>本题中行列是无关的，所以可以拆分成两个一维问题，使用贪心法</li>
<li>为每个列单独选择一个车来填充。对于合法的车，贪心策略是使得该车的右边界尽量小。</li>
<li>这个车没有使用过，并且它的左边界不在当前要填充的列右侧。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="solve-贪心过程"><a href="#solve-贪心过程" class="headerlink" title="solve 贪心过程"></a>solve 贪心过程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool solve(const int *a, const int *b, int *c) &#123;&#x2F;&#x2F;解决第col列放哪个的问题。选择有边界最小的车记为rook</span><br><span class="line">for(int col &#x3D; 1; col &lt;&#x3D; n; col++) &#123;</span><br><span class="line">   </span><br><span class="line">   int rook &#x3D; -1, minb &#x3D; n+1;</span><br><span class="line"></span><br><span class="line">   for(int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">     if(!c[i]&amp;&amp; b[i] &lt; minb &amp;&amp; col &gt;&#x3D; a[i]) &#123; rook &#x3D; i; minb &#x3D; b[i]; &#125;</span><br><span class="line">   if(rook &lt; 0 || col &gt; minb) return false;</span><br><span class="line">   c[rook] &#x3D; col;</span><br><span class="line">&#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 5000 + 5;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">bool solve(const int *a, const int *b, int *c);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int x1[maxn], x2[maxn], y1[maxn], y2[maxn];</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)</span><br><span class="line">&#123;</span><br><span class="line">	int  x[maxn]&#123;&#125;, y[maxn]&#123;&#125;;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">		scanf(&quot;%d %d %d %d&quot;, &amp;x1[i], &amp;y1[i], &amp;x2[i], &amp;y2[i]);</span><br><span class="line">	if (solve(x1, x2, x) &amp;&amp; solve(y1, y2, y)) &#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			printf(&quot;%d %d\n&quot;, x[i], y[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	else printf(&quot;IMPOSSIBLE\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>两亲性分子</title>
    <url>/2020/01/29/%E4%B8%A4%E4%BA%B2%E6%80%A7%E5%88%86%E5%AD%90/</url>
    <content><![CDATA[<h1 id="UVA-1606-两亲性分子"><a href="#UVA-1606-两亲性分子" class="headerlink" title="UVA 1606 两亲性分子"></a>UVA 1606 两亲性分子</h1><p>平面上有n(n≤1000)n(n&lt;=1000)个点，每个点为白点或者黑点。</p>
<p>现在需要放置一条隔板，使得隔板一侧的白点数加上另一侧的黑点数总数最大。隔板上的点可以看作任意一侧。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>基础：令隔板经过至少两个点(否则可以移动隔板使其经过两个点而总数不变</li>
<li>最直接的，枚举两个点，再计算总数，O(n<sup>3</sup>)</li>
<li>改进：先枚举一个基准点，然后以这个点为轴，旋转直线，这样就可可以动态修改两侧的点数。</li>
<li>技巧：<ol>
<li>将黑点以当前的基准点为对称中心，将它对称过去，这样只用统计直线一端的点数就是答案</li>
<li>利用叉积判断两个向量是否反向(即旋转了180°)</li>
</ol>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="solve-枚举基准点，并统计每个基准点对应的总数"><a href="#solve-枚举基准点，并统计每个基准点对应的总数" class="headerlink" title="solve 枚举基准点，并统计每个基准点对应的总数"></a>solve 枚举基准点，并统计每个基准点对应的总数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int solve() &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">	scanf(&quot;%d %d %d&quot;, &amp;in[i].x, &amp;in[i].y, &amp;flag[i]);</span><br><span class="line"></span><br><span class="line">if (n &lt;&#x3D; 2) return 2;</span><br><span class="line">node p[maxn];</span><br><span class="line">int ans &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">	int k &#x3D; 0;</span><br><span class="line">	for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">		if (j &#x3D;&#x3D; i) continue;</span><br><span class="line">		p[k].x &#x3D; in[j].x - in[i].x;</span><br><span class="line">		p[k].y &#x3D; in[j].y - in[i].y;</span><br><span class="line">		if (flag[j]) p[k].x *&#x3D; -1, p[k].y *&#x3D; -1;</span><br><span class="line">		p[k].rad &#x3D; atan2(p[k].y, p[k].x);</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(p, p + k);</span><br><span class="line">	int L &#x3D; 0, R &#x3D; 0, cnt &#x3D; 2;</span><br><span class="line">	while (L &lt; k)</span><br><span class="line">	&#123;</span><br><span class="line">		if (R &#x3D;&#x3D; L) &#123;</span><br><span class="line">			R &#x3D; (R + 1) % k;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		while (R !&#x3D; L &amp;&amp; left(p[L], p[R]))</span><br><span class="line">		&#123;</span><br><span class="line">			R &#x3D; (R + 1) % k;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		cnt--;</span><br><span class="line">		L++;</span><br><span class="line">		ans &#x3D; max(ans, cnt);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="left-判断两个向量是否反向"><a href="#left-判断两个向量是否反向" class="headerlink" title="left 判断两个向量是否反向"></a>left 判断两个向量是否反向</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool left(node a, node b) &#123;</span><br><span class="line">return a.x*b.y - a.y*b.x &gt;&#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1005;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int x, y;</span><br><span class="line">	double rad;</span><br><span class="line">	bool operator &lt; (const node &amp;a) const &#123; return rad &lt; a.rad; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node in[maxn];</span><br><span class="line">int n;</span><br><span class="line">bool flag[maxn];</span><br><span class="line"></span><br><span class="line">bool left(node a, node b);</span><br><span class="line">int solve();</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n) &#123;</span><br><span class="line">		printf(&quot;%d\n&quot;, solve());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>唯一的雪花</title>
    <url>/2020/01/29/%E5%94%AF%E4%B8%80%E7%9A%84%E9%9B%AA%E8%8A%B1/</url>
    <content><![CDATA[<h1 id="UVA-11572-唯一的雪花"><a href="#UVA-11572-唯一的雪花" class="headerlink" title="UVA 11572 唯一的雪花"></a>UVA 11572 唯一的雪花</h1><p>求最长连续无重复子序列。输入：第一行给出样例数，对于每组数据，第一行给出序列长度n，之后n行给出每个元素的值。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>滑动窗口：优先向右扩展，如果A[R+1]已存在，那么增大L。这是因为L-R是解的情况下，增大L也必然是解，所以R不必动。</li>
<li>判断是否出现过，可以使用set(240ms),map(270ms),数组(1140ms)<ol>
<li>set的查询，插入，删除的复杂度都是O(logn)</li>
<li>map[i]来记录元素i上次出现的下标，并更新到数组last。后面，如果上一次出现的下标不在目前的搜索范围内，那么可以扩展。</li>
<li>数组法可能是因为数组太大，所以速度太慢。</li>
</ol>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="set法"><a href="#set法" class="headerlink" title="set法"></a>set法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000000 + 5;</span><br><span class="line">int A[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int T, n;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">  while(T--) &#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;A[i]);</span><br><span class="line"></span><br><span class="line">    set&lt;int&gt; s;</span><br><span class="line">    int L &#x3D; 0, R &#x3D; 0, ans &#x3D; 0;</span><br><span class="line">    while(R &lt; n) &#123;</span><br><span class="line">      while(R &lt; n &amp;&amp; !s.count(A[R])) s.insert(A[R++]);</span><br><span class="line">      ans &#x3D; max(ans, R - L);</span><br><span class="line">      s.erase(A[L++]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="map法"><a href="#map法" class="headerlink" title="map法"></a>map法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000000 + 5;</span><br><span class="line">int A[maxn], last[maxn];</span><br><span class="line">map&lt;int, int&gt; cur;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int T, n;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">  while(T--) &#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    cur.clear();</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">      scanf(&quot;%d&quot;, &amp;A[i]);</span><br><span class="line">      if(!cur.count(A[i])) last[i] &#x3D; -1;</span><br><span class="line">      else last[i] &#x3D; cur[A[i]];</span><br><span class="line">      cur[A[i]] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int L &#x3D; 0, R &#x3D; 0, ans &#x3D; 0;</span><br><span class="line">    while(R &lt; n) &#123;</span><br><span class="line">      while(R &lt; n &amp;&amp; last[R] &lt; L) R++;</span><br><span class="line">      ans &#x3D; max(ans, R - L);</span><br><span class="line">      L++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组法"><a href="#数组法" class="headerlink" title="数组法"></a>数组法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1e9 + 5;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int in[1000005];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		int n;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;in[i]);</span><br><span class="line">		int L &#x3D; 0, R &#x3D; 0, ans &#x3D; 0;</span><br><span class="line">		while (L &lt;&#x3D; R &amp;&amp; R &lt; n)</span><br><span class="line">		&#123;</span><br><span class="line">			if (!vis[in[R]]) &#123; vis[in[R]] &#x3D; 1; R++; &#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				ans &#x3D; max(ans, R - L);</span><br><span class="line">				vis[in[L]] &#x3D; 0; L++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, max(ans, R - L));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>煎饼</title>
    <url>/2020/01/29/%E7%85%8E%E9%A5%BC/</url>
    <content><![CDATA[<h1 id="UVA-120-煎饼"><a href="#UVA-120-煎饼" class="headerlink" title="UVA 120 煎饼"></a>UVA 120 煎饼</h1><p>给你一迭薄煎饼，请你写一个程式来指出要如何安排才能使这些薄煎饼由上到下依薄煎饼的半径由小到大排好。所有的薄煎饼半径均不相同。</p>
<p>要把薄煎饼排好序需要对这些薄煎饼做翻面（flip）的动作。方法是以一抹刀插入一迭薄煎饼中，然后做翻面的动作（也就是说在抹刀上面的薄煎饼经翻面后，会依相反的次序排列）。若一迭共有n个薄煎饼，我们定义最底下的薄煎饼的位置为1，最上面的薄煎饼位置为n。当抹刀插入位置为k时，代表从位置k到位置n的薄煎饼要做翻面的动作。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>题意是要进行排序，只不过基本操作是颠倒一个连续的子序列</li>
<li>借鉴选择排序的思想，从大到小依次将每个数排到正确的位置。</li>
<li>实现时先翻到最上面，再翻到正确位置。因为大的在下面，并且按照从大到小的顺序处理，所以当处理第i大的煎饼时，不会影响到1，2，3，…，i-1大的煎饼。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><ol>
<li>由于规模较小，所以使用order数组来确定大小关系，也可以使用max_element函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 35;</span><br><span class="line">int in[maxn];</span><br><span class="line">int order[maxn];</span><br><span class="line">int ans[maxn];</span><br><span class="line">int n;</span><br><span class="line">int main() &#123;</span><br><span class="line">string line;</span><br><span class="line">while (getline(cin, line))</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">	stringstream ss(line);</span><br><span class="line">	n &#x3D; 0;</span><br><span class="line">	while (ss &gt;&gt; in[n]) n++;</span><br><span class="line">	memcpy(order, in, sizeof(in));</span><br><span class="line">	sort(order, order + n);</span><br><span class="line">	int now;</span><br><span class="line">	for (int i &#x3D; n - 1; i &gt;&#x3D; 0;i--) &#123;</span><br><span class="line">		int now &#x3D; order[i];</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">			if (in[j] &#x3D;&#x3D; now) &#123;</span><br><span class="line">				if (j &#x3D;&#x3D; i ) break;</span><br><span class="line">				if (j !&#x3D; 0)  filp(j);</span><br><span class="line">				filp(i);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt;&quot;0&quot;&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="filp-从p处开始翻"><a href="#filp-从p处开始翻" class="headerlink" title="filp 从p处开始翻"></a>filp 从p处开始翻</h2><ol>
<li>使用swap函数更好理解，并且省下了辅助数组所耗费的时间和空间</li>
</ol>
<pre><code>
void filp(int p) {
for (int i = 0; i &lt; p - i; i++) 
    swap(in[i], in[p - i]);
printf(&quot;%d &quot;, n - p);

}
</code></pre>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>联合国大楼</title>
    <url>/2020/01/29/%E8%81%94%E5%90%88%E5%9B%BD%E5%A4%A7%E6%A5%BC/</url>
    <content><![CDATA[<h1 id="UVA-1605-联合国大楼"><a href="#UVA-1605-联合国大楼" class="headerlink" title="UVA 1605 联合国大楼"></a>UVA 1605 联合国大楼</h1><p>给出有多少个国家 nnn （ n&lt;= 50），需要给每个国家安排办公室。大楼的每一层有着相同的行列数，请你构造一种安排（输出层数，行数和列数），使得每两个国家之间都有一间挨着的办公室，且办公室总数不超过 1000000 ，用不同字母表示不同国家，输出每层楼的安排方法。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>最简单的，一共键两层，每层都是n*n,令第一层全是国家i，第二层第j列全是国家j。这样任何一个国家(行)必能与另一层的所有列相交，所以设计方案一定正确。</li>
<li>使用中途相遇法，从两个不同的方向来解决问题</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 50 + 5;</span><br><span class="line">int f1[maxn][maxn];</span><br><span class="line">int f2[maxn][maxn];</span><br><span class="line">inline char to_alp(int x) &#123; return x &lt; 26 ? x + &#39;A&#39; : &#39;a&#39; + x - 26; &#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int n;</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1) &#123;</span><br><span class="line"></span><br><span class="line">	printf(&quot;2 %d %d\n&quot;, n, n);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">			f1[i][j] &#x3D; i;</span><br><span class="line">			f2[i][j] &#x3D; j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">			printf(&quot;%c&quot;, to_alp(f1[i][j]));</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">			printf(&quot;%c&quot;, to_alp(f2[i][j]));</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>和为0的4个值</title>
    <url>/2020/01/29/%E5%92%8C%E4%B8%BA0%E7%9A%844%E4%B8%AA%E5%80%BC/</url>
    <content><![CDATA[<h1 id="UVA-1152-和为0的4个值"><a href="#UVA-1152-和为0的4个值" class="headerlink" title="UVA 1152 和为0的4个值"></a>UVA 1152 和为0的4个值</h1><p>给出四个集合，从每个集合中任取一个数，问有多少种方案使得四个数和为0</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>最直观的四重循环复杂度O(n<sup>4</sup>)不可能</li>
<li>三重循环计算第四个数，之后查找这个数。如果查找使用二分查找，那么复杂度也在O(n<sup>3</sup>nlogn)</li>
<li><strong>解决</strong> 首先枚举a,b，把所有a+b记录下来放到一个有序sum数组中。之后枚举c,d，统计对于sum中的每个元素有多少种写成-C[i]-D[j]的方法(利用upper_bound和lower_bound的差计算)。两个步骤都是n<sup>2</sup>logn，总的也是n<sup>2</sup>logn</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 4000 + 5;</span><br><span class="line">int A[maxn];</span><br><span class="line">int B[maxn];</span><br><span class="line">int C[maxn];</span><br><span class="line">int D[maxn];</span><br><span class="line">int sum[maxn*maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">int T;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">while (T--)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">		scanf(&quot;%d %d %d %d&quot;, &amp;A[i], &amp;B[i], &amp;C[i], &amp;D[i]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	int index &#x3D; 0;</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++) </span><br><span class="line">			sum[index++] &#x3D; A[i] + B[j];</span><br><span class="line">	sort(sum, sum + index);</span><br><span class="line">	long long  cnt &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++) </span><br><span class="line">			cnt +&#x3D; upper_bound(0, index, -C[i] - D[j]) - lower_bound(0, index, -C[i] - D[j]);</span><br><span class="line">	printf(&quot;%lld\n&quot;, cnt);</span><br><span class="line">	if (T) printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a>upper_bound</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int upper_bound(int x, int y, int v) &#123;</span><br><span class="line">int m;</span><br><span class="line">while (x&lt;y)</span><br><span class="line">&#123;</span><br><span class="line">	m &#x3D; x + (y - x) &#x2F; 2;</span><br><span class="line">	if (sum[m] &lt;&#x3D; v) x &#x3D; m + 1;</span><br><span class="line">	else y &#x3D; m;</span><br><span class="line">&#125;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int lower_bound(int x, int y, int v) &#123;</span><br><span class="line">int m;</span><br><span class="line">while (x&lt;y)</span><br><span class="line">&#123;</span><br><span class="line">	m &#x3D; x + (y - x) &#x2F; 2;</span><br><span class="line">	if (sum[m] &gt;&#x3D; v) y &#x3D; m;</span><br><span class="line">	else x &#x3D; m + 1;</span><br><span class="line">&#125;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口最小问题</title>
    <url>/2020/01/29/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="P1886-滑动窗口最小问题"><a href="#P1886-滑动窗口最小问题" class="headerlink" title="P1886 滑动窗口最小问题"></a>P1886 滑动窗口最小问题</h1><p>有一个长为 n 的序列 a，以及一个大小为 k 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。</p>
<p><img src="/img_UVA%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/5.png" alt=""></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>窗口滑动的过程，相当于删除一个元素，再插入一个元素，同时获得最大值或者最小值。相当于一个<strong>优先级队列</strong>，可以使用set来模拟一个优先级队列实现,时间复杂度O((n-k)logk)，其中插入，删除，取极值都是logk,一共需要滑动n-k次。规模大时TLE。</li>
<li>使用<strong>单调队列</strong>：队列中元素顺序与输入相同，而元素的值是有序的。因为每个元素至多被删除依次，所以总的时间复杂度在O(n)。以单调增队列为例<ol>
<li>如果当前正在扫描的元素比队列队尾元素大，那么直接插入。如果比队尾元素小，则将元素从<strong>队尾出队</strong>，直到队尾元素小于当前元素。</li>
<li>如果插入元素后，有的元素滑动到窗口外，则应该从<strong>队头出队</strong></li>
</ol>
</li>
<li>单调增队列求最小值，单调减序列维护最大值。<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">struct monotone_queue &#123;</span><br><span class="line">	static const int maxn &#x3D; 1e6+5;</span><br><span class="line">	int n, k, a[maxn];</span><br><span class="line">	int q[maxn], head, tail, p[maxn];&#x2F;&#x2F;q是值的队列,q是编号的队列</span><br><span class="line"></span><br><span class="line">	void read_in() &#123;</span><br><span class="line">		scanf(&quot;%d %d&quot;, &amp;n, &amp;k);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void monotone_min() &#123;</span><br><span class="line">		int head &#x3D; 1;</span><br><span class="line">		int tail &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			while (head &lt;&#x3D; tail &amp;&amp; q[tail] &gt;&#x3D; a[i]) tail--;&#x2F;&#x2F;比当前元素大的全部从队尾出队</span><br><span class="line">			q[++tail] &#x3D; a[i];</span><br><span class="line">			p[tail] &#x3D; i;&#x2F;&#x2F;插入当前元素</span><br><span class="line">			while (p[head] &lt;&#x3D; i - k) head++;&#x2F;&#x2F;窗口外元素从队头出队</span><br><span class="line">			if (i &gt;&#x3D; k) printf(&quot;%d &quot;, q[head]);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void monotone_max() &#123;</span><br><span class="line">		int head &#x3D; 1;</span><br><span class="line">		int tail &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			while (head &lt;&#x3D; tail &amp;&amp; q[tail] &lt;&#x3D; a[i]) tail--;&#x2F;&#x2F;比当前元素小的全部从队尾出队</span><br><span class="line">			q[++tail] &#x3D; a[i];</span><br><span class="line">			p[tail] &#x3D; i;</span><br><span class="line">			while (p[head] &lt;&#x3D; i - k) head++;</span><br><span class="line">			if (i &gt;&#x3D; k) printf(&quot;%d &quot;, q[head]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">monotone_queue mq;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	mq.read_in();</span><br><span class="line">	mq.monotone_min();</span><br><span class="line">	mq.monotone_max();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="模拟优先队列-超时"><a href="#模拟优先队列-超时" class="headerlink" title="模拟优先队列(超时)"></a>模拟优先队列(超时)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1e6 + 5;</span><br><span class="line"> </span><br><span class="line">set&lt;int, less&lt;int&gt; &gt; s;</span><br><span class="line">int big[maxn], small[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, k;</span><br><span class="line">	scanf(&quot;%d %d&quot;, &amp;n, &amp;k);</span><br><span class="line"></span><br><span class="line">	int a;</span><br><span class="line">	int p1 &#x3D; 0, p2 &#x3D; 0;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">		q.push(a);</span><br><span class="line">		s.insert(a);</span><br><span class="line">		if (q.size() &#x3D;&#x3D; k) &#123;</span><br><span class="line">			int tmp &#x3D; q.front(); q.pop();</span><br><span class="line">			small[p1++] &#x3D; *(s.begin());</span><br><span class="line">			big[p2++] &#x3D; *(s.rbegin());</span><br><span class="line">			s.erase(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; p1; i++)</span><br><span class="line">		printf(&quot;%d &quot;, small[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; p2; i++)</span><br><span class="line">		printf(&quot;%d &quot;, big[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>排序与检索</title>
    <url>/2020/01/27/%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%A3%80%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="归并排序-O-nlogn"><a href="#归并排序-O-nlogn" class="headerlink" title="归并排序 O(nlogn)"></a>归并排序 O(nlogn)</h1><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ol>
<li>划分问题： 把序列分成元素个数尽量相等的两半</li>
<li>递归求解： 把两半元素分别排序</li>
<li>合并问题： 把两个有序表合并成一个</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void merge_sort(int *A,int x,int y,int* T)&#123;</span><br><span class="line">if(y-x&gt;1)&#123;</span><br><span class="line">	int m &#x3D; x+(y-x)&#x2F;2;</span><br><span class="line">	int p &#x3D; x,q &#x3D; m,i &#x3D; x; </span><br><span class="line">	merge_sort(A,x,m,T);</span><br><span class="line">	merge_sort(A,m,y,T);</span><br><span class="line">	while(p&lt;m||q&lt;y)&#123;</span><br><span class="line">		if(q&gt;&#x3D;y||(p&lt;m&amp;&amp;A[p]&lt;&#x3D;A[q]))</span><br><span class="line">		&#x2F;&#x2F;如果右侧表为空而左表非空或者左表元素小于右表元素，那么将左表复制到临时表</span><br><span class="line">			T[i++] &#x3D; A[p++];</span><br><span class="line">		else&#123;</span><br><span class="line">			 T[i++] &#x3D; A[q++];</span><br><span class="line">			 &#x2F;&#x2F;cnt+&#x3D;m-p;	可以统计逆序对的个数</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(i &#x3D; x;i&lt;y;i++) A[i] &#x3D; T[i]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>加入cnt+=m-p可以统计序列中逆序对的个数。</strong>这是因为合并的时候是按从小到大的顺序进行，当执行else语句时，说明此时右侧元素更小，此时左边还没来得及复制的元素就是左边所有比A[j]大的数，m-p即为他的个数。</li>
</ol>
<h1 id="快速排序-O-nlogn"><a href="#快速排序-O-nlogn" class="headerlink" title="快速排序 O(nlogn)"></a>快速排序 O(nlogn)</h1><ol>
<li>划分问题： 把数组的各个元素重排后分成左右两部分，使得左边的任意元素都小于或等于右边的任意元素</li>
<li>递归求解： 把左右两部分分别划分</li>
<li>合并问题： 不用合并，因为此时数组已经完全有序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void QSort( SqList &amp;L,  int  low,  int high) &#123;</span><br><span class="line">   if( low &lt; high)&#123;</span><br><span class="line">          pivotloc &#x3D; Partition( L, low, high);</span><br><span class="line">          QSort( L, low, pivotloc – 1);</span><br><span class="line">          QSort( L, pivotloc + 1, high);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Partition( SqList &amp;L,  int low,  int high)</span><br><span class="line">&#123; </span><br><span class="line">   L.r[0] &#x3D; L.r[low];</span><br><span class="line">   pivotkey &#x3D; L.r[low].key;</span><br><span class="line">   while( low &lt; high)&#123;</span><br><span class="line">        while( low &lt; high &amp;&amp; L.r[high].key &gt;&#x3D; pivotkey)  --high;</span><br><span class="line">        L.r[low] &#x3D; L.r[high];</span><br><span class="line">        while( low &lt; high &amp;&amp; L.r[low].key &lt;&#x3D; pivotkey)  ++low;</span><br><span class="line">        L.r[high] &#x3D; L.r[low];</span><br><span class="line">   &#125;</span><br><span class="line">   L.r[low] &#x3D; L.r[0];   </span><br><span class="line">   return low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol>
<li>可以解决的问题：选择出第k大的数。序列划分成A[low,pivotkey]和A[pivotkey+1,high]两部分，比较左侧元素个数q-p+1和k的大小关系，选择在左半部递归还是在右半部递归。</li>
</ol>
<h1 id="二分查找-适用于有序序列"><a href="#二分查找-适用于有序序列" class="headerlink" title="二分查找 适用于有序序列"></a>二分查找 适用于有序序列</h1><ol>
<li>划分问题： 将序列分成尽量相等的两份</li>
<li>递归求解： 在左半部分或者右半部分搜素</li>
<li>合并问题： 无需合并</li>
</ol>
<h2 id="迭代-常用"><a href="#迭代-常用" class="headerlink" title="迭代(常用)"></a>迭代(常用)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">int bsearch(int* A,int x,int y,int v)&#123;</span><br><span class="line">while(x&lt;y)&#123;</span><br><span class="line">	m &#x3D; x + (y-x)&#x2F;2;</span><br><span class="line">	if(A[m]&#x3D;&#x3D;v) return m;</span><br><span class="line">	else if(A[m]&gt;v) y &#x3D; m;</span><br><span class="line">	else x &#x3D; m+1;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">int bsearch(int l,int r)&#123;</span><br><span class="line">	int m &#x3D; l+(r-l)&#x2F;2;</span><br><span class="line">	if(A[m]&#x3D;&#x3D;goal) return m;</span><br><span class="line">	else if(goal&lt;A[m])</span><br><span class="line">		return bsearch(l,m);</span><br><span class="line">	else return bsearch(m+1,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="考虑新问题："><a href="#考虑新问题：" class="headerlink" title="考虑新问题："></a>考虑新问题：</h2><p>如果数组中有多个goal，如果返回目标值的完整区间(上例程序返回中间那一个的索引)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int lower_bound(int* A,int x,int y,int v)&#123;</span><br><span class="line">int m;</span><br><span class="line">while(x&lt;y)&#123;</span><br><span class="line">	m &#x3D; x + (y-x)&#x2F;2;</span><br><span class="line">	if(A[m]&gt;&#x3D;v) y &#x3D; m;</span><br><span class="line">	else x &#x3D; m+1;</span><br><span class="line">&#125;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>上述程序返回v的第一个出现位置或者是返回一个下标i，在i处插入v，后面的序列仍然有序。</li>
<li>虽然搜索的区间是[x,y)，但是v可能比A[y-1]要大，所以返回值的取值范围在[x,y]。A[m]和v的关系的影响包括：<ol>
<li>A[m]==v 时，至少找到了一个，但是左边可能还有，搜索区间变成[x,m]</li>
<li>A[m]&gt;v 时，所求位置不可能在后面，但可能是m，因此区间变成[x,m]</li>
<li>A[m]&lt;v 时，区间变成[m+1,y]</li>
</ol>
</li>
<li>相应的可以写出upper_bound，共同构成    [L,R)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int upper_bound(int* A,int x,int y,int v)&#123;</span><br><span class="line">int m;</span><br><span class="line">while(x&lt;y)&#123;</span><br><span class="line">	m &#x3D; x+(y-x)&#x2F;2;</span><br><span class="line">	if(A[m]&lt;&#x3D;v) x &#x3D; m+1;</span><br><span class="line">	else y &#x3D; m;</span><br><span class="line">&#125;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-中"><a href="#C-中" class="headerlink" title="C++中"></a>C++中</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;lower_bound(起始地址，结束地址，要查找的数值) 返回大于或等于val的第一个元素位置，返回类型为迭代器</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;upper_bound(起始地址，结束地址，要查找的数值)返回大于val的第一个元素位置，返回迭代器</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;binary_search(起始地址，结束地址，要查找的数值)  返回的是是否存在这么一个数，是一个bool值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; t;</span><br><span class="line">    t.push_back(1);</span><br><span class="line">    t.push_back(2);</span><br><span class="line">    t.push_back(3);</span><br><span class="line">    t.push_back(5);</span><br><span class="line">    t.push_back(5);</span><br><span class="line">    t.push_back(7);</span><br><span class="line">    t.push_back(8);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    int low&#x3D;lower_bound(t.begin(),t.end(),5) - t.begin();</span><br><span class="line">    int upp&#x3D;upper_bound(t.begin(),t.end(),5) - t.begin();</span><br><span class="line">    cout&lt;&lt;low&lt;&lt;endl;&#x2F;&#x2F;3</span><br><span class="line">    cout&lt;&lt;upp&lt;&lt;endl;&#x2F;&#x2F;5</span><br><span class="line"></span><br><span class="line">    return 0；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="递归与分支"><a href="#递归与分支" class="headerlink" title="递归与分支"></a>递归与分支</h1><h2 id="棋盘覆盖问题"><a href="#棋盘覆盖问题" class="headerlink" title="棋盘覆盖问题"></a>棋盘覆盖问题</h2><p>有一个2<sup>k</sup>×2<sup>k</sup>的方格棋盘，恰有一个方格是黑色的，其他是白色的。你的任务是用包含3个方格的L型牌覆盖所有白色方格。黑色方格不能被覆盖，且任意一个白色方格不能同时被两个或更多牌覆盖。问至少要用多少L型牌。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>分治法，每次将棋盘分割成4块，每块都是2<sup>k-1</sup>×2<sup>k-1</sup>。</li>
<li>对于有黑格子的块使用递归解决，没有黑格子的块构造出一个黑格子。</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;（tr,tc)表示棋盘左上角坐标 (dr,dc)表示黑块坐标</span><br><span class="line">void ChessBoard(int tr,int tc,int dr,int dc,int size)</span><br><span class="line">&#123;</span><br><span class="line">    if(size&#x3D;&#x3D;1) return;</span><br><span class="line">    int t&#x3D;tile++,s&#x3D;size&#x2F;2;</span><br><span class="line"></span><br><span class="line">    if(dr&lt;tr+s &amp;&amp; dc&lt;tc+s)&#x2F;&#x2F;&#x2F;在左上角区域内</span><br><span class="line">    	ChessBoard(tr,tc,dr,dc,s);</span><br><span class="line">    else&#x2F;&#x2F;&#x2F;不在左上角区域内</span><br><span class="line">    &#123;</span><br><span class="line">        Board[tr+s-1][tc+s-1]&#x3D;t;&#x2F;&#x2F;&#x2F;用t号(用一个数字表示)L型骨牌覆盖右下角</span><br><span class="line">        ChessBoard(tr,tc,tr+s-1,tc+s-1,s);&#x2F;&#x2F;&#x2F;覆盖剩余方格</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(dr&lt;tr+s &amp;&amp; dc&gt;&#x3D;tc+s)&#x2F;&#x2F;&#x2F;在右上角区域内</span><br><span class="line">        ChessBoard(tr,tc+s,dr,dc,s);</span><br><span class="line">    else&#x2F;&#x2F;&#x2F;不在右上角的区域内</span><br><span class="line">    &#123;</span><br><span class="line">        Board[tr+s-1][tc+s]&#x3D;t;</span><br><span class="line">        ChessBoard(tr,tc+s,tr+s-1,tc+s,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(dr&gt;&#x3D;tr+s &amp;&amp; dc&lt;tc+s)</span><br><span class="line">        ChessBoard(tr+s,tc,dr,dc,s);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Board[tr+s][tc+s-1]&#x3D;t;</span><br><span class="line">        ChessBoard(tr+s,tc,tr+s,tc+s-1,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(dr&gt;&#x3D;tr+s &amp;&amp; dc&gt;&#x3D;tc+s)</span><br><span class="line">        ChessBoard(tr+s,tc+s,dr,dc,s);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Board[tr+s][tc+s]&#x3D;t;</span><br><span class="line">        ChessBoard(tr+s,tc+s,tr+s,tc+s,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环日程表问题"><a href="#循环日程表问题" class="headerlink" title="循环日程表问题"></a>循环日程表问题</h2><p>有n=2<sup>k</sup>个运动员进行网球循环赛，需要设计比赛日程表。每个选手必须与其他n-1个选手各赛一次：每个选手每天只能赛一次，循环赛一共进行n-1天。按此要求设计一张比赛日程表，该表用n行和n-1列，第i行j列为第i个选手第j天遇到的选手。</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>观察紫书P230页给出的样例结果，发现结果是对称矩阵，且每一个小块处都是对称的，所以考虑使用分治法。</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; (1 &lt;&lt; 10);</span><br><span class="line">int table[maxn][maxn];</span><br><span class="line">void fill(int x, int y, int n);&#x2F;&#x2F;填充左上角为x,y的，长度为n的方格</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	table[0][0] &#x3D; 1;</span><br><span class="line">	fill(0, 0, n);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">			printf(&quot;%d &quot;, table[i][j]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void fill(int x, int y, int n) &#123;</span><br><span class="line">	if (n &#x3D;&#x3D; 1) return;</span><br><span class="line">	int half &#x3D; n &#x2F; 2;</span><br><span class="line"></span><br><span class="line">	table[x + half][y + half] &#x3D; table[x][y];</span><br><span class="line">	table[x + half][y] &#x3D; table[x][y + half] &#x3D; table[x][y] + half;</span><br><span class="line">	fill(x, y, half);</span><br><span class="line">	fill(x + half, y, half);</span><br><span class="line">	fill(x, y + half, half);</span><br><span class="line">	fill(x + half, y + half, half);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="巨人与鬼"><a href="#巨人与鬼" class="headerlink" title="巨人与鬼"></a>巨人与鬼</h2><p>在平面上有n个巨人和n个鬼，没有三者在同一条直线上。每个巨人需要选择一个不同的鬼，向其发送质子流消灭它，质子流呈直线。质子流不能交叉，要求设计一种巨人和鬼的配对方法。</p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>使用分治法，以连线两侧内的巨人和鬼的数量相等来分割，然后递归解决。</li>
<li>考虑最左下角的点，假设它是一个巨人，然后将其余的点按照极角从小到大排列依次检查<ol>
<li>如果第一个点是鬼，则匹配完成，剩下的鬼和巨人一样多</li>
<li>如果第一个点是巨人，那么继续检查知道鬼和巨人一样多。</li>
<li>以这个连线为分界，分割问题，递归解决。</li>
</ol>
</li>
</ol>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">int x, y, flag, id;</span><br><span class="line">&#125;;</span><br><span class="line">node p[1000], base;</span><br><span class="line">int ans[1000];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void go(int l, int r);&#x2F;&#x2F;在数组中的左右边界</span><br><span class="line">bool cmp1(node &amp;a, node&amp;b) &#123; return a.y &lt; b.y || a.y &#x3D;&#x3D; b.y&amp;&amp;a.x &lt; b.x; &#125;</span><br><span class="line">bool cmp2(node &amp;a, node &amp;b) &#123;</span><br><span class="line">	return atan2((a.y - base.y), (a.x - base.x)) &lt; atan2((b.y - base.y), (b.x - base.x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int T;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">while (T--)</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d %d %d&quot;, &amp;p[i].flag, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">		p[i].id &#x3D; i + 1;</span><br><span class="line">	&#125;</span><br><span class="line">	go(0, n - 1);</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D;n; i++)</span><br><span class="line">		printf(&quot;%d &quot;, ans[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void go(int l, int r) &#123;</span><br><span class="line">if (l &gt; r)</span><br><span class="line">	return;</span><br><span class="line">sort(p + l, p + r + 1, cmp1);</span><br><span class="line">base &#x3D; p[l];</span><br><span class="line">sort(p + l + 1, p + r + 1, cmp2);</span><br><span class="line">int c1 &#x3D; 0, c2 &#x3D; 0;</span><br><span class="line">int k &#x3D; r;</span><br><span class="line">while (!(p[k].flag !&#x3D; base.flag&amp;&amp;c1 &#x3D;&#x3D; c2))</span><br><span class="line">&#123;</span><br><span class="line">	if (p[k].flag &#x3D;&#x3D; base.flag) c1++;&#x2F;&#x2F;巨人</span><br><span class="line">	else c2++;</span><br><span class="line">	k--;</span><br><span class="line">&#125;</span><br><span class="line">ans[p[k].id] &#x3D; base.id;</span><br><span class="line">ans[base.id] &#x3D; p[k].id;</span><br><span class="line">go(l + 1, k - 1);</span><br><span class="line">go(k + 1, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h1><h2 id="乘船问题"><a href="#乘船问题" class="headerlink" title="乘船问题"></a>乘船问题</h2><p>第一行输入s,表示测试数据的组数；<br>每组数据的第一行包括两个整数w，n，80&lt;=w&lt;=200,1&lt;=n&lt;=300，w为一条独木舟的最大承载量,n为人数；<br>接下来的一组数据为每个人的重量（不能大于船的承载量）；<br>输出<br>每组人数所需要的最少独木舟的条数。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol>
<li>贪心法：给最轻的人i找最重j的匹配，如果仍然超重，那么这个重人只能单独坐船。</li>
<li>证明：使用反证法<ol>
<li>如果目前i单独乘船，那么令j和他同乘不会使总的乘船数量增多。</li>
<li>如果目前i和k同乘，那么根据假设，k应该比j轻，那么k和j交换之后k所在的船仍然不会超重。按照贪心法的过程，交换后j所在船也不会超重。</li>
<li>因此，这样贪心不会丢失最优解</li>
</ol>
</li>
</ol>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 305;</span><br><span class="line">int weight[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int T, c, n;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">while (T--)</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d %d&quot;, &amp;c, &amp;n);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;weight[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int l &#x3D; 0, r &#x3D; n - 1;</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	sort(weight, weight + n);</span><br><span class="line">	while (l &lt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		if (weight[l] + weight[r] &lt;&#x3D; c)</span><br><span class="line">			l++;</span><br><span class="line">		ans++;</span><br><span class="line">		r--;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择不相交区间"><a href="#选择不相交区间" class="headerlink" title="选择不相交区间"></a>选择不相交区间</h2><p>输入n个区间，从中选出尽量多的不相交区间。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>首先，最明显的是如果区间A完全包含于区间B，那么应该选择区间A。所以贪心的策略是一定要选择第一个区间</p>
</li>
<li><p>证明： 首先对区间进行排序，b已经有序，观察a的关系</p>
<ol>
<li>如果a1&gt;a2，那么区间2包含了区间1，则应该选择区间1(依据1中讨论),并且以后的所有选中的区间i都要满足a1&lt;ai</li>
<li>在1的条件下，则a也有序。如果区间2和区间1完全不相交，那么没有影响；否则区间1和区间2只能保留一个。</li>
<li>考虑临近的区间3，区间1和区间3的重叠部分被区间2所包含，根据1中讨论，应该保留区间1。这也就说明不能因为其他区间的影响而不选择区间1，所以贪心策略成立。</li>
</ol>
</li>
<li><p>选择区间1后要把所有和区间1相交的区间排除在外，需要记录上一个被选择的区间编号。</p>
</li>
</ol>
<h3 id="代码-NBUT-今年暑假不AC"><a href="#代码-NBUT-今年暑假不AC" class="headerlink" title="代码 NBUT 今年暑假不AC"></a>代码 NBUT 今年暑假不AC</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int a, b;</span><br><span class="line">	bool operator &lt; (const node&amp;x) const &#123; return b &lt; x.b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node g[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;g[i].a, &amp;g[i].b);</span><br><span class="line">			if (g[i].a &gt; g[i].b)</span><br><span class="line">				swap(g[i].a, g[i].b);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sort(g, g + n);</span><br><span class="line"></span><br><span class="line">		int r &#x3D; -1;</span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			if (g[i].a &gt;&#x3D; r) &#123;&#x2F;&#x2F;此处是否取等取决于题目中端点共有算几次</span><br><span class="line">				ans++;</span><br><span class="line">				r &#x3D; g[i].b;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间选点问题"><a href="#区间选点问题" class="headerlink" title="区间选点问题"></a>区间选点问题</h2><p>在数轴上有n个闭区间[a,b]，要求去尽量少的点，使得每个区间内都有至少一个点</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ol>
<li>如果区间1被区间2完全包含，那么在区间1内取的点必定在区间2中。</li>
<li>如果区间1和区间2部分相交，且区间2在后面，那么在区间1的尾部取点最可能在区间2中。</li>
<li>所以贪心策略是取最后一个点</li>
<li>所以首先对b进行排序，每次取最后一个点，如果某个区间的起始点超过了最后一个点的坐标，那么要更新最后一个点的位置。</li>
</ol>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><p>其实和选择不相交区间是一样的,此处留下一个板子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1005;</span><br><span class="line">struct node &#123;</span><br><span class="line">int a, b;</span><br><span class="line">bool operator &lt; (const node &amp;x)const &#123; return b &lt; x.b || b &#x3D;&#x3D; x.b&amp;&amp;a &lt; x.a; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node p[maxn];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;n)&#x3D;&#x3D;1)</span><br><span class="line">&#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d %d&quot;, &amp;p[i].a, &amp;p[i].b);</span><br><span class="line">		if (p[i].a &gt; p[i].b)</span><br><span class="line">			swap(p[i].a, p[i].b);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(p, p + n);</span><br><span class="line">	int r &#x3D; -1;&#x2F;&#x2F;此处也可以设置为p[0].b，同时ans&#x3D;1</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (p[i].a &gt; r) &#123;</span><br><span class="line">			ans++;</span><br><span class="line">			r &#x3D; p[i].b;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;ans: %d\n&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间覆盖问题"><a href="#区间覆盖问题" class="headerlink" title="区间覆盖问题"></a>区间覆盖问题</h2><p>从n个区间中选择尽量少的区间覆盖目标区间[s,t]。代码对应覆盖[0,t]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1005;</span><br><span class="line">int n;</span><br><span class="line">struct node &#123;</span><br><span class="line">int a, b;</span><br><span class="line">bool operator &lt; (const node &amp;x)const &#123; return a &lt; x.a || a &#x3D;&#x3D; x.a &amp;&amp; b&gt;x.b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node p[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int T;</span><br><span class="line">int s, t;</span><br><span class="line">s &#x3D; 0;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">while (T--)</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">	n &#x3D; 0;</span><br><span class="line">	while (scanf(&quot;%d %d&quot;, &amp;p[n].a, &amp;p[n].b) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">		if (p[n].a &#x3D;&#x3D; 0 &amp;&amp; p[n].b &#x3D;&#x3D; 0)</span><br><span class="line">			break;</span><br><span class="line">		if (p[n].a &gt; p[n].b)</span><br><span class="line">			swap(p[n].a, p[n].b);</span><br><span class="line">		if (p[n].b &lt; t || p[n].b &lt; s) continue;</span><br><span class="line">		p[n].a &#x3D; max(p[n].a, s);</span><br><span class="line">		p[n].b &#x3D; min(p[n].b, t);</span><br><span class="line">		if (p[n].a &lt; p[n].b)</span><br><span class="line">			n++;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(p, p + n);</span><br><span class="line">	if (!n||p[0].a !&#x3D; s)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;ans: 0\n&quot;);</span><br><span class="line">		continue;</span><br><span class="line">	&#125;</span><br><span class="line">	int r &#x3D; s;</span><br><span class="line">	int ans &#x3D;0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (p[i].b &gt; r) &#123;</span><br><span class="line">			r &#x3D; p[i].b;</span><br><span class="line">			ans++;</span><br><span class="line">			printf(&quot;%d %d\n&quot;, p[i].a, p[i].b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;ans: %d\n\n&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Huffman-编码"><a href="#Huffman-编码" class="headerlink" title="Huffman 编码"></a>Huffman 编码</h1><h2 id="Huffman-树"><a href="#Huffman-树" class="headerlink" title="Huffman 树"></a>Huffman 树</h2><ol>
<li>n个叶子的二叉树一定对应一个前缀码。如果编码a是编码b的前缀，则a所对应的结点一定为b所对应节点的先祖，而两个叶子不会有先祖后代的关系。</li>
<li>最优前缀码一定可以写成二叉树</li>
</ol>
<h2 id="Huffman-算法-O-nlogn"><a href="#Huffman-算法-O-nlogn" class="headerlink" title="Huffman 算法 O(nlogn)"></a>Huffman 算法 O(nlogn)</h2><p>把每个字符看作一个单结点子树放在一个树集合中，每颗子树的权值等于相应字符的频率。每次取权值最小的两颗紫书合并成一颗新树，并重新放到集合中。新树的权值等于两颗子树权值之和。</p>
<h2 id="相关问题-UVA10954"><a href="#相关问题-UVA10954" class="headerlink" title="相关问题 UVA10954"></a>相关问题 UVA10954</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, x;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">			pq.push(x);</span><br><span class="line">		&#125;</span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n - 1; i++) &#123;</span><br><span class="line">			int a &#x3D; pq.top(); pq.pop();</span><br><span class="line">			int b &#x3D; pq.top(); pq.pop();</span><br><span class="line">			ans +&#x3D; a + b;</span><br><span class="line">			pq.push(a + b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>最大连续和问题</title>
    <url>/2020/01/24/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>给定一个长度为n的序列1,A2,···,An，求最大连续和</p>
<h1 id="O-n3"><a href="#O-n3" class="headerlink" title="O(n3)"></a>O(n<sup>3</sup>)</h1><p>枚举始末位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">for(int i&#x3D;0;i&lt;&#x3D;n;i++)</span><br><span class="line">	for(int j&#x3D;0;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">		int sum &#x3D; 0;</span><br><span class="line">		for(int k&#x3D;i;k&lt;&#x3D;j;k++)&#123;</span><br><span class="line">			sum+&#x3D;A[k];</span><br><span class="line">			tot++;</span><br><span class="line">		&#125;</span><br><span class="line">		if(sum&gt;best) best&#x3D;sum;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="O-n2"><a href="#O-n2" class="headerlink" title="O(n2)"></a>O(n<sup>2</sup>)</h1><p>先递推的求出前i项和，利用Sj-Si求出i-j的连续和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">S[0] &#x3D; 0;</span><br><span class="line">for(int i&#x3D;0;i&lt;n;i++) S[i] &#x3D; A[i]+S[i-1];</span><br><span class="line">for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">for(int j &#x3D; i;j &lt; n;j++)</span><br><span class="line">best &#x3D; max(best,S[j]-S[i-1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分治法-O-nlogn"><a href="#分治法-O-nlogn" class="headerlink" title="分治法 O(nlogn)"></a>分治法 O(nlogn)</h1><ol>
<li>划分问题：将序列分成数量尽可能相等两部分</li>
<li>递归求解：分别求出完全位于左半部和完全位于右半部的最佳序列</li>
<li>合并问题：求出起点位于左半，终点位于右半的连续和序列<ol>
<li>注：递归方程T(n) = 2T(n/2)+O(n)</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int maxsum(int* A, int x, int y)&#123;</span><br><span class="line">	if(y-x&#x3D;&#x3D;1) return A[x];</span><br><span class="line">	int m &#x3D; x+(y-x)&#x2F;2;</span><br><span class="line">	int maxs &#x3D; max(maxsum(A,x,m),maxsum(A,m,y));</span><br><span class="line">	int v, L, R;</span><br><span class="line">	v&#x3D; 0;L &#x3D; A[m-1];</span><br><span class="line">	for(int i &#x3D; m-1;i &gt;&#x3D; x;i--)</span><br><span class="line">		L &#x3D; max(L,v +&#x3D; A[i]);</span><br><span class="line">	v&#x3D; 0;R &#x3D; A[m];</span><br><span class="line">	for(int i &#x3D; m;i &lt; y;i++)</span><br><span class="line">		R &#x3D; max(R,v +&#x3D; A[i]);</span><br><span class="line">	return max(maxs, L+R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>战场</title>
    <url>/2020/01/24/%E6%88%98%E5%9C%BA/</url>
    <content><![CDATA[<h1 id="UVA-11853-战场"><a href="#UVA-11853-战场" class="headerlink" title="UVA 11853 战场"></a>UVA 11853 战场</h1><p>有一个1000*1000的正方形战场，战场西南角的坐标为(0,0)，西北角的坐标为(0,1000)。战场上有n个敌人，给定每个敌人的坐标和攻击半径，求能否从西边进入，从东边离开。如果有多个位置进出，则求出最北的进/出位置。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>地图比较大，敌人相对较少。转换思路，考虑能否从上边界踩着敌人到达下边界</p>
<ol>
<li>如果能，则说明敌人将战场从中分割，即无解。</li>
<li>如果不能，在选择最北的点。</li>
</ol>
</li>
<li><p>将问题转换成了图的连通性问题，下面给出bfs和dfs两种解法</p>
</li>
<li><p>dfs速度远远快于bfs</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    bool dfs(int u)</span><br><span class="line">	&#123;</span><br><span class="line">	if (vis[u]) return false;</span><br><span class="line">	vis[u] &#x3D; 1;</span><br><span class="line">	if (y[u] &lt; r[u]) return true;</span><br><span class="line">	for (int v &#x3D; 0; v &lt; n; v++) &#123;</span><br><span class="line">		if (intersect(u, v) &amp;&amp; dfs(v)) </span><br><span class="line">			return true;</span><br><span class="line">	&#125;</span><br><span class="line">	check(u);</span><br><span class="line">	return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">1. 注意是在走不通时，才更新进入点</span><br></pre></td></tr></table></figure>
<h3 id="intersect-判断两个圆是否相交"><a href="#intersect-判断两个圆是否相交" class="headerlink" title="intersect 判断两个圆是否相交"></a>intersect 判断两个圆是否相交</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool intersect(int a, int b) &#123;</span><br><span class="line">return sqrt((x[a] - x[b])*(x[a] - x[b]) + (y[a] - y[b])*(y[a] - y[b])) &lt; r[a] + r[b];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="check-更新进入点"><a href="#check-更新进入点" class="headerlink" title="check 更新进入点"></a>check 更新进入点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void check(int u)</span><br><span class="line">&#123;</span><br><span class="line">if (x[u] &lt; r[u]) left &#x3D; min(left, y[u] - sqrt(r[u] * r[u] - x[u] * x[u]));</span><br><span class="line">if (x[u] + r[u] &gt; W) right &#x3D; min(right, y[u] - sqrt(r[u] * r[u] - (W - x[u])*(W - x[u])));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">#ifdef local</span><br><span class="line">freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">#endif &#x2F;&#x2F; local</span><br><span class="line">while (~scanf(&quot;%d&quot;, &amp;n)) &#123;</span><br><span class="line">	bool ok &#x3D; true;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	left &#x3D; right &#x3D; W;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, x + i, y + i, r + i);</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (r[i] + y[i] &gt;&#x3D; W &amp;&amp; dfs(i)) &#123; ok &#x3D; false; break; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (ok) printf(&quot;0.00 %.2lf 1000.00 %.2lf\n&quot;, left, right);</span><br><span class="line">	else printf(&quot;IMPOSSIBLE\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#pragma warning(disable:4996)</span><br><span class="line">#define LOCAL</span><br><span class="line">#ifdef LOCAL</span><br><span class="line">FILE *fin &#x3D; freopen(&quot;战场in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">FILE *fout &#x3D; freopen(&quot;战场out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">#endif </span><br><span class="line">using namespace std;</span><br><span class="line">int vis[1005];</span><br><span class="line">int n;</span><br><span class="line">double le, ri;</span><br><span class="line">struct Node &#123;</span><br><span class="line">double x, y, r;</span><br><span class="line">Node(double x, double y, double r) :x(x), y(y), r(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Node&gt; enemy;</span><br><span class="line">bool intersect(int u, int v) &#123;</span><br><span class="line">return sqrt(pow(enemy[u].x - enemy[v].x, 2) + pow(enemy[u].y - enemy[v].y, 2)) &lt; enemy[u].r + enemy[v].r;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line">void check_circle(int u) &#123;</span><br><span class="line">if (enemy[u].x - enemy[u].r &lt; 0)</span><br><span class="line">	le &#x3D; min(le, enemy[u].y - sqrt(enemy[u].r * enemy[u].r - enemy[u].x * enemy[u].x));</span><br><span class="line">if (enemy[u].x + enemy[u].r &gt; 1000)</span><br><span class="line">	ri &#x3D; min(ri, enemy[u].y - sqrt(enemy[u].r * enemy[u].r - (1000 - enemy[u].x) *(1000 - enemy[u].x)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool bfs(int i) &#123;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(i);</span><br><span class="line">while (!q.empty()) &#123;</span><br><span class="line">	int u &#x3D; q.front(); q.pop();</span><br><span class="line">	if (enemy[u].y - enemy[u].r &lt;&#x3D; 0) &#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	vis[u] &#x3D; 1;</span><br><span class="line">	check_circle(u);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (!vis[i] &amp;&amp; intersect(i, u))</span><br><span class="line">			q.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">while (cin &gt;&gt; n) &#123;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	enemy.clear();</span><br><span class="line">	le &#x3D; ri &#x3D; 1000;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		int x, y, r;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; r;</span><br><span class="line">		enemy.push_back(Node(x, y, r));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool flag &#x3D; true;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">		if (enemy[i].y + enemy[i].r &gt;&#x3D; 1000)</span><br><span class="line">			flag &#x3D; bfs(i);</span><br><span class="line"></span><br><span class="line">	if (!flag) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;IMPOSSIBLE&quot; &lt;&lt; endl;</span><br><span class="line">		continue;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;0.00 %.2f 1000.00 %.2f\n&quot;,le, ri);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>分数拆分</title>
    <url>/2020/01/24/%E5%88%86%E6%95%B0%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<h1 id="UVA-10976-分数拆分"><a href="#UVA-10976-分数拆分" class="headerlink" title="UVA 10976 分数拆分"></a>UVA 10976 分数拆分</h1><p>输入正整数k，找到所有正整数x&gt;=y,使得1/k=1/x+1/y</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>枚举y，算x。 关键在于找到枚举的上界。</li>
<li>由x&gt;=y,1/x&lt;=1/y,则1/k-1/y=1/x&lt;=1/y，则y&lt;=2k</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 10000;</span><br><span class="line">int cnt, n;</span><br><span class="line">int ans[maxn][2];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int x, y;</span><br><span class="line">	int c;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">	cnt &#x3D; 0;</span><br><span class="line">	for (y &#x3D; n + 1; y &lt;&#x3D; 2 * n; y++) &#123;</span><br><span class="line">		if ((n*y % (y - n)))</span><br><span class="line">			continue;</span><br><span class="line">		x &#x3D; (n*y) &#x2F; (y - n);</span><br><span class="line"></span><br><span class="line">		ans[cnt][0] &#x3D; x;</span><br><span class="line">		ans[cnt][1] &#x3D; y;</span><br><span class="line">		cnt++;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;, cnt);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; cnt; i++)</span><br><span class="line">		printf(&quot;1&#x2F;%d &#x3D; 1&#x2F;%d + 1&#x2F;%d\n&quot;, n, ans[i][0], ans[i][1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>素数环</title>
    <url>/2020/01/24/%E7%B4%A0%E6%95%B0%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="UVA-524-素数环"><a href="#UVA-524-素数环" class="headerlink" title="UVA 524 素数环"></a>UVA 524 素数环</h1><p>输入正整数n，把1，2，3，···，n组成一个环，使得相邻两个整数之和均为素数。输出时从整数1开始逆时针排列。同一个环应恰好输出一次。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>直观的考虑，答案应该是1-n的某种排列，但是16！太大了，如果生成排列再测试会导致超时。</li>
<li>因为前面能构成素数也未必能构成素数环，有点局部最优未必是整体最优的感觉。所以考虑回溯法，在当前位置处枚举没用过的数，判断能否与上一位构成素数。</li>
<li>加速：事先打印出素数表，后面直接判断。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="dfs-每一层都在寻找cur位置处能放的数，别忘了回溯"><a href="#dfs-每一层都在寻找cur位置处能放的数，别忘了回溯" class="headerlink" title="dfs 每一层都在寻找cur位置处能放的数，别忘了回溯"></a>dfs 每一层都在寻找cur位置处能放的数，别忘了回溯</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void dfs(int cur) &#123;</span><br><span class="line">if (cur &#x3D;&#x3D; n &amp;&amp; isp[A[0] + A[n - 1]]) &#123;</span><br><span class="line">	cout &lt;&lt; A[0];</span><br><span class="line">	for (int i &#x3D; 1; i &lt; n; i++) cout &lt;&lt; &quot; &quot; &lt;&lt; A[i];</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">	for (int j &#x3D; 2; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">		if (!vis[j] &amp;&amp; isp[j + A[cur - 1]]) &#123;</span><br><span class="line"></span><br><span class="line">			A[cur] &#x3D; j;</span><br><span class="line">			vis[j] &#x3D; 1;</span><br><span class="line">			dfs(cur + 1);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F;回溯</span><br><span class="line">			vis[j] &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="is-prime-判断i是否是素数，固定的"><a href="#is-prime-判断i是否是素数，固定的" class="headerlink" title="is_prime 判断i是否是素数，固定的"></a>is_prime 判断i是否是素数，固定的</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int is_prime(int a) &#123;</span><br><span class="line">for (int i &#x3D; 2; i &lt; a; i++)</span><br><span class="line">	if (a%i &#x3D;&#x3D; 0) return 0;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int n, vis[1000000];</span><br><span class="line">int A[1000000];</span><br><span class="line">int isp[100000];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int kase &#x3D; 0;</span><br><span class="line">while (cin &gt;&gt; n) &#123;</span><br><span class="line">	if (kase) cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++kase &lt;&lt; &quot;:&quot; &lt;&lt; endl;</span><br><span class="line">	memset(isp, 0, 2 * n * sizeof(int));</span><br><span class="line">	memset(vis, 0, 2 * n * sizeof(int));</span><br><span class="line">	for (int i &#x3D; 2; i &lt;&#x3D; 2 * n; i++)</span><br><span class="line">		isp[i] &#x3D; is_prime(i);</span><br><span class="line">	isp[1] &#x3D; 1;&#x2F;&#x2F;先构造出素数表，以后方便</span><br><span class="line">	A[0] &#x3D; 1;&#x2F;&#x2F;题干要求从1开始逆序输出</span><br><span class="line">	dfs(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>困难的串</title>
    <url>/2020/01/23/%E5%9B%B0%E9%9A%BE%E7%9A%84%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="UVA-129-困难的串"><a href="#UVA-129-困难的串" class="headerlink" title="UVA 129 困难的串"></a>UVA 129 困难的串</h1><p>将一个包含两个相邻的重复子串的子串，称为“容易的串”，其他为“困难的串”。 输入正整数n和l,输出由前l个字符组成的，字典序第k小的困难的串。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>输出完整的串，即这条路要走到头，想到用dfs。枚举每个位置处的字符，并判断当前局面的合法性。</li>
<li>合法性：如果扩展到当前处没有导致重复子串的出现即为合法。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int dfs(int cur) &#123;</span><br><span class="line">if (cnt++ &#x3D;&#x3D; n) &#123;</span><br><span class="line">	int len &#x3D; 1;</span><br><span class="line">	cout &lt;&lt; char(&#39;A&#39; + S[0]);</span><br><span class="line">	for (int i &#x3D; 1; i &lt; cur; i++) &#123;</span><br><span class="line">		if (i&amp;&amp;i % 4 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">			cout &lt;&lt; &quot; &quot;;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; char(&#39;A&#39; + S[i]);</span><br><span class="line">		if (i + 1 &lt; cur) &#123;</span><br><span class="line">			if ((i + 1) % 64 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">				cout &lt;&lt; char(&#39;A&#39; + S[++i]);</span><br><span class="line">				len++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		len++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 0; i &lt; l; i++) &#123;</span><br><span class="line">	S[cur] &#x3D; i;</span><br><span class="line">	int ok &#x3D; 1;</span><br><span class="line">	for (int j &#x3D; 1; j * 2 &lt;&#x3D; cur + 1; j++) &#123;</span><br><span class="line">&gt; 相当于在枚举循环节,关注循环条件</span><br><span class="line">		int equal &#x3D; 1;</span><br><span class="line">		for (int k &#x3D; 0; k &lt; j; k++)</span><br><span class="line">			if (S[cur - k] !&#x3D; S[cur - k - j]) &#123;</span><br><span class="line">				equal &#x3D; 0;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		if (equal) &#123;</span><br><span class="line">&gt; 如果后一半等于前一半，则不合法</span><br><span class="line">			ok &#x3D; 0;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (ok) if (!dfs(cur + 1)) return 0;</span><br><span class="line">&gt; 递归的搜索剩余位置</span><br><span class="line">&#125;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 80;</span><br><span class="line">int cnt, n, l;</span><br><span class="line">int S[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">while (cin &gt;&gt; n &gt;&gt; l &amp;&amp; n&amp;&amp;l) &#123;</span><br><span class="line">	cnt &#x3D; 0;</span><br><span class="line">	memset(S, 0,sizeof(S));</span><br><span class="line">	dfs(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>倒水问题</title>
    <url>/2020/01/23/%E5%80%92%E6%B0%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="UVA-10603-倒水问题"><a href="#UVA-10603-倒水问题" class="headerlink" title="UVA 10603 倒水问题"></a>UVA 10603 倒水问题</h1><p>在装满水的c升被子、空的a升杯子和b升杯子，3个杯子中都没有刻度。要求在不使用其他道具的情况下，在最少的取水量下量出d升水。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>经典的状态空间树搜索问题，采用广度搜索</p>
<ol>
<li>每次选择取水量最小的节点进行扩展</li>
<li>扩展的方法是枚举取水杯子的编号和倒入水的杯子的编号</li>
</ol>
</li>
<li><p>关于存储</p>
<ol>
<li>使用三元组存储三个杯子内的状态</li>
<li>设置dist变量存到该状态的取水量</li>
<li>bfs过程中使用优先级队列，需要重写&lt;</li>
</ol>
</li>
<li><p>由于每次必须倒空一个或者倒满另一个，所以倒水量无需枚举。倒水量用末状态-初状态</p>
</li>
<li><p>访问标志：由于三个杯子总水量一定，所以使用一个二维数组即可标记</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">	int v[3];</span><br><span class="line">	int dist;</span><br><span class="line">	bool operator &lt; (const node &amp;a) const &#123;</span><br><span class="line">		return dist &gt; a.dist;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">node nodes[maxn*maxn];</span><br><span class="line">struct ID &#123;&#x2F;&#x2F;如果需要，可以用于打印路径</span><br><span class="line">	int id;</span><br><span class="line">	ID(int id) :id(id) &#123;&#125;</span><br><span class="line">	bool operator &lt; (const ID &amp;a) const &#123;</span><br><span class="line">		return nodes[id].dist &lt; nodes[a.id].dist;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="solve-广度遍历过程"><a href="#solve-广度遍历过程" class="headerlink" title="solve 广度遍历过程"></a>solve 广度遍历过程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void solve(int a, int b, int c, int d) &#123;</span><br><span class="line">priority_queue&lt;ID&gt; q;</span><br><span class="line">int cap[3];</span><br><span class="line">memset(ans, -1, sizeof(ans));</span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">cap[0] &#x3D; a; cap[1] &#x3D; b; cap[2] &#x3D; c;</span><br><span class="line">node u;</span><br><span class="line">u.dist &#x3D; 0;</span><br><span class="line">u.v[0] &#x3D; 0; u.v[1] &#x3D; 0; u.v[2] &#x3D; c;</span><br><span class="line">vis[0][0] &#x3D; 1;</span><br><span class="line">int index &#x3D; 0;</span><br><span class="line">u.fa &#x3D; -1;</span><br><span class="line">q.push(ID(index));</span><br><span class="line">nodes[index++] &#x3D; u;</span><br><span class="line">while (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">	ID iu &#x3D; q.top(); q.pop();</span><br><span class="line">	u &#x3D; nodes[iu.id];</span><br><span class="line">	update_ans(u);</span><br><span class="line">	if (ans[d] &gt;&#x3D; 0) break;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 3; i++)</span><br><span class="line">		for (int j &#x3D; 0; j &lt; 3; j++)</span><br><span class="line">			if (i !&#x3D; j) &#123;</span><br><span class="line">				if (u.v[i] &gt; 0 &amp;&amp; u.v[j] &lt; cap[j]) &#123;</span><br><span class="line">					int amount &#x3D; min(cap[j], u.v[i] + u.v[j]) - u.v[j];</span><br><span class="line">					node v &#x3D; u;</span><br><span class="line">					v.dist +&#x3D; amount;</span><br><span class="line">					v.v[i] -&#x3D; amount;</span><br><span class="line">					v.v[j] +&#x3D; amount;</span><br><span class="line">					if (!vis[v.v[0]][v.v[1]]) &#123;</span><br><span class="line">						q.push(ID(index));</span><br><span class="line">						v.fa &#x3D; iu.id;</span><br><span class="line">						nodes[index++] &#x3D; v;</span><br><span class="line">						vis[v.v[0]][v.v[1]] &#x3D; 1;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br><span class="line">while (d &gt;&#x3D; 0)</span><br><span class="line">&#123;</span><br><span class="line">	if (ans[d] &gt;&#x3D; 0) &#123;</span><br><span class="line">		printf(&quot;%d %d\n&quot;, ans[d], d);</span><br><span class="line">		while (true) &#123;</span><br><span class="line">			&#x2F;*cout &lt;&lt; u.v[0] &lt;&lt;&quot; &quot;&lt;&lt; u.v[1] &lt;&lt;&quot; &quot;&lt;&lt; u.v[2] &lt;&lt; endl;</span><br><span class="line">			if (u.fa &#x3D;&#x3D; -1) return;*&#x2F;</span><br><span class="line">			u &#x3D; nodes[u.fa];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	d--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="update-更新到达状态u代表的各个杯中水量的最小取水量"><a href="#update-更新到达状态u代表的各个杯中水量的最小取水量" class="headerlink" title="update 更新到达状态u代表的各个杯中水量的最小取水量"></a>update 更新到达状态u代表的各个杯中水量的最小取水量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void update_ans(node u) &#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">		int d &#x3D; u.v[i];</span><br><span class="line">		if (ans[d] &lt; 0 || u.dist &lt; ans[d])</span><br><span class="line">			ans[d] &#x3D; u.dist;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void update_ans(node);</span><br><span class="line">void solve(int, int, int, int);</span><br><span class="line">const int maxn &#x3D; 200 + 5;</span><br><span class="line">int ans[maxn];</span><br><span class="line">int vis[maxn][maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, a, b, c, d;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	while (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">		solve(a, b, c, d);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>流水线调度</title>
    <url>/2020/01/23/%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="UVA-690-流水线调度"><a href="#UVA-690-流水线调度" class="headerlink" title="UVA 690 流水线调度"></a>UVA 690 流水线调度</h1><p>题目大意：有10个任务，5个管道，每个任务需要占用不同时间的管道，给出任务所占用管道的时间，求最短需要多少时间。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>框架是dfs，且存在明显的深度上限10*n。通过枚举每个程序的起始点选择出最优解</p>
</li>
<li><p>如果不使用二进制法，那么循环遍历状态，判断每个段是否正被占用会消耗大量的时间，导致TLE</p>
</li>
<li><p>关于剪枝：</p>
<ol>
<li>即使剩余的程序都按照最好的情况执行也比目前的最优解慢，那么直接剪掉</li>
</ol>
</li>
<li><p>剪枝依然TLE，所以不能从头开始枚举起始点。故进行预处理。循环枚举相邻两个程序起始点间的间隔，判断有无段冲突，若没有，则记录这个间隔。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">c &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; n; i++)&#x2F;&#x2F;枚举两个程序起始点的间隔</span><br><span class="line">	if (judge(w, i)) &#123;</span><br><span class="line">		jump[c++] &#x3D; i;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="judge-判断在状态s下，相邻两个程序起始点间隔为k是否会导致冲突"><a href="#judge-判断在状态s下，相邻两个程序起始点间隔为k是否会导致冲突" class="headerlink" title="judge 判断在状态s下，相邻两个程序起始点间隔为k是否会导致冲突"></a>judge 判断在状态s下，相邻两个程序起始点间隔为k是否会导致冲突</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool judge(const int *s, int k) &#123;&#x2F;&#x2F;判断相邻的两个程序间隔k的时间片时</span><br><span class="line">							&#x2F;&#x2F;是否会冲突</span><br><span class="line">for (int i &#x3D; 0; i &lt; 5; i++)</span><br><span class="line">	if ((s[i] &gt;&gt; k)&amp;w[i]) return false;</span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void dfs(int d, int time, const int *s) &#123;</span><br><span class="line">if (time + (10 - d) *jump[0] &gt;&#x3D; ans) return;</span><br><span class="line">if (d &#x3D;&#x3D; 10) &#123;</span><br><span class="line">	ans &#x3D; min(ans, time);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 0; i &lt; c; i++) &#123;</span><br><span class="line">	if (judge(s, jump[i])) &#123;</span><br><span class="line">		int p[5];</span><br><span class="line">		for (int j &#x3D; 0; j &lt; 5; j++)</span><br><span class="line">			p[j] &#x3D; (s[j] &gt;&gt; jump[i]) ^ w[j];</span><br><span class="line"></span><br><span class="line">&gt; 尝试每一种间隔，如果不冲突，那么更新状态到p，p的二进制形式相当于s的二进制形式中1复制到右一位处 </span><br><span class="line"></span><br><span class="line">		dfs(d + 1, jump[i] + time, p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="init-初始化"><a href="#init-初始化" class="headerlink" title="init 初始化"></a>init 初始化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">ans &#x3D; 10 * n;</span><br><span class="line">memset(w, 0, sizeof(w));</span><br><span class="line">char s[maxn];</span><br><span class="line">for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">	scanf(&quot;%s&quot;, s);</span><br><span class="line">	for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">		if (s[j] &#x3D;&#x3D; &#39;X&#39;) &#123;</span><br><span class="line">			w[i] |&#x3D; (1 &lt;&lt; j);&#x2F;&#x2F;记录初始状态</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">c &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; n; i++)&#x2F;&#x2F;枚举两个程序起始点的间隔</span><br><span class="line">	if (judge(w, i)) &#123;</span><br><span class="line">		jump[c++] &#x3D; i;</span><br><span class="line">	&#125;</span><br><span class="line">dfs(1, n, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int M &#x3D; 100;</span><br><span class="line">const int maxn &#x3D; 20;</span><br><span class="line">int n, c, ans, w[5], jump[M];</span><br><span class="line"></span><br><span class="line">inline bool judge(const int *s, int k);</span><br><span class="line">void dfs(int d, int time, const int *s);</span><br><span class="line">inline void init();</span><br><span class="line">int main() &#123;</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)</span><br><span class="line">&#123;</span><br><span class="line">	init();</span><br><span class="line">	printf(&quot;%d\n&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA核心技术卷一</title>
    <url>/2020/01/22/JAVA%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E4%B8%80/</url>
    <content><![CDATA[<h1 id="第一章-Java程序设计概述"><a href="#第一章-Java程序设计概述" class="headerlink" title="第一章 Java程序设计概述"></a>第一章 Java程序设计概述</h1><h1 id="第二章-Java程序设计环境"><a href="#第二章-Java程序设计环境" class="headerlink" title="第二章 Java程序设计环境"></a>第二章 Java程序设计环境</h1><h2 id="体系结构中立"><a href="#体系结构中立" class="headerlink" title="体系结构中立"></a>体系结构中立</h2><ol>
<li>JAVA编译器生成与特定的计算机体系结构无关的字节码指令来实现体系结构中立。</li>
<li>字节码可以在任何机器上解释执行，而且可以动态翻译成本地机器代码，即<strong>即时编译</strong></li>
</ol>
<h2 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h2><ol>
<li>JAVA中数据类型具有固定的大小，如int永远32位。字符串用标准Unicode存储。</li>
<li>除了与用户界面有关的库，所有其他的JAVA库都能很好的支持平台的独立性。</li>
</ol>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h2 id="动态性"><a href="#动态性" class="headerlink" title="动态性"></a>动态性</h2><ol>
<li>JAVA的库中可以自由的添加新方法和实例变量，而对客户端没有任何影响。</li>
</ol>
<h2 id="applet和Internet"><a href="#applet和Internet" class="headerlink" title="applet和Internet"></a>applet和Internet</h2><ol>
<li>在网页中运行的Java称为applet。要使用applet，需要启用Java 的 Web 浏览器执行字节码，而不<br>需要安装任何软件。由于虚拟机的安全性，也不必担心恶意软件攻击。可以实现动态网页。<h2 id="常见术语解释"><a href="#常见术语解释" class="headerlink" title="常见术语解释"></a>常见术语解释</h2></li>
<li>JDK：编写java程序的程序员使用的软件。</li>
<li>JRE：运行Java程序的用户使用的软件。包含虚拟机而不包含编译器。</li>
<li>SE： 用于桌面或简单服务器应用的Java 平台</li>
<li>EE ：用于复杂服务器应用的 Java 平台</li>
<li>ME：用于手机和 其他小搜设备的 Java 平台。</li>
</ol>
<h2 id="使用命令工具"><a href="#使用命令工具" class="headerlink" title="使用命令工具"></a>使用命令工具</h2><ol>
<li>javac xxx.java//javac是一个java编译器，将java文件编译成class文件</li>
<li>java xxx//java程序启动java虚拟机，虚拟机执行class中的字节码</li>
</ol>
<h1 id="第三章-Java的基本程序设计结构"><a href="#第三章-Java的基本程序设计结构" class="headerlink" title="第三章 Java的基本程序设计结构"></a>第三章 Java的基本程序设计结构</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ol>
<li>可作为一个加载程序逻辑的容器，程序逻辑定义了应用程序的行为。</li>
<li>类名必须是大写字母开头的名词。如果有多个单词，那么每个单词的第一个字母都要大写。源代码的文件名必须与公共类的名字相同。</li>
</ol>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li><p>8种基本类型：4种整型，2种浮点型，1种字符类型，一种布尔型。</p>
</li>
<li><p>整型：</p>
<ol start="4">
<li>BYTE 1B</li>
<li>short 2B</li>
<li>int 4B</li>
<li>long 8B</li>
</ol>
</li>
<li><p>表示</p>
<ol>
<li>长整型有后缀L</li>
<li>十六进制加前缀0x</li>
<li>八进制加前缀0</li>
<li>二进制加前缀0b</li>
<li>JAVA 7开始，允许数字中加下划线。</li>
</ol>
</li>
<li><p>浮点型</p>
<ol>
<li>float 4B 有效位6-7位</li>
<li>double 8B 有效位约15位</li>
</ol>
</li>
<li><p>表示</p>
<ol>
<li>单精度加后缀F</li>
<li>双精度加后缀D</li>
</ol>
</li>
<li><p>特殊常量</p>
<ol>
<li>Double.POSITIVE_INFINITY</li>
<li>Double.NEGATIVE_INFINITY</li>
<li>Double.NaN</li>
<li>注意：所有的非数都认为是不相等的。</li>
<li><strong>注意</strong>：浮点数值不适用于无法受舍入误差的金融计算。如2.0-1.1 = 0.899999999，这是因为二进制系统无法精确的表示1/10.如果不允许有任何舍入误差，则应该使用BigDecimal类</li>
</ol>
</li>
<li><p>char类型</p>
<ol>
<li><p>转义序列会在解析代码之前得到处理</p>
<img src="/JAVA核心卷1_img/1.png">
</li>
<li><p>JAVA解决Unicode-16不够用的问题–&gt;码点：是指与一个编码表中的某个字符对应的代码值。</p>
</li>
</ol>
</li>
<li><p>boolean </p>
<ol>
<li>整型与布尔型间不可转换</li>
</ol>
</li>
<li><p>变量名：以字母开头并由字母或数字构成的序列。 </p>
</li>
<li><p>常量：使用final声明。如果经常希望某个常量可以在一个类中的多个方法中使用，通常使用static final 声明。</p>
</li>
</ol>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ol>
<li><p>对于浮点数运算，为了实现可移植性，JAVA虚拟机最初规范所有中间的计算结果必须进行截断。但是截断会影响速度，所以后来允许对中间的计算结果扩展精度。对于使用strictfp标记的方法必须使用严格的浮点数运算来生成可再生的结果。</p>
</li>
<li><p>整型提升</p>
<img src="/JAVA核心卷1_img/2.png"></li>
<li><p>强制转型</p>
<ol>
<li>浮点型变整型：通过截断小数部分；若要舍入，则使用Math.round()方法</li>
<li>要注意是否超出目标类型的表示范围</li>
<li>布尔型转整型 b?1:0</li>
</ol>
</li>
<li><p>移位操作符：移位运算符的右操作数要完成模 32 的运算（除非左操作数是 long 类型， 在这种情况下需要对右操作數模 64 )。例如， 1 «35 的值等同于 1 «3 或 8。</p>
</li>
<li><p>枚举类型 </p>
 <img src="/JAVA核心卷1_img/3.png">

</li>
</ol>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol>
<li><p>substring(int a,int b) 第二个参数是不想复制的第一个位置，截得的字串长度为b-a。</p>
</li>
<li><p>join方法可以将多个字符串放在一起，用一个定界符隔开。String all = String.join(“ / “, “S”, “M”, “L”, “XL”); // all is the string “S / H / L / XL”</p>
</li>
<li><p>String为不可变字符串，优点是编译器可以让字符串共享(只有字符串常量是共享的)。可以想象将各种字符串放在公共的存储池中，字符串变量指向存储池中相应的位置，如果复制一个字符串变量，原始字符串与复制的字符串共享相同的字符。</p>
</li>
<li><p>JAVA的String类完全不同于字符数组，大致类似于char*指针</p>
</li>
<li><p>equal() <strong>用于判断相等</strong>。</p>
</li>
<li><p>null 不等同于空串</p>
<ol>
<li>空串是长度为0的字符串。</li>
<li>null指的是没有任何对象与该变量关联。如果在一个null值上调用方法，会抛出异常</li>
</ol>
</li>
<li><p>码点与代码单元</p>
<ol>
<li>码点表示一个字符。通过codepoints函数计算。</li>
<li>代码单元表示2个字节。通过length计算</li>
<li>如果想要遍历一个字符串，并且依次查看每一个码点，可以使用intp[] codePoints = str.codePoints().toArray();反之，如果想要将一个码点数组转换为一个字符串，可以使用String str = new String(codePoints,0,codePoints.length);<h3 id="String-API"><a href="#String-API" class="headerlink" title="String API"></a>String API</h3></li>
</ol>
</li>
</ol>
<img src="/JAVA核心卷1_img/4.png">

<img src="/JAVA核心卷1_img/5.png">

<img src="/JAVA核心卷1_img/6.png">

<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><ol>
<li>用于将许多字符串进行连接的情况</li>
<li>可以通过调用append方法修改原串</li>
<li>可以通过toString方法转换为字符串</li>
</ol>
<img src="/JAVA核心卷1_img/7.png">

<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><ol>
<li><p>使用Scanner类对象，定义在java.util包中。由于输入是可见的所以不适用于读取密码</p>
 <img src="/JAVA核心卷1_img/9.png">    
</li>
<li><p>Console类可以读取密码.</p>
 <img src="/JAVA核心卷1_img/8.png">

<p> 使用Console对象每次只能读取一行</p>
 <img src="/JAVA核心卷1_img/10.png">


</li>
</ol>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><ol>
<li><p>沿用了printf方法进行格式化输出</p>
<ol>
<li><p>转义符</p>
<img src="/JAVA核心卷1_img/11.png">

<p>注意可以使用s转换符格式化任何字符串。如果实现了Formattable接口，调用formatTo方法    ；否则，调用toString方法</p>
</li>
<li><p>标志</p>
<img src="/JAVA核心卷1_img/12.png">
</li>
</ol>
</li>
<li><p>文件输入与输出</p>
<ol>
<li>读入 Scanner in = new Scanner(Paths.get(“c:\mydirectory\myfile.txt ”), “UTF-8”);</li>
<li>写出 PrintWriter out = new PrintlulriterC’myfile.txt”, “UTF-8”);</li>
<li>注意 如果使用相对路径，JAVA会根据虚拟机启动路径的相对路径。可以使用System.getProperty(“user.dir”);得到</li>
<li>注意 如果路径不存在则会抛出异常，throw IOException</li>
</ol>
</li>
</ol>
<h2 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h2><ol>
<li><p>switch语句</p>
<ol>
<li>case后的类型可以是char,byte,int，枚举常量，string</li>
</ol>
</li>
<li><p>带标签的break：在外层循环开始处加上标签，比如read_data，然后break read_data</p>
</li>
</ol>
<h2 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h2><p>在java.math包中，包含Biginteger,BigDecimal两个类。</p>
<ol>
<li>使用静态方法valueof将普通的数值转换成大数值。</li>
<li>使用add，subtract,multiply，divide进行加减乘除。</li>
<li>取模mod(),比较compareTo()</li>
</ol>
<img src="/JAVA核心卷1_img/13.png">

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol>
<li>数组长度不要求是常量，初始所有元素为0；boolean型的初始为false；对象数组初始化为null，表示还没存放任何对象</li>
</ol>
<h3 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h3><ol>
<li>语法for (variable : collection) statement。其中collection这一集合表达式必须是一个数组或者是一个实现了Iterator接口的类对象</li>
</ol>
<h3 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h3><ol>
<li>使用Arrays.copyOf(arrayname,arraylength)方法。常用来增加数组的大小。</li>
</ol>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><ol>
<li>使用Array.sort()方法，实现采用快排。</li>
</ol>
<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><img src="/JAVA核心卷1_img/14.png">

<img src="/JAVA核心卷1_img/15.png">


<ol>
<li>打印数组Arrays.toString();Arrays.deepToString();</li>
</ol>
<h3 id="不规则数组"><a href="#不规则数组" class="headerlink" title="不规则数组"></a>不规则数组</h3><ol>
<li>JAVA中的高维数组其实是数组的数组</li>
<li>创建不规则数组：假设建一个下三角数组</li>
</ol>
<p><code>i n t[][] odds = new int[NMAX + 1] [] ;</code></p>
<p><code>for (int n = 0; n &lt;= NMAX ; n++)</code></p>
<p><code>odds [n] = new int[n + 1];</code></p>
<h1 id="第四章-对象和类"><a href="#第四章-对象和类" class="headerlink" title="第四章 对象和类"></a>第四章 对象和类</h1><h2 id="面向对象程序设计概述"><a href="#面向对象程序设计概述" class="headerlink" title="面向对象程序设计概述"></a>面向对象程序设计概述</h2><ol>
<li><p>封装（ encapsulation , 有时称为数据隐藏） 是与对象有关的一个重要概念。从形式上看，<br>封装不过是将数据和行为组合在一个包中， 并对对象的使用者隐藏了数据的实现方式。对象<br>中的数据称为实例域（ instance field ), 操纵数据的过程称为方法（ method 。) 对于每个特定的<br>类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前状态（ state )。<br>无论何时，只要向对象发送一个消息，它的状态就有可能发生改变。</p>
</li>
<li><p>对象的三个主要特性</p>
<ol>
<li>对象的行为：操作对象的方法</li>
<li>对象的状态：操作之后对象的响应</li>
<li>对象标识：如何区分具有相同行为和状态的不同对象</li>
</ol>
</li>
<li><p>类之间的关系：可以用UML绘制类图</p>
<ol>
<li><p>依赖</p>
</li>
<li><p>聚合</p>
</li>
<li><p>继承</p>
<img src="/JAVA核心卷1_img/16.png">

</li>
</ol>
</li>
</ol>
<h2 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h2><ol>
<li><p><strong>所有的Java对象都存储在堆中</strong>，当一个对象包含另一个对象变量时，这个变量依然包含指向另一个堆对象的指针。</p>
</li>
<li><p>时间类</p>
<ol>
<li><p>Date类</p>
</li>
<li><p>LocalDate类：用LocalDate.now()来创建对象；或者指定时间的对象，用LocalDate.of(1999,8,3);</p>
</li>
<li><p>可以使用getYear,getMonthValue,getDayOfMonth获取年月日。</p>
</li>
<li><p>使用plusDays(int x)得到距离当前对象x天的新日期</p>
<img src="/JAVA核心卷1_img/17.png">

<img src="/JAVA核心卷1_img/18.png">

</li>
</ol>
</li>
</ol>
<h2 id="用户自定义类"><a href="#用户自定义类" class="headerlink" title="用户自定义类"></a>用户自定义类</h2><ol>
<li><p>在一个源文件中，只能有一个公有类，但可以有若干非公有类。源文件名必须与public类的名字相匹配。编译时，公有类和非公有类都生成class文件。</p>
</li>
<li><p>隐式参数：调用方法的对象，可以用this指代;显式参数：方法的参数列表中的参数。</p>
</li>
<li><p><strong>警告</strong>：注意不要编写返回引用可变对象的访问器方法，否则会破坏封装性。</p>
 <img src="/JAVA核心卷1_img/19.png">

<p> 如果一定要返回一个可变对象的引用，可以返回对他的克隆。对象克隆是指存放在另一个位置上的对象副本。</p>
</li>
<li><p>如果类中包含final域，那么在构造器中必须设置该项的值。</p>
<ol>
<li><strong>注意</strong> 如果用final修饰引用，那么仅仅表示该引用不能指向别的对象，但是对象本身是可以更改的。</li>
</ol>
</li>
</ol>
<h3 id="静态域和静态方法"><a href="#静态域和静态方法" class="headerlink" title="静态域和静态方法"></a>静态域和静态方法</h3><ol>
<li>静态域，每个类中只有一个这样的域。即使没有对象，静态域也存在。</li>
<li>静态变量：如out，不能将其他打印流赋给他。</li>
<li>静态方法：不能向对象实时操作的方法。因此，静态方法不能操作对象，但是静态方法可以访问类中的静态域，因为他不属于对象而属于类。</li>
</ol>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>有些时候使用构造器不能实现目的，所以引入工厂函数。例如对于NumberFormat类</p>
<ol>
<li>无法命名构造器。构造器的名字必须与类名相同。但是， 这里希望将得到的货币实例<br>和百分比实例采用不用的名字。</li>
<li>当使用构造器时，无法改变所构造的对象类型。而 Factory 方法将返回一个 DecimalFormat<br>类对象，这是NumberFormat 的子类</li>
</ol>
<h3 id="main-方法"><a href="#main-方法" class="headerlink" title="main 方法"></a>main 方法</h3><ol>
<li><strong>每个类</strong>都可以有一个main方法</li>
</ol>
<h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><ol>
<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）</li>
<li>一个方法可以改变一个对象参数的状态。 </li>
<li>一个方法不能让对象参数引用一个新的对象。</li>
</ol>
<h2 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h2><ol>
<li>如果没有显式的写出一个无参构造器，那么系统会默认将实例域中的数值型数据设置为0，布尔型设置为false，对象变量置为null</li>
</ol>
<h3 id="显式域初始化"><a href="#显式域初始化" class="headerlink" title="显式域初始化"></a>显式域初始化</h3><ol>
<li><p>可以在类定义时，直接将一个值赋给任何域</p>
</li>
<li><p>构造器内部可以调用另一个构造器，使用this</p>
 <img src="/JAVA核心卷1_img/20.png">

</li>
</ol>
<h3 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h3><ol>
<li>在一个类声明中，可以包含多个代码块，只要构造类的对象，这些块就会被执行。首先运行初始化块，然后才运行构造函数的主体部分。</li>
</ol>
<h3 id="构造器具体处理步骤"><a href="#构造器具体处理步骤" class="headerlink" title="构造器具体处理步骤"></a>构造器具体处理步骤</h3><ol>
<li>所有数据域被初始化为默认值（0、false 或 null。)</li>
<li>按照在类声明中出现的次序， 依次执行所有域初始化语句和初始化块。</li>
<li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体</li>
<li>执行这个构造器的主体.</li>
</ol>
<h3 id="静态初始化块"><a href="#静态初始化块" class="headerlink" title="静态初始化块"></a>静态初始化块</h3><ol>
<li>如果对类的静态域进行初始化的代码比较复杂，那么可以使用静态的初始化块。</li>
<li>所有的静态初始化语句以及静态初始<br>化块都将依照类定义的顺序执行。</li>
</ol>
<h3 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h3><ol>
<li>用于人工回收除内存外的其他资源，比如文件或者使用了系统资源的另一个对象的句柄。</li>
<li>实际中不要依赖finalize方法回收短缺资源，因为不能确定该方法何时被调用。</li>
</ol>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ol>
<li>用于组织类，确保类名的唯一性。</li>
<li>JAVA包应该具有一定的层次结构。所有的标准Java包都处于java和javax包层次中</li>
<li>一个类可以使用所属包中的所有类，以及其他包中的公有类；</li>
</ol>
<h3 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h3><ol>
<li>可以使用import语句导入类，静态方法和静态域。</li>
<li>如import static java.lang.System.*;后可直接调用out.println();</li>
<li>如import import static java.lang.Math.*;后可直接sqrt();</li>
</ol>
<h3 id="包作用域"><a href="#包作用域" class="headerlink" title="包作用域"></a>包作用域</h3><ol>
<li><p>如果没有public或者private修饰，那么这个部分可以被同一个包中所有方法访问。一般来说变量都要指明作用域。</p>
</li>
<li><p>可以通过包密封机制来解决各种包混杂在一起的问题</p>
<h2 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h2></li>
<li><p>类文件也可以储存在JAR文件中。在一个JAR文件中，可以包含多个压缩形式的类文件和子目录。</p>
</li>
<li><p>设置类路径：java -classpath 绝对路径</p>
</li>
</ol>
<h2 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h2><ol>
<li>使用/<em>*开头，以</em>/结束。</li>
<li>使用Javadoc自动抽取注释形成文档。</li>
</ol>
<h3 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h3><p>在import语句之后，在类定义之前。</p>
<h3 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h3><ol>
<li>@parma变量描述</li>
<li>@return描述</li>
<li>@throws描述</li>
</ol>
<h3 id="域注释"><a href="#域注释" class="headerlink" title="域注释"></a>域注释</h3><p>只需要对公有域建立文档(通常是静态变量)</p>
<h3 id="通用注释"><a href="#通用注释" class="headerlink" title="通用注释"></a>通用注释</h3><ol>
<li>@author 姓名</li>
<li>@version 文本</li>
<li>@since 文本，对引入特性的版本的描述</li>
<li>@deprecated 文本，不再使用的。</li>
<li>@see 引用，后面跟一个类，方法，或者变量，javadoc后会形成一个超链接。<strong>注意</strong>一定要使用# 分割类名域方法名，或类名与变量名。@see后也可以使用html语法指定任何一个URL</li>
</ol>
<h2 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h2><ol>
<li><p>一定保证数据私有</p>
</li>
<li><p>一定要对数据初始化</p>
</li>
<li><p>不要在类中使用过多的基本类型。</p>
 <img src="/JAVA核心卷1_img/21.png"></li>
<li><p>不是所有的域都需要独立的域访问器和域更改器</p>
</li>
<li><p>将职责过多的类进行分解</p>
</li>
<li><p>类名和方法名能够体现他们的职责</p>
</li>
<li><p>优先使用不可变的类</p>
</li>
</ol>
<h1 id="第五章-继承"><a href="#第五章-继承" class="headerlink" title="第五章 继承"></a>第五章 继承</h1><h2 id="类、超类和子类"><a href="#类、超类和子类" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h2><h3 id="定义子类"><a href="#定义子类" class="headerlink" title="定义子类"></a>定义子类</h3><ol>
<li>extends关键字标识</li>
<li>Java中所有继承都是公有继承</li>
</ol>
<h3 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h3><ol>
<li>注意父类的私有域子类不能直接访问。如果一定要访问，则必须借助于公有接口。</li>
<li>使用super调用父类的同名方法</li>
<li>super &amp; this。super不是一个对象的引用，不能将super赋给另一个对象变量，他只是一个指示编译器调用超类方法的特殊关键字</li>
<li>方法的名字和参数列表称为方法的签名。如果在子类中定义了一个与超类签名相同的方法，那么子类中的这一个方法就覆盖了超类中的这个相同签名的方法。</li>
<li>返回值类型不是签名的一部分，因此，在覆盖方法时，要保证返回类型的兼容性。</li>
</ol>
<h3 id="子类构造器"><a href="#子类构造器" class="headerlink" title="子类构造器"></a>子类构造器</h3><ol>
<li>由于子类不能访问符类的私有域，所以子类构造器需要先通过super调用父类构造器。<strong>如果没有显式调用，则自动调用父类无参构造器</strong> （如果没有，则会报错）</li>
<li><strong>多态</strong> 一个对象变量可以指示多种实际类型的现象称为多态。</li>
<li><strong>动态绑定</strong> 在运行时能够自动的选择调用哪个方法的现象称为动态绑定。调用的方法依赖于隐式参数的实际类型。<ol>
<li>动态绑定下，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。如假设x是D类型，D是C的子类。如果D类定义了f方法，则直接调用，否则在D的父类中找f方法。</li>
<li>实现动态绑定时，为了加快速度，会维护一张方法表。</li>
<li>动态绑定有一个非常重要的特性： 无需对现存的代码进行修改，就可以对程序进行扩展。假设增加一个新类 Executive, 并且变量 e 有可能引用这个类的对象， 我们不需要对包含调用<br>e.getSalary() 的代码进行重新编译。如果 e 恰好引用一个 Executive 类的对象，就会自动地调<br>用 Executive.getSalaryO 方法</li>
</ol>
</li>
<li><strong>静态绑定</strong> 如果是private方法，static方法，final方法或者构造器，那么编译器可以准确的知道应该调用哪个方法，这种调用方式称为静态绑定。</li>
<li>父类引用也可以指向子类对象。调用实际指向对象的函数</li>
</ol>
<h3 id="阻止继承：final类和方法"><a href="#阻止继承：final类和方法" class="headerlink" title="阻止继承：final类和方法"></a>阻止继承：final类和方法</h3><ol>
<li>final类不可被继承</li>
<li>final方法不可被覆盖。final类中方法都是final方法</li>
<li>final域不可改变值final类中的域<strong>不是</strong>final域</li>
</ol>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ol>
<li>目的：暂时忽视对象的实际类型之后，使用对象的全部功能。</li>
<li>将一个超类的引用赋给一个子类变量时，必须进行类型转换。</li>
<li><strong>注意</strong> 好的习惯是在进行类型转换之前，先查看一下是否能够成功的转换。使用instanceof操作就可以实现。(如果x.instanceof，而x是null，则会返回false)<ol>
<li>否则可能抛出ClassCastException异常</li>
</ol>
</li>
</ol>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ol>
<li>使用abstract 关键字</li>
<li>包含一个或多个抽象方法的类本身必须被声明为抽象的。</li>
<li>抽象类不能被实例化，但是可以定义抽象类的变量来引用非抽象类的对象。</li>
<li>扩展抽象类的两种方法<ol>
<li>一种是在抽象类中定义部分抽象类方法或不定义抽象类方法，这样就必须将子类也标记为抽象类；</li>
<li>另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。</li>
</ol>
</li>
</ol>
<h3 id="受保护的访问"><a href="#受保护的访问" class="headerlink" title="受保护的访问"></a>受保护的访问</h3><ol>
<li>任何声明为private的内容对其他的类都是不可见的。</li>
<li><strong>protected</strong> 修饰只允许子类访问的内容</li>
</ol>
<h2 id="Object-所有类的超类"><a href="#Object-所有类的超类" class="headerlink" title="Object 所有类的超类"></a>Object 所有类的超类</h2><h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><ol>
<li><p>特殊情况</p>
<ol>
<li>如果一个为null，则返回false</li>
<li>如果都为null，则返回true</li>
</ol>
</li>
<li><p>子类中定义equals方法时，首先调用超类的equals，如果检测失败，则对象不可能相等</p>
</li>
<li><p>重写equal方法的正确姿势</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public boolean equals(Object otherObject) &#123;</span><br><span class="line">	if(this&#x3D;&#x3D;otherObject) return true;</span><br><span class="line">	if (getClass() !&#x3D; otherObject.getClass()) return false;</span><br><span class="line">	if (!(otherObject instanceof ClassName)) return false;</span><br><span class="line">	ClassName other &#x3D; (ClassName) otherObject</span><br><span class="line">			</span><br><span class="line">	return fieldl &#x3D;&#x3D; other.field</span><br><span class="line">			&amp;&amp; Objects.equa1s(fie1d2, other.field2)</span><br><span class="line">			&amp;&amp; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode 方法"></a>hashCode 方法</h3><p><img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/22.png" alt=""></p>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString 方法"></a>toString 方法</h3><ol>
<li>通用的写法<br><img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/23.png" alt=""></li>
<li>子类的写法<br><img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/24.png" alt=""></li>
<li>只要对象与一个字符串通过操作符“+”连接起来，Java编译就会自动的调用toString方法</li>
<li><strong>注意</strong> 数组可以使用Arrays.toString(数组名)来打印一维数组；使用Arrays.deepToString方法打印多维数组。</li>
</ol>
<h3 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h3><ol>
<li><p>Employee类<br><img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/25.png" alt=""></p>
</li>
<li><p>Manager类<br><img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/26.png" alt=""></p>
</li>
<li><p>相关函数<br><img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/27.png" alt=""></p>
</li>
</ol>
<h2 id="泛型数组列表"><a href="#泛型数组列表" class="headerlink" title="泛型数组列表"></a>泛型数组列表</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ol>
<li><p>可以动态的改变数组的大小，如果在填充之前就可以确定数组的大小</p>
<ol>
<li>可以使用ensureCapacity方法。</li>
<li><code>ArrayList&lt;Employee&gt; staff = new ArrayListo(lOO);</code></li>
</ol>
</li>
<li><p>声明和构造</p>
<p> <code>ArrayList&lt;Employee&gt; staff = new ArrayListoQ；</code></p>
</li>
<li><p>添加元素 add</p>
<p> <code>staff.add(new Employee(&quot;Harry Hacker&quot;,···));</code></p>
</li>
<li><p><strong>注意</strong> 预先确定容量的数组列表与数组也不同。</p>
<ol>
<li>对于数组，如果分配了100个空间，数组就有100个空位置可以使用。</li>
<li>对于数组列表，容量为100的数组列表只是拥有保存100个元素的潜力。但是在初始化后，数组列表中不包含任何元素。</li>
</ol>
</li>
<li><p>size方法，返回实际元素数目.<strong>一旦数组列表的不再变化，就可以调用trimToSize</strong>将存储区域大小调整为当前元素数量所需要的存储空间数目，之后垃圾回收机制自动回收多余空间。</p>
</li>
</ol>
<p><img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/28.png" alt=""></p>
<h3 id="访问数组列表元素"><a href="#访问数组列表元素" class="headerlink" title="访问数组列表元素"></a>访问数组列表元素</h3><ol>
<li><p>set(i,x) 设置第i个元素(从1开始)</p>
</li>
<li><p>get(i) 获得第i个元素。</p>
</li>
<li><p>技巧：</p>
<p> ``</p>
<pre><code>ArrayList&lt;X&gt; list = new ArrayListoQ;
while (. . .) { 
x = . .
list.add(x); 
}
X[] a = new XPtst.sizeO];
list.toArray(a);</code></pre><p> ``</p>
</li>
<li><p>remove(i) 删除第i个元素</p>
</li>
<li><p>for each</p>
<p> ``</p>
<pre><code>for (Employee e : staff)
    dosomethingwith e</code></pre><p> ``</p>
</li>
</ol>
<h3 id="类型化与原始数组列表的兼容性"><a href="#类型化与原始数组列表的兼容性" class="headerlink" title="类型化与原始数组列表的兼容性"></a>类型化与原始数组列表的兼容性</h3><ol>
<li>将类型化数组列表传给没有类型的参数不会报错，反之不然。(<strong>有警告时可尝试使用强制类型转换</strong>)</li>
<li><strong>注意</strong> 鉴于兼容性的考虑， 编译<br>器在对类型转换进行检査之后， 如果没有发现违反规则的现象，就将所有的类型化数组列表<br>转换成原始 ArrayList 对象。 在程序运行时，所有的数组列表都是一样的，即没有虚拟机中<br>的类型参数。 因此， 类型转换（ ArrayList) 和 ( ArrayList<Employee> ) 将执行相同的运行时<br>检查。</li>
<li>如果能够确定这个警告问题不大，可以用@SuppressWamings(“unchecked”) 标注来标记。</li>
</ol>
<h2 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h2><h3 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h3><ol>
<li><p>包装类是final，即一旦构造了包装器，就不允许更改包装在其中的值。同时也不可被继承。</p>
</li>
<li><p><strong>自动装箱</strong> 有需要时，基本类型自动转成相应的包装类。相应的，也存在自动拆箱。</p>
<ol>
<li>自动装箱规范要求 boolean、byte、char 127， 介于 -128 ~ 127 之间的 short 和int 被包装到固定的对象中。</li>
<li>由于包装器类引用可以为 null, 所以自动装箱有可能会抛出一个NullPointerException 异常</li>
</ol>
</li>
<li><p>如果一个表达式中混合使用了Integer和Double，那么Integer会先拆箱，再提升为double，再装箱为Double</p>
</li>
<li><p>这些过程时编译器做的，虚拟机只是执行这些字节码</p>
</li>
</ol>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ol>
<li><strong>注意</strong> Integer对象是不可变的：包含在包装器中的内容不会改变。不能使用这些包装器类创建修改数值参数的方法</li>
<li>Integer.parseInt(s) 将一个字符串转成整型</li>
</ol>
<p><img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/29.png" alt=""></p>
<p><img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/30.png" alt=""></p>
<h2 id="参数数量可变的方法"><a href="#参数数量可变的方法" class="headerlink" title="参数数量可变的方法"></a>参数数量可变的方法</h2><h3 id="printf-函数"><a href="#printf-函数" class="headerlink" title="printf 函数"></a>printf 函数</h3><p>``</p>
<pre><code>public PrintStream printf(String fmt , Object... args) { return format(fmt, args); }</code></pre><p>``</p>
<ol>
<li><p>…是Java代码的一部分，Object… 相当于 Object[]</p>
</li>
<li><p>编译器需要对 printf 的每次调用进行转换， 以便将参数绑定到数组上，并在必要的时候<br>进行自动装箱：</p>
<p> ``</p>
<pre><code>System.out.printf(&quot;M Xs&quot;, new ObjectO { new Integer(n), &quot;widgets&quot; } );</code></pre><p> ``</p>
<h3 id="自定义多参数函数"><a href="#自定义多参数函数" class="headerlink" title="自定义多参数函数"></a>自定义多参数函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public static double max (double... values) &#123;</span><br><span class="line">double largest &#x3D; Double.NECATIVEJNFINITY;</span><br><span class="line">for (double v : values) </span><br><span class="line">	if (v &gt; largest) largest &#x3D; v;</span><br><span class="line">return largest; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>允许将一个数组传递给可变参数方法的最后一个参数。</p>
</li>
</ol>
<p>``</p>
<pre><code>public static void main(String... args)</code></pre><p>``</p>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><ol>
<li><p>使用enum修饰</p>
<p> ``</p>
<pre><code>public enuni Size { SMALL , MEDIUM, LARGE, EXTRAJARGE };</code></pre><p> ``</p>
<ol>
<li>定义了一个类，它有4个实例</li>
</ol>
</li>
<li><p>比较两个枚举类型时，直接 == 即可</p>
</li>
<li><p>所有的枚举类型都是enum类的子类，它们继承了这个类的许多方法。</p>
</li>
<li><p>toString方法可以返回枚举常量名</p>
</li>
<li><p>valueOf方法时toString方法的逆方法</p>
</li>
<li><p>每个枚举类型都有一个静态的values方法， 它将返回一个包含全部枚举值的数组。</p>
</li>
</ol>
<p>``</p>
<pre><code>Size[] values = Size.values();</code></pre><p>``</p>
<ol start="7">
<li>ordinal 方法 返回enum声明中枚举常量的位置，位置从0开始计数。</li>
</ol>
<p><img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/31.png" alt=""></p>
<h3 id="枚举类举例"><a href="#枚举类举例" class="headerlink" title="枚举类举例"></a>枚举类举例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	public enum Day2 &#123;</span><br><span class="line">    MONDAY(&quot;星期一&quot;),</span><br><span class="line">    TUESDAY(&quot;星期二&quot;),</span><br><span class="line">    WEDNESDAY(&quot;星期三&quot;),</span><br><span class="line">    THURSDAY(&quot;星期四&quot;),</span><br><span class="line">    FRIDAY(&quot;星期五&quot;),</span><br><span class="line">    SATURDAY(&quot;星期六&quot;),</span><br><span class="line">    SUNDAY(&quot;星期日&quot;);&#x2F;&#x2F;记住要用分号结束</span><br><span class="line"></span><br><span class="line">    private String desc;&#x2F;&#x2F;中文描述</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 私有构造,防止被外部调用</span><br><span class="line">     * @param desc</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private Day2(String desc)&#123;</span><br><span class="line">        this.desc&#x3D;desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义方法,返回描述,跟常规类的定义没区别</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public String getDesc()&#123;</span><br><span class="line">        return desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        for (Day2 day:Day2.values()) &#123;</span><br><span class="line">            System.out.println(&quot;name:&quot;+day.name()+</span><br><span class="line">                    &quot;,desc:&quot;+day.getDesc());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     输出结果:</span><br><span class="line">     name:MONDAY,desc:星期一</span><br><span class="line">     name:TUESDAY,desc:星期二</span><br><span class="line">     name:WEDNESDAY,desc:星期三</span><br><span class="line">     name:THURSDAY,desc:星期四</span><br><span class="line">     name:FRIDAY,desc:星期五</span><br><span class="line">     name:SATURDAY,desc:星期六</span><br><span class="line">     name:SUNDAY,desc:星期日</span><br><span class="line">     *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><ol>
<li>反射库：提供了一个非常丰富且精心设计的工具集， 以便编写能够动<br>态操纵 Java 代码的程序。大量地应用于 JavaBeans 中， 它是 Java组件的体系结构。</li>
<li>反射：能够分析类能力的程序称为反射。可以用于<ol>
<li>在运行时分析类的能力</li>
<li>在运行时查看对象</li>
<li>实现通用的数组操作代码</li>
<li>利用Method对象，这个对象很像C++中的函数指针</li>
</ol>
</li>
</ol>
<h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><ol>
<li><p>一个Class对象标识一个特定类的属性。</p>
<ol>
<li>使用getClass()返回一个Class类型的实例</li>
<li>使用getName()返回类的名字</li>
</ol>
</li>
<li><p>newInstance()方法，可以用来动态的创建一个类的实例。</p>
<p> ``</p>
<pre><code>e.getClass.newInstance();</code></pre><p> ``</p>
<ol>
<li>newlnstance方法调用默认的构造器（没有参数的构<br>造器）初始化新创建的对象。如果这个类没有默认的构造器， 就会抛出一个异常。</li>
</ol>
</li>
<li><p><strong>技巧</strong> 将 forName 与 newlnstance 配合起来使用， 可以根据存储在字符串中的类名创建一个对象</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">String s &#x3D; &quot;java.util .Random&quot;;</span><br><span class="line">Object m &#x3D; Cl ass.forName (s) .newlnstance();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><ol>
<li><p>分为未检查异常和已检查异常。</p>
<ol>
<li>对于已检查异常， 编译器将会检查是否提<br>供了处理器。</li>
<li>对于未检查异常，编译<br>器不会査看是否为这些错误提供了处理器。毕竟，应该精心地编写代码来避免这些错误的发<br>生， 而不要将精力花在编写异常处理器上。</li>
</ol>
</li>
<li><p>常用方法</p>
</li>
</ol>
<p><img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/32.png" alt=""></p>
<h3 id="利用反射分析类的能力"><a href="#利用反射分析类的能力" class="headerlink" title="利用反射分析类的能力"></a>利用反射分析类的能力</h3><ol>
<li><p>java.lang.reflect 包中有三个类 Field、 Method 和 Constructor分别用于描述类的域、 方<br>法和构造器。</p>
<ol>
<li>Held 类有一<br>个 getType 方法， 用来返回描述域所属类型的 Class 对象。</li>
<li>Method 和 Constructor 类有能够<br>报告参数类型的方法，Method 类还有一个可以报告返回类型的方法。</li>
<li>这三个类还有一个叫<br>做 getModifiers 的方法， 它将返回一个整型数值，用不同的位开关描述 public 和 static 这样<br>的修饰符使用状况。</li>
<li>可以利用java.lang.refleCt 包中的 Modifiei•类的静态方法分析<br>getModifiers 返回的整型数值。例如， 可以使用 Modifier 类中的 isPublic、 isPrivate 或 isFinal<br>判断方法或构造器是否是 public、 private 或 final。</li>
</ol>
</li>
<li><p>Class类中的 </p>
<ol>
<li>getFields、 getMethods 和 getConstructors 方 法 将 分 别 返 回 类 提 供 的<br>public 域、 方法和构造器数组， 其中包括超类的公有成员。</li>
<li>getDeclareFields、<br>getDeclareMethods 和 getDeclaredConstructors 方法将分别返回类中声明的全部域、 方法和构<br>造器， 其中包括私有和受保护成员，但不包括超类的成员。</li>
</ol>
</li>
<li><p>访问示例</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">package reflection;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * This program uses reflection to print all features of a class.</span><br><span class="line"> * @version 1.1 2004-02-21</span><br><span class="line"> * @author Cay Horstmann</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ReflectionTest</span><br><span class="line">&#123;</span><br><span class="line">   public static void main(String[] args)</span><br><span class="line">   &#123;</span><br><span class="line">      &#x2F;&#x2F; read class name from command line args or user input</span><br><span class="line">      String name;</span><br><span class="line">      if (args.length &gt; 0) name &#x3D; args[0];</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">         Scanner in &#x3D; new Scanner(System.in);</span><br><span class="line">         System.out.println(&quot;Enter class name (e.g. java.util.Date): &quot;);</span><br><span class="line">         name &#x3D; in.next();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      try</span><br><span class="line">      &#123;</span><br><span class="line">         &#x2F;&#x2F; print class name and superclass name (if !&#x3D; Object)</span><br><span class="line">         Class cl &#x3D; Class.forName(name);</span><br><span class="line">         Class supercl &#x3D; cl.getSuperclass();</span><br><span class="line">         String modifiers &#x3D; Modifier.toString(cl.getModifiers());</span><br><span class="line">         if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;);</span><br><span class="line">         System.out.print(&quot;class &quot; + name);</span><br><span class="line">         if (supercl !&#x3D; null &amp;&amp; supercl !&#x3D; Object.class) System.out.print(&quot; extends &quot;</span><br><span class="line">               + supercl.getName());</span><br><span class="line"></span><br><span class="line">         System.out.print(&quot;\n&#123;\n&quot;);</span><br><span class="line">         printConstructors(cl);</span><br><span class="line">         System.out.println();</span><br><span class="line">         printMethods(cl);</span><br><span class="line">         System.out.println();</span><br><span class="line">         printFields(cl);</span><br><span class="line">         System.out.println(&quot;&#125;&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      catch (ClassNotFoundException e)</span><br><span class="line">      &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      System.exit(0);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Prints all constructors of a class</span><br><span class="line">    * @param cl a class</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public static void printConstructors(Class cl)</span><br><span class="line">   &#123;</span><br><span class="line">      Constructor[] constructors &#x3D; cl.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line">      for (Constructor c : constructors)</span><br><span class="line">      &#123;</span><br><span class="line">         String name &#x3D; c.getName();</span><br><span class="line">         System.out.print(&quot;   &quot;);</span><br><span class="line">         String modifiers &#x3D; Modifier.toString(c.getModifiers());</span><br><span class="line">         if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;);         </span><br><span class="line">         System.out.print(name + &quot;(&quot;);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; print parameter types</span><br><span class="line">         Class[] paramTypes &#x3D; c.getParameterTypes();</span><br><span class="line">         for (int j &#x3D; 0; j &lt; paramTypes.length; j++)</span><br><span class="line">         &#123;</span><br><span class="line">            if (j &gt; 0) System.out.print(&quot;, &quot;);</span><br><span class="line">            System.out.print(paramTypes[j].getName());</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(&quot;);&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Prints all methods of a class</span><br><span class="line">    * @param cl a class</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public static void printMethods(Class cl)</span><br><span class="line">   &#123;</span><br><span class="line">      Method[] methods &#x3D; cl.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">      for (Method m : methods)</span><br><span class="line">      &#123;</span><br><span class="line">         Class retType &#x3D; m.getReturnType();</span><br><span class="line">         String name &#x3D; m.getName();</span><br><span class="line"></span><br><span class="line">         System.out.print(&quot;   &quot;);</span><br><span class="line">         &#x2F;&#x2F; print modifiers, return type and method name</span><br><span class="line">         String modifiers &#x3D; Modifier.toString(m.getModifiers());</span><br><span class="line">         if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;);         </span><br><span class="line">         System.out.print(retType.getName() + &quot; &quot; + name + &quot;(&quot;);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; print parameter types</span><br><span class="line">         Class[] paramTypes &#x3D; m.getParameterTypes();</span><br><span class="line">         for (int j &#x3D; 0; j &lt; paramTypes.length; j++)</span><br><span class="line">         &#123;</span><br><span class="line">            if (j &gt; 0) System.out.print(&quot;, &quot;);</span><br><span class="line">            System.out.print(paramTypes[j].getName());</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println(&quot;);&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Prints all fields of a class</span><br><span class="line">    * @param cl a class</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public static void printFields(Class cl)</span><br><span class="line">   &#123;</span><br><span class="line">      Field[] fields &#x3D; cl.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">      for (Field f : fields)</span><br><span class="line">      &#123;</span><br><span class="line">         Class type &#x3D; f.getType();</span><br><span class="line">         String name &#x3D; f.getName();</span><br><span class="line">         System.out.print(&quot;   &quot;);</span><br><span class="line">         String modifiers &#x3D; Modifier.toString(f.getModifiers());</span><br><span class="line">         if (modifiers.length() &gt; 0) System.out.print(modifiers + &quot; &quot;);         </span><br><span class="line">         System.out.println(type.getName() + &quot; &quot; + name + &quot;;&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>获得对应的Class对象</li>
<li>通过Class对象调用getDeclaredFields</li>
</ol>
</li>
<li><p>常用函数</p>
<p> <img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/33.png" alt=""></p>
<p> <img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/34.png" alt=""></p>
<p> <img src="/JAVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/35.png" alt=""></p>
</li>
</ol>
<h3 id="运行时使用反射分析对象"><a href="#运行时使用反射分析对象" class="headerlink" title="运行时使用反射分析对象"></a>运行时使用反射分析对象</h3><ol>
<li><p>获取某个域当前内容的步骤</p>
<ol>
<li><p>获得Class对象</p>
</li>
<li><p>用Class对象得到Field对象</p>
</li>
<li><p>用get获得域的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Employee harry &#x3D; new Employee(&quot;Harry Hacker&quot;, 35000, 10, 1, 1989);</span><br><span class="line">Class cl &#x3D; harry.getClass0； &#x2F;&#x2F; the class object representing Employee</span><br><span class="line">Field f &#x3D; cl .getDeclaredFieldC&#39;name&quot;): &#x2F;&#x2F; the name field of the Employee class</span><br><span class="line">Object v &#x3D; f.get(harry); &#x2F;&#x2F; the value of the name field of the harry object , i .e., the String object &quot;Harry Hacker&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>涉及三种异常NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException。</p>
</li>
<li><p>只有利用 get 方法才能得到可访问域的值。除非拥有访问权限，否则<br>Java 安全机制只允许査看任意对象有哪些域， 而不允许读取它们的值。</p>
</li>
<li><p>可使用Field、 Method 或<br>Constructor 对象的 setAccessible 方法来覆盖访问控制。setAccessible 方法是 AccessibleObject 类中的一个方法， 它是 Field、 Method 和 Constructor<br>类的公共超类。</p>
</li>
<li><p>可以通过f.set(obj，value) 可以将 obj 对象的 f 域设置成新值。</p>
</li>
<li><p>常用方法</p>
 <img src="/JAVA核心卷1_img/36.png"></li>
<li><p>toString()通用写法</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">package objectAnalyzer;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.AccessibleObject;</span><br><span class="line">import java.lang.reflect.Array;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.Modifier;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class ObjectAnalyzer</span><br><span class="line">&#123;</span><br><span class="line">   private ArrayList&lt;Object&gt; visited &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Converts an object to a string representation that lists all fields.</span><br><span class="line">    * @param obj an object</span><br><span class="line">    * @return a string with the object&#39;s class name and all field names and</span><br><span class="line">    * values</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public String toString(Object obj)</span><br><span class="line">   &#123;</span><br><span class="line">      if (obj &#x3D;&#x3D; null) return &quot;null&quot;;</span><br><span class="line">      if (visited.contains(obj)) return &quot;...&quot;;</span><br><span class="line">      visited.add(obj);</span><br><span class="line">      Class cl &#x3D; obj.getClass();</span><br><span class="line">      if (cl &#x3D;&#x3D; String.class) return (String) obj;</span><br><span class="line">      if (cl.isArray())</span><br><span class="line">      &#123;</span><br><span class="line">         String r &#x3D; cl.getComponentType() + &quot;[]&#123;&quot;;</span><br><span class="line">         for (int i &#x3D; 0; i &lt; Array.getLength(obj); i++)</span><br><span class="line">         &#123;</span><br><span class="line">            if (i &gt; 0) r +&#x3D; &quot;,&quot;;</span><br><span class="line">            Object val &#x3D; Array.get(obj, i);</span><br><span class="line">            if (cl.getComponentType().isPrimitive()) r +&#x3D; val;</span><br><span class="line">            else r +&#x3D; toString(val);</span><br><span class="line">         &#125;</span><br><span class="line">         return r + &quot;&#125;&quot;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      String r &#x3D; cl.getName();</span><br><span class="line">      &#x2F;&#x2F; inspect the fields of this class and all superclasses</span><br><span class="line">      do</span><br><span class="line">      &#123;</span><br><span class="line">         r +&#x3D; &quot;[&quot;;</span><br><span class="line">         Field[] fields &#x3D; cl.getDeclaredFields();</span><br><span class="line">         AccessibleObject.setAccessible(fields, true);</span><br><span class="line">         &#x2F;&#x2F; get the names and values of all fields</span><br><span class="line">         for (Field f : fields)</span><br><span class="line">         &#123;</span><br><span class="line">            if (!Modifier.isStatic(f.getModifiers()))</span><br><span class="line">            &#123;</span><br><span class="line">               if (!r.endsWith(&quot;[&quot;)) r +&#x3D; &quot;,&quot;;</span><br><span class="line">               r +&#x3D; f.getName() + &quot;&#x3D;&quot;;</span><br><span class="line">               try</span><br><span class="line">               &#123;</span><br><span class="line">                  Class t &#x3D; f.getType();</span><br><span class="line">                  Object val &#x3D; f.get(obj);</span><br><span class="line">                  if (t.isPrimitive()) r +&#x3D; val;</span><br><span class="line">                  else r +&#x3D; toString(val);</span><br><span class="line">               &#125;</span><br><span class="line">               catch (Exception e)</span><br><span class="line">               &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         r +&#x3D; &quot;]&quot;;</span><br><span class="line">         cl &#x3D; cl.getSuperclass();</span><br><span class="line">      &#125;</span><br><span class="line">      while (cl !&#x3D; null);</span><br><span class="line"></span><br><span class="line">      return r;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">package com.corejava.reflection;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">public class ObjectAnalyzerTest &#123;</span><br><span class="line"> </span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; squares &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">		for (int i &#x3D; 1; i &lt; 5; i++)</span><br><span class="line">			squares.add(i * i);</span><br><span class="line">		System.out.println(new ObjectAnalyzer().toString(squares));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="使用反射编写泛型数组代码"><a href="#使用反射编写泛型数组代码" class="headerlink" title="使用反射编写泛型数组代码"></a>使用反射编写泛型数组代码</h3><ol>
<li><p>步骤</p>
<ol>
<li>首先获得a数组的类对象</li>
<li>确认它是一个数组</li>
<li>使用Class类的getComponentType方法确定数组对应的类型</li>
<li>注 数组的长度可以通过Array的getLength获得</li>
</ol>
</li>
<li><p>代码</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">public static Object goodCopyOf(Object a, int newLength) &#123;</span><br><span class="line">Class cl &#x3D; a.getClassO；</span><br><span class="line">if (Icl .isArrayO) return null ;</span><br><span class="line">Class componentType &#x3D; cl .getComponentType0；</span><br><span class="line">int length &#x3D; Array.getLength(a);</span><br><span class="line">Object newArray &#x3D; Array.newlnstance(componentType, newLength):</span><br><span class="line">System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength));</span><br><span class="line">return newArray; &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>注意 参数中a没有定义为Object[]，这是因为像int[]可以被转成Object，但是不能转成对象数组</li>
</ol>
</li>
<li><p>CopyTest</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package arrays;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * This program demonstrates the use of reflection for manipulating arrays.</span><br><span class="line"> * @version 1.2 2012-05-04</span><br><span class="line"> * @author Cay Horstmann</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CopyOfTest</span><br><span class="line">&#123;</span><br><span class="line">   public static void main(String[] args)</span><br><span class="line">   &#123;</span><br><span class="line">      int[] a &#x3D; &#123; 1, 2, 3 &#125;;</span><br><span class="line">      a &#x3D; (int[]) goodCopyOf(a, 10);</span><br><span class="line">      System.out.println(Arrays.toString(a));</span><br><span class="line"></span><br><span class="line">      String[] b &#x3D; &#123; &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot; &#125;;</span><br><span class="line">      b &#x3D; (String[]) goodCopyOf(b, 10);</span><br><span class="line">      System.out.println(Arrays.toString(b));</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;The following call will generate an exception.&quot;);</span><br><span class="line">      b &#x3D; (String[]) badCopyOf(b, 10);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * This method attempts to grow an array by allocating a new array and copying all elements.</span><br><span class="line">    * @param a the array to grow</span><br><span class="line">    * @param newLength the new length</span><br><span class="line">    * @return a larger array that contains all elements of a. However, the returned array has </span><br><span class="line">    * type Object[], not the same type as a</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public static Object[] badCopyOf(Object[] a, int newLength) &#x2F;&#x2F; not useful</span><br><span class="line">   &#123;</span><br><span class="line">      Object[] newArray &#x3D; new Object[newLength];</span><br><span class="line">      System.arraycopy(a, 0, newArray, 0, Math.min(a.length, newLength));</span><br><span class="line">      return newArray;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * This method grows an array by allocating a new array of the same type and</span><br><span class="line">    * copying all elements.</span><br><span class="line">    * @param a the array to grow. This can be an object array or a primitive</span><br><span class="line">    * type array</span><br><span class="line">    * @return a larger array that contains all elements of a.</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public static Object goodCopyOf(Object a, int newLength) </span><br><span class="line">   &#123;</span><br><span class="line">      Class cl &#x3D; a.getClass();</span><br><span class="line">      if (!cl.isArray()) return null;</span><br><span class="line">      Class componentType &#x3D; cl.getComponentType();</span><br><span class="line">      int length &#x3D; Array.getLength(a);</span><br><span class="line">      Object newArray &#x3D; Array.newInstance(componentType, newLength);</span><br><span class="line">      System.arraycopy(a, 0, newArray, 0, Math.min(length, newLength));</span><br><span class="line">      return newArray;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>常用方法</p>
<p> <img src="/AVA%E6%A0%B8%E5%BF%83%E5%8D%B71_img/37.png" alt=""></p>
</li>
</ol>
<h3 id="调用任意方法"><a href="#调用任意方法" class="headerlink" title="调用任意方法"></a>调用任意方法</h3><ol>
<li><p>利用反射实现C++的传递函数参数的功能</p>
</li>
<li><p>使用Method 类中有一个 invoke 方法， 它允许调用包装在当前 Method 对象中<br>的方法。</p>
</li>
<li><p>Object invoke(Object obj, Object… args)</p>
</li>
<li><p>获取Method对象</p>
<ol>
<li>可以通过调用 getDeclareMethods 方法， 然后对返回<br>的 Method 对象数组进行查找， 直到发现想要的方法为止。</li>
<li>也可以通过调用 Class类中的<br>getMethod方法得到想要的方法。但是要注意可能存在很多同名方法，所以还需压迫提供想要的方法的参数类型。</li>
</ol>
</li>
<li><p>通用制表例</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package methods;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * This program shows how to invoke methods through reflection.</span><br><span class="line"> * @version 1.2 2012-05-04</span><br><span class="line"> * @author Cay Horstmann</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MethodTableTest</span><br><span class="line">&#123;</span><br><span class="line">   public static void main(String[] args) throws Exception</span><br><span class="line">   &#123;</span><br><span class="line">      &#x2F;&#x2F; get method pointers to the square and sqrt methods</span><br><span class="line">      Method square &#x3D; MethodTableTest.class.getMethod(&quot;square&quot;, double.class);</span><br><span class="line">      Method sqrt &#x3D; Math.class.getMethod(&quot;sqrt&quot;, double.class);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; print tables of x- and y-values</span><br><span class="line"></span><br><span class="line">      printTable(1, 10, 10, square);</span><br><span class="line">      printTable(1, 10, 10, sqrt);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Returns the square of a number</span><br><span class="line">    * @param x a number</span><br><span class="line">    * @return x squared</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public static double square(double x)</span><br><span class="line">   &#123;</span><br><span class="line">      return x * x;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * Prints a table with x- and y-values for a method</span><br><span class="line">    * @param from the lower bound for the x-values</span><br><span class="line">    * @param to the upper bound for the x-values</span><br><span class="line">    * @param n the number of rows in the table</span><br><span class="line">    * @param f a method with a double parameter and double return value</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public static void printTable(double from, double to, int n, Method f)</span><br><span class="line">   &#123;</span><br><span class="line">      &#x2F;&#x2F; print out the method as table header</span><br><span class="line">      System.out.println(f);</span><br><span class="line"></span><br><span class="line">      double dx &#x3D; (to - from) &#x2F; (n - 1);</span><br><span class="line"></span><br><span class="line">      for (double x &#x3D; from; x &lt;&#x3D; to; x +&#x3D; dx)</span><br><span class="line">      &#123;</span><br><span class="line">         try</span><br><span class="line">         &#123;</span><br><span class="line">            double y &#x3D; (Double) f.invoke(null, x);</span><br><span class="line">            System.out.printf(&quot;%10.4f | %10.4f%n&quot;, x, y);</span><br><span class="line">         &#125;</span><br><span class="line">         catch (Exception e)</span><br><span class="line">         &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>问题</strong></p>
<ol>
<li>invoke 的参数和返回值必须是 Object 类型的。这就意味着必须进行多次的类型转<br>换。</li>
<li>用反射获得方法指针的代码要比仅仅直接调用方<br>法明显慢一些</li>
</ol>
</li>
</ol>
<h2 id="继承的设计技巧"><a href="#继承的设计技巧" class="headerlink" title="继承的设计技巧"></a>继承的设计技巧</h2><ol>
<li><p>将公共操作和域放在超类</p>
</li>
<li><p>不要使用受保护的域。主要原因有</p>
<ol>
<li>子类集合是无限制的， 任何一个人都能够由某个类派生一个子类，并<br>编写代码以直接访问 protected 的实例域， 从而破坏了封装性。</li>
<li>在 Java 程序设计语言<br>中，在同一个包中的所有类都可以访问 proteced 域，而不管它是否为这个类的子类。</li>
<li>protected 方法对于指示那些不提供一般用途而应在子类中重新定义的方法很有用。</li>
</ol>
</li>
<li><p>使用继承实现“ is-a” 关系。如果B不包含A中某些域，那么一般就不是is-a关系</p>
</li>
<li><p>除非所有继承的方法都有以以，否则不要使用继承</p>
</li>
<li><p>在覆盖方法时，不要改变预期的行为</p>
</li>
<li><p>使用多态，而非类型信息</p>
</li>
<li><p>不要过多的使用反射</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>python数据分析与挖掘实战笔记</title>
    <url>/2020/01/22/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="第1章-数据挖掘基础"><a href="#第1章-数据挖掘基础" class="headerlink" title="第1章 数据挖掘基础"></a><a href="/2020/01/22/数据挖掘U1/">第1章 数据挖掘基础</a></h2><h2 id="第2章-python数据分析简介"><a href="#第2章-python数据分析简介" class="headerlink" title="第2章 python数据分析简介"></a><a href="/2020/01/22/数据挖掘U2/">第2章 python数据分析简介</a></h2><h2 id="第3章-数据探索"><a href="#第3章-数据探索" class="headerlink" title="第3章 数据探索"></a><a href="/2020/01/22/数据挖掘U3/">第3章 数据探索</a></h2>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘U1</title>
    <url>/2020/01/22/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98U1/</url>
    <content><![CDATA[<h1 id="数据挖掘基本概念"><a href="#数据挖掘基本概念" class="headerlink" title="数据挖掘基本概念"></a>数据挖掘基本概念</h1><ol>
<li>数据挖掘：从大量数据中挖掘处隐含的，未知的，对决策有潜在价值的关系，模式和趋势，并用这些知识和规则建立用于决策支持的模型。</li>
<li>基本任务：包括利用分类与预测，聚类分析，关联规则，时序模式，偏差检测，智能推荐等方法，提取数据中的价值。</li>
</ol>
<h1 id="数据挖掘建模过程"><a href="#数据挖掘建模过程" class="headerlink" title="数据挖掘建模过程"></a>数据挖掘建模过程</h1><h2 id="定义挖掘目标"><a href="#定义挖掘目标" class="headerlink" title="定义挖掘目标"></a>定义挖掘目标</h2><ol>
<li>即明确系统完成后达到什么样的效果。</li>
<li>需要分析应用领域，包括应用中的各种知识和应用目标。</li>
</ol>
<h2 id="数据取样"><a href="#数据取样" class="headerlink" title="数据取样"></a>数据取样</h2><ol>
<li>抽取标准：相关性；可靠性；有效性。</li>
<li>一定要保证数据的质量，衡量数据质量的标准<ol>
<li>资料完整无缺，各类指标项齐全</li>
<li>数据准确无误，反应的都是正常状态下的水平</li>
</ol>
</li>
</ol>
<h3 id="常见抽样方式"><a href="#常见抽样方式" class="headerlink" title="常见抽样方式"></a>常见抽样方式</h3><ol>
<li>随机抽样：使数据集中的每一组观测值都有相同的被抽样的概率</li>
<li>等距抽样</li>
<li>分层抽样：先将数据分成若干层次，在每个层次中的观测值都具有相同的被选用的概率，但对不同层次可设定不同概率</li>
<li>从起始顺序抽样</li>
<li>分类抽样：依据某种属性的具体取值来选择数据子集，如按客户名称分类。</li>
</ol>
<h2 id="数据搜素"><a href="#数据搜素" class="headerlink" title="数据搜素"></a>数据搜素</h2><p>目的是对所抽取的样本数据进行搜素，审核和必要的加工处理，以保证最终的挖掘模型的质量所必须的。</p>
<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><ol>
<li>目的是减少噪声和不一致，不完整的数据。</li>
<li>主要包括：数据筛选；数据变量转换，缺失值处理，坏数据处理，数据标准化，主成分分析，属性选择，数据规约等</li>
</ol>
<h2 id="挖掘建模"><a href="#挖掘建模" class="headerlink" title="挖掘建模"></a>挖掘建模</h2><ol>
<li>首先分析本次建模属于哪类问题（分类与预测，聚类，关联规则，时序模式或者智能推荐）</li>
</ol>
<h2 id="模型评价"><a href="#模型评价" class="headerlink" title="模型评价"></a>模型评价</h2>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘U2</title>
    <url>/2020/01/22/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98U2/</url>
    <content><![CDATA[<h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><h2 id="列表元组相关函数"><a href="#列表元组相关函数" class="headerlink" title="列表元组相关函数"></a>列表元组相关函数</h2><img src="/数据挖掘实战_img/1.png">

<h2 id="列表相关方法"><a href="#列表相关方法" class="headerlink" title="列表相关方法"></a>列表相关方法</h2><img src="/数据挖掘实战_img/2.png">

<img src="/数据挖掘实战_img/3.png">

<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><ol>
<li>定义:如d = {‘today’:20,’tomorrow’:30};或者通过dict([‘today’,20],[‘tomorrow’,30])</li>
</ol>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ol>
<li>定义：如s={1,2,2,3}//得到{1,2,3}</li>
<li>集合运算<ol>
<li>| 并集</li>
<li>&amp; 交集</li>
<li><ul>
<li>差集//t-s在t中不在s中</li>
</ul>
</li>
<li>^ 对称差集//不同时出现在二者中</li>
</ol>
</li>
</ol>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><ol>
<li><p>map</p>
 <img src="/数据挖掘实战_img/4.png">
</li>
<li><p>reduce</p>
 <img src="/数据挖掘实战_img/5.png">
</li>
<li><p>filter</p>
 <img src="/数据挖掘实战_img/6.png">

</li>
</ol>
<h2 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h2><ol>
<li>from 库 import 函数 as 别名</li>
</ol>
<h1 id="Python-数据分析工具"><a href="#Python-数据分析工具" class="headerlink" title="Python 数据分析工具"></a>Python 数据分析工具</h1><h2 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h2><ol>
<li>提供多维数组</li>
</ol>
<img src="/数据挖掘实战_img/7.png">

<h2 id="Scipy"><a href="#Scipy" class="headerlink" title="Scipy"></a>Scipy</h2><ol>
<li>提供了真正的矩阵，以及大量基于矩阵运算的对象和函数。</li>
</ol>
<img src="/数据挖掘实战_img/8.png">

<h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><ol>
<li>主要用于二维绘图，也可以进行简单的三维绘图。</li>
<li>如果想使用中文标签</li>
</ol>
<p><code>plt.rcParams[&#39;font.sans-serif&#39;]=[&#39;SimHei&#39;]</code></p>
<ol start="3">
<li>如果负号不能正常显示</li>
</ol>
<p><code>plt.rcParams[&#39;axes.unicode.minus&#39;]=False</code></p>
<img src="/数据挖掘实战_img/9.png">

<h2 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h2><ol>
<li>基本数据结构Series和DataFrame。Series是序列，DataFrame类似二维数组，每一列是一个Series。每个Series都带有一个对应的Index，Index可以是字母，中文，数字等</li>
</ol>
<img src="/数据挖掘实战_img/10.png">

<h2 id="StatsModels"><a href="#StatsModels" class="headerlink" title="StatsModels"></a>StatsModels</h2><ol>
<li>用于数据的统计建模分析，与Pandas结合</li>
</ol>
<h2 id="Scikit-Learn"><a href="#Scikit-Learn" class="headerlink" title="Scikit-Learn"></a>Scikit-Learn</h2><ol>
<li>完善的机器学习工具箱，包括数据预处理，分类，回归，聚类，预测和模型分析。</li>
</ol>
<img src="/数据挖掘实战_img/11.png">

<h2 id="Keras"><a href="#Keras" class="headerlink" title="Keras"></a>Keras</h2><ol>
<li>Win下速度比Linux慢很多</li>
</ol>
<img src="/数据挖掘实战_img/12.png">
## Gnesim

<img src="/数据挖掘实战_img/13.png">
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘U3</title>
    <url>/2020/01/22/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98U3/</url>
    <content><![CDATA[<h1 id="数据质量分析"><a href="#数据质量分析" class="headerlink" title="数据质量分析"></a>数据质量分析</h1><p>目的是为了数据预处理做准备，为数据挖掘分析结论有效性和准确性提供基础。</p>
<ol>
<li>脏数据:不符合要求，以及不能直接进行相应分析的数据。包括：<ol>
<li>缺失值</li>
<li>异常值</li>
<li>不一致的值</li>
<li>重复数据及含有特殊符号的数据</li>
</ol>
</li>
</ol>
<h2 id="缺失值分析"><a href="#缺失值分析" class="headerlink" title="缺失值分析"></a>缺失值分析</h2><p>指某个记录的缺失和记录中某个字段信息的缺失。</p>
<h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><ol>
<li>某些信息暂时无法获取</li>
<li>有些信息被遗漏</li>
<li>属性值不存在</li>
</ol>
<h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><ol>
<li>数据挖掘建模将丢失大量有效信息</li>
<li>挖掘的不确定性更加显著</li>
<li>包含空值的数据会使建模过程陷入混乱，导致不可靠的输出。</li>
</ol>
<h3 id="缺失值分析-1"><a href="#缺失值分析-1" class="headerlink" title="缺失值分析"></a>缺失值分析</h3><ol>
<li>使用统计分析可以得到缺失值的属性的个数，以及每个属性的未缺失数，缺失数和缺失率。</li>
</ol>
<h3 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h3><ol>
<li>对可能值进行插补和不处理等，见第四章</li>
</ol>
<h2 id="异常值分析"><a href="#异常值分析" class="headerlink" title="异常值分析"></a>异常值分析</h2><ol>
<li>异常值指样本中的个别值，其数值明显偏离其余的观测值。</li>
<li>异常值分析：用于检验数据是否有录入错误以及不合常理的数据。</li>
</ol>
<h3 id="简单统计量分析"><a href="#简单统计量分析" class="headerlink" title="简单统计量分析"></a>简单统计量分析</h3><p>先对变量做一个描述性统计，进而查看哪些数据是不合理的。如给数据设置最大值和最小值。</p>
<h3 id="3σ原则"><a href="#3σ原则" class="headerlink" title="3σ原则"></a>3σ原则</h3><p><strong>如果数据符合正态分布</strong>，在3σ原则下，异常值被定义为一组测定值中与平均值的偏差超过3倍标准差的值。(即使不服从正态分布，也可以用原理平均值的多少倍标准差来描述)</p>
<h3 id="箱型图分析"><a href="#箱型图分析" class="headerlink" title="箱型图分析"></a>箱型图分析</h3><p><img src="/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98_img/14.png" alt=""></p>
<ol>
<li><p>异常值通常被定义为小于Q<sub>L</sub>-1.5IQR或大于Q<sub>U</sub>+1.5IQR。</p>
</li>
<li><p>Q<sub>L</sub>称为下四分位数，表示全部观察值中只有四分之一的数据取值比它小</p>
</li>
<li><p>Q<sub>U</sub>称为上四分位数，表示全部观察值中有四分之一的数据取值比他大</p>
</li>
<li><p>IQR 为四分位数间距。IQR=Q<sub>U</sub>-Q<sub>L</sub>，其间包含了全部观察值的一半。</p>
</li>
<li><p>优点：</p>
<ol>
<li>不对数据的分布形式有要求</li>
<li>判断异常值的标准时以四分位数和四分位距为标准，具有一定的鲁棒性。(25%以上的异常值才可能对四分位数产生较大的扰动)</li>
<li>箱型图识别异常值的结果比较客观。</li>
</ol>
</li>
<li><p>使用</p>
<p> <img src="/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98_img/15.png" alt=""></p>
</li>
<li><p>异常值检测</p>
<p> <img src="/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98_img/16.png" alt="">    </p>
</li>
</ol>
<h2 id="一致性分析"><a href="#一致性分析" class="headerlink" title="一致性分析"></a>一致性分析</h2><h3 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h3><p>是指数据的矛盾性。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ol>
<li>不一致性的产生主要发生在数据集成的过程中，可能是因为数据来自于不同的数据源</li>
<li>对重复存放的数据未能进行一致性更新造成的。(两张表中的同一个数据只改了一个)</li>
</ol>
<h1 id="数据特征分析"><a href="#数据特征分析" class="headerlink" title="数据特征分析"></a>数据特征分析</h1><h2 id="分布分析"><a href="#分布分析" class="headerlink" title="分布分析"></a>分布分析</h2><p>目的是揭示数据的分布特征和分布类型</p>
<h3 id="定量数据的分布分析"><a href="#定量数据的分布分析" class="headerlink" title="定量数据的分布分析"></a>定量数据的分布分析</h3><ol>
<li><p>想要了解分布形式是否对称，是否存在某些特大或特小的可疑值。可绘制<strong>频率表格</strong>，绘制<strong>频率直方图</strong>，绘制<strong>茎叶图</strong>来分析</p>
</li>
<li><p>主要问题： 选择组数和组宽</p>
</li>
<li><p>步骤</p>
<ol>
<li>求极差</li>
<li>决定组数和组距</li>
<li>决定分点</li>
<li>列出频率分布表</li>
<li>绘制频率分布直方图(纵轴频率密度)</li>
</ol>
</li>
<li><p>原则</p>
<ol>
<li>各组间必须相互排斥</li>
<li>各组必须将所有的数据包含在内</li>
<li>各组的组宽最好相等</li>
</ol>
</li>
</ol>
<h3 id="定性数据的分布分析"><a href="#定性数据的分布分析" class="headerlink" title="定性数据的分布分析"></a>定性数据的分布分析</h3><ol>
<li>根据变量的分类类型来分组，使用饼图和条形图来描述分布。</li>
<li>条形图的高度和饼图的面积用来代表每一类型的百分比或频数。</li>
</ol>
<h3 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h3><ol>
<li>对比分析：指把两个相互联系的指标进行比较，从数量上展示和说明研究对象规模的大小，水平的高低，速度的快慢，以及各种关系是否协调。</li>
<li>关键在于选择对比标准</li>
<li>主要包括<strong>绝对数比较</strong>，<strong>相对数比较</strong></li>
<li>相对数标胶：通过两个有联系的指标对比计算，用以反应客观现象间数量的联系程度的综合指标。相对数包括<ol>
<li>结构相对数：同一总体内的部分数值与全部数值的比重。</li>
<li>比例相对数：同一总体中，不同部分的数值的对比，表明总体中各部分的比例关系</li>
<li>比较相对数：将同一时期的两个性质相同的指标数值进行对比，说明同类现象在不同的空间条件下的数量对比关系。</li>
<li>强度相对数：将两个性质不同但有一定联系的总量指标进行对比，用以说明现象的强度、密度和普通程度。</li>
<li>计划完成程度相对数：对某一时期实际完成数与计划数对比，用以说明计划完成程度。</li>
<li>动态对比数：同一现象在不同时期的指标数值进行对比，用以说明发展方向和变化的速度。</li>
</ol>
</li>
</ol>
<h3 id="统计量分析"><a href="#统计量分析" class="headerlink" title="统计量分析"></a>统计量分析</h3><ol>
<li><p>集中趋势度量</p>
<ol>
<li>均值(加权均值)</li>
<li>频率分布表的加权平均数<br> <img src="/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98_img/17.png" alt=""></li>
<li>中位数：先排序</li>
<li>众数</li>
</ol>
</li>
<li><p>离中趋势度量</p>
<ol>
<li><p>极差:对极端值非常敏感</p>
</li>
<li><p>标准差<br> <img src="/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98_img/18.png" alt=""></p>
</li>
<li><p>变异稀疏：度量标准差相对于均值的离中趋势<br> <img src="/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98_img/19.png" alt=""></p>
</li>
<li><p>四分位数间距：需要排序。间距越大说明数据的变异程度越大。<br> <img src="/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98_img/20.png" alt=""></p>
</li>
</ol>
</li>
</ol>
<h3 id="周期性分析"><a href="#周期性分析" class="headerlink" title="周期性分析"></a>周期性分析</h3><ol>
<li>周期性分析:探索某个变量是否随着时间变化呈现出某种周期变化趋势。</li>
</ol>
<h3 id="贡献度分析-帕累托分析"><a href="#贡献度分析-帕累托分析" class="headerlink" title="贡献度分析(帕累托分析)"></a>贡献度分析(帕累托分析)</h3><h3 id="相关性分析"><a href="#相关性分析" class="headerlink" title="相关性分析"></a>相关性分析</h3><ol>
<li><p>用于分析连续变量之间线性相关程度的强弱，并用适当的统计指标表示。表示方法包括</p>
</li>
<li><p>直接绘制散点图</p>
</li>
<li><p>绘制散点图矩阵</p>
</li>
<li><p>计算相关系数</p>
<ol>
<li><p>Pearson相关系数：要求连续变量的取值服从正态分布</p>
<p> <img src="/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98_img/22.png" alt=""></p>
</li>
<li><p>Spearman秩相关系数</p>
<p> <img src="/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98_img/23.png" alt=""></p>
<p> <img src="/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98_img/24.png" alt=""></p>
<ol>
<li>只要两个变量具有严格单调函数关系，那么他们就是完全Sperman相关的。</li>
</ol>
</li>
<li><p>判断系数：相关系数的平方；用以衡量回归方程对y的解释程度。<br> <img src="/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98_img/25.png" alt=""></p>
</li>
</ol>
</li>
</ol>
<h1 id="主要数据探索函数"><a href="#主要数据探索函数" class="headerlink" title="主要数据探索函数"></a>主要数据探索函数</h1><h2 id="基本统计特征函数"><a href="#基本统计特征函数" class="headerlink" title="基本统计特征函数"></a>基本统计特征函数</h2><p><img src="/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98_img/26.png" alt=""></p>
<ol>
<li><p>D.corr(method=’pearson’)，样本D可为DataFrame，返回相关系数矩阵，method参数为计算方法，支持pearson，kendall，spearman系数</p>
</li>
<li><p>S1.(S2,method=’pearman’)，求S1和S2之间的相关系数。</p>
<p> <img src="/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98_img/27.png" alt=""></p>
</li>
<li><p>cov()返回协方差矩阵</p>
<ol>
<li>样本D可为DataFrame</li>
<li>可用S1.cov(S2)计算两个Series之间的协方差</li>
</ol>
</li>
<li><p>skew/kurt</p>
<ol>
<li>计算数据样本的偏度(三阶矩)/峰度(四阶矩)</li>
</ol>
</li>
<li><p>describe</p>
<ol>
<li>返回一些基本统计量</li>
</ol>
</li>
</ol>
<h2 id="拓展统计特征函数"><a href="#拓展统计特征函数" class="headerlink" title="拓展统计特征函数"></a>拓展统计特征函数</h2><p><img src="/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98_img/28.png" alt=""></p>
<p><img src="/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98_img/29.png" alt=""></p>
<ol>
<li>DataFrame或Series的对象D；D.cumsum()</li>
<li>pd.rolling_mean(D,k)每k列计算一次均值，滚动计算。</li>
</ol>
<p><img src="/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98_img/30.png" alt=""></p>
<h2 id="统计作图函数"><a href="#统计作图函数" class="headerlink" title="统计作图函数"></a>统计作图函数</h2><p><img src="/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98_img/31.png" alt=""></p>
<h3 id="plot"><a href="#plot" class="headerlink" title="plot"></a>plot</h3><ol>
<li>plt.plot(x,y,S)</li>
<li>S为格式设置</li>
<li>D.plot(kind=’xxx’)指定作图类型</li>
</ol>
<h3 id="pie"><a href="#pie" class="headerlink" title="pie"></a>pie</h3><ol>
<li>plt.pie(size)绘制饼状图</li>
</ol>
<p><img src="/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98_img/32.png" alt=""></p>
<h3 id="hist"><a href="#hist" class="headerlink" title="hist"></a>hist</h3><ol>
<li>绘制二维条形直方图</li>
</ol>
<p><img src="/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98_img/33.png" alt=""></p>
<h3 id="boxplot"><a href="#boxplot" class="headerlink" title="boxplot"></a>boxplot</h3><ol>
<li>绘制箱式图</li>
</ol>
<p><img src="/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98_img/34.png" alt=""></p>
<h3 id="plot-logx-True-plot-logy-True"><a href="#plot-logx-True-plot-logy-True" class="headerlink" title="plot(logx=True)/plot(logy=True)"></a>plot(logx=True)/plot(logy=True)</h3><ol>
<li>绘制x或y轴的对数图形</li>
</ol>
<p><img src="/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98_img/35.png" alt=""></p>
<h3 id="plot-yerr-error"><a href="#plot-yerr-error" class="headerlink" title="plot(yerr=error)"></a>plot(yerr=error)</h3><ol>
<li>绘制误差条形图</li>
</ol>
<p><img src="/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98_img/36.png" alt=""></p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>切断圆环链</title>
    <url>/2020/01/22/%E5%88%87%E6%96%AD%E5%9C%86%E7%8E%AF%E9%93%BE/</url>
    <content><![CDATA[<h1 id="UVA-818-切断圆环链"><a href="#UVA-818-切断圆环链" class="headerlink" title="UVA 818 切断圆环链"></a>UVA 818 切断圆环链</h1><p>现在有n个圆环 ，其中可能有些已经连接在一起 现在你想拆开一些圆环与其他圆环连接，使得最后所有圆环都在一条串上 问至少需要拆开几个圆环 (n≤15)</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>应该抽象为图的问题，要解决连通性的问题。</p>
</li>
<li><p>首先，把所有环打开后再扣上一定可以形成一条链。所以不存在无解的情况。</p>
</li>
<li><p>然后，我们发现n≤15，所以我们可以用二进制表示这n个环是否被打开。</p>
</li>
<li><p>我们可以遍历所有状态。判断这个状态是否合法即可。如何判断状态合法？我们发现只要一个状态满足一下三条条件就合法。</p>
<ol>
<li><p>不能有环</p>
</li>
<li><p>一个节点不能有3个及其以上的儿子。即：每个点的度数需要≤2</p>
</li>
<li><p>由于每个打开的环只能连接两个未打开的环（即两个连通分量），所以联通分量的个数必须≤要打开的环的个数＋1。</p>
</li>
</ol>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="have-cycle-判断有无环-使用递归"><a href="#have-cycle-判断有无环-使用递归" class="headerlink" title="have_cycle 判断有无环(使用递归)"></a>have_cycle 判断有无环(使用递归)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool have_circle(int s) &#123;&#x2F;&#x2F;判断是否存在环</span><br><span class="line">	memset(used, 0, sizeof(used));</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (!used[i] &amp;&amp; !(s&amp;(1 &lt;&lt; i))) &#123;</span><br><span class="line"></span><br><span class="line">&gt; 此处条件表示i节点没有遍历过，且跳过s代表的状态</span><br><span class="line">&gt; 只有当s&#x3D;&#x3D;(1&lt;&lt;i)时，后面的条件才为假</span><br><span class="line"></span><br><span class="line">			num++;&#x2F;&#x2F;num表示连通分量数</span><br><span class="line">			if (dfs(i, -1, s))</span><br><span class="line">				return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool dfs(int u, int fa, int s) &#123;</span><br><span class="line">	used[u] &#x3D; 1;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (g[u][i]) &#123;</span><br><span class="line">			if (i &#x3D;&#x3D; fa || (s &amp; (1 &lt;&lt; i))) continue;</span><br><span class="line"></span><br><span class="line">&gt; 状态s下，该边会被切断，所以不能走下去。</span><br><span class="line"></span><br><span class="line">			if (used[i]) return true;&#x2F;&#x2F;如果被标记第二次，那么存在环</span><br><span class="line">			if (dfs(i, u, s)) return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="above-two-判断是否右节点的度大于二"><a href="#above-two-判断是否右节点的度大于二" class="headerlink" title="above_two 判断是否右节点的度大于二"></a>above_two 判断是否右节点的度大于二</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool above_two(int s) &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">	int cnt &#x3D; 0;</span><br><span class="line">	for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">		if (g[i][j] &amp;&amp; !(s&amp;(1 &lt;&lt; i)) &amp;&amp; !(s&amp;(1 &lt;&lt; j))) &#123;</span><br><span class="line">			&#x2F;&#x2F;这里注意 i和 j 都不被切断的情况下</span><br><span class="line">			cnt++;</span><br><span class="line">			if (cnt &gt; 2) return true;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="count-统计s状态打开的环的数量"><a href="#count-统计s状态打开的环的数量" class="headerlink" title="count 统计s状态打开的环的数量"></a>count 统计s状态打开的环的数量</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int count(int s) &#123;</span><br><span class="line">int cnt &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">	if (s&amp;(1 &lt;&lt; i)) cnt++;</span><br><span class="line">return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 15;</span><br><span class="line">bool dfs(int u, int fa, int s);</span><br><span class="line">bool above_two(int s);</span><br><span class="line">bool have_circle(int s);</span><br><span class="line">int count(int s);</span><br><span class="line">int n, num;</span><br><span class="line">int g[maxn][maxn];</span><br><span class="line">bool used[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">int a, b;</span><br><span class="line">int kase &#x3D; 0;</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	int ans &#x3D; inf;</span><br><span class="line">	memset(g, 0, sizeof(g));</span><br><span class="line">	while (scanf(&quot;%d %d&quot;, &amp;a, &amp;b) &amp;&amp; a !&#x3D; -1) &#123;</span><br><span class="line">		g[a - 1][b - 1] &#x3D; 1;</span><br><span class="line">		g[b - 1][a - 1] &#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; (1 &lt;&lt; n); i++) &#123;</span><br><span class="line">		num &#x3D; 0;</span><br><span class="line">		if (above_two(i) || have_circle(i))</span><br><span class="line">			continue;</span><br><span class="line">		int now &#x3D; count(i);</span><br><span class="line">		if (num - 1 &lt;&#x3D; now)</span><br><span class="line">			ans &#x3D; min(ans, now);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;Set %d: Minimum links to open is %d\n&quot;, ++kase, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>多米诺效应</title>
    <url>/2020/01/22/%E5%A4%9A%E7%B1%B3%E8%AF%BA%E6%95%88%E5%BA%94/</url>
    <content><![CDATA[<h1 id="UVA-211-多米诺效应"><a href="#UVA-211-多米诺效应" class="headerlink" title="UVA 211 多米诺效应"></a>UVA 211 多米诺效应</h1><p><img src="/img_UVA%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/2.png" alt=""></p>
<p><img src="/img_UVA%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/3.png" alt=""></p>
<p><img src="/img_UVA%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/4.png" alt=""></p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>题干可以理解为有28个1*<em>2的色块，先要拼成一个7*</em>8的矩形。问有多少种方案</li>
<li>大体框架一定是深搜了。问题在于如果本题中的跨度为2。如果按照可以构成骨牌步长为2来走，可能导致中空，那么递归不会执行递归头的期望结束点。</li>
<li>改为步长为1，且人为规定图像的填充沿着右下方向延伸。所以dx，dy只需要两个方向。</li>
<li>应该注意的点还是基本问题，比如越界判定，访问标志的置位与清零等等。</li>
<li>本题的输出格式要求尤为恶心</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="dfs-部分"><a href="#dfs-部分" class="headerlink" title="dfs 部分"></a>dfs 部分</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void dfs(int x, int y, int step) &#123;</span><br><span class="line">int newx, newy, now;</span><br><span class="line">if (step &#x3D;&#x3D; cnt) &#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; maxr; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; maxc; j++)</span><br><span class="line">			printf(ans[i][j] &lt; 10 ? &quot;   %d&quot; : &quot;  %d&quot;, ans[i][j]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	tot++;</span><br><span class="line">	printf(&quot;\n\n&quot;);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (y &#x3D;&#x3D; maxc) &#123; x++; y &#x3D; 0; &#125;</span><br><span class="line">if (vis[x][y]) dfs(x, y + 1, step);</span><br><span class="line">else &#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 2; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		newx &#x3D; x + dx[i];</span><br><span class="line">		newy &#x3D; y + dy[i];</span><br><span class="line"></span><br><span class="line">		if (newx &lt; 0 || newy &lt; 0 || newx &gt;&#x3D; maxr || newy &gt;&#x3D; maxc || vis[newx][newy])</span><br><span class="line">			continue;</span><br><span class="line">		now &#x3D; max(id[in[x][y]][in[newx][newy]], id[in[newx][newy]][in[x][y]]);</span><br><span class="line"></span><br><span class="line">		if (now)</span><br><span class="line">		&#123;</span><br><span class="line">   			if (used[now]) continue;</span><br><span class="line"></span><br><span class="line">			ans[x][y] &#x3D; ans[newx][newy] &#x3D; now;</span><br><span class="line">			vis[newx][newy] &#x3D; 1;</span><br><span class="line">			used[now] &#x3D; 1;</span><br><span class="line"></span><br><span class="line">			dfs(x, y + 1, step + 1);</span><br><span class="line"></span><br><span class="line">			ans[x][y] &#x3D; ans[newx][newy] &#x3D; 0;</span><br><span class="line">			vis[x][y] &#x3D; vis[newx][newy] &#x3D; 0;</span><br><span class="line">			used[now] &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxr &#x3D; 7;</span><br><span class="line">const int maxc &#x3D; 8;</span><br><span class="line">int tot;</span><br><span class="line">int id[maxr][maxc];</span><br><span class="line">int ans[maxr][maxc];</span><br><span class="line">int vis[maxr][maxc];</span><br><span class="line">int in[maxr][maxc];</span><br><span class="line">int cnt;</span><br><span class="line">int used[29];</span><br><span class="line">const int dx[] &#x3D; &#123; 1,0 &#125;;</span><br><span class="line">const int dy[] &#x3D; &#123; 0,1 &#125;;</span><br><span class="line">void dfs(int x, int y, int step);</span><br><span class="line">void dfs(int x, int y);</span><br><span class="line">int main() &#123;</span><br><span class="line">int kase &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 7; i++)</span><br><span class="line">	for (int j &#x3D; i; j &lt; 7; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		id[i][j] &#x3D; ++cnt;</span><br><span class="line">	&#125;</span><br><span class="line">while (1) &#123;</span><br><span class="line"></span><br><span class="line">	tot &#x3D; 0;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	memset(used, 0, sizeof(used));</span><br><span class="line">	for (int i &#x3D; 0; i &lt; maxr; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; maxc; j++) &#123;</span><br><span class="line">			if (scanf(&quot;%d&quot;, &amp;in[i][j]) !&#x3D; 1)</span><br><span class="line">				return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		scanf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if (kase) printf(&quot;\n\n\n\n\n&quot;);</span><br><span class="line">	printf(&quot;Layout #%d:\n\n\n&quot;, ++kase);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; maxr; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; maxc; j++) &#123;</span><br><span class="line">			printf(&quot;   %d&quot;, in[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">	printf(&quot;Maps resulting from layout #%d are:\n\n\n&quot;, kase);</span><br><span class="line">	dfs(0, 0, 0);</span><br><span class="line">	printf(&quot;There are %d solution(s) for layout #%d.\n&quot;, tot, kase);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>微机原理</title>
    <url>/2020/01/21/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="8255"><a href="#8255" class="headerlink" title="8255"></a><a href="/2019/11/06/8255">8255</a></h2><h2 id="8259"><a href="#8259" class="headerlink" title="8259"></a><a href="/2019/11/18/8259">8259</a></h2><h2 id="微原实验"><a href="#微原实验" class="headerlink" title="微原实验"></a><a href="https://github.com/Cccceb/BTF/tree/master/MicroComputerExp">微原实验</a></h2>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础</title>
    <url>/2020/01/20/MySQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><pre><code>一、为什么要学习数据库
二、数据库的相关概念      
    DBMS、DB、SQL
三、数据库存储数据的特点
四、初始MySQL
    MySQL产品的介绍        
    MySQL产品的安装          ★        
    MySQL服务的启动和停止     ★
    MySQL服务的登录和退出     ★      
    MySQL的常见命令和语法规范      
五、DQL语言的学习   ★              
    基础查询        ★             
    条件查询         ★            
    排序查询         ★                
    常见函数        ★               
    分组函数        ★              
    分组查询           ★            
    连接查询         ★            
    子查询       √                  
    分页查询       ★              
    union联合查询    √            

六、DML语言的学习    ★             
    插入语句                        
    修改语句                        
    删除语句                        
七、DDL语言的学习  
    库和表的管理     √                
    常见数据类型介绍  √          
    常见约束        √            
八、TCL语言的学习
    事务和事务处理                 
九、视图的讲解           √
十、变量                      
十一、存储过程和函数   
十二、流程控制结构       </code></pre><h2 id="数据库的好处"><a href="#数据库的好处" class="headerlink" title="数据库的好处"></a>数据库的好处</h2><pre><code>1.持久化数据到本地
2.可以实现结构化查询，方便管理</code></pre><h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><pre><code>1、DB：数据库，保存一组有组织的数据的容器
2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据
3、SQL:结构化查询语言，用于和DBMS通信的语言</code></pre><h2 id="数据库存储数据的特点"><a href="#数据库存储数据的特点" class="headerlink" title="数据库存储数据的特点"></a>数据库存储数据的特点</h2><pre><code>1、将数据放到表中，表再放到库中
2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。
3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。
4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”
5、表中的数据是按行存储的，每一行类似于java中的“对象”。</code></pre><h2 id="MySQL产品的介绍和安装"><a href="#MySQL产品的介绍和安装" class="headerlink" title="MySQL产品的介绍和安装"></a>MySQL产品的介绍和安装</h2><h3 id="MySQL服务的启动和停止"><a href="#MySQL服务的启动和停止" class="headerlink" title="MySQL服务的启动和停止"></a>MySQL服务的启动和停止</h3><pre><code>方式一：计算机——右击管理——服务
方式二：通过管理员身份运行
net start 服务名（启动服务）
net stop 服务名（停止服务）</code></pre><h3 id="MySQL服务的登录和退出"><a href="#MySQL服务的登录和退出" class="headerlink" title="MySQL服务的登录和退出"></a>MySQL服务的登录和退出</h3><pre><code>方式一：通过mysql自带的客户端
只限于root用户

方式二：通过windows自带的客户端
登录：
mysql 【-h主机名 -P端口号 】-u用户名 -p密码

退出：
exit或ctrl+C</code></pre><h3 id="MySQL的常见命令"><a href="#MySQL的常见命令" class="headerlink" title="MySQL的常见命令"></a>MySQL的常见命令</h3><pre><code>1.查看当前所有的数据库
show databases;
2.打开指定的库
use 库名
3.查看当前库的所有表
show tables;
4.查看其它库的所有表
show tables from 库名;
5.创建表
create table 表名(

    列名 列类型,
    列名 列类型，
    。。。
);
6.查看表结构
desc 表名;


7.查看服务器的版本
方式一：登录到mysql服务端
select version();
方式二：没有登录到mysql服务端
mysql --version
或
mysql --V</code></pre><h3 id="MySQL的语法规范"><a href="#MySQL的语法规范" class="headerlink" title="MySQL的语法规范"></a>MySQL的语法规范</h3><pre><code>1.不区分大小写,但建议关键字大写，表名、列名小写
2.每条命令最好用分号结尾
3.每条命令根据需要，可以进行缩进 或换行
4.注释
    单行注释：#注释文字
    单行注释：-- 注释文字
    多行注释：/* 注释文字  */</code></pre><h3 id="SQL的语言分类"><a href="#SQL的语言分类" class="headerlink" title="SQL的语言分类"></a>SQL的语言分类</h3><pre><code>DQL（Data Query Language）：数据查询语言
    select 
DML(Data Manipulate Language):数据操作语言
    insert 、update、delete
DDL（Data Define Languge）：数据定义语言
    create、drop、alter
TCL（Transaction Control Language）：事务控制语言
    commit、rollback</code></pre><h3 id="SQL的常见命令"><a href="#SQL的常见命令" class="headerlink" title="SQL的常见命令"></a>SQL的常见命令</h3><pre><code>show databases； 查看所有的数据库
use 库名； 打开指定 的库
show tables ; 显示库中的所有表
show tables from 库名;显示指定库中的所有表
create table 表名(
    字段名 字段类型,    
    字段名 字段类型
); 创建表

desc 表名; 查看指定表的结构
select * from 表名;显示表中的所有数据</code></pre><h2 id="DQL语言的学习"><a href="#DQL语言的学习" class="headerlink" title="DQL语言的学习"></a>DQL语言的学习</h2><h3 id="进阶1：基础查询"><a href="#进阶1：基础查询" class="headerlink" title="进阶1：基础查询"></a>进阶1：基础查询</h3><pre><code>语法：
SELECT 要查询的东西
【FROM 表名】;

类似于Java中 :System.out.println(要打印的东西);
特点：
①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在
② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数</code></pre><h3 id="进阶2：条件查询"><a href="#进阶2：条件查询" class="headerlink" title="进阶2：条件查询"></a>进阶2：条件查询</h3><pre><code>条件查询：根据条件过滤原始表的数据，查询到想要的数据
语法：
select 
    要查询的字段|表达式|常量值|函数
from 
    表
where 
    条件 ;

分类：
一、条件表达式
    示例：salary&gt;10000
    条件运算符：
    &gt; &lt; &gt;= &lt;= = != &lt;&gt;

二、逻辑表达式
示例：salary&gt;10000 &amp;&amp; salary&lt;20000

逻辑运算符：

    and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false
    or(||)：两个条件只要有一个成立，结果为true，否则为false
    not(!)：如果条件成立，则not后为false，否则为true

三、模糊查询
示例：last_name like &apos;a%&apos;</code></pre><h3 id="进阶3：排序查询"><a href="#进阶3：排序查询" class="headerlink" title="进阶3：排序查询"></a>进阶3：排序查询</h3><pre><code>语法：
select
    要查询的东西
from
    表
where 
    条件

order by 排序的字段|表达式|函数|别名 【asc|desc】</code></pre><h3 id="进阶4：常见函数"><a href="#进阶4：常见函数" class="headerlink" title="进阶4：常见函数"></a>进阶4：常见函数</h3><pre><code>一、单行函数
1、字符函数
    concat拼接
    substr截取子串
    upper转换成大写
    lower转换成小写
    trim去前后指定的空格和字符
    ltrim去左边空格
    rtrim去右边空格
    replace替换
    lpad左填充
    rpad右填充
    instr返回子串第一次出现的索引
    length 获取字节个数

2、数学函数
    round 四舍五入
    rand 随机数
    floor向下取整
    ceil向上取整
    mod取余
    truncate截断
3、日期函数
    now当前系统日期+时间
    curdate当前系统日期
    curtime当前系统时间
    str_to_date 将字符转换成日期
    date_format将日期转换成字符
4、流程控制函数
    if 处理双分支
    case语句 处理多分支
        情况1：处理等值判断
        情况2：处理条件判断

5、其他函数
    version版本
    database当前库
    user当前连接用户</code></pre><p>二、分组函数</p>
<pre><code>sum 求和
max 最大值
min 最小值
avg 平均值
count 计数

特点：
1、以上五个分组函数都忽略null值，除了count(*)
2、sum和avg一般用于处理数值型
    max、min、count可以处理任何数据类型
3、都可以搭配distinct使用，用于统计去重后的结果
4、count的参数可以支持：
    字段、*、常量值，一般放1

   建议使用 count(*)</code></pre><h2 id="进阶5：分组查询"><a href="#进阶5：分组查询" class="headerlink" title="进阶5：分组查询"></a>进阶5：分组查询</h2><pre><code>语法：
select 查询的字段，分组函数
from 表
group by 分组的字段


特点：
1、可以按单个字段分组
2、和分组函数一同查询的字段最好是分组后的字段
3、分组筛选
        针对的表    位置            关键字
分组前筛选：    原始表        group by的前面        where
分组后筛选：    分组后的结果集    group by的后面        having

4、可以按多个字段分组，字段之间用逗号隔开
5、可以支持排序
6、having后可以支持别名</code></pre><h2 id="进阶6：多表连接查询"><a href="#进阶6：多表连接查询" class="headerlink" title="进阶6：多表连接查询"></a>进阶6：多表连接查询</h2><pre><code>笛卡尔乘积：如果连接条件省略或无效则会出现
解决办法：添加上连接条件</code></pre><p>一、传统模式下的连接 ：等值连接——非等值连接</p>
<pre><code>1.等值连接的结果 = 多个表的交集
2.n表连接，至少需要n-1个连接条件
3.多个表不分主次，没有顺序要求
4.一般为表起别名，提高阅读性和性能</code></pre><p>二、sql99语法：通过join关键字实现连接</p>
<pre><code>含义：1999年推出的sql语法
支持：
等值连接、非等值连接 （内连接）
外连接
交叉连接

语法：

select 字段，...
from 表1
【inner|left outer|right outer|cross】join 表2 on  连接条件
【inner|left outer|right outer|cross】join 表3 on  连接条件
【where 筛选条件】
【group by 分组字段】
【having 分组后的筛选条件】
【order by 排序的字段或表达式】

好处：语句上，连接条件和筛选条件实现了分离，简洁明了！</code></pre><p>三、自连接</p>
<p>案例：查询员工名和直接上级的名称</p>
<p>sql99</p>
<pre><code>SELECT e.last_name,m.last_name
FROM employees e
JOIN employees m ON e.`manager_id`=m.`employee_id`;</code></pre><p>sql92</p>
<pre><code>SELECT e.last_name,m.last_name
FROM employees e,employees m 
WHERE e.`manager_id`=m.`employee_id`;</code></pre><h2 id="进阶7：子查询"><a href="#进阶7：子查询" class="headerlink" title="进阶7：子查询"></a>进阶7：子查询</h2><p>含义：</p>
<pre><code>一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询
在外面的查询语句，称为主查询或外查询</code></pre><p>特点：</p>
<pre><code>1、子查询都放在小括号内
2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧
3、子查询优先于主查询执行，主查询使用了子查询的执行结果
4、子查询根据查询结果的行数不同分为以下两类：
① 单行子查询
    结果集只有一行
    一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;= 
    非法使用子查询的情况：
    a、子查询的结果为一组值
    b、子查询的结果为空

② 多行子查询
    结果集有多行
    一般搭配多行操作符使用：any、all、in、not in
    in： 属于子查询结果中的任意一个就行
    any和all往往可以用其他查询代替</code></pre><h2 id="进阶8：分页查询"><a href="#进阶8：分页查询" class="headerlink" title="进阶8：分页查询"></a>进阶8：分页查询</h2><p>应用场景：</p>
<pre><code>实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句</code></pre><p>语法：</p>
<pre><code>select 字段|表达式,...
from 表
【where 条件】
【group by 分组字段】
【having 条件】
【order by 排序的字段】
limit 【起始的条目索引，】条目数;</code></pre><p>特点：</p>
<pre><code>1.起始条目索引从0开始

2.limit子句放在查询语句的最后

3.公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage
假如:
每页显示条目数sizePerPage
要显示的页数 page</code></pre><h2 id="进阶9：联合查询"><a href="#进阶9：联合查询" class="headerlink" title="进阶9：联合查询"></a>进阶9：联合查询</h2><p>引入：<br>    union 联合、合并</p>
<p>语法：</p>
<pre><code>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】
select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】
select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】
.....
select 字段|常量|表达式|函数 【from 表】 【where 条件】</code></pre><p>特点：</p>
<pre><code>1、多条查询语句的查询的列数必须是一致的
2、多条查询语句的查询的列的类型几乎相同
3、union代表去重，union all代表不去重</code></pre><h2 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>语法：<br>    insert into 表名(字段名，…)<br>    values(值1，…);</p>
<p>特点：</p>
<pre><code>1、字段类型和值类型一致或兼容，而且一一对应
2、可以为空的字段，可以不用插入值，或用null填充
3、不可以为空的字段，必须插入值
4、字段个数和值的个数必须一致
5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致</code></pre><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>修改单表语法：</p>
<pre><code>update 表名 set 字段=新值,字段=新值
【where 条件】</code></pre><p>修改多表语法：</p>
<pre><code>update 表1 别名1,表2 别名2
set 字段=新值，字段=新值
where 连接条件
and 筛选条件</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>方式1：delete语句 </p>
<p>单表的删除： ★<br>    delete from 表名 【where 筛选条件】</p>
<p>多表的删除：<br>    delete 别名1，别名2<br>    from 表1 别名1，表2 别名2<br>    where 连接条件<br>    and 筛选条件;</p>
<p>方式2：truncate语句</p>
<pre><code>truncate table 表名</code></pre><p>两种方式的区别【面试题】</p>
<pre><code>#1.truncate不能加where条件，而delete可以加where条件

#2.truncate的效率高一丢丢

#3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始
#delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始

#4.truncate删除不能回滚，delete删除可以回滚</code></pre><h2 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h2><h3 id="库和表的管理"><a href="#库和表的管理" class="headerlink" title="库和表的管理"></a>库和表的管理</h3><p>库的管理：</p>
<pre><code>一、创建库
create database 库名
二、删除库
drop database 库名</code></pre><p>表的管理：<br>    #1.创建表</p>
<pre><code>CREATE TABLE IF NOT EXISTS stuinfo(
    stuId INT,
    stuName VARCHAR(20),
    gender CHAR,
    bornDate DATETIME


);

DESC studentinfo;
#2.修改表 alter
语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;

#①修改字段名
ALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;

#②修改表名
ALTER TABLE stuinfo RENAME [TO]  studentinfo;
#③修改字段类型和列级约束
ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;

#④添加字段

ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;
#⑤删除字段
ALTER TABLE studentinfo DROP COLUMN email;


#3.删除表

DROP TABLE [IF EXISTS] studentinfo;</code></pre><h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><pre><code>整型：

小数：
    浮点型
    定点型
字符型：
日期型：
Blob类型：</code></pre><h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><pre><code>NOT NULL
DEFAULT
UNIQUE
CHECK
PRIMARY KEY
FOREIGN KEY</code></pre><h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><pre><code>通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态</code></pre><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><pre><code>（ACID）
原子性：要么都执行，要么都回滚
一致性：保证数据的状态操作前和操作后保持一致
隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰
持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改</code></pre><p>相关步骤：</p>
<pre><code>1、开启事务
2、编写事务的一组逻辑操作单元（多条sql语句）
3、提交事务或回滚事务</code></pre><h3 id="事务的分类："><a href="#事务的分类：" class="headerlink" title="事务的分类："></a>事务的分类：</h3><p>隐式事务，没有明显的开启和结束事务的标志</p>
<pre><code>比如
insert、update、delete语句本身就是一个事务</code></pre><p>显式事务，具有明显的开启和结束事务的标志</p>
<pre><code>1、开启事务
取消自动提交事务的功能

2、编写事务的一组逻辑操作单元（多条sql语句）
insert
update
delete

3、提交事务或回滚事务</code></pre><h3 id="使用到的关键字"><a href="#使用到的关键字" class="headerlink" title="使用到的关键字"></a>使用到的关键字</h3><pre><code>set autocommit=0;
start transaction;
commit;
rollback;

savepoint  断点
commit to 断点
rollback to 断点</code></pre><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别:"></a>事务的隔离级别:</h3><p>事务并发问题如何发生？</p>
<pre><code>当多个事务同时操作同一个数据库的相同数据时</code></pre><p>事务的并发问题有哪些？</p>
<pre><code>脏读：一个事务读取到了另外一个事务未提交的数据
不可重复读：同一个事务中，多次读取到的数据不一致
幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据</code></pre><p>如何避免事务的并发问题？</p>
<pre><code>通过设置事务的隔离级别
1、READ UNCOMMITTED
2、READ COMMITTED 可以避免脏读
3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读
4、SERIALIZABLE可以避免脏读、不可重复读和幻读</code></pre><p>设置隔离级别：</p>
<pre><code>set session|global  transaction isolation level 隔离级别名;</code></pre><p>查看隔离级别：</p>
<pre><code>select @@tx_isolation;</code></pre><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>含义：理解成一张虚拟的表</p>
<p>视图和表的区别：</p>
<pre><code>    使用方式    占用物理空间

视图    完全相同    不占用，仅仅保存的是sql逻辑

表    完全相同    占用</code></pre><p>视图的好处：</p>
<pre><code>1、sql语句提高重用性，效率高
2、和表实现了分离，提高了安全性</code></pre><h3 id="视图的创建"><a href="#视图的创建" class="headerlink" title="视图的创建"></a>视图的创建</h3><pre><code>语法：
CREATE VIEW  视图名
AS
查询语句;</code></pre><h3 id="视图的增删改查"><a href="#视图的增删改查" class="headerlink" title="视图的增删改查"></a>视图的增删改查</h3><pre><code>1、查看视图的数据 ★

SELECT * FROM my_v4;
SELECT * FROM my_v1 WHERE last_name=&apos;Partners&apos;;

2、插入视图的数据
INSERT INTO my_v4(last_name,department_id) VALUES(&apos;虚竹&apos;,90);

3、修改视图的数据

UPDATE my_v4 SET last_name =&apos;梦姑&apos; WHERE last_name=&apos;虚竹&apos;;


4、删除视图的数据
DELETE FROM my_v4;</code></pre><h3 id="某些视图不能更新"><a href="#某些视图不能更新" class="headerlink" title="某些视图不能更新"></a>某些视图不能更新</h3><pre><code>包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all
常量视图
Select中包含子查询
join
from一个不能更新的视图
where子句的子查询引用了from子句中的表</code></pre><h3 id="视图逻辑的更新"><a href="#视图逻辑的更新" class="headerlink" title="视图逻辑的更新"></a>视图逻辑的更新</h3><pre><code>#方式一：
CREATE OR REPLACE VIEW test_v7
AS
SELECT last_name FROM employees
WHERE employee_id&gt;100;

#方式二:
ALTER VIEW test_v7
AS
SELECT employee_id FROM employees;

SELECT * FROM test_v7;</code></pre><h3 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h3><pre><code>DROP VIEW test_v1,test_v2,test_v3;</code></pre><h3 id="视图结构的查看"><a href="#视图结构的查看" class="headerlink" title="视图结构的查看"></a>视图结构的查看</h3><pre><code>DESC test_v7;
SHOW CREATE VIEW test_v7;</code></pre><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>含义：一组经过预先编译的sql语句的集合<br>好处：</p>
<pre><code>1、提高了sql语句的重用性，减少了开发程序员的压力
2、提高了效率
3、减少了传输次数</code></pre><p>分类：</p>
<pre><code>1、无返回无参
2、仅仅带in类型，无返回有参
3、仅仅带out类型，有返回无参
4、既带in又带out，有返回有参
5、带inout，有返回有参
注意：in、out、inout都可以在一个存储过程中带多个</code></pre><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><p>语法：</p>
<pre><code>create procedure 存储过程名(in|out|inout 参数名  参数类型,...)
begin
    存储过程体

end</code></pre><p>类似于方法：</p>
<pre><code>修饰符 返回类型 方法名(参数类型 参数名,...){

    方法体;
}</code></pre><p>注意</p>
<pre><code>1、需要设置新的结束标记
delimiter 新的结束标记
示例：
delimiter $

CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)
BEGIN
    sql语句1;
    sql语句2;

END $

2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end

3、参数前面的符号的意思
in:该参数只能作为输入 （该参数不能做返回值）
out：该参数只能作为输出（该参数只能做返回值）
inout：既能做输入又能做输出</code></pre><p>#调用存储过程<br>    call 存储过程名(实参列表)</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><p>学过的函数：LENGTH、SUBSTR、CONCAT等<br>语法：</p>
<pre><code>CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型
BEGIN
    函数体

END</code></pre><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><pre><code>SELECT 函数名（实参列表）</code></pre><h3 id="函数和存储过程的区别"><a href="#函数和存储过程的区别" class="headerlink" title="函数和存储过程的区别"></a>函数和存储过程的区别</h3><pre><code>        关键字        调用语法    返回值            应用场景
函数        FUNCTION    SELECT 函数()    只能是一个        一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个
存储过程    PROCEDURE    CALL 存储过程()    可以有0个或多个        一般用于更新</code></pre><h2 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h2><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>一、全局变量</p>
<p>作用域：针对于所有会话（连接）有效，但不能跨重启</p>
<pre><code>查看所有全局变量
SHOW GLOBAL VARIABLES;
查看满足条件的部分系统变量
SHOW GLOBAL VARIABLES LIKE &apos;%char%&apos;;
查看指定的系统变量的值
SELECT @@global.autocommit;
为某个系统变量赋值
SET @@global.autocommit=0;
SET GLOBAL autocommit=0;</code></pre><p>二、会话变量</p>
<p>作用域：针对于当前会话（连接）有效</p>
<pre><code>查看所有会话变量
SHOW SESSION VARIABLES;
查看满足条件的部分会话变量
SHOW SESSION VARIABLES LIKE &apos;%char%&apos;;
查看指定的会话变量的值
SELECT @@autocommit;
SELECT @@session.tx_isolation;
为某个会话变量赋值
SET @@session.tx_isolation=&apos;read-uncommitted&apos;;
SET SESSION tx_isolation=&apos;read-committed&apos;;</code></pre><h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><p>一、用户变量</p>
<p>声明并初始化：</p>
<pre><code>SET @变量名=值;
SET @变量名:=值;
SELECT @变量名:=值;</code></pre><p>赋值：</p>
<pre><code>方式一：一般用于赋简单的值
SET 变量名=值;
SET 变量名:=值;
SELECT 变量名:=值;


方式二：一般用于赋表 中的字段值
SELECT 字段名或表达式 INTO 变量
FROM 表;</code></pre><p>使用：</p>
<pre><code>select @变量名;</code></pre><p>二、局部变量</p>
<p>声明：</p>
<pre><code>declare 变量名 类型 【default 值】;</code></pre><p>赋值：</p>
<pre><code>方式一：一般用于赋简单的值
SET 变量名=值;
SET 变量名:=值;
SELECT 变量名:=值;


方式二：一般用于赋表 中的字段值
SELECT 字段名或表达式 INTO 变量
FROM 表;</code></pre><p>使用：</p>
<pre><code>select 变量名</code></pre><p>二者的区别：</p>
<pre><code>作用域            定义位置        语法</code></pre><p>用户变量    当前会话        会话的任何地方        加@符号，不用指定类型<br>局部变量    定义它的BEGIN END中     BEGIN END的第一句话    一般不用加@,需要指定类型</p>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>一、if函数<br>    语法：if(条件，值1，值2)<br>    特点：可以用在任何位置</p>
<p>二、case语句</p>
<p>语法：</p>
<pre><code>情况一：类似于switch
case 表达式
when 值1 then 结果1或语句1(如果是语句，需要加分号) 
when 值2 then 结果2或语句2(如果是语句，需要加分号)
...
else 结果n或语句n(如果是语句，需要加分号)
end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）

情况二：类似于多重if
case 
when 条件1 then 结果1或语句1(如果是语句，需要加分号) 
when 条件2 then 结果2或语句2(如果是语句，需要加分号)
...
else 结果n或语句n(如果是语句，需要加分号)
end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）</code></pre><p>特点：<br>    可以用在任何位置</p>
<p>三、if elseif语句</p>
<p>语法：</p>
<pre><code>if 情况1 then 语句1;
elseif 情况2 then 语句2;
...
else 语句n;
end if;</code></pre><p>特点：<br>    只能用在begin end中！！！！！！！！！！！！！！！</p>
<p>三者比较：<br>            应用场合<br>    if函数        简单双分支<br>    case结构    等值判断 的多分支<br>    if结构        区间判断 的多分支</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>语法：</p>
<pre><code>【标签：】WHILE 循环条件  DO
    循环体
END WHILE 【标签】;</code></pre><p>特点：</p>
<pre><code>只能放在BEGIN END里面

如果要搭配leave跳转语句，需要使用标签，否则可以不用标签

leave类似于java中的break语句，跳出所在循环！！！</code></pre>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统</title>
    <url>/2020/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="MYQSL基础"><a href="#MYQSL基础" class="headerlink" title="MYQSL基础"></a><a href="/2020/01/20/MySQL基础">MYQSL基础</a></h2><h2 id="DB第3章"><a href="#DB第3章" class="headerlink" title="DB第3章"></a><a href="/2020/01/20/DB第3章/">DB第3章</a></h2><h2 id="DB第4章"><a href="#DB第4章" class="headerlink" title="DB第4章"></a><a href="/2020/01/20/DB第4章/">DB第4章</a></h2><h2 id="DB第5章"><a href="#DB第5章" class="headerlink" title="DB第5章"></a><a href="/2020/01/20/DB第5章/">DB第5章</a></h2><h2 id="DB第6章"><a href="#DB第6章" class="headerlink" title="DB第6章"></a><a href="/2020/01/20/DB第6章/">DB第6章</a></h2><h2 id="DB第7章"><a href="#DB第7章" class="headerlink" title="DB第7章"></a><a href="/2020/01/20/DB第7章/">DB第7章</a></h2>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>DB第5章</title>
    <url>/2020/01/20/DB%E7%AC%AC5%E7%AB%A0/</url>
    <content><![CDATA[<ol>
<li>数据库的完整性：防止数据库中出现不合语义数据。</li>
<li>完整性控制机制：<ol>
<li>完整性约束条件定义机制。</li>
<li>完整性检查机</li>
<li>违约处理.</li>
</ol>
</li>
<li>关系型数据库的三类完整性约束：实体完整性、参照完整性、用户定义完整性。</li>
</ol>
<h1 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h1><ol>
<li>实体完整性定义：<ol>
<li>单属性构成的码：定义为列级或表级约束条件。</li>
<li>多属性构成的码：只可定义为表级约束条件。</li>
</ol>
</li>
<li>实体完整性检查和违约处理<ol>
<li>检查主码是否唯一；检查主码的各个属性值是否为空。</li>
</ol>
</li>
</ol>
<h1 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h1><ol>
<li>参照完整性定义：若属性F是基本关系R的外码，它与基本关系S的码Ks相对应，则对于R中每个元组在F上的取值必须满足<ol>
<li>参照关系R和被参照关系S不一定是不同的关系。</li>
<li>外码中若有多个属性，若其一为NULL，则需全NULL。</li>
</ol>
</li>
</ol>
<h1 id="用户定义完整性"><a href="#用户定义完整性" class="headerlink" title="用户定义完整性"></a>用户定义完整性</h1><ol>
<li>使用CHECK见本。</li>
</ol>
<h1 id="完整性约束命名子句"><a href="#完整性约束命名子句" class="headerlink" title="完整性约束命名子句"></a>完整性约束命名子句</h1><ol>
<li>CONSTRAINT</li>
</ol>
<h1 id="域中的完整性限制"><a href="#域中的完整性限制" class="headerlink" title="域中的完整性限制"></a>域中的完整性限制</h1><p>CREATE DOMAIN,DOMAIN相当于一个自定义的数据类型。</p>
<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><ol>
<li><p>触发器：用户定义在关系表上的 一类由事件驱动的特殊存储过程</p>
 <img src="/DB_img/U5/1.png" style="zoom:80%"></li>
<li><p>注</p>
<ol>
<li>触发器可以在触发事件之前或之后执行。</li>
<li>触发事件为INSERT/DELETE/UPDATE（SELECT不触发）</li>
<li>分为行级触发器和语句级触发器</li>
<li>触发器被激活时，执行触发体。</li>
<li>同一个表上的触发器，先执行BEFORE触发器，再执行SQL，再执行AFTER触发器。</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>DB第4章</title>
    <url>/2020/01/20/DB%E7%AC%AC4%E7%AB%A0/</url>
    <content><![CDATA[<p>数据库的安全性是指保护数据库，防止因用户非法使用数据库造成数据泄漏、更改或破坏。</p>
<p>数据库系统的安全：包括计算机安全和数据库安全。</p>
<h1 id="数据库安全性控制"><a href="#数据库安全性控制" class="headerlink" title="数据库安全性控制"></a>数据库安全性控制</h1><p>数据库安全性控制的常用方法：用户标识和鉴定、存取控制、视图、审计、数据加密。</p>
<h2 id="用户标识与鉴别"><a href="#用户标识与鉴别" class="headerlink" title="用户标识与鉴别"></a>用户标识与鉴别</h2><ol>
<li>用户标识与鉴别是系统提供的最外层安全保护措施。</li>
<li>基本方法：系统通过一定方式让用户标识自己的身份或名字。</li>
</ol>
<h2 id="自主存取控制-授权与回收"><a href="#自主存取控制-授权与回收" class="headerlink" title="自主存取控制-授权与回收"></a>自主存取控制-授权与回收</h2><h3 id="存取控制机制的功能"><a href="#存取控制机制的功能" class="headerlink" title="存取控制机制的功能"></a>存取控制机制的功能</h3><ol>
<li>存取控制机制的组成：<ol>
<li>定义存取权限</li>
<li>检查存取权限</li>
</ol>
</li>
<li>用户权限定义和合法权检查机制一起组成了DBMS的安全子系统</li>
</ol>
<h3 id="常用存取控制方法"><a href="#常用存取控制方法" class="headerlink" title="常用存取控制方法"></a>常用存取控制方法</h3><ol>
<li>自主存取控制：<ol>
<li>同一用户对不同对象有不同的存储权限。</li>
<li>不同用户对同一对象也有不同的存储权限。</li>
<li>用户还可以将其拥有的存储权限转授给其他用户。</li>
<li><strong>优点</strong>：能够通过授权机制有效的控制其他用户对敏感数据的存取。</li>
<li><strong>缺点</strong>：<ol>
<li>可能存在数据的无意泄漏。</li>
<li><strong>原因</strong>：这种机制仅仅通过对数据的存取权限来进行安全控制，而对数据本身并无安全性标记。</li>
<li><strong>解决</strong>：对系统控制下的所有主客体实施强制存取控制。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="授权与回收"><a href="#授权与回收" class="headerlink" title="授权与回收"></a>授权与回收</h3><ol>
<li>授权语法：见本</li>
<li>注意：<ol>
<li>DBA拥有数据库操作的所有权限，可以将权限赋给其他用户。</li>
<li>建立数据库对象的的用户称为该对象的属主，他拥有该对象的所有操作权限。</li>
<li>授权给全体用户是PUBLI</li>
<li>C。</li>
<li>若指定了WITH GRANT OPTION子句，则获得某种权限的用户还可以把这种权限再授予别的用户。否则，不能传播该权限。</li>
</ol>
</li>
<li>回收权限REVOKE</li>
<li>授权图：用户拥有授权当且仅当存在从授权图的根到代表该用户的节点的路径。</li>
</ol>
<h3 id="数据库角色：被命名的一组与数据库操作相关的权限。"><a href="#数据库角色：被命名的一组与数据库操作相关的权限。" class="headerlink" title="数据库角色：被命名的一组与数据库操作相关的权限。"></a>数据库角色：被命名的一组与数据库操作相关的权限。</h3><ol>
<li><p>数据库角色</p>
<ol>
<li>角色是权限的集合。</li>
<li>可以为一组具有相同权限的用户创建一个角色。</li>
</ol>
</li>
<li><p>相关语法：见本</p>
</li>
</ol>
<h3 id="权限总结"><a href="#权限总结" class="headerlink" title="权限总结"></a>权限总结</h3><ol>
<li>DBA拥有对数据库中所有对象的所有权限，并可以根据应用<br>的需要将不同的权限授予不同的用户；</li>
<li>用户对自己建立的基本表和视图拥有全部的操作权限，并且<br>可以用GRANT语句把其中某些权限授予其他用户；</li>
<li>被授权的用户如果有“继续授权”的许可，还可以把获得的<br>权限再授予其他用户；</li>
<li>所有授予出去的权力在必要时可以用REVOKE语句收回；</li>
<li>使用角色管理数据库可以简化授权的过程；</li>
</ol>
<h2 id="强制存取控制"><a href="#强制存取控制" class="headerlink" title="强制存取控制"></a>强制存取控制</h2><ol>
<li>强制存取控制：<ol>
<li>对每一个数据对象都标以一定的密级。</li>
<li>对每一个用户都授予一个级别的许可证。</li>
<li>对于任意的一个对象，只有具有合法许可证的用户才能存取。</li>
</ol>
</li>
<li>敏感度标记： 绝密（Top Secret、机密（Secret）、秘密（Confidential）、公开（Public）。</li>
<li>强制存取控制规则<ol>
<li>仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体。</li>
<li>仅当主体的许可证级别等于客体的密级时，主体才能写相应客体。</li>
</ol>
</li>
<li>DAC和MAC关系<ol>
<li>二者共同构成DBMS的安全机制。因为较高安全性级别提供的安全保护要包含较低级别的所有保护。</li>
<li>安全性检查，要先进行DAC检查，通过DAC检查的数据对象再由系统进行MAC检查，只有都通过的才能进行存取。</li>
</ol>
</li>
</ol>
<h2 id="视图机制"><a href="#视图机制" class="headerlink" title="视图机制"></a>视图机制</h2><ol>
<li>视图机制与授权机制配合使用共同提供安全性。<ol>
<li>先用视图屏蔽掉一部分保密数据。</li>
<li>再进一步在视图上定义存取权限。</li>
<li>间接实现了支持存取谓词的用户权限定义。</li>
</ol>
</li>
</ol>
<h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><ol>
<li>审计：将用户对数据库的所有操作记录在上面。</li>
</ol>
<h2 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h2><ol>
<li>加密方法<ol>
<li>替换方法：将明文中的每一个字符都转换维密文中的每一个字符。</li>
<li>置换方法：将明文的字符按不同的顺序重新排列。</li>
<li>混合方法</li>
</ol>
</li>
</ol>
<h1 id="统计数据库安全性"><a href="#统计数据库安全性" class="headerlink" title="统计数据库安全性"></a>统计数据库安全性</h1><ol>
<li>统计数据库的特点<ol>
<li>允许用户查询聚集类型信息。</li>
<li>不允许查询单个记录信息。</li>
</ol>
</li>
<li>统计数据库的问题<ol>
<li>隐藏的信息通道</li>
<li>从合法的查询中推导出不合法的信息。</li>
</ol>
</li>
<li>统计数据库的规则<ol>
<li>任何查询至少要涉及N（N足够大）个以上的记录。</li>
<li>任意两个查询的相交数据项不能超过M个。</li>
<li>任一用户的查询次数不能超过1+(N-2)/M次。</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>DB第7章</title>
    <url>/2020/01/20/DB%E7%AC%AC7%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="数据库的设计方法"><a href="#数据库的设计方法" class="headerlink" title="数据库的设计方法"></a>数据库的设计方法</h1><ol>
<li>新奥尔良法:将数据库设计分为四个阶段：需求分析、概念设计、逻辑设计和物理设计。</li>
<li>基于ER模型的设计方法：使用ER模型来设计数据库的概念模型。</li>
<li>3NF的设计方法：用关系数据理论指导逻辑模型的设计。</li>
<li>ODL方法：用面向对象的概念和属于来说明数据库结构。</li>
</ol>
<h2 id="数据库设计中的各级模式"><a href="#数据库设计中的各级模式" class="headerlink" title="数据库设计中的各级模式"></a>数据库设计中的各级模式</h2><img src="/DB_img/U7/1.png">

<h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>需求分析的重点是调查、收集与分析用户在数据管理中的信息要求、处理要求、安全性与完整性要求。</p>
<h2 id="需求信息的收集"><a href="#需求信息的收集" class="headerlink" title="需求信息的收集"></a>需求信息的收集</h2><p>即了解用户的组织机构设置、主要业务活动和职能及对新系统的要求。</p>
<h2 id="需求信息的分析"><a href="#需求信息的分析" class="headerlink" title="需求信息的分析"></a>需求信息的分析</h2><p>步骤</p>
<h3 id="确定系统边界"><a href="#确定系统边界" class="headerlink" title="确定系统边界"></a>确定系统边界</h3><h3 id="业务流程分析"><a href="#业务流程分析" class="headerlink" title="业务流程分析"></a>业务流程分析</h3><p>使用数据流图</p>
<ol>
<li><p>表达方式</p>
<ol>
<li><p>圆圈：表示一次处理过程</p>
</li>
<li><p>有向线：表示数据流</p>
</li>
<li><p>双线段：表示存储的信息</p>
<img src="/DB_img/U7/2.png">
</li>
</ol>
</li>
<li><p>分析方法</p>
<ol>
<li>自顶向下，逐层分解</li>
<li>先主干后分支</li>
</ol>
</li>
<li><p>建立<strong>数据字典</strong></p>
<ol>
<li>数据字典是各类数据描述的集合，通常以表格的形式详细地描述业务处理过程中用到的各类数据</li>
<li>数据字典的内容包括数据项、数据结构、数据流、数据存储、处理过程等五部分。</li>
<li>数据流：可以是数据项，也可以是数据结构，表示数据的来源和去向。</li>
<li>数据存储：xx表。包括数据存储名、说明、输入数据流、输出数据流、组成成份、数据量、存取方式、存取频度等。</li>
<li>处理过程：加工处理过程定义和说明。</li>
</ol>
</li>
</ol>
<h1 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h1><p>概念结构设计就是将现实事物以不依赖于任何数据模<br>型的方式加以描述，目的在于以符号化的形式正确地反映<br>现实事物及事物与事物间的联系。概念结构设计的内容就<br>是建立概念模型。</p>
<h2 id="概念结构设计四种策略"><a href="#概念结构设计四种策略" class="headerlink" title="概念结构设计四种策略"></a>概念结构设计四种策略</h2><h3 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h3><p>即首先定义全局概念结构的框架，然后逐步细化。</p>
<h3 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h3><p>即首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构。</p>
<h3 id="逐步扩张"><a href="#逐步扩张" class="headerlink" title="逐步扩张"></a>逐步扩张</h3><p>即首先确定核心业务的概念结构，然后以此为中心向外扩张，最终实现全局概念结构。</p>
<h3 id="混合策略"><a href="#混合策略" class="headerlink" title="混合策略"></a>混合策略</h3><p>即将自顶向下和自底向上两种策略结合使用，首先确定全局框架，划分为若干个局部概念模型，再采取自底向上的策略实现各局部概念模型，加以合并实现全局概念模型。</p>
<h2 id="抽象现实事物的三种方法"><a href="#抽象现实事物的三种方法" class="headerlink" title="抽象现实事物的三种方法"></a>抽象现实事物的三种方法</h2><p>分类；聚集；概括</p>
<h2 id="设计局部视图"><a href="#设计局部视图" class="headerlink" title="设计局部视图"></a>设计局部视图</h2><p>步骤</p>
<h3 id="选择局部应用"><a href="#选择局部应用" class="headerlink" title="选择局部应用"></a>选择局部应用</h3><h3 id="设计分E-R图"><a href="#设计分E-R图" class="headerlink" title="设计分E-R图"></a>设计分E-R图</h3><h2 id="确定实体与属性的两条准则"><a href="#确定实体与属性的两条准则" class="headerlink" title="确定实体与属性的两条准则"></a>确定实体与属性的两条准则</h2><ol>
<li>属性是不可再分的数据项，属性不可以再有属性</li>
<li>属性不能与其他实体发生联系，联系只能存在于实体与<br>实体之间</li>
<li>例如职工(职工号，姓名，年龄，职称)，其中的职称如果<br>与工资、住房和福利挂勾(即有联系)，则应该单独作为<br>实体，而职工与职称间构成联系</li>
</ol>
<h2 id="视图集成"><a href="#视图集成" class="headerlink" title="视图集成"></a>视图集成</h2><img src="/DB_img/U7/4.png">

<p>选择两个具有相同实体的E-R图，通过相同实体将两个ER图连结起来构成一个E-R图，然后再与其它E-R图连结直到将<br>所有的局部E-R图全部连结成一个E-R图，称为全局E-R图</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>可以完整地描述企业的信息及其联系</li>
<li>另一方面在集成过程中可以解决冲突和消除冗余。</li>
</ol>
<h3 id="分E-R图之间的三类冲突"><a href="#分E-R图之间的三类冲突" class="headerlink" title="分E-R图之间的三类冲突"></a>分E-R图之间的三类冲突</h3><ol>
<li>属性冲突</li>
<li>命名冲突</li>
<li>结构冲突：同一对象在某一分E-R图中被抽象为实体而在另一分E-R图中又被抽象为属性，需要统一。</li>
</ol>
<h3 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h3><p>注意从一个实体到另一个实体存在多条路的情况，要检查能否消除冗余。</p>
<h1 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h1>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>DB第6章</title>
    <url>/2020/01/20/DB%E7%AC%AC6%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="关系模式设计引论"><a href="#关系模式设计引论" class="headerlink" title="关系模式设计引论"></a>关系模式设计引论</h1><h2 id="关系的外延和内涵"><a href="#关系的外延和内涵" class="headerlink" title="关系的外延和内涵"></a>关系的外延和内涵</h2><ol>
<li>外延：关系模型的值，即关系模型中的数据，是动态的。</li>
<li>内涵：对关系、属性、域的定义和说明，即关系模型的定义。</li>
</ol>
<img src="/DB_img/U6/1.png" >

<h2 id="关系模式的存储异常"><a href="#关系模式的存储异常" class="headerlink" title="关系模式的存储异常"></a>关系模式的存储异常</h2><p>例：描述学校的数据库有如下属性：<br>学生的学号(Sno)、所在系(Sdept)、系主任姓名(Mname)、课<br>程名(Cname)、成绩(Grade)<br>关系模式 ：Student ( Sno, Sdept, Mname, Cname, Grade )</p>
<ol>
<li><strong>问题</strong>：<ol>
<li>数据冗余太大：每行中系主任的姓名重复出现。</li>
<li>更新异常：假如某系更换主任后，系统必须修改所有与该系相关的学生。</li>
<li>插入异常：对于新成立的系中没有学生，也无法把主任存入。</li>
<li>删除异常：如果某个系学生全部毕业了，删除学生的同时，该系主任也没了。</li>
</ol>
</li>
<li><strong>原因</strong> 由于各属性见存在某些依赖关系</li>
<li><strong>解决</strong> 通过模式分解，分解为两个关系模式Student ( Sno, Sdept,<br>Cname, Grade )和 Dept ( Sdept, Mname ) 。</li>
</ol>
<h1 id="规范化（函数依赖"><a href="#规范化（函数依赖" class="headerlink" title="规范化（函数依赖)"></a>规范化（函数依赖)</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p>函数依赖（简称FD）<br> 设R(U)是一个属性集U上的关系模式，X和Y是U的<br> 子集。若对于R(U)的任意一个可能的关系r，r中不可能<br> 存在两个元组在X上的属性值相等， 而在Y上的属性值<br> 不等， 则称 “X函数确定Y” 或 “Y函数依赖于X”，记<br> 作X→Y(读作X决定Y)。X称为这个函数依赖的决定因素<br> (Determinant)。</p>
<p> 说明：</p>
<pre><code>1. 函数依赖不是指关系模式R的某个或某些关系实例满足的约束条件，而是指R的所有关系实例均要满足的约束条件。
2. 函数依赖是语义范畴的概念。只能根据数据的语义来确定函数依赖。</code></pre></li>
<li><p><strong>几种特殊的函数依赖</strong>：在关系模式R(U)中，对于U的子集X和Y</p>
<ol>
<li>若X→Y，但Y X，则称X→Y是非平凡的函数依赖</li>
<li>若X→Y，但Y  X，则称X→Y是平凡的函数依赖</li>
<li>若X→Y，并且Y→X，则记为X←→Y。(X与Y相互决定)</li>
<li>若Y不函数依赖于X，则记为X→Y。</li>
</ol>
</li>
<li><p><strong>完全函数依赖</strong></p>
 <img src="/DB_img/U6/2.png" ></li>
<li><p><strong>传递函数依赖</strong></p>
 <img src="/DB_img/U6/3.png" >
</li>
<li><p><strong>候选码</strong>：设K为关系模式R&lt;U, F&gt;中的属性或属性组。若K F<br>U，则K称为R的一个候选码(Candidate Key)。若关系模<br>式R有多个候选码，则选定其中的一个做为主码(Primary<br>key)。候选码常常简称为码。</p>
<ol>
<li>具有决定性和最小性。</li>
<li>主属性：<strong>所有</strong>候选码中出现的属性。</li>
<li>非主属性：不出现在候选码中的属性</li>
<li>全码：由关系模式的所有属性构成的码</li>
</ol>
</li>
<li><p><strong>外码</strong>：关系模式 R 中属性或属性组X 并非R 的码，但 X 是<br>另一个关系模式的码，则称 X 是R 的外部码(Foreign key),<br>也称外码。</p>
</li>
</ol>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><h3 id="一范式-保持列的原子性"><a href="#一范式-保持列的原子性" class="headerlink" title="一范式 保持列的原子性"></a>一范式 保持列的原子性</h3><p>如果一个关系模式R的所有属性都是不可分的基本<br>数据项，则称关系R为第一范式的关系模式(First Normal<br>Form)，简称关系R属于一范式，记为：R∈1NF。</p>
<h3 id="二范式-非主属性都完全依赖于-R-的候选键"><a href="#二范式-非主属性都完全依赖于-R-的候选键" class="headerlink" title="二范式 非主属性都完全依赖于 R 的候选键"></a>二范式 非主属性都完全依赖于 R 的候选键</h3><p>若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于R的码，则R∈2NF。</p>
<h3 id="三范式-非主属性都不传递依赖于-R-的候选键"><a href="#三范式-非主属性都不传递依赖于-R-的候选键" class="headerlink" title="三范式 非主属性都不传递依赖于 R 的候选键"></a>三范式 非主属性都不传递依赖于 R 的候选键</h3><p>属性不依赖于其它非主属性</p>
<p>主键和其他列有直接的联系</p>
<img src="/DB_img/U6/4.png" >

<ol>
<li><p>定理：满足三范式，则一定满足二范式。</p>
</li>
<li><p>证明</p>
 <img src="/DB_img/U6/5.png" >

</li>
</ol>
<h3 id="BCNF-每个属性都不传递依赖于-R-的候选键"><a href="#BCNF-每个属性都不传递依赖于-R-的候选键" class="headerlink" title="BCNF 每个属性都不传递依赖于 R 的候选键"></a>BCNF 每个属性都不传递依赖于 R 的候选键</h3><p>所有函数依赖关系中，自变量皆含有一个及以上的候选键</p>
<ol>
<li><p>多值依赖：在关系模式R(X,Y,Z)的任一关系r中，如果存在元组t,s，使得t[X]=s[X]，就必然存在元组w,v∈r，使得w[X]=v[X]=t[X] (=s[X])，而 w[Y]=t[Y], w[Z]=s[Z]; v[Y]=s[Y], v[Z]=t[Z] (即交换t,s在Y上的分量构成的新元组必然在r中)，则称Y多值依赖于X，记为X→→Y。 这里，X、Y、Z是U的子集，且Z=U-X-Y。</p>
<p> <strong>没有直接联系、但有间接的联系称为多值依赖的数据依赖。</strong></p>
<ol>
<li>类似于部分函数依赖，但是函数就是唯一确定的关系；多值依赖却不能唯一确定。</li>
<li>若X→→Y，而Z＝Ф，则称X→→Y为平凡的多值依赖，否则称X→→Y为非平凡的多值依赖。</li>
<li><strong>非平凡函数依赖，平凡多值依赖比较好</strong></li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>多值依赖的性质：</p>
 <img src="/DB_img/U6/6.png" >

 <img src="/DB_img/U6/7.png" ></li>
<li><p>多值依赖 &amp; 函数依赖</p>
 <img src="/DB_img/U6/8.png" >

 <img src="/DB_img/U6/9.png" >

</li>
</ol>
<p><a href=""https://blog.csdn.net/w2011212787/article/details/52351668"">函数依赖与多值依赖</a></p>
<img src="/DB_img/U6/11.png" >

<ol start="4">
<li>BCNF </li>
</ol>
<p>不存在任何字段对任一候选关键字段的传递函数依赖</p>
<p>如果有不依赖于候选码的其他函数依赖，则不满足BCNF</p>
<img src="/DB_img/U6/21.png" >

<h3 id="四范式-完全的一一对应"><a href="#四范式-完全的一一对应" class="headerlink" title="四范式 完全的一一对应"></a>四范式 完全的一一对应</h3><ol start="5">
<li>四范式是BCNF的子集</li>
</ol>
<img src="/DB_img/U6/10.png" >

<h1 id="公理系统"><a href="#公理系统" class="headerlink" title="公理系统"></a>公理系统</h1><h2 id="Armstrong-公理系统"><a href="#Armstrong-公理系统" class="headerlink" title="Armstrong 公理系统"></a>Armstrong 公理系统</h2><ol>
<li><p>公理系统</p>
 <img src="/DB_img/U6/12.png" >
</li>
<li><p>定律</p>
<ol>
<li>自反律：X能决定他的子集</li>
<li>增广律：若X-&gt;Y,那么XZ-&gt;YZ</li>
<li>传递律：若X-&gt;Y,Y-&gt;Z，则X-&gt;Z</li>
</ol>
</li>
<li><p>推理规则</p>
<ol>
<li>合并规则：若X-&gt;Y,X-&gt;，则X-&gt;YZ</li>
<li>分解规则：若X-&gt;Y,Z是Y的子集，那么X-&gt;Z</li>
<li>伪传递规则：若X-&gt;Y,WY-&gt;Z,则WX-&gt;Z</li>
</ol>
</li>
<li><p>定理：X-&gt;A1A2…Ak成立的充分必要条件是X-&gt;Ai成立(i=1,2,…,k)</p>
</li>
</ol>
<h2 id="函数依赖集的闭包"><a href="#函数依赖集的闭包" class="headerlink" title="函数依赖集的闭包"></a>函数依赖集的闭包</h2><ol>
<li>定义：在关系模式R&lt;U，F&gt;中为F所逻辑蕴含的函数依<br>赖的全体叫作 F的闭包(Closure)，记为F<sup>+</sup>。</li>
<li>F<sup>+</sup>的意义：包含了给定函数依赖集F(部分)所蕴含的属性集U上的全部函数依赖。但是依赖信息太多，难于利用。</li>
</ol>
<h2 id="属性集的闭包"><a href="#属性集的闭包" class="headerlink" title="属性集的闭包"></a>属性集的闭包</h2><ol>
<li><p>定义：设F为属性集U上的一组函数依赖，X是U的子集， X关于<br>函数依赖集F 的闭包(Closure of X under F ) X<sub>F</sub><sup>+</sup> ={ A |<br>X→A能由F 根据Armstrong公理导出}。</p>
</li>
<li><p>X<sub>F</sub><sup>+</sup>的求法</p>
 <img src="/DB_img/U6/13.png" >
</li>
<li><p>定理1：设F为属性集U上的一组函数依赖，X，Y 是U的子集， X→Y能由F 根据Armstrong公理导出的充分必要条件是Y 是X<sub>F</sub><sup>+</sup>的子集。</p>
</li>
<li><p>定理2：Armstrong公理系统是有效的、完备的。</p>
</li>
</ol>
<h2 id="最小函数依赖集"><a href="#最小函数依赖集" class="headerlink" title="最小函数依赖集"></a>最小函数依赖集</h2><ol>
<li><p>定义：假设在关系模式R&lt;U, F&gt;上有两个函数依赖集F和 G。如果F＋=G+，则称<strong>F和G是等价的，或称F与G相互覆盖。</strong></p>
</li>
<li><p>定理：F<sup>+</sup>=G<sup>+</sup>，当且仅当F是G<sup>+</sup>的子集且G是F<sup>+</sup>的子集。</p>
</li>
<li><p>如果函数依赖集F满足下列条件，则称F为一个<strong>极小函数依赖集</strong>。亦称为最小依赖集或最小覆盖。</p>
<ol>
<li>F中任一函数依赖的右部仅含有一个属性；</li>
<li>F中不存在这样的函数依赖X→A，使得F与F－{X→A}等价；(去除多余的函数依赖)</li>
<li>F中不存在这样的函数依赖X→A，X有真子集Z使得 (F－{X→A} )∪{Z→A}与F等价。（去除左部的冗余属性）</li>
</ol>
</li>
<li><p>最小函数依赖集的求解算法</p>
 <img src="/DB_img/U6/14.png" ></li>
<li><p>一个给定的函数依赖集F的最小函数集不是唯一的。</p>
</li>
</ol>
<h2 id="候选码求解算法"><a href="#候选码求解算法" class="headerlink" title="候选码求解算法"></a>候选码求解算法</h2><ol>
<li><p>注意</p>
<ol>
<li>码是可以确定一个元组的所有信息的属性名或属性名组，差不多理解为主键，并且主键加其他任意属性名也是码。</li>
<li>候选码的真子集中不存在码。</li>
<li>主码就是主键的意思，主码是任意一个候选码，注意是任意的一个。而且主码也可能是一个属性名组。</li>
</ol>
</li>
<li><p>对于给定的关系模式R&lt;U, F&gt;，依照函数依赖集F将U中的属性分为以下四类：</p>
<ol>
<li><p><strong>L类属性</strong>: 在F中只出现在函数依赖的左部的属性；</p>
</li>
<li><p><strong>R类属性</strong>: 在F中只出现在函数依赖的右部的属性；</p>
</li>
<li><p><strong>LR类属性</strong>: 分别出现在F中的函数依赖左部和右部的属性；</p>
</li>
<li><p><strong>N类属性</strong>: 不在F中的函数依赖中出现的属性。</p>
<p>有<strong>结论</strong></p>
</li>
<li><p>L类属性和N类属性必包含于任何候选码中；</p>
</li>
<li><p>R类属性必不包含于任何候选码中；</p>
</li>
<li><p>LR类属性不能确定是否在候选码中。</p>
</li>
</ol>
</li>
<li><p>算法</p>
 <img src="/DB_img/U6/15.png" >

 <img src="/DB_img/U6/16.png" >

 <img src="/DB_img/U6/17.png" >

 <img src="/DB_img/U6/18.png" >

</li>
</ol>
<h1 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h1><ol>
<li>目的：未来更好的存储，在使用中通过自然连接还原为分解前的关系模式。</li>
</ol>
<h2 id="无损连接性"><a href="#无损连接性" class="headerlink" title="无损连接性"></a>无损连接性</h2><p>要求自然连接后与原模式相同。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>就好像在模拟自然连接</p>
<p>过程见本。</p>
<h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>用于一分为二判定</p>
<ol>
<li><p>R分成R1和R2，具有无损连结性的充要条件是：U1∩U2-&gt;U1-U2属于F<sup>+</sup>或U1∩U2-&gt;U2-U1属于F<sup>+</sup>。</p>
</li>
<li><p>关系模式R&lt;U, D&gt;中，D为R中的函数依赖FD和多<br>值依赖MVD的集合。则X→→Y成立的充要条件是R的<br>分解ρ={ R1&lt;XY, F1&gt;，R2 &lt;XZ, F2&gt; }具有无损连接性，<br>其中Z=U－X－Y。</p>
</li>
</ol>
<h2 id="函数依赖性"><a href="#函数依赖性" class="headerlink" title="函数依赖性"></a>函数依赖性</h2><p>若原函数依赖的闭包和分解后函数依赖的闭包的和相等，那么就保持函数依赖性。</p>
<p>例题见本。</p>
<h2 id="模式分解结论"><a href="#模式分解结论" class="headerlink" title="模式分解结论"></a>模式分解结论</h2><ol>
<li>无损连结性和函数依赖性互不包含，可能只能满足其中一个。</li>
<li>无损连结性分解能达到4NF</li>
<li>函数依赖性分解可达到3NF，未必达到BCNF</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>DB第3章</title>
    <url>/2020/01/20/DB%E7%AC%AC3%E7%AB%A0/</url>
    <content><![CDATA[<img src="/DB_img/U3/1.png" style="zoom:80%">
<img src="/DB_img/U3/2.png" style="zoom:80%">
<img src="/DB_img/U3/3.png" style="zoom:80%">
<img src="/DB_img/U3/4.png" style="zoom:80%">
<img src="/DB_img/U3/5.png" style="zoom:80%">

<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><ol>
<li><p>普通索引：索引表的Search-key项中的<strong>每一索引值对应全部取该值的基本表中的记录</strong>。普通索引通过索引<br>表的指针项指向一个单链表来实现，该链表的每个结点的数<br>据项指向一条物理记录。</p>
</li>
<li><p>单一索引：<strong>每一个索引值只对应唯一的数据记录</strong>。当建立单一索引后，索引项不可以再插入已有值，但可<br>以插入多个空值，这等同于在建表时对索引列增加一个<br>UNIQUE约束；同样，当建立单一索引时，如果待索引项存<br>在相同值则不能建立。</p>
</li>
<li><p>聚簇索引：<strong>索引项顺序与表中数据记录的物理顺序一致。</strong>即基本表是按照索引表的Search-key项的排列次序<br>组织存储的，因此，一个基本表只能建立一个聚簇索引。<br>注：聚簇索引适应于很少对基本表进行增删操作和对变长列<br>进行修改操作的情况(?)。</p>
</li>
</ol>
<img src="/DB_img/U3/6.png" style="zoom:80%">

<img src="/DB_img/U3/7.png" style="zoom:80%">

<img src="/DB_img/U3/8.png" style="zoom:80%">

<img src="/DB_img/U3/9.png" style="zoom:80%">

<img src="/DB_img/U3/10.png" style="zoom:80%">

<img src="/DB_img/U3/11.png" style="zoom:80%">

<img src="/DB_img/U3/12.png" style="zoom:80%">

<img src="/DB_img/U3/13.png" style="zoom:80%">

<img src="/DB_img/U3/14.png" style="zoom:80%">

<img src="/DB_img/U3/15.png" style="zoom:80%">

<img src="/DB_img/U3/16.png" style="zoom:80%">

<img src="/DB_img/U3/17.png" style="zoom:80%">

<img src="/DB_img/U3/18.png" style="zoom:80%">

<img src="/DB_img/U3/19.png" style="zoom:80%">

<img src="/DB_img/U3/20.png" style="zoom:80%">

<img src="/DB_img/U3/21.png" style="zoom:80%">

<img src="/DB_img/U3/22.png" style="zoom:80%">]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉实验</title>
    <url>/2020/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="视觉第一次实验"><a href="#视觉第一次实验" class="headerlink" title="视觉第一次实验"></a><a href="https://github.com/Cccceb/BTF/tree/master/CV_Exp1">视觉第一次实验</a></h2><h2 id="视觉第二次实验"><a href="#视觉第二次实验" class="headerlink" title="视觉第二次实验"></a><a href="https://github.com/Cccceb/BTF/tree/master/CV_Exp2">视觉第二次实验</a></h2><h2 id="视觉第三次实验"><a href="#视觉第三次实验" class="headerlink" title="视觉第三次实验"></a><a href="https://github.com/Cccceb/BTF/tree/master/CV_Exp3">视觉第三次实验</a></h2><h2 id="视觉第四次实验"><a href="#视觉第四次实验" class="headerlink" title="视觉第四次实验"></a><a href="https://github.com/Cccceb/BTF/tree/master/CV_Exp4">视觉第四次实验</a></h2>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉</title>
    <url>/2020/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/</url>
    <content><![CDATA[<h2 id="视觉第1讲"><a href="#视觉第1讲" class="headerlink" title="视觉第1讲"></a><a href="/2020/01/20/视觉第1讲/">视觉第1讲</a></h2><h2 id="视觉第2讲"><a href="#视觉第2讲" class="headerlink" title="视觉第2讲"></a><a href="/2020/01/20/视觉第2讲/">视觉第2讲</a></h2><h2 id="视觉第3讲"><a href="#视觉第3讲" class="headerlink" title="视觉第3讲"></a><a href="/2020/01/20/视觉第3讲/">视觉第3讲</a></h2><h2 id="视觉第4讲"><a href="#视觉第4讲" class="headerlink" title="视觉第4讲"></a><a href="/2020/01/20/视觉第4讲/">视觉第4讲</a></h2><h2 id="视觉第5讲"><a href="#视觉第5讲" class="headerlink" title="视觉第5讲"></a><a href="/2020/01/20/视觉第5讲/">视觉第5讲</a></h2><h2 id="视觉第6讲"><a href="#视觉第6讲" class="headerlink" title="视觉第6讲"></a><a href="/2020/01/20/视觉第6讲/">视觉第6讲</a></h2><h2 id="视觉第7讲"><a href="#视觉第7讲" class="headerlink" title="视觉第7讲"></a><a href="/2020/01/20/视觉第7讲/">视觉第7讲</a></h2><h2 id="视觉第8讲"><a href="#视觉第8讲" class="headerlink" title="视觉第8讲"></a><a href="/2020/01/20/视觉第8讲/">视觉第8讲</a></h2><h2 id="视觉第9讲"><a href="#视觉第9讲" class="headerlink" title="视觉第9讲"></a><a href="/2020/01/20/视觉第9讲/">视觉第9讲</a></h2><h2 id="视觉第10讲"><a href="#视觉第10讲" class="headerlink" title="视觉第10讲"></a><a href="/2020/01/20/视觉第10讲/">视觉第10讲</a></h2><h2 id="视觉第11讲"><a href="#视觉第11讲" class="headerlink" title="视觉第11讲"></a><a href="/2020/01/20/视觉第11讲/">视觉第11讲</a></h2><h2 id="视觉第12讲"><a href="#视觉第12讲" class="headerlink" title="视觉第12讲"></a><a href="/2020/01/20/视觉第12讲/">视觉第12讲</a></h2><h2 id="视觉第13讲"><a href="#视觉第13讲" class="headerlink" title="视觉第13讲"></a><a href="/2020/01/20/视觉第13讲/">视觉第13讲</a></h2><h2 id="视觉第14讲"><a href="#视觉第14讲" class="headerlink" title="视觉第14讲"></a><a href="/2020/01/20/视觉第14讲/">视觉第14讲</a></h2><h2 id="视觉第15讲"><a href="#视觉第15讲" class="headerlink" title="视觉第15讲"></a><a href="/2020/01/20/视觉第15讲/">视觉第15讲</a></h2><h2 id="视觉第16讲"><a href="#视觉第16讲" class="headerlink" title="视觉第16讲"></a><a href="/2020/01/20/视觉第16讲/">视觉第16讲</a></h2><h2 id="视觉第17讲"><a href="#视觉第17讲" class="headerlink" title="视觉第17讲"></a><a href="/2020/01/20/视觉第17讲/">视觉第17讲</a></h2><h2 id="视觉第18讲"><a href="#视觉第18讲" class="headerlink" title="视觉第18讲"></a><a href="/2020/01/20/视觉第18讲/">视觉第18讲</a></h2><h2 id="视觉第19讲"><a href="#视觉第19讲" class="headerlink" title="视觉第19讲"></a><a href="/2020/01/20/视觉第19讲/">视觉第19讲</a></h2>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>目录</title>
    <url>/2020/01/20/%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h1 id="UVA习题"><a href="#UVA习题" class="headerlink" title="UVA习题"></a><a href="/2020/01/20/UVA习题笔记/">UVA习题</a></h1><h1 id="计算机安全导论"><a href="#计算机安全导论" class="headerlink" title="计算机安全导论"></a><a href="/2020/01/20/计算机安全导论/">计算机安全导论</a></h1><h1 id="IPtablesExp"><a href="#IPtablesExp" class="headerlink" title="IPtablesExp"></a><a href="/2020/01/20/IPtablesExp/">IPtablesExp</a></h1><h1 id="区块链技术"><a href="#区块链技术" class="headerlink" title="区块链技术"></a><a href="/2020/01/20/区块链技术/">区块链技术</a></h1><h1 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a><a href="/2020/01/20/计算机视觉/">计算机视觉</a></h1><h1 id="计算机视觉实验"><a href="#计算机视觉实验" class="headerlink" title="计算机视觉实验"></a><a href="/2020/01/20/计算机视觉实验/">计算机视觉实验</a></h1><h1 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a><a href="/2020/01/20/数据库系统/">数据库系统</a></h1><h1 id="公交管理系统"><a href="#公交管理系统" class="headerlink" title="公交管理系统"></a><a href="https://github.com/Cccceb/BTF/tree/master/DataBaseHomeWork">公交管理系统</a></h1><h1 id="微机原理"><a href="#微机原理" class="headerlink" title="微机原理"></a><a href="/2020/01/21/微机原理/">微机原理</a></h1><h1 id="考研机试"><a href="#考研机试" class="headerlink" title="考研机试"></a><a href="/2020/02/07/考研机试/">考研机试</a></h1><h1 id="CSP认证"><a href="#CSP认证" class="headerlink" title="CSP认证"></a><a href="/2020/02/25/ccf/">CSP认证</a></h1><h1 id="Python可视化"><a href="#Python可视化" class="headerlink" title="Python可视化"></a><a href="/2020/02/20/Python数据可视化/">Python可视化</a></h1><h1 id="python数据分析与挖掘实战"><a href="#python数据分析与挖掘实战" class="headerlink" title="python数据分析与挖掘实战"></a><a href="/2020/01/22/python数据分析与挖掘实战笔记/">python数据分析与挖掘实战</a></h1><h1 id="JAVA核心技术卷一"><a href="#JAVA核心技术卷一" class="headerlink" title="JAVA核心技术卷一"></a><a href="/2020/01/22/JAVA核心技术卷一/">JAVA核心技术卷一</a></h1><h1 id="学妹如果觉得不错，那么…"><a href="#学妹如果觉得不错，那么…" class="headerlink" title="学妹如果觉得不错，那么…"></a>学妹如果觉得不错，那么…<img src='/hh/qq.png' width =30% height =30%></h1>]]></content>
  </entry>
  <entry>
    <title>北大网课</title>
    <url>/2020/01/20/%E5%8C%97%E5%A4%A7%E7%BD%91%E8%AF%BE/</url>
    <content><![CDATA[<h1 id="哈希函数与加密体制"><a href="#哈希函数与加密体制" class="headerlink" title="哈希函数与加密体制"></a>哈希函数与加密体制</h1><ol>
<li>性质：<ol>
<li>抗碰撞性：难以人为制造哈希碰撞。</li>
<li>单向性：前提是输入空间足够大并且输入的分布比较均匀。(如果输入空间不够大，那么把输入后面拼接一个随机数再哈希)</li>
<li>puzzle friendly:比特币特有的性质。比特币区块要求计算出来的哈希值小于等于某一个阈值。</li>
<li>难以计算，但是易于验证。</li>
</ol>
</li>
<li>比特币中用的哈希函数:SHA-256</li>
<li>账户：在本地创建一个公私钥对就是一个账户。</li>
<li>非对称加密体系：公私钥。加密用公钥，解密用私钥，且加密和解密用的是用一个人的公钥和私钥。<ol>
<li>私钥保存在本地就行，公钥可以公开。</li>
<li>公钥相当于你的银行账号，私钥相当于银行密码。</li>
</ol>
</li>
<li>对称加密体系：加密解密使用同一个密钥，假设前提是存在一种安全的渠道把密钥分发给通信双方。</li>
<li>比特币系统中的公钥和私钥<ol>
<li>比特币系统中的信息都是公开的</li>
<li>所以私钥用来对交易做签名。我发起一个交易，那么我拿我的私钥进行签名，发布到区块链上，别人再用我的公钥进行验证。 </li>
</ol>
</li>
<li>以上所述的公私钥体制建立在有一个好的随机源上，同时每次签名操作也需要一个好的随机源。</li>
</ol>
<h1 id="比特币中的数据结构"><a href="#比特币中的数据结构" class="headerlink" title="比特币中的数据结构"></a>比特币中的数据结构</h1><ol>
<li><p>哈希指针：比如一个哈希指针指向一个结构体，那么这个指针里不止存它的地址还存它的哈希值。</p>
</li>
<li><p>区块链&amp;普通链表</p>
<ol>
<li><p>以哈希指针代替普通指针。</p>
</li>
<li><p>后一块的哈希指针是通过前一区块的全部内容(包括前一区块的哈希指针)计算出来的。</p>
<p> <strong>这样从最后一个区块就能知道前面的区块是否被修改。</strong></p>
<p> <strong>这样系统中的某些节点就不需要保存全部区块信息</strong></p>
</li>
<li><p>梅克尔树</p>
<img src="/区块链_img/2.png" style="zoom:80%">        
 1. 每个区块内部的交易组织成梅克尔树的形式
 2. 区块间通过哈希指针连接在一起。 </li>
<li><p>比特币网络由轻节点和全结点构成，其中</p>
<ol>
<li>轻节点只保存区块头；当轻节点想确认某笔交易是否已经被写进区块链中：轻节点向全节点请求红色的哈希值，轻节点自己计算绿色的哈希值。最终，可以将得到的根哈希值和头部中的根哈希值相比较。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="BTC协议：比特币的共识机制"><a href="#BTC协议：比特币的共识机制" class="headerlink" title="BTC协议：比特币的共识机制"></a>BTC协议：比特币的共识机制</h1><p>比特币需要解决问题：双花；发行</p>
<h2 id="双花问题"><a href="#双花问题" class="headerlink" title="双花问题"></a>双花问题</h2><ol>
<li><p>转账：假如A要向B和C转帐</p>
<ol>
<li><p>交易需要A的签名，证明是经过A统一 的。 </p>
</li>
<li><p>需要指明A的比特币从哪来</p>
</li>
<li><p>注：比特币系统中的交易包括输入和输出两部分，输入部分要指明币的来源，输出部分要给出收款人的公钥的哈希。</p>
<img src="/区块链_img/8.png" style="zoom:80%">

<p>注意：其中包含两种哈希指针。一种用来构成链表，另一种用来指向前面某个交易，以说明币的来源。</p>
</li>
<li><p>A需要知道B的公钥，B乃至所有节点也需要知道A的公钥，用来验证A的签名。因为怀疑网络中存在恶意节点，所以每个节点都需要亲自验证。</p>
<p> <strong>问题</strong>：A的公钥需要A自己去公布；如果某个恶意节点伪造了转账记录，用自己的私钥去签名，再公开自己的公钥说是A的公钥，那么可以转走A上钱么？</p>
<p> <strong>不</strong>，因为每个交易要去追溯币的来源，最终会追溯到币基交易，而币基交易（前面的交易）的输出正是A的哈希地址，只有当转帐中用到的公钥和这个哈希能对上，才能认为合法。</p>
</li>
<li><p><strong>注</strong>：加密是用接收者的公钥加密，接收者用自己的私钥解密。 </p>
</li>
</ol>
</li>
<li><p>区块的头部，包括</p>
<ol>
<li>比特币协议版本信息</li>
<li>指向前一个区块的指针</li>
<li>梅克尔树的根哈希值</li>
<li>挖矿的难度目标阈值（整个块头的哈希要小于等于目标阈值）</li>
<li>随机数</li>
</ol>
</li>
<li><p>分布式共识</p>
<ol>
<li>比如分布式哈希表：需要取得共识的是哈希表中包含了哪些 键值对。</li>
</ol>
</li>
<li><p>比特币的共识协议：问题出现在比特币系统中部分节点是有恶意的。</p>
<ol>
<li>最简单的，想要通过投票来判断某个节点产生的区块是否正确（区块内部的交易是否都是合法的）。但是存在一个问题，就是如何判断谁有投票资格。<ol>
<li><strong>女巫攻击</strong>：产生大量的公私钥对，极端情况下超过半数，那么他就得到了控制权。  </li>
</ol>
</li>
<li>通过<strong>算力</strong>来投票，每个节点都可以在本地组装候选区块，把他认为合法的交易放进去。然后开始算能够使得头部的哈希值小于目标阈值的随机数的值，找到了这个随机数的节点就获得了记账权，向比特币网络中发布这个区块<ol>
<li>其他节点收到这个区块后，首先验证nbits域的设置是否符合难度要求；验证头的哈希是否小于等于目标阈值。</li>
<li>然后验证body中的交易<ol>
<li>是否是合法的签名</li>
<li>以前是否被花过</li>
</ol>
</li>
<li>即使通过了前面的检查，但是该区块不是连接在最长合法链的末尾，也不接受。因为验证交易合法性时候，只去验证他所在的分支。<ol>
<li><strong>分叉攻击</strong>：通过向区块链中间插入某个区块来回滚某个已经发生的交易。<img src="/区块链_img/13.png" style="zoom:80%"></li>
</ol>
</li>
<li>接受一个区块意味着沿着这个区块继续往下扩展。如果产生的链不是基于最长的链，那么他在该链上通过币基交易得到的比特币也是不被认可的非法交易。</li>
</ol>
</li>
</ol>
</li>
<li><p>为什么要争夺记账权？为了币基交易的比特币奖励。 </p>
</li>
<li><p><strong>总结</strong>：比特币系统中的共识是针对分布式账本内容-&gt;只有获得记账权的节点才有权力向账本里写东西，有权决定账本中的内容-&gt;获得记账权需要算力支持-&gt;比特币的投票是基于算力的。</p>
<ol>
<li>比特币的性质：puzzle friendly，即想计算出结果，没有捷径，只有一个个试。</li>
</ol>
</li>
</ol>
<h1 id="比特币系统的实现"><a href="#比特币系统的实现" class="headerlink" title="比特币系统的实现"></a>比特币系统的实现</h1><ol>
<li>比特币使用基于交易的账本模式</li>
<li>比特币系统的全节点要维护一个UTXO的数据结构（所有没被花掉的交易输出组成的集合）以检查双花问题。  </li>
<li><strong>比特币激励机制2</strong>：交易费，激励争夺记账权的节点将他人的交易打包进区块。</li>
<li>想要使哈希值低于根哈希值，一个使太正nance，另一个使调整coinbase，这样搜索空间就达到了2<sup>96。</li>
<li>求解puzzle过程<img src="/区块链_img/14.png" style="zoom:80%">

</li>
</ol>
<p>其中tx那一串在实际上只需要梅克尔树的根哈希值即可。</p>
<h2 id="挖矿的概率分析："><a href="#挖矿的概率分析：" class="headerlink" title="挖矿的概率分析："></a>挖矿的概率分析：</h2><ol>
<li>每次挖矿的过程可以看作是一个伯努利试验。大量的伯努利实验构成一个伯努利程序。<ol>
<li>性质1：无记忆性</li>
</ol>
</li>
<li>试验次数很多，但是实验成功的概率很小的时候，可以用泊松分布来近似。</li>
<li>整个系统的出块时间是服从指数分布的，平均是10分钟。这个指数分布也是无记忆的。所以将来还要挖多少时间和过去已经挖了多少时间是没有关系的。这也保证了算力强的矿工拥有成比例的优势。</li>
</ol>
<h2 id="比特币系统的总量"><a href="#比特币系统的总量" class="headerlink" title="比特币系统的总量"></a>比特币系统的总量</h2><ol>
<li>比特币区块奖励是固定的，每个四年减半一次，所以比特币的数量会构成一个几何序列。可以计算出一共只有2100万个比特币。  </li>
</ol>
<h2 id="挖矿的意义"><a href="#挖矿的意义" class="headerlink" title="挖矿的意义"></a>挖矿的意义</h2><ol>
<li>挖矿本身并不解决什么问题，但是其算力竞争对于维护比特币系统的安全性是至关重要的。只要大部分算力是掌握在诚实节点手里，那么安全性就得以保证。</li>
</ol>
<h2 id="安全性分析："><a href="#安全性分析：" class="headerlink" title="安全性分析："></a>安全性分析：</h2><ol>
<li>恶意节点能否将别人的比特币转走：<strong>不能</strong>，无法伪造签名。如果他把交易硬写到区块链里，那么诚实的节点不会认可这个交易，因为他包含了一个非法的交易</li>
<li>恶意节点能否双花（<strong>分叉攻击</strong>）<ol>
<li>简单的防范方法是多等待几个区块（几个确认）（比特币协议中是等待6个确认），这样写入了回滚交易的区块想要使自己所在的分支成为最长合法链的难度就大大增加。</li>
</ol>
</li>
<li>恶意节点故意不包含某些交易<ol>
<li>但是问题不大，总有诚实的节点愿意将交易写入区块。即使不在这个区块里写入，也会写在下一个区块里。</li>
<li>正常的情况下，也有可能出现这种情况，因为比特币协议要求每个区块不得大于1MB。</li>
</ol>
</li>
<li>selfish mining攻击：挖到区块先不发布，攒了一堆再去发布以争夺最长合法链<ol>
<li><strong>不行</strong>：这对算力要求很大，起码要占据51%以上的算力才有一定的成功的可能性。但是话说回来，如果恶意节点占据了如此大的算力，比特币系统就崩盘了。</li>
<li><strong>出于盈利目的</strong>：如果一个节点的算力特别强，他挖到n+1个区块，之后不发布并立即开始挖第n+2个区块。等到侦听到有人挖到第n+1个区块的时候，他立刻将n+1和n+2个区块同时发布，那么他所在的链就成为了最长合法链，他得到的币基交易才是真实有效的。<ol>
<li>存在很大的风险：我们只有在假设别人挖出一个的时间里，我可以挖出两个，才能获得更大的利益。如果别人挖完第一个而我没有挖出第二个，那么我只能去碰碰运气。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="比特币网络"><a href="#比特币网络" class="headerlink" title="比特币网络"></a>比特币网络</h1><ol>
<li>比特币工作在应用层，其底层运行的是一个P2P Overlay网络，且这里的P2P网路中所有节点都是对等的。网络存在一个种子节点，可以通过它直到网络中其他节点的信息。节点之间通过TCP连接（这样有利于穿透防火墙）</li>
<li>每个节点维护一个临近节点集合(临近节点的选取是随机的，而不考虑底层拓扑结构)，消息传播采用洪范方式</li>
</ol>
<h1 id="比特币系统的挖矿难度"><a href="#比特币系统的挖矿难度" class="headerlink" title="比特币系统的挖矿难度"></a>比特币系统的挖矿难度</h1><ol>
<li>通过调整目标空间占搜索空间的比例来调整挖矿难度。</li>
<li>挖矿难度和目标阈值是成反比的。</li>
<li>为什么要维护挖矿难度：<ol>
<li>如果不调整这个难度，那么随着挖矿的人数增多，设备的进步，那么相对于网路延迟来说，生成区块的速度过快，从而导致多分叉。分叉过多对系统达成共识没有帮助，也会危害到系统的安全性。</li>
<li>回顾分叉攻击：我们只有在假设大部分的算力都掌握在诚实的矿工手里的时候才能避免。如果出现多分叉，那么算力被分散，被分叉攻击的可能性大大增加。</li>
</ol>
</li>
<li>比特币系统规定每个2016个区块调整一次，大约14天一次。且增大和减小都有要求，增大不会一次性增大超过4倍，减少也不会一次减少到1/4以上。</li>
</ol>
<h1 id="比特币挖矿"><a href="#比特币挖矿" class="headerlink" title="比特币挖矿"></a>比特币挖矿</h1><ol>
<li><p>比特币系统包括全节点和轻节点</p>
 <img src="/区块链_img/27.png" style="zoom:80%">

<p> 全节点：</p>
<ol>
<li><p>决定沿着那条链挖下去：缺省情况下，沿着最长合法链挖下去。</p>
</li>
<li><p>出现等长分叉：选择最先听到的分叉。</p>
<img src="/区块链_img/28.png" style="zoom:80%">

<p>轻节点：</p>
</li>
<li><p>只能检测合法链，但是不知道哪个是最长合法链。</p>
</li>
<li><p>轻节点假设矿工是有理智的，不会沿着非法的链挖下去。</p>
</li>
<li><p>轻节点在挖矿过程中，如果监听到别的节点已经挖出了新的区块，那么它只能放弃已有的区块。因为梅克尔树的跟哈希值和组成链的哈希指针都发生了变化。尽管如此，这并不可惜，因为挖矿具有无记忆性，成功的概率是没区别的。</p>
</li>
</ol>
</li>
<li><p>比特币的安全性保障</p>
<ol>
<li>由密码学提供：无法伪造的私钥签名。这个的前提是比特币网络中大多数节点都是好的，不会接受不合法的交易。</li>
<li>由比特币的共识机制提供</li>
</ol>
</li>
<li><p>矿石：使得51%以上的攻击变得容易。</p>
</li>
<li><p>矿石可发动的攻击：</p>
<ol>
<li>分叉攻击：</li>
<li>Boycott：比如想封锁A账户，可以在任何包含A的交易的区块被发布之后，立刻组装新的不包含A 的交易的区块，并经可能是新区块所在链变为最长合法链。</li>
</ol>
</li>
</ol>
<h1 id="比特币分叉"><a href="#比特币分叉" class="headerlink" title="比特币分叉"></a>比特币分叉</h1><ol>
<li>state fork:两个节点几乎同时挖到了区块。</li>
<li>forking attack（deliberate fork）</li>
<li>protocal fork:由于比特币协议修改导致的分叉<ol>
<li>硬分叉：这样的分叉是永久的，只要有算力不更新软件就存在。</li>
<li>软分叉：临时性的分叉</li>
</ol>
</li>
</ol>
<h1 id="比特币的匿名性"><a href="#比特币的匿名性" class="headerlink" title="比特币的匿名性"></a>比特币的匿名性</h1><ol>
<li><p>假的匿名，类似于化名不是绝对的。而且比特币的账本是完全公开的，对匿名性一种挑战。</p>
</li>
<li><p>实际上不同的地址可能被关联在一起。通过推理出来。</p>
</li>
<li><p>如果交易只在区块链内，则不会泄漏。但是一旦和实体世界发生关联，那么就可能泄漏隐私，具体在：</p>
<ol>
<li>比特币支付</li>
<li>资金转入转出的时候</li>
</ol>
</li>
<li><p>提高匿名性的方法</p>
<ol>
<li>首先要实现网络层的匿名性：采用多路径转发的方法。</li>
<li>混合币</li>
</ol>
</li>
<li><p>保护匿名性很难的原因：（1）区块链是公开的（2）区块链具有不可修改性，一旦某一个交易暴露了身份，影响会是永久的。</p>
</li>
</ol>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><h2 id="哈希指针"><a href="#哈希指针" class="headerlink" title="哈希指针"></a>哈希指针</h2><ol>
<li>实际上比特币系统只有哈希没有指针。在全节点中,所有的区块是以levelDB这种键值对数据来存储,其中key为哈希值,value为区块内容。</li>
</ol>
<h2 id="区块恋"><a href="#区块恋" class="headerlink" title="区块恋"></a>区块恋</h2><ol>
<li>这样会严重影响私钥的安全性，因为私钥长度变短时，暴力破解的搜索空间大大降低。</li>
<li>所以应该用多重签名，其中每个私钥都是独立产生的。</li>
<li>如果两个人分手，那么所有的币都会被存在UTXO中。</li>
</ol>
<h2 id="分布式共识"><a href="#分布式共识" class="headerlink" title="分布式共识"></a>分布式共识</h2><ol>
<li>实际上比特币并没有达成真正意义的共识。随时可能被推翻。</li>
</ol>
<h2 id="比特币的稀缺性"><a href="#比特币的稀缺性" class="headerlink" title="比特币的稀缺性"></a>比特币的稀缺性</h2><ol>
<li>总量一定的东西并不适用于做货币。因为随着社会财富总值的增长，每单位该种货币就变得越来越值钱，先买的人就越来越富，后面的人就永远也赶不上。就像房地产。</li>
</ol>
<h1 id="以太坊概述"><a href="#以太坊概述" class="headerlink" title="以太坊概述"></a>以太坊概述</h1><ol>
<li>memory hard mining puzzle</li>
<li>以后想权益证明代替工作量证明，用类似于股权投票的方式。</li>
<li>智能合约：去中心化合约。加入参与方来自世界各地，那么手段维持合约的有效性就很困难，所以考虑写成程序，写进区块链。</li>
</ol>
<h1 id="以太坊中的账户"><a href="#以太坊中的账户" class="headerlink" title="以太坊中的账户"></a>以太坊中的账户</h1><ol>
<li>BTC中需要统计所有的UTXO。</li>
<li>账户天然的防护了双花问题。但是存在重放攻击。</li>
</ol>
<h2 id="重放攻击："><a href="#重放攻击：" class="headerlink" title="重放攻击："></a>重放攻击：</h2><ol>
<li>假设A给B转了一次帐，广播过一次，之后B又向网络广播这次交易。那么网络中的其他节点就会认为A又向B转账了一次。</li>
<li><strong>解决</strong>：多维护一个交易次数的属性，在签名的保护下一起发布出去。系统中的全节点维护这个交易次数值。假设A-&gt;B是第20次，那么全节点认为下次来的应该是第21，那么即使B重放，也不行。</li>
</ol>
<h2 id="外部账户"><a href="#外部账户" class="headerlink" title="外部账户"></a>外部账户</h2><ol>
<li>由公私钥控制，包括账户余额和交易次数。</li>
</ol>
<h2 id="合约账户"><a href="#合约账户" class="headerlink" title="合约账户"></a>合约账户</h2><ol>
<li>不是由公私钥对控制，也有nonce值，用来标识调用别的合约的次数。还有code，storage。但是合约账户不能主动发起交易。</li>
</ol>
<h2 id="为什么有合约"><a href="#为什么有合约" class="headerlink" title="为什么有合约"></a>为什么有合约</h2><ol>
<li>为了支持智能合约，要求参与者有相对稳定的身份。</li>
</ol>
<h1 id="以太坊状态树"><a href="#以太坊状态树" class="headerlink" title="以太坊状态树"></a>以太坊状态树</h1><p>目的是建立一个账户到状态的映射。以太坊的账户为160b，状态包括余额、交易次数（代码，存储）。</p>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><ol>
<li><p>优点：</p>
<ol>
<li>每个节点的分叉数目取决于取值范围。</li>
<li>查找效率取决于键的长度。</li>
<li>插入顺序不一样，得到的结构也一样。</li>
<li>更新局部性很好，每个区块对应的账户很少，伊这种结构不需要管别的分支</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>存储浪费</li>
<li>查找效率与深度有关</li>
</ol>
</li>
</ol>
<h2 id="Patricia-tree"><a href="#Patricia-tree" class="headerlink" title="Patricia tree"></a>Patricia tree</h2><ol>
<li>是路径压缩的trie树。键值分布稀疏的时候比较好。</li>
</ol>
<h2 id="MPT-Merkle-Partricia-Tree"><a href="#MPT-Merkle-Partricia-Tree" class="headerlink" title="MPT Merkle Partricia Tree"></a>MPT Merkle Partricia Tree</h2><ol>
<li>路径压缩加路径压缩</li>
<li>优点：<ol>
<li>放篡改</li>
<li>可以证明账户上的余额。 </li>
<li>还可以证明某个键值是不存在的。</li>
</ol>
</li>
</ol>
<h2 id="Modified-MPT"><a href="#Modified-MPT" class="headerlink" title="Modified MPT"></a>Modified MPT</h2><ol>
<li>以太坊的结构是一颗大的MPT包含很多小的MPT，每一个合约账户就是一颗小的MPT</li>
<li>系统中的全节点维护的不是一颗MPT，而是每产生一个新的区块就新建一颗MPT,这些树中大部分的节点是共享的，只有少数更新的节点要新建分支。</li>
<li>保留历史状态是因为可能需要回滚交易，比如分叉的时候。以太坊由于智能合约的出现，所以很难去反向推算前一个状态，所以要保存。</li>
<li>状态树中保存的是键值对，地址作为key。而value要首先经过序列化之后再存储，大致理解为变成字节数组。</li>
</ol>
<h1 id="以太坊数据结构"><a href="#以太坊数据结构" class="headerlink" title="以太坊数据结构"></a>以太坊数据结构</h1><h2 id="交易树–也是一种MPT"><a href="#交易树–也是一种MPT" class="headerlink" title="交易树–也是一种MPT"></a>交易树–也是一种MPT</h2><ol>
<li>区块中的交易形成一颗交易树</li>
</ol>
<h2 id="收据树–也是一种MPT"><a href="#收据树–也是一种MPT" class="headerlink" title="收据树–也是一种MPT"></a>收据树–也是一种MPT</h2><ol>
<li>每个交易执行完，会形成一颗收据树，记录这个交易的相关信息。交易树和收据树上的节点是一一对应的。利于快速查找执行的结果。</li>
<li>每个区块的交易树和收据树都是独立的。他们发布的交易本身我们也认为是独立的。</li>
</ol>
<h2 id="bloom-filter"><a href="#bloom-filter" class="headerlink" title="bloom filter"></a>bloom filter</h2><ol>
<li>为了在大的集合中进行查找，以支持复杂的查询操作。</li>
<li>一般的扫描存在存储问题和查找效率问题。</li>
<li>将每个元素取一个哈希，形成一个向量，其中某位为1代表该对应该哈希值的元素存在，这个向量称为摘要。</li>
<li>不支持删除操作。 </li>
<li>作用：加入要查找过去十天发生的和某个智能合约相关的交易。首先，查找区块块头的bloom filter，看哪个块头的bloom filter里有我要的类型。如果某个块头里有，在去找对应收据树里的bf,看看哪个有。有的再去仔细查看。</li>
</ol>
<h2 id="以太坊的运行过程"><a href="#以太坊的运行过程" class="headerlink" title="以太坊的运行过程"></a>以太坊的运行过程</h2><p>看成是交易驱动的状态机。状态是所有账户的状态；交易每次发布区块包含的交易，这些交易会驱动从当前的状态转移到下一个状态。 </p>
<h1 id="GHOST协议–利于出现分叉后及时合并"><a href="#GHOST协议–利于出现分叉后及时合并" class="headerlink" title="GHOST协议–利于出现分叉后及时合并"></a>GHOST协议–利于出现分叉后及时合并</h1><ol>
<li><p>没有竞争称为最长合法链上的区块也会发放一定的出块奖励（7/8）称为叔父区块。下一个区块要包含所有叔父区块，同时得到1/32个出块奖励的额外报酬。最多可以包含两个叔父区块。</p>
</li>
<li><p>不在最长合法链上的区块都是叔父区块，即使是爷爷啥的。  </p>
</li>
<li><p>为了防止在挖矿难度较低的时候产生叔父而不当获利，最多7代。叔父区块中的交易不执行，所以也不检查交易合法性，只检查是否符合挖矿难度。</p>
 <img src="/区块链_img/52.png" style="zoom:80%">    </li>
<li><p>GHOST机制是为了解决临时性的分叉。</p>
</li>
</ol>
<h1 id="以太坊的挖矿算法"><a href="#以太坊的挖矿算法" class="headerlink" title="以太坊的挖矿算法"></a>以太坊的挖矿算法</h1><ol>
<li>求解很难，验证简单、</li>
<li>回避ASIC芯片。</li>
</ol>
<h2 id="Lite币"><a href="#Lite币" class="headerlink" title="Lite币"></a>Lite币</h2><ol>
<li>基于Scrypt加密，需要大内存来保存这个数组。</li>
<li>但是设定小了，只有128K。</li>
</ol>
<h2 id="以太币"><a href="#以太币" class="headerlink" title="以太币"></a>以太币</h2><ol>
<li>有两个数据集，初始一个是16M的cache，另一个是1G的DAG。DAG从cache中生成出来。轻节点只需要保存cache便于验证。</li>
<li>cache形成 ：首先从一个种子节点开始依次去哈希来填充数组。</li>
<li>DAG形成：从cache里随机读一个数，然后进行哈希计算，得到下一个要读取的数的位置。然后用cache中这个位置的数和当前的哈希值再计算出一个哈希值，反复迭代256次，将最终得到的数填充到数组的第一个位置。</li>
<li>挖矿的时候，先根据块头和nonce值计算一个哈希，这个哈希映射到数组中的某一个位置。通过这个位置和相邻位置的元素进行运算得到下一个位置，循环64次，最后得到的哈希值与目标阈值比较，看一下是否成功。不成功则换下一个nonce。</li>
<li>生成cache的seed每隔3w个区块会变一下。同时cache和DAG大小会增加1/128。 </li>
</ol>
<h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><ol>
<li>外部账户可以调用合约，一个合约可以调用另一个合约。只有外部账户可以调用。</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链技术</title>
    <url>/2020/01/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="区块链技术学习报告"><a href="#区块链技术学习报告" class="headerlink" title="区块链技术学习报告"></a><a href="/2020/02/20/计安导报告/">区块链技术学习报告</a></h1><h1 id="区块链自学笔记"><a href="#区块链自学笔记" class="headerlink" title="区块链自学笔记"></a><a href="/2020/01/20/区块链自学/">区块链自学笔记</a></h1><h1 id="北大网课摘要"><a href="#北大网课摘要" class="headerlink" title="北大网课摘要"></a><a href="/2020/01/20/北大网课/">北大网课摘要</a></h1>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链自学</title>
    <url>/2020/01/20/%E5%8C%BA%E5%9D%97%E9%93%BE%E8%87%AA%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="比特币的诞生"><a href="#比特币的诞生" class="headerlink" title="比特币的诞生"></a>比特币的诞生</h1><ol>
<li><p>比特币目的是在数字世界，创造一个具有现金特性的事物</p>
</li>
<li><p>比特币组成成分</p>
<p> 1）加密数字货币</p>
<p> 2）分布式账本</p>
<p> 3) 去中心网络</p>
</li>
<li><p>目前的电子现金系统：依靠中心化数据库和可信的第三方中介来避免双花问题</p>
</li>
<li><p>比特币同时做到了去中介化和去中心化</p>
<p> 1） 个人与个人之间的电子现金无需可信第三方中介的介入，这是去中介化</p>
<p> 2）这个电子现金的货币发行也不需要一个中心化的机构，而是由代码与社区共识完成，这是去中心化</p>
</li>
<li><p>比特币系统三层结构</p>
<p> 1）最上一层是比特币这种电子现金。是整个系统的应用层</p>
<p> 2）中间一层的功能是发行比特币与处理用户见的比特币转移。这一层也叫比特币协议，是整个系统的应用协议层。（相当于中央银行（发行货币）与银行（处理转账）等金融机构间的关系）</p>
<p> 3）最底层是比特币的分布式账本和去中心化网络。这一层也被称为比特币区块链，是整个系统的通用协议层。</p>
</li>
</ol>
<h1 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h1><ol>
<li>定义：区块链是数字世界中进行价值表示和价值转移的技术。区块链硬币一面是表示价值的加密数字货币或通证，另一面是进行价值转移的分布式账本与去中心网络。</li>
<li>通证：基于区块链的价值表示无都称为通证。</li>
</ol>
<h1 id="加密数字货币前传"><a href="#加密数字货币前传" class="headerlink" title="加密数字货币前传"></a>加密数字货币前传</h1><ol>
<li>大卫·乔姆：<ol>
<li>盲签：在一张纸条上， 你选择一个只有你知道的序列号，然后我在上面签名。由于我不知道这个序列号，所以我没法再复制一份这张纸条给另一个人。</li>
<li>这个方案的缺点是：必须有一个所有参与者都薪人的中心化服务器来进行这些“数字纸条”的验证。</li>
</ol>
</li>
<li>尼克·萨博<ol>
<li>提出智能合约。智能合约是区块链处理交易的核心方式，区块链应用的实质可被看成是一个个智能合约的组合。</li>
</ol>
</li>
<li>哈尔·芬妮<ol>
<li>著名的PGP加密中的”G”</li>
</ol>
</li>
<li>中本聪<ol>
<li>首次建立了一个去中心化，非基于信任的系统。</li>
<li>它通过已有的公钥加密方式来管理所有权，并用一个名为工作量证明的共识算法来记录谁拥有货币。</li>
</ol>
</li>
</ol>
<h1 id="中心化"><a href="#中心化" class="headerlink" title="中心化"></a>中心化</h1><h2 id="数字世界中的货币有三种形式"><a href="#数字世界中的货币有三种形式" class="headerlink" title="数字世界中的货币有三种形式"></a>数字世界中的货币有三种形式</h2><ol>
<li>中心化的在线支付：<ol>
<li>在这些支付系统中流转的是映射到数字世界的各国法定货币（也乘法币）</li>
<li>法定货币的价值来自拥有者相信货币将来能维持其购买力，本身并无内在价值。 </li>
</ol>
</li>
<li>中心化的计算机点数或互联网积分<ol>
<li>不与物理世界的法币对应，而是由商业公司中心化发行，仅可以在一家公司的体系中使用，称为虚拟货币。如Q币</li>
</ol>
</li>
<li>去中心化的电子现金：比特币</li>
</ol>
<h2 id="比特币实现了极致的去中心化"><a href="#比特币实现了极致的去中心化" class="headerlink" title="比特币实现了极致的去中心化"></a>比特币实现了极致的去中心化</h2><ol>
<li>威廉·穆贾雅在《商业区块链》一书中对比特币白皮书摘要进行了分析，他总结了四个要点：<ol>
<li>点对点电子交易；</li>
<li>不需要金融机构；</li>
<li>加密证据而不是中心化的信用；</li>
<li>信用存在于网络，而不是某个中心机构。</li>
</ol>
</li>
<li>在《去中心化应用》一书中，开发者西拉杰·拉瓦尔对去中心化应用的去中心化程度进行了一番讨论。他认为，区块链可能在四个过去集中化的方面完成去中心化： 数据；财富；身份；计算。</li>
</ol>
<h2 id="比特币系统设计的五个要点："><a href="#比特币系统设计的五个要点：" class="headerlink" title="比特币系统设计的五个要点："></a>比特币系统设计的五个要点：</h2><p>比特币的区块链系统是由分布式账本（即狭义的区块链）和去中心网络（点对点网络）组成的，形成链条的方式是工作量证明共识机制。最长链是由网络中的算力共同决定的，因而它是可信的，节点离开和加入依据的是最长链是可信的这一原则。这些组合起来形成了比特币系统。</p>
<ol>
<li><p>去中心化的点对点电子现金</p>
</li>
<li><p>分布式账本</p>
<p> 比特币的区块链是基于工作量证明形成的带时间戳、存储数据的数据块和由哈希指针连接成的链条。</p>
<p> 这个链条或者说账本以分布式的方式存储在比特币网络的各个节点上，因而也被称为分布式账本。</p>
</li>
<li><p>工作量证明</p>
</li>
<li><p>最长链原则</p>
</li>
<li><p>去中心网络</p>
</li>
</ol>
<h1 id="比特币是如何转账的"><a href="#比特币是如何转账的" class="headerlink" title="比特币是如何转账的"></a>比特币是如何转账的</h1><h2 id="分布式账本和去中心网络"><a href="#分布式账本和去中心网络" class="headerlink" title="分布式账本和去中心网络"></a>分布式账本和去中心网络</h2><ol>
<li><p>比特币网络由众多轻节点和全结点组成，这些结点形成一个去中心网络，其中：</p>
<ol>
<li>全节点包含所有比特币区块链的区块数据</li>
<li>轻节点仅包含自己相关的数据。</li>
<li>比特币网络是开放的，任何服务器都可以加入成为全结点</li>
</ol>
</li>
<li><p>分布式账本：所有用户持有的比特币信息都存在一个分布式账本中；比特币账本可被认为同时存储在所有全结点中。</p>
</li>
<li><p>中心化在线支付系统的交易流程：交易双方通过中心化的交易平台中开设的账户完成交易。中心化在线支付系统维护一个中心化的账本，用户在账本上开设账户，通过密码(私钥)来与之交互。</p>
</li>
<li><p>比特币系统的交易过程：</p>
<ol>
<li><p>每个人在比特币区块链上建立账户(地址)，获得一对公钥和私钥，地址是公钥的哈希值，我们通过私钥与地址进行交互。</p>
</li>
<li><p>每个人有一个钱包，钱包中装的是私钥，转账时，可以通过各自的钱包软件直接进行。</p>
</li>
<li><p>对比而言，对于中心化在线支付系统，它通常是由中心化的服务器来管理集中式账本。对于比特币系统，它背后的系统是一个去中心网络，网络节点共同维护一个分布式账本。</p>
<p> &nbsp;比特币是记录在账本中的，看起来还是有一个“中心”？</p>
<p> &nbsp;其实，这个账本是分布式地存储在去中心网络中的，因而从这个层面看，它可以看成是去中心化的。</p>
</li>
</ol>
</li>
</ol>
<h2 id="UTXO-未使用的交易输出"><a href="#UTXO-未使用的交易输出" class="headerlink" title="UTXO:未使用的交易输出"></a>UTXO:未使用的交易输出</h2><ol>
<li><p>比特币系统中的账户：没有账户，只有地址(是公钥的哈希值)。如果愿意可以开始无限多的钱包地址，但是系统不会汇总形成账户。</p>
</li>
<li><p>所以转账是从我的一个钱包地址转到你的一个钱包地址。</p>
</li>
<li><p>UTXO</p>
<ol>
<li><p>通证经济专家孟岩曾撰写一篇文章，标题是“其实没有什么比特币，只有UTXO”，这个标题指出了，对于计算机来说比特币是什么——比特币是区块链账本上的交易输出。</p>
</li>
<li><p>例子：假</p>
<ol>
<li>如我有8比特币，说明之前有一个交易把这些比特币转入我的地址，这个交易的输出未被使用，我拥有了8个比特币。</li>
<li>现在我发起一个转账交易，这个交易的输入是我拥有的这些比特币的上一个交易。我转账给你，假设对我拥有的这8毕业比的上一个交易进行签名，把这一新转账交易的输出地址设为你的钱包地址。</li>
<li>这样，这8比特币就属于你了，你拥有的是我这个交易的未使用的交易输出。等矿工把这一交易打包进新的区块，转账交易完成。</li>
<li>交易中涉及比特币的公钥和私钥的非对称加密机制。钱包地址理解为房间号和锁，私钥则相当于钥匙，钥匙可以打开对应的锁。</li>
<li>对于每一笔比特币的源头，都有一种特殊的交易–创币交易。对于矿工赢得25比特币的创币交易，它的输入是0，而输出是25个比特币进到矿工的钱包地址中。</li>
</ol>
</li>
<li><p>UTXO的优点（相比于账户）</p>
<ol>
<li><p>UTXO设计易于确认比特币的所有权。</p>
<p> 想要转账，只需要确认上一个交易时真实的，我就的确拥有这些比特币。而一个区块经过6次确认，其中的交易可被认为是真实无误的。</p>
</li>
<li><p>UTXO设计与区块链账本是完全融为一体的</p>
<p> 区块链账本存储的是状态。区块链中的交易都是一种状态转换函数。每一个新区快和它之前的所有区块一起形成了一个新的状态。在确认之后，之前的状态就不可篡改。</p>
</li>
</ol>
</li>
<li><p>深入理解UXTO</p>
<ol>
<li>比特币就是UTXO<ol>
<li>当甲要把一笔比特币转给乙时，这个过程是把甲的钱包地址中之前的一个UTXO，用私钥进行签名，发送给乙的地址，这个过程就是一个新的交易，而乙得到的是一个新的UTXO。</li>
<li>世界上根本没有比特币，只有UTXO，你的地址中的比特币是指没花掉的交易输出。</li>
</ol>
</li>
<li>详细阐述从甲向乙的转账过程。<ol>
<li>假设A之前通过币基交易挖矿获得了12.5个比特币，那么在它的钱包地址中，就有了相应的UTXO</li>
<li>Alice发起一个转账交易，输入是自己的上一个交易，输出是B的地址，数量是12.5比特币，A用自己的私钥进行签名。</li>
<li>当交易的区块链确认后，A的UTXO变成0.而B的地址中就多了一个UTXO，数量是12.5.</li>
<li>存在B的地址中的这些比特币只有用B的私钥进行签名才可以转账给其他人。</li>
<li>总的来说，比特币转账就是用这个地址对应的私钥打开，再加密发送到另一个地址的过程。这个私钥的打开和加密就是签名的过程。在这个过程中，接受比特币的一方不需要动用自己的私钥。</li>
</ol>
</li>
</ol>
</li>
<li><p>比特币存在哪儿</p>
<ol>
<li>一方面，你的比特币是一个物理存在的一一对应的一个数据文件。比特币以一个交易的UTXO的形式存在着，每个交易都被看成是一个数据文件。</li>
<li>另一方面，比特币是区块链这个账本上的记录。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="比特币区块的数据结构"><a href="#比特币区块的数据结构" class="headerlink" title="比特币区块的数据结构"></a>比特币区块的数据结构</h2><ol>
<li>每个区块由两个部分组成–区块头部和区块数据。</li>
<li>区块头部<ol>
<li>头部中有一个哈希指针指向上一个区块，这个哈希指针包含前一个数据块的哈希值。</li>
<li>如果前一个区块中的数据被篡改了，那么通过哈希指针就能够发现。所以，要修改一个区块中的数据，对其后的每个区块都必须相应的进行修改。</li>
</ol>
</li>
<li>区块数据：一个区块中的数据是被打包进这个区块的一系列交易。这些交易按规则打包最终形成梅克尔树。</li>
<li>区块链中的两种哈希指针：<ol>
<li>一个是形成”区块+链”的链状数据结构。</li>
<li>另一个是数据块内部用来形成梅克尔树的哈希指针</li>
</ol>
</li>
</ol>
<h2 id="工作量证明共识机制"><a href="#工作量证明共识机制" class="headerlink" title="工作量证明共识机制"></a>工作量证明共识机制</h2><ol>
<li><p>共识机制为什么存在：是因为这是一个非基于信任的网络，任何人无需许可都可以接入这个网络。并且，这些节点需要达成一致。共识机制即为这些节点达成一致的机制。</p>
</li>
<li><p>比特币的共识机制有两个与过去不同的特点</p>
<ol>
<li><p>引入了奖励机制</p>
<ol>
<li><p>通过比特币奖励使网络中的节点愿意打包交易，维护账本。</p>
<p> &nbsp;除了新区块相关奖励外，挖矿节点还可以的饿到区块中包含的所有交易付出的交易费。</p>
</li>
</ol>
</li>
<li><p>包含了随机性的概念</p>
<ol>
<li><p>比特币的共识系统并不是完全可靠的，但是经过约一小时(6个区块)后，出问题概率呈指数级下降，从实用角度来看，这个共识是可信的。</p>
 <img src="/区块链_img/1.png" style="zoom:80%">

</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="比特币的挖矿机制"><a href="#比特币的挖矿机制" class="headerlink" title="比特币的挖矿机制"></a>比特币的挖矿机制</h2><ol start="5">
<li><p>挖矿结点计算机的两个任务</p>
<ol>
<li><p>第一个任务是把比特币网络中未确认的交易按梅克尔树组装成候选区块，未被纳入的交易则往下顺延。</p>
<p> 在创建候选区块时，除了普通的交易外，矿工在器中增加一个特殊的交易： 如果挖矿成功，则币基交易会凭空转出新区块的奖励比特币到矿工的钱包地址中，从而发行这些比特币出来。</p>
</li>
<li><p>第二个任务是进行加密哈希计算，解决一个计算难题，进行算力竞争。在众多争夺记账权的结点中，谁最先完成这个计算，它打包的区块就被加到了区块链的最后，称为最新的区块。刷先完成计算的矿工会赢得新区快对对挖矿奖励。</p>
</li>
</ol>
</li>
<li><p>比特币的工作量证明共识机制与它的挖矿机制</p>
<ol>
<li>向内看： 在候选区块的头部有一个32位的随机数区域，矿工需要反复调整随机数并计算，目标是让整个区块的哈希值小于一个目标值。如果尝试过所有的32位随机数可能性后，计算仍未成功，那么就要改变币基的一个随机数，接着反复计算。</li>
<li>向外看： 随着算力的增长，会调整目标值的难度使得挖出一个区块的时间始终是10分钟左右。</li>
<li>总之，比特币的经济系统是以竞争-记账-奖励循环为核心的。<h2 id="比特币转账过程"><a href="#比特币转账过程" class="headerlink" title="比特币转账过程"></a>比特币转账过程</h2><img src="/区块链_img/3.png" style="zoom:80%">

</li>
</ol>
</li>
</ol>
<h1 id="区块链的应用"><a href="#区块链的应用" class="headerlink" title="区块链的应用"></a>区块链的应用</h1><ol>
<li><p>总的来说，区块链让我们从信息互联网跨越到价值互联网。</p>
</li>
<li><p>信息传递到价值传递</p>
<ol>
<li><p>区块链提供了数字世界中价值表示与价值转移</p>
 <img src="/区块链_img/4.png" style = "zoom:80%"></li>
<li><p>目前的互联网实现的是信息传递，其特征是进行信息的复制。这一特征使得在数字空间中进行价值转移时，必须依赖可信的第三方</p>
</li>
<li><p>未来，我们不再需要这些“信用中介”。基于区块链技术，我们可能建立一个通过网络本身进行价值表示、价值转移的全新交易基础设施。</p>
</li>
</ol>
</li>
<li><p>数字世界中的价值转移和价值表示</p>
<ol>
<li>价值的转移依靠记录：比如进行房产交易，那么要做的是把记录中所有权人改为你。</li>
<li>数字世界中，可完美复制的数据文件和需要唯一性的价值表示形式形成冲突。为了防止双花问题，所以需要一个可信的第三方作为中介。所有与价值转移有关的事处于成本高，效率低的状态，互联网上的价值转移就局限在少数的价值类别上。</li>
</ol>
</li>
</ol>
<h2 id="价值表示"><a href="#价值表示" class="headerlink" title="价值表示"></a>价值表示</h2><ol>
<li>价值的表示是在交易中体现出来的，因此可以从价值转移来讨论价值表示。</li>
<li>传统的体系中：价值的表示需要一个中介来参与。中介维护一个集中的账本用以记录，协助完成价值转移。</li>
<li>比特币系统中，区块链的账本以分布式的方式存在于互联网上，由去中心网络的节点共同维护。只要掌握自己的私钥即可。即所有人共享一个云端账本。</li>
</ol>
<h2 id="价值转移"><a href="#价值转移" class="headerlink" title="价值转移"></a>价值转移</h2><ol>
<li>在基础层次上，区块链担任信用中介，协助进行价值表示和价值转移。</li>
<li>互联网的层次：<ol>
<li>最上层，是普通用户看到的网站与App等应用。</li>
<li>中间层，是协议层，这一层过去主要是信息传递的WWW等协议。</li>
<li>最底层，是网络传输硬件和网络传输协议如TCP/IP等。</li>
</ol>
</li>
<li>区块链给互联网带来了进行价值表示和价值转移的新协议。区块链信用层协议由一组协议组成，在现有硬件网络之上，形成了一个协助我们进行价值表示和价值转移的新层次。这组协议目前仍未定性，也尚未被广泛认可，在持续发展中。</li>
</ol>
<h2 id="价值表示物：数字世界中表示价值的通证"><a href="#价值表示物：数字世界中表示价值的通证" class="headerlink" title="价值表示物：数字世界中表示价值的通证"></a>价值表示物：数字世界中表示价值的通证</h2><ol>
<li>以太坊创始人维塔利克写道，常被提及的应用包括：<ol>
<li>使用链上数字资产来代表定制货币和金融工具。</li>
<li>某种基础物理设备的所有权。</li>
<li>如域名一样的不可互换的资产</li>
<li>以及复杂的应用来直接控制转移数字资产（<strong>智能合约</strong>）</li>
<li>甚至基于区块链的分布式自治组织。</li>
</ol>
</li>
<li><a href="http://c.biancheng.net/view/1908.html" target="_blank" rel="noopener">应用及以太坊简史</a></li>
<li>把数字世界中，基于区块链的各种价值表示物都称为通证。</li>
<li>总的来说，现在在数字世界中，类似于 HTML 的代表价值的语言（通证）已经准备好了。“怎么用通证，通证有什么用”等问题等待着创造性的回答。</li>
</ol>
<h2 id="区块链的第三第四定义"><a href="#区块链的第三第四定义" class="headerlink" title="区块链的第三第四定义"></a>区块链的第三第四定义</h2><img src="/区块链_img/5.png" style = "zoom:80%">

<img src="/区块链_img/6.png" style = "zoom:80%">

<img src="/区块链_img/7.png" style = "zoom:80%">

<h1 id="区块链将成为互联网基础协议"><a href="#区块链将成为互联网基础协议" class="headerlink" title="区块链将成为互联网基础协议"></a>区块链将成为互联网基础协议</h1><ol>
<li><p>目前互联网通信用的协议是TCP/IP协议族。通常认为包括四层：    </p>
<ol>
<li>链路层：将一些数据放在电线上。</li>
<li>网络层：对数据进行路由</li>
<li>传输层：将数据持久化</li>
<li>应用层：以应用的形式提供数据的抽象。</li>
</ol>
</li>
<li><p>万维网协议包括三部分：</p>
<ol>
<li>文本标记语言HTML</li>
<li>文档传输协议HTTP</li>
<li>指定文档网络地址的统一资源定位符URL</li>
</ol>
</li>
<li><p>区块链技术作用于硬件网络之上、WWW协议旁边</p>
 <img src="/区块链_img/9.png" style = "zoom:80%">

</li>
</ol>
<h1 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h1><ol>
<li><p>在软件层面加入智能合约，但在实际应用中，它真正带来巨变的是通证。</p>
<blockquote>
<p>当下，对于区块链的发展阶段划分，一个被普遍接受的分类来自区块链研究者梅兰妮·斯万，在《区块链：新经济蓝图》一书中，她将区块链分为：区块链1.0，货币；区块链2.0，合约；区块链3.0，应用。从货币到合约、再到应用是一种阶段分类，以太坊白皮书的题目即宣称，它试图成为智能合约和去中心化应用的平台。</p>
</blockquote>
</li>
<li><p>以太坊是区块链2.0，实现了从数字现金到数字资产的转换。</p>
</li>
</ol>
<h2 id="智能合约与去中心化的平台"><a href="#智能合约与去中心化的平台" class="headerlink" title="智能合约与去中心化的平台"></a>智能合约与去中心化的平台</h2><ol>
<li><p>维塔利克分析在比特币系统的基础上开发高级应用的三种可行路径：</p>
<ol>
<li>建立一个新的区块链</li>
<li>在比特币区块链上使用脚本。</li>
<li>在比特币区块链上建立元协议。</li>
</ol>
</li>
<li><p>维塔利克认为，比特币系统的主要设计UTXO和其对应的脚本语言有缺陷。他总结了四点不足：</p>
<ol>
<li><p>缺少图灵完备性。尽管比特币的脚本语言可以支持多种计算，但并非所有。</p>
</li>
<li><p>价值盲：UTXO脚本不能为账户的取款额度提供精细的控制。</p>
</li>
<li><p>缺少状态：UTXO只能是已花费或者未花费状态，这意味着UTXO只能用于建立简单的、一次性的合约。</p>
</li>
<li><p>区块链盲：UTXO看不到区块链的数据，比如区块头部的随机数、时间戳和上一个区块数据的哈希值。</p>
<img src="/区块链_img/10.png" style = "zoom:80%">
</li>
</ol>
</li>
<li><p>以太坊的目标：提供一个区块链，内置有成熟的图灵完备的编程语言，用这种语言可以创建合约来编码，实现任意<strong>状态转换</strong>功能。（他认为比特币是一个状态转换系统）。</p>
<ol>
<li><p>要创建一个新的区块链。</p>
</li>
<li><p>这个区块链的特色是，有一个实现所有计算，即所谓的图灵完备的脚本编程语言。</p>
</li>
<li><p>这个脚本语言可以用来创建复杂的智能合约，用以控制区块链的状态转换，也即进行链上数字资产的转移。</p>
<blockquote>
<p>关于智能合约，在以太坊白皮书中，维塔利克用的词汇是“实现预先设定规则的一段代码”（implementing arbitrary rules）。在区块链上，这些代码的用途是控制链上的数字资产的转移。关于智能合约的更多介绍见相关冷知识专栏讨论</p>
</blockquote>
</li>
</ol>
</li>
<li><p>维塔利克认为在以太坊上可以开发的三大类应用</p>
<ol>
<li>金融应用：用他们的钱去管理和参与合约。这些应用包括子货币、金融衍生品、对冲合约、储蓄钱包、遗嘱，甚至雇用合约。</li>
<li>半金融应用：这里有钱的存在，但非金钱的方面所占的比例也很重。一个好例子是为了解决计算问题而设的自动执行的悬赏。</li>
<li>非金融应用：如在线投票和去中心化治理等。</li>
</ol>
</li>
</ol>
<h2 id="用智能合约管理数字资产与ERC20通证标准"><a href="#用智能合约管理数字资产与ERC20通证标准" class="headerlink" title="用智能合约管理数字资产与ERC20通证标准"></a>用智能合约管理数字资产与ERC20通证标准</h2><p>目前以太坊最常用的功能是通过编写智能合约来管理用通证表示的数字资产。</p>
<ol>
<li>比特币出现以后，出现了很多通过简单修改比特币开源代码的参数得到替代币。而以太坊的智能合约将创建通证的门槛降到了很低。</li>
</ol>
<img src="/区块链_img/11.png" style = "zoom:80%">

<img src="/区块链_img/10.png" style = "zoom:80%">
2. ERC721（不可互换通证标准）：比如我的一本专门题名给我的签名书和你的同一本书是不同的，二者不可互换。
3. ERC20（可互换通证）：指的是每一个通证都是一模一样的，比如任何两张100元的价值是完全相同的。符合ERC20的通证的重要用途是被用于首次代币发行的筹资。人们可以用以太币按照项目方案设定的兑换率来换取这些通证，而项目方获得以太币形式的资金。

<p><a href="http://c.biancheng.net/view/1915.html" target="_blank" rel="noopener">“V神简介”</a></p>
<h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><ol>
<li>其中智能可以理解为，按条件自动执行，无须人的干预，是自动的或者自治的。</li>
<li>其中合约应该看成是存在于以太坊执行环境中的”自治代理”，它拥有自己的以太坊账户，他们收到交易信息后就相当于被捅了一下，然后自动执行一段代码—–V神如是说。（类比有限状态机，自动售货机）</li>
<li>可以认为区块链存储的是状态，智能合约是它用于状态转换的方式。智能合约像是一个特别的时钟，把世界从同步转向异步。</li>
</ol>
<h2 id="智能资产：用智能合约来控制实体资产"><a href="#智能资产：用智能合约来控制实体资产" class="headerlink" title="智能资产：用智能合约来控制实体资产"></a>智能资产：用智能合约来控制实体资产</h2><ol>
<li><p>所谓智能财产，是智能合约程序按照设定的规则控制的财产。萨博举例说明如下：</p>
<p> 例如，为了防止一部车被偷窃，除非确定拥有者完成正确的“挑战响应协议”，否则车是不会启动激活的。<br> 例如，如果车是贷款买的，当拥有者无法偿还贷款时，智能合约将会自动启动扣押令，并将车钥匙的控制权交给银行。一旦拥有者还清贷款，智能合约就移除扣押令。</p>
</li>
</ol>
<p>目前来说：由比特币区块链上的智能合约控制的资产，不管是实体的还是数字的，都叫智能资产。</p>
<h2 id="以太坊的智能合约"><a href="#以太坊的智能合约" class="headerlink" title="以太坊的智能合约"></a>以太坊的智能合约</h2><ol>
<li>以太坊的智能合约是存在于区块链上，可以被触发执行的一段程序代码，这些代码实现了某种预定的规则，是存在于以太坊执行环境中的“自治代理”。</li>
</ol>
<img src="/区块链_img/15.png" style = "zoom:80%">

<p>注：合约账户不能自己启动运行自己的智能合约。要运行一个智能合约，需要由外部账户对合约账户发起交易，从而启动其中的代码的执行。</p>
<h2 id="以太坊的智能合约有什么用"><a href="#以太坊的智能合约有什么用" class="headerlink" title="以太坊的智能合约有什么用"></a>以太坊的智能合约有什么用</h2><ol>
<li>创建通证，通证对应的多是以太坊区块链之外的资产。</li>
<li>图 2 是一个简明的图示，这是从 Komhar 咨询公司的一个图示重绘而来的。图示是一个典型的 ERC20 通证发行过程：一个项目通过智能合约创建通证，这个通证是实体资产或线上资产的价值表示物。投资者（用户）发起交易，向智能合约转入以太币（ETH），智能合约自动运转，在满足一定规则后，它向投资者账户转入相应数量的通证。</li>
</ol>
<img src="/区块链_img/16.png" style = "zoom:80%">

<h1 id="令牌系统-token-systems"><a href="#令牌系统-token-systems" class="headerlink" title="令牌系统 token systems"></a>令牌系统 token systems</h1><p>令牌：用以表示资产的通证。</p>
<ol>
<li><p>所有的货币或者令牌系统从根本上来说都是带有如下操作的数据库：从A中减去X单位并把X单位加到B上。前提条件是</p>
<ol>
<li><p>A在交易之前至少有X单位</p>
</li>
<li><p>交易被A批准</p>
<p>实施令牌系统，即是把这样一个逻辑实例实施到一个合约之中。</p>
</li>
</ol>
</li>
<li><p>区块链能方便的承载Token系统，是因为它存储的是状态。</p>
</li>
<li><blockquote>
<p>在《商业区块链》一书中，区块链专家威廉·穆贾雅提出了一个可以用Token系统表示的事物的分类。他把区块链中可存储的事物的首字母组成了一个单词“ATOMIC”：</p>
</blockquote>
<p> 可编程的资产（assets）。</p>
<p> 可编程的信任（trust）。</p>
<p> 可编程的所有权（ownership）。</p>
<p> 可编程的货币（money）。</p>
<p> 可编程的身份（identity）。</p>
<p> 可编程的合同（contracts）。</p>
<h1 id="通证有什么用：机器比人更需要通证"><a href="#通证有什么用：机器比人更需要通证" class="headerlink" title="通证有什么用：机器比人更需要通证"></a>通证有什么用：机器比人更需要通证</h1></li>
</ol>
<img src="/区块链_img/17.png" style = "zoom:80%">

<ol>
<li>要<strong>把其他象限的价值映射到链上</strong>，用通证来表示，主要有两个途径：<ol>
<li>路径之一是，把原本在互联网上通过中心化机构的数据库表示的价值和价值转移，切换到去中心化的区块链上来。比如常见的有网络零售的支付、社交网络的积分、游戏里的道具等，反映在图中就是从象限 ② 到象限 ③。</li>
<li>路径之二是，把实体中的资产映射到链上，通过区块链进行流通。比如常见的有：把线下的民宿、供应链金融、资产证券化（ABS）中的资产用通证进行表示，反映在图中就是从象限 ③ 到象限 ①。</li>
</ol>
</li>
</ol>
<p>但实际上，以上的路通过传统的方法已经做的够好了（我们总在考虑我们手中的加密货币能兑换多少法币，这恰恰说明了法币在价值表示上已经做的很好了）</p>
<h2 id="在机器视角看通证"><a href="#在机器视角看通证" class="headerlink" title="在机器视角看通证"></a>在机器视角看通证</h2><ol>
<li><p>令牌：初始用于通信网络，只有拥有两派的节点才能参与通信，令牌代表了权力。</p>
<blockquote>
<p>一个关于令牌的例子：假设，为了防止网络中的机器发出垃圾邮件，我们设定如下规则：个人电脑或手机在发出邮件时，需要消耗一个 token；发件邮件服务器也要消耗一个 token。如果这个邮件不被垃圾邮件规则拦截，或不被个人举报为垃圾邮件，那么在一定时间内，所消耗的 token 又会回到我们手中。</p>
</blockquote>
<p> 在这里实际发生了令牌抵押，以确保我们在实施正当行为。</p>
</li>
<li><p>随着物联网技术的发展，越来越多的机器需要通证，我们的做法也不应该是给每一个传感器开设一个和法币对应的账户。这时，我们应该设计机器专用的钱包和通证。</p>
</li>
</ol>
<h1 id="ERC20通证标准"><a href="#ERC20通证标准" class="headerlink" title="ERC20通证标准"></a>ERC20通证标准</h1><p>–是通过以太坊创建通证时得到一种规范。按照ERC20的规范可以编写一个智能合约。</p>
<p><a href="http://c.biancheng.net/view/1922.html" target="_blank" rel="noopener">详解ERC20W</a></p>
<h1 id="The-DAO众筹事件与以太坊分叉"><a href="#The-DAO众筹事件与以太坊分叉" class="headerlink" title="The DAO众筹事件与以太坊分叉"></a>The DAO众筹事件与以太坊分叉</h1><h2 id="分叉的存在：比特币共识机制"><a href="#分叉的存在：比特币共识机制" class="headerlink" title="分叉的存在：比特币共识机制"></a>分叉的存在：比特币共识机制</h2><ol>
<li>分叉方案：即从某个区块开始以太坊区块链不向前兼容，从而把 The DAO 众筹来的以太币夺回来，转移到一个恢复地址上，再还给参与众筹的人。<br>比特币的共识机制本质上是通过算力进行的投票。在去中心化的网络中，一定程度上来说我们不存在真币和假币。你相信他是真的，愿意在包含这个交易的区块后面继续追加区块，维护这一区块链分支，那么他就是真的。日后，如果还要和其他人进行交易，并且他也认为你的比特币的起源是真实可靠的，那么你们就可以完成交易；反之，则会出现分歧，如果多数人都不站在你那边，那么你所拥有的比特币就来自非法交易。</li>
</ol>
<h1 id="设计通证：用通证表示资产"><a href="#设计通证：用通证表示资产" class="headerlink" title="设计通证：用通证表示资产"></a>设计通证：用通证表示资产</h1><p>有了智能合约和通证之后，以太坊就有了新的用途—进行数字资产的表示与交易。这使得数字资产也有了相对统一的价值表示形式，所以以太坊超越作为数字现金系统的比特币，开始解决如何表示资产等问题。</p>
<img src="/区块链_img/18.png" style = "zoom:80%">

<h2 id="用通证将资产表示为链上的“数字资产”"><a href="#用通证将资产表示为链上的“数字资产”" class="headerlink" title="用通证将资产表示为链上的“数字资产”"></a>用通证将资产表示为链上的“数字资产”</h2><ol>
<li><p>通证是资产在区块链上的价值表示物，涉及的资产包括：</p>
<ol>
<li>比特币，以太币等链上的原生资产、映射到链上的线上资产、映射到链上的线下资产。</li>
</ol>
</li>
<li><p>我们通过以太坊区块链和他的智能合约来创建与发行代表价值的通证，然后用它去关联资产。</p>
</li>
<li><p>以太坊上的通证包括两种：可互换的ERC20和不可互换的ERC721。可互换的通证可类比现金，不可互换的通证类比房契。</p>
 <img src="/区块链_img/19.png" style = "zoom:80%">
</li>
<li><p>链上和链下的交互包括两大部分：</p>
<ol>
<li>将链下资产与通证关联，进行通证的发行与分配。</li>
<li>在链上进行通证交易后，对链下资产进行相应的变动，并将变动在链上确认。 </li>
</ol>
</li>
<li><p>将资产表示成通证的好处：</p>
<ol>
<li><p>帮助市场交易发现价格</p>
</li>
<li><p>在流动周转中增加资产价值。</p>
<blockquote>
<p>其中，关于流动增加总体价值的例子，我们在现实生活中也可以体验到：二手物品的流动让买方和卖方都收益，车辆与房屋的共享提升了资源的利用效率。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h2 id="数字资产系统的去中心化交易场景"><a href="#数字资产系统的去中心化交易场景" class="headerlink" title="数字资产系统的去中心化交易场景"></a>数字资产系统的去中心化交易场景</h2><p>—–以太坊的出现使得基于它的智能合约创建的各种通证都可以进行中心化或去中心化交易。</p>
<ol>
<li><p>通过智能合约进行链上数字资产交易：假设我们编写一个合约，售卖一种基于 ERC721 的不可互换通证，如性质类似于收藏卡的“加密猫”。每个加密猫通证各不相同，预先在智能合约中设定价格均为 10 个以太币，购买方式是先到先得。</p>
<p> 这时，去中心化的数字资产交易过程如下：</p>
<ol>
<li><p>买方向智能合约地址转入 10 个以太币，即为发起购买邀约，智能合约担任第三方保管的角色。</p>
</li>
<li><p>卖方把该收藏卡（基于 ERC721 的通证）转入买方地址。</p>
</li>
<li><p>智能合约自动将以太币款项转入卖家账户。</p>
<p>由于这里仅涉及以太坊区块链上的数字资产（加密猫通证和以太币）的转移，因此在链上可以完成全部过程。</p>
<p>对比 A、B 两种场景我们看到，原本中心化的中介（如淘宝与支付宝）被按预先设定规则自动执行的智能合约所取代。中心化中介被区块链（即分布式账本和去中心网络）所取代。 </p>
</li>
</ol>
</li>
<li><p>通过智能合约进行涉及线下资产的交易</p>
<ol>
<li><p>当交易的不是链上的数字资产时，智能合约和预言机是一对必备的组合。智能合约在链上，预言机在链下，它可以与链上的智能合约进行通信（见图4）。</p>
 <img src="/区块链_img/20.png" style = "zoom:80%"></li>
<li><p>比如，当卖家把数字文件传递给买家，买家确认之后，连接链上和链下的预言机就发出消息通知智能合约。接到消息后，智能合约执行后续的步骤，把以太币转入卖家账户。</p>
</li>
</ol>
</li>
<li><p>对比两个场景，我们知道</p>
<ol>
<li>有了智能合约，用通证表示的数字资产就是可编程的；</li>
<li>它是可以由计算机自动处理的；</li>
<li>如果数字资产交易各方形成一定的规则与逻辑，那么这些交易方之间可以进行完全自治的交易。</li>
</ol>
<p> <strong>最终，可以大幅度降低资产流转交易的成本，提高效率，并实现智能化。</strong></p>
</li>
</ol>
<h2 id="通证的四个特征"><a href="#通证的四个特征" class="headerlink" title="通证的四个特征"></a>通证的四个特征</h2><ol>
<li>中关村区块链产业联盟理事长元道指出的通证的三个要素：<ol>
<li>第一是数字权益证明。通证必须代表一种权利，一种固有和内在的价值。</li>
<li>第二是加密。通证的真实性、防篡改性，保护隐私等特性由密码学给出。</li>
<li>第三是可流通。通证必须能够在一个网络中流通，从而随时随地都可以进行验证。<blockquote>
<p>事实上，通证可以代表一切权益证明，从身份证到学历文凭，从货币到票据，从钥匙、门票到积分、卡券，从股票到债券，人类社会的全部权益证明都可以用通证来代表。</p>
</blockquote>
</li>
</ol>
</li>
<li>第四个特点：通证是可编程的。</li>
</ol>
<p>在区块链上，可以通过智能合约自治或自动的处理通证。</p>
<img src="/区块链_img/21.png" style = "zoom:80%">

<h2 id="通过经济系统设计和通证的发行与分配"><a href="#通过经济系统设计和通证的发行与分配" class="headerlink" title="通过经济系统设计和通证的发行与分配"></a>通过经济系统设计和通证的发行与分配</h2><ol>
<li><p>回以太坊的建立过程，他起初进行了一轮众筹，严格来说，以太币的发行时中心化的，由以太币基金会发起的。但是过程时自动化的，由预先确定规则，编写后不能修改的智能合约自动执行的。</p>
<ol>
<li>中心化的原因：用区块链上的通证来表示链上资产、线上资产、线下资产时，完全的去中心化，甚至完全无人介入的自动化通常是不可行的。资产的设计、发行的设计以及后续项目的运行，都需要有机构来发起。这个机构在一定程度上是区块链项目的中心。</li>
<li>然而中心化机构只需要在初期持续运行项目和社群，直到社区能够自行运转。随着项目的发展，社区的扩大，中心化开始弱化，甚至是最终达到去中心化的状态。</li>
</ol>
</li>
<li><p>通证经济体</p>
<ol>
<li><p>通证经济体：是一个产业生态圈或社区，用通证来表示一个生态或社区的广义资产；借助通证来进行分配、交易。</p>
</li>
<li><p>核心事务：</p>
<ol>
<li><p>链：区块链技术的落实。</p>
</li>
<li><p>通证：通证的建立、分配与管理。</p>
</li>
<li><p>社群：用户社区与投资社区等以价值共识形成的社群。</p>
<img src="/区块链_img/22.png" style = "zoom:80%"></li>
</ol>
</li>
</ol>
</li>
<li><p>通证经济系统的设计：一方面是和通证的价值相关的设计，另一方面是和通证的数量相关的设计。</p>
</li>
</ol>
<img src="/区块链_img/23.png" style = "zoom:80%">

<img src="/区块链_img/24.png" style = "zoom:80%">
4. **一个例子**：假设用通证经济系统来改造一个线下社区，那么可能的初始分配包括：投资方、团队和顾问、社区成员、留存。其中社区成员按一定规则得到的通证就是将线上资产映射到链上，用通证表示出来。之后，还需要设定规则定义生态成员如何获得通证，如何使用通证，此外还需要定义相关的经济逻辑。都确定之后，就可以通过编写智能合约来用代码实现它。

<img src="/区块链_img/25.png" style = "zoom:80%">

<ol start="5">
<li><strong>通证，参考元道的说法是一种权利，不要局限于资产。他可以对应某种线上或线下的资产，也可能是代表某种功能的使用权</strong></li>
</ol>
<img src="/区块链_img/26.png" style = "zoom:80%">

<h2 id="以太坊：数字资产的基础设施"><a href="#以太坊：数字资产的基础设施" class="headerlink" title="以太坊：数字资产的基础设施"></a>以太坊：数字资产的基础设施</h2><p>之前，在以太坊的 ERC20 标准被广泛接纳之前，要发行一个原生数字资产需要自行开发一条链，而现在我们可以基于以太坊这条公链来创建一个数字资产的价值表示物。<br>#<a href=""http://c.biancheng.net/view/1931.html"">通证的分类</a></p>
<h1 id="以太坊只能合约的技术与组件"><a href="#以太坊只能合约的技术与组件" class="headerlink" title="以太坊只能合约的技术与组件"></a>以太坊只能合约的技术与组件</h1><img src="/区块链_img/39.png" style = "zoom:80%">

<h1 id="ERC721标准与加密猫"><a href="#ERC721标准与加密猫" class="headerlink" title="ERC721标准与加密猫"></a>ERC721标准与加密猫</h1><p>加密猫—基于以太坊的ERC721标准发行的加密数字宠物，每一只猫咪<strong>各不相同</strong>。在此之前人们对以太坊的认识是，它的主要应用是用它的智能合约发行符合 ERC20 标准的可互换通证，同一种通证的一枚和另一枚是完全一样的。</p>
<h1 id="以太坊的账户"><a href="#以太坊的账户" class="headerlink" title="以太坊的账户"></a>以太坊的账户</h1><p>以太币账户可以查看余额（包括以太币和其他基于ERC20标准的通证）。以太坊账户分为外部账户和合约账户。外部账户由密钥控制，合约账户由只能合约控制</p>
<img src="/区块链_img/40.png" style = "zoom:80%">

<ol>
<li>以太坊的账户包括：一个随机数、账户余额、[合约代码]，存储</li>
</ol>
<h2 id="合约账户"><a href="#合约账户" class="headerlink" title="合约账户"></a>合约账户</h2><ol>
<li>只有合约账户才有代码，存储的是这个账户的以太坊虚拟机代码的哈希值。生成后不可修改，即智能合约代码不能修改。</li>
<li>合约账户可以设置多重签名</li>
</ol>
<h2 id="外部账户"><a href="#外部账户" class="headerlink" title="外部账户"></a>外部账户</h2><ol>
<li>外部账户可以触发交易，而合约账户不能主动发起交易，只能在被触发后执行代码。</li>
</ol>
<h2 id="以太坊的区块"><a href="#以太坊的区块" class="headerlink" title="以太坊的区块"></a>以太坊的区块</h2><ol>
<li>区块中存交易，本质是状态转移函数。一个交易触发它的执行，它将相应的账户从一个状态转变成新状态，然后将新状态存储在区块链的数据区块中。</li>
<li>以梅克尔帕特丽夏树组织。</li>
</ol>
<h1 id="区块链的四大特征—区块链有什么用"><a href="#区块链的四大特征—区块链有什么用" class="headerlink" title="区块链的四大特征—区块链有什么用"></a>区块链的四大特征—区块链有什么用</h1><img src="/区块链_img/41.png" style = "zoom:80%">

<h2 id="一-不可篡改"><a href="#一-不可篡改" class="headerlink" title="一 不可篡改"></a>一 不可篡改</h2><ol>
<li>要修改一个区块中的数据，那么就要生成后面所有的区块。</li>
<li>共识机制的重要作用之一是使得修改大量区块的成本极高，从而几乎不可能。</li>
<li><strong>应用</strong>：农产品或商品溯源的应用：将它们的流通记录在区块链上，以确保数据记录不被篡改，从而提供追溯的证据。</li>
</ol>
<blockquote>
<p>2018 年 3 月，在网络零售集团京东发布的《区块链技术实践白皮书》中，京东认为，区块链技术（分布式账本）的三种应用场景是：跨主体协作，需要低成本信任，存在长周期交易链条。这三个应用场景所利用的都是区块链的不可篡改特性。多主体在一个不可篡改的账本上协作，降低了信任成本。区块链账本中存储的是状态，未被涉及的数据的状态不会发生变化，且越早前的数据越难被篡改，这使得它适用于长周期交易。 </p>
</blockquote>
<h2 id="二-表示价值所需要的唯一性"><a href="#二-表示价值所需要的唯一性" class="headerlink" title="二 表示价值所需要的唯一性"></a>二 表示价值所需要的唯一性</h2><ol>
<li>中心化账本存在是因为在数字世界中，文件可以复制。<blockquote>
<p>2018 年年初，中国的两位科技互联网企业领袖不约而同地强调了区块链带来的“唯一性”。腾讯主要创始人、CEO 马化腾说：“区块链确实是一项具有创新性的技术，用数字化表达唯一性，区块链可以模拟现实中的实物唯一性。”</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>百度创始人、CEO 李彦宏说：“区块链到来之后，可以真正使虚拟物品变得唯一，这样的互联网跟以前的互联网会是非常不一样的。”</p>
</blockquote>
<h2 id="三-智能合约"><a href="#三-智能合约" class="headerlink" title="三 智能合约"></a>三 智能合约</h2><ol>
<li><p>智能合约的出现使得基于区块链的两个人不只是可以进行简单的价值转移，而是可以设置复杂的规则，由智能合约来进行自治，自动的管理。</p>
</li>
<li><p>智能合约的性质：相当于一种特殊的服务端后台程序。</p>
<blockquote>
<p>在以太坊白皮书中，维塔利克写道：（合约）应被看成是存在于以太坊执行环境中的“自治代理”（autonomous agents），它拥有自己的以太坊账户，收到交易信息，它们就相当于被捅了一下，然后它就自动执行一段代码。</p>
</blockquote>
</li>
<li><p>编写智能合约</p>
 <img src="/区块链_img/42.png" style = "zoom:80%">
</li>
<li><p><strong>区块链的新认识</strong></p>
<ol>
<li>区块链：是分布式账本技术。各方共同维护一个共享、互通、互联的账本，在此账本上就价值的确认、交易、分配达成共识。</li>
<li>区块链：是基于分布式账本技术的自治执行机制，即把区块链等同于智能合约。<ol>
<li>在没有通证的情况下，通过智能合约的自动/自治执行，进行数字资产的交易。</li>
<li>在有通证的情况下，通过智能合约的自治执行，进行通证形式的数字资产的交易。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="四-去中心自组织"><a href="#四-去中心自组织" class="headerlink" title="四 去中心自组织"></a>四 去中心自组织</h2><p>—-可能会失控，但失控也是一种自治。</p>
<ol>
<li><blockquote>
<p>在《去中心化应用》一书中，作者西拉杰·拉瓦尔（Siraj Raval）还从另一个角度进行了区分，他的这个区分有助于我们更好地理解未来的应用与组织。他从两个维度看现有的互联网技术产品：一个维度是，在组织上是中心化的，还是去中心化的；另一个维度是，在逻辑上是中心化的，还是去中心化的。</p>
</blockquote>
</li>
</ol>
<pre><code>他认为：“比特币在组织上去中心化，在逻辑上集中。”而电子邮件系统在组织上和逻辑上都是去中心化的

&lt;img src=&quot;/区块链_img/43.png&quot; style = &quot;zoom:80%&quot;&gt;</code></pre><ol start="2">
<li><strong>区块链在技术之外的意义</strong> 可能作为基础设施支持人类的生产组织和协同的变革。这正是区块链与互联网是完全同构的又一例证，互联网也不仅仅是一项技术，它改变了人们的组织和协同。</li>
<li><strong>再看以太坊</strong> 以太坊将区块链技术带入了新的阶段，带来了智能合约和通证。作为价值表示物的通证，它的角色类似于 HTML。在有了 HTML 之后，建什么样的网站完全取决于我们的想象力。</li>
</ol>
<h1 id="区块链3-0"><a href="#区块链3-0" class="headerlink" title="区块链3.0"></a>区块链3.0</h1><h2 id="类比理解"><a href="#类比理解" class="headerlink" title="类比理解"></a>类比理解</h2><ol>
<li><p>类比操作系统的市场</p>
<blockquote>
<p>在 2016 年出版的《商业区块链》一书中，区块链专家威廉·穆贾雅以“数以百万计的区块链”（Getting to millions of blockchains）作为一个小节的标题。从整体上，他展望的未来图景是：“随着公有、私有、半私有、特殊目的以及其他类型的区块链的增长扩散，数以百万计的区块链世界将会实现。”这个说法可能展现了最可能的区块链未来图景。</p>
</blockquote>
<p> 区块链的未来很可能不止是一条。</p>
</li>
<li><p>类比网站</p>
<blockquote>
<p>威廉·穆贾雅还做了一个虽然不甚准确但易懂的类比——“区块链将会成为新的网站”。在回顾了从 20 世纪 90 年代开始的网站发展史后，他类比指出：“每个公司一定会拥有或参与各种各样的区块链，无论它们是私有的、半私有的或公共的。”</p>
</blockquote>
</li>
<li><p>类比为云服务平台</p>
<ol>
<li>和现有的云不同，他们的核心功能是价值交易。</li>
</ol>
</li>
</ol>
<h2 id="作为云服务的区块链3-0"><a href="#作为云服务的区块链3-0" class="headerlink" title="作为云服务的区块链3.0"></a>作为云服务的区块链3.0</h2><ol>
<li>以太坊曾把自己定位为一台“全球分布式计算机”。在《区块链革命》中，商业思想家唐·塔普斯科特这样写道：“区块链上运行的所有计算资源可以在整体上视为一台计算机。”</li>
<li>区块链3.0从一个个的通证进化到一个个的应用，会使得它的基础模型可能与已知的以太坊模型有很大的不同。</li>
<li>目前，人们关注的焦点往往是性能问题，比如以太坊计划通过改用 POS 共识机制（casper）和分片技术（sharding）来提升性能，又比如人们关注 EOS 采用委托权益证明机制（DPOS）来提升性能。或许，架构也需要改变。</li>
<li>要看待这一个个应用（App），可以有两种方式：既可以把它们看成是区块链操作系统上的软件，它们用的是一条区块链的分布式账本和去中心网络；也可以把这些应用看成类似于一条条链，它们有着自己的分布式账本与去中心网络。<ol>
<li>类比地看，在云服务出现之前，要开发一个网站或应用，我们要自己架设和运维服务器；而有了云服务之后，我们可以在云服务上开发自己的应用。在采用云服务时，一个个应用就有自己的一组专用服务器，像之前一样。类似地，如果采用类似的架构来开发区块链的应用，则可以认为，一个个应用也像有着自己的一条条独立的区块链。</li>
<li>现在的各个作为基础公链的区块链项目，做的正是云服务：以开源软件系统、分布式账本、去中心网络为基础，提供一系列和价值有关的云计算服务。</li>
<li>现在，对试图在各个领域或产业中实际应用区域链的人来说，要在区块链上开发应用，需要的正是一个类似的云服务架构：区块链的软件系统、分布式账本与去中心网络，从及一系列云计算软件服务。</li>
<li>当然，区块链云服务与现有的云服务也有很多不同：<ol>
<li>它提供的云计算软件服务是基于分布式账本与去中心网络的。</li>
<li>软件系统通常不是由一家公司开发，而是由社区开发的，以开源方式发布。</li>
<li>去中心网络不是由一家公司运维，而是由不同主体出于经济激励而自主提供的。</li>
<li>一系列云计算软件服务也不是由一家公司提供，而是由社区提供的。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="走向应用的五条路径"><a href="#走向应用的五条路径" class="headerlink" title="走向应用的五条路径"></a>走向应用的五条路径</h2><img src="/区块链_img/44.png" style = "zoom:80%">

<ol>
<li><p>以超级账本为代表的联盟链软件：</p>
<ol>
<li>与比特币，以太坊等公有链不同，联盟链需要经过许可才能加入。联盟链有其特定的用途，较为适合大型公司在自己的内部部署使用，或部署后在自己的产业链生态中邀请合作伙伴接入，也可以由产业联盟共同部署。</li>
<li>从互联网的发展经验来看，区块链的未来只要还是开辟一套基础公链。目标是开发一条有通用功能或专一功能的公有链，并同时做三件事：开发软件，运行系统，运行社区。</li>
</ol>
</li>
<li><p>基础公链：通用类</p>
<p> 开发一条通用类的基础公链。代表EOS（一个更快，更好，更适合应用开发的以太坊）</p>
</li>
<li><p>基础公链：功能类</p>
<p> 开发专用于某类功能的区块链，代表IOTA（专用于物联网等），Steem和Steemit（专用于数字内容），再比如比原链（专用于数字资产交换，按白皮书披露的信息它要做到的是，连通比特世界与原子世界，实现“比特资产”（原生的数字货币、数字资产）和“原子资产”（有传统物理世界对应物）的交互与流转。 ）</p>
</li>
<li><p>基础公链：行业类</p>
<p> 开发专用于某个行业的区块链，充分考虑该行业的特点提供相关的功能，比如保险、供应链金融、游戏、政务等。</p>
</li>
<li><p>基础设施 跨链的资产交易</p>
<p> 可以预见的是区块链世界中必然有着很多链，甚至是非常多的链的共存。链与链之间的功能或资产的连接就变得非常重要。</p>
<blockquote>
<p>2018 年年初，新区块链项目区块基石（ArcBlock）自称是区块链 3.0，它的核心是提供跨链的协议，并以云服务的形式为开发者提供便利。另一个新项目梵塔网络（Penta）则定位在做“区块链世界的连接器”，要实现三大连接——链与链的连接、链与中心化系统的连接、链下与链上价值的连接，即为了推进区块链的应用，不只是连接不同的链，连接链上与链下，更要在需要时连接链与中心化系统。<br>在鲸准研究院与节点资本研究中心的“侧链跨链研究报告”（2018年）中，它认为侧链与跨链在技术上大体相似，只有在谈到它们的服务对象时才需做细致的区分：一般来说，侧链服务于主链，而跨链试图改进的是链之间价值和功能的连通。其实，现在区块链领域的主要应用之一“币币交易所”实质上做的也是跨链资产的交易，只是目前采用的主要还是中心化的方式。目前，主要的交易所都推出了自己的通证（一般称平台币），并公布基础公链计划，也即准备用区块链技术来改进自身业务。</p>
</blockquote>
</li>
<li><p>基础设施 服务中心化应用</p>
<p> 随着去中心化应用的出现，各种基础性技术服务成为刚需。如星际文件系统，分布式文件存储等。</p>
</li>
<li><p>区块链3.0 类比云服务</p>
 <img src="/区块链_img/45.png" style = "zoom:80%">

</li>
</ol>
<h2 id="从多个网到多条链"><a href="#从多个网到多条链" class="headerlink" title="从多个网到多条链"></a>从多个网到多条链</h2><p>雷纳特·卡桑辛（Renat Khasanshyn）曾展示他基于联盟链理解的区块链应用未来。现在的各类系统，比如相互连接在一起的金融系统，是由多个中心化的数据库组成的。用区块链技术来改造这些系统，他的设想是，在合适的地方用相应的区块链来取代原来的数据库（见图 6）。从图 6 中可以看到，中心化的数据库被去中心化的区块链所取代。</p>
<h1 id="EOS、比特币、以太坊"><a href="#EOS、比特币、以太坊" class="headerlink" title="EOS、比特币、以太坊"></a>EOS、比特币、以太坊</h1><ol>
<li><p>EOS 是一款企业操作系统（区块链软件系统）,其目的是将一切去中心化。</p>
<p> 从 2017 年年中开始，经过一年的代币众筹后，它于 2018 年 6 月 15 通过由数十个区块生产者（block producer，BP，又称超级节点）组成的社区上线了主网，EOS 主网这条主要的区块链开始正式运转。</p>
</li>
<li><p>EOS包括三个部分：</p>
<ol>
<li>EOSIO软件，一共社区开发 的开源软件，任何人都可以参与开发、提交代码。</li>
<li>EOS币（EOS通证）</li>
<li>EOS主网：通过竞选，一批区块生产者被选出来，它们启动EOS主网。</li>
</ol>
</li>
<li><p>EOS账户：</p>
<ol>
<li>外部账户：由私钥控制</li>
<li>合约账户</li>
<li>与账户相关的概念：<ol>
<li>钱包：保存密钥的客户端；</li>
<li>权限：包裹owner和active，用户可自定义各种权限。</li>
</ol>
</li>
</ol>
</li>
<li><p>EOS的智能合约：<br> 其含义非常接近与linux的后台应用，节点在启动时包括缺省合约。</p>
<ol>
<li>调用方法：用户命令调用；EOSIO的send方法调用</li>
</ol>
</li>
</ol>
<h2 id="EOS-VS-以太坊"><a href="#EOS-VS-以太坊" class="headerlink" title="EOS VS 以太坊"></a>EOS VS 以太坊</h2><img src="/区块链_img/46.png" style="zoom:80%">

<ol>
<li>以太坊是比特币的改进，EOS是以太坊的改进（进化到应用）</li>
<li>以太坊的设计思路类似于高速公路。在这条收费高速公路上，车辆行驶需要付费。它早期募集资金，建设“高速公路”，早期投资者享有“高速公路”的主要权益。之后，一起建设与维护“高速公路”的挖矿节点也可以获得挖矿奖励与交易费收益。在以太坊网络中，由于各类项目已经基于它生成了大量的通证，以太坊网络的交易量相对较多，挖矿节点获得的交易费收益占比高于比特币。</li>
<li>EOS 的设计思路则类似于房地产开发。Block.one 公司在将土地售卖出去之后，逻辑上它用获得的资金进行基础的开发，此后每年再以类似填海造田的方式增加 5% 的土地出来。</li>
<li>EOS 网络要依靠超级节点（即区块生产者）来各自建设、共同运营，按现在的设计，这些节点共同获得每年 1% 新增发的 EOS 作为回报。其繁荣程度主要取决于超级节点能否建设号自己的地盘。</li>
<li>实际上，EOS的实际情况是：BlockOne公司募集资金开发一个名为EOSIO的开源软件。EOS社区通过这个软件运行EOS主网。EOS是对以太坊的改进，各中由EOSIO运行起来的区块链网络，也可以做以太坊能做的事。</li>
</ol>
<h2 id="EOS的超级节点竞选"><a href="#EOS的超级节点竞选" class="headerlink" title="EOS的超级节点竞选"></a>EOS的超级节点竞选</h2><ol>
<li>EOS采用的共识机制是DPOS（委托权益证明），即一些节点在获得足够多的投票后，成为见证人节点或EOS中所说的区块链生产者，<strong>负责区块的生成</strong>。</li>
<li>基于区块链的思路开发的软件系统的关键要求：<ol>
<li>一是性能：它的去中心化网络的整体性能能否支撑大量应用。</li>
<li>二是网络：它的共识机制、经济激励和社区运营能否吸引足够多的节点加入，形成安全可靠的去中心网络。</li>
<li>三是功能：无论目标是通用类，功能类还是行业类，它是否提供了应用开发所需要的必备功能。</li>
</ol>
</li>
<li>超级节点竞选（DPOS）是一种激励。通过DPOS来刺激形成一个活跃的去中心网络，并且，超级节点竞选时与其共识机制DPOS高度匹配的。区块生产则时动态的，时刻根据投票动态调整。<blockquote>
<p>EOS 的区块链生产者的收益分配机制是，区块生产者一共可获得每年新增出来的 1% 的 EOS 通证作为回报，其中 0.25% 按每个区块来进行奖励，0.75% 按所获投票来进行分配。可参见 2018 年 5 月 12 日项目发布的信息。</p>
</blockquote>
</li>
</ol>
<h2 id="EOS-的共识机制"><a href="#EOS-的共识机制" class="headerlink" title="EOS 的共识机制"></a>EOS 的共识机制</h2><p>所有的出块者都要对所有区块签名，以确保在同一时间戳或者同一区块高度上，没有区块生产者能够同时在两个区块上签名。一旦一个区块有了 15 个区块生产者的签名，该区块就被认为是不可逆的。任一区块生产者如果想在同一时间戳或者同一区块高度的两个区块上签名，就会留下密码学证据。在这一模式下，一秒之内就可以达成不可逆的共识。</p>
<ol>
<li>EOSIO 设定每0.5秒产生一个区块，每126个区块为一个周期（每个出块者6个区块，乘以21个出块者）。在每个出块周期开始时，软件会根据通证持有人投票选出21个区块生产者。每个生产的区块要获得15个以上的区块生产者的签名即变成不可逆的交易。</li>
<li>如果在计划的时间内没有成功出块，则跳过该块，产生0.5秒的空白。如果出块者错过了一个区块，并且在最近24小时内都没有产生任何区块，则这个出块者将被踢出考虑范围，直至他们通知区块链可以重新开始产生区块。这确保了网络的顺利运行。</li>
</ol>
<h1 id="区块链的不可能三角"><a href="#区块链的不可能三角" class="headerlink" title="区块链的不可能三角"></a>区块链的不可能三角</h1><img src="/区块链_img/47.png" style="zoom:80%">


<p>对比一下比特币和 EOS：比特币系统看重的是去中心化和安全，而牺牲了可扩展性；EOS 在一定程度上牺牲了去中心化，而去追求可扩展性与安全。</p>
<h1 id="去中心化的应用"><a href="#去中心化的应用" class="headerlink" title="去中心化的应用"></a>去中心化的应用</h1><ol>
<li><p>EOS白皮书中给出了区块链应用的六个条件：</p>
<ol>
<li>支持百万级别的用户，需要能够处理数千万日活跃用户的区块链技术。</li>
<li>使用免费，应用开发人员需要具备灵活性，能够为用户提供免费服务；用户不必为了使用平台或从平台的服务中受益而付费。</li>
<li>轻松升级和故障修复，区块链平台必须对软件和智能合约的升级提供支持。</li>
<li>延迟低，及时地反馈是良好用户体验的基础。</li>
<li>串行性能，有些应用程序由于必须顺序执行命令，无法用并行算法进行实现。区块链需要提供强大的串行性能支持。</li>
<li>并行性能，大型应用程序需要在多个CPU和计算机之间分配工作负载。</li>
</ol>
</li>
<li><p>早期的应用:将会在区块链上出现原生的区块链应用或去中心化应用。</p>
</li>
<li><p>如果单独看一条区块链的应用，情形可能如图 2 所示。</p>
<ol>
<li>这条区块链是分布式账本与去中心网络，它提供着一系列与价值相关的数据和功能。</li>
<li>多个应用接入区块链网络。在这些应用中，有的可能是普通用户可以使用的，是网站/移动 App 与区块链应用的组合；有的可能是纯粹的区块链应用。<pre><code>&lt;img src=&quot;/区块链_img/48.png&quot; style=&quot;zoom:80%&quot;&gt;</code></pre></li>
</ol>
</li>
<li><p>有的应用可能接入多个区块链，比如现在常见的应用交易所、钱包就接入多个区块链。</p>
</li>
<li><p>去中心化应用可以从去财富中心化和去计算中心化入手。</p>
</li>
<li><p>区块链3.0的先驱者EOS为应用而做的三件事：用户免费、账户与权限体系、存储系统。 </p>
</li>
</ol>
<h2 id="区块链应用实例—Steemit博客"><a href="#区块链应用实例—Steemit博客" class="headerlink" title="区块链应用实例—Steemit博客"></a>区块链应用实例—Steemit博客</h2><ol>
<li>基于Steem区块链上存储价值，并按照内容贡献进行分配。</li>
<li>基于这条区块链建有多个应用：普通用户可用的 Steemit 博客平台、视频平台 DTube 等；常备的应用如区块链浏览器 steemd.com 网站。它的社区算是较为活跃的，还有其他的很多应用。</li>
</ol>
<h2 id="用户免费"><a href="#用户免费" class="headerlink" title="用户免费"></a>用户免费</h2><p>—-用户不必为了使用平台或从平台的服务中收益而付费。</p>
<ol>
<li><p>使用一个区块链应用需要三种资源，均由维护这个去中心网络的计算机提供。分别是：</p>
<ol>
<li>带宽资源：带宽和日志存储。(磁盘)</li>
<li>计算资源：计算和计算积压。（CPU）</li>
<li>状态资源：状态存储。（RAM）</li>
</ol>
</li>
<li><p>关于状态：区块链账本中存储的是状态，比如交易账本、账户余额等，按其名字缩写为 RAM，它的性质大约相当于内存。EOS 还特别举例说明，什么应该存入状态，什么不应该存入状态。例如，一个区块链应用程序的逻辑不需要读取博客文章的内容和评论，因此它们不应该存储在区块链的状态中。但是，博客文章或评论是否存在、投票数以及其他属性，需要存在区块链的状态之中。</p>
<p> <strong>简单的说，区块链是用于交易的，区块链的状态是交易账本，那么，与交易相关的信息应该存入交易账本，而与交易无关的信息不应存入交易账本。</strong></p>
</li>
<li><p>EOS中的三种资源的消耗机制：区块生产者（BP）公布可用的带宽（bandwidth）、计算（computation）和状态（state）的容量。EOSIO 系统允许每个账户消耗一定比例的可用资源，这个比例是根据账户将自己持有的通证存入“三天抵押合约”的数量决定的。</p>
</li>
<li><p>关于交易费：</p>
<ol>
<li>以太币和比特币中都需要交易的发起方设定一个交易费，付给区块链网络，从而使网络能够处理这一交易。</li>
<li>EOS的逻辑是去中心化应用程序不应该强迫它的用户为使用区块链而支付费用。具体实现是由应用自己决定采用什么方式，通常为了用户使用，应用会自行解决，从而使得用户看上去是免费的。</li>
</ol>
</li>
<li><p>交易成本与通证价值分开</p>
<ol>
<li><p>在以太坊的网络中，我们交易支付以太币，随着以太币价格的涨跌，交易成本也随之变化。</p>
</li>
<li><p>EOS的逻辑是使交易成本与通证价值无关。EOS的做法是，一个应用拥有的带宽、计算、状态等资源，是与其持有的通证数量有关的，但由于不需要消耗，因此一定程度上与通证价值无关。</p>
</li>
<li><p>如果应用开发者不持有足够多的通证，则EOS网络还有一种“将资源能力授权出去”的机制，通证持有人可以不立刻消耗可用带宽或全部资源，可以将未消耗的带宽委托或租赁给其他人。</p>
<blockquote>
<p>根据 EOSIO 文档，这里的状态可认为指的是一个应用所占用的区块链网络的 RAM 存储空间。原文为：Storage of application state will require an application developer to hold tokens until that state is deleted.If state is never deleted,then the tokens are effectively removed from circulation.</p>
</blockquote>
<blockquote>
<p>对比以太坊和 EOS 我们可以看到，在以太坊中进行交易，个人用户需要支付交易费，而在 EOS 中进行交易，则是应用提供者需要承担成本，现在看来其中主要的成本是与 RAM 存储空间相关的。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h2 id="账户与权限体系"><a href="#账户与权限体系" class="headerlink" title="账户与权限体系"></a>账户与权限体系</h2><ol>
<li>比特币：没有账户，所有比特币交易都是地址见的交换。</li>
<li>以太坊：引入了账户。每个账户包括四个信息：一个随机数、账户的余额、合约代码（如果有的话）、存储（通常为空）。分为外部账户和合约账户。这里的合约代码相当于以太坊中的自治代理。</li>
</ol>
<h3 id="EOS账户"><a href="#EOS账户" class="headerlink" title="EOS账户"></a>EOS账户</h3><ol>
<li>一个EOS账户可以发送动作给另一个账户，而每个账户都可以设定一个处理器来自动处理发给自己的动作。动作与处理器的结合就是智能合约。</li>
<li>EOS系统提供了一个标准的基于角色的权限系统。允许每个用户持有者定义自己的权限层次结构以及动作的分组。</li>
<li>其账户系统包含两个缺省的权限组：最高级别的缺省是owner，第二个缺省权限组是active，其他的权限组都可以由active派生出来</li>
</ol>
<h2 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h2><p>—与交易相关的数据被存储在区块链中，那么应用相关数据放在哪呢？</p>
<ol>
<li>目前EOS的想法是存储在基于IPFS的EOS存储中。</li>
</ol>
<h2 id="总结-区块链的定义七-八"><a href="#总结-区块链的定义七-八" class="headerlink" title="总结 区块链的定义七 八"></a>总结 区块链的定义七 八</h2><img src="/区块链_img/49.png" style="zoom:80%">

<img src="/区块链_img/50.png" style="zoom:80%">

<h1 id="EOS账户的密钥被盗找回"><a href="#EOS账户的密钥被盗找回" class="headerlink" title="EOS账户的密钥被盗找回"></a>EOS账户的密钥被盗找回</h1><ol>
<li>基于它的用户权限机制</li>
<li>在这种情况下，你可以用过去 30 天中有效的 owner 权限对应的私钥，和你预先设定的账户恢复合作伙伴（account recovery partner）重置账户的私钥。这样你可能夺回了账户的所有权。</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>IPtablesExp</title>
    <url>/2020/01/20/IPtablesExp/</url>
    <content><![CDATA[<h1 id="实验内容报告及展示见代码仓库"><a href="#实验内容报告及展示见代码仓库" class="headerlink" title="实验内容报告及展示见代码仓库"></a><a href="https://github.com/Cccceb/BTF/tree/master/IPtablesExp">实验内容报告及展示见代码仓库</a></h1><h1 id="iptables-基础"><a href="#iptables-基础" class="headerlink" title="iptables 基础"></a>iptables 基础</h1><p>iptables本身不是防火墙，可以理解为一个客户端代理，通过iptables来设定规则，最终运行在netfilter框架下。</p>
<h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h2><p>当客户端访问服务器的时候，客户端发送报文到网卡，通过内核的TCP协议传输到用户空间的web服务器中，而此时，客户端报文的目标终点为web服务所监听的套接字。当web服务需要相应客户端请求时，web服务发出的响应报文的目标终点为客户端。netfilter作为内核的一部分，所有进出的报文都要通过这些关卡。于是，就有了input和output关卡，在iptables中，这些关卡称为链。除了通往本机的链，还有PREROURING(路由前)、FORWARD(转发)、POSTROUTING(路由后)。</p>
<img src="/iptables_img/29.png" style="zoom:80%">

<h2 id="链"><a href="#链" class="headerlink" title="链"></a>链</h2><ol>
<li>防火墙的功能是对经过的报文匹配规则，然后执行对应的动作。对于每个关卡，都不止一条规则，故称为链。</li>
</ol>
<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><ol>
<li>表：我们把具有相同功能的规则的集合叫做表。</li>
<li>iptables预定义了四种表<ol>
<li>filter表：负责过滤功能，防火墙；内核模块：iptables_filter</li>
<li>nat表：负责网络地址转换功能。内核模块：iptable_nat</li>
<li>mangle表：拆解报文，做出修改，并重新封装的功能；iptables_mangle</li>
<li>raw表：关闭nat表上启用的连接追踪机制；iptable_raw<br>也就是说，我们自定义的所有规则都是这四种分类中的规则。</li>
</ol>
</li>
</ol>
<h2 id="表链关系"><a href="#表链关系" class="headerlink" title="表链关系"></a>表链关系</h2><ol>
<li>prerouting：规则存在于raw,mangle,nat.</li>
<li>INPUT:规则存在于mangle,filter.</li>
<li>FORWARD:规则存在于mangle,filter.</li>
<li>OUTPUT:规则存在于raw,mangle,nat,filter.</li>
<li>POSTROUTING:规则存在于mangle,nat.</li>
<li>实际使用中，往往以表为入口，对规则进行定义。</li>
<li>表链关系：<img src="/iptables_img/31.png" style="zoom:80%"></li>
<li>表的优先级：raw&gt;mangle&gt;nat&gt;filter</li>
<li>我们也可以在某个表中创建自定义链，将针对某个应用程序所设置的规则放置在这个自定义链中，但是自定义链接不能直接使用，之恶能被某个默认的链当作动作去调用才能起作用。</li>
</ol>
<h2 id="数据经过防火墙的流程"><a href="#数据经过防火墙的流程" class="headerlink" title="数据经过防火墙的流程"></a>数据经过防火墙的流程</h2><img src="/iptables_img/32.png" style="zoom:80%">
## 规则
1. 规则：根据指定的匹配条件来尝试匹配每个流经此处的报文，一旦匹配成功，则由规则后面指定的处理动作进行处理。

<h1 id="iptables实际操作之规则查询"><a href="#iptables实际操作之规则查询" class="headerlink" title="iptables实际操作之规则查询"></a>iptables实际操作之规则查询</h1><ol>
<li><strong>命令</strong> iptables -t filter -L<ol>
<li>-t指定要操作的表</li>
<li>-L列出规则</li>
</ol>
</li>
<li>如果我们要定义过滤规则，那么我们会在filter中定义，但是具体在那条链上实现，取决于我们的工作场景。</li>
<li>举例：<ol>
<li>我们需要禁止某个IP地址访问我们的主机，我们则需要在INPUT链上定义规则</li>
</ol>
</li>
<li><strong>命令</strong> iptables -t filter -vL INPUT 查看详细信息<ol>
<li>pkts 对应规则匹配到的报文的个数</li>
<li>bytes 对应匹配到的报文包的大小总和。</li>
<li>target 往往表示规则对应的动作，即匹配成功后需要采取的措施。</li>
<li>prot 表示规则对应的协议，是否只针对某些协议应用次规则。</li>
<li>opt 表示规则对应的选项。</li>
<li>in 表示数据包由哪个接口流入，我们可以设置通过哪块网卡流入的报文需要匹配当前规则。</li>
<li>out 表示数据包由哪个接口流出，我们可以设置通过哪块网卡流出的报文需要匹配当前规则。</li>
<li>source 表示规则对应的源地址，可以时一个IP，也可以是一个网段。</li>
<li>destination 表示规则对应的目的地址。可以是一个IP也可以是一个网段。</li>
</ol>
</li>
<li><strong>命令</strong> iptables -nvl INPUT不进行名称反解。</li>
<li><strong>命令</strong> iptables –line-number -nvL INPUT</li>
<li>命令小节<img src="/iptables_img/33.png" style="zoom:80%">

</li>
</ol>
<img src="/iptables_img/34.png" style="zoom:80%">

<h1 id="iptables规则管理"><a href="#iptables规则管理" class="headerlink" title="iptables规则管理"></a>iptables规则管理</h1><ol>
<li><strong>命令</strong> iptables -F INPUT 清空规则</li>
<li><strong>如果报文已经被前面的规则匹配到，iptables则会对报文执行相应动作，即使后面的规则也能匹配到当前报文，也没有机会对报文执行修改</strong></li>
<li>使用修改指令的时候，如果我拒绝某个源地址发来的包，但是修改时又没有指定对应的源地址，那么源地址会自动编程0.0.0.0，如果是为远程服务器配置iptables，那么正在使用的链接也会和中断。</li>
<li>REGECT&amp;DROP<ol>
<li>DROP丢弃而不返回，ping命令所在机器永远得不到回应</li>
<li>REGECT 返回拒绝，通知目的端不可达。</li>
</ol>
</li>
<li><img src="/iptables_img/35.png" style="zoom:80%">

</li>
</ol>
<img src="/iptables_img/36.png" style="zoom:80%">

<img src="/iptables_img/37.png" style="zoom:80%">

<img src="/iptables_img/38.png" style="zoom:80%">

<h1 id="匹配条件总结"><a href="#匹配条件总结" class="headerlink" title="匹配条件总结"></a>匹配条件总结</h1><h2 id="s参数：匹配源地址"><a href="#s参数：匹配源地址" class="headerlink" title="-s参数：匹配源地址"></a>-s参数：匹配源地址</h2><ol>
<li>可以是由逗号隔开的多个参数</li>
<li>可以通过指定子网掩码来指定某个网段</li>
<li>可以对某个地址取反，达到白（黑）名单的目的。但是存在问题，比如链上规则设定为不是某个源即进行-j操作；如果是，则继续匹配其他条件（都不匹配，则执行默认操作）。</li>
</ol>
<h2 id="d参数：匹配目的地址"><a href="#d参数：匹配目的地址" class="headerlink" title="-d参数：匹配目的地址"></a>-d参数：匹配目的地址</h2><p><strong>取反操作与同时指定多个IP的操作不能同时使用</strong></p>
<h2 id="p参数：匹配协议类型"><a href="#p参数：匹配协议类型" class="headerlink" title="-p参数：匹配协议类型"></a>-p参数：匹配协议类型</h2><ol>
<li><p>例如拒绝tcp请求 </p>
<p> iptables -I INPUT -s 192.168.1.146 -d 192.168.1.156 -p tcp -j REJECT</p>
<p> 使用ssh链接测试</p>
</li>
<li><p>-p支持的协议类型：</p>
<ol>
<li>tcp,udp,udplite,icmp,icmpv6,esp,ah,sctp,mh</li>
<li>缺省形况下，默认为-p all</li>
</ol>
</li>
</ol>
<h2 id="i参数：匹配流入的网卡-o匹配流出的网卡"><a href="#i参数：匹配流入的网卡-o匹配流出的网卡" class="headerlink" title="-i参数：匹配流入的网卡 -o匹配流出的网卡"></a>-i参数：匹配流入的网卡 -o匹配流出的网卡</h2><ol>
<li>通过ifconfig查询</li>
<li>-i 网卡名 来指定匹配</li>
<li>只能用来判断流入的包，故用于<ol>
<li>ROUTING 链</li>
<li>INPUT 链</li>
<li><strong>FORWARD 链</strong></li>
</ol>
</li>
<li>-o 用于匹配报文从哪个网卡流出，用于<ol>
<li>OUTPUT 链</li>
<li><strong>FORWARD 链</strong></li>
<li>POSTROUTING 链</li>
</ol>
</li>
</ol>
<h2 id="dport-扩展目的端口"><a href="#dport-扩展目的端口" class="headerlink" title="-dport 扩展目的端口"></a>-dport 扩展目的端口</h2><ol>
<li>dport(destination-port)<ol>
<li><strong>使用dport之前必须先使用-p选项</strong></li>
<li>之后使用-m指定扩展模块，缺省情况下，默认为于-p指定的协议同名。</li>
<li>最后，使用-dport指定目标端口</li>
</ol>
</li>
</ol>
<h2 id="sport-匹配源端口"><a href="#sport-匹配源端口" class="headerlink" title="-sport:匹配源端口"></a>-sport:匹配源端口</h2><ol>
<li>不管是sport还是dport都可以指定端口范围，如22：25</li>
<li>multiport模块：<ol>
<li>若要指定离散的端口，需要借助multiport模块。端口号间以逗号隔开。并且，这些端口中可以包含连续端口号。</li>
<li><strong>只有tcp,udp可以使用</strong></li>
</ol>
</li>
</ol>
<h2 id="基本匹配条件总结"><a href="#基本匹配条件总结" class="headerlink" title="基本匹配条件总结"></a><a href=""http://www.zsythink.net/archives/1544"">基本匹配条件总结</a></h2><h1 id="常用扩展模块"><a href="#常用扩展模块" class="headerlink" title="常用扩展模块"></a><a href=""http://www.zsythink.net/archives/1564"">常用扩展模块</a></h1><h2 id="iprange-扩展模块"><a href="#iprange-扩展模块" class="headerlink" title="iprange 扩展模块"></a>iprange 扩展模块</h2><ol>
<li>用于指定一系列连续的ip。包括–src-range,–dst-range。</li>
</ol>
<h2 id="string-扩展模块"><a href="#string-扩展模块" class="headerlink" title="string 扩展模块"></a>string 扩展模块</h2><ol>
<li><p>用于匹配含有某一个字符串的报文。</p>
<p> iptables -t filter -I INPUT -m string –algo bm –string “OOXX” -j REJECT</p>
<ol>
<li>-m 用于指定模块</li>
<li>–algo bm 表示用bm算法匹配。</li>
</ol>
</li>
</ol>
<h2 id="time-扩展模块"><a href="#time-扩展模块" class="headerlink" title="time 扩展模块"></a>time 扩展模块</h2><ol>
<li><p>用于限制时间</p>
<p> iptables -t filter -I OUTPUT -p tcp -dport 80 -m time –timestart 09:00:00 –timestop 18:00:00 -j REJECT</p>
<ol>
<li>可以使用timestart 和timestop 来指定起止时间。也可以通过weekdays 来指定某一天,多个天之间通过逗号隔开。也可以结合使用。</li>
<li>此外还有monthdays,datestart和datestop</li>
</ol>
</li>
</ol>
<h2 id="connlimit-扩展模块"><a href="#connlimit-扩展模块" class="headerlink" title="connlimit 扩展模块"></a>connlimit 扩展模块</h2><ol>
<li><p>用于限制每个IP地址同时连接到server的数量。</p>
<p> iptables -I INPUT -p tcp –dport 803 -m connlimit –connlimit-above 2 -j REJECT</p>
<ol>
<li>限制每个IP最多只能让两个ssh连接到server。</li>
</ol>
</li>
<li><p>其实还可以配合–connlimit-mask去限制某类网段的链接数量</p>
<p> iptables -I INPUT -p tcp –dport 22 -m conlimit –connlimit-above 2 –connlimit-mask 24 -j REJECT</p>
</li>
</ol>
<h2 id="limit-扩展模块"><a href="#limit-扩展模块" class="headerlink" title="limit 扩展模块"></a>limit 扩展模块</h2><p>对报文到达速率进行限制，即限制单位时间内流入的包的数量。</p>
<ol>
<li>iptables -t filter -I INPUT -p icmp -m limit –limit 10/minute -j ACCEPT</li>
</ol>
<p>表示每分钟最多放10个包，相当于每6秒最多放一个包。<br>然而这样遂率并没有变，是因为第六秒的报文确实被策略匹配到了，于是执行了放行操作，但是6秒钱的报文没有被匹配到，于是自动执行默认策略，也是放行。<br><strong>修改</strong>：iptables -t filter -A INPUT -p icmp -j REJECT</p>
<ol start="2">
<li><p>–limit-burst 选项用于指明空闲时放行包的数量，默认为5.</p>
</li>
<li><p>limit模块工作原理：令牌桶算法<br> 想象有一个木桶，里面放了5块令牌，且目前这个桶中最多只能存放5个令牌。所有报文想要出关入关，都必须持有木桶中的令牌，这个木桶可以每6秒生成一个新的令牌。此时，如果桶已经满了，那么新生成的令牌就被丢弃。假设现在有五个报文想要进入，那么这5个报文就会去桶中找令牌，正好一人一个。此时，如果再有令牌想要进入，则没有对应的令牌可以使用。如果长时间没有人使用令牌，令牌桶中又出现了5枚令牌，也就是所谓的空闲。</p>
</li>
</ol>
<h1 id="iptables-扩展匹配条件-tcp-flags"><a href="#iptables-扩展匹配条件-tcp-flags" class="headerlink" title="iptables 扩展匹配条件 -tcp-flags"></a><a href=""http://www.zsythink.net/archives/1578"">iptables 扩展匹配条件 -tcp-flags</a></h1><p>用于匹配tcp头部的标志位，然后根据标识位的实时情况进行实时访问控制功能。</p>
<ol>
<li><p>iptables -t filter -I INPUT -p tcp -m tcp –dport 22 –tcp-flags SYN,ACK,FIN,RST,URG,PSH SYN -j REJECT</p>
<ol>
<li>SYN,ACK,FIN,RST,URG,PSH 表示需要匹配报文tcp头部的标志位列表</li>
<li>第二个SYN处表示，要求为1的标志位列表。不出现的标志位必须为0。</li>
<li>这条命令是拒绝tcp第一次链接。</li>
<li>可以使用-syn代替这一段。</li>
</ol>
</li>
<li><p>iptables -t filter -I INPUT -p tcp -m tcp –dport 22 –tcp-flags SYN,ACK,FIN,RST,URG,PSH SYN，ACK -j REJECT</p>
</li>
</ol>
<h1 id="iptables-udp扩展与icmp扩展"><a href="#iptables-udp扩展与icmp扩展" class="headerlink" title="iptables udp扩展与icmp扩展"></a><a href=""http://www.zsythink.net/archives/1588"">iptables udp扩展与icmp扩展</a></h1><h2 id="udp-扩展"><a href="#udp-扩展" class="headerlink" title="udp 扩展"></a>udp 扩展</h2><ol>
<li>iptables -t filter -I INPUT -p udp -m udp –dport 137 -j ACCEPT<ol>
<li>137为端口号，samba服务的端口为137，138</li>
<li>可以指定连续的端口号 137:157</li>
</ol>
</li>
</ol>
<h2 id="icmp-扩展"><a href="#icmp-扩展" class="headerlink" title="icmp 扩展"></a>icmp 扩展</h2><img src="/iptables_img/51.png" style="zoom:80%">

<ol>
<li><p>可以指定匹配的类型和code</p>
<p> iptables -t filter -I INPUT -p icmp -m icmp –icmp-type3/1 -j REJECT</p>
<p> 表示拒绝主机不可达报文</p>
</li>
<li><p>还可以用icmp报文的描述名称去匹配对应类型的报文</p>
<p> iptables -t filter -I INPUT -p icmp –icmp-type “echo-request” -j REJECT</p>
</li>
</ol>
<h1 id="iptables-扩展模块-state"><a href="#iptables-扩展模块-state" class="headerlink" title="iptables 扩展模块 state"></a><a href=""http://www.zsythink.net/archives/1597"">iptables 扩展模块 state</a></h1><p>当我们访问http时，需要放行80端口以便能够与服务端进行通信。进行ssh链接时，需要打开22端口。然而，这样并不安全，攻击者可以利用这些端口主动和我建立链接。使用state可以实现链接追踪功能。</p>
<h2 id="state基本概念"><a href="#state基本概念" class="headerlink" title="state基本概念"></a>state基本概念</h2><ol>
<li>连接：在state模块中，认为两台机器在你来我往的通信就算建立了连接。</li>
<li>连接状态包括：NEW,ESTABLISHED,RELATED,INVALID,UNTRACKED</li>
</ol>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ol>
<li>iptables -t filter -I INPUT -m state –state RELATED,ESTABLISHED -j ACCEPT<ol>
<li>只有回应我们的报文能够通过防火墙。</li>
</ol>
</li>
</ol>
<h1 id="iptables的黑白名单机制"><a href="#iptables的黑白名单机制" class="headerlink" title="iptables的黑白名单机制"></a><a href=""http://www.zsythink.net/archives/1604"">iptables的黑白名单机制</a></h1><ol>
<li>黑名单：链中设置规则的动作为drop或reject，默认动作是ACCEPT，那么匹配到规则的报文会被拒绝。</li>
<li>白名单：默认规则是DROP，链中规则的动作是ACCEPT，则被匹配到的报文才会放行，即白名单机制。</li>
</ol>
<h2 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h2><p>#iptables -P INPUT DROP</p>
<p>#iptables -I INPUT -p tcp –dport 22 -j ACCEPT</p>
<p>#iptables -I INPUT -p tcp<br>–dport 80 -j ACCEPT</p>
<ol>
<li>注意-F选项只是将链中规则情况，此处修改了默认规则，所以即使-F也会DROP；</li>
<li><strong>改进</strong>：将链的设置保持为ACCEPT，然后将拒绝所有请求的规则放在链尾，将放行规则放在签名，这样既实现了白名单，又保证规则清空时，管理员能够连接到主机。</li>
</ol>
<p>#iptables -I INPUT -p tcp –dport 22 -j ACCEPT</p>
<p>#iptables -I INPUT -p tcp –dport 80 -j ACCEPT</p>
<p># iptables -A INPUT -j REJECT</p>
<h1 id="iptables-自定义链"><a href="#iptables-自定义链" class="headerlink" title="iptables 自定义链"></a><a href=""http://www.zsythink.net/archives/1625"">iptables 自定义链</a></h1><p>由于默认链的规则非常 多，不便于管理，所以引入自定义链。</p>
<h2 id="创建自定义链"><a href="#创建自定义链" class="headerlink" title="创建自定义链"></a>创建自定义链</h2><ol>
<li>iptables -t filter -N IN_WEB</li>
</ol>
<h2 id="使用自定义链"><a href="#使用自定义链" class="headerlink" title="使用自定义链"></a>使用自定义链</h2><ol>
<li>必须被默认链引用</li>
<li>iptables -I INPUT -p tcp –dport 80 -j IN WEB</li>
<li>自定义链也可以引用其他的自定义链</li>
</ol>
<h2 id="自定义链重命名"><a href="#自定义链重命名" class="headerlink" title="自定义链重命名"></a>自定义链重命名</h2><p>iptables -E IN_WEB WEB</p>
<h2 id="删除自定义链"><a href="#删除自定义链" class="headerlink" title="删除自定义链"></a>删除自定义链</h2><ol>
<li>如果被引用，则要iptables -D INPUT 1</li>
<li>如果链种含有规则，则要Iptables -t filter -F WEB</li>
<li>iptables -X WEB</li>
</ol>
<h1 id="网络防火墙"><a href="#网络防火墙" class="headerlink" title="网络防火墙"></a><a href=""http://www.zsythink.net/archives/1663"">网络防火墙</a></h1><ol>
<li>定义：处于网络入口或边缘，针对于网络入口进行防护，服务于防火墙背后的本地局域网。主要任务时过滤并转发。</li>
<li>涉及：INPUT,OUTPUT,FORWARD</li>
</ol>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol>
<li><p>PC1：</p>
<ol>
<li>192.18.33.33</li>
<li>route add -net 192.18.22.0/24 gw 192.18.33.251</li>
</ol>
</li>
<li><p>PC2:</p>
<ol>
<li>192.18.22.22</li>
<li>route add -net 192.18.33.0/24 gw 192.18.22.251</li>
</ol>
</li>
<li><p>r1:</p>
<ol>
<li>ens33:192.18.33.251</li>
<li>ens37:192.18.22.251    <ol start="3">
<li>cat /proc/sys/net/ipv4/ip_forward 来查看是否支持转发功能。</li>
<li>每次需要echo 1 &gt; /proc/sys/net/ipv4/ip_forward来开启转发功能</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="iptables-动作总结"><a href="#iptables-动作总结" class="headerlink" title="iptables 动作总结"></a><a href=""http://www.zsythink.net/archives/1684"">iptables 动作总结</a></h1><h2 id="REJECT"><a href="#REJECT" class="headerlink" title="REJECT"></a>REJECT</h2><ol>
<li>–reject-with :提示拒绝原因。包括：<ol>
<li>icmp-net-unreachable</li>
<li>icmp-host-unreachable</li>
<li>icmp-port-unreachable</li>
<li>icmp-proto-unreachable(默认)</li>
<li>icmp-net-prohibited</li>
<li>icmp-host-pro-hibited</li>
<li>icmp-admin-prohibited</li>
</ol>
</li>
</ol>
<h2 id="LOG"><a href="#LOG" class="headerlink" title="LOG"></a>LOG</h2><ol>
<li><p>LOG 可以将符合条件的报文的相关信息记录到日志中。可以在后面设置具体规则对报文进一步处理。</p>
</li>
<li><p>可以通过tail -f /var/log/messages 来查看。</p>
</li>
<li><p>–log-level 来指定日志的日志级别。包括</p>
<ol>
<li>emerg</li>
<li>alert</li>
<li>crit</li>
<li>error</li>
<li>warning</li>
<li>notice</li>
<li>info</li>
<li>debug</li>
</ol>
</li>
<li><p>–log-prefix 来给记录到的相关信息添加标签之类的信息，以区分各种记录到的报文。</p>
</li>
</ol>
<p>iptables -I INPUT -p tcp –dport 80 -m state –state NEW -j LOG –log-prefix “want-in-from-22”</p>
<h1 id="iptables-动作总结2"><a href="#iptables-动作总结2" class="headerlink" title="iptables 动作总结2"></a><a href=""http://www.zsythink.net/archives/1764"">iptables 动作总结2</a></h1><h2 id="SNAT"><a href="#SNAT" class="headerlink" title="SNAT"></a>SNAT</h2><p>iptables -t nat -A POSTROUTING -s 192.18.0.0/16 -j SNAT –to-source 192.18.33.251</p>
<ol>
<li>其中-A 标识将snat规则添加到POSTROUTING链的末尾。POSTROUTING可以认为是报文发出的最后一个关卡。</li>
<li>-j SNAT表示对匹配到的报文进行源地址转换。</li>
<li>–to-source表示转换成这个源</li>
</ol>
<h2 id="DNAT"><a href="#DNAT" class="headerlink" title="DNAT"></a>DNAT</h2><p>按端口进行转发</p>
<ol>
<li><p>iptables -t nat -I PREROUTING -d 192.18.33.251 -p tcp –dport 801 -j DNAT –to-destination 192.18.22.22:80</p>
</li>
<li><p>注：开启端口/sbin/iptables -I INPUT -p tcp –dport 80 -j ACCEPT</p>
</li>
</ol>
<h2 id="MASQUERADE"><a href="#MASQUERADE" class="headerlink" title="MASQUERADE"></a>MASQUERADE</h2><p>动态的将源地址转换为可用的IP地址。类似于SNAT而无需指明修改成哪个IP，可以适应动态变化。</p>
<ol>
<li>iptables -t nat -I POSTROUTING -s 192.18.0.0/16 -o ens33 -j MASQUERADE</li>
</ol>
<h2 id="REDIRECT"><a href="#REDIRECT" class="headerlink" title="REDIRECT"></a>REDIRECT</h2><p>可以将本机端口进行映射。</p>
<ol>
<li>iptables -t nat -A PREROUTING -p tcp –dport 80 -j REDIRECT –to-ports 801</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计安导第4章</title>
    <url>/2020/01/20/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC4%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="内部攻击"><a href="#内部攻击" class="headerlink" title="内部攻击"></a>内部攻击</h1><ol>
<li>内部攻击：指控制和保护资产的内部人员利用安全漏洞进行的攻击</li>
</ol>
<h2 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h2><ol>
<li>后门：是程序中隐藏的功能或命令，有时也称为活门，它允许用户执行一些正常情况下不允许用户执行的操作。通常这些操作会违反安全策略，如执行特权升级。<ol>
<li>为调试有时也会插入后门</li>
<li>为了紧急情况也可能留后门</li>
<li>恶意的后门：直接留后门；在程序中引入脆弱性，如缓冲区溢出。</li>
<li>彩蛋</li>
</ol>
</li>
</ol>
<h2 id="逻辑炸弹"><a href="#逻辑炸弹" class="headerlink" title="逻辑炸弹"></a>逻辑炸弹</h2><ol>
<li>逻辑炸弹：是一种程序，它根据一定的逻辑条件执行恶意操作。</li>
<li>千年虫问题：具有和逻辑炸弹类似的效果，但是不视为逻辑炸弹</li>
</ol>
<h2 id="内部攻击的防御"><a href="#内部攻击的防御" class="headerlink" title="内部攻击的防御"></a>内部攻击的防御</h2><ol>
<li>避免单点故障：不能只让一个人创建备份或管理重要系统。</li>
<li>使用代码走查</li>
<li>使用归档和报告工具</li>
<li>限制授权和权限：使用最小权限原则；在保证每个员工能正常工作的情况下，授予他们最小权限。</li>
<li>重要系统的物理安全</li>
<li>监控员工行为</li>
<li>控制软件的安装</li>
</ol>
<h1 id="计算机病毒"><a href="#计算机病毒" class="headerlink" title="计算机病毒"></a>计算机病毒</h1><ol>
<li>计算机病毒：是一种能自我复制的计算机指令或程序代码，它通过修改其他文件与程序来插入代码，且能进一步自我复制；<ol>
<li>这种自我复制的特性是计算机病毒与其他类型恶意软件（如逻辑炸弹）的不同之处；</li>
<li>病毒的另一个特性是其复制需要某种类型的用户协助，如打开电子邮件附件或共享USB驱动器；</li>
</ol>
</li>
<li>恶意软件分类：<ol>
<li>按传播特性分：<ol>
<li>病毒：人工辅助传播</li>
<li>蠕虫：自动传播</li>
</ol>
</li>
<li>按隐藏特性分：<ol>
<li>Rootkit：修改操作系统以隐藏其存在</li>
<li>特洛伊木马：提供理想的功能但是隐藏恶意操作。</li>
</ol>
</li>
</ol>
</li>
<li>隐藏方式<ol>
<li>加密病毒：<ol>
<li>病毒包括解密引擎+病毒代码主体，随机生成加密密钥</li>
<li>检测：通过查找解密引擎</li>
</ol>
</li>
<li>多态病毒<ol>
<li>具有随机变体的解密引擎的加密病毒</li>
<li>检测：使用CPU仿真器</li>
</ol>
</li>
<li>变形病毒<ol>
<li>不同的病毒体；方法包括代码排列和指令替换</li>
<li>具有挑战性的检测</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="病毒的分类"><a href="#病毒的分类" class="headerlink" title="病毒的分类"></a>病毒的分类</h2><ol>
<li>病毒执行的四个阶段<ol>
<li>潜伏阶段</li>
<li>繁殖阶段：病毒进行自我复制，归纳然新系统中的新文件。</li>
<li>触发阶段</li>
<li>行动阶段：此阶段，病毒会执行恶意操作。</li>
</ol>
</li>
<li>病毒的类型<ol>
<li>程序病毒（文件病毒）：通过修改文件包含的对象代码感染文件。</li>
<li>宏病毒（文档病毒）：打开文档时，启动病毒，此时，病毒搜索其他要感染的文件。此外，宏病毒还可以将自己插入到模板中，使得每次新建的文档都含有此病毒。另外，还可以通过电子邮件传播。</li>
<li>引导区病毒：感染驱动器引导区的代码，每次启动计算机或重启时，都会运行引导区的代码。</li>
</ol>
</li>
<li>病毒的特征<ol>
<li>传染性</li>
<li>隐蔽性</li>
<li>潜伏性：只有当触发条件满足时才破坏，否则只传染</li>
<li>多态性：不断变种</li>
<li>破坏性</li>
</ol>
</li>
<li>病毒注入：（1）在程序开始处简单注入（2）将病毒代码分成两部分，并将这两部分分别注入到程序的不同位置，使用跳转指令来执行。</li>
</ol>
<h2 id="病毒的防御"><a href="#病毒的防御" class="headerlink" title="病毒的防御"></a>病毒的防御</h2><ol>
<li>病毒的特征码：<ol>
<li>通过病毒样本找到病毒的特征指令集，产检唯一标识这类病毒的特征字符串。<strong>一般将特征字符串称为病毒的特征码</strong>。它是病毒的一种数字指纹</li>
</ol>
</li>
<li>病毒的检测与隔离<ol>
<li>可以定期扫描整个文件系统</li>
<li>可以实时的分析每个新创建的文件，每个修改的文件和收到的电子邮件。一旦文件中有一部分包含与病毒特征码匹配的代码，就会被放入隔离区。</li>
</ol>
</li>
</ol>
<h2 id="加密病毒"><a href="#加密病毒" class="headerlink" title="加密病毒"></a>加密病毒</h2><ol>
<li>加密病毒：通过加密病毒代码的主体，以隐藏其自身的特征码。<ol>
<li>包括解密代码、密钥和加密病毒代码（解密代码一般用暴力破解代替）。</li>
<li>对病毒主体的解密代码本身时未加密的代码，此结构本身就构成了一种病毒的特征码。</li>
</ol>
</li>
</ol>
<h2 id="多变体病毒和变形病毒"><a href="#多变体病毒和变形病毒" class="headerlink" title="多变体病毒和变形病毒"></a>多变体病毒和变形病毒</h2><ol>
<li>多变体：变异的病毒。<ol>
<li>一方面，多变体病毒通过加密使自身呈现出多种形式。</li>
<li>另一方面，多变体病毒采用非加密的混淆技术，如指令重排和包含无用指令技术。</li>
</ol>
</li>
<li>检测多变体病毒：单个字符串不可能检测变形病毒的特征码，可以采用<ol>
<li>联合特征码：由在被感染文件中必须出现的字符串集组成。</li>
<li>序列特征码：由在被感染文件中必须出现的有序字符串列表组成</li>
<li>概率特征码：由阈值和字符串-评分对组成。如果文件中存在的字符串的评分总和大于阈值，则认为被感染。</li>
</ol>
</li>
</ol>
<h1 id="恶意软件攻击"><a href="#恶意软件攻击" class="headerlink" title="恶意软件攻击"></a>恶意软件攻击</h1><h2 id="特洛伊木马"><a href="#特洛伊木马" class="headerlink" title="特洛伊木马"></a>特洛伊木马</h2><ol>
<li><p>特洛伊木马：是一种恶意程序，表面上，它会执行一些有用的任务，但同时会隐形的执行具有负面后果的任务。</p>
<ol>
<li><p>组成：</p>
<ol>
<li>硬件部分：包括控制端、服务端、因特网；</li>
<li>软件部分：控制端程序、木马程序、木马配置程序；</li>
<li>具体连接部分：控制端IP、服务端IP、控制端端口、木马端口；</li>
</ol>
</li>
<li><p>木马入侵步骤：</p>
<p> 1.配置木马  2.传播木马  3.运行木马  </p>
<p> 4.信息反馈  5.建立连接  6.远程控制 </p>
</li>
</ol>
</li>
<li><p>计算机蠕虫：是一种恶意程序，不需要将自己注入其他程序就能传播自己的副本，并且不需要与人交互。</p>
<ol>
<li><p>蠕虫可以自我复制传播，但它不属于计算机病毒，因为他们不会感染其他程序。</p>
</li>
<li><p>大多数情况下，蠕虫用来删除文件或者安装后门</p>
</li>
<li><p>蠕虫的结构</p>
<img src="/计算机安全导论_img/第四章1.png" style="zoom:30%"/></li>
<li><p>设计蠕虫</p>
<img src="/计算机安全导论_img/第四章2.png" style="zoom:70%"/></li>
<li><p>蠕虫传播</p>
<ol>
<li><p>传播理论</p>
<p>经典的传播病模型</p>
<img src="/计算机安全导论_img/第四章3.png" style="zoom:70%"/>   

</li>
</ol>
<p>N: 易受感染的主机总数; I(t)：在t时刻被感染的主机数<br>S(t)：在t时刻，易被感染的主机数;I(t)+S(t)=N;β：感染率;I(t)的微分方程 ：dI/dt=βI(t)S(t);    </p>
<ol start="2">
<li>蠕虫可以利用正在运行应用程序的脆弱性（如缓冲区溢出）来进行自我传播。</li>
<li>一般通过修改注册表来隐藏自身。(同时杀毒软件也会观察一些注册表项)</li>
</ol>
</li>
</ol>
</li>
<li><p>Rootkits</p>
<ol>
<li>Rootkits最早是一组用于UNIX操作系统的工具集，黑客使用它们隐藏入侵活 动的痕迹，它能在操作系统中隐藏恶意程序。这些程序在植入系统后，rootkits 会将它们 隐藏起来，它能隐藏任何恶意程序过程、文件夹、注册码。</li>
<li>一般通过修改系统是实用程序或操作系统本身来防止检测。</li>
<li>通常使用Rootkits来隐藏其他恶意软件的恶意行为（在进程控制器中删除进程的显示，删除文件浏览器中文件的显示）</li>
</ol>
</li>
<li><p>恶意软件僵尸</p>
<ol>
<li>僵尸是一种外部控制以执行恶意攻击的计算机，通常作为僵尸网络的一部分。</li>
</ol>
</li>
</ol>
<h2 id="入侵隐私软件"><a href="#入侵隐私软件" class="headerlink" title="入侵隐私软件"></a>入侵隐私软件</h2><ol>
<li>包括广告软件、间谍软件</li>
</ol>
<h2 id="对策"><a href="#对策" class="headerlink" title="对策"></a>对策</h2><ol>
<li><p>病毒签名：一个签名是一个病毒指纹</p>
<ol>
<li>扫描将分析的对象与签名数据库进行比较。如果文件中包含签名，则文件被感染。</li>
</ol>
</li>
<li><p>黑/白名单</p>
<ol>
<li>维护加密哈希数据库<br> （1）操作系统文件 （2）热门应用程序<br> （3）已知被感染的文件</li>
<li>需要保护数据库的完整性</li>
</ol>
</li>
<li><p>启发式分析</p>
<ol>
<li>用于识别新的和“零日”恶意软件 </li>
<li>步骤<ol>
<li>代码分析：根据说明防病毒软件可以确定该程序是否是恶意的。</li>
<li>执行仿真：在隔离的仿真环境中执行代码，并监控目标文件所采取的操作，如果操作有害，则认为其为病毒。</li>
<li>启发式方法可以触发错误警报</li>
</ol>
</li>
</ol>
</li>
<li><p>隔离：将可疑文件隔离在隔离文件夹中。</p>
<ol>
<li>可疑文件未被删除，最终可以由用户决定何使删除</li>
<li>只能通过防病毒程序与隔离区中的文件交互。</li>
<li>隔离区的文件是无害的，因为它是加密的</li>
<li>隔离技术的细节是保密的</li>
</ol>
</li>
<li><p>静态分析与动态分析</p>
 <img src="/计算机安全导论_img/第四章4.png" style="zoom:70%"/>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计安导第5章</title>
    <url>/2020/01/20/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC5%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="网络基本概念"><a href="#网络基本概念" class="headerlink" title="网络基本概念"></a>网络基本概念</h1><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><ol>
<li>OSI七层模型：应用层；表示层；会话层；传输层；网络层；链路层；物理层</li>
<li>TCP/IP五层模型：应用层；传输层；网络层；数据链路层；物理层</li>
</ol>
<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><ol>
<li><p>物理层</p>
<ol>
<li>其任务是以尽力服务为基础，在网络节点之间传输实际的比特位。</li>
<li>规定通信设备的机械的、电气的、功能的和过程的特性，用以建 立、维护和拆除物理链路连接。</li>
</ol>
</li>
<li><p>链路层</p>
<ol>
<li>其任务是在网络节点对间或局域网节点间传输数据并检测物理层出现的差错。</li>
<li>该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据 的检错、重发等。</li>
</ol>
</li>
<li><p>网络层</p>
<ol>
<li>其任务是以尽力服务为基础，在任意两台主机之间传送数据包。就是选择合适的网间路由和交换结点， 确保数据及 时传送。</li>
<li>网络层将数据链路层提供的帧组成数据包，包中封装有网络层包 头，其中含有逻辑地址信息：源站点和目的站点地址的网络地址。</li>
</ol>
</li>
<li><p>传输层</p>
<ol>
<li>其任务是基于IP地址和端口，支持应用程序之间的通信与连接。</li>
<li>传输层为上层提供端到端（最终用户到最终用户）的透明的、可 靠的数据传输服务。所谓透明的传输是指在通信过程中传输层对 上层屏蔽了通信传输系统的具体细节。</li>
</ol>
</li>
<li><p>应用层</p>
<ol>
<li>其任务是以传输层提供的服务为基础，提供协议来支持互联网上的有用的功能。</li>
<li>常用协议有FTP、TELNET、DNS、SMTP、POP3。</li>
</ol>
</li>
</ol>
<h2 id="网络与安全"><a href="#网络与安全" class="headerlink" title="网络与安全"></a>网络与安全</h2><h3 id="与计算机安全目标-CIA"><a href="#与计算机安全目标-CIA" class="headerlink" title="与计算机安全目标 CIA"></a>与计算机安全目标 CIA</h3><ol>
<li>机密性：网络协议的任何分层中，都没有要求传输数据的机密性。 需要修订相关协议来完成机密性。可以在应用层进行加密协议的 设计，也可以在网络层。</li>
<li>完整性：封装的数据包中的头和尾部都有简单的校验和，以检查 传输数据是否有改变。但这些校验和不是密码学意义下安全的， 因此不能提供计算机安全层面的完整性。</li>
<li>可用性：网络协议设计之初主要考虑的是节点发生故障时如何保 证可用性，并未考虑攻击者存在时的情形。如拒绝服务攻击会影 响系统可用性。</li>
</ol>
<h3 id="与计算机安全目标-3A"><a href="#与计算机安全目标-3A" class="headerlink" title="与计算机安全目标 3A"></a>与计算机安全目标 3A</h3><ol>
<li>保证：默认情况下网络中数据包可以在任何两个节点间阐述。如 果需要引入权限和策略来控制网络中的数据流，必须通过显式得 的措施来实现。</li>
<li>真实性：网络协议的数据格式中没有存储数字签名的字段，也没 有用户身份的概念。如果需要引入身份证明和数字签名，必须在 应用层完成。</li>
<li>匿名：网络协议没有用户身份的概念，因此具有内在的匿名性。 对于匿名攻击，可以通过确定用户正在使用网络中的哪台计算机 来确定。</li>
</ol>
<h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><ol>
<li>定义：以太网包括通信所使用的物理介质以及链路层的协议 标准IEEE 802.3。</li>
<li>不同帧 在以太网电缆上同时传输时会产生冲突，需要丢弃并重传冲突帧。</li>
<li>冲突处理：以太网协议使用CSMA/CD（载波监听多路访问及冲突 检测）技术来避免冲突。</li>
</ol>
<h2 id="集线器："><a href="#集线器：" class="headerlink" title="集线器："></a>集线器：</h2><ol>
<li>工作与物理层，将所有帧广播给与之相连的所有设备。</li>
<li>缺点是与集线器相连的所有设备共享带宽，传输效率低下。由于 是广播，所以数据容易被窃听。</li>
</ol>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><ol>
<li>交换机会记录连接到自己各个接口的计算机地址。之后交换机会 将接收到的帧发送到特定的接收端，而不是广播出去。</li>
</ol>
<h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><ol>
<li>MAC（Medium/Media Access Control）地址，用来表示互联网 上每一个站点的标识符，采用十六进制数表示，共六个字节。</li>
<li>MAC地址是网卡决定的，一般是固定的。但可以通过网卡的驱动 程序软件来修改MAC地址。因此，<strong>从安全角度考虑，不能使用MAC地址作为识别网络流源头的依据。</strong></li>
</ol>
<h2 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h2><ol>
<li>ARP:是一种链路层协议，其主要功能是将给定主机的网络层地址解析为主机 的硬件地址。</li>
<li>过程：主机通过发送包含目标IP地址的AARP请求到网络上所有主机，并接受返回消息，以此确定目标的物理地址。同时将映射存入ARP缓存。</li>
<li><strong>ARP欺骗</strong>：攻击者可以向某 一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主 机或到达错误的主机，这就构成了一个<strong>ARP欺骗</strong>。<ol>
<li>问题在于ARP缺乏身份认证</li>
<li><strong>解决</strong> ：<ol>
<li>检查相同的MAC是否在局域网中多次出现，以作为ARP欺骗的标志。</li>
<li>静态ARP表：通过手动指定路由器的ARP缓存来将具体的MAC地址与特定的IP地址进行绑定。问题是不够灵活。</li>
<li>更加复杂和灵活的措施：anti-arpsroof、XArp、Arpwatch，这些 程序会仔细检查所有的ARP数据包，并将数据包的内容与所存储 的ARP表项纪录做比较，以检测并防止ARP欺骗。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网际协议基本概念"><a href="#网际协议基本概念" class="headerlink" title="网际协议基本概念"></a>网际协议基本概念</h2><ol>
<li>IP：网络层协议，尽最大努力将一个数据包从源节点路由到目的 节点。节点由IP地址标识，IPv4地址为32位，IPv6地址为128位。</li>
<li>IP包路由：如果数据包的源和目的在同一个局域网内，则通过ARP进行。否则，将包传送至网关，由网关根据路由表来确定如何转发。</li>
<li>IP地址与子网掩码：例如IP地址为192.168.1.100,子网掩码为 255.255.255.0。则该地址的网络部分为192.168.1.0,主机部分为 0.0.0.100.</li>
<li>IPv4地址耗尽解决：IPv6；网络地址转换</li>
</ol>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol>
<li>路由器：为数据包寻找一条最佳的传输路径。路由器中维护一张路由表，以提高效率。</li>
<li>路由操作：包括发送、丢弃、转发</li>
<li><strong>TTL</strong>:数据包的<strong>生存周期</strong>，由跳数决定，一般最大条数为255。</li>
<li>路由协议<ol>
<li>OSPF决定了如何在自治系统内路由数据包。</li>
<li>BGP决定了如何在自治系统之间路由数据包。</li>
</ol>
</li>
</ol>
<h2 id="ICMP-网际控制消息协议"><a href="#ICMP-网际控制消息协议" class="headerlink" title="ICMP 网际控制消息协议"></a>ICMP 网际控制消息协议</h2><ol>
<li>ICMP:用于在主机、路由器之间传递控制消息。<ol>
<li>包括：回显请求；回显响应；超时；目的地不可达</li>
</ol>
</li>
<li>Ping 命令：Ping发送一个ICMP<strong>回声请求</strong> 消息给目的地并报告是否收到ICMP<strong>回声应答</strong>消息。</li>
<li>traceroute命令：利用ICMP 协议定位您的计算机和目标计算机之间的所有路由器。<strong>利用ICMP超时报文，依次等增TTL，以确定路径上有哪些路由</strong></li>
</ol>
<h2 id="IP地址欺骗"><a href="#IP地址欺骗" class="headerlink" title="IP地址欺骗"></a>IP地址欺骗</h2><ol>
<li><strong>方法</strong> 恶意用户产生的IP数据包中的源IP地址是伪造的， 以便冒充其他系统或发件人的身份。源IP地址修改后， IP数据包 头部校验和也需重新计算。</li>
<li>攻击者不会收到服务器响应，因为服务器会将数据包返回给具有假冒IP地址的主机。因此，攻击者不在乎响应，故可以用来Dos攻击。</li>
<li><strong>应对</strong> <ol>
<li>通过边缘路由器禁止那些源地址在域内，但实际地址在域外的数据包或源地址在域外，但是从域内向域外发的送的数据包。</li>
<li>可以通过IP追踪计数追踪数据包返回到实际源地址的路径。</li>
</ol>
</li>
</ol>
<h2 id="数据包嗅探"><a href="#数据包嗅探" class="headerlink" title="数据包嗅探"></a>数据包嗅探</h2><ol>
<li>Wireshark：网络数据包分析软件。使用WinpCAP作为接口，直接与网卡进行数据报文交换。此时网卡需要设置为混杂模式。<ol>
<li><strong>问题</strong> 可能泄露敏感信息。</li>
</ol>
</li>
<li><strong>解决</strong><ol>
<li>对于有线网，使用以太网交换机而不是集线器，降低数据包包嗅探的可能性。</li>
<li>检查网卡是否被设置为混杂模式。 </li>
<li>利用高层协议进行加密，比如HTTPS</li>
</ol>
</li>
</ol>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ol>
<li><p>端口号：16位，用来标识应用层不同服务。</p>
<ol>
<li>FTP:21</li>
<li>Telnet:23</li>
<li>SSMTP:25</li>
<li>HTTP:80</li>
</ol>
</li>
<li><p><strong>TCP</strong>:面向连接的、可靠的。面向 连接意味着实现会比较复杂，可靠的是指信息会完整、有序地到 达。如果数据包丢失，TCP会保证重传。 TCP是传输文件、网页 和电子邮件的首选协议。</p>
</li>
<li><p><strong>UDP</strong>：无连接的、不可靠但速度快。基于IP的语音会话(VoIP)适合于使用UDP协议。</p>
</li>
</ol>
<h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><ol>
<li><p>三次握手建立连接，每个数据包都有编号。</p>
</li>
<li><p>采用<strong>累计确认</strong></p>
</li>
<li><p>流量控制使用滑动窗口协议</p>
</li>
<li><p>校验和：使用循环冗余校验(CRC)，可以检测由网络错误引发的数据不一致，但不能检测恶意篡改。</p>
</li>
<li><p>拥塞控制：拥塞会导致传输速率急剧下降和数据包的丢弃。拥塞 控制是防止流量淹没网络的一种技术，通过收集确认数据包等信 息来调整数据的传输速率，防止拥塞。</p>
<ol>
<li>慢开始与拥塞避免</li>
<li>快重传与快恢复</li>
</ol>
</li>
<li><p>TCP三次握手</p>
 <img src="/计算机安全导论_img/1.png" style="zoom:80%">

<ol>
<li>初始序列号是随机的，以<strong>防止针对预测初始序列号的攻击</strong>。</li>
</ol>
</li>
</ol>
<h2 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h2><ol>
<li>无需三次握手，允许直接发送数据包。</li>
<li>UPD提供无连接、不可靠的服务。将数据报序列中丢失数据报的工作交给应用层。</li>
<li>使用16位校验和验证数据包完整性。</li>
<li>速度远远快于TCP,用于DNS和VoIP。</li>
</ol>
<h2 id="NAT-网络地址转换"><a href="#NAT-网络地址转换" class="headerlink" title="NAT 网络地址转换"></a>NAT 网络地址转换</h2><ol>
<li>NAT允许局域网内的主机共享一个公共IP，以接入因特网。<ol>
<li>解决了IP地址不足的问题。</li>
<li>有效的避免了来自网络外部的攻击，隐藏并保护网络内部的计算机。</li>
<li>NAT路由器：公网和私网之间的网关，负责管理流入和流出的数据包。</li>
<li>NAT路由器通过维护一个查找表来实现私有IP和公有IP的地址转换。</li>
<li>使用NAT设备时，互联网的流入流量不能到达内部网络，能够阻 止来自外部网络的威胁。</li>
</ol>
</li>
</ol>
<h2 id="TCP会话劫持"><a href="#TCP会话劫持" class="headerlink" title="TCP会话劫持"></a>TCP会话劫持</h2><ol>
<li><p><strong>TCP序列号预测攻击</strong> 通过预测TCP会话的初始序列号，以建立伪造的TCP会话。之后</p>
<ol>
<li>发动拒绝服务攻击</li>
<li>向服务器发送SYN，将源IP地址伪造成受害者客户端IP。</li>
<li>在等待服务器向客户端发送响应之后，攻击者通过发送一个 ACK数据包来结束TCP握手，该数据包的序列号是预测的下一个序列号；</li>
<li>攻击者以受害客户端名义向服务器发送请求。</li>
</ol>
</li>
<li><p><strong>盲注入</strong>：在TCP序列预测攻击中使用了IP欺骗，所以攻击者无法从服务器收到任何响应。盲注入允许攻击者使用请求者的源IP地址来执行某些命令，从而破坏系统。</p>
</li>
<li><p><strong>ACK风暴</strong>：盲注入后客户端不会向服务器发送同步消息，导致不同步。此时，客户端和服务端都会向对方发送ACK消息，来告知对方需要开始使用正确的序列号。这种反复的通信称为ACK风暴。</p>
</li>
<li><p><strong>完全会话劫持</strong>：当攻击者与目标服务器或客户端在同一网段时，攻击者可以通过数据包嗅探攻击，直到建立会话时的数据包序列号，从而完全劫持会话。</p>
</li>
<li><p><strong>防范会话劫持</strong>：</p>
<ol>
<li>在IP层或者应用层使用认证和加密，如IPSec或者应用层安全协议。</li>
<li>网站应避免创建以安全身份验证措施开始，但后来切换到未加密交 换的会话，这样会产生TCP会话劫持攻击的风险。</li>
</ol>
</li>
</ol>
<h1 id="Dos攻击"><a href="#Dos攻击" class="headerlink" title="Dos攻击"></a>Dos攻击</h1><ol>
<li><strong>拒绝服务攻击</strong>亦称洪水攻击，其目的在于使目标电脑的网络或系统 资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</li>
<li><strong>分布式拒绝服务攻击</strong>：使用多台僵尸机发起攻击。</li>
<li>症状：网络异常缓慢(打开文件或访问网站)、特定网站无法访 问、无法访问任何网站、垃圾邮件的数量急剧增加、无线或有线网 络连接异常断开、长时间尝试访问网站或任何互联网服务时被拒绝、 服务器容易断线、卡顿等。</li>
</ol>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol>
<li><p>带宽消耗：</p>
<ol>
<li>ICMP洪水攻击：通过向未良好设置的路由器发送广播信息以占用系统资源 。</li>
<li>UDP洪水攻击：大量UDP数据包发送给受害系统，可能会导致带宽。</li>
<li>死亡之ping：产生超过IP协议能容忍的数据包数，可能会导致死机。</li>
<li>泪滴攻击：数据在发送前都会经过切割，每个小切割都会记录位移的信息，以 便重组。此攻击模式就是捏造位移信息，导致重组时发生问题，造成错误。</li>
</ol>
</li>
<li><p>资源消耗型</p>
<ol>
<li>SYN 洪水攻击：大量TCP SYN请求反复发送，导致系统资源耗尽。</li>
<li>LAND攻击：与SYN floods类似，会导致被攻击的机器死循环。</li>
<li>分布式HTTP洪水攻击：使用代理服务器向受害服务器发送大量貌似合法的请 求，通常使用HTTP GET。</li>
<li>僵尸网络攻击：大量被命令与控制服务器所控制的互联网主机群协同攻击。</li>
</ol>
</li>
</ol>
<h2 id="ICMP-攻击"><a href="#ICMP-攻击" class="headerlink" title="ICMP 攻击"></a>ICMP 攻击</h2><ol>
<li><strong>ping洪水攻击</strong>：通过功能强大的计算机向单个受害服务器发送大量 回显请求命令。这样受害服务器会被这些网络流量 淹没，无法响应合法的请求。</li>
<li><strong>Smurf攻击</strong>：攻击者向网络广播地址发送ICMP包，并将回复地址 设置成受害网络的广播地址，通过使用ICMP应答请求数据包来淹 没受害主机的方式进行。</li>
<li><strong>阻止Smurf攻击</strong>：<ol>
<li>管理员应该将网络中的主机和路由器配置 为忽略广播请求；</li>
<li>避免直接向广播地址转发数据包；</li>
<li>忽略 ping请求。</li>
</ol>
</li>
</ol>
<h2 id="SYN洪水攻击"><a href="#SYN洪水攻击" class="headerlink" title="SYN洪水攻击"></a>SYN洪水攻击</h2><ol>
<li><p>攻击者故意延迟或不发送握手确认。</p>
</li>
<li><p><strong>过程</strong>：</p>
<ol>
<li>假设连接发起方是A，接受方是B。A发送SYN消息给B，B反馈 SYN-ACK消息给A，使连接进入半开状态。此时B会给每个半开连 接都设一个Timer，如果超过时间还没有收到A的ACK消息，则重 新发送一次SYN-ACK消息给A，直到重试超过一定次数时才会放弃。</li>
<li>攻击方A可以控制肉鸡向B发送大量SYN消息但不响应ACK消息， 或者干脆伪造SYN消息中的Source IP，使B反馈的SYN-ACK消息 石沉大海，导致B被大量注定不能完成的半开连接占据，直到资源 耗尽，停止响应正常的连接请求。</li>
</ol>
</li>
<li><p><strong>防范</strong></p>
<ol>
<li><strong>SYN Cookie机制</strong>：在TCP服务器接收到TCP SYN包并返回TCP SYN+ACK包时，不分配专门的数据区，而是根据SYN包计算一个 cookie值。 这个cookie作为将要返回的SYN-ACK包的初始序列号。</li>
</ol>
</li>
<li><p>SYN + ACK包的32比特结构如下：</p>
<ol>
<li>前5比特是时间戳，由每分 钟按模32递增的计数器实现</li>
<li>中间3比特是编码值，表示传输段 的最大值</li>
<li>最后24比特是基于密钥k，由服务器和客户端IP地址，端口号和前面使用的时间戳计算出来的MAC值。</li>
</ol>
</li>
<li><p>当客户端返回一个ACK包时</p>
<ol>
<li>服务器首先根据其前5比特判断是否 过期；</li>
<li>服务器根据包头信息重新计算24比特的MAC值，与返回的确认序列号(初始序列号 + 1)进行对比；</li>
<li>服务器对中间3 比特进行解码，完成对SYN队列项的重构。如果验证通过，则服务 器发起TCP会话。</li>
</ol>
</li>
<li><p>Optimistic TCP ACK攻击</p>
<ol>
<li>利用TCP的拥塞控制机制。在TCP的华东窗口协议中，虽则接收ACK的增多，窗口大小增大。</li>
<li><strong>攻击</strong> 恶意客户端在没有收到SYN-ACK时，就提前发送ACK，使得服务 器增加其传输速度。如果同时针对多台服务器进行TCP ACK攻击，它会通过淹 没网络带宽资源，导致互联网范围内的拥塞。</li>
<li><strong>防御</strong> 设置对每个客户端最大流量的限制。</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计安导第6章</title>
    <url>/2020/01/20/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC6%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="DNS-域名系统"><a href="#DNS-域名系统" class="headerlink" title="DNS 域名系统"></a>DNS 域名系统</h1><ol>
<li>DNS是应用层协议，负责将域名映射到IP地址。</li>
<li>DNS数据库包括<ol>
<li>地址记录：与主机名相关链的IP地址。</li>
<li>邮件交换记录：域的邮件服务器。</li>
<li>名称服务器记录：域的权威服务器。</li>
</ol>
</li>
</ol>
<h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><ol>
<li>DNS：建立IP和域名间的映射</li>
<li>HTTP:用来浏览网页</li>
<li>SSL/TLS: 以安全的、加密的方式浏览网页的协议(<strong>HTTPS</strong>)</li>
<li>IMAP/POP/SMAP:用于互联网电子邮件</li>
<li>SOAP：用于交换作为网络服务模式部分的结构化数据</li>
<li>talent：远程访问协议(与FTP一样，不提供加密)</li>
<li>SSH:较新的安全远程访问和管理协议</li>
</ol>
<h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><ol>
<li>域名：最右为顶级域名(TLD)</li>
<li>域名服务器从上至下依次为<ol>
<li>根域名服务器：管理顶级域名.</li>
<li>顶级域名服务器:如.com。其中保存的每条记录都对应一个权威域名服务器</li>
<li>权威域名服务器</li>
</ol>
</li>
</ol>
<h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><ol>
<li><p>区域：具有相同权威DNS服务器的已连接节点的集合。</p>
</li>
<li><p>域名解析：</p>
<ol>
<li><p>迭代解析</p>
<img src="/计算机安全导论_img/2.png">
</li>
<li><p>递归解析</p>
<img src="/计算机安全导论_img/3.png">    

</li>
</ol>
</li>
</ol>
<h2 id="权威域名服务器"><a href="#权威域名服务器" class="headerlink" title="权威域名服务器"></a>权威域名服务器</h2><ol>
<li>权威域名服务器层次结构：权威域名服务器也是分层的，每个域名服务器都存储着记录的集合，每个记录提供域名地址或者对该域权威域名服务器的引用。</li>
<li>作用：控制在权威域名服务器(ANS)之间分配<ol>
<li>负责特定域</li>
<li>可以为子域指定其他ANS</li>
</ol>
</li>
</ol>
<h2 id="DNS数据包"><a href="#DNS数据包" class="headerlink" title="DNS数据包"></a>DNS数据包</h2><ol>
<li>DNS查询和应答是通过UDP实现的，但当请求超过512时，会采用TCP。</li>
<li>DNS查询通常通过端口53上的UDP发出。</li>
</ol>
<h3 id="组成："><a href="#组成：" class="headerlink" title="组成："></a>组成：</h3><ol>
<li>头：包含16为查询标识符，用于标识查询和响应</li>
<li>查询部分：由问题序列组成，每个问题由所查询域名和查询记录的类型组成。</li>
<li>应答部分包括<ol>
<li>NAME 包含一个全域名</li>
<li>2B的TYPE 标识DNS记录的类型</li>
<li>2B的CLASS域 标识更广泛的类型</li>
<li>4B的TTL 标识有效时间</li>
<li>2B的RDLENGTH 标识数据段的长度</li>
<li>可变长RDATA段 包括实际的记录数据</li>
</ol>
</li>
</ol>
<h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><ol>
<li>目的：如果每个查询都遍历DNS树会导致根区域过载</li>
<li>缓存有效期：由ANS回复的TTL指定。</li>
<li>由操作系统和浏览器维护缓存</li>
</ol>
<h2 id="DNS-攻击：-网络嫁接与网络钓鱼"><a href="#DNS-攻击：-网络嫁接与网络钓鱼" class="headerlink" title="DNS 攻击： 网络嫁接与网络钓鱼"></a>DNS 攻击： 网络嫁接与网络钓鱼</h2><ol>
<li><strong>过程</strong> 攻击者把网站发送请求解析成子集恶意服务器的伪装IP地址，导致受害人浏览或下载伪造的内容。 </li>
<li><strong>用途</strong> 伪造王章</li>
</ol>
<h2 id="DNS-缓存中毒"><a href="#DNS-缓存中毒" class="headerlink" title="DNS 缓存中毒"></a>DNS 缓存中毒</h2><ol>
<li><p><strong>思想</strong> 攻击者欺骗DNS服务器缓存保存虚假的DNS记录。</p>
 <img src="/计算机安全导论_img/4.png">

 <img src="/计算机安全导论_img/5.png">

 <img src="/计算机安全导论_img/6.png">
</li>
<li><p><strong>检测</strong> DNS使用16位请求标识符将查询ID与响应ID配对。当服务器</p>
<ol>
<li><p>忽略标识符</p>
</li>
<li><p>具有可预测的ID</p>
</li>
<li><p>接受未经请求的DNS记录</p>
<p>说明可能中毒了</p>
</li>
</ol>
</li>
<li><p>防御DNS缓存中毒</p>
<ol>
<li>对查询使用随机标识符 </li>
<li>始终检查标识符 </li>
<li>DNS请求的端口随机化</li>
<li>部署DNSSEC（DNS协议的安全扩展集）</li>
</ol>
</li>
</ol>
<h2 id="DNS缓存中毒和生日悖论"><a href="#DNS缓存中毒和生日悖论" class="headerlink" title="DNS缓存中毒和生日悖论"></a>DNS缓存中毒和生日悖论</h2><blockquote>
<p>DNS 协议交换不验证对递归迭代查询的响应。验证查询只会检查 16 位事务 ID 以及响应数据包的源 IP 地址和目标端口。在 2008 年之前，所有 DNS 使用固定端口53 解析.因此，除了事务 ID 之外，欺骗 DNS 回复所需的所有信息都是可预测的。用这种弱点攻击 DNS 被称为“生日悖论”，平均需要 256 次来猜测事务 ID。为了使攻击成功，伪造的 DNS 回复必须在合法权威响应之前到达目标解析器。如果合法响应首先到达，它将由解析器缓存，并且直到其生存时间（TTL）到期，解析器将不会要求权威服务器解析相同的域名，从而防止攻击者中毒映射该域，直到 TTL 到期。</p>
</blockquote>
<h2 id="DNSSEC"><a href="#DNSSEC" class="headerlink" title="DNSSEC"></a>DNSSEC</h2><blockquote>
<p>DNSSEC 采用基于公共密钥加密的数字签名，从而增强 DNS 验证强度。DNSSEC 并非对 DNS 查询和响应本身进行加密签名，而是由数据所有者对 DNS 数据自身进行签名。</p>
</blockquote>
<blockquote>
<p>每一个 DNS 区均包含一个公私秘钥对。DNS 区所有者使用该区域的私钥对区域内的 DNS 数据进行签名，为这些数据生成数字签名。顾名思义，”私钥”是指 DNS 区所有者会对这些密钥材料保密。但是，该区域的公钥则在区域内公开发布，供全体用户检索。凡在区域内查找数据的递归解析器，还必需检索区域公钥，从而使用公钥验证 DNS 数据的真实性。解析器确认检索到的 DNS 数据的数字签名是否有效。如果有效，证明 DNS 数据合法，则将 DNS 数据返回给用户。如果签名未通过验证，解析器会假设发生攻击，丢弃数据并向用户返回错误。</p>
</blockquote>
<ol>
<li><p>目的：验证</p>
<ol>
<li>DNS回答来源的真实性</li>
<li>回复的完整性</li>
<li>拒绝存在的真实性</li>
</ol>
</li>
<li><p>通过在每一步中对DNS回复签名来实现这一点</p>
</li>
<li><p>使用公钥加密对所有DNS应答进行数字签名</p>
</li>
<li><p>通常使用信任锚，操作系统中的条目来引导进程</p>
</li>
<li><p>现状：加入安全机制后，数据包会远大于512B的UDP数据包。</p>
</li>
</ol>
<h1 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h1><ol>
<li><p>定义：防火墙是一种集成的安全措施集合，旨在防止对网络计算机 系统未经授权的访问。</p>
</li>
<li><p>防火墙策略：</p>
<ol>
<li>接收</li>
<li>拒绝</li>
<li>丢弃</li>
</ol>
</li>
<li><p>数据包匹配：基于数据包的一些特性。</p>
</li>
</ol>
<h2 id="黑名单与白名单"><a href="#黑名单与白名单" class="headerlink" title="黑名单与白名单"></a>黑名单与白名单</h2><h3 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h3><ol>
<li>默认规则为接收，只拒绝/丢弃黑名单定义的规则匹配到的数据包。</li>
</ol>
<h3 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h3><ol>
<li>默认规则拒绝，只接收白名单规则匹配到的数据包。</li>
</ol>
<h2 id="防火墙分类"><a href="#防火墙分类" class="headerlink" title="防火墙分类"></a>防火墙分类</h2><ol>
<li>数据包过滤器(无状态防火墙)：如果数据包与数据包过滤器的规则集匹配，则数据包过滤器将丢弃或者接受他。</li>
<li>状态过滤器(状态防火墙)：一种能够提供状态数据包检查或状态查看功能的防火墙，能够持续追踪穿过这个防火墙的各种网络连接（例如TCP与UDP连接）的状态。这种防火墙被设计来区分不同连接种类下的合法数据包。只有匹配主动连接的数据包才能够被允许穿过防火墙，其他的数据包都会被拒绝。</li>
<li>应用层防火墙：当内部计算机与外部主机连结时，将由代理服务器（Proxy Server）担任内部计算机与外部主机的连结中继者。使用ALG的好处是隐藏内部主机的地址和防止外部不正常的连接，如果代理服务器上未安装针对该应用程序设计的代理程序时，任何属于这个网络服务的封包将完全无法通过防火墙。</li>
</ol>
<h3 id="无状态防火墙"><a href="#无状态防火墙" class="headerlink" title="无状态防火墙"></a>无状态防火墙</h3><ol>
<li>将每个尝试通过它的数据包视为独立的，而不考虑前后数据包间的关系。</li>
<li>因此必须具有严格的限制性</li>
</ol>
<h3 id="状态防火墙"><a href="#状态防火墙" class="headerlink" title="状态防火墙"></a>状态防火墙</h3><ol>
<li>可以区分数据包是否是<strong>受信任网络</strong>内发起的<strong>合法会话</strong>的一部分。</li>
<li>状态防火墙维护一些表，表中包含每个活动<strong>连接的信息</strong>， 包括<strong>IP地址、端口和数据包的序列号</strong>。通过这些表，可以只允许响应内部网发起连接的TCP数据包流入。</li>
<li><strong>对于TCP</strong> 一旦完成初始的握手，且也允许数据包通过防火墙，则该连接的所有后续通信都允许通过防火墙，直到连接终止。</li>
<li><strong>对于UDP</strong> 由于UDP没有握手过程，所以一般情况下，当防火墙允许合法UDP通过</li>
</ol>
<h3 id="应用层防火墙"><a href="#应用层防火墙" class="headerlink" title="应用层防火墙"></a>应用层防火墙</h3><ol>
<li>基于进入或流出网络数据包的实际内容来管理流量，而不是仅仅分析源和目的。</li>
</ol>
<h3 id="现状：基于深度数据包检测技术"><a href="#现状：基于深度数据包检测技术" class="headerlink" title="现状：基于深度数据包检测技术"></a>现状：基于深度数据包检测技术</h3><h1 id="隧道—-gt-TCP"><a href="#隧道—-gt-TCP" class="headerlink" title="隧道—-&gt;TCP"></a>隧道—-&gt;TCP</h1><ol>
<li><strong>问题</strong> 由于TCP本身是不加密的，如果有人窃听TCP连接，就可以知道有效载荷中的全部内容。</li>
<li><strong>解决</strong> 使用隧道协议，无需改变软件的执行就能防止窃听，并且加密是自动的。</li>
<li><strong>缺点</strong> 需要在传输层或网络层协议中使用应用层概念，增加了协议栈的开销。</li>
</ol>
<h2 id="安全的Shell-SSH-gt-Telnet-FTP-rlogin等早期远程管理协议"><a href="#安全的Shell-SSH-gt-Telnet-FTP-rlogin等早期远程管理协议" class="headerlink" title="安全的Shell (SSH) -&gt;Telnet,FTP,rlogin等早期远程管理协议"></a>安全的Shell (SSH) -&gt;Telnet,FTP,rlogin等早期远程管理协议</h2><ol>
<li>使用对称和公钥密码技术加密通信。</li>
<li>常用于<strong>安全隧道</strong>，目的是使窃听者无法推断出SSH流量的内容，使用SSH建立的隧道能防止许多基于数据包嗅探的攻击。</li>
<li><strong>安全的交互式命令会话</strong>过程：<ol>
<li>客户端通过一个TCP会话连接到服务器</li>
<li>客户端与服务器交换管理细节的信息，如支持的加密方法、各 自协议的版本，每一方都要选择另一方支持的一组协议</li>
<li>客户端和服务器进行密钥交换，创建共享的秘密会话密钥，用 会话密钥加密双方的通信（但不用于身份验证）。这个会话密 钥配合选择的块加密（通常是AES、3DES、Blowfish或IDEA） 来加密所有后续的通信</li>
<li>服务器向客户端发送可以接受身份验证列表，客户端将按顺序尝 试。最常见的机制是使用密码或以下的公共密钥身份验证方法：<ol>
<li>如果选定的机制是<strong>公共密钥身份验证</strong>，则客户端向服务器发送<strong>自己的</strong>公钥；</li>
<li>然后服务器检查是否这密钥已存储在其授权的密钥列表之中。如果在， 服务器使用客户的<strong>公钥加密挑战</strong>，并将其发送给客户端；</li>
<li>客户用自己的私钥解密挑战，并向服务器发回响应，证明自己的身份；</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="IPSec–-gt-IP"><a href="#IPSec–-gt-IP" class="headerlink" title="IPSec–&gt;IP"></a>IPSec–&gt;IP</h2><p>IPSec协议族在网络层保证应用程序的安全，为数据包提供机密性和真实性。且协议族中每个协议都能运行在<strong>传输模式</strong>或<strong>隧道模式</strong>下</p>
<ol>
<li><strong>传输模式</strong>：在原数据包的数据之前，插入额外的IPSec的头信息，只对数据包的有效载荷继续加密或身份验证。</li>
<li><strong>隧道模式</strong>：构造一个新的数据包，将IPSec头信息和整个原数据包一起封装进新数据包的有效载荷中。</li>
</ol>
<h2 id="VPN-虚拟专用网"><a href="#VPN-虚拟专用网" class="headerlink" title="VPN 虚拟专用网"></a>VPN 虚拟专用网</h2><p>分为 <strong>远程访问VPN</strong>和<strong>站点到站点的VPN</strong></p>
<h3 id="远程访问VPN"><a href="#远程访问VPN" class="headerlink" title="远程访问VPN"></a>远程访问VPN</h3><p>允许授权的用户通过安装在自己电脑上的客户端通过NAS访问私有网络，即内网。</p>
<ol>
<li><strong>网路接入服务器(NAS)</strong>：VPN服务端</li>
</ol>
<h3 id="站点到站点的VPN"><a href="#站点到站点的VPN" class="headerlink" title="站点到站点的VPN"></a>站点到站点的VPN</h3><p>旨在为<strong>两个或更多</strong>远程网络提供安全的桥梁。两个网络各有一个独立的VPN端点，两端点之间相互通信。</p>
<h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><ol>
<li><p>使用点对点的隧道协议 PPTP</p>
<p> 首先使用PPP建立连接，然后封装PPP帧，然后用MPPE对其加密，最后通过互联网发送数据包。</p>
</li>
</ol>
<h2 id="隧道存在的安全风险"><a href="#隧道存在的安全风险" class="headerlink" title="隧道存在的安全风险"></a>隧道存在的安全风险</h2><ol>
<li>会规避防火墙的策略。当使用隧道技术时，会不同的传输协议对一系列网络数据包的有效载荷进行封装。同时，在隧道协议中也对有效载荷进行了加密，所以深度数据包检测也毫无用处。</li>
<li>如果内部用户通过隧道直接和外部服务器连接，并代表该用户向禁止访问的网站路由HTTP流量，同样通过隧道，将响应返回给该用户。相应的，攻击者也可以通过隧道规避防火墙。</li>
</ol>
<h1 id="入侵检测"><a href="#入侵检测" class="headerlink" title="入侵检测"></a>入侵检测</h1><h2 id="入侵检测系统-IDS"><a href="#入侵检测系统-IDS" class="headerlink" title="入侵检测系统 IDS"></a>入侵检测系统 IDS</h2><p>IDS 是一个软件或硬件系统，用于检测网络或个人计算机上恶意活动的迹象。</p>
<ol>
<li><p>分类： 按功能分</p>
<ol>
<li><p>IDS传感器，用于收集网络组件或计算机的实时数据</p>
</li>
<li><p>IDS管理器，用于接收来自传感器的报告</p>
</li>
<li><p><strong>关系</strong>：IDS管理器编译来自IDS传感器的数据，以确定是否发生了入侵。以此确定基于一组站点策略，这些策略是定义可能入侵的规则和条件。如果 IDS管理员检测到入侵，则会发出警报。</p>
</li>
</ol>
</li>
<li><p>IDS所检测的威胁包括</p>
<ol>
<li>伪装者：冒用合法用户的身份或凭据来获得对计算机系统或网络的访问的攻击者</li>
<li>违反者：执行了未经授权的操作的合法的用户</li>
<li>秘密用户：通过删除审计文件或系统日志，试图组织或掩盖自己行为的用户</li>
</ol>
</li>
<li><p>IDS所检测的攻击包括</p>
<ol>
<li><strong>端口扫描</strong>：是指某些别有用心的人发送一组端口扫描消息，试图以此侵入某台计算机，并了解其提供的计算机网络服务类型。攻击者可以通过它了解到从哪里可探寻到攻击弱点。</li>
<li><strong>拒绝服务攻击</strong>：网络攻击淹没主机，并将合法访问拒之门外</li>
<li><strong>恶意软件攻击</strong>：复制恶意软件的攻击，特洛伊木马、计算机蠕虫和病毒等</li>
<li>ARP欺骗：试图重定向局域网中的IP流量</li>
<li><strong>DNS缓存中毒</strong>：网络嫁接攻击旨在改变主机的DNS缓存，以创建伪造的域名/IP 地址的关联</li>
</ol>
</li>
</ol>
<h2 id="入侵检测技术"><a href="#入侵检测技术" class="headerlink" title="入侵检测技术"></a>入侵检测技术</h2><ol>
<li><p>传统的网络入侵检测系统（NIDS）</p>
<p> – 位于网络边界，基于<strong>流量模式和内容</strong>检测恶意的行为；</p>
</li>
<li><p>基于入侵检测系统的协议（PIDS）</p>
<p> – <strong>专门检测特定协议中的恶意行为</strong>，通常部署在特定的网络主机中。如 Web服务器可以运行PIDS来分析流入的HTTP流量，丢弃恶意的或包含错误的请求</p>
</li>
<li><p>基于主机的IDS（HIDS）</p>
<p> – 驻留在单个系统之中，<strong>监控这台计算机上的活动</strong>。如系统调用，进程间 的通信和资源使用模式</p>
</li>
</ol>
<h2 id="IDS攻击"><a href="#IDS攻击" class="headerlink" title="IDS攻击"></a>IDS攻击</h2><p>通过对IDS本身发动Dos攻击，故意触发大量入侵警报。直到淹没IDS，使他无法记录每个事件，或让管理员很难确定哪些日志代表攻击。</p>
<h2 id="入侵检测错误"><a href="#入侵检测错误" class="headerlink" title="入侵检测错误"></a>入侵检测错误</h2><p>包括：</p>
<ol>
<li>误报：当事件是良性活动而不是入侵时就发出警报，导致时间和资源的浪费。</li>
<li>漏报：当事件是入侵的恶意事件，却未发出警报。</li>
</ol>
<h3 id="基率谬误"><a href="#基率谬误" class="headerlink" title="基率谬误"></a>基率谬误</h3><p>由于基率谬误的存在，可能使某些IDS的有效性被误解。所以，当评估某些条件事件的概率而不考虑该事件的“基本概率”时，会发生此类错误。例如：</p>
<ol>
<li><p>假设IDS准确度为99％，假阳性或假阴性的概率为1％。 </p>
</li>
<li><p>假设入侵检测系统生成1,000,100个日志条目。 1,000,100个条目中只有100个对应于实际的恶意事件。 </p>
</li>
<li><p>由于IDS的成功率，在100个恶意事件中，99个将被检测为恶意，这意 味着我们有1个假阴性。 </p>
</li>
<li><p>然而，在1,000,000个良性事件中，10,000个将被错误地识别为恶意事件。 </p>
</li>
<li><p>因此，将共有10,099个警报响起，其中10,000个是误报警。也就是说，大约99％的警报都是误报警。</p>
</li>
</ol>
<h2 id="IDS数据收集和审计记录"><a href="#IDS数据收集和审计记录" class="headerlink" title="IDS数据收集和审计记录"></a>IDS数据收集和审计记录</h2><ol>
<li><p>入侵检测的输入是确定网络或主机操作基本的记录流</p>
</li>
<li><p>记录流中操作的类型包括：</p>
<ol>
<li>基于网的IDS，包括每次HTTP会话尝试、每次登录尝试、每 次TCP绘画的初始化等；</li>
<li>基于主机的IDS，包括对文件的读、写或执行</li>
</ol>
</li>
<li><p>IDS传感器检测这些操作，创建这些操作的特征。将这 些记录报告给IDS管理器或者将它们写入审计日志</p>
</li>
<li><p>IDS事件记录包括：主体，对象，操作，异常条件，占用的资源，时间戳。</p>
</li>
</ol>
<h2 id="入侵检测系统的类型"><a href="#入侵检测系统的类型" class="headerlink" title="入侵检测系统的类型"></a>入侵检测系统的类型</h2><h3 id="基于规则的入侵检测"><a href="#基于规则的入侵检测" class="headerlink" title="基于规则的入侵检测"></a>基于规则的入侵检测</h3><ol>
<li><p><strong>规则</strong>标识与入侵攻击的某些已知<strong>配置文件匹配的操作类型</strong>，在这种情况下， 规则将编码此类攻击的<strong>签名</strong>。因此，如果IDS管理器看到与该规则的签名匹配的事件，它将立即发出警报，甚至可能指示怀疑的类型。</p>
</li>
<li><p><strong>优点</strong>：减少了误报，因为决策者已经明确了规则列表。</p>
</li>
<li><p><strong>缺点</strong>：存在局限性，因为它需要IDS具有每一个攻击类型的特征。</p>
</li>
</ol>
<h3 id="基于统计的入侵检测"><a href="#基于统计的入侵检测" class="headerlink" title="基于统计的入侵检测"></a>基于统计的入侵检测</h3><ol>
<li>构建了一个配置文件，它是用户行为或主机使用的<strong>典型方式</strong>的统计表示； 因此，它可用于确定用户或主机何时以非常不寻常的<strong>异常方式</strong>运行。</li>
</ol>
<h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><ol>
<li><p>允许用户列举计算机的哪个端口正在接受连接的技术。端口的状态包括：开放的，关闭的，阻塞的。</p>
</li>
<li><p>端口扫描的方法：</p>
<ol>
<li><p>TCP扫描/连接扫描：向目标主机的每个端口发起TCP连接。完成连接的端口是开放的，否则要么是关闭的，要么是阻塞的。</p>
</li>
<li><p>SYN扫描：向目标主机端口发起SYN标志的数据包，看是否有SYN-ACK返回。(如果收到，则发出一个RST数据包终止连接而非完成握手)</p>
</li>
<li><p>空闲扫描：它允许进行端口完全欺骗扫描。使得攻击者能够不使用自己的IP向目标主机发送数据包。它的巧妙之处在于，利用不活跃的“僵尸主机”反弹给攻击者一个旁通信道，从而使得攻击者可以进行端口扫描。入侵检测系统也就会把无辜的僵尸主机当成攻击者。利用僵尸可预测的TCP序列号实现。其过程如下：</p>
<ol>
<li>探测僵尸主机的IP ID 并记录。</li>
<li>向需要扫描的目标主机端口发送一个伪造成来自僵尸主机的SYN包。根据目标主机端口状态的不同，目标主机返回的数据包会使得僵尸主机的IP ID递增或否。</li>
<li>再次探测僵尸主机的IP ID。并对比第一步记录的IP ID就可以确定目标主机端口的状态。如果序列号递增了，则表示目标端口是开放的。否则，目标端口是关闭或阻塞的。</li>
</ol>
</li>
<li><p>UDP扫描：向目标主机端口发送UDP数据包。</p>
</li>
</ol>
</li>
</ol>
<h2 id="蜜罐"><a href="#蜜罐" class="headerlink" title="蜜罐"></a>蜜罐</h2><p>使用一台计算机作为诱饵的入侵检测技术。其优点包括</p>
<ol>
<li><p>入侵检测：因为连接到蜜罐的尝试不会来自合法用户，所以 对蜜罐的任何连接都被安全地确定为入侵。</p>
</li>
<li><p>证据：蜜罐计算机中有吸引力的文件使入侵者逗留并留下证据，从而识别出入侵者或者确定他的位置。</p>
</li>
<li><p>导流：与合法计算机相比，蜜罐对入侵者更有吸引力，从而分散入侵者对敏感信息和服务的注意力。</p>
</li>
</ol>
<h1 id="无线网"><a href="#无线网" class="headerlink" title="无线网"></a>无线网</h1><p>无线网引入安全问题包括：</p>
<ol>
<li>使得<strong>数据包嗅探</strong>更加容易。因为同一个网段的所有计算机都共享一个无线接入点。</li>
<li>使得<strong>会话劫持</strong>更加容易。因为配有无线适配器的计算机都可以嗅探出数据包并模拟无线接入点。</li>
<li>存在<strong>入侵</strong>问题。入侵指未授权用户通过其他人的无限接入点连接到互联网。</li>
<li>验证<strong>合法用户</strong>的难度增加。通过在局域网中主机的位置来验证合法主机再不可能，需要其他的身份验证或授权方法。</li>
</ol>
<h2 id="无线网结构"><a href="#无线网结构" class="headerlink" title="无线网结构"></a>无线网结构</h2><img src="/计算机安全导论_img/7.png">    

<ol>
<li>基于802.11标准。大多数的TCP/IP实现会根据不同的接收者重新定义数据包，即802.11帧和以太网帧的相互转换。</li>
<li>结构<ol>
<li>客户端计算机与接入点建立无线连接。</li>
<li>无线接入点连接到有线网络的接入点提供到互联网的网关。</li>
</ol>
</li>
</ol>
<h2 id="SSID-服务集ID"><a href="#SSID-服务集ID" class="headerlink" title="SSID (服务集ID)"></a>SSID (服务集ID)</h2><ol>
<li>SSID 32个字符组成的网络标识，使得多个无线网络可以共存。<ol>
<li>制造商的名称是接入点的典型默认SSID。</li>
<li>经常广播SSID可以使潜在用户能够发现网络</li>
</ol>
</li>
<li><strong>问题</strong> ：由于SSID未被签名，所以可以进行欺骗攻击<ol>
<li>将恶意接入点放置在公共场所（例如，咖啡馆，机场）； </li>
<li>使用ISP的SSID</li>
<li>设置类似于ISP的登录页面； </li>
<li>等待客户端连接到恶意接入点并进行身份验证；</li>
<li>可能会转发到ISP网络的会话；</li>
<li>由自动连接默认值促成</li>
</ol>
</li>
</ol>
<h2 id="强制网络门户"><a href="#强制网络门户" class="headerlink" title="强制网络门户"></a>强制网络门户</h2><ol>
<li><p><strong>定义</strong>：是公共接入网络的用户在授予访问权限之前必须查看和交互的网页。通常 用于商业中心、机场、酒店大堂、咖啡店等为用户提供免费Wi-Fi的场所</p>
</li>
<li><p><strong>协议</strong></p>
<ol>
<li><p>通过MAC地址定位客户端。</p>
</li>
<li><p>认证完成之前，任何URL都会被重定向到身份验证界面。</p>
<ol>
<li>防火墙会阻止其他流量。</li>
<li>名称服务器会将一切映射到认证服务器。</li>
</ol>
</li>
<li><p>身份验证之后，恢复常规网络服务。由DHCP提供IP地址。</p>
</li>
</ol>
</li>
<li><p><strong>问题</strong> </p>
<ol>
<li>如果客户端没有主动断开连接，则可以执行MAC欺骗和会话窃取。</li>
<li>如果身份验证之前未阻止防火墙之外的DNS流量，则隧道攻击可以绕过强制网络门户。</li>
</ol>
</li>
</ol>
<h2 id="Wardriving-and-Warchalking"><a href="#Wardriving-and-Warchalking" class="headerlink" title="Wardriving and Warchalking"></a>Wardriving and Warchalking</h2><ol>
<li>Wardriving在移动的汽车中，使用移动设备四处寻找无线网。</li>
<li>Warchalking（开战标记）：在公共场所绘制引导公共Wi-Fi网 络的一种绘画符号（源自流浪汉符号）</li>
</ol>
<h2 id="WEP-有线等效保密协议"><a href="#WEP-有线等效保密协议" class="headerlink" title="WEP 有线等效保密协议"></a>WEP 有线等效保密协议</h2><p>###<strong>目标</strong> ：</p>
<ol>
<li>机密性:防止窃听。</li>
<li>数据完整性：保证数据包不被篡改。</li>
<li>访问控制：仅路由正确加密的数据包。</li>
</ol>
<p>###<strong>限制</strong></p>
<ol>
<li>在数据链路层加密每个帧的主体。</li>
<li>避免传统的802.11标准。</li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>接入点和客户端共享40b的密钥。密钥在WEP会话期间不被更改。</p>
<h3 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h3><ol>
<li>流密码是一种对称加密系统，密文C由明文消息M异或密钥流生成，而密钥流是密钥产生的伪随机数二进制向量S。</li>
<li><strong>流密码是安全的</strong> 因为相同的密钥流永远不会被重用，否则攻击者会得到两个明文消息的异或值，统计攻击就能同时恢复明文和密钥流。</li>
</ol>
<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><ol>
<li>计算消息M(有效载荷部分)的CRC校验和。</li>
<li>选择24b的初始化向量V</li>
<li>使用RC4流密码生成密钥流S(K,V)</li>
<li>计算密文 C=(M||CRC(m))⊕S(K,V)</li>
</ol>
<h3 id="WEP-认证方法"><a href="#WEP-认证方法" class="headerlink" title="WEP 认证方法"></a>WEP 认证方法</h3><p>包括开放系统和共享密钥两种。</p>
<ol>
<li><p><strong>开放系统</strong>身份验证</p>
<p> 客户端无需任何凭证就可以连接接入点。且只能使用正确的密钥发送和接收信息，否则接入点会忽略请求。</p>
</li>
<li><p><strong>共享密钥</strong>身份验证</p>
<p> 在连入接入点之前要先证明自己拥有接入点的WEP密钥。</p>
<ol start="2">
<li>接入点向客户端发起明文挑战，客户端用拥有的密钥加密该明文，并将生成的密文发给接入点。</li>
<li>如果接入点能正确解密，则可连接接入点。</li>
</ol>
</li>
</ol>
<h2 id="消息篡改攻击"><a href="#消息篡改攻击" class="headerlink" title="消息篡改攻击"></a>消息篡改攻击</h2><h3 id="消息篡改"><a href="#消息篡改" class="headerlink" title="消息篡改"></a>消息篡改</h3><p>对于给定一个任意字符串 ，我们想用M’=M⊕▲替换消息M</p>
<p>可以在中途用C’=C⊕(▲||CRC(▲))来替换C。</p>
<ol>
<li>需要直到消息中文本的位置即可</li>
<li><strong>脆弱性原因</strong> CRC检验和是通过XOR</li>
<li><strong>解决</strong> 改用哈希函数</li>
</ol>
<h2 id="IP重定向攻击"><a href="#IP重定向攻击" class="headerlink" title="IP重定向攻击"></a>IP重定向攻击</h2><p>指攻击者利用物理接入点解密数据包，将目的地址修改为恶意主机地址。</p>
<ol>
<li><p>过程为：</p>
<ol>
<li>窃听入站的IP数据包。</li>
<li>将数据包重新发送到由攻击者控制的外部计算机。</li>
<li>接收由接入点解密的数据包。</li>
<li>重复出站数据包。</li>
</ol>
</li>
<li><p>需要修改数据包校验和。校验和的差为：x’-x=(D’H+D’L)-(DH-DL)</p>
</li>
</ol>
<h2 id="重用初始化向量IV"><a href="#重用初始化向量IV" class="headerlink" title="重用初始化向量IV"></a>重用初始化向量IV</h2><h3 id="初始化向量IV"><a href="#初始化向量IV" class="headerlink" title="初始化向量IV"></a>初始化向量IV</h3><ol>
<li>每个数据包一个，24位。</li>
<li>以邮件的明文部分发送。</li>
<li>初始化向量空间过小会导致重用相同的密钥流。</li>
</ol>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li><strong>问题</strong> 重用初始化向量意味着重用密钥流，攻击者获得两条消息的XOR，可以恢复出消息和密钥流。</li>
<li><strong>默认IV存在上述问题</strong></li>
<li><strong>解决</strong> 使用随机IV，且长度要足够长。</li>
</ol>
<h3 id="注入方法"><a href="#注入方法" class="headerlink" title="注入方法"></a>注入方法</h3><ol>
<li>假设攻击者知道一个加密消息的一个明文。</li>
<li>利用RC4(X )⊕X⊕Y=RC4(Y),来构造计算CRC32的新消息。</li>
</ol>
<h2 id="身份验证欺骗"><a href="#身份验证欺骗" class="headerlink" title="身份验证欺骗"></a>身份验证欺骗</h2><ol>
<li>不知道密钥的非法用户可以通过窃听身份验证消息。</li>
<li><strong>攻击</strong><ol>
<li>生成挑战R和加密挑战C =(R||CRC(R))⊕S(K,V)</li>
<li>计算密钥流S(K,V)=(R||CRC(R))⊕C</li>
<li>从接入点挑战时重用密钥流S(K,V)</li>
</ol>
</li>
</ol>
<h2 id="慢攻击：WEP嗅探"><a href="#慢攻击：WEP嗅探" class="headerlink" title="慢攻击：WEP嗅探"></a>慢攻击：WEP嗅探</h2><p>通过大量数据包去计算初始化向量IV</p>
<h2 id="快攻击：数据包注入"><a href="#快攻击：数据包注入" class="headerlink" title="快攻击：数据包注入"></a>快攻击：数据包注入</h2><h2 id="WPA-Wi-fi访问保护"><a href="#WPA-Wi-fi访问保护" class="headerlink" title="WPA Wi-fi访问保护"></a>WPA Wi-fi访问保护</h2><p>目的是为了改进WEP</p>
<h3 id="区别WEP"><a href="#区别WEP" class="headerlink" title="区别WEP"></a>区别WEP</h3><ol>
<li>采用128位密钥和48位IV</li>
<li>支持除共享密钥外各种类型的身份验证。</li>
<li>会话期间动态修改密钥。</li>
<li>支持检查完整性的加密。</li>
<li>增加帧计数器防止重放攻击</li>
</ol>
<h3 id="WPA2"><a href="#WPA2" class="headerlink" title="WPA2"></a>WPA2</h3><ol>
<li>使用AES而不是RC4</li>
<li>处理加密，密钥管理和完整性</li>
<li>由反模式提供的MAC与密码块链接（CCMP）一起使用</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计安导第3章</title>
    <url>/2020/01/20/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC3%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h1><ol>
<li>包括计算机硬件系统和计算机软件系统。<ol>
<li>硬件系统包括：运算器，控制器，存储器，输入设备，输出设备。</li>
<li>软件系统：操作系统</li>
</ol>
</li>
<li>操作系统：提供计算机用户和该计算机硬件之间的接口，管理应用程序访问计算机资源的方式。<ol>
<li>内核：操作系统的核心组件，处理对底层硬件资源的管理。</li>
</ol>
</li>
<li>系统调用：是一种机制，通过这种机制，应用程序可以委托内核来执行与硬件相关的操作。</li>
</ol>
<h1 id="进程："><a href="#进程：" class="headerlink" title="进程："></a>进程：</h1><ol>
<li>进程进程是正在执行的程序的一个实例。</li>
<li>进程树：新的进程由其父进程产生，构成一颗进程树。树的根是init进程，在加载和运行内核后开始执行，并创建登陆会话和系统任务等其他子进程。</li>
<li>进程ID：每个进程都通过唯一的非负整数进行标识。</li>
<li>进程间通信<ol>
<li>读写文件进行方式<ol>
<li>通过硬盘，速度较慢。</li>
<li>不便于进行私密通信。</li>
</ol>
</li>
<li>共享内存方式<ol>
<li>只有内核能管理共享内存区。</li>
</ol>
</li>
<li>管道和套接字：提供进程与进程间通信的通道，通信双方共享管道和套接字。</li>
<li>信号量机制</li>
</ol>
</li>
<li>远程过程调用RPC：允许一个进程调用另一个进程中的子例程。</li>
<li>守护进程和服务<ol>
<li>守护进程（后台进程）（Windows下称为服务）：运行权限高于任何用户，并在登陆会话结束前就一直存在。如Web服务器，远程登陆</li>
</ol>
</li>
</ol>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><ol>
<li><p>文件系统是如何组织计算机的外部、非易失性存储的一种抽象。</p>
</li>
<li><p>文件权限</p>
<p> 关键在于界定哪些用户可以访问哪些资源。</p>
</li>
<li><p>Unix文件权限</p>
<ol>
<li>包括三类用户：<ol>
<li>owner类</li>
<li>group类：决定了相同组中的用户的文件权限。</li>
<li>others类</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><ol>
<li>内存管理是指如何组织和分配计算机的内存。</li>
<li>进程的地址空间<ol>
<li>代码段</li>
<li>数据段</li>
<li>BSS：符号起始区块，包含未初始化的静态变量。</li>
<li>堆：动态段，存储运行时产生的数据。</li>
<li>栈：记录函数调用和他们的参数。</li>
</ol>
</li>
<li>内存访问权限<ol>
<li>五段都有各自的访问权限。通常代码段只读，其他段可以写入</li>
<li><strong>不允许进程访问其他进程的地址空间</strong></li>
</ol>
</li>
<li>虚拟内存<ol>
<li>每个进程都有一个虚拟地址空间，虚拟内存系统将每个虚拟地址映射为实际内存地址。</li>
<li>由MMU来进行地址转换。</li>
<li>在进程看来，它的虚拟地址空间是连续的，但是实际内存却未必。</li>
<li>优点：允许进程的地址空间大于内存。</li>
<li>缺点：访问硬盘速度慢。 </li>
<li><strong>问题</strong>：不正常关机的时候，虚拟页面可能未被删除。攻击者可以通过外部介质引导另一个操作系统，查看并重建部分内存，导致信息泄漏。</li>
<li><strong>解决</strong>：对硬盘内容进行加密。</li>
</ol>
</li>
<li>缺页</li>
<li>虚拟机<ol>
<li>不直接接触底层硬件就允许操作系统的运行。</li>
<li>在虚拟机中运行的操作系统称为客户机，本地的操作系统称为主机。</li>
<li>虚拟机的实现：<ol>
<li>模拟：主机系统翻译接口的通信，传给硬件。其优点是增加了硬件的灵活性，缺点是使性能下降。</li>
<li>虚拟化：失去硬件灵活性，但是性能提升了。</li>
</ol>
</li>
<li>虚拟机的优点<ol>
<li>提高了硬件效率：在一台机器上托管多个操作系统。</li>
<li>可移植性</li>
<li>安全：沙箱</li>
<li>便于管理</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="进程安全"><a href="#进程安全" class="headerlink" title="进程安全"></a>进程安全</h1><h2 id="引导顺序及安全"><a href="#引导顺序及安全" class="headerlink" title="引导顺序及安全"></a>引导顺序及安全</h2><ol>
<li>引导：从关机状态到将操作系统加载到内存。</li>
<li>加载分两阶段：首先加载BIOS固件中的代码，然后这程序会假爱国操作系统其余部分加载到内存，然后将控制权交给操作系统。</li>
<li><strong>问题</strong>：恶意用户可以利用引导过程的一些脆弱点来控制计算机的执行。</li>
<li><strong>解决</strong>：设置BIOS密码。</li>
</ol>
<h2 id="引导设备的层次"><a href="#引导设备的层次" class="headerlink" title="引导设备的层次"></a>引导设备的层次</h2><ol>
<li>第二阶段引导程序允许用户指定使用哪个设备来加载操作系统。</li>
<li><strong>问题</strong>：攻击者可以绕过运行的计算机上的安全机制，从外部介质引导其他操作系统。</li>
<li><strong>解决</strong>：对第二阶段引导程序启动密码保护。</li>
</ol>
<h2 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h2><ol>
<li>休眠：电源关闭的状态。当进入休眠时，操作系统将计算机内存的全部内容存储到硬盘中的休眠文件中；系统通电后，再迅速恢复计算机状态。</li>
<li><strong>问题</strong>：<ol>
<li>攻击者可以从休眠文件中获取一些敏感信息。Windows的休眠文件目录C:/hiberfil.sys</li>
<li>攻击者可以修改休眠文件，改变计算机上执行的程序。</li>
<li>即使计算机重启后，也不会删除休眠文件。</li>
</ol>
</li>
<li><strong>解决</strong>：使用硬盘加密来保护休眠文件。</li>
</ol>
<h2 id="监控、管理和日志"><a href="#监控、管理和日志" class="headerlink" title="监控、管理和日志"></a>监控、管理和日志</h2><p>操作系统可以根据留下的线索解决常见的问题，还能确定出现安全漏洞的原因。</p>
<ol>
<li>事件日志：<ol>
<li>由操作系统进行管理</li>
<li>Windows中定义了三种日记 源：系统、应用程序和安全。其中系统日志只有操作系统才能写入；应用程序日志只由应用程序写入；安全日志由操作系统提供的本地安全授予子系统服务才能写入。  </li>
</ol>
</li>
<li>进程监控：查看正在运行的进程</li>
<li>进程查看器：提供进程监控和管理的大量信息。<ol>
<li>提高进程的映像，即运行进程的代码所在的磁盘位置。</li>
<li><strong>问题</strong>：攻击者可以通过替换合法程序的映像来掩饰自身。</li>
<li><strong>解决</strong>：可以对映像使用数字签名来保证磁盘上存储的应用程序不被替换。</li>
</ol>
</li>
</ol>
<h1 id="基于密码的身份认证"><a href="#基于密码的身份认证" class="headerlink" title="基于密码的身份认证"></a>基于密码的身份认证</h1><ol>
<li>密码盐—反字典攻击：是一种加密技术，使用随机位作为散列函数的输入或加密算法的部分输入，从而增加随机性。<br> (U,S,h(S||P))其中S为U的盐，h是散列函数。</li>
<li>加盐的原理：增大字典攻击的搜索空间。2<sup>B×D，其中B是随机数位数，D是字典攻击单词列表。</li>
</ol>
<h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><h2 id="Linux的权限"><a href="#Linux的权限" class="headerlink" title="Linux的权限"></a>Linux的权限</h2><ol>
<li>使用文件权限矩阵</li>
<li>对于未明确授权的都默认拒绝</li>
<li>为了访问文件，在文件系统树中的每个祖先文件夹都必须有执行权限。</li>
<li>文件所有者具有自主访问控制权，可以修改文件权限。</li>
<li>可以使用chattr设置权限，lsattr查看。</li>
<li>目前开始支持ACL方案</li>
<li>对owner, group和other主体，每个文件都有基本的ACE(<strong>访问控制项</strong>)；对于命名用户和命名组可创建额外的ACE；还有掩码ACE,即规定主体允许的最大权限</li>
</ol>
<h2 id="Linux的ACL权限方案"><a href="#Linux的ACL权限方案" class="headerlink" title="Linux的ACL权限方案"></a>Linux的ACL权限方案</h2><ol>
<li>设U是进程的euid，具有一定的请求权限，视图访问文件或文件夹</li>
<li>为确定是否授权，操作系统将进行匹配：<ol>
<li>U是文件所有者的ID</li>
<li>U是命名组之一</li>
<li>U的一个组是所有组，该组的ACE包含请求权限。</li>
<li>U的一个组是命名组，该组的ACE包含请求权限。</li>
<li>对于U所在的每个组，该组的ACE都不包含请求权限。</li>
<li>检查other的ACE</li>
</ol>
</li>
</ol>
<h2 id="Windows权限基础"><a href="#Windows权限基础" class="headerlink" title="Windows权限基础"></a>Windows权限基础</h2><ol>
<li>Windows使用访问控制列表，允许用户创建访问控制规则。</li>
<li>默认是拒绝</li>
<li>标准权限包裹：读、写、修改、读和执行、完全控制。</li>
<li>读相关的高级属性：读取数据、读取属性、读取扩展属性和读取权限。</li>
<li>文件夹权限包括<ol>
<li>读权限：可以列出文件夹内容。</li>
<li>写权限：允许用户创建新文件夹。</li>
<li>Windows下可以禁止用户访问文件夹，但允许用户访问该文件夹下的特定文件。</li>
</ol>
</li>
<li>ACE<ol>
<li>继承ACE：文件夹的任何ACE可用于该文件夹内的子文件夹和文件。</li>
<li>显式ACE：针对文件或者文件夹专门设置的ACE。</li>
<li>ACE优先级：拒绝ACE&gt;允许ACE、显示ACE&gt;继承ACE、继承ACE优先级 由祖先与对象之间的距离决定，越近优先级越高。</li>
</ol>
</li>
</ol>
<h2 id="Windows文件权限"><a href="#Windows文件权限" class="headerlink" title="Windows文件权限"></a>Windows文件权限</h2><ol>
<li><p>SetUID操作：程序由普通用户运行，但期望允许程序改变普通用户无法改变的文件。</p>
<p> 例如：在早期UNIX系统中，用户登录信息存储在/etc/passwd中。普通用户 不能编辑这个文件，但允许该用户更改自己的密码是合理的要求</p>
<ol>
<li>设置了setuid位，使得程序以其所有者的有效ID来运行，而不是以正在执行程序的进程ID。</li>
<li><strong>问题</strong>  <ol>
<li>攻击者可以强制setuid程序执行任意代码，如缓冲区溢出攻击。</li>
<li>权限升级：攻击者可以通过setuid机制来运用程序的所有者权限。</li>
</ol>
</li>
</ol>
</li>
<li><p>文件描述符：存储在文件描述符表中的索引值，用来索引特定文件</p>
<ol>
<li>当程序需要访问文件时，访问open系统调用，该调用使内核创建一个文件 描述符表中的新项并将其返回给程序，该项映射到文件的磁盘位置。程序可以使用文件描述符发送读或者写命令。内核在接到读、写系统调用时， 在文件描述符表中查找相关的表项，并在磁盘适当位置执行读、写操作。完成操作后，要用close系统调用删除打开的文件描述符。</li>
<li><strong>漏洞</strong> 当进程创建子进程时，子进程会集成父进程打开的所有文 件描述符副本。当程序以高权限打开文件描述符，但未关闭，然后又创建了 低权限的进程，那么新进程就能够读写相关文件，但子进程本身不具有打开 该文件的权限。</li>
<li><strong>原因</strong> 在创建文件描述符项的时刻，操作 系统只检查进程是否具有读写权限；在实际读写文件操作时，只根据文件描 述符被打开时的权限来确认是否允许请求的操作。</li>
</ol>
</li>
<li><p>符号链接与快捷方式</p>
<ol>
<li><strong>问题</strong> 攻击者可以利用符号链接来诱使应用程序执行不良操作。</li>
<li><strong>解决</strong> 程序检查文件名是否指向符号链接，以确定打开的实际文件名。</li>
<li>Windows的快捷方式&amp;Linux的符号链接：符号链接由操作系统处 理，使用透明；而快捷方式是普通文件。</li>
</ol>
</li>
</ol>
<h1 id="应用程序安全"><a href="#应用程序安全" class="headerlink" title="应用程序安全"></a>应用程序安全</h1><h2 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h2><ol>
<li>编译：将源代码转换为处理器能够执行的机器代码的过程</li>
<li>静态链接：程序执行时所需的共享库需要复制到编译程序中。一般比较安全， 但重复代码会占用额外的空间。</li>
<li>动态链接：程序真正运行时，才会加载共享库。加载程序确定待运行程序需 要哪些共享库，然后在磁盘上找到这些库，并将它们导入进程的地址空间。<ol>
<li><strong>DDL注入</strong>：通过共享库向程序注入任意代码的过程。<strong>优点</strong> 是便于调试，<strong>缺点</strong> 是潜在的安全风险，恶意用户能向合法程序注入自己的代码。</li>
</ol>
</li>
</ol>
<h2 id="简单的缓冲区溢出攻击"><a href="#简单的缓冲区溢出攻击" class="headerlink" title="简单的缓冲区溢出攻击"></a>简单的缓冲区溢出攻击</h2><ol>
<li>缓冲区：进程为程序在内存中分配固定大小的存储空间。</li>
<li>缓冲区溢出：如果不进行边界检查，攻击者提供的输入数据可能会超出缓冲 区的大小。此时，内存缓冲区之外的数据可能会被覆盖。</li>
<li><strong>问题</strong> 攻击者利用缓冲区溢出获得进程的控制权，执行任意恶意代码。</li>
</ol>
<h2 id="基于栈的缓冲区溢出"><a href="#基于栈的缓冲区溢出" class="headerlink" title="基于栈的缓冲区溢出"></a>基于栈的缓冲区溢出</h2><ol>
<li>进程地址空间中栈由帧组成，每一帧存储局部变量、调用参数和返回地址。</li>
<li><strong>问题</strong> 如果攻击者提供的输入大于调用函数中缓冲区的大小，会导致溢出，从而导致栈缓冲区之外 的内存空间被覆盖。</li>
<li>缓冲区溢出攻击：当缓冲区是局部变量 或帧的参数时，用户的输入 可能覆盖返回地址，改变程 序的执行。<ol>
<li><strong>问题</strong> 攻击者利用栈缓冲区的脆弱 性，在栈中注入恶意代码， 覆盖当前调用的返回地址， 从而将执行权限传递给攻击 者的恶意代码。</li>
<li>实际攻击中，攻击者需要猜测缓冲区返回地址的位置，并确定用什么地址覆盖返回地址。难点在于：<ol>
<li>进程不能访问其他进程的地址空间，因此恶意代码必须驻留在被攻击进 程的地址空间内。一般驻留在缓冲区中或者在用户的Shell环境中。</li>
<li>给定进程的地址空间是不可预测的，程序在不同计算机上执行时，地址 空间可能发生改变。</li>
<li>为了克服以上困难，攻击者可以采取的相关技术有：NOP指令滑动(NOP sledding)、返回到libc(return-to-libc)、跳转到寄存器(jump-to-register)或蹦 床(Trampolining)技术</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="缓冲区溢出攻击相关技术"><a href="#缓冲区溢出攻击相关技术" class="headerlink" title="缓冲区溢出攻击相关技术"></a>缓冲区溢出攻击相关技术</h2><ol>
<li><p>NOP指令滑动:通过命中一串连续的NOP指令，从而使CPU指令执行流一直滑动到特定位 置来执行恶意代码。</p>
<ol>
<li>由于进程地址空间难以预测，所以通过一连串的NOP指令，只要有一个命中就能执行恶意代码。</li>
</ol>
</li>
<li><p>跳转到寄存器：在初始化时，大多数进程需要将外部库的内容加载到自己的地址空间。操作 系统一般将这些外部库加载到内存预留段的进程地址空间中。因此，外部库 在内存中的位置是可预测的。攻击者利用这些外部库的知识进行跳转攻击：</p>
<ol>
<li>攻击者找到特定代码集中 的跳转指令，如jump ESP；</li>
<li>攻击者设法把恶意代码放在ESP寄存器指定 的内存地址上；</li>
<li>攻击者将当前函数的返回地址重写为jump指令的地址； </li>
<li>函数返回时将执行jump指令，并跳转执行恶意代码；</li>
</ol>
</li>
<li><p>返回到libc攻击：攻击者确定脆弱进程的地址空间内C库函数的地址，如system()或execv的 地址，并使用这些信息强制进程调用该函数。</p>
<ol>
<li>攻击者首先让缓冲区溢出，并用所需库函数的地址覆盖返回地址，并传递重 新设定好的参数使其能够按攻击者的期望运行。</li>
<li>这种攻击方式在实现攻击的同时，也避开了数据执行保护策略中对攻击代码 的注入和执行所采取的的防护措施。Return-to-libc 攻击不需要注入新的恶意代码，而是重用漏洞程序中已有的 函数完成攻击，让漏洞程序跳转到已有的代码序列。</li>
</ol>
</li>
</ol>
<h2 id="防止基于栈的缓冲区溢出攻击"><a href="#防止基于栈的缓冲区溢出攻击" class="headerlink" title="防止基于栈的缓冲区溢出攻击"></a>防止基于栈的缓冲区溢出攻击</h2><ol>
<li>规范C语言编程</li>
<li>使用更安全的函数</li>
<li>操作系统也提供保护措施，如防止攻击者覆盖返回地址；使用金丝雀技术。</li>
</ol>
<h3 id="防止攻击者覆盖返回值地址"><a href="#防止攻击者覆盖返回值地址" class="headerlink" title="防止攻击者覆盖返回值地址"></a>防止攻击者覆盖返回值地址</h3><ol>
<li>在所有指针使用前后都进行异或编码</li>
<li>将内存的栈空间设置为非执行权限</li>
<li>地址空间布局随机化，随机地重新安排地址空间的数据，使得攻击者难以预测。</li>
</ol>
<h3 id="金丝雀预警技术"><a href="#金丝雀预警技术" class="headerlink" title="金丝雀预警技术"></a>金丝雀预警技术</h3><p>重新组织分配程序的堆栈数据，使用一个canary值，并将此值放在缓冲区和 控制数据之间。系统定期检查canary值的完整性。如果此值被更改，表明缓 冲区溢出，就要防止恶意代码的执行。</p>
<h2 id="基于堆的缓冲区溢出"><a href="#基于堆的缓冲区溢出" class="headerlink" title="基于堆的缓冲区溢出"></a>基于堆的缓冲区溢出</h2><p><strong>问题</strong> 如果在堆上显示分配了内存，但没有释放，会导致内存泄漏问题。</p>
<p><strong>攻击</strong> 攻击者一般通过修改堆中的数据 或者滥用管理堆内存的函数和宏 来执行恶意代码。</p>
<ol>
<li>如果攻击者向程序提供输入，而程序以不安全的方式将其复制到堆中的内存 块中。那么攻击者可以使数据溢出块的边界，并覆盖下一个内存块。通过精心设计，攻击者会覆盖下一个内存块的链表指针，并将该内存块标记 为空闲。此时，unlink例程可以向内存地址空间中的任意地址写入数据。如 果写入的数据是恶意代码的存储位置，会导致程序跳转并执行恶意代码。</li>
</ol>
<h2 id="防御基于堆的缓冲区溢出"><a href="#防御基于堆的缓冲区溢出" class="headerlink" title="防御基于堆的缓冲区溢出"></a>防御基于堆的缓冲区溢出</h2><p>如安全编程、地址空间随机化、设置堆数据不可执 行、将存储堆内存的指针数据和存储堆中的实际数据相分离。</p>
<h1 id="格式化字符串攻击"><a href="#格式化字符串攻击" class="headerlink" title="格式化字符串攻击"></a>格式化字符串攻击</h1><p><strong>攻击</strong> 攻击者可以精心指定所使用的格式化字符串作为输入，并可以将输入写入内 存的任意位置。如果写入的位置正好覆盖了返回地址、函数指针等，则攻击 者能够取得控制权，并在程序的上下文中执行任意代码。</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计安导第7章</title>
    <url>/2020/01/20/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC7%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h1><h2 id="HTML-超文本标记语言"><a href="#HTML-超文本标记语言" class="headerlink" title="HTML 超文本标记语言"></a>HTML 超文本标记语言</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>静态文档描述语言</li>
<li>支持链接到其他页面或者嵌入图像</li>
<li>通过表单（Forms）将用户输入发送到服务器</li>
</ol>
<h2 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h2><ol>
<li>先检索本地DNS，如果没有找到则查询DNS服务器</li>
<li>解析IP地址之后，建立TCP连接</li>
<li>HTTP请求和响应<strong>通过TCP的端口80</strong>传输</li>
<li>不提供数据加密，以明文发送</li>
</ol>
<h2 id="安全套接字层超文本传输协议HTTPS"><a href="#安全套接字层超文本传输协议HTTPS" class="headerlink" title="安全套接字层超文本传输协议HTTPS"></a>安全套接字层超文本传输协议HTTPS</h2><ol>
<li><p>与HTTP语法相同，但使用了安全套接字层SSL或传输层安全TLS</p>
</li>
<li><p>SSL和TLS都依靠证书来验 证服务器的身份，并建立加 密的通信信道</p>
 <img src="/计算机安全导论_img/8.png">

</li>
</ol>
<h1 id="网络钓鱼"><a href="#网络钓鱼" class="headerlink" title="网络钓鱼"></a>网络钓鱼</h1><p>通过伪造网页以欺诈的方式获取敏感资料</p>
<h2 id="URL混淆-同源攻击"><a href="#URL混淆-同源攻击" class="headerlink" title="URL混淆    同源攻击"></a>URL混淆    同源攻击</h2><p>注册带有unicode字符的域名，针对相似的字母进行注册。称为<strong>同源攻击</strong></p>
<h2 id="移除或伪造地址栏"><a href="#移除或伪造地址栏" class="headerlink" title="移除或伪造地址栏"></a>移除或伪造地址栏</h2><h1 id="图像崩溃"><a href="#图像崩溃" class="headerlink" title="图像崩溃"></a>图像崩溃</h1><p>由于浏览器的缺陷导致。通过HTML代码创建一个非常大比例的简单图像，可以使IE 崩溃，有时还会使电脑宕机。</p>
<h1 id="可移动代码"><a href="#可移动代码" class="headerlink" title="可移动代码"></a>可移动代码</h1><p><strong>可移动代码</strong> 指可执行、通过网络发送、在目标 电脑上执行的代码程序。包括</p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h2 id="ActiveX控件"><a href="#ActiveX控件" class="headerlink" title="ActiveX控件"></a>ActiveX控件</h2><h3 id="支持签名"><a href="#支持签名" class="headerlink" title="支持签名"></a>支持签名</h3><p>此签名的ActiveX控件要求 用户运行权限。如果获得批准，控件将以与用户相同的权限运行</p>
<h3 id="受信任-不受信任的ActiveX控件"><a href="#受信任-不受信任的ActiveX控件" class="headerlink" title="受信任/不受信任的ActiveX控件"></a>受信任/不受信任的ActiveX控件</h3><ol>
<li><p>可行的发布者：</p>
<ol>
<li>存储在Windows注册表中的列表 </li>
<li>恶意ActiveX控件可以修改注册表，使其发行者可信 </li>
<li>运行该发布者今后所有的插件不需要提示用户</li>
</ol>
</li>
<li><p>未签名的控件</p>
<ol>
<li>浏览器对于未签名的控件会给出一个接受/拒绝的选项</li>
<li>但即使你拒绝该控件，它也已被下载到一个临时文件夹中</li>
<li>如果拒绝，它不会被执行，但也不会被删除</li>
</ol>
</li>
</ol>
<h3 id="可以访问用户文件"><a href="#可以访问用户文件" class="headerlink" title="可以访问用户文件"></a><strong>可以访问用户文件</strong></h3><h2 id="Java插件"><a href="#Java插件" class="headerlink" title="Java插件"></a>Java插件</h2><h3 id="支持签名-1"><a href="#支持签名-1" class="headerlink" title="支持签名"></a>支持签名</h3><h3 id="沙箱执行"><a href="#沙箱执行" class="headerlink" title="沙箱执行"></a><strong>沙箱执行</strong></h3><ol>
<li>沙箱：应用程序或脚本在另一个应用程序中首先的运行权限。沙箱只能访问某些文件和设备。</li>
</ol>
<h1 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h1><p>cookie是指存储在计算机上、与特定服务器关联的 一小部分信息。用于在会话中保存状态信息。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>可能包含敏感信息</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol>
<li><strong>会话型cookie</strong>：是浏览器的处理过程中保留的，是暂时性的，当 浏览器关闭时则消除。</li>
<li><strong>持久性cookie</strong>：而持久性的是保存在客户端的硬盘上的，浏览器 关闭也不会消除。</li>
</ol>
<h1 id="跨站脚本-XSS"><a href="#跨站脚本-XSS" class="headerlink" title="跨站脚本 XSS"></a>跨站脚本 XSS</h1><p>用于攻击者将脚本代码注入Web应用程序生成的页面。攻击者通常在有漏洞的程序中插入Javascript， VBScript，ActiveX或Flash以欺骗用户。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>2005 年 Samy 在社交网站Myspace的个人资料中加入 Javascript ，打开该页面 的浏览器将执行该脚本 ― 首先把攻击者加为好友，其次把这段 XSS 复制到被 攻击者的个人资料中。</p>
<p>这算是一种<strong>蠕虫</strong></p>
<h2 id="XSS的发起条件"><a href="#XSS的发起条件" class="headerlink" title="XSS的发起条件"></a>XSS的发起条件</h2><ol>
<li>Web服务器没有对用户输入进行有效性验证或者验证强度不够 ，而又轻易地将它们返回到客户端</li>
<li>允许用户在表格或编辑框中输入不相关字符</li>
<li>存储并允许把用户输入显示在返回给终端的页面上，而没有去 除非法字符或者重新进行编码</li>
</ol>
<h2 id="XSS盗取cookie"><a href="#XSS盗取cookie" class="headerlink" title="XSS盗取cookie"></a>XSS盗取cookie</h2><ol>
<li>首先编写获取cokie的php脚本</li>
<li>向被攻击者服务器页面上注入一段JS代码，用于将被攻击者的cookie传送到我们的服务器。</li>
</ol>
<h2 id="XSS的防御"><a href="#XSS的防御" class="headerlink" title="XSS的防御"></a>XSS的防御</h2><h3 id="基于代理"><a href="#基于代理" class="headerlink" title="基于代理"></a>基于代理</h3><ol>
<li>分析浏览器和Web服务器之间的HTTP通信量</li>
<li>寻找HTML中的特殊字符</li>
<li>执行Web页面之前对它们进行编码</li>
</ol>
<h3 id="使用应用层防火墙"><a href="#使用应用层防火墙" class="headerlink" title="使用应用层防火墙"></a>使用应用层防火墙</h3><ol>
<li>分析HTML页面中可能导致敏感信息泄漏的超链接</li>
<li>对于使用不良请求的一系列链接进行停止操作</li>
</ol>
<h3 id="审计制度"><a href="#审计制度" class="headerlink" title="审计制度"></a>审计制度</h3><p>监视JavaScript代码的执行，并将操作与高级策略进行比较，以 检测恶意行为</p>
<h1 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h1><p>SQL注入：就是通过把SQL命令插入到Web表单提交或输入 域名或页面请求的查询字符串，最终达到欺骗服务器执行恶 意的SQL命令</p>
<h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><ol>
<li>web应用程序从表单中获取用户输入</li>
<li>用户提交的信息用于构建查询</li>
<li>SQL注入攻击涉及在用户输入中放置SQL语句。</li>
</ol>
<h2 id="万能语句-1-or-1"><a href="#万能语句-1-or-1" class="headerlink" title="万能语句 1 or 1"></a>万能语句 1 or 1</h2><h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><ol>
<li>使用预编译语句，绑定变量。</li>
<li>对用户提交的数据和输入参数进行严格过滤。</li>
<li>使用安全函数</li>
<li>摒弃动态SQL语句，改用存储过程来访问和操作数据。</li>
<li>最小权限原则：避免Web直接使用root</li>
</ol>
<h1 id="DoS-拒绝服务攻击"><a href="#DoS-拒绝服务攻击" class="headerlink" title="DoS 拒绝服务攻击"></a>DoS 拒绝服务攻击</h1><p>任何旨在 使计算机或系统不可用或无法执行基本功能的攻击。如TCP 泛滥攻击，DNS放大攻击。</p>
<h2 id="分布式拒绝服务攻击-DDoS"><a href="#分布式拒绝服务攻击-DDoS" class="headerlink" title="分布式拒绝服务攻击 DDoS"></a>分布式拒绝服务攻击 DDoS</h2><ol>
<li>利用控制的大量僵尸计算机同时攻击目标。使得传统DoS攻击不了的高性能服务器也变得不安全。</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计安导第8章</title>
    <url>/2020/01/20/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC8%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="密码学基础"><a href="#密码学基础" class="headerlink" title="密码学基础"></a>密码学基础</h1><h2 id="基本符号"><a href="#基本符号" class="headerlink" title="基本符号"></a>基本符号</h2><ol>
<li>密钥 K</li>
<li>加密算法 E<sub>K</sub>(P) = C</li>
<li>解密算法 D<sub>K</sub>(C)    = M</li>
</ol>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li>密文长度通常和明文长度相同</li>
<li>加密/解密是所有n位二进制序列构成的集合上的 (双射)置换函数。加密算法EK(P)和解密算法DK(C)必须是高效的。</li>
<li>对密文解密后可恢复出明文，即D<sub>K</sub>(E<sub>K</sub>(P))=P</li>
</ol>
<h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><p>加密和解密使用同一个密钥</p>
<h2 id="攻击者主要类型"><a href="#攻击者主要类型" class="headerlink" title="攻击者主要类型"></a>攻击者主要类型</h2><ol>
<li>唯密文攻击：攻击者收集一个或多个消息的密文。且这些消息都使用相同的密钥K加密。攻击者的目标是根据一个或多个密文来确定明文，或者找到密钥K。</li>
<li>已知明文攻击：攻击者收集一个或多个明文-密文对。且每个这样的对都使用相同的密钥K加密。攻击者目标是确定密钥K。</li>
<li>选择明文攻击: 攻击者可收集指定的明文对应的密文信息。且这些明文都使用相同的密钥K。 目的在于破解密钥K。</li>
<li>选择密文攻击：攻击者可收集指定的密文 对应的明文信息。且这些明文都使用相同的密钥K。 目的在于破解密钥K。</li>
<li>穷举攻击：穷举可能的密钥，直到能把密文转换称有意义的明文。需要了解明文结构且密钥不长。</li>
</ol>
<h2 id="英文文本的唯一解距离计算"><a href="#英文文本的唯一解距离计算" class="headerlink" title="英文文本的唯一解距离计算"></a>英文文本的唯一解距离计算</h2><p>已知英文文本的信息熵为1.25bits，共t个字符，每个字符由8位二进制数的ASCII码表示。</p>
<img src="/计算机安全导论_img/9.png">

<img src="/计算机安全导论_img/10.png">

<h2 id="替换密码"><a href="#替换密码" class="headerlink" title="替换密码"></a>替换密码</h2><p>每个字母用不同的独一无二的其他字符替代。存在26!个可能的替换密码。存在4.03×1026个可能的密文。</p>
<h3 id="主要弱点"><a href="#主要弱点" class="headerlink" title="主要弱点"></a>主要弱点</h3><p>他们不隐藏明文中不同字母的基本频率。</p>
<h3 id="多字母替换密码和替换盒"><a href="#多字母替换密码和替换盒" class="headerlink" title="多字母替换密码和替换盒"></a>多字母替换密码和替换盒</h3><ol>
<li><p>多字母替换密码：对字母组进行替换。由26<sup>2</sup> = 676种可能的组合。会产生676!个可能的密钥</p>
</li>
<li><p>问题 导致密钥太长，需要保存所有替换组合密码。</p>
</li>
<li><p>替换盒(S-盒)：一张二维表，交叉处为相应的替换。</p>
 <img src="/计算机安全导论_img/11.png">

</li>
</ol>
<h3 id="频率分析"><a href="#频率分析" class="headerlink" title="频率分析"></a>频率分析</h3><p>对字母频率的分析是针对替换密码的有效攻击手段</p>
<h3 id="一次一密"><a href="#一次一密" class="headerlink" title="一次一密"></a>一次一密</h3><p>绝对牢不可破的替换密码</p>
<ol>
<li>使用密钥块(k1, k2, . . . , kn)来加密长度为n的明文M，每个密钥ki都是均匀随机生成的。由于每次都是完全随机地选择移动量，在密文中字母表的每 个字母出现的概率几乎相同</li>
<li>弱点：<ol>
<li>密钥块的长度m必须和明文的 长度n相同</li>
<li>密钥不可以被重用。而事实是密钥很可能被用完，当重用密钥时，安全性会大大降低。</li>
</ol>
</li>
</ol>
<h2 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h2><p>每条消息被划分成一系列的块，基于这些数据块来进行加密或解密。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>明文和密文具有固定的长度b</li>
<li>长度为 n 的明文被划分为 m 个序列块 P[0], …, P[m-1]（n ≤ bm＜ n + b）</li>
</ol>
<h3 id="填充要求"><a href="#填充要求" class="headerlink" title="填充要求"></a>填充要求</h3><p>分组密码要求明文长度n应该为块长度b的倍数，所以最后一个块特殊。对最后一个数据块的填充必须是明确的（不能只是填充0）。要求</p>
<ol>
<li>当块大小和明文长度是8的倍数时，一种常用的填充方法（PKCS5） 是一组相同的字节，每个字节都表示填充的长度（以字节为单位）</li>
</ol>
<img src="/计算机安全导论_img/12.png"> 

<p>意思貌似是要填充9个字节，所以用9来填充。</p>
<h2 id="实际使用的分组密码"><a href="#实际使用的分组密码" class="headerlink" title="实际使用的分组密码"></a>实际使用的分组密码</h2><h3 id="AES-高级加密标准"><a href="#AES-高级加密标准" class="headerlink" title="AES 高级加密标准"></a>AES 高级加密标准</h3><ol>
<li>每组128位，所采用的密钥长度为128、192或者256 位，所得到的密码称为AES-128、AES-192和AES-256。</li>
<li>AES轮结构</li>
</ol>
<img src="/计算机安全导论_img/13.png"> 

<p>10轮异或之后得到密文。</p>
<ol>
<li>SubBytes步骤：S-盒替换步骤 </li>
<li>ShiftRows步骤：置换步骤 </li>
<li>MixColumns步骤：矩阵乘法（希尔密码）步骤</li>
<li>AddRoundKey步骤：使用从128位密钥派生的轮密钥的XOR步骤</li>
</ol>
<h3 id="数据加密标准（DES）"><a href="#数据加密标准（DES）" class="headerlink" title="数据加密标准（DES）"></a>数据加密标准（DES）</h3><h3 id="三重DES-（3DES）"><a href="#三重DES-（3DES）" class="headerlink" title="三重DES （3DES）"></a>三重DES （3DES）</h3><h2 id="分组密码的操作模式"><a href="#分组密码的操作模式" class="headerlink" title="分组密码的操作模式"></a>分组密码的操作模式</h2><h3 id="电子密码本模式-ECB"><a href="#电子密码本模式-ECB" class="headerlink" title="电子密码本模式     ECB"></a>电子密码本模式     ECB</h3><ol>
<li>明文块 P[i] 加密成密文块 C[i] = EK( P[i] )；密文块 C[i] 解密成明文块 M[i] = DK( C[i] )</li>
<li>优点 可以容忍分组丢失。因为解密i分组与i-1分组无关。</li>
<li>缺点<ol>
<li>如果加密算法是完全确定的，比如使用AES，那么每个明文都与唯一的密文相关联。对于很长的消息，ECB模式可能会解释分组流中出现的模式。</li>
<li>适用于短报文，如<strong>密钥和初始向量的加密</strong></li>
</ol>
</li>
</ol>
<h3 id="密码分组链接模式-CBC"><a href="#密码分组链接模式-CBC" class="headerlink" title="密码分组链接模式    CBC"></a>密码分组链接模式    CBC</h3><p>是最常用的模式之一</p>
<img src="/计算机安全导论_img/14.png"> 

<ol>
<li><p>加密 C[i] = EK(C[i-1] ⊕ P[i])    </p>
<p> C[-1] = V， 一个单独传输的随机加密数据块将作为初始化向量</p>
</li>
<li><p>解密 P[i] = C[i-1] ⊕DK(C[i])</p>
</li>
<li><p>优点</p>
<ol>
<li>没有在明文中泄露明文的模式</li>
<li>快速而简单</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>需要所有数据进行有序可靠的传输</li>
<li>不适用于允许丢包的应用，如音频流、视频流</li>
</ol>
</li>
</ol>
<h3 id="密码反馈模式-CFB"><a href="#密码反馈模式-CFB" class="headerlink" title="密码反馈模式 CFB"></a>密码反馈模式 CFB</h3><h3 id="输出反馈模式-OFB"><a href="#输出反馈模式-OFB" class="headerlink" title="输出反馈模式 OFB"></a>输出反馈模式 OFB</h3><h2 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h2><h3 id="密钥流"><a href="#密钥流" class="headerlink" title="密钥流"></a>密钥流</h3><p>是一组伪随机序列S = S[0], S[1], S[2], …… ；每次生成1位或者1个字节。</p>
<h3 id="流密码-1"><a href="#流密码-1" class="headerlink" title="流密码"></a>流密码</h3><p>密钥流和明文流进行对位异或操作 C[i] = S[i]⊕P[i]</p>
<h3 id="同步流密码"><a href="#同步流密码" class="headerlink" title="同步流密码"></a>同步流密码</h3><ol>
<li>密钥流的生成只依靠密钥K</li>
<li>如果明文是带有序列号的包，同步流密码可在不可靠信道下工作。</li>
</ol>
<h3 id="自同步流密码"><a href="#自同步流密码" class="headerlink" title="自同步流密码"></a>自同步流密码</h3><ol>
<li>使用密钥K和前q个密文来生成密钥流</li>
<li>在接收到q个密文后自动与密钥流生成器同步，如果数字被丢弃或添加到明文流中，更容易恢复。</li>
<li>自同步：因解码当前文字只依赖于固定个数的之前的密文字。所以仅有确定数量的明文字符不可被恢复。</li>
</ol>
<h3 id="RC4-流密码与密钥流生成器"><a href="#RC4-流密码与密钥流生成器" class="headerlink" title="RC4 流密码与密钥流生成器"></a>RC4 流密码与密钥流生成器</h3><ol>
<li>最多可以使用2048位的密钥</li>
<li>使用块大小为b的数据块</li>
<li>使用一个密钥对(K, t), K为密钥，计数器t是一个b位的值</li>
<li>密钥流由下列密文块连接而成: E<sub>K</sub>(t), E<sub>K</sub>(t+1), E<sub>K</sub>(t+2), ……</li>
</ol>
<h2 id="针对流密码的攻击"><a href="#针对流密码的攻击" class="headerlink" title="针对流密码的攻击"></a>针对流密码的攻击</h2><h3 id="重试攻击"><a href="#重试攻击" class="headerlink" title="重试攻击"></a>重试攻击</h3><p>如果密钥流被重用，那么攻击者可获得两个明文的异或值</p>
<h3 id="插入攻击"><a href="#插入攻击" class="headerlink" title="插入攻击"></a>插入攻击</h3><p>将由攻击者选定的字节插入到消息流中，并使用相同的密钥流进行加密</p>
<h1 id="公钥加密"><a href="#公钥加密" class="headerlink" title="公钥加密"></a>公钥加密</h1><h2 id="数论基础"><a href="#数论基础" class="headerlink" title="数论基础"></a>数论基础</h2><h3 id="素数-只能被1和他自身整除。"><a href="#素数-只能被1和他自身整除。" class="headerlink" title="素数 只能被1和他自身整除。"></a>素数 只能被1和他自身整除。</h3><ol>
<li>正整数n可以写成若干个素数的某次幂的乘积。如200=2<sup>3</sup>×5<sup>2</sup></li>
<li>算术基本定理：一个正整数的素数分解是唯一的</li>
</ol>
<h3 id="互质-两个数的最大公约数为1"><a href="#互质-两个数的最大公约数为1" class="headerlink" title="互质 两个数的最大公约数为1"></a>互质 两个数的最大公约数为1</h3><h3 id="辗转相除法-用于计算两个正整数的最大公约数"><a href="#辗转相除法-用于计算两个正整数的最大公约数" class="headerlink" title="辗转相除法 用于计算两个正整数的最大公约数"></a>辗转相除法 用于计算两个正整数的最大公约数</h3><ol>
<li><p>gcd(a, b) = gcd(b, a mod b)</p>
</li>
<li><p>算法最大迭代次数为1+2log max(a,b) </p>
<p> 复杂度 O(log min(a,b))</p>
<p> gcd(412,260)=4</p>
 <img src="/计算机安全导论_img/15.png">

</li>
</ol>
<h3 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h3><ol>
<li><p>xy mod n = 1, 则称 y 是 x 在 Zn的乘法逆元，记作 y = x - 1</p>
 <img src="/计算机安全导论_img/16.png">
</li>
<li><p>定理：Zn中的元素 x 有乘法逆元当且仅当 x 和 n 互素。</p>
</li>
<li><p>定理：a存在模b的乘法逆元的充要条件是gcd（a,b）= 1</p>
</li>
<li><p>定理：如果p是素数，那么Zp上的非0剩余类都有乘法逆元</p>
</li>
<li><p>定理：欧几里得算法可以用来计算 Zn 中元素 x 的乘法逆元或者确定该元素是否存在乘法逆元</p>
</li>
</ol>
<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><ol>
<li><p>若 p 是素数，x 是正整数且不能被 p 整除，则 x<sup>p-1</sup> mod p = 1</p>
 <img src="/计算机安全导论_img/17.png">
</li>
<li><p>若 p 是素数，x 是正整数且不能被 p 整除，x的乘法逆元是 xp<sup>p-2</sup> mod p</p>
</li>
</ol>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><ol>
<li>欧拉函数  Φ(n)指的是小于n且与n互素的正整数个数。Φ(1) = 1。 当p为素数时，Φ(p - 1) = p</li>
<li>欧拉定理：对任意互素的x和n，有 x<sup>Φ(n)</sup> mod n = 1</li>
</ol>
<img src="/计算机安全导论_img/18.png">

<h2 id="RSA-密码系统"><a href="#RSA-密码系统" class="headerlink" title="RSA 密码系统"></a>RSA 密码系统</h2><img src="/计算机安全导论_img/19.png">

<img src="/计算机安全导论_img/20.png">

<h3 id="RSA-安全性"><a href="#RSA-安全性" class="headerlink" title="RSA 安全性"></a>RSA 安全性</h3><p>基于给定e和n，找到d是困难的</p>
<h1 id="密码学哈希函数"><a href="#密码学哈希函数" class="headerlink" title="密码学哈希函数"></a>密码学哈希函数</h1><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><ol>
<li>哈希函数 指将可变长度的消息P 作为输入，产生固定 长度的Hash值 x = h(P)，称函数值h(P)为P的哈希值或消息摘要。</li>
<li>哈希表 是根据关键码值(Key value)而直接进行访问的数据结构。也就是说， 它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。</li>
<li>性质：<ol>
<li>单向性</li>
<li>抗弱碰撞性 想穷举出明文是困难的</li>
<li>抗强碰撞性 想伪造哈希签名是困难的</li>
<li>一个函数如果是抗强碰撞的，那么也同时是抗弱碰撞的，但反之则不 一定成立</li>
</ol>
</li>
</ol>
<h2 id="随机预言机"><a href="#随机预言机" class="headerlink" title="随机预言机"></a>随机预言机</h2><p>把随机预言机理解为<strong>完美</strong>的散列函数，具有</p>
<ol>
<li>一致性：对于相同的输入，其输出必然相同</li>
<li>可计算性：输出的计算可以在多项式时间内完成</li>
<li>均匀分布性：预言机的输出在取值空间内均匀分布，<strong>无碰撞</strong></li>
</ol>
<h2 id="生日攻击"><a href="#生日攻击" class="headerlink" title="生日攻击"></a>生日攻击</h2><p>暴力破解哈希，危害其抗碰撞性</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>随机产生消息序列X1，X2，X3，…</li>
<li>对于每个Xi计算Hash值 yi = h(Xi) 并且检测yi是否等于yj ( j &lt; i )</li>
<li>直至找到碰撞即停止</li>
</ol>
<h3 id="概率分析"><a href="#概率分析" class="headerlink" title="概率分析"></a>概率分析</h3><ol>
<li>对于b位的Hash函数，则有2<sup>b</sup>个Hash值数目</li>
<li>攻击者 生成的第 i 个消息与前面 i-1 个消息中任意一个产生冲突的概率为 1 - (i - 1)/m</li>
<li>在k轮的失败概率(即攻击者在生成 k个消息后没有找到冲突的概率)为Fk = (1 - 1/m) (1 - 2/m) (1 - 3/m) … (1 - (k - 1)/m)</li>
<li>用1- x ≈ e<sup>-x</sup>逼近,Fk ≈ e <sup>-(1/m + 2/m + 3/m + … + (k - 1)/m) </sup>= e <sup>-k ( k-1) / 2m</sup></li>
<li>当Fk = 1/2时，攻击成功/失败的概率为50%，即e <sup>-k ( k-1) / 2m</sup> = 1/2</li>
<li>进一步得到k=1.17&radic;m , 其中&radic;m 的位数是b/2，m位数的一半</li>
<li>所以通常根据输出大小的一半来考虑加密散列函数的安全, 比如256位抗冲突Hash函数的安全是128位。</li>
</ol>
<h2 id="MD5消息签名算法"><a href="#MD5消息签名算法" class="headerlink" title="MD5消息签名算法"></a>MD5消息签名算法</h2><p>对于任意两个密文Ｐ和Ｑ，通过250次MD5哈希运算可以找出两个前 缀S1和S2使得 P||S1 和 Q||S2 发生碰撞.</p>
<h1 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h1><h2 id="消息认证码-MAC"><a href="#消息认证码-MAC" class="headerlink" title="消息认证码 MAC"></a>消息认证码 MAC</h2><ol>
<li>发送方计算MAC值 c = h(K, M) 并且将c连同消息M一起传输。接收方从收到的消息中重新计算MAC值并将其与接收到的MAC进行比较。</li>
<li>密钥可以以单独加密并签名的方式发送</li>
</ol>
<h2 id="基于Hash函数的MAC-HMAC"><a href="#基于Hash函数的MAC-HMAC" class="headerlink" title="基于Hash函数的MAC HMAC"></a>基于Hash函数的MAC HMAC</h2><ol>
<li>密码学Hash函数不能直接用作消息认证函数。因为Hash函数内部迭代结构，所以标准Hash并不安全。</li>
<li>HMAC构造方法<ol>
<li>h(K⊕A||h(K⊕B||M)) A和B为常数</li>
</ol>
</li>
</ol>
<h2 id="安全信道"><a href="#安全信道" class="headerlink" title="安全信道"></a>安全信道</h2><p>确保不安全信道所传输的消息的完整性和机密性。包括</p>
<ol>
<li>签名配合加密：对(message, signature)加密后再进行传输</li>
<li>MAC配合加密：对(message, MAC)加密后再进行传输。<ol>
<li>比签名配合加密的方法更加高效：计算消息的MAC比对消息进行签名 和验证更快，且开销更低。</li>
</ol>
</li>
</ol>
<h2 id="Hash链"><a href="#Hash链" class="headerlink" title="Hash链"></a>Hash链</h2><img src="/计算机安全导论_img/21.png">

<ol>
<li><p>计算Hash链</p>
<p> xn = r </p>
<p> xi = h(x<sub>i+1</sub>) for i = n-1, …, 1</p>
</li>
<li><p>验证Hash链</p>
<p> xn+1 = 0</p>
<p> xi = h(Pi || x<sub>i+1</sub>) ) for i = n, …, 1</p>
</li>
</ol>
<h2 id="Hash-树"><a href="#Hash-树" class="headerlink" title="Hash 树"></a>Hash 树</h2><p>是一种树 形数据结构，每个叶节点均以 数据块的Hash作为标签，而 除了叶节点以外的节点则以其 子节点标签的Hash作为标签</p>
<h2 id="哈希认证树"><a href="#哈希认证树" class="headerlink" title="哈希认证树"></a>哈希认证树</h2><img src="/计算机安全导论_img/22.png">

<ol>
<li>g = h(h(a, h(x3, x4)), d)</li>
<li>proof(x4) = [(x3, L), (a, L), (d, R)]</li>
<li>具有对数级的存储和计算复杂度</li>
</ol>
<h2 id="允许丢包的数据流检验"><a href="#允许丢包的数据流检验" class="headerlink" title="允许丢包的数据流检验"></a>允许丢包的数据流检验</h2><img src="/计算机安全导论_img/23.png">]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计安导第9章</title>
    <url>/2020/01/20/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC9%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="策略、模型与信任"><a href="#策略、模型与信任" class="headerlink" title="策略、模型与信任"></a>策略、模型与信任</h1><h2 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h2><h3 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h3><p>是与系统交互的代理</p>
<h3 id="客体"><a href="#客体" class="headerlink" title="客体"></a>客体</h3><p>是安全策略要保护和管理的信息与计算资源</p>
<h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p>主体对客体可能(或不可能)执行的操作</p>
<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>主体、操作与客体之间的映射，权限明确规定允许或禁止哪些操作</p>
<h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p>策略中包含的特定安全特性或规则，以 帮助实现特定的安全目标，如保密性、完整性、可用性或匿 名性。</p>
<h2 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h2><p>是一种抽象的、为管理员指定安全策略提供 概念语言。</p>
<p>通常定义了</p>
<ol>
<li>组织成员所拥有的访问或修改权限的层次结构</li>
</ol>
<h2 id="自主访问控制-DAC"><a href="#自主访问控制-DAC" class="headerlink" title="自主访问控制 DAC"></a>自主访问控制 DAC</h2><p>指的是赋予用户能力确定文件访 问权限的一种方案。</p>
<ol>
<li>允许用户根据用户和组设置访问控制措施。</li>
<li>允许用户将资源特权授予同一系统上的其他用户。</li>
</ol>
<h2 id="强制访问控制-MAC"><a href="#强制访问控制-MAC" class="headerlink" title="强制访问控制 MAC"></a>强制访问控制 MAC</h2><ol>
<li>不允许用户定义文件的权限.</li>
<li>而是由中央策略管理员制定安全策略。</li>
<li>每个安全规则都由主体、客体和一系列的权限组成。其中主体是获得权限的的一方，客体是被访问的资源。</li>
</ol>
<h2 id="信任管理系统"><a href="#信任管理系统" class="headerlink" title="信任管理系统"></a>信任管理系统</h2><h2 id="组成包括"><a href="#组成包括" class="headerlink" title="组成包括"></a>组成包括</h2><ol>
<li><strong>策略语言</strong></li>
<li><strong>一致性检查器</strong></li>
<li>策略规则由策略语言指定，并由一致性检查器执行</li>
</ol>
<h2 id="规则包括"><a href="#规则包括" class="headerlink" title="规则包括"></a>规则包括</h2><ol>
<li>操作 与系统安全相关的结果</li>
<li>主题 可以在系统 上执行操作的用户、进程或其他实体</li>
<li>策略 就是制定的规 则，制定赋予主体哪些权限，能执行那些操作</li>
<li>凭证 数字签名 的文件，将主体身份与允许的行 为绑定，包括允许主体将权限委 托给其他主体的权限</li>
</ol>
<h1 id="访问控制模型"><a href="#访问控制模型" class="headerlink" title="访问控制模型"></a>访问控制模型</h1><h2 id="Bell-La-Padula模型"><a href="#Bell-La-Padula模型" class="headerlink" title="Bell-La Padula模型"></a>Bell-La Padula模型</h2><p>强制访问控制模型，保护机密性</p>
<h3 id="全序和偏序"><a href="#全序和偏序" class="headerlink" title="全序和偏序"></a>全序和偏序</h3><ol>
<li>全序：自反，反对称，传递，完全性(如果x和y在U中，则x ≤ y 或 y ≤ x)</li>
<li>偏序：去掉完全性</li>
</ol>
<h3 id="BLP-工作原理"><a href="#BLP-工作原理" class="headerlink" title="BLP 工作原理"></a>BLP 工作原理</h3><ol>
<li>原则：信息只能从低安全级别流向高安全级别。</li>
<li>安全级别是偏序的</li>
<li>每个对象x被分配到一个安全级别L(X)。同样，每个用户u被分配到 安全级别L(U)。用户对象的访问受以下两条规则控制：<ol>
<li>简单安全性质：只有满足L(x) ≼ L(u)，用户u才能读取对象x：即<strong>不可向上读</strong></li>
<li>性质只有满足L(u) ≼ L(x)，用户u才能写入（创建、编 辑或追加）对象x：即<strong>不可向下写</strong></li>
</ol>
</li>
</ol>
<h2 id="Biba模型"><a href="#Biba模型" class="headerlink" title="Biba模型"></a>Biba模型</h2><ol>
<li>Biba模型的完整性级别表明对象和用户的可信度或准确度。</li>
<li>Biba 不允许从下一级阅读，也不允许写到上层。</li>
</ol>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>如果让I(u)表示用户u的完整性级别，I(x)表示对象x的完整性级别， 则Biba模型中有以下规则：</p>
<ol>
<li>原则：信息只能从较高的完整性级别下降 到较低的完整性级别</li>
<li>用户u只能在I(u) ≼ I(x)情况下读取对象x：</li>
<li>用户u只能在I(x) ≼ I(u)情况下才能写入(创建、编辑或追加)一个对象x</li>
</ol>
<h2 id="低水印模型"><a href="#低水印模型" class="headerlink" title="低水印模型"></a>低水印模型</h2><p>扩展的Biba模型，放宽了不可想下读的限制。</p>
<ol>
<li>原则 具有较高完整性级别的用户可以读取完整性级别较低 的对象。</li>
<li>在这样的读取之后，对执行读取的用户进行降级，使其完整性级别 与所读取对象的完整性级别相匹配。</li>
</ol>
<h2 id="克拉克-威尔逊模型"><a href="#克拉克-威尔逊模型" class="headerlink" title="克拉克-威尔逊模型"></a>克拉克-威尔逊模型</h2><p>用于处理执行事务的系统。关键组件包括</p>
<ol>
<li>完整性约束：表明为了保证系统的状态有效，各对象之间必须满足的关系。</li>
<li>认证方法：验证事务给定的完整性约束。一旦认证了事务的程序，每 次执行事务时，则不必再次进行完整性约束验证。</li>
<li>职责分离原则：防止执行事务的用户验证事务。通常，每个事务都被 分配给可以分别验证和执行事务的不相交的用户集。</li>
</ol>
<h2 id="中国墙模型"><a href="#中国墙模型" class="headerlink" title="中国墙模型"></a>中国墙模型</h2><p>被设计用于商业领域， 以消除利益冲突的可能性。</p>
<ol>
<li>讲资源分组为利益冲突类</li>
<li>每个用户只能从每个利益冲突类访问一个资源。</li>
</ol>
<h2 id="基于角色的访问控制-RBAC"><a href="#基于角色的访问控制-RBAC" class="headerlink" title="基于角色的访问控制 RBAC"></a>基于角色的访问控制 RBAC</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>便于组织授权管理</li>
<li>支持继承</li>
<li>便于实现最小特权原则</li>
<li>可实现指责隔离原则</li>
<li>支持客体抽象</li>
<li>策略中立，通过不同配置能够实现特殊策略</li>
</ol>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ol>
<li>用户：需要访问组织的资源以执行任务的实体</li>
<li>角色：组织中具有类似功能和职责的用户的集合</li>
<li>权限：权限描述了允许访问资源的方法。</li>
<li>会话：由为执行特定任务而激活用户角色的子集组成。</li>
</ol>
<h3 id="分级RBAC"><a href="#分级RBAC" class="headerlink" title="分级RBAC"></a>分级RBAC</h3><ol>
<li>定义：色R1继承（inherits）R2，如果R1包含R2的所有权限，R2包括 R1的所有用户，可以表示为R1 ≽ R2。称R1为R2的上一层。</li>
</ol>
<h1 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p>渗透测试：从攻击者(黑客)的角度测试系统和体系结构的安全性，在 固定时间内必须获得的具有预定目标的“模拟攻击”</p>
<ol>
<li>组我欸其他安全措施的补充</li>
<li>花销大</li>
</ol>
</li>
<li><p>流程：</p>
<ol>
<li>收集信息<ol>
<li>IP地址信息</li>
<li>个人信息</li>
</ol>
</li>
<li>扫描IP：给定一组IP地址，确定每个服务和操作系统都在运行</li>
<li>识别系统：通过扫描开放电脑的网络连接端，确定哪些服务运行在哪些连接端，并且推断计算机运行哪个操作系统</li>
<li>识别易受攻击的服务：给定特定的IP地址和端口，尝试获得对机器 的访问权限。报告此目标的所有已知漏洞</li>
<li>利用漏洞</li>
</ol>
</li>
</ol>
<h1 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h1><ol>
<li>Kerberos：基于可信第三方（Trusted Third Party， TTP）的身份认证协议；</li>
<li>旨在对整个网络进行集中身份验证，而不是在每个用户计算机上存储敏感的身份验证信息。</li>
</ol>
<h2 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h2><ol>
<li><p>在身份验证过程中，客户端收到两个票据</p>
<ol>
<li>票据授予票据（TGT）：用户和会话密钥的全局标识符。</li>
<li>服务票据（service ticket）：对用户进行身份验证，确定用户能否 使用特殊服务。</li>
<li>票据都有时间戳，用于标明数据的有效期限</li>
</ol>
</li>
<li><p>密钥分发中心 KDC 组成</p>
<p> 为了实现安全的身份验证</p>
<ol>
<li>身份验证服务器(AS):用于执行用户身份验证。维护存储用户和服务密钥的数据库。对用户提供的密码执行单向散列来生成用户的密钥。</li>
<li>票据授予服务器(TGS):用于向用户授予票据</li>
</ol>
</li>
</ol>
<h3 id="身份认证过程"><a href="#身份认证过程" class="headerlink" title="身份认证过程"></a>身份认证过程</h3><p>概括的说</p>
<ol>
<li>客户端与AS互相进行身份验证</li>
<li>客户端与TGS互相进行身份验证</li>
<li>客户端与服务S互相进行身份验证，为客户端提供服务</li>
</ol>
<p>具体</p>
<ol>
<li><p>用户输入的密码经过哈希散列形成客户端密钥Kc</p>
</li>
<li><p>客户端与AS联系，AS执行</p>
<ol>
<li><p>使用客户端密钥Kc加密客户端-TGS的会话密钥K<sub>CT</sub></p>
</li>
<li><p>使用TGS的密钥K<sub>T</sub>加密票据授予票据TGT。TGT中包含K<sub>CT</sub>和有效期。</p>
</li>
<li><p>客户端使用Kc解密TGS会话密钥K<sub>CT</sub>。之后，客户端向TGS发送如下两个消息：</p>
<ol>
<li>TGT 和 所请求服务名称S</li>
<li>验证令牌 有用户ID和时间戳组成，使用客户端TGS会话密钥K<sub>CT</sub>进行加密</li>
</ol>
</li>
<li><p>.TGS使KT解密TGS，从而得到客户端TGS的会话密钥K<sub>CT</sub>和TGT的 有效期。在有效期之内，TGS使用密钥K<sub>CT</sub>解密身份验证令牌，向客 户端发送如下两个消息：</p>
<ol>
<li>使用K<sub>CT</sub>加密的新的客户端-服务器会话密K<sub>CS</sub>。 </li>
<li>使用具体服务的密钥KS加密客户端-服务器票据（client-server ticket），其中 TGS已知密钥KS 。票据包含客户端ID、网络地址、有效期、密钥K<sub>CS</sub>。</li>
</ol>
</li>
<li><p>在对客户端-服务器会话密钥K<sub>CS</sub>解密后，为了使服务对客户端进行身份验证，客户端发送以下两个消息： </p>
<ol>
<li>在上个步骤中，TGS发送的客户端-服务器的票据。 </li>
<li>使用K<sub>CS</sub>加密的客户端ID和时间戳。</li>
</ol>
</li>
<li><p>服务使用自己的密钥KS解密客户端-服务器的票据，得到客户端-服 务器的会话密钥K<sub>CS</sub> 。使用K<sub>CS</sub>解密客户端ID和时间戳。最后，为了向客户端证码自己的身份，它使用时间戳加1，并用K<sub>CS</sub>重新加密送回客户端。 </p>
</li>
<li><p>客户端使用KCS解密并验证这个响应，如果验证成功，就可以开始 客户端-服务器的会话了。</p>
</li>
<li><p>票据有效期内，客户端为了访问多个服务，可以一直重复3-7步。</p>
</li>
</ol>
</li>
</ol>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol>
<li>分布式体系结构，可以在不安全的网络中使用。</li>
<li>由于每次传输都使用适当的密钥进行加密，攻击者在不能破解密 钥或底层的加密算法的情况下，无法伪造有效的票据来获得对未 授权服务的访问。</li>
<li>可防止重放攻击，因为不接受未授权方重传的消息。</li>
<li>使用对称加密，所以比较高效</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>存在单点故障问题：密钥分发中心不可用</li>
<li>如果KDC被破坏，在每个客户端和服务器的身法验证信息都被泄漏</li>
<li>需要所有参与方都有同步的时钟</li>
</ol>
<h1 id="安全存储"><a href="#安全存储" class="headerlink" title="安全存储"></a>安全存储</h1><h2 id="安全保护措施"><a href="#安全保护措施" class="headerlink" title="安全保护措施"></a>安全保护措施</h2><ol>
<li>保存好U盘手机</li>
<li>防范窃取数据的恶意软件</li>
<li>合理处置废旧设备</li>
<li>备份</li>
<li>云存储</li>
</ol>
<h2 id="文件密码保护"><a href="#文件密码保护" class="headerlink" title="文件密码保护"></a>文件密码保护</h2><p>保护信息的一种方法就是对文件进行加密，在密码算法没有在理论破解或密钥泄露的情况下，即使文件被盗，也不用担心信息会泄露。</p>
<ol>
<li><p>常见密码算法</p>
 <img src="/计算机安全导论_img/25.png">


</li>
</ol>
<h3 id="加密文件系统-EFS"><a href="#加密文件系统-EFS" class="headerlink" title="加密文件系统 EFS"></a>加密文件系统 EFS</h3><ol>
<li><p>特点</p>
<ol>
<li>自动加密解密</li>
<li>保护文件内容，而不保护文件名和其他元数据</li>
<li>支持共享加密文件</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>只保护本地文件系统，所以传送到其他文件系统会被破解</li>
<li>临时文件不受保护</li>
<li>密钥管理很麻烦</li>
</ol>
</li>
<li><p>加密技术：同时使用对称和非对称加密</p>
 <img src="/计算机安全导论_img/26.png">

<ol>
<li>加密时首先使用AES(对称)单独的加密密钥FEK加密每个文件</li>
<li>然后使用FEK加密数据</li>
<li>再用用户的RSA(非对称)的公钥加密FEK，并保存文件的元数据。</li>
<li>解密时首先用用户的私钥解密FEK</li>
<li>然后再用FEK解密数据</li>
<li>注：每个用户对应一个经过公钥加密的FEK</li>
</ol>
</li>
</ol>
<h2 id="磁盘加密"><a href="#磁盘加密" class="headerlink" title="磁盘加密"></a>磁盘加密</h2><h3 id="TrueCrypt"><a href="#TrueCrypt" class="headerlink" title="TrueCrypt"></a>TrueCrypt</h3><ol>
<li>以分区为基础</li>
<li>所有加密数据都是经过AES等加密算法，难以破解</li>
<li>加密过程自动透明</li>
<li>提供两级方案</li>
</ol>
<h3 id="BitLocker"><a href="#BitLocker" class="headerlink" title="BitLocker"></a>BitLocker</h3><ol>
<li>使用AES对扇区进行加密</li>
<li>使用NTFS格式的卷</li>
<li>可以通过冷启动攻击：属于一种边信道攻击方法，可 以物理接触到计算机的攻击者能够运用这种攻击手段 在冷启动或硬盘重启之后，比如计算机没经历正常的 关机过程就突然重启时，从计算机的内存(RAM)中获 取加密密钥、口令和其他数据。断电后内存中的数据 能维持几十秒或数分钟，但通过液氮或压缩空气冷冻 ，这一数据衰减过程可被攻击者拉长至数小时之久。</li>
</ol>
<h2 id="可信平台模块-TPM"><a href="#可信平台模块-TPM" class="headerlink" title="可信平台模块 TPM"></a>可信平台模块 TPM</h2><p>是设计安装在主板上的芯片 ，作为安全密码处理器，它能安全地生成和存储密 钥。在生产时，将一个唯一地RSA私钥铸入到每一 个TPM芯片中。TPM的设计是防篡改的，所以，能 进行物理访问的攻击者也很难恢复这个密钥。</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计安导第10章</title>
    <url>/2020/01/20/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC10%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="数据库安全"><a href="#数据库安全" class="headerlink" title="数据库安全"></a>数据库安全</h1><h2 id="两阶段协议–实现完整性和可用性"><a href="#两阶段协议–实现完整性和可用性" class="headerlink" title="两阶段协议–实现完整性和可用性"></a>两阶段协议–实现完整性和可用性</h2><ol>
<li>第一阶段是请求阶段：<ol>
<li>该阶段，确定所要修改的部分，并标记。</li>
<li>结果是成功或终止。在成功时，每个修改请求都是可 用的，标记被修改；在中止时，由于别人早已对其进行了标记，或者 由于网络或系统出现了故障，所以不能标记所有需要修改的部分。</li>
<li>如果第一阶段被中止，则重置所有修改的请求，这样做是完全可行 的，因为并未进行任何永久性的修改。如果第一阶段成功完成，则协议继续第二个阶段。</li>
</ol>
</li>
<li>第二阶段是提交阶段<ol>
<li>在这个阶段，对于其他 修改而言，数据库是锁定的，只执行在请求阶段确定的修改序列。</li>
<li>如果更新成功完成，则清除所有确定请求修改的标志，并释放对数据库的锁定。</li>
<li>如果更新操作失败，则回滚，使数据库回到完成第一 阶段后的状态。</li>
</ol>
</li>
</ol>
<h2 id="数据库访问控制"><a href="#数据库访问控制" class="headerlink" title="数据库访问控制"></a>数据库访问控制</h2><ol>
<li><p><strong>最小特权原则</strong>：实现适当的访问控制应遵 循最小特权原则，使每个用户都拥有完成自己任务所必需的权限，但 除此之外，不再拥有其他的权限</p>
</li>
<li><p><strong>特权分离原则</strong>：实现适当的访问控 制还应遵循特权分离原则，以便不同的用户具有不同的权限，这取决 于他们需要执行的不同任务</p>
</li>
<li><p>数据库允许SQL实现权限委托</p>
</li>
<li><p>权限委托：除了能向其他用户授予具体的权限外，表的所有者还允许其他用户来授予 这些表的权限，这称为策略授权委托</p>
</li>
<li><p>权限撤销：级联撤销</p>
</li>
</ol>
<h2 id="敏感信息"><a href="#敏感信息" class="headerlink" title="敏感信息"></a>敏感信息</h2><p>1.要保护用户因素，满足机密性要求<br>2. 方法：使用加密，存储密文。授权用户直到解密密钥，但不能将解密密钥存储在数据库中。<br>3. 隐私保护：如果数据库是公开的，比如说是出于研究的目的，则应删除姓名、地址、 社会安全码、员工人数和学生人数等身份信息，或改用掩码值 ，从而不提供任何身份信息。</p>
<h2 id="推理攻击"><a href="#推理攻击" class="headerlink" title="推理攻击"></a>推理攻击</h2><ol>
<li><p>推理攻击：即使删除或屏蔽掉身份信息，攻击者仍能将其他的信息与数据库结合，得到底层的数据。</p>
</li>
<li><p>推理攻击的防御：</p>
<ol>
<li><p>单元抑制：在使用这种技术时，会删除数据库 中的一些单元，在公开版本中只留下空白。</p>
</li>
<li><p>推广：在使用这种技术时，公开数据库中的一些 值被更常用的值所替代。</p>
</li>
<li><p>加噪：在使用这种技术时，在公开数据库中添加 了随机值，使具有相同属性的所有记录的平均噪声为零。</p>
<img src="/计算机安全导论_img/27.png">

</li>
</ol>
</li>
</ol>
<h1 id="垃圾邮件和网络犯罪"><a href="#垃圾邮件和网络犯罪" class="headerlink" title="垃圾邮件和网络犯罪"></a>垃圾邮件和网络犯罪</h1><h2 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h2><ol>
<li>使用25端口建立TCP连接</li>
<li>客户端向服务器发送命令，服务器确认或通知错误</li>
<li><strong>问题</strong> <ol>
<li>发件人未经过身份验证 </li>
<li>消息和消息头使用明文传输 </li>
<li>消息和消息头完整性没有得到保护</li>
</ol>
</li>
</ol>
<h2 id="垃圾邮件"><a href="#垃圾邮件" class="headerlink" title="垃圾邮件"></a>垃圾邮件</h2><ol>
<li>垃圾邮件：不清自来的批量电子邮件</li>
</ol>
<h2 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h2><img src="/计算机安全导论_img/28.png">

<h2 id="灰名单"><a href="#灰名单" class="headerlink" title="灰名单"></a>灰名单</h2><ol>
<li>灰名单：是一种垃圾邮件过滤技术，接收邮件服务器拒绝来自未知发 件人的邮件。当接收来自未知发件人的邮件时，接收服务器会发送一 个“临时拒绝”消息给发送方，并记录相应的信息。</li>
<li>维护一个可信发件服务器的数据库</li>
<li>简单易行高效</li>
</ol>
<h2 id="发件人ID和发件人策略框架"><a href="#发件人ID和发件人策略框架" class="headerlink" title="发件人ID和发件人策略框架"></a>发件人ID和发件人策略框架</h2><ol>
<li>发件人策略框架(SPF)可对发件人的发送邮 件代理进行身份验证，其中不使用加密 技术。接收方MTA会检查发送方MTA的IP是否在发件人域的授权IP 地址列表中。</li>
</ol>
<h2 id="发件人的MTA身份验证：DKIM"><a href="#发件人的MTA身份验证：DKIM" class="headerlink" title="发件人的MTA身份验证：DKIM"></a>发件人的MTA身份验证：DKIM</h2><ol>
<li>域密钥标识邮件DKIM：是一种用于验证发送邮件传输代理的方法</li>
<li>签名实体(通常是发件人的MTA) 向消息中增加签名， 表明消息的签名实体所在的域</li>
<li>公钥存储在DNS的文本记录中</li>
</ol>
<h2 id="SPF-vs-DKIM"><a href="#SPF-vs-DKIM" class="headerlink" title="SPF vs DKIM"></a>SPF vs DKIM</h2><img src="/计算机安全导论_img/29.png">

<h2 id="网络犯罪"><a href="#网络犯罪" class="headerlink" title="网络犯罪"></a>网络犯罪</h2><ol>
<li>网络犯罪：是使用计算机、网络或硬件设备犯下的任何罪行。 计算机或 设备可以是犯罪的代理人，犯罪的促进者或犯罪的目标。 犯罪可以 单独在计算机上进行，也可以在其他地方进行</li>
</ol>
<h2 id="信用卡"><a href="#信用卡" class="headerlink" title="信用卡"></a>信用卡</h2><ol>
<li><p>特点</p>
<ol>
<li>支持保密</li>
<li>可与多个商家共享</li>
<li>经常被不安全的传送</li>
<li>熵值较低</li>
</ol>
</li>
<li><p>优点：简单易行</p>
</li>
<li><p>缺点：易发生欺诈</p>
</li>
<li><p>防范：</p>
<ol>
<li>一次性信用卡号码</li>
<li>监控交易</li>
<li>交易时启动密码输入</li>
</ol>
</li>
</ol>
<h2 id="常见银行欺诈"><a href="#常见银行欺诈" class="headerlink" title="常见银行欺诈"></a>常见银行欺诈</h2><ol>
<li>伪造支票</li>
<li>电子汇款</li>
<li>创建恶意账户</li>
<li>多重身份认证</li>
<li>账户所有权验证</li>
<li>账户限制</li>
<li>监控银行交易</li>
<li>取消网银</li>
</ol>
<h1 id="支付系统"><a href="#支付系统" class="headerlink" title="支付系统"></a>支付系统</h1><h2 id="电子支付方案"><a href="#电子支付方案" class="headerlink" title="电子支付方案"></a>电子支付方案</h2><ol>
<li>是一种多方协议</li>
<li>目标：<ol>
<li>完整性：电子货币不能伪造或复制；合法交易能够兑现</li>
<li>问责制：交易后不可否认</li>
<li>隐私</li>
</ol>
</li>
</ol>
<h2 id="私密支付方案"><a href="#私密支付方案" class="headerlink" title="私密支付方案"></a>私密支付方案</h2><h3 id="盲签名"><a href="#盲签名" class="headerlink" title="盲签名"></a>盲签名</h3><ol>
<li><p>允许签名者在不知道消息本身的情况下对消息进行签名</p>
</li>
<li><p>基本过程</p>
<ol>
<li>银行对客户提取的货币进行盲签名 </li>
<li>商家验证签名并存入货币 </li>
<li>银行无法将货币与客户关联起来</li>
</ol>
</li>
<li><p>RSA 盲签名</p>
 <img src="/计算机安全导论_img/30.png">

 <img src="/计算机安全导论_img/31.png"></li>
<li><p>对钱币进行盲签名</p>
 <img src="/计算机安全导论_img/32.png">

</li>
</ol>
<h2 id="防止双重支付"><a href="#防止双重支付" class="headerlink" title="防止双重支付"></a>防止双重支付</h2><ol>
<li>联机系统：在支付过程中，银行保持在线，实时撤销已使用的钱币</li>
<li>离线系统：<ol>
<li>每个提款的钱币都包含客户身份的加密信息</li>
<li>每个存款的钱币都包含商家身份的加密信息</li>
<li>双重支付将导致欺骗者的身份被披露出来</li>
</ol>
</li>
</ol>
<h2 id="秘密分享"><a href="#秘密分享" class="headerlink" title="秘密分享"></a>秘密分享</h2><p>步骤</p>
<ol>
<li>一个秘密字符串 x 可以被划分为以下的随机值 y 和 z。选择一个随机数 y ；z = y⊕x</li>
<li>通过x = y⊕z重构字符串x</li>
<li>其中y和z都是随机值，成为x的秘密份额，任一秘密份额都不会揭示关于秘密值 x 的任何信息</li>
</ol>
<h2 id="钱币–保护匿名性"><a href="#钱币–保护匿名性" class="headerlink" title="钱币–保护匿名性"></a>钱币–保护匿名性</h2><ol>
<li>给定一个秘密值x和关于x的承诺(a,b)</li>
<li>a=h(y) b=h(z) y,z是x的秘密份额</li>
</ol>
<h2 id="取款"><a href="#取款" class="headerlink" title="取款"></a>取款</h2><ol>
<li>客户生成并向银行提交 k 个钱币 </li>
<li>银行随机选择 k-1 枚钱币 </li>
<li>银行要求客户向其披露所选定的 k-1 个钱币的承诺的秘密份额 </li>
<li>银行在剩余的硬币上创建一个盲签名 </li>
<li>银行签名的钱币是有效的概率是 1 - 1/k</li>
</ol>
<h2 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h2><ol>
<li><p>客户向商家提交钱币 {x, [(a1, b2) , … , (an, bn)]} </p>
</li>
<li><p>商家验证钱币上的签名 </p>
</li>
<li><p>商家发送给客户一个随机的二进制向量 s1, … , sn, 称为选择器。</p>
</li>
<li><p>客户向商家揭示由选择器所选定的秘密份额，即客户向商家发送 一组字符串 P1, … , Pn </p>
<p> h(Pi) = ai if si = 0 </p>
<p> h(Pi) = bi if si= 1</p>
</li>
</ol>
<h2 id="存款及其安全性分析"><a href="#存款及其安全性分析" class="headerlink" title="存款及其安全性分析"></a>存款及其安全性分析</h2><ol>
<li><p>存款</p>
<ol>
<li>商人将钱币和字符串 P1, … , Pn提交给银行进行存款 </li>
<li>银行验证签名并且记录钱币和相应字符串的对应关系</li>
</ol>
</li>
<li><p>安全性分析</p>
<ol>
<li>两个商家提供的选择器相同的概率是 1/2<sup>n</sup> </li>
<li>因此，如果客户将1个钱币进行双重支付，那么银行发现该客户 身份的概率为 1/2<sup>n</sup>  </li>
<li>客户想要在不被银行发现的情况进行双重支付的唯一办法是找到 一个Hash函数的碰撞。</li>
</ol>
</li>
</ol>
<h1 id="数字版权管理"><a href="#数字版权管理" class="headerlink" title="数字版权管理"></a>数字版权管理</h1><ol>
<li>数字版权管理：是指能限制用户 使用数字内容的做法，常用于数字媒体，如DVD、下载的音乐和 许可的软件</li>
</ol>
<h2 id="复制保护方法"><a href="#复制保护方法" class="headerlink" title="复制保护方法"></a>复制保护方法</h2><ol>
<li>加密狗</li>
<li>产品密钥</li>
<li>手机激活</li>
</ol>
<h2 id="用于媒体文件的DRM方案"><a href="#用于媒体文件的DRM方案" class="headerlink" title="用于媒体文件的DRM方案"></a>用于媒体文件的DRM方案</h2><p>步骤</p>
<ol>
<li>媒体服务器向播放器发送用文件密钥加密的媒体文件和用播放器密钥加密的文件密钥</li>
<li>播放器先用播放器密 钥解密文件密钥，然 后使用文件密钥解密 媒体文件</li>
</ol>
<h2 id="叛徒识别"><a href="#叛徒识别" class="headerlink" title="叛徒识别"></a>叛徒识别</h2><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA_img/33.png" alt=""></p>
<h2 id="逻辑密钥对"><a href="#逻辑密钥对" class="headerlink" title="逻辑密钥对"></a>逻辑密钥对</h2><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA_img/34.png" alt=""></p>
<ol>
<li>是平衡二叉树，树的每个节点都与一个对称加密密钥相关联 </li>
<li>将设备与叶子节点关联，每个设备上存储着从叶子到根路径上的所有密钥</li>
<li>用节点 v 的密钥加密的内容可以被 v 的子树中的所有设备解密</li>
<li>撤销设备：如果设备需要被撤销，则必须更改此设备已知的密钥，并分发新的密钥。新密钥的分发可以通过广播对数级数量的加密消息来完成</li>
</ol>
<h2 id="加密广播"><a href="#加密广播" class="headerlink" title="加密广播"></a>加密广播</h2><ol>
<li>广播之前，每个内容都用单一的对称密钥进行加密。被授权产看内容项的订阅者应该拥有解密该项的密钥</li>
<li>每个节点的密钥可以被用来计算子孙节点的密钥</li>
<li>存在密钥分配问题</li>
</ol>
<h2 id="可信设备"><a href="#可信设备" class="headerlink" title="可信设备"></a>可信设备</h2><ol>
<li>由可信制造商加工，被分配一个保密的播放器密钥</li>
</ol>
<h2 id="内容扰乱系统CSS"><a href="#内容扰乱系统CSS" class="headerlink" title="内容扰乱系统CSS"></a>内容扰乱系统CSS</h2><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA_img/35.png" alt=""></p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计安导第2章</title>
    <url>/2020/01/20/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC2%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="物理保护与攻击"><a href="#物理保护与攻击" class="headerlink" title="物理保护与攻击"></a>物理保护与攻击</h1><h2 id="物理安全"><a href="#物理安全" class="headerlink" title="物理安全"></a>物理安全</h2><ol>
<li>物理安全：泛指保护贵重物品、信息或访问受限资源 所使用的物理措施，物理安全直接影响完整性、计算 机硬件和数字信息保护。包括<ol>
<li>位置保护</li>
<li>物理入侵检测</li>
<li>硬件攻击</li>
<li>窃听</li>
<li>物理接口攻击</li>
</ol>
</li>
</ol>
<h2 id="钥匙与锁"><a href="#钥匙与锁" class="headerlink" title="钥匙与锁"></a>钥匙与锁</h2><ol>
<li>包括TSA锁，凸块锁，万能钥匙，弹子锁</li>
<li>非破坏性开锁：选取，旁路</li>
<li>40种不同的钥匙坯，7个顶部锁鞘，8个不同高度的底部锁鞘，则可能的钥匙数量是40*8<sup>7</sup></li>
</ol>
<h2 id="特权升级"><a href="#特权升级" class="headerlink" title="特权升级"></a>特权升级</h2><p>攻击者将地权限的密钥提升为高权限的密钥</p>
<h2 id="指纹锁相关问题"><a href="#指纹锁相关问题" class="headerlink" title="指纹锁相关问题"></a>指纹锁相关问题</h2><ol>
<li>识别率不够高</li>
<li>电池寿命问题</li>
<li>指纹锁的稳定性不高</li>
</ol>
<h2 id="测信道攻击"><a href="#测信道攻击" class="headerlink" title="测信道攻击"></a>测信道攻击</h2><p>攻击者不是试图直接绕过 安全措施，而是通过利用 其他不受安全机制保护的 漏洞绕过安全措施</p>
<h1 id="身份认证技术"><a href="#身份认证技术" class="headerlink" title="身份认证技术"></a>身份认证技术</h1><ol>
<li>包括条形码，二维码，磁条卡，智能卡，SIM卡,RFID</li>
</ol>
<h2 id="磁条卡安全"><a href="#磁条卡安全" class="headerlink" title="磁条卡安全"></a>磁条卡安全</h2><ol>
<li>问题：易于读取和复制。词条阅读器成本相对较低</li>
<li>解决：要求输入PIN</li>
</ol>
<h2 id="智能卡安全"><a href="#智能卡安全" class="headerlink" title="智能卡安全"></a>智能卡安全</h2><ol>
<li>可以提供保护所有者信息的安全认证机制，并且极难复制</li>
<li>使用加密技术加强认证的手段</li>
</ol>
<h2 id="SIM卡安全"><a href="#SIM卡安全" class="headerlink" title="SIM卡安全"></a>SIM卡安全</h2><ol>
<li>SIM卡：用于识别所有者并对相应的蜂窝网络进行身份验证</li>
<li>18位，用于硬件识别</li>
<li>128位密钥</li>
</ol>
<h2 id="GSM挑战-相应协议"><a href="#GSM挑战-相应协议" class="headerlink" title="GSM挑战-相应协议"></a>GSM挑战-相应协议</h2><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA_img/36.png" alt=""></p>
<ol>
<li>当手机希望加入蜂窝网络时，它连接并发送其IMSI到网络提供商拥有的 本地基站。 </li>
<li>如果IMSI匹配网络提供商的数据库中的用户记录正确，则基站将128位 随机数发送到蜂窝电话。 </li>
<li>然后，该随机数由蜂窝电话编码存储在SIM卡中，用户的密钥使用A3的 专有加密算法，从而产生发送回基站的密文</li>
<li>然后，基站使用其存储的用于用户密钥的值来执行相同的计算。 如果两 个密文匹配，则手机被认证到网络并被允许拨打和接听电话。</li>
</ol>
<h2 id="RFID"><a href="#RFID" class="headerlink" title="RFID"></a>RFID</h2><ol>
<li>必须与单独的读取器或写入器一起使用</li>
<li>所有RFID都使用密钥加密</li>
</ol>
<h2 id="生物识别技术"><a href="#生物识别技术" class="headerlink" title="生物识别技术"></a>生物识别技术</h2><ol>
<li><p>生物特征：指用于基于生物或生理特 征唯一识别信息进行的任何身份度 量。</p>
</li>
<li><p>生物识别的要求</p>
<ol>
<li>普遍性</li>
<li>独特性</li>
<li>持久性</li>
<li>可回收性：该特征应具有有效确定和量化的能力</li>
</ol>
</li>
<li><p>如指纹，虹膜，步态</p>
</li>
</ol>
<h1 id="针对计算设备的攻击"><a href="#针对计算设备的攻击" class="headerlink" title="针对计算设备的攻击"></a>针对计算设备的攻击</h1><h2 id="环境攻击"><a href="#环境攻击" class="headerlink" title="环境攻击"></a>环境攻击</h2><ol>
<li>电力，温度，有限的传导</li>
</ol>
<h2 id="窃听"><a href="#窃听" class="headerlink" title="窃听"></a>窃听</h2><p>搭线窃听同轴电缆的电脉冲</p>
<h2 id="信号发射"><a href="#信号发射" class="headerlink" title="信号发射"></a>信号发射</h2><p>通过计算机屏幕发出的射频信号来检测正在显示的内容</p>
<h2 id="键盘记录"><a href="#键盘记录" class="headerlink" title="键盘记录"></a>键盘记录</h2><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><ol>
<li>三级：1米；20米，100米</li>
<li>放射阻隔(阻隔光,音)</li>
<li>法拉第笼：阻挡电磁辐射</li>
</ol>
<h1 id="计算机取证"><a href="#计算机取证" class="headerlink" title="计算机取证"></a>计算机取证</h1><p>计算机取证是一种获取包含在电子媒介上的信息的方 法，如计算机系统、硬盘和光盘，通常用于收集用于 法律诉讼的证据</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li>鉴定</li>
<li>收集：注意不要修改数据</li>
<li>分析和评估</li>
<li>报告</li>
</ol>
<h2 id="取证约束"><a href="#取证约束" class="headerlink" title="取证约束"></a>取证约束</h2><ol>
<li>监管链</li>
<li>优先级RAM &gt; swap &gt; disk &gt; CDs/DVDs。第一时间捕获更易失的</li>
<li>犯罪现场的计算机应该被视为完全敌对的</li>
</ol>
<h2 id="隐藏数据的方法"><a href="#隐藏数据的方法" class="headerlink" title="隐藏数据的方法"></a>隐藏数据的方法</h2><ol>
<li>密码学</li>
<li>隐写术</li>
<li>更改文件名或者扩展名</li>
<li>隐藏分区</li>
<li>删除文件</li>
</ol>
<h2 id="反取证技术"><a href="#反取证技术" class="headerlink" title="反取证技术"></a>反取证技术</h2><ol>
<li>反取证技术试图阻止调查员及其取证技术</li>
<li>安全删除数据，以便无法使用取证方法进行恢复 </li>
<li>首先防止创建某些数据</li>
<li>从未出现的数据显然无法通过取证方法恢复。</li>
</ol>
<h2 id="磁盘擦出"><a href="#磁盘擦出" class="headerlink" title="磁盘擦出"></a>磁盘擦出</h2>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机安全导论</title>
    <url>/2020/01/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="计安导第2章"><a href="#计安导第2章" class="headerlink" title="计安导第2章"></a><a href="/2020/01/20/计安导第2章/">计安导第2章</a></h2><h2 id="计安导第3章"><a href="#计安导第3章" class="headerlink" title="计安导第3章"></a><a href="/2020/01/20/计安导第3章/">计安导第3章</a></h2><h2 id="计安导第4章"><a href="#计安导第4章" class="headerlink" title="计安导第4章"></a><a href="/2020/01/20/计安导第4章/">计安导第4章</a></h2><h2 id="计安导第5章"><a href="#计安导第5章" class="headerlink" title="计安导第5章"></a><a href="/2020/01/20/计安导第5章/">计安导第5章</a></h2><h2 id="计安导第6章"><a href="#计安导第6章" class="headerlink" title="计安导第6章"></a><a href="/2020/01/20/计安导第6章/">计安导第6章</a></h2><h2 id="计安导第7章"><a href="#计安导第7章" class="headerlink" title="计安导第7章"></a><a href="/2020/01/20/计安导第7章/">计安导第7章</a></h2><h2 id="计安导第8章"><a href="#计安导第8章" class="headerlink" title="计安导第8章"></a><a href="/2020/01/20/计安导第8章/">计安导第8章</a></h2><h2 id="计安导第9章"><a href="#计安导第9章" class="headerlink" title="计安导第9章"></a><a href="/2020/01/20/计安导第9章/">计安导第9章</a></h2><h2 id="计安导第10章"><a href="#计安导第10章" class="headerlink" title="计安导第10章"></a><a href="/2020/01/20/计安导第10章/">计安导第10章</a></h2>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第9讲</title>
    <url>/2020/01/20/%E8%A7%86%E8%A7%89%E7%AC%AC9%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="随机抽样一致"><a href="#随机抽样一致" class="headerlink" title="随机抽样一致"></a>随机抽样一致</h1><p>针对最小二乘法出现的离群点问题</p>
<ol>
<li><p>思路</p>
<ol>
<li>先求得一条候选直线</li>
<li>计算与该直线的内群点</li>
<li>对于所有候选直线，选择内群点最多的那一条。</li>
</ol>
</li>
<li><p>RANSAC算法</p>
<ol>
<li><p>思想：所有的内点将在平移向量上达成一致；少部分离群点彼此矛盾。</p>
</li>
<li><p>RANSAC只能在离群点少于50%时才能保证正确解。</p>
</li>
<li><p>衡量内点：通过阈值过滤</p>
<p> 阈值与噪声量有关，通常噪声建模为高斯噪声，标准差为3个像素。</p>
<p> 通过设置阈值，使高斯分布中95%的比例位于半径内。</p>
</li>
<li><p>算法完整过程</p>
<ol>
<li><p>随机选择s个样本点</p>
<p> 通常s=可求解模型的最少样本点数</p>
</li>
<li><p>根据样本得到一个解</p>
</li>
<li><p>计算内点数</p>
</li>
<li><p>重复N次</p>
</li>
<li><p>选择具有最多内点的模型。</p>
</li>
<li><p>计算所有内点的平均平移向量。</p>
</li>
</ol>
</li>
<li><p>实验轮数         </p>
 <img src="/CV_img/9_1.png " style="zoom:80%">

<p> 其中p为内点概率；s是每次实验使用的样本点数目；P为能最终找到正确解的概率；R为实验轮次</p>
</li>
<li><p>s的取值<br> 为自由度/2下取整</p>
 <img src="/CV_img/9_2.png " style="zoom:80%"></li>
<li><p>优点</p>
<ol>
<li>简单，通用</li>
<li>适用于许多不同的问题</li>
<li>实践中表现良好，通常比蛮力取样要好</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>需要调整参数</li>
<li>有时需要大量迭代，耗费时间</li>
<li>内点概率极低时可能失败</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第5讲</title>
    <url>/2020/01/20/%E8%A7%86%E8%A7%89%E7%AC%AC5%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="特征不变性"><a href="#特征不变性" class="headerlink" title="特征不变性"></a>特征不变性</h1><ol>
<li><p>不变性与协变性</p>
<ol>
<li><p>不变性：图像变换后，角点位置不变。</p>
<p> 我们希望角点的位置对光照变换有不</p>
</li>
<li><p>协变性：如果有两张同一图像的变换版本，则应在相应的位置检测到同一特征。</p>
<p> 我们希望角点对几何变换具有协变性。</p>
</li>
</ol>
</li>
<li><p>Harris检测器</p>
<ol>
<li><p>平移：</p>
<ol>
<li>导数和窗口函数是平移不变的。</li>
<li>角点位置是平移协变的。</li>
</ol>
</li>
<li><p>图像旋转</p>
<ol>
<li>形状是旋转不变的</li>
<li>角点位置是旋转协变的。</li>
</ol>
</li>
<li><p>仿射强度变化</p>
<ol>
<li><p>对仿射强度变化部分具有不变性。</p>
 <img src="/CV_img/5_1.png" style="zoom:80%"></li>
</ol>
</li>
<li><p>缩放</p>
<ol>
<li>对缩放不具有不变性。</li>
<li>实现尺度不变性：寻找使f具有局部最大值的尺度。<ol>
<li>同时在位置和尺度上查找。</li>
</ol>
</li>
<li>自动尺度选择：规格化到固定尺度。<ol>
<li>是在高斯金字塔中使用固定大小的窗口。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>高斯-拉布普拉斯算子(LoG)</p>
<p> <a href=""https://blog.csdn.net/touch_dream/article/details/62237018"/a">高斯-拉普拉斯算子</a></p>
<ol>
<li><p>LoG是高斯函数的二阶导数</p>
</li>
<li><p>为了减少计算量，可以用高斯差分算子(DoG)来近似</p>
 <img src="/CV_img/5_2.png" style="zoom:80%">

<p> 该函数逼近是因为发现高斯二阶导和原高斯函数对sigma参数求导之后函数模型的关系如上述的公式，然后约等于右边的导数表达式（严格的话需要加上极限的）！模型逼近如下：好处是可以提高算法的效率减少计算量</p>
</li>
<li><p>LoG和DoG都是旋转不变的。</p>
</li>
</ol>
</li>
<li><p>Blob斑点检测器</p>
<ol>
<li><p>在空间和尺度上查找LoG算子的极大值和极小值。</p>
<ol>
<li><p>将一个点与周围26个点比较，以求得极大值。</p>
 <img src="/CV_img/5_3.png" style="zoom:80%"></li>
</ol>
</li>
<li><p>特征尺度：产生拉普拉斯响应峰值的尺度。</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第6讲</title>
    <url>/2020/01/20/%E8%A7%86%E8%A7%89%E7%AC%AC6%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="特征描述符"><a href="#特征描述符" class="headerlink" title="特征描述符"></a>特征描述符</h1><ol>
<li>性质：<ol>
<li>不变性：图像被变换，描述符应该不变</li>
<li>区分力：每个点的描述符是高度唯一的<h2 id="实现不变性"><a href="#实现不变性" class="headerlink" title="实现不变性"></a>实现不变性</h2></li>
</ol>
</li>
<li>确保检测器是不变的</li>
<li>设计不变的特征描述符</li>
</ol>
<h2 id="旋转不变性"><a href="#旋转不变性" class="headerlink" title="旋转不变性"></a>旋转不变性</h2><p>通过寻找图像块的主导方向实现，主导方向为<br>    1. H的特征向量Xmax对应的λmax<br>    2. 梯度方向</p>
<h2 id="MOPS"><a href="#MOPS" class="headerlink" title="MOPS"></a>MOPS</h2><ol>
<li><strong>步骤</strong>：<ol>
<li>选出特征点周围40×40的窗口</li>
<li>缩放到1/5大小</li>
<li>旋转至水平</li>
<li>在以特征为中心的8×8窗口内采样</li>
<li>规格化：强度减去平均值除以标准差，使之均值为0，方差为1。</li>
</ol>
</li>
</ol>
<h2 id="SIFT"><a href="#SIFT" class="headerlink" title="SIFT"></a>SIFT</h2><ol>
<li><p><strong>步骤</strong></p>
<ol>
<li>取特征周围16×16的窗口，划分为4×4单元格</li>
<li>为每个像素计算边缘方向(梯度方向-90°)</li>
<li>通过梯度幅值阈值去除弱的边缘</li>
<li>为剩余边缘<strong>方向</strong>建立直方图，得到16个单元格×8方向=128维描述符</li>
<li>将该128维描述符归一化到单位长度</li>
</ol>
</li>
<li><p>性质：</p>
<ol>
<li>可以处理视角变化</li>
<li>适应光照变化</li>
<li>快速高效</li>
</ol>
</li>
</ol>
<h1 id="特征匹配"><a href="#特征匹配" class="headerlink" title="特征匹配"></a>特征匹配</h1><p>想找到最佳匹配</p>
<ol>
<li>定义距离函数来比较两个描述符</li>
<li>测试I2中所有的特征，找出距离最小的一个。</li>
</ol>
<h2 id="特征距离"><a href="#特征距离" class="headerlink" title="特征距离"></a>特征距离</h2><ol>
<li>定义为||f1-f2||<ol>
<li><strong>问题</strong> 可能对不正确匹配给出小的距离。</li>
<li><strong>解决</strong> 定义距离比= ||f1-f2||/||f1-f2’||<ol>
<li>f2是f1在I2中最好的SSD匹配</li>
<li>f2’是f1在I2中次好的SSD匹配</li>
<li>距离比可以对不正确的匹配给出较大的值，用阈值过滤即可。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="结果评估"><a href="#结果评估" class="headerlink" title="结果评估"></a>结果评估</h1><ol>
<li>最大化真阳性，最小化假阳性<h2 id="Roc-曲线"><a href="#Roc-曲线" class="headerlink" title="Roc 曲线"></a>Roc 曲线</h2></li>
</ol>
<img src="/CV_img/6-1.png" style="zoom: ">


<img src="/CV_img/6-2.png" style="zoom: ">
1. AUC:一个正例，一个负例，预测为正的概率值比负的概率值还要大的可能性。
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第7讲</title>
    <url>/2020/01/20/%E8%A7%86%E8%A7%89%E7%AC%AC7%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="图像卷绕"><a href="#图像卷绕" class="headerlink" title="图像卷绕"></a>图像卷绕</h1><p>卷绕&amp;滤波：</p>
<p>滤波改变图像的值域</p>
<p>&lt;img src=”/CV_img/7-1.png”style=”zoom: “&gt;</p>
<p>卷绕改变图像的定义域</p>
<p>&lt;img src=”/CV_img/7-2.png”style=”zoom: “&gt;</p>
<h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><ol>
<li><p>缩放</p>
<p> &lt;img src=”/CV_img/7-3.png”style=”zoom: “&gt;</p>
</li>
<li><p>旋转</p>
<p> &lt;img src=”/CV_img/7-4.png”style=”zoom: “&gt;</p>
<ol>
<li>R<sup>-1</sup>=R<sup>T</sup></li>
</ol>
</li>
<li><p>镜像    </p>
<ol>
<li><p>关于Y轴镜像</p>
<p> &lt;img src=”/CV_img/7-5.png”style=”zoom: “&gt;</p>
</li>
<li><p>关于y=x镜像</p>
<p> &lt;img src=”/CV_img/7-6.png”style=”zoom: “&gt;</p>
</li>
</ol>
</li>
<li><p>剪切</p>
</li>
<li><p>性质：</p>
<ol>
<li>原点映射到原点</li>
<li>直线映射到直线</li>
<li>平行线保持平行</li>
<li>保持比率</li>
<li>线性变换的组合仍然是线性变换。</li>
</ol>
</li>
</ol>
<h2 id="非线性变换–仿射变换"><a href="#非线性变换–仿射变换" class="headerlink" title="非线性变换–仿射变换"></a>非线性变换–仿射变换</h2><p>&lt;img src=”/CV_img/7-8.png”style=”zoom: “&gt;</p>
<p>方式变换是线性变换和平移变换的组合</p>
<ol>
<li><p>基本仿射变换</p>
<p> &lt;img src=”/CV_img/7-7.png”style=”zoom: “&gt;</p>
</li>
<li><p>仿射变换的性质</p>
<ol>
<li>原点不一定映射到原点</li>
<li>直线映射到直线</li>
<li>平行线保持平行</li>
<li>保持比率</li>
<li>仿射变换的组合仍然是仿射变换</li>
</ol>
</li>
</ol>
<h2 id="投影变换-透视变换-单应映射"><a href="#投影变换-透视变换-单应映射" class="headerlink" title="投影变换(透视变换/单应映射)"></a>投影变换(透视变换/单应映射)</h2><p>&lt;img src=”/CV_img/7-9.png”style=”zoom: “&gt;</p>
<ol>
<li><p>8个自由度</p>
</li>
<li><p>投影变换的属性</p>
<ol start="2">
<li><p>保直线</p>
</li>
<li><p>原点不一定映射到原点</p>
</li>
<li><p>不保平行</p>
</li>
<li><p>不保比率</p>
</li>
<li><p>投影的组合仍然是投影变换</p>
</li>
</ol>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&lt;img src=”/CV_img/7-10.png”style=”zoom: “&gt;</p>
<h1 id="实现图像卷绕"><a href="#实现图像卷绕" class="headerlink" title="实现图像卷绕"></a>实现图像卷绕</h1><h2 id="前向卷绕"><a href="#前向卷绕" class="headerlink" title="前向卷绕"></a>前向卷绕</h2><p>将每个像素f (x,y)复制到g图中对应位置(x’,y’) = T(x,y)</p>
<ol>
<li>如果(x’,y’)不是整数，则将像素值分配给四个最近邻，记录每个点的权重并在最后归一化。</li>
<li><strong>问题</strong> 可能有空洞，效果是混叠与模糊</li>
</ol>
<h2 id="反向卷绕"><a href="#反向卷绕" class="headerlink" title="反向卷绕"></a>反向卷绕</h2><p>获取每个像素g(x’, y’) 在原图像中对应的位 置 (x, y) = T<sup>-1</sup>(x’<br>, y’) 处的像素值f(x, y)</p>
<ol>
<li>如果(x,y)不是整数，则f(x,y)的颜色值通过原图像中邻域的插值获得，且可以使用滤波器来控制混叠。</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第8讲</title>
    <url>/2020/01/20/%E8%A7%86%E8%A7%89%E7%AC%AC8%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="图像配准"><a href="#图像配准" class="headerlink" title="图像配准"></a>图像配准</h1><p>问题：给定图像A和B之间的一组匹配项，如何计算从A到B的变换T？</p>
<ol>
<li><p>对于平移</p>
<ol>
<li><p>最简单的取n对匹配的移动平均值值</p>
 <img src="/CV_img/8_1.png" style = "zoom:80%" /></li>
<li><p>通过线性方程组求解</p>
<ol>
<li><p>问题：对于n对匹配点，有2两个未知数和2n个方程–&gt;最小二乘法。</p>
</li>
<li><p>最小二乘法</p>
<ol>
<li><p>最小二乘法公式</p>
 <img src="/CV_img/8_2.png" style = "zoom:80%"/></li>
<li><p>矩阵形式</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code>&lt;img src=&quot;/CV_img/8_3.png&quot; style = &quot;zoom:80%&quot;/&gt;</code></pre><ol start="2">
<li><p>对于仿射变化</p>
<ol>
<li><p>有6个未知数</p>
 <img src="/CV_img/8_4.png" style = "zoom:80%"/></li>
</ol>
</li>
<li><p>对于同态映射（单应映射）</p>
<ol>
<li><p>有8个未知数，至少需要4个匹配对。</p>
<img src="/CV_img/8_5.png" style = "zoom:80%"/>

<img src="/CV_img/8_6.png" style = "zoom:80%"/>

<img src="/CV_img/8_7.png" style = "zoom:80%"/></li>
</ol>
</li>
<li><p>图像配准过程</p>
<ol>
<li>计算A和B的特征</li>
<li>匹配A和B之间的特征</li>
<li>使用匹配集计算A到B单应映射矩阵的最小二乘解。</li>
</ol>
</li>
<li><p>离群点（外点）</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第1讲</title>
    <url>/2020/01/20/%E8%A7%86%E8%A7%89%E7%AC%AC1%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="滤波器"><a href="#滤波器" class="headerlink" title="滤波器"></a>滤波器</h1><ol>
<li><strong>滤波</strong>：形成一个新的图像，其像素是原始像素的组合。</li>
<li>用途：<ol>
<li>提取边缘或轮廓</li>
<li>消除噪音</li>
<li>锐化和增强形象</li>
</ol>
</li>
</ol>
<h1 id="线性滤波"><a href="#线性滤波" class="headerlink" title="线性滤波"></a>线性滤波</h1><ol>
<li>线性滤波：用相邻的线性组合(加权和)替换每个像素</li>
</ol>
<p>–&gt;互相关，卷积</p>
<h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><img src="/CV_img/1-1.png" style="zoom: ">

<ol>
<li>将图像记为,以H表示权重核（大小为(2K+1)x(2K+1)),并记G为输出图像</li>
<li>G=H×F<h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2></li>
</ol>
<img src="/CV_img/1-2.png" style="zoom: ">

<ol>
<li>与相关相同，只是将权重核在水平和竖直方向翻转。</li>
<li>妈祖交换律、分配律和结合律</li>
</ol>
<h2 id="平均滤波"><a href="#平均滤波" class="headerlink" title="平均滤波"></a>平均滤波</h2><ol>
<li>H 全为1/k，其中k为权重核边长。</li>
</ol>
<h2 id="锐化-增强图像-平均滤波"><a href="#锐化-增强图像-平均滤波" class="headerlink" title="锐化 = 增强图像-平均滤波"></a>锐化 = 增强图像-平均滤波</h2><img src="/CV_img/1-3.png" style="zoom: ">

<img src="/CV_img/1-5.png" style="zoom: ">

<h2 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h2><ol>
<li><p>高斯核</p>
 <img src="/CV_img/1-4.png" style="zoom: ">

<ol>
<li>σ作用：σ越大，带通越大，高斯核函数的局部影响的范围就越大。中心亮点也越大，卷积后的图像越模糊。</li>
</ol>
</li>
<li><p>高斯滤波器（低通滤波器）</p>
<ol>
<li>用宽度为σ的核卷积两次=以宽度为&radic;2σ的核卷积一次。</li>
</ol>
</li>
</ol>
<h2 id="阈值滤波器"><a href="#阈值滤波器" class="headerlink" title="阈值滤波器"></a>阈值滤波器</h2><p><strong>不是线性滤波器</strong></p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第2讲</title>
    <url>/2020/01/20/%E8%A7%86%E8%A7%89%E7%AC%AC2%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="边缘"><a href="#边缘" class="headerlink" title="边缘"></a>边缘</h1><ol>
<li><p>来源：</p>
<ol>
<li>表面法线不连续</li>
<li>深度不连续</li>
<li>颜色不连续</li>
<li>光照不连续</li>
</ol>
</li>
<li><p>特征是图像强度函数中快速变化的地方：    </p>
<ol>
<li>一阶导数的极值点</li>
<li>二阶导数为0的点</li>
</ol>
</li>
</ol>
<h2 id="图像导数求解"><a href="#图像导数求解" class="headerlink" title="图像导数求解"></a>图像导数求解</h2><img src="/CV_img/1-6.png" style="zoom: ">

<h2 id="图像梯度求解"><a href="#图像梯度求解" class="headerlink" title="图像梯度求解"></a>图像梯度求解</h2><img src="/CV_img/1-7.png" style="zoom: ">

<ol>
<li>梯度点在强度增大最快的方向上</li>
<li>边缘方向与梯度方向垂直</li>
</ol>
<h2 id="去噪"><a href="#去噪" class="headerlink" title="去噪"></a>去噪</h2><ol>
<li><p>问题</p>
 <img src="/CV_img/1-8.png" style="zoom: ">
</li>
<li><p>解决:先做平滑</p>
 <img src="/CV_img/1-9.png" style="zoom: ">

<ol>
<li>核一般不变，可以先求h的导数，以简化计算。</li>
</ol>
</li>
</ol>
<h1 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h1><h2 id="高斯一阶导"><a href="#高斯一阶导" class="headerlink" title="高斯一阶导"></a>高斯一阶导</h2><img src="/CV_img/1-10.png" style="zoom: ">

<h2 id="Sobel算子"><a href="#Sobel算子" class="headerlink" title="Sobel算子"></a>Sobel算子</h2><img src="/CV_img/1-11.png" style="zoom: ">

<ol>
<li>是高斯导数的一般近似</li>
<li>标准定义中没有1/8，不会影响边缘检测</li>
<li>如果要得到正确的梯度值，1/8是必须的。</li>
</ol>
<h2 id="非最大抑制"><a href="#非最大抑制" class="headerlink" title="非最大抑制"></a>非最大抑制</h2><p>检测像素是否是梯度方向上的局部最大值，一般需要插值。</p>
<img src="/CV_img/1-12.png" style="zoom: ">

<h2 id="Canny-边缘检测器"><a href="#Canny-边缘检测器" class="headerlink" title="Canny 边缘检测器"></a>Canny 边缘检测器</h2><p><strong>步骤</strong></p>
<ol>
<li>用高斯导数做滤波<ol>
<li>大σ检测大尺度边缘</li>
<li>小σ检测细微边缘</li>
</ol>
</li>
<li>获得梯度的赋值和方向</li>
<li>非最大抑制</li>
<li>连接与滞后 阈值化（两个阈值）<ol>
<li>高阈值寻找边缘曲线的起点</li>
<li>低阈值确定后继点</li>
</ol>
</li>
</ol>
<h1 id="尺度空间"><a href="#尺度空间" class="headerlink" title="尺度空间"></a>尺度空间</h1><p><strong>性质</strong></p>
<ol>
<li>边缘位置随尺度(σ) 的增大而变化</li>
<li>随尺度增加，两条边缘有可能合并</li>
<li>随尺度增加，边缘不可能分成两个</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第3讲</title>
    <url>/2020/01/20/%E8%A7%86%E8%A7%89%E7%AC%AC3%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="子采样"><a href="#子采样" class="headerlink" title="子采样"></a>子采样</h1><ol>
<li>每隔一行一列丢弃一行一列</li>
<li>问题：导致噪声变多</li>
<li>解决：先滤波，再子采样</li>
</ol>
<h2 id="混叠"><a href="#混叠" class="headerlink" title="混叠"></a>混叠</h2><ol>
<li>定义：当采样频率不够高时，无法捕捉图像中的细节。</li>
<li>解决：采样率≥2 * 图像中的最大频率&lt;=&gt;每周期至少两个样本</li>
<li>若原始图像频率太高，则先做高斯预处理，然后子采样。（高斯金字塔）</li>
</ol>
<h1 id="上采样"><a href="#上采样" class="headerlink" title="上采样"></a>上采样</h1><h2 id="最简单方法"><a href="#最简单方法" class="headerlink" title="最简单方法"></a>最简单方法</h2><p>重复每行每列n次</p>
<h2 id="图像插值"><a href="#图像插值" class="headerlink" title="图像插值"></a>图像插值</h2><img src="/CV_img/3-1.png" style="zoom:80%">
###   重建滤波器
1. 目的是重建连续图像f
2. 步骤
    1. 将F转换成连续函数：
        f<sub>F</sub>(x)=F(x/d) 当x/d是整数，否则为0
    2. 用重建滤波器H来卷积
        f = h*f<sub>F</sub>


]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第4讲</title>
    <url>/2020/01/20/%E8%A7%86%E8%A7%89%E7%AC%AC4%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="Harris角点检测"><a href="#Harris角点检测" class="headerlink" title="Harris角点检测"></a>Harris角点检测</h1><ol>
<li><p>不变的局部特征</p>
<ol>
<li>几何不变性：平移、旋转、缩放</li>
<li>光度不变性：亮度、曝光率</li>
<li>局部特征的优点<ol>
<li>局部性：由于特征是局部的，所以对遮挡和噪声鲁棒。</li>
<li>数量：一张图片中成百上千。</li>
<li>独特性：可以区分大量对象</li>
<li>效率：可实现实时性能。</li>
</ol>
</li>
</ol>
</li>
<li><p>好的特征</p>
<ol>
<li>需要具有唯一性</li>
<li>在任何方向上移动窗口都导致大的变化–&gt;角点。</li>
</ol>
</li>
<li><p>Harris角点检测</p>
<ol>
<li><p>通过比较平移前后窗口w内每个像素的差异平方和(SSD)</p>
</li>
<li><p>SSD:</p>
 <img src="/CV_img/4_1.png" style="zoom:80%">

<ol>
<li>SSD越大越好</li>
<li>问题：计算每个点的SSD很慢。</li>
<li>对平移量进行泰勒级数展开。</li>
</ol>
</li>
<li><p>近似SSD</p>
 <img src="/CV_img/4_2.png" style="zoom:80%">

 <img src="/CV_img/4_3.png" style="zoom:80%">
 1. 对于水平边缘Ix=0;垂直边缘Iy=0;
 2. 对于矩阵H可以看作一个椭圆

<pre><code>&lt;img src=&quot;/CV_img/4_4.png&quot; style=&quot;zoom:80%&quot;&gt;

可以通过查看H的特征向量来找到导致最大和最小的E的方向。
1. &lt;img src=&quot;/CV_img/4_4.png&quot; style=&quot;zoom:80%&quot;&gt;
2. 特征值与特征检测的关系：我们希望E(u,v)的最小值对于小的平移量(u,v)都大，此最小值由H的较小的特征值λ&lt;sub&gt;min&lt;/sub&gt;给出</code></pre></li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第17讲</title>
    <url>/2020/01/20/%E8%A7%86%E8%A7%89%E7%AC%AC17%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="光"><a href="#光" class="headerlink" title="光"></a>光</h1><h2 id="辐射"><a href="#辐射" class="headerlink" title="辐射"></a>辐射</h2><ol>
<li>像素亮度决定因素<ol>
<li>光源属性</li>
<li>表面特性<h2 id="光谱"><a href="#光谱" class="headerlink" title="光谱"></a>光谱</h2>可见光为400nm-700nm的电磁辐射</li>
</ol>
</li>
</ol>
<h2 id="颜色知觉"><a href="#颜色知觉" class="headerlink" title="颜色知觉"></a>颜色知觉</h2><img src="/CV_img/17-1.png">


<img src="/CV_img/17-2.png">

<ol>
<li>视锥细胞和视杆细胞在光谱上充当滤波器。<h2 id="亮度对比度和恒常"><a href="#亮度对比度和恒常" class="headerlink" title="亮度对比度和恒常"></a>亮度对比度和恒常</h2></li>
<li>亮度对比度：恒定的有色区域根据周围的强度看起来更亮或更暗。</li>
<li>明度恒常性：当照明条件改变时，人知觉到的物体的相对明度保持不变。</li>
</ol>
<h2 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h2><h3 id="定向照明："><a href="#定向照明：" class="headerlink" title="定向照明："></a>定向照明：</h3><ol>
<li>所有射线都是平行的</li>
<li>等价于无穷远的点光源</li>
</ol>
<h3 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h3><img src="/CV_img/17-3.png">

<p>I = N·L</p>
<ol>
<li>漫反射反射到各个角度得到的光强一样，与视角无关</li>
<li>正比于夹角余弦<h3 id="三种材料"><a href="#三种材料" class="headerlink" title="三种材料"></a>三种材料</h3></li>
<li>理想漫反射：哑光表面</li>
<li><h1 id="图像形成模型"><a href="#图像形成模型" class="headerlink" title="图像形成模型"></a>图像形成模型</h1></li>
</ol>
<img src="/CV_img/17-4.png">

<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><ol>
<li>Kd：表示入射光反射的比例</li>
<li>I：光强度，表示有多少光射进来</li>
<li>相机相应函数：假设像素值与传入光的能量成线性比例关系。<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2>测量光的方向以辨别真假照片。</li>
</ol>
<p>需要增加假设</p>
<ol>
<li>反照率恒定</li>
<li>已知一些法线</li>
<li>已知法线的平滑度</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第18讲</title>
    <url>/2020/01/20/%E8%A7%86%E8%A7%89%E7%AC%AC18%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="光度测量立体视觉"><a href="#光度测量立体视觉" class="headerlink" title="光度测量立体视觉"></a>光度测量立体视觉</h1><p>基于<strong>朗伯漫反射</strong></p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="求光照方向"><a href="#求光照方向" class="headerlink" title="求光照方向"></a>求光照方向</h3><p>利用铬球的镜面反射</p>
<img src="/CV_img/18-2.png">
###   求法线方向

<p>假设已知三个点</p>
<ol>
<li><img src="/CV_img/18-3.png"></li>
<li><p>写成矩阵形式</p>
</li>
<li> <img src="/CV_img/18-4.png">
</li>
<li><p>求解N</p>
 <img src="/CV_img/18-5.png"></li>
<li><p>对每个像素求解可以获得该像素的表面法线方向</p>
</li>
<li><p>超过三个光源</p>
 <img src="/CV_img/18-1.png">

</li>
</ol>
<h3 id="从法线计算深度-泊松方程"><a href="#从法线计算深度-泊松方程" class="headerlink" title="从法线计算深度(泊松方程)"></a>从法线计算深度(泊松方程)</h3><p>将相邻的连个点的连线看成是曲面的切面向量，那么这条线与法线垂直。</p>
<img src="/CV_img/18-6.png">

<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>对于有反射，折射，阴影等情况不起效</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第19讲</title>
    <url>/2020/01/20/%E8%A7%86%E8%A7%89%E7%AC%AC19%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="图像识别"><a href="#图像识别" class="headerlink" title="图像识别"></a>图像识别</h1><ol>
<li><p>简单匹配存在的问题：</p>
<ol>
<li>遮挡，视角的变化</li>
<li>类内的变化</li>
<li>照明变化</li>
<li>变形</li>
<li>背景杂乱</li>
</ol>
</li>
<li><p>没有明确的解</p>
<h1 id="数据驱动的方法"><a href="#数据驱动的方法" class="headerlink" title="数据驱动的方法"></a>数据驱动的方法</h1><img src="/CV_img/19-1.png">
</li>
<li><p>收集带有标签的图像数据库</p>
</li>
<li><p>使用机器学习算法训练图像分类器</p>
</li>
<li><p>用测试图像评估分类器的效果</p>
</li>
</ol>
<h2 id="线性分类器"><a href="#线性分类器" class="headerlink" title="线性分类器"></a>线性分类器</h2><p>要做</p>
<ol>
<li>定义一个损失函数：在训练集上评估我们对分类分数的不满意程度</li>
<li>优化方法：求解参数的方法，以最小化损失函数<h3 id="评分函数-原始数据到类分数"><a href="#评分函数-原始数据到类分数" class="headerlink" title="评分函数 原始数据到类分数"></a>评分函数 原始数据到类分数</h3></li>
</ol>
<img src="/CV_img/19-2.png">

<ol>
<li>要将图像拉成列向量</li>
<li>偏执向量可归到权重向量中</li>
</ol>
<h3 id="损失函数-预测分数与实际标签的一致性"><a href="#损失函数-预测分数与实际标签的一致性" class="headerlink" title="损失函数 预测分数与实际标签的一致性"></a>损失函数 预测分数与实际标签的一致性</h3><img src="/CV_img/19-3.png">

<ol>
<li>其中yi为真实标签</li>
<li>目标是通过训练找到最小化损失函数的参数W(评分函数中的权)</li>
</ol>
<h2 id="Softmax分类"><a href="#Softmax分类" class="headerlink" title="Softmax分类"></a>Softmax分类</h2><p>由于分数不直观，所以将分数归一化得到概率分布。推广逻辑斯蒂回归将分数转到(0,1)。</p>
<img src="/CV_img/19-4.png">

<img src="/CV_img/19-5.png">

<ol>
<li>分数转到(0,1)</li>
<li>Li只对真实标签计算，取值[0,∞]。S=0时，Li=logN</li>
<li>注意Li的负号</li>
</ol>
<h3 id="交叉熵损失"><a href="#交叉熵损失" class="headerlink" title="交叉熵损失"></a>交叉熵损失</h3><ol>
<li><img src="/CV_img/19-6.png"></li>
<li>Softmax分类器目标是最小化交叉熵</li>
</ol>
<h3 id="KL-散度-相对熵"><a href="#KL-散度-相对熵" class="headerlink" title="KL 散度 相对熵"></a>KL 散度 相对熵</h3><img src="/CV_img/19-7.png">

<ol>
<li>描述p与q之间的差异</li>
<li>非负</li>
</ol>
<h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><img src="/CV_img/19-8.png">

<img src="/CV_img/19-13.png">

<ol>
<li>使模型更加简单，增强其泛化能力</li>
<li>使权重均匀</li>
<li>避免过拟合，避免拟合噪声，增强泛化能力</li>
</ol>
<h2 id="设置权重的方法"><a href="#设置权重的方法" class="headerlink" title="设置权重的方法"></a>设置权重的方法</h2><h3 id="随机搜索"><a href="#随机搜索" class="headerlink" title="随机搜索"></a>随机搜索</h3><h3 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h3><p>跟随斜坡(沿梯度反方向进发)</p>
<img src="/CV_img/19-9.png">

<p>𝛻<sub>w</sub>L = W-α𝛻<sub>w</sub>L </p>
<ol>
<li><p>对于一维函数，梯度即导数。对于多维函数，梯度是沿各维的偏导数。</p>
</li>
<li><p>某个方向上的斜率是该方向与梯度的点积。</p>
</li>
<li><p>两向量方向相同时，点积模长最大。所以下降最快速的方向是负梯度方向。</p>
</li>
<li><p>α为学习率：太大会错过最低点，太小收敛速度慢。</p>
</li>
<li><p>数值解求法 速度慢</p>
 <img src="/CV_img/19-10.png">

 <img src="/CV_img/19-11.png">

 <img src="/CV_img/19-12.png">

<p> 近似、速度慢、容易编程</p>
</li>
<li><p><strong>解析解求法</strong>(梯度检查) 用微积分来求</p>
 <img src="/CV_img/19-14.png">

<p> 精确、快速、容易出错</p>
</li>
</ol>
<h3 id="批量梯度下降"><a href="#批量梯度下降" class="headerlink" title="批量梯度下降"></a>批量梯度下降</h3><img src="/CV_img/19-15.png">

<h3 id="动量项"><a href="#动量项" class="headerlink" title="动量项"></a>动量项</h3><img src="/CV_img/19-16.png">

<p>使得梯度变换平缓一些</p>
<h1 id="图像特征分类"><a href="#图像特征分类" class="headerlink" title="图像特征分类"></a>图像特征分类</h1><p>方法</p>
<ol>
<li>建立颜色直方图</li>
<li>建立梯度直方图</li>
<li>建立词袋</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第14讲</title>
    <url>/2020/01/20/%E8%A7%86%E8%A7%89%E7%AC%AC14%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="极线"><a href="#极线" class="headerlink" title="极线"></a>极线</h1><img src="/CV_img/14_2.png" style="zoom: ">

<ol>
<li>极线：极面与成像平面的交线<h1 id="基本矩阵"><a href="#基本矩阵" class="headerlink" title="基本矩阵"></a>基本矩阵</h1><h2 id="基本矩阵性质"><a href="#基本矩阵性质" class="headerlink" title="基本矩阵性质"></a>基本矩阵性质</h2></li>
<li>F将图像1中的点映射到图像2中的极线</li>
<li>Fp是与p对应的极线</li>
<li>F<sup>T</sup>q是与q对应的极线</li>
<li>Fe1=0，F<sup>T</sup>e2=0<ol>
<li><strong>证明</strong> 比如极线恒过e1，则对于任意的q，e1<sup>T</sup>F1<sup>T</sup>q=0，则e1<sup>T</sup>F1<sup>T</sup>=0</li>
</ol>
</li>
<li>F的秩是2，行列式为0</li>
<li>点p在图2中的极线是:Fp</li>
<li>对应点间<strong>极线约束</strong>为q<sup>T</sup>Fp=0,即匹配点必须在极线上</li>
<li>特殊点e1和e2(极点)：是相机在另一个相机成像平面上的投影。(两个相机互相拍照)</li>
<li>所有极线都通过极点</li>
</ol>
<h2 id="求解基本矩阵-已标定时"><a href="#求解基本矩阵-已标定时" class="headerlink" title="求解基本矩阵-已标定时"></a>求解基本矩阵-已标定时</h2><img src="/CV_img/14_3.png" style="zoom: ">    

<p>其中</p>
<ol>
<li>ot为baseline</li>
<li>相机1坐标系即世界坐标系</li>
<li>p,q为齐次坐标</li>
<li>旋转矩阵R<sup>-1</sup>=R<sup>T</sup><img src="/CV_img/14_4.png" style="zoom: ">

</li>
</ol>
<img src="/CV_img/14_5.png" style="zoom: ">

<ol start="3">
<li>与t的叉积可表示为</li>
</ol>
<img src="/CV_img/14_6.png" style="zoom: ">

<img src="/CV_img/14_7.png" style="zoom: ">

<ol start="4">
<li>求得本质矩阵E</li>
</ol>
<img src="/CV_img/14_8.png" style="zoom: ">

<ol start="5">
<li>求得基本矩阵F</li>
</ol>
<img src="/CV_img/14_9.png" style="zoom: ">    

<h2 id="估计基本矩阵"><a href="#估计基本矩阵" class="headerlink" title="估计基本矩阵"></a>估计基本矩阵</h2><p>在不知道K1,K2,R或t的情况下估计F</p>
<h3 id="8点算法"><a href="#8点算法" class="headerlink" title="8点算法"></a>8点算法</h3><ol>
<li>求解思路<br> 对于每对匹配点，由x’<sup>T</sup>Fx=0</li>
</ol>
<pre><code>&lt;img src=&quot;/CV_img/14_10.png&quot; style=&quot;zoom: &quot;&gt;    

将问题转换成求解让det(Af)最小化的f,其解为A&lt;sup&gt;T&lt;/sup&gt;A的最小特征向量。</code></pre><ol start="2">
<li>问题<ol>
<li>不能保证F的秩是2</li>
</ol>
</li>
<li>解决<ol>
<li>因此应将F换成F’，F’的秩为2，且是|F-F’|最小化</li>
</ol>
</li>
</ol>
<pre><code>&lt;img src=&quot;/CV_img/14_11.png&quot; style=&quot;zoom: &quot;&gt;</code></pre><ol start="4">
<li>8点算法：<ol>
<li><strong>优点</strong> 是线性的，易于实现且速度快</li>
<li><strong>缺点</strong> 易受噪声影响，当各列间数量级差别较大的时候，最小二乘法得到不良解。</li>
</ol>
</li>
</ol>
<h2 id="归一化的8点算法"><a href="#归一化的8点算法" class="headerlink" title="归一化的8点算法"></a>归一化的8点算法</h2><p>将图像变换到[-1,1]×[-1,1]</p>
<img src="/CV_img/14_12.png" style="zoom: ">

<img src="/CV_img/14_13.png" style="zoom: ">

<p>其中T为归一化矩阵</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第13讲</title>
    <url>/2020/01/20/%E8%A7%86%E8%A7%89%E7%AC%AC13%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="极几何"><a href="#极几何" class="headerlink" title="极几何"></a>极几何</h1><h2 id="基本的立体图算法"><a href="#基本的立体图算法" class="headerlink" title="基本的立体图算法"></a>基本的立体图算法</h2><img src="/CV_img/13_1.png" style="zoom: ">

<p>对于左图中每个像素，在右图同一个极线上选择最小匹配成本的像素。</p>
<ol>
<li>用SSD衡量成本</li>
<li>匹配窗口：大窗口粒度粗，小窗口更加精细，但是噪声多。</li>
</ol>
<h2 id="能量最小化求解立体视觉"><a href="#能量最小化求解立体视觉" class="headerlink" title="能量最小化求解立体视觉"></a>能量最小化求解立体视觉</h2><ol>
<li><p>目标</p>
<ol>
<li>匹配质量：希望每个像素在其他图像中找到一个好的匹配项</li>
<li>平滑：如果两个像素相邻，他们的应该平移大约相同的量<h3 id="贪心匹配"><a href="#贪心匹配" class="headerlink" title="贪心匹配"></a>贪心匹配</h3></li>
</ol>
</li>
<li><p>定义能量函数E(d)</p>
 <img src="/CV_img/13_2.png" style="zoom: ">

<ol>
<li>现在要找一个平移量映射D，最大限度的减少一个能量函数E(d)</li>
<li>独立的选择每一列的最小值d(x,y)=argmin C(x,y,d’)<h3 id="改进目标函数"><a href="#改进目标函数" class="headerlink" title="改进目标函数"></a>改进目标函数</h3></li>
</ol>
</li>
</ol>
<img src="/CV_img/13_3.png" style="zoom: ">

<p>其中</p>
<img src="/CV_img/13_4.png" style="zoom: ">

<p>对于平滑成本，v的选择很多</p>
<img src="/CV_img/13_5.png" style="zoom: ">

<ol>
<li><p>一维动态规划</p>
<ol>
<li><p>对每条扫描线使用动态规划方法独立求解</p>
</li>
<li><p>以增量方式构建成本函数D</p>
 <img src="/CV_img/13_6.png" style="zoom: ">
</li>
</ol>
</li>
<li><p>二维动态规划</p>
 <img src="/CV_img/13_7.png" style="zoom: ">

<ol>
<li>不能用二维动态规划求解，因为dx,y-1和 dx-1,y可能取决于 dx-1,y-1 的不同值</li>
<li>2D有许多局部极小值</li>
<li>以及一个大的搜索群空间</li>
<li>好的方法是马尔可夫随机场</li>
</ol>
</li>
</ol>
<h1 id="通过视差求深度"><a href="#通过视差求深度" class="headerlink" title="通过视差求深度"></a>通过视差求深度</h1><img src="/CV_img/13_8.png" style="zoom: ">

<ol>
<li>baseline 极线，平行于成像平面</li>
<li>X是物体</li>
<li>x和x’是向量</li>
<li>(baseline-(x-x’))/baseline=z-f/z</li>
<li>z为深度<h1 id="立体重建"><a href="#立体重建" class="headerlink" title="立体重建"></a>立体重建</h1></li>
</ol>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol>
<li>标定摄像机：标定内外参数</li>
<li>校正图像：将两个图像放到同一个平面上，且平行于baseline</li>
<li>计算平移量</li>
<li>估计深度</li>
</ol>
<h2 id="由结构光主动获得立体图"><a href="#由结构光主动获得立体图" class="headerlink" title="由结构光主动获得立体图"></a>由结构光主动获得立体图</h2>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第15讲</title>
    <url>/2020/01/20/%E8%A7%86%E8%A7%89%E7%AC%AC15%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="运动恢复结构-SFM"><a href="#运动恢复结构-SFM" class="headerlink" title="运动恢复结构 SFM"></a>运动恢复结构 SFM</h1><ol>
<li>目的：输入一对匹配点的图像坐标，输出这个点的三维坐标及相机内外参数(可能的话)。同时使得目标函数具有最小化重投影误差。</li>
<li>过程：<ol>
<li>特征检测与匹配</li>
<li>匹配每对图像之间的特征</li>
<li>用 RANSAC 优化匹配以估计各对之间的基本矩阵</li>
</ol>
</li>
</ol>
<h2 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h2><img src="/CV_img/15-1.png" style="zoom:80%">

<ol>
<li>目标是使重投影误差平方和最小</li>
<li>P(xi,Rj,tj)表示把Xi这个点投影到第j个相机。</li>
<li>Wij：=1代表三维点在图像中出现了；=0代表没出现。</li>
<li>解不唯一。</li>
</ol>
<h2 id="重复结构问题的解决"><a href="#重复结构问题的解决" class="headerlink" title="重复结构问题的解决"></a>重复结构问题的解决</h2><ol>
<li>预处理：删除不一致的场景图边缘</li>
<li>后处理：识别和更正重复的结构</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第16讲</title>
    <url>/2020/01/20/%E8%A7%86%E8%A7%89%E7%AC%AC16%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="立体视觉"><a href="#立体视觉" class="headerlink" title="立体视觉"></a>立体视觉</h1><p>通过多个角度拍摄的标定过 的图像，进行3D对象建模。###</p>
<h1 id="多视图立体视觉"><a href="#多视图立体视觉" class="headerlink" title="多视图立体视觉"></a>多视图立体视觉</h1><ol>
<li>需要多视图原因<ol>
<li>可能有某些区域的特写</li>
<li>某些表面在某些视图中缩小了</li>
<li>某些点可能在某些视图中完全消失。</li>
<li>多次测量同一个点可以减小误差。</li>
</ol>
</li>
</ol>
<h1 id="多基线立体视觉"><a href="#多基线立体视觉" class="headerlink" title="多基线立体视觉"></a>多基线立体视觉</h1><p>将几台相机矫正到同一共同平面上。可能有宽基线和扭曲问题。</p>
<h2 id="选择立体视图基线"><a href="#选择立体视图基线" class="headerlink" title="选择立体视图基线"></a>选择立体视图基线</h2><img src="/CV_img/16-1.png" height="5%" width="%5">

<img src="/CV_img/16-2.png" height="5%" width="%5">

<ol>
<li>基线太小导致深度误差大</li>
<li>基线太大大致搜索范围大，计算复杂度提高。</li>
</ol>
<h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><ol>
<li>选择参考视图</li>
<li>使用立体视图算法，但将其中双视图SSD换成SSSD(SUM SSD)</li>
</ol>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ol>
<li>只能给出深度图，不能给出对象模型</li>
<li>不适用于广泛分布的视图</li>
</ol>
<h1 id="照片一致性评分"><a href="#照片一致性评分" class="headerlink" title="照片一致性评分"></a>照片一致性评分</h1><h2 id="衡量函数"><a href="#衡量函数" class="headerlink" title="衡量函数"></a>衡量函数</h2><ol>
<li><p>SSD</p>
 <img src="/CV_img/16-3.png" height="5%" width="%5">
</li>
<li><p>SAD</p>
 <img src="/CV_img/16-4.png" height="5%" width="%5">
</li>
<li><p>ZNCC</p>
 <img src="/CV_img/16-5.png" height="5%" width="%5">

</li>
</ol>
<h1 id="平面扫描立体视觉"><a href="#平面扫描立体视觉" class="headerlink" title="平面扫描立体视觉"></a>平面扫描立体视觉</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><img src="/CV_img/16-6.png" height="5%" width="%5">

<ol>
<li><p>相机1系即世界坐标系，相机1为参考相机</p>
</li>
<li><p>深度平面</p>
 <img src="/CV_img/16-7.png" height="5%" width="%5">

<ol>
<li>其中n<sub>m</sub>为深度平面的法向量</li>
<li>平面表示为ax+by+cz+d=0</li>
<li>点到平面距离dm=&radic;a<sup>2</sup>+b<sup>2</sup>+c<sup>2</sup>?</li>
</ol>
</li>
<li><p>从参考相机Pref映射到深度平<br>面Πm，再映射到相机Pk的单应<br>映射为</p>
 <img src="/CV_img/16-8.png" height="5%" width="%5">

</li>
</ol>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><img src="/CV_img/16-9.png" height="5%" width="%5">

<h3 id="参考平面"><a href="#参考平面" class="headerlink" title="参考平面"></a>参考平面</h3><ol>
<li><p>与成像平面平行</p>
 <img src="/CV_img/16-10.png" height="5%" width="%5">
</li>
<li><p>其他方向</p>
 <img src="/CV_img/16-11.png" height="5%" width="%5">

</li>
</ol>
<h1 id="深度图融合"><a href="#深度图融合" class="headerlink" title="深度图融合"></a>深度图融合</h1><p>方法</p>
<ol>
<li>使用多基线方法计算一个深度图</li>
<li>体积融合</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第10讲</title>
    <url>/2020/01/20/%E8%A7%86%E8%A7%89%E7%AC%AC10%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="相机成像原理"><a href="#相机成像原理" class="headerlink" title="相机成像原理"></a>相机成像原理</h1><ol>
<li><p>为什么不使光圈尽可能小?<br> （1）使光线减少 （2）衍射影响</p>
</li>
<li><p>人的眼睛：瞳孔相当于光圈；视网膜上的感光细胞相当于胶片。</p>
<h2 id="相机模型"><a href="#相机模型" class="headerlink" title="相机模型"></a>相机模型</h2></li>
<li><p>投影建模</p>
 <img src="/CV_img/10_1.png" style="zoom:80%">
 1. 将相机近似为针孔模型
 2. 把小孔的位置设在原点
 3. 将图像平面放在投影中心COP的前面(为了得到正立的相)
 4. 相机向负z轴看去(右手坐标系下)</li>
<li><p>投影方程</p>
 <img src="/CV_img/10_2.png" style="zoom:80%">

<ol>
<li><p>不是线性变换—-&gt;采用3D齐次坐标。</p>
 <img src="/CV_img/10_3.png" style="zoom:80%"></li>
</ol>
</li>
<li><p>透视投影</p>
<ol>
<li><p>投影是使用齐次坐标的矩阵乘法：</p>
 <img src="/CV_img/10_4.png" style="zoom:80%">
</li>
<li><p>改变投影变换的吃尺度对变换没有影响</p>
 <img src="/CV_img/10_5.png" style="zoom:80%"></li>
</ol>
</li>
<li><p>正交投影（平行投影）</p>
<ol>
<li><p>是透视投影的特殊情况：当光学中心COP到投影平面PP的距离是无限的时候。（1/d = 0）</p>
 <img src="/CV_img/10_6.png" style="zoom:80%">
##  正交投影的变体</li>
</ol>
</li>
<li><p>缩放正交（弱透视）</p>
<p> 相当于在物体聚焦到角点前就将图像截获。</p>
 <img src="/CV_img/10_7.png" style="zoom:80%">

<p> 分两步: </p>
<ol>
<li>第一步：整个物体按平行于光轴的方向正交投影到经过物体质心并与图像平面平行的平面上。</li>
<li>第二步：再按透视模型投影到图像平面上，这一步实际是全局的缩放。</li>
</ol>
</li>
<li><p>仿射投影</p>
 <img src="/CV_img/10_8.png" style="zoom:80%">

<p> 分两步：</p>
<ol>
<li>仍把物体平行投影到过质心且与图象平面平行的平面上，不过这次的投影线不是平行于光轴，而是平行于光心C和物体质心G的连线CG；</li>
<li>再按透视模型投影到图象平面上。</li>
</ol>
</li>
<li><p>总结</p>
</li>
</ol>
<img src="/CV_img/10_9.png" style="zoom:80%">

<h2 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h2><ol>
<li><p>投影属性</p>
<ol>
<li><p>多对一：同一光线上的所有点映射到图像中的同一点。</p>
</li>
<li><p>点-&gt;点，线-&gt;线（通过角点的线变成一个点）</p>
</li>
<li><p>平面-&gt;平面（通过角点的平面变成一条线）</p>
</li>
<li><p>平行线在消失点汇合</p>
<ol>
<li>每个方向在空间中都有他自己的消失点，但平行于图像平面的平行线保持平行。</li>
</ol>
<img src="/CV_img/10_10.png" style="zoom:80%">
##  相机参数
现在我们要将世界坐标系中的一个点投影到相机坐标系中。我们需要知道相机在世界坐标系中的位置和方向。然后透视投影到图像平面上以获得像素坐标。
</li>
</ol>
</li>
<li><p>相机内参数</p>
<ol>
<li>从世界坐标系原点到光心COP的平移变换T</li>
<li>描述相机方向的旋转变换R</li>
<li>焦距f、主点(x,y)、像素大小（sx,sy）</li>
</ol>
</li>
<li> <img src="/CV_img/10_11.png" style="zoom:80%">

<p> ·</p>
<p> ·</p>
 <img src="/CV_img/10_12.png" style="zoom:80%">

<p> 这个公式要从右向左看</p>
<ol>
<li>平移矩阵即是将相机原点与世界原点重合。</li>
<li>第二步旋转，是将相机坐标系的三个轴旋转到与世界坐标系坐标轴平行。</li>
<li>第三步是将世界坐标系中的三维点透过光心进行投影。</li>
<li>第四步是使用相机内参数将图像变成离散的坐标。</li>
<li><strong>注意</strong> 该公式中对投影变换进行了拆分，，一部分与内参数乘在了一起。</li>
</ol>
</li>
</ol>
<h2 id="外参数—让相机规范化"><a href="#外参数—让相机规范化" class="headerlink" title="外参数—让相机规范化"></a>外参数—让相机规范化</h2><ol>
<li><p>第一步 平移-c，将相机坐标系原点与世界坐标系原点重合。</p>
 <img src="/CV_img/10_15.png" style="zoom:80%">

<p> 其中c为相机坐标原点在世界坐标系中的坐标[[tx,ty,tz]].T</p>
</li>
<li><p>第二步 旋转R， 将相机坐标系的轴旋转到与世界坐标系轴平行。</p>
 <img src="/CV_img/10_16.png" style="zoom:80%">

</li>
</ol>
<h2 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h2><img src="/CV_img/10_17.png" style="zoom:80%">

<h2 id="投影矩阵"><a href="#投影矩阵" class="headerlink" title="投影矩阵"></a>投影矩阵</h2><img src="/CV_img/10_18.png" style="zoom:80%">

<p><strong>注：</strong></p>
<ol>
<li><p>平移的三个参数是相机原点在世界坐标系中的坐标。</p>
</li>
<li><p>旋转的三个参数是相机坐标系的坐标轴在用世界坐标系的方向向量来表达的向量坐标的转置。</p>
</li>
<li><p><strong>将投影矩阵乘开</strong></p>
</li>
</ol>
<img src="/CV_img/10_19.png" style="zoom:80%">

<img src="/CV_img/10_13.png" style="zoom:80%">

<h2 id="透视失真"><a href="#透视失真" class="headerlink" title="透视失真"></a>透视失真</h2><ol>
<li>梯形失真</li>
<li>仰拍导致。解决：移轴镜头</li>
<li>外侧列更大</li>
<li>镜头失真：枕型，桶型–&gt;由不完美镜头引起</li>
<li><strong>修正径向畸变</strong><img src="/CV_img/10_14.png" style="zoom:80%"></li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第11讲</title>
    <url>/2020/01/20/%E8%A7%86%E8%A7%89%E7%AC%AC11%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="创建全景图"><a href="#创建全景图" class="headerlink" title="创建全景图"></a>创建全景图</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><ol>
<li>从同一位置拍摄一系列图像。<strong>光心不动</strong></li>
<li>计算第二个图像与第一个映像之间的变换。</li>
<li>变换第二个图像与第一个图像部分重合</li>
<li>将二者融合在一起创建拼图。</li>
<li>多个图像重复上述过程</li>
</ol>
<img src="/CV_img/11_1.png" style="zoom:80%">
##  变换矩阵

<img src="/CV_img/11_2.png" style="zoom:80%">

<img src="/CV_img/11_3.png" style="zoom:80%">

<p>注：</p>
<ol>
<li>图像平面一般以主点为圆心。</li>
<li>相机1的坐标系为世界坐标系。<h2 id="360°全景图"><a href="#360°全景图" class="headerlink" title="360°全景图"></a>360°全景图</h2>使用拼图投影球</li>
</ol>
<img src="/CV_img/11_4.png" style="zoom:80%">

<p>注：</p>
<ol>
<li>球面坐标：弧长</li>
<li>s为投影球半径<h2 id="装配全景图"><a href="#装配全景图" class="headerlink" title="装配全景图"></a>装配全景图</h2></li>
<li>过程：拼接，融合，裁剪</li>
<li>问题：出现漂移</li>
<li>解决</li>
</ol>
<img src="/CV_img/11_5.png" style="zoom:80%">

<h2 id="图像融合"><a href="#图像融合" class="headerlink" title="图像融合"></a>图像融合</h2><ol>
<li><p>使用羽化</p>
<ol>
<li>窗口大小影响羽化效果。<ol>
<li>窗口大小为0和直接拼接一样</li>
<li>良好的窗口应该是平滑且没有虚影的。</li>
</ol>
</li>
</ol>
</li>
<li><p>金字塔混合<br> 使用拉普拉斯金子塔在各层次上融合，最终叠加。</p>
<p> 拉普拉斯金字塔</p>
 <img src="/CV_img/11_6.png" style="zoom:80%">
</li>
<li><p>Alpha混合</p>
<img src="/CV_img/11_7.png" style="zoom:80%">
</li>
<li><p>泊松图像编辑</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第12讲</title>
    <url>/2020/01/20/%E8%A7%86%E8%A7%89%E7%AC%AC12%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="点和线"><a href="#点和线" class="headerlink" title="点和线"></a>点和线</h1><h2 id="点和线的对偶性"><a href="#点和线的对偶性" class="headerlink" title="点和线的对偶性"></a>点和线的对偶性</h2><img src="/CV_img/12_1.png" style="zoom:70%">

<ol>
<li>对于线上的每一点P,有I·P=0    （面上一点同理）</li>
<li>由射线P1和P2决定的线I,有I=P1×P2</li>
<li>两条线I1和I2的交点P，有P=I1×I2</li>
</ol>
<h2 id="理想的点和线"><a href="#理想的点和线" class="headerlink" title="理想的点和线"></a>理想的点和线</h2><img src="/CV_img/12_2.png" style="zoom:70%">

<ol>
<li><p>理想点（无穷远点）</p>
<ol>
<li>P(x,y,0)平行于图像平面</li>
<li>有无限的图像坐标</li>
</ol>
</li>
<li><p>理想线</p>
<ol>
<li>I(a,b,0)平行于图像平面</li>
<li>对应于图像平面过主点的一条线</li>
<li>由ax+by=0组成的线</li>
</ol>
</li>
</ol>
<h2 id="面和点的对偶性"><a href="#面和点的对偶性" class="headerlink" title="面和点的对偶性"></a>面和点的对偶性</h2><ol>
<li>一个平面可以用四维向量表示</li>
<li>点和平面是对偶的：N·P=0</li>
<li>三点定义一个平面，三个平面定义一个点</li>
</ol>
<h1 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h1><img src="/CV_img/12_3.png" style="zoom:40%">

<h2 id="消失点-1D"><a href="#消失点-1D" class="headerlink" title="消失点 1D"></a>消失点 1D</h2><img src="/CV_img/12_4.png" style="zoom:40%">

<ol>
<li>消失点：<ol>
<li>是无穷处一个点的投影</li>
<li>通常投影到图像中的一个有限点</li>
</ol>
</li>
</ol>
<h2 id="消失点-2D"><a href="#消失点-2D" class="headerlink" title="消失点 2D"></a>消失点 2D</h2><img src="/CV_img/12_5.png" style="zoom:40%">
##  消失点 3D
<img src="/CV_img/12_6.png" style="zoom:40%">

<ol>
<li>特性<ol>
<li>任意两条平行线都有相同的消失点V</li>
<li>从光心C通过消失点V的射线与那些平行线平行</li>
<li>图像可能有多个消失点</li>
</ol>
</li>
</ol>
<h2 id="消失线"><a href="#消失线" class="headerlink" title="消失线"></a>消失线</h2><img src="/CV_img/12_7.png" style="zoom:40%">

<ol>
<li>平面上任意一组平行线都定义一个消失点</li>
<li>消失点的联合就是消失线(地平线)</li>
<li>不同平面可以定义不同的消失线</li>
</ol>
<h2 id="计算消失点"><a href="#计算消失点" class="headerlink" title="计算消失点"></a>计算消失点</h2><img src="/CV_img/12_8.png" style="zoom:40%">

<p>v = ΠP<sub>∞</sub></p>
<ol>
<li><p>解释：</p>
<ol>
<li>先得到一条射线Px，其中t是一个自由变化的系数，D是方向向量</li>
<li>将t-&gt;∞代入，得到P<sub>∞</sub></li>
<li>将P<sub>∞</sub>投影到成像平面</li>
</ol>
</li>
<li><p>特性：</p>
<ol>
<li>P<sub>∞</sub> 是无穷远处的一个点，v是其投影</li>
<li>仅取决于线的方向</li>
<li>平行线P<sub>0</sub>+tD和P<sub>1</sub>+tD相交于P<sub>∞</sub></li>
</ol>
</li>
</ol>
<ol start="2">
<li><img src="/CV_img/12_10.png" style="zoom:40%">
##  计算消失线


</li>
</ol>
<img src="/CV_img/12_9.png" style="zoom:40%">

<p>作平行于地面平面且过C的平面与投影平面的交线。</p>
<ol>
<li>特性<ol>
<li>I是通过C的水平平面与图像平面的交集</li>
<li>可以通过地面平面上的两组平行线计算I</li>
<li>所有与光心C同样高度的点投影到I上</li>
<li>提供了比较场景中对象高度的方法</li>
</ol>
</li>
</ol>
<h1 id="通过参照物测量高度"><a href="#通过参照物测量高度" class="headerlink" title="通过参照物测量高度"></a>通过参照物测量高度</h1><ol>
<li><p>交叉比—射影不变量</p>
 <img src="/CV_img/12_11.png" style="zoom:40%">
</li>
<li><p>测量高度</p>
 <img src="/CV_img/12_12.png" style="zoom:40%">
</li>
<li><p>实际</p>
 <img src="/CV_img/12_13.png" style="zoom:40%"></li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA习题笔记</title>
    <url>/2020/01/20/UVA%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="完整源代码见代码仓库"><a href="#完整源代码见代码仓库" class="headerlink" title="完整源代码见代码仓库"></a><a href="https://github.com/Cccceb/UvaCode">完整源代码见代码仓库</a></h2><h2 id="排序与检索"><a href="#排序与检索" class="headerlink" title="排序与检索"></a><a href="/2020/01/27/排序与检索">排序与检索</a></h2><h2 id="空间结构"><a href="#空间结构" class="headerlink" title="空间结构"></a><a href="/2020/01/20/空间结构/">空间结构</a></h2><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a><a href="/2020/01/20/带宽/">带宽</a></h2><h2 id="并行程序模拟"><a href="#并行程序模拟" class="headerlink" title="并行程序模拟"></a><a href="/2020/01/20/并行程序模拟/">并行程序模拟</a></h2><h2 id="集合栈计算机"><a href="#集合栈计算机" class="headerlink" title="集合栈计算机"></a><a href="/2020/01/20/集合栈计算机/">集合栈计算机</a></h2><h2 id="网格动物"><a href="#网格动物" class="headerlink" title="网格动物"></a><a href="/2020/01/20/网格动物/">网格动物</a></h2><h2 id="移动木块"><a href="#移动木块" class="headerlink" title="移动木块"></a><a href="/2020/01/20/移动木块/">移动木块</a></h2><h2 id="编辑书稿"><a href="#编辑书稿" class="headerlink" title="编辑书稿"></a><a href="/2020/01/20/编辑书稿/">编辑书稿</a></h2><h2 id="切断圆环链"><a href="#切断圆环链" class="headerlink" title="切断圆环链"></a><a href="/2020/01/22/切断圆环链/">切断圆环链</a></h2><h2 id="两亲性分子"><a href="#两亲性分子" class="headerlink" title="两亲性分子"></a><a href="/2020/01/29/两亲性分子/">两亲性分子</a></h2><h2 id="传说中的车"><a href="#传说中的车" class="headerlink" title="传说中的车"></a><a href="/2020/01/29/传说中的车/">传说中的车</a></h2><h2 id="和为0的4个值"><a href="#和为0的4个值" class="headerlink" title="和为0的4个值"></a><a href="/2020/01/29/和为0的4个值/">和为0的4个值</a></h2><h2 id="素数环"><a href="#素数环" class="headerlink" title="素数环"></a><a href="/2020/01/24/素数环/">素数环</a></h2><h2 id="多米诺效应"><a href="#多米诺效应" class="headerlink" title="多米诺效应"></a><a href="/2020/01/22/多米诺效应/">多米诺效应</a></h2><h2 id="唯一的雪花"><a href="#唯一的雪花" class="headerlink" title="唯一的雪花"></a><a href="/2020/01/29/唯一的雪花/">唯一的雪花</a></h2><h2 id="滑动窗口最小问题"><a href="#滑动窗口最小问题" class="headerlink" title="滑动窗口最小问题"></a><a href="/2020/01/29/滑动窗口最小问题/">滑动窗口最小问题</a></h2><h2 id="煎饼"><a href="#煎饼" class="headerlink" title="煎饼"></a><a href="/2020/01/29/煎饼/">煎饼</a></h2><h2 id="邮件传输代理的交互"><a href="#邮件传输代理的交互" class="headerlink" title="邮件传输代理的交互"></a><a href="/2020/01/20/邮件传输代理的交互/">邮件传输代理的交互</a></h2><h2 id="倒水问题"><a href="#倒水问题" class="headerlink" title="倒水问题"></a><a href="/2020/01/23/倒水问题/">倒水问题</a></h2><h2 id="困难的串"><a href="#困难的串" class="headerlink" title="困难的串"></a><a href="/2020/01/23/困难的串/">困难的串</a></h2><h2 id="战场"><a href="#战场" class="headerlink" title="战场"></a><a href="/2020/01/24/战场/">战场</a></h2><h2 id="最大连续和问题"><a href="#最大连续和问题" class="headerlink" title="最大连续和问题"></a><a href="/2020/01/24/最大连续和问题/">最大连续和问题</a></h2><h2 id="流水线调度"><a href="#流水线调度" class="headerlink" title="流水线调度"></a><a href="/2020/01/23/流水线调度/">流水线调度</a></h2><h2 id="黄金图形"><a href="#黄金图形" class="headerlink" title="黄金图形"></a><a href="/2020/01/20/黄金图形/">黄金图形</a></h2><h2 id="联合国大楼"><a href="#联合国大楼" class="headerlink" title="联合国大楼"></a><a href="/2020/01/29/联合国大楼/">联合国大楼</a></h2><h2 id="Abbott的复仇"><a href="#Abbott的复仇" class="headerlink" title="Abbott的复仇"></a><a href="/2020/01/20/Abbott的复仇/">Abbott的复仇</a></h2><h2 id="Shuffle的播放记录"><a href="#Shuffle的播放记录" class="headerlink" title="Shuffle的播放记录"></a><a href="/2020/02/04/Shuffle的播放记录/">Shuffle的播放记录</a></h2><h2 id="不公平竞赛"><a href="#不公平竞赛" class="headerlink" title="不公平竞赛"></a><a href="/2020/02/04/不公平竞赛/">不公平竞赛</a></h2><h2 id="理想路径"><a href="#理想路径" class="headerlink" title="理想路径"></a><a href="/2020/02/16/理想路径/">理想路径</a></h2><h2 id="不无聊的序列"><a href="#不无聊的序列" class="headerlink" title="不无聊的序列"></a><a href="/2020/02/04/不无聊的序列/">不无聊的序列</a></h2><h2 id="与非门电路"><a href="#与非门电路" class="headerlink" title="与非门电路"></a><a href="/2020/02/04/与非门电路/">与非门电路</a></h2><h2 id="奇怪的气球膨胀"><a href="#奇怪的气球膨胀" class="headerlink" title="奇怪的气球膨胀"></a><a href="/2020/02/04/奇怪的气球膨胀/">奇怪的气球膨胀</a></h2><h2 id="平均值"><a href="#平均值" class="headerlink" title="平均值"></a><a href="/2020/02/04/平均值/">平均值</a></h2><h2 id="抄书"><a href="#抄书" class="headerlink" title="抄书"></a><a href="/2020/02/04/抄书/">抄书</a></h2><h2 id="环形跑道"><a href="#环形跑道" class="headerlink" title="环形跑道"></a><a href="/2020/02/04/环形跑道/">环形跑道</a></h2><h2 id="防线"><a href="#防线" class="headerlink" title="防线"></a><a href="/2020/02/04/防线/">防线</a></h2><h2 id="划分成回文串"><a href="#划分成回文串" class="headerlink" title="划分成回文串"></a><a href="/2020/02/16/划分成回文串/">划分成回文串</a></h2><h2 id="劲歌金曲"><a href="#劲歌金曲" class="headerlink" title="劲歌金曲"></a><a href="/2020/02/16/劲歌金曲/">劲歌金曲</a></h2><h2 id="单向TSP"><a href="#单向TSP" class="headerlink" title="单向TSP"></a><a href="/2020/02/16/单向TSP/">单向TSP</a></h2><h2 id="城市里的间谍"><a href="#城市里的间谍" class="headerlink" title="城市里的间谍"></a><a href="/2020/02/16/城市里的间谍/">城市里的间谍</a></h2><h2 id="巴比伦塔"><a href="#巴比伦塔" class="headerlink" title="巴比伦塔"></a><a href="/2020/02/16/巴比伦塔/">巴比伦塔</a></h2><h2 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a><a href="/2020/02/16/旅行/">旅行</a></h2><h2 id="照明系统设计"><a href="#照明系统设计" class="headerlink" title="照明系统设计"></a><a href="/2020/02/16/照明系统设计/">照明系统设计</a></h2><h2 id="颜色的长度"><a href="#颜色的长度" class="headerlink" title="颜色的长度"></a><a href="/2020/02/16/颜色的长度/">颜色的长度</a></h2><h2 id="万圣节后的早晨"><a href="#万圣节后的早晨" class="headerlink" title="万圣节后的早晨"></a><a href="/2020/01/20/万圣节后的早晨/">万圣节后的早晨</a></h2><h2 id="分数拆分"><a href="#分数拆分" class="headerlink" title="分数拆分"></a><a href="/2020/01/24/分数拆分/">分数拆分</a></h2><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a><a href="/2020/01/20/二叉树的层序遍历/">二叉树的层序遍历</a></h2><h2 id="二叉树的重建"><a href="#二叉树的重建" class="headerlink" title="二叉树的重建"></a><a href="/2020/01/20/二叉树的重建/">二叉树的重建</a></h2><h2 id="修改天平"><a href="#修改天平" class="headerlink" title="修改天平"></a><a href="/2020/01/20/修改天平/">修改天平</a></h2><h2 id="八数码"><a href="#八数码" class="headerlink" title="八数码"></a><a href="/2020/01/20/八数码/">八数码</a></h2><h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a><a href="/2020/01/20/八皇后问题/">八皇后问题</a></h2><h2 id="反片语"><a href="#反片语" class="headerlink" title="反片语"></a><a href="/2020/01/20/反片语/">反片语</a></h2><h2 id="古代象形符号"><a href="#古代象形符号" class="headerlink" title="古代象形符号"></a><a href="/2020/01/20/古代象形符号/">古代象形符号</a></h2><h2 id="周期串"><a href="#周期串" class="headerlink" title="周期串"></a><a href="/2020/01/20/周期串/">周期串</a></h2><h2 id="Gergovia的酒交易"><a href="#Gergovia的酒交易" class="headerlink" title="Gergovia的酒交易"></a><a href="/2020/01/29/Gergovia的酒交易/">Gergovia的酒交易</a></h2><h2 id="团体队列"><a href="#团体队列" class="headerlink" title="团体队列"></a><a href="/2020/01/20/团体队列/">团体队列</a></h2><h2 id="图书管理系统"><a href="#图书管理系统" class="headerlink" title="图书管理系统"></a><a href="/2020/01/20/图书管理系统/">图书管理系统</a></h2><h2 id="在Web中搜索"><a href="#在Web中搜索" class="headerlink" title="在Web中搜索"></a><a href="/2020/01/20/在Web中搜索/">在Web中搜索</a></h2><h2 id="埃及分数"><a href="#埃及分数" class="headerlink" title="埃及分数"></a><a href="/2020/01/20/埃及分数/">埃及分数</a></h2><h2 id="城市正视图"><a href="#城市正视图" class="headerlink" title="城市正视图"></a><a href="/2020/01/20/城市正视图/">城市正视图</a></h2><h2 id="天平难题"><a href="#天平难题" class="headerlink" title="天平难题"></a><a href="/2020/01/20/天平难题/">天平难题</a></h2><h2 id="安迪的第一本字典"><a href="#安迪的第一本字典" class="headerlink" title="安迪的第一本字典"></a><a href="/2020/01/20/安迪的第一本字典/">安迪的第一本字典</a></h2><h2 id="宝箱"><a href="#宝箱" class="headerlink" title="宝箱"></a><a href="/2020/01/20/宝箱/">宝箱</a></h2><h2 id="小球下落"><a href="#小球下落" class="headerlink" title="小球下落"></a><a href="/2020/01/20/小球下落/">小球下落</a></h2><h2 id="巡逻机器人"><a href="#巡逻机器人" class="headerlink" title="巡逻机器人"></a><a href="/2020/01/20/巡逻机器人/">巡逻机器人</a></h2><h2 id="循环小数"><a href="#循环小数" class="headerlink" title="循环小数"></a><a href="/2020/01/20/循环小数/">循环小数</a></h2><h2 id="快速幂计算"><a href="#快速幂计算" class="headerlink" title="快速幂计算"></a><a href="/2020/01/20/快速幂计算/">快速幂计算</a></h2><h2 id="打印队列"><a href="#打印队列" class="headerlink" title="打印队列"></a><a href="/2020/01/20/打印队列/">打印队列</a></h2><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><a href="/2020/01/20/数据库/">数据库</a></h2><h2 id="旋转游戏"><a href="#旋转游戏" class="headerlink" title="旋转游戏"></a><a href="/2020/01/20/旋转游戏/">旋转游戏</a></h2><h2 id="木块问题"><a href="#木块问题" class="headerlink" title="木块问题"></a><a href="/2020/01/20/木块问题/">木块问题</a></h2><h2 id="树"><a href="#树" class="headerlink" title="树"></a><a href="/2020/01/20/树/">树</a></h2><h2 id="消防车"><a href="#消防车" class="headerlink" title="消防车"></a><a href="/2020/01/20/消防车/">消防车</a></h2><h2 id="破坏正方形"><a href="#破坏正方形" class="headerlink" title="破坏正方形"></a><a href="/2020/01/20/破坏正方形/">破坏正方形</a></h2><h2 id="S树"><a href="#S树" class="headerlink" title="S树"></a><a href="/2020/01/20/S树/">S树</a></h2><h2 id="Tex中的引导"><a href="#Tex中的引导" class="headerlink" title="Tex中的引导"></a><a href="/2020/01/20/Tex中的引导/">Tex中的引导</a></h2><h2 id="UnixIS命令"><a href="#UnixIS命令" class="headerlink" title="UnixIS命令"></a><a href="/2020/01/20/UnixIS命令/">UnixIS命令</a></h2>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>周期串</title>
    <url>/2020/01/20/%E5%91%A8%E6%9C%9F%E4%B8%B2/</url>
    <content><![CDATA[<hr>
<p>tag: hide</p>
<hr>
<h1 id="uav-455-周期串"><a href="#uav-455-周期串" class="headerlink" title="uav 455 周期串"></a>uav 455 周期串</h1><p>如果一个字符串可以由某个长度为kkk 的字符串重复多次得到，则称该串以kkk 为周期。例如，abcabcabcabcabcabcabcabcabcabcabcabc 以333 为周期（注意，它也以666 和121212 为周期）。</p>
<p>输入一个长度不超过808080 的字符串，输出其最小周期。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  #include&lt;iostream&gt;</span><br><span class="line">  #include&lt;stdio.h&gt;</span><br><span class="line">  #include&lt;string.h&gt;</span><br><span class="line"># pragma warning(disable:4996)</span><br><span class="line">  # define LOCAL</span><br><span class="line">  # ifdef LOCAL</span><br><span class="line">  FILE *fin &#x3D; freopen(&quot;习题3-8in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">  FILE *fout &#x3D; freopen(&quot;习题3-8out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">  # endif </span><br><span class="line">  using namespace std;</span><br><span class="line">  int main()</span><br><span class="line">  &#123;</span><br><span class="line">  	int t; cin &gt;&gt; t;</span><br><span class="line">  	char s[85];</span><br><span class="line">  	while (t--)</span><br><span class="line">  	&#123;</span><br><span class="line">  		memset(s, 0, sizeof(s));</span><br><span class="line">  		scanf(&quot;%s&quot;, s);</span><br><span class="line">  		int len &#x3D; strlen(s);</span><br><span class="line">  		int j;</span><br><span class="line">  		for (int i &#x3D; 1; i &lt;&#x3D; len; ++i)</span><br><span class="line">  			if (len%i &#x3D;&#x3D; 0)&#x2F;&#x2F;说明长度i可以作为一个循环节</span><br><span class="line">  			&#123;</span><br><span class="line">  				for (j &#x3D; i; j &lt;&#x3D; len; j++)</span><br><span class="line">  					if (s[j] !&#x3D; s[j%i])&#x2F;&#x2F;之后都和0-i-1的字符串来比较</span><br><span class="line">  						break;</span><br><span class="line">  				if (j &#x3D;&#x3D; len)</span><br><span class="line">  				&#123;</span><br><span class="line">  					cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">  					break;</span><br><span class="line">  				&#125;</span><br><span class="line">  			&#125;</span><br><span class="line">  		if (t)cout &lt;&lt; endl;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>修改天平</title>
    <url>/2020/01/20/%E4%BF%AE%E6%94%B9%E5%A4%A9%E5%B9%B3/</url>
    <content><![CDATA[<h1 id="uva12166-修改天平-括号表示法给出树"><a href="#uva12166-修改天平-括号表示法给出树" class="headerlink" title="uva12166 修改天平    (括号表示法给出树)"></a>uva12166 修改天平    (括号表示法给出树)</h1><p>给出一个深度不超过16的二叉树，代表一个天平。每根杆都悬挂在中间，每个秤砣的重量已知。至少修改多少个秤砣的重量才能让天平平衡？</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>思考如何使得修改的天平最少：保证让总重量最多的秤砣不变。</li>
<li>用sum记录总的秤砣个数，用base记录每个对应重量的秤砣数。注意秤砣重量与所在高度有关，重w的秤砣在depth深处的总重量为w&lt;&lt;depth</li>
<li>括号表示法给出树的结构可以参考本题</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>```</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
# pragma warning(disable:4996)
# define LOCAL
# ifdef LOCAL
FILE *fin = freopen(&quot;习题6-6in.txt&quot;, &quot;r&quot;, stdin);
FILE *fout = freopen(&quot;习题6-6out.txt&quot;, &quot;w&quot;, stdout);
# endif 
using namespace std;
int T;
string s;
int sum;
map&lt;long long, int&gt; base;
void dfs(int depth, int p, int e) {
    if (s[p] == &apos;[&apos;) {
    int not_ok = 0;
    for (int i = p + 1; i != e; i++) {
        if (s[i] == &apos;[&apos;) not_ok++;
        if (s[i] == &apos;]&apos;) not_ok--;
        //注意此处脱括号的方法非常灵性
        if (!not_ok&amp;&amp;s[i] == &apos;,&apos;) {
            dfs(depth + 1, p + 1, i - 1);
            dfs(depth + 1, i + 1, e - 1);
        }
    }
}
else {
    long long w = 0;
    for (int i = p; i &lt;= e; i++)
        w = w * 10 + s[i] - &apos;0&apos;;
    ++sum;
    ++base[w &lt;&lt; depth];//sum统计砝码总数量，base[w&lt;&lt;depth]统计该总重量对应的砝码个数

}
}
int main() {
cin &gt;&gt; T;
while (T--)
{
    cin &gt;&gt; s;
    sum = 0;
    base.clear();
    dfs(0, 0, s.length() - 1);
    int maxn = 0;
    for (auto it = base.begin(); it != base.end(); it++)
        maxn = max(maxn, it-&gt;second);
    cout &lt;&lt; sum - maxn &lt;&lt; endl;
}
}</code></pre>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>在Web中搜索</title>
    <url>/2020/01/20/%E5%9C%A8Web%E4%B8%AD%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="uva-1597-在web中搜索"><a href="#uva-1597-在web中搜索" class="headerlink" title="uva 1597 在web中搜索"></a>uva 1597 在web中搜索</h1><p>输入nnn篇文章和mmm个请求（n&lt;100，m≤50000n &lt; 100\text{，}m \leq 50000n&lt;100，m≤50000），每个请求都是444种格式之一。</p>
<p>A: 找包含关键字A的文章。</p>
<p>A AND B 找同时包含关键字A和B的文章。</p>
<p>A OR B 找包含关键字A或B的文章。</p>
<p>NOT A 找不包含关键字A的文章。</p>
<p>处理询问时需要对每篇文章输出证据。前3种询问输出所有至少包含一个关键字的行。第4种询问输出不包含A的整篇文章。关键字只由小写字母组成，查找时忽略大小写。每行不超过不超过80字符，一共不超过1500行。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>主要的STL是一个map&lt;string,set<Node>&gt; 用来存储每个单词出现的段号和行号。vector<string> txt[i]来存储第i段的若干句子，一句一句的存。</li>
<li>对于AND指令，需要n2次查找两个单词出现的段落和行号，只有当两个单词出现的段落一致的时候，才输出</li>
<li>OR指令同理</li>
<li>NOT需要循环所有的段落，对于A出现的段落集合中不包括的段，将它防在答案集合中<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line"># pragma warning(disable:4996)</span><br><span class="line"># define LOCAL</span><br><span class="line"># ifdef LOCAL</span><br><span class="line">FILE *fin &#x3D; freopen(&quot;习题5-10in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">FILE *fout &#x3D; freopen(&quot;习题5-10out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line"># endif </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; txt[105];</span><br><span class="line">map&lt;string, set&lt;int&gt;&gt; which_pa;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int p;</span><br><span class="line">	int r;</span><br><span class="line">	node(int p, int r) :p(p), r(r) &#123;&#125;</span><br><span class="line">	bool operator &lt;(const node&amp;a) const &#123;</span><br><span class="line">		return p &lt; a.p || p &#x3D;&#x3D; a.p&amp;&amp;r &lt; a.r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, set&lt;node&gt;&gt; words_in_where;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	string s;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n); getchar();</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">		while (getline(cin, s) &amp;&amp; s !&#x3D; &quot;**********&quot;) &#123;</span><br><span class="line">			txt[i].push_back(s);</span><br><span class="line">			string r;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; s.length(); j++) &#123;</span><br><span class="line">				if (isalpha(s[j])) r +&#x3D; tolower(s[j]);</span><br><span class="line">				else &#123;</span><br><span class="line">					if (!r.empty()) &#123;</span><br><span class="line">						words_in_where[r].insert(node(i, txt[i].size() - 1));</span><br><span class="line">						which_pa[r].insert(i);</span><br><span class="line">					&#125;</span><br><span class="line">					r.clear();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	scanf(&quot;%d&quot;, &amp;m); getchar();</span><br><span class="line">	for (int ff &#x3D; 0; ff &lt; m; ff++) &#123;</span><br><span class="line">		getline(cin, s);</span><br><span class="line">		int orx;</span><br><span class="line">		&#x2F;&#x2F;cout &lt;&lt; endl &lt;&lt; s &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">		if ((orx &#x3D; s.find(&quot; AND &quot;)) !&#x3D; string::npos) &#123;</span><br><span class="line">			string a &#x3D; s.substr(0, orx);</span><br><span class="line">			string b &#x3D; s.substr(orx + 5);</span><br><span class="line">			&#x2F;&#x2F;	cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">			set&lt;node&gt; aw &#x3D; words_in_where[a];</span><br><span class="line">			set&lt;node&gt; bw &#x3D; words_in_where[b];</span><br><span class="line">			set&lt;node&gt; ans;</span><br><span class="line">			ans.clear();</span><br><span class="line">			if (a &#x3D;&#x3D; b) &#123;</span><br><span class="line">				for (set&lt;node&gt;::iterator it &#x3D; aw.begin(); it !&#x3D; aw.end(); it++)</span><br><span class="line">					ans.insert(*it);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				for (set&lt;node&gt;::iterator it &#x3D; aw.begin(); it !&#x3D; aw.end(); it++)</span><br><span class="line">					for (set&lt;node&gt;::iterator id &#x3D; bw.begin(); id !&#x3D; bw.end(); id++)</span><br><span class="line">						if ((*it).p &#x3D;&#x3D; (*id).p) &#123;</span><br><span class="line">							ans.insert(*it);</span><br><span class="line">							ans.insert(*id);</span><br><span class="line">						&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (ans.empty()) &#123;</span><br><span class="line">				cout &lt;&lt; &quot;Sorry, I found nothing.&quot; &lt;&lt; endl &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			int k &#x3D; ans.begin()-&gt;p;</span><br><span class="line">			for (set&lt;node&gt;::iterator it &#x3D; ans.begin(); it !&#x3D; ans.end(); it++)</span><br><span class="line">			&#123;</span><br><span class="line">				int p &#x3D; (*it).p;</span><br><span class="line">				int r &#x3D; (*it).r;</span><br><span class="line">				if (k !&#x3D; p) &#123;</span><br><span class="line">					cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;</span><br><span class="line">					k &#x3D; p;</span><br><span class="line">				&#125;</span><br><span class="line">				cout &lt;&lt; txt[p][r] &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else if ((orx &#x3D; s.find(&quot; OR &quot;)) !&#x3D; string::npos) &#123;</span><br><span class="line">			string a &#x3D; s.substr(0, orx);</span><br><span class="line">			string b &#x3D; s.substr(orx + 4);</span><br><span class="line">			&#x2F;&#x2F;cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">			set&lt;node&gt; aw &#x3D; words_in_where[a];</span><br><span class="line">			set&lt;node&gt; bw &#x3D; words_in_where[b];</span><br><span class="line">			set&lt;node&gt; ans;</span><br><span class="line">			ans.clear();</span><br><span class="line">			if (a &#x3D;&#x3D; b) &#123;</span><br><span class="line">				for (set&lt;node&gt;::iterator it &#x3D; aw.begin(); it !&#x3D; aw.end(); it++) &#123;</span><br><span class="line">					ans.insert(*it);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				for (set&lt;node&gt;::iterator it &#x3D; aw.begin(); it !&#x3D; aw.end(); it++)</span><br><span class="line">					ans.insert(*it);</span><br><span class="line">				for (set&lt;node&gt;::iterator id &#x3D; bw.begin(); id !&#x3D; bw.end(); id++)</span><br><span class="line">					ans.insert(*id);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (ans.empty()) &#123;</span><br><span class="line">				cout &lt;&lt; &quot;Sorry, I found nothing.&quot; &lt;&lt; endl &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			int k &#x3D; ans.begin()-&gt;p;</span><br><span class="line">			for (set&lt;node&gt;::iterator it &#x3D; ans.begin(); it !&#x3D; ans.end(); it++)</span><br><span class="line">			&#123;</span><br><span class="line">				int p &#x3D; (*it).p;</span><br><span class="line">				int r &#x3D; (*it).r;</span><br><span class="line">				if (k !&#x3D; p) &#123;</span><br><span class="line">					cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;</span><br><span class="line">					k &#x3D; p;</span><br><span class="line">				&#125;</span><br><span class="line">				cout &lt;&lt; txt[p][r] &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (s[0]&#x3D;&#x3D;&#39;N&#39;) &#123;</span><br><span class="line">			string no &#x3D; s.substr(4);</span><br><span class="line">			&#x2F;&#x2F;cout &lt;&lt; no &lt;&lt; endl;</span><br><span class="line">			bool flag &#x3D; false;</span><br><span class="line">			bool first &#x3D; true;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">				if (!which_pa[no].count(i)) &#123;</span><br><span class="line">					if (first) first &#x3D; false; else cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;</span><br><span class="line">					for (int j &#x3D; 0; j &lt; txt[i].size(); j++)</span><br><span class="line">						cout &lt;&lt; txt[i][j] &lt;&lt; endl;</span><br><span class="line">					flag &#x3D; true;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (flag) cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">			else cout &lt;&lt; &quot;Sorry, I found nothing.&quot; &lt;&lt; endl &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			&#x2F;&#x2F;cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">			if (!words_in_where.count(s)) &#123;</span><br><span class="line">				cout &lt;&lt; &quot;Sorry, I found nothing.&quot; &lt;&lt; endl &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;##    ##  </span><br><span class="line">			int k &#x3D; words_in_where[s].begin()-&gt;p;</span><br><span class="line">			for (set&lt;node&gt;::iterator it &#x3D; words_in_where[s].begin(); it !&#x3D; words_in_where[s].end(); it++) &#123;</span><br><span class="line">				int p &#x3D; (*it).p;</span><br><span class="line">				int r &#x3D; (*it).r;</span><br><span class="line">				if (k !&#x3D; p) &#123;</span><br><span class="line">					cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;</span><br><span class="line">					k &#x3D; p;</span><br><span class="line">				&#125;</span><br><span class="line">				cout &lt;&lt; txt[p][r] &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;if (first) cout &lt;&lt; &quot;Sorry, I found nothing.&quot; &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>巡逻机器人</title>
    <url>/2020/01/20/%E5%B7%A1%E9%80%BB%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
    <content><![CDATA[<h1 id="uva1600-巡逻机器人"><a href="#uva1600-巡逻机器人" class="headerlink" title="uva1600 巡逻机器人"></a>uva1600 巡逻机器人</h1><p>本题有t组数据，每组数据包含一个m*n的01矩阵，0表示能走，1表示有一个障碍物。机器人能往上下左右四个方向走动.它要从(1,1)到(m,n),可以连续翻越k个障碍物,求它从(1,1)到(m,n)的最短路径.如果不能到达输出”-1”.</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>本题基础是一个bfs，附加可以跳跃0的条件。</li>
<li>对无权图进行bfs的时候，走到每一个点时的步数都是一定的，所以对于每个点，应该让能够跨越障碍的机会越多越好，所以Node节点中应该包含(r,c,k,step)其中k为到达(r,c)位置时剩余的跨越障碍的机会，step为最小步数。(※如果只需要知道步数而不需要路径，则将其包在结构体里即可)<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   #include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;习题6-5in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;习题6-5out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   int n, x, y, k;</span><br><span class="line">   int g[20][20];</span><br><span class="line">   struct node &#123;</span><br><span class="line">   	int r, c, k, step;</span><br><span class="line">   </span><br><span class="line">   	node(int r, int c, int k, int step &#x3D; 0) :r(r), c(c), k(k), step(step) &#123;&#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   int step[20][20];</span><br><span class="line">   int dr[] &#x3D; &#123; 1, 0, -1, 0 &#125;;</span><br><span class="line">   int dc[] &#x3D; &#123; 0, 1, 0, -1 &#125;;</span><br><span class="line">   int min_step;</span><br><span class="line">   void bfs() &#123;</span><br><span class="line">   	queue&lt;node&gt;q;</span><br><span class="line">   	q.push(node(0, 0, k));</span><br><span class="line">   	int block &#x3D; 0;</span><br><span class="line">   	while (!q.empty()) &#123;</span><br><span class="line">   		node u &#x3D; q.front(); q.pop();</span><br><span class="line">   </span><br><span class="line">   		if (u.r &#x3D;&#x3D; x - 1 &amp;&amp; u.c &#x3D;&#x3D; y - 1) &#123;</span><br><span class="line">   			min_step &#x3D; u.step;</span><br><span class="line">   			break;</span><br><span class="line">   		&#125;</span><br><span class="line">   		for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">   			int r &#x3D; u.r + dr[i], c &#x3D; u.c + dc[i];</span><br><span class="line">   			if (r &gt;&#x3D; 0 &amp;&amp; r &lt; x&amp;&amp;c &gt;&#x3D; 0 &amp;&amp; c &lt; y) &#123;</span><br><span class="line">   				if (step[r][c] &lt; u.k) &#123;&#x2F;&#x2F;u.k是走到step[r][c]处，还剩余的跳过障碍的机会，所以要保留大的</span><br><span class="line">   					step[r][c] &#x3D; u.k;</span><br><span class="line">   				&#125;</span><br><span class="line">   				else continue;&#x2F;&#x2F;如果step[r][c]更大，说明目前正在走的路不是最好的(因为bfs走到每个节点的步数是一定的</span><br><span class="line">   							  &#x2F;&#x2F;所以剩余的跨越障碍的次数越多越好),不需要再走下去，所以不入队)</span><br><span class="line">   				if (g[r][c] &#x3D;&#x3D; 0) q.push(node(r, c, k, u.step + 1));</span><br><span class="line">   				else if(u.k) q.push(node(r, c, u.k - 1, u.step + 1));</span><br><span class="line">   			&#125;</span><br><span class="line">   		&#125;</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   int main() &#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">while (n--) &#123;</span><br><span class="line"></span><br><span class="line">	memset(g, 0, sizeof(g));</span><br><span class="line">	memset(step, -1, sizeof(step));</span><br><span class="line">	cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	cin &gt;&gt; k;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; x; i++)</span><br><span class="line">		for (int j &#x3D; 0; j &lt; y; j++)</span><br><span class="line">			cin &gt;&gt; g[i][j];</span><br><span class="line">	min_step &#x3D; 999;</span><br><span class="line">	bfs();</span><br><span class="line">	min_step &#x3D;&#x3D; 999 ? cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl:cout &lt;&lt; min_step &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>循环小数</title>
    <url>/2020/01/20/%E5%BE%AA%E7%8E%AF%E5%B0%8F%E6%95%B0/</url>
    <content><![CDATA[<h1 id="UVA-202-循环小数"><a href="#UVA-202-循环小数" class="headerlink" title="UVA 202 循环小数"></a>UVA 202 循环小数</h1><p>输入整数aaa 和bbb （0≤a ≤3000,1≤b ≤3000），输出a/b的循环小数表示以及循环节的长度。例如a =5，b =43 小数表示为0.(116279069767441860465)，循环节长度为21。 补充： 如果循环节超过50位，就在第50位后打省略号（三个点，就像“…”）</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>要模拟手算，以得到任意位小数的结果</li>
<li>计算小数的过程中，如果发现同一个余数出现了两次，那么就可以认为出现了循环节。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   &#x2F;&#x2F;被除数出现重复，那么出现了循环节</span><br><span class="line">   const int maxn &#x3D; 100000 + 5;</span><br><span class="line">   </span><br><span class="line">   int a, b;</span><br><span class="line">   int vis[maxn], res[maxn];</span><br><span class="line">   </span><br><span class="line">   int main() &#123;</span><br><span class="line">while (scanf(&quot;%d%d&quot;, &amp;a, &amp;b) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">	memset(vis, -1, sizeof(vis));</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;※这样做可以得到所有小数</span><br><span class="line">	&#x2F;&#x2F;vis用来确定是否出现循环，res存小数部分</span><br><span class="line">	&#x2F;&#x2F;本题特殊在同一个余数出现两次，那么可以认为出现循环节</span><br><span class="line">	int c &#x3D; a % b, cnt &#x3D; 0;</span><br><span class="line">	c *&#x3D; 10;</span><br><span class="line">	while (vis[c] &#x3D;&#x3D; -1) &#123;</span><br><span class="line">		res[cnt] &#x3D; c &#x2F; b;</span><br><span class="line">		vis[c] &#x3D; cnt++;</span><br><span class="line">		c %&#x3D; b;</span><br><span class="line">		c *&#x3D; 10;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	int sta_pos &#x3D; vis[c];</span><br><span class="line">	printf(&quot;%d&#x2F;%d &#x3D; %d.&quot;, a, b, a &#x2F; b);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; sta_pos; i++) &#123;</span><br><span class="line">		printf(&quot;%d&quot;, res[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;(&quot;);</span><br><span class="line">	if (cnt - sta_pos &lt;&#x3D; 50) &#123;</span><br><span class="line">		for (int i &#x3D; sta_pos; i &lt; cnt; i++) &#123;</span><br><span class="line">			printf(&quot;%d&quot;, res[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		for (int i &#x3D; sta_pos; i &lt; sta_pos + 50; i++) &#123;</span><br><span class="line">			printf(&quot;%d&quot;, res[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;...&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;)\n&quot;);</span><br><span class="line">	printf(&quot;   %d &#x3D; number of digits in repeating cycle\n\n&quot;, cnt - sta_pos);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转游戏</title>
    <url>/2020/01/20/%E6%97%8B%E8%BD%AC%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="UVA-1343-旋转游戏"><a href="#UVA-1343-旋转游戏" class="headerlink" title="UVA 1343 旋转游戏"></a>UVA 1343 旋转游戏</h1><img src="/img_UVA习题笔记/1.png">


<p>现给定一个初始状态，请使用最少的操作次数，使 “# ” 形棋盘最中间的 888 个格子里的数字相同。输入包括不超过 303030 组测试数据。每个测试数据只包括一行，包含 242424 个整数，每相邻两个整数之间用 111 个空格隔开，表示这个 “# ” 形棋盘的初始状态。（这些整数的排列顺序是从上至下，同一行的从左至右。例如 1 1 1 1 3 2 3 2 3 1 3 2 2 3 1 2 2 2 3 1 2 1 3 3\text{1 1 1 1 3 2 3 2 3 1 3 2 2 3 1 2 2 2 3 1 2 1 3 3}1 1 1 1 3 2 3 2 3 1 3 2 2 3 1 2 2 2 3 1 2 1 3 3 表示图 111 最左边的状态。）每两组测试数据之间没有换行符。输入文件以一行 000 结束。对于每组测试数据，输出两行。第一行用字符 A∼H\text{A}\sim \text{H}A∼H 输出操作的方法，每两个操作字符之间没有空格分开，如果不需要任何步数，输出 No moves needed。第二行输出最终状态中最中间的 888 个格子里的数字。如果有多组解，输出操作次数最少的一组解；如果仍有多组解，输出字典序最小的一组。任意相邻两组测试数据的输出之间不需输出换行符。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li><p>典型的状态空间搜索，采用迭代加深搜的方法。</p>
</li>
<li><p><strong>IDA*模板题</strong></p>
</li>
<li><p>本题中要求中间8个数是相同的，而出现的数字又限定在1，2，3中。所以可以分三次求解，这样可以减少搜素空间。以目标为1为例，这时，将元素看作为1和非1的元素，那么状态总数就变成了8个1，16个非1的全排列，即24!/(8!*16!)。</p>
</li>
<li><p>其实本题中的state可以定义为bool型，因为只关心比如1和非1</p>
</li>
<li><p>关于剪枝</p>
<ol>
<li>最直接的，由于A-F/B-E/H-C/G-D相对，所以不能回滚上一层的操作。<strong>实现时使用op数组记录对应关系</strong></li>
<li>每次旋转至多引入一个新的元素，也就是说每次回滚只能增加一个相同的元素。所以如果当前的层数d加上中间8个数字中非当前目标的数字个数大于最大个数maxd时，需要进行剪枝。</li>
</ol>
</li>
<li><p>关于旋转：由于输入方式比较特殊，旋转的次序固定，所以把A-H中每个元素在输入串中出现的位置手动写出。旋转时只需要模7加即可。</p>
</li>
<li><p>相同的思路，将中间8个格出现的位置预先写出也可简化代码。</p>
</li>
<li><p>与编辑书稿有相似之处</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool dfs(int d) &#123;</span><br><span class="line">if (d &#x3D;&#x3D; maxd) &#123;</span><br><span class="line">	if (not_equal(d) &#x3D;&#x3D; 0) return true;</span><br><span class="line">	else return false;</span><br><span class="line">&#125;</span><br><span class="line">int next &#x3D; d + 1;</span><br><span class="line">if (d + not_equal(d) &gt; maxd) return false;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 8; i++) &#123;</span><br><span class="line">	if (d &gt; 0 &amp;&amp; op[v[d-1]]&#x3D;&#x3D; i) continue;</span><br><span class="line"></span><br><span class="line">	v[d] &#x3D; i;</span><br><span class="line">	memcpy(state[next], state[d], 24 * sizeof(int));</span><br><span class="line">	for (int j &#x3D; 0; j &lt; 7; j++)</span><br><span class="line">		state[next][move[i][j]] &#x3D; state[d][move[i][(j + 1) % 7]];</span><br><span class="line">	if (dfs(next)) return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="update-判断是否字典序更小"><a href="#update-判断是否字典序更小" class="headerlink" title="update 判断是否字典序更小"></a>update 判断是否字典序更小</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool update() &#123;</span><br><span class="line">if (ans[0] !&#x3D; -1)</span><br><span class="line">	for (int i &#x3D; 0; i &lt; maxd; i++)</span><br><span class="line">		if (v[i] &gt; ans[i]) return false;</span><br><span class="line">		else if (v[i] &lt; ans[i]) break;</span><br><span class="line">memcpy(ans, v, sizeof(int)*maxd);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="not-equla-统计中间八格中与当前目标不等的元素个数"><a href="#not-equla-统计中间八格中与当前目标不等的元素个数" class="headerlink" title="not_equla 统计中间八格中与当前目标不等的元素个数"></a>not_equla 统计中间八格中与当前目标不等的元素个数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int not_equal(int d) &#123;</span><br><span class="line">int ans &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 8; i++)</span><br><span class="line">	if (state[d][mid[i]] !&#x3D; cur_nm)	ans++;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int maxd;</span><br><span class="line">int move[8][7] &#x3D; &#123;</span><br><span class="line">&#123;0,2,6,11,15,20,22&#125;,</span><br><span class="line">&#123;1,3,8,12,17,21,23&#125;,</span><br><span class="line">&#123;10,9,8,7,6,5,4&#125;,</span><br><span class="line">&#123;19,18,17,16,15,14,13&#125;,</span><br><span class="line">&#123;23,21,17,12,8,3,1&#125;,</span><br><span class="line">&#123;22,20,15,11,6,2,0&#125;,</span><br><span class="line">&#123;13,14,15,16,17,18,19&#125;,</span><br><span class="line">&#123;4,5,6,7,8,9,10&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int mid[8] &#x3D; &#123; 6,7,8,11,12,15,16,17 &#125;;</span><br><span class="line">int op[8] &#x3D; &#123; 5,4,7,6,1,0,3,2 &#125;;</span><br><span class="line">int state[50][24];</span><br><span class="line">int ans[50], v[50];</span><br><span class="line">int table[24];</span><br><span class="line">inline int not_equal(int d);</span><br><span class="line">bool dfs(int d);</span><br><span class="line">inline bool update();</span><br><span class="line">int cur_nm;</span><br><span class="line">int main() &#123;</span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">	memset(ans, -1, sizeof(ans));</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;table[0]);</span><br><span class="line">	if (!table[0]) break;</span><br><span class="line">	for (int i &#x3D; 1; i &lt; 24; i++)</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;table[i]);</span><br><span class="line">	int p &#x3D; 0;</span><br><span class="line">	for (maxd &#x3D; 0;; maxd++) &#123;</span><br><span class="line">		for (cur_nm &#x3D; 1; cur_nm &lt;&#x3D; 3; cur_nm++) &#123;</span><br><span class="line">			memcpy(state[0], table, 24 * sizeof(int));</span><br><span class="line">			if (dfs(0) &amp;&amp; update()) </span><br><span class="line">				p &#x3D; cur_nm;</span><br><span class="line">		&#125;</span><br><span class="line">		if (p) break;</span><br><span class="line">	&#125;</span><br><span class="line">	if (maxd)</span><br><span class="line">		for (int i &#x3D; 0; i &lt; maxd; i++) printf(&quot;%c&quot;, ans[i] + &#39;A&#39;);</span><br><span class="line">	else printf(&quot;No moves needed&quot;);</span><br><span class="line">	printf(&quot;\n%d\n&quot;, p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>移动木块</title>
    <url>/2020/01/20/%E7%A7%BB%E5%8A%A8%E6%9C%A8%E5%9D%97/</url>
    <content><![CDATA[<h1 id="UVA-12657-移动盒子"><a href="#UVA-12657-移动盒子" class="headerlink" title="UVA 12657 移动盒子"></a>UVA 12657 移动盒子</h1><p>你有n个盒子在桌子上的一条线上从左到右编号为1……n。你的任务是模拟四种操作</p>
<p>1 X Y 移动盒子编号X到盒子编号Y的左边（如果X已经在Y的左边了就忽略）</p>
<p>2 X Y 移动盒子编号X到盒子编号Y的右边（如果X已经在Y的右边了就忽略）</p>
<p>3 X Y 交换盒子编号X与盒子编号Y的位置</p>
<p>4 将整条线反转</p>
<p>操作保证合法，X不等于Y</p>
<p>举一个例子，如果n=6，操作 1 1 4然后就变成了2 3 1 4 5 6；再操作 2 3 5就变成了 2 1 4 5 3 6；再操作 3 1 6 就变成 2 6 4 5 3 1；最后操作4，就变成了 1 3 5 4 6 2</p>
<p>输入</p>
<p>最多有10组数据，每个数据会包含两个整数n,m（1≤n,m&lt;100,000）, 接下来是m行数据，表示操作。</p>
<p>输出</p>
<p>对于每组数据，输出他们奇数位置的编号的和。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题中操作使得插入可以在任意位置进行（看起来双端队列好像可以，但是光标移动到HOME之后，就不是在头部插入了）</p>
<ol>
<li>考虑用双向链表，因为用数组会超时，用单向链表又不够</li>
<li>定义辅助函数link来连接链表</li>
<li>定义inv来标识4号反转指令执行了几次，如果是奇数次，那么op=3-op（即放左边变成放右边），如果是偶数次，那么不变。</li>
<li>对于指令三，需要注意当XY相邻的时候，情况不一样。代码中对于此处用了技巧，比如X在Y的相邻右侧，并且交换XY之后Y在X的右侧，则XY相邻。</li>
<li>本题主要是细节比较多<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   # define maxn 100005</span><br><span class="line">   int left[maxn], right[maxn];</span><br><span class="line">   void link(int l, int r) &#123;</span><br><span class="line">   	left[r] &#x3D; l;</span><br><span class="line">   	right[l] &#x3D; r;</span><br><span class="line">   &#125;</span><br><span class="line">   int main() &#123;</span><br><span class="line">   	int n, m;</span><br><span class="line">int kase &#x3D; 0;</span><br><span class="line">while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">		left[i] &#x3D; i - 1;</span><br><span class="line">		right[i] &#x3D; (i + 1) % (n + 1);</span><br><span class="line">	&#125;</span><br><span class="line">	right[0] &#x3D; 1;</span><br><span class="line">	left[0] &#x3D; n;</span><br><span class="line">	int op, x, y, inv &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	while (m--) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		scanf(&quot;%d&quot;, &amp;op);</span><br><span class="line">		if (op &#x3D;&#x3D; 4) inv &#x3D; !inv;</span><br><span class="line">		else &#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;x, &amp;y);</span><br><span class="line">			if (op &#x3D;&#x3D; 3 &amp;&amp; right[y] &#x3D;&#x3D; x) std::swap(x, y);</span><br><span class="line">			if (op !&#x3D; 3 &amp;&amp; inv) op &#x3D; 3 - op;</span><br><span class="line">			if (op &#x3D;&#x3D; 1 &amp;&amp; x &#x3D;&#x3D; left[y]) continue; </span><br><span class="line">			if (op &#x3D;&#x3D; 2 &amp;&amp; x &#x3D;&#x3D; right[y]) continue;</span><br><span class="line"></span><br><span class="line">			int lx &#x3D; left[x], rx &#x3D; right[x], ly &#x3D; left[y], ry &#x3D; right[y];</span><br><span class="line">			if (op &#x3D;&#x3D; 1) &#123;</span><br><span class="line">				link(lx, rx); link(ly, x); link(x, y);</span><br><span class="line">			&#125;</span><br><span class="line">			else if (op &#x3D;&#x3D; 2) &#123;</span><br><span class="line">				link(lx, rx); link(y, x); link(x, ry);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			&#x2F;*else if (op &#x3D;&#x3D; 3) &#123;</span><br><span class="line">				if (right[y] &#x3D;&#x3D; x) &#123;</span><br><span class="line">					link(y, rx); link(ly, x); link(x, y);</span><br><span class="line">				&#125;</span><br><span class="line">				else if (left[y] &#x3D;&#x3D; x) &#123;</span><br><span class="line">					link(lx, y); link(y, x); link(x, ry);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					link(ly, x); link(x, ry);</span><br><span class="line">					link(lx, y); link(y, rx);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;*&#x2F;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; 注释部分与下面这段等价</span><br><span class="line">			else if (op &#x3D;&#x3D; 3) &#123;</span><br><span class="line">				if (right[x] &#x3D;&#x3D; y) &#123;</span><br><span class="line">					link(lx, y); link(y, x); link(x, ry);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123; link(lx, y); link(y, rx); link(ly, x); link(x, ry); &#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int b &#x3D; 0;</span><br><span class="line">	</span><br><span class="line">	long long ans &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">		b &#x3D; right[b];</span><br><span class="line">		&#x2F;&#x2F;std::cout &lt;&lt; i&lt;&lt;&quot;: &quot;&lt;&lt;right[b] &lt;&lt; std::endl;</span><br><span class="line">		if (i % 2 &#x3D;&#x3D; 1) ans +&#x3D; b;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;*using namespace std;</span><br><span class="line">	cout &lt;&lt; endl;*&#x2F;</span><br><span class="line">	if (inv &amp;&amp; n % 2 &#x3D;&#x3D; 0) ans &#x3D; (long long)n*(n + 1) &#x2F; 2 - ans;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;由于处理的时候，对于反转，只对1.2操作处理了。所以在输出的时候还要考虑：如果总数为偶数，并且反转了奇数次，那么奇数位的盒子编号才会改变</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	printf(&quot;Case %d: %lld\n&quot;, ++kase, ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li>学习代码中处理相邻的简化方法</li>
<li>学习双向链表的辅助函数</li>
<li>如果某一操作非常费时，那么不必每一步都真的执行他</li>
<li>编号不是位置了</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>邮件传输代理的交互</title>
    <url>/2020/01/20/%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E4%BB%A3%E7%90%86%E7%9A%84%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<h1 id="UVA-814-邮件传输代理的交互"><a href="#UVA-814-邮件传输代理的交互" class="headerlink" title="UVA 814 邮件传输代理的交互"></a>UVA 814 邮件传输代理的交互</h1><p>&ensp;本题的任务为模拟发送邮件时MTA（邮件传输代理）之间的交互。所谓MTA，就是email地址格式user@mtaname的“后面部分”。当某人从user1@mta1发送给另一个人user2@mta2时，这两个MTA将会通信。如果两个收件人属于同一个MTA，发送者的MTA只需与这个 MTA通信一次就可以把邮件发送给这两个人。</p>
<p>&ensp;输入每个MTA里的用户列表，对于每个发送请求（输入发送者和接收者列表），按顺序 输出所有MTA之间的SMTP（简单邮件协议）交互。协议细节参见原题。</p>
<p>&ensp;发送人MTA连接收件人MTA的顺序应该与在输入中第一次出现的顺序一致。例如，若 发件人是Hamdy@Cairo，收件人列表为Conrado@MexicoCity、Shariff@SanFrancisco、 Lisa@MexicoCity，则Cairo应当依次连接MexicoCity和SanFrancisco。 如果连接某个MTA之后发现所有收件人都不存在，则不应该发送DATA。所有用户名均由不超过15个字母和数字组成。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>首先考虑输入过程，可以选择用map来存用户列表；也可以选择用set来存，值就是邮件地址。</li>
<li>对于每个请求，首先读入发件人，分离出MTA和用户名，然后读取收件人，根据MTA出现的先后顺序进行保存，并且去掉重复。</li>
<li>接下来读入邮件正文，最后按顺序依次连接每个MTA，检查并输出每个收件人是否存在，如果至少有一个存在，则输出邮件正文。<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="分离用户名和mta"><a href="#分离用户名和mta" class="headerlink" title="分离用户名和mta"></a>分离用户名和mta</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">void pare_address(const string s, string &amp;user, string &amp;mta) &#123;</span><br><span class="line">	int k &#x3D; s.find(&#39;@&#39;);</span><br><span class="line">	user &#x3D; s.substr(0, k);</span><br><span class="line">	mta &#x3D; s.substr(k + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">string s;</span><br><span class="line">set&lt;string&gt; addr;&#x2F;&#x2F;存每个mta对应用户的列表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string user1, mta1;</span><br><span class="line">while (cin &gt;&gt; s &amp;&amp; s !&#x3D; &quot;*&quot;) &#123;</span><br><span class="line">	int k;</span><br><span class="line">	string loc;</span><br><span class="line">	cin &gt;&gt; s &gt;&gt; k;</span><br><span class="line">	while (k--) &#123;</span><br><span class="line">		cin &gt;&gt; loc;</span><br><span class="line">		addr.insert(loc + &quot;@&quot; + s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;输入完成</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;处理发送地址和接收地址</span><br><span class="line">string sender;</span><br><span class="line">while (cin &gt;&gt; sender &amp;&amp; sender !&#x3D; &quot;*&quot;) &#123;</span><br><span class="line"></span><br><span class="line">	pare_address(sender, user1, mta1);</span><br><span class="line">	vector&lt;string&gt; mta;&#x2F;&#x2F;按序存需要连接的mta</span><br><span class="line">	map&lt;string, vector&lt;string&gt;&gt; dest;&#x2F;&#x2F;存每个mta要发送的用户</span><br><span class="line">	set&lt;string&gt; vis;&#x2F;&#x2F;用来去除重复收件人</span><br><span class="line"></span><br><span class="line">	while (cin &gt;&gt; s &amp;&amp; s !&#x3D; &quot;*&quot;) &#123;</span><br><span class="line">		string user2, mta2;</span><br><span class="line">		pare_address(s, user2, mta2);</span><br><span class="line"></span><br><span class="line">		if (vis.count(s)) continue;&#x2F;&#x2F;重复收件人</span><br><span class="line">		vis.insert(s);</span><br><span class="line">		if (!dest.count(mta2)) &#123;&#x2F;&#x2F;如果不是重复的要连接的mta</span><br><span class="line">			mta.push_back(mta2);</span><br><span class="line">			dest[mta2] &#x3D; vector&lt;string&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">		dest[mta2].push_back(s);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	getline(cin, s);&#x2F;&#x2F;把“*”这一行的回车吃掉</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;输入正文</span><br><span class="line">	string data;</span><br><span class="line">	while (getline(cin, s) &amp;&amp; s[0] !&#x3D; &#39;*&#39;)	data +&#x3D; &quot;     &quot; + s + &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; mta.size(); i++) &#123;</span><br><span class="line">		string mta2 &#x3D; mta[i];&#x2F;&#x2F;mta2遍历要连接的mta</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; &quot;Connection between &quot; &lt;&lt; mta1 &lt;&lt; &quot; and &quot; 	&lt;&lt; mta2 &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;     HELO &quot; &lt;&lt; mta1 &lt;&lt; endl &lt;&lt; &quot;     250\n&quot;;</span><br><span class="line">		cout &lt;&lt; &quot;     MAIL FROM:&lt;&quot; &lt;&lt; sender &lt;&lt; &quot;&gt;&quot; &lt;&lt; endl &lt;&lt; &quot;     250&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		vector&lt;string&gt; users &#x3D; dest[mta2];</span><br><span class="line">		</span><br><span class="line">		bool ok &#x3D; false;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; users.size(); j++) &#123;</span><br><span class="line">		&#x2F;&#x2F;遍历当前连接的mta2下要发送的用户列表</span><br><span class="line">			cout &lt;&lt; &quot;     RCPT TO:&lt;&quot; &lt;&lt; users[j] &lt;&lt; &quot;&gt;&quot; &lt;&lt; endl;</span><br><span class="line">			if (addr.count(users[j])) &#123;</span><br><span class="line">				ok &#x3D; true;</span><br><span class="line">				cout &lt;&lt; &quot;     250&quot; &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				cout &lt;&lt; &quot;     550&quot; &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (ok) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;     DATA&quot; &lt;&lt; endl &lt;&lt; &quot;     354&quot; &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; data &lt;&lt; &quot;     .&quot; &lt;&lt; endl &lt;&lt; &quot;     250&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; &quot;     QUIT&quot; &lt;&lt; endl &lt;&lt; &quot;     221&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li>学习拆分用户和地址时的引用传递</li>
<li>存一对多关系的时候可以用map+vector</li>
<li>去重时可以考虑多加一个容器，不要仅仅因为不能重复，就断定用set存一些数据</li>
<li>向量能保持原序，set能避免重复，map能得到对应关系</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>万圣节后的早晨</title>
    <url>/2020/01/20/%E4%B8%87%E5%9C%A3%E8%8A%82%E5%90%8E%E7%9A%84%E6%97%A9%E6%99%A8/</url>
    <content><![CDATA[<h1 id="UVA-1601-万圣节后的早晨"><a href="#UVA-1601-万圣节后的早晨" class="headerlink" title="UVA 1601 万圣节后的早晨"></a>UVA 1601 万圣节后的早晨</h1><p>w h （w, h &lt;= 16)的网格有 n （ n &lt;= 3) 个小写字母（代表鬼）其余的是‘# ’（代表障碍格） 或 ‘ ’（代表空格。 要求把他们移动到对应的大写字母里。每步可以有多少个鬼同时移动（均为上下左右4个移动方向之一）， 但每步移动两个鬼不能占用同一个位置， 也不能在一步之内交换位置。输入保证空格联通，障碍联通，且在2 2子网格中至少有一个障碍格，并且最外面一层是障碍格。输入保证有解。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>是隐式图最短路径问题，通过bfs求解最短路径即可。</li>
<li>由于鬼的数量不大于3，所以统一按照3个鬼的情况编程。两个鬼看作是第三个一直不动；一个鬼同理。</li>
<li>问题主要在于有三个点，状态如何保存？访问标志如何保存？</li>
<li>由于题中说每2*2的小格中必有障碍，暗示了可移动的位置是少数，所以给空白格建立一张图。</li>
<li>通过一个索引值cnt来连接空白格的坐标，用x[cnt],y[cnt]来表示第cnt个非障碍格的坐标;用id[i][j]=cnt来记录每个位置的索引值。</li>
<li>建立空白格图，在每个空白格处可移动的空白格必然是其他的空白格。用blank[cnt][num_blank[cnt]] = id[x][y]来表示索引为cnt的空白格处可移动的方向中第num_blank[cnt]个的目的格的索引值。</li>
<li>由于本题中的图比较小，所以可以开三维数组来标记访问。此外可以使用哈希函数，编码或者set的方法来判重。本题中出入队列的值即是通过编码得到。</li>
<li>应该关注ID函数、索引值的写法、多个值同时改变构成新状态的做法。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 20;</span><br><span class="line">int id[maxn][maxn];</span><br><span class="line">int s[3], t[3];</span><br><span class="line">char g[maxn][maxn];</span><br><span class="line"></span><br><span class="line">int blank[maxn*maxn][5];</span><br><span class="line">int dist[maxn*maxn][maxn*maxn][maxn*maxn];</span><br><span class="line">int num_blank[maxn*maxn];</span><br><span class="line">int r, c, w;</span><br><span class="line"></span><br><span class="line">int dx[] &#x3D; &#123; 0, -1, 1, 0, 0 &#125;;</span><br><span class="line">int dy[] &#x3D; &#123; 0, 0, 0, -1, 1 &#125;;</span><br><span class="line">inline void read_in();</span><br><span class="line">inline int bfs();</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">while (~scanf(&quot;%d %d %d\n&quot;, &amp;c, &amp;r, &amp;w) &amp;&amp; w)</span><br><span class="line">&#123;</span><br><span class="line">	read_in();</span><br><span class="line">	printf(&quot;%d\n&quot;, bfs());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="read-in"><a href="#read-in" class="headerlink" title="read_in"></a>read_in</h2><p>读入数据，并用数组记录鬼的初始位置和目标位置。之后，给空白建图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">inline void read_in() &#123;</span><br><span class="line">int x[maxn*maxn];</span><br><span class="line">int y[maxn*maxn];</span><br><span class="line">for (int i &#x3D; 0; i &lt; r; i++) fgets(g[i], 20, stdin);</span><br><span class="line">int cnt &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; r; i++)</span><br><span class="line">	for (int j &#x3D; 0; j &lt; c; j++) &#123;</span><br><span class="line">		if (g[i][j] !&#x3D; &#39;# &#39;) &#123;</span><br><span class="line">			x[cnt] &#x3D; i;</span><br><span class="line">			y[cnt] &#x3D; j;</span><br><span class="line">			id[i][j] &#x3D; cnt;</span><br><span class="line">			if (islower(g[i][j])) s[g[i][j] - &#39;a&#39;] &#x3D; cnt;</span><br><span class="line">			else if (isupper(g[i][j])) t[g[i][j] - &#39;A&#39;] &#x3D; cnt;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;记录每个空白处可以走的方向</span><br><span class="line">for (int i &#x3D; 0; i &lt; cnt; i++) &#123;</span><br><span class="line">	num_blank[i] &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F;四个正方向加不动</span><br><span class="line">	for (int k &#x3D; 0; k &lt; 5; k++) &#123;</span><br><span class="line">		int nx &#x3D; x[i] + dx[k];</span><br><span class="line">		int ny &#x3D; y[i] + dy[k];</span><br><span class="line">		if (g[nx][ny] !&#x3D; &#39;# &#39;)</span><br><span class="line">			blank[i][num_blank[i]++] &#x3D; id[nx][ny];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果少于三个鬼，令另外的不动，初始位置等于末位置。</span><br><span class="line">if (w &lt;&#x3D; 2) &#123; num_blank[cnt] &#x3D; 1; blank[cnt][0] &#x3D; cnt; s[2] &#x3D; t[2] &#x3D; cnt++; &#125;</span><br><span class="line">if (w &lt;&#x3D; 1) &#123; num_blank[cnt] &#x3D; 1; blank[cnt][0] &#x3D; cnt; s[1] &#x3D; t[1] &#x3D; cnt++; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h2><p>进行广度搜索，利用二进制法存储状态，沿途更新到达每个状态的步数，当走到目标状态时退出循环。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">inline int bfs() &#123;</span><br><span class="line">memset(dist, -1, sizeof(dist));</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(ID(s[0], s[1], s[2]));</span><br><span class="line">dist[s[0]][s[1]][s[2]] &#x3D; 0;</span><br><span class="line">while (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">	int u &#x3D; q.front(); q.pop();</span><br><span class="line">	int a &#x3D; (u &gt;&gt; 16) &amp; 0xff, b &#x3D; (u &gt;&gt; 8) &amp; 0xff, c &#x3D; u &amp; 0xff;</span><br><span class="line">	if (a &#x3D;&#x3D; t[0] &amp;&amp; b &#x3D;&#x3D; t[1] &amp;&amp; c &#x3D;&#x3D; t[2])</span><br><span class="line">		return dist[a][b][c];</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; num_blank[a]; i++) &#123;</span><br><span class="line">		int a2 &#x3D; blank[a][i];</span><br><span class="line">		for (int j &#x3D; 0; j &lt; num_blank[b]; j++) &#123;</span><br><span class="line">			int b2 &#x3D; blank[b][j];</span><br><span class="line">			if (!isOk(a, a2, b, b2)) continue;</span><br><span class="line"></span><br><span class="line">			for (int k &#x3D; 0; k &lt; num_blank[c]; k++) &#123;</span><br><span class="line">				int c2 &#x3D; blank[c][k];</span><br><span class="line">				if (!isOk(a, a2, c, c2) || !isOk(b, b2, c, c2)) continue;</span><br><span class="line"></span><br><span class="line">				if (dist[a2][b2][c2] &#x3D;&#x3D; -1) &#123;</span><br><span class="line">					dist[a2][b2][c2] &#x3D; dist[a][b][c] + 1;</span><br><span class="line">					q.push(ID(a2, b2, c2));</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ID-对二进制编码状态进行解码"><a href="#ID-对二进制编码状态进行解码" class="headerlink" title="ID 对二进制编码状态进行解码"></a>ID 对二进制编码状态进行解码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">inline int ID(int a, int b, int c) &#123;</span><br><span class="line">return (a &lt;&lt; 16) | (b &lt;&lt; 8) | c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="isOk-判断两个鬼是否占据同一个位置或者在一步之内交叉"><a href="#isOk-判断两个鬼是否占据同一个位置或者在一步之内交叉" class="headerlink" title="isOk 判断两个鬼是否占据同一个位置或者在一步之内交叉"></a>isOk 判断两个鬼是否占据同一个位置或者在一步之内交叉</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">inline bool isOk(int a1, int a2, int b1, int b2) &#123;</span><br><span class="line">return a2 !&#x3D; b2 &amp;&amp; !(a2 &#x3D;&#x3D; b1 &amp;&amp; b2 &#x3D;&#x3D; a1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>团体队列</title>
    <url>/2020/01/20/%E5%9B%A2%E4%BD%93%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="UVA540-团体队列"><a href="#UVA540-团体队列" class="headerlink" title="UVA540 团体队列"></a>UVA540 团体队列</h1><p>有t个团队的人正在排一个长队。每次新来一个人时，如果他有队友在排队，那么这个新人会插队到最后一个队友的身后。如果没有任何一个队友排队，则他会排到长队的队尾。输入每个团队中所有队员的编号，要求支持如下3种指令（前两种指令可以穿插进行）。</p>
<p>ENQUEUEx：编号为x的人进入长队。</p>
<p>DEQUEUE：长队的队首出队。</p>
<p>STOP：停止模拟。</p>
<p>对于每个DEQUEUE指令，输出出队的人的编号。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>本题中涉及两种队列，一个是每个团队的队列，一个是整体的长队。所以用两个整型队列来存储。</li>
<li>由于一个团队的人一定站在一起，所以在整体的长队里，我们不关心每个人的具体位置。所以用给每个团队映射为一个编号，长队中是元素是队伍的编号<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1> /*<br> p117 例5-6 UVA540<br> */</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    #include&lt;iostream&gt;</span><br><span class="line">    #include&lt;string&gt;</span><br><span class="line">    #include&lt;map&gt;</span><br><span class="line">    #include&lt;queue&gt;</span><br><span class="line">    using namespace std;</span><br><span class="line">    int main() &#123;</span><br><span class="line">	int kase &#x3D; 0;</span><br><span class="line">	for (;;) &#123;</span><br><span class="line">		map&lt;int, int&gt; belong;</span><br><span class="line">		queue&lt;int&gt; total,team[1100];</span><br><span class="line">		int n;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		if (!n) return 0;</span><br><span class="line">		cout &lt;&lt; &quot;Scenario # &quot; &lt;&lt; ++kase &lt;&lt; endl;</span><br><span class="line">		for(int i&#x3D;0;i&lt;n;i++) &#123;</span><br><span class="line">			int m;</span><br><span class="line">			cin &gt;&gt; m;</span><br><span class="line">			while(m--) &#123;</span><br><span class="line">				int x;</span><br><span class="line">				cin &gt;&gt; x;</span><br><span class="line">				belong[x] &#x3D; i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">**完成输入，并给每个队伍的成员都映射一个编号**</span><br><span class="line"></span><br><span class="line">		for (;;) &#123;</span><br><span class="line">			string cmd;</span><br><span class="line">			cin &gt;&gt; cmd;</span><br><span class="line">			if (cmd[0] &#x3D;&#x3D; &#39;S&#39;) break;</span><br><span class="line">			else &#123;</span><br><span class="line">				if (cmd[0] &#x3D;&#x3D; &#39;D&#39;) &#123;</span><br><span class="line">					int t &#x3D; total.front();</span><br><span class="line">					cout &lt;&lt; team[t].front() &lt;&lt; endl;</span><br><span class="line">					team[t].pop();</span><br><span class="line">					if (team[t].empty()) total.pop();</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">				if (cmd[0] &#x3D;&#x3D; &#39;E&#39;) &#123;</span><br><span class="line">					int num;</span><br><span class="line">					cin &gt;&gt; num;</span><br><span class="line">					int t &#x3D; belong[num];</span><br><span class="line">					if (team[t].empty()) total.push(t);</span><br><span class="line">					team[t].push(num);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li>因为队伍数量不定，所以一开始想用vector，但是会出现越界，所以使用vector时，最好用push_back，不要随机访问。</li>
<li>两个指令，一个有操作数，一个没有，注意分情况输入！！</li>
<li>学习映射的方法，注意需要什么，应该关注什么。本题中，长队里只需关注各队伍的相对顺序，无需在长队中注意每个人的相对位置。</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>图书管理系统</title>
    <url>/2020/01/20/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="uva230-图书管理系统"><a href="#uva230-图书管理系统" class="headerlink" title="uva230 图书管理系统"></a>uva230 图书管理系统</h1><p>&ensp;你的任务是模拟一个图书管理系统。首先输入若干图书的标题和作者（标题各不相同，以END结束），然后是若干指令：BORROW指令表示借书，RETURN指令表示还书，SHELVE指令表示把所有已归还但还没有上架的图书排序后依次插入书架并输出图书标题和插入位置（可能是第一本书或者某本书的后面）。<br>&ensp;图书排序的方法是先按作者从小到大排，再按标题从小到大排。在处理第一条指令之前，你应当现将所有图书按照这种方式排序。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>涉及排序，想到用一个集合来存，其中元素既要包含作者名，又要包含书名，并且要先按作者名排序，再按书名排序。所以要写一个结构体，并冲写&lt;号。</li>
<li>由于指令后面只跟书名，所以还要用一个map来存储每本书的作者，以便在处理指令的时候，补全字段，从而在集合中查找    </li>
<li>SHELVE是在所有return结束后一起进行，所以还要用一个容器来存归还过的书，并且也要按要求排序，所以用了一个after这个set。</li>
<li>BORROW即在集合中找到对应元素，然后擦除(要判断是否为结束迭代器，否则re)</li>
<li>RETURN即插入图书集合以及after集合</li>
<li>SHELVE时，按after中顺序结合作者名查找对应书，输出前一个迭代器指向的对象，注意first的判断即可</li>
<li>别的都十分正常，主要是注意以下erase时，要判断是否为end<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   #include&lt;iostream&gt;</span><br><span class="line">   #include&lt;string&gt;</span><br><span class="line">   #include&lt;algorithm&gt;</span><br><span class="line">   #include&lt;vector&gt;</span><br><span class="line">   #include&lt;iterator&gt;</span><br><span class="line">   #include&lt;set&gt;</span><br><span class="line">   #include&lt;map&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;习题5-8in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;习题5-8out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   string s;</span><br><span class="line">   struct node &#123;</span><br><span class="line">   	string book;</span><br><span class="line">   	string auth;</span><br><span class="line">   	node() &#123; &#125;</span><br><span class="line">   	node(string book, string auth) : book(book), auth(auth) &#123;&#125;</span><br><span class="line">   	bool operator &lt; (const node &amp;a)const &#123;</span><br><span class="line">   		return auth &lt; a.auth || (auth &#x3D;&#x3D; a.auth &amp;&amp; book &lt; a.book);</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   int main() &#123;</span><br><span class="line">set&lt;node&gt; library;</span><br><span class="line">map&lt;string, string&gt; who;</span><br><span class="line">set&lt;node&gt; after;</span><br><span class="line">while (getline(cin, s) &amp;&amp; s !&#x3D; &quot;END&quot;) &#123;</span><br><span class="line">	int f1 &#x3D; s.find(&quot;\&quot;&quot;);</span><br><span class="line">	int f2 &#x3D; s.substr(f1+1).find(&#39;&quot;&#39;);&#x2F;&#x2F;+1!!!!</span><br><span class="line">	node b(s.substr(f1 + 1, f2), s.substr(f2 + 5));</span><br><span class="line">	library.insert(b);</span><br><span class="line">	who[b.book] &#x3D; b.auth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while (getline(cin, s) &amp;&amp; s !&#x3D; &quot;END&quot;) &#123;</span><br><span class="line">	set&lt;node&gt;::iterator it;</span><br><span class="line">	int f1 &#x3D; s.find(&quot;\&quot;&quot;);</span><br><span class="line">	int f2 &#x3D; s.substr(f1 + 1).find(&#39;&quot;&#39;);</span><br><span class="line">	string bookname &#x3D; s.substr(f1 + 1,f2);</span><br><span class="line">	</span><br><span class="line">	if (s[0] &#x3D;&#x3D; &#39;B&#39;) &#123;</span><br><span class="line">		</span><br><span class="line">		it &#x3D; library.find(node(bookname, who[bookname]));</span><br><span class="line">		</span><br><span class="line">		if (it !&#x3D; library.end())	library.erase(it);</span><br><span class="line">	&#125;</span><br><span class="line">	if (s[0] &#x3D;&#x3D; &#39;R&#39;) &#123;</span><br><span class="line">		library.insert(node(bookname, who[bookname]));</span><br><span class="line">		after.insert(node(bookname, who[bookname]));</span><br><span class="line">	&#125;</span><br><span class="line">	if (s[0] &#x3D;&#x3D; &#39;S&#39;) &#123;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		for (set&lt;node&gt;::iterator i &#x3D; after.begin(); i !&#x3D; after.end();i++) &#123;&#x2F;&#x2F;输出也是先按作者名排序再按书名排序</span><br><span class="line">			bookname &#x3D; i-&gt;book;</span><br><span class="line">			it &#x3D; library.find(node(bookname, who[bookname]));</span><br><span class="line">			cout &lt;&lt; &quot;Put \&quot;&quot; &lt;&lt; bookname &lt;&lt;&quot;\&quot;&quot;;</span><br><span class="line">			if (it !&#x3D; library.begin()) cout &lt;&lt; &quot; after \&quot;&quot; &lt;&lt; (--it)-&gt;book &lt;&lt; &quot;\&quot;&quot;&lt;&lt;endl;</span><br><span class="line">			else cout &lt;&lt; &quot; first&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;END&quot; &lt;&lt; endl;</span><br><span class="line">		after.clear();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><p>存储重复的数据有时候也是必要的，不要为了那点空间，花太多力气</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>天平难题</title>
    <url>/2020/01/20/%E5%A4%A9%E5%B9%B3%E9%9A%BE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="UVA-1354-天平难题"><a href="#UVA-1354-天平难题" class="headerlink" title="UVA 1354 天平难题"></a>UVA 1354 <a href=""https://www.luogu.com.cn/problem/UVA1354"">天平难题</a></h1><p>给出房间宽度r和s个吊坠的重量wi。设计一个尽量宽（不超过r)的天平，挂着所有挂坠。 天平由一些长度为1的木棍组成。木棍的每一端要么挂一个挂坠，要么挂另外一个木棍。设n和m分别是两端挂的总重量，a和b为两端长度，要让天平平衡，必须满足na=mb。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>回溯法加暴搜，通过枚举二叉树来求解，<strong>其中天平力矩平衡的条件用来计算偏移量</strong>。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="DFS函数"><a href="#DFS函数" class="headerlink" title="DFS函数"></a>DFS函数</h2><p>用来遍历解答树，同时进行剪枝。只有当可扩展位置和剩余挂坠全部刚好同时用尽，才说明是一个可能的解，对于其他的情况需要进行剪枝。对于枚举二叉树中的每个节点，可能的情况又分成两种，一种是在该节点(step)处放一个木棍，那么可放置挂坠的节点数+1(别忘了回溯);另一种是在该节点处放置一个挂坠，那么可放置挂坠的位置-1，同时剩余挂坠-1(也要回溯)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   void dfs(int step, int leaf, int node) &#123;</span><br><span class="line">if (!node &amp;&amp; !leaf) &#123;</span><br><span class="line">	update(step - 1);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">if ((!node&amp;&amp;leaf) || (node &amp;&amp; !leaf)) &#123;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">if (tree[step &#x2F; 2] !&#x3D; -1) &#123;</span><br><span class="line">	dfs(step + 1, leaf, node);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">if (leaf &lt; node) &#123;</span><br><span class="line">	tree[step] &#x3D; -1;</span><br><span class="line">	dfs(step + 1, leaf + 1, node);</span><br><span class="line">	tree[step] &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; s; i++) &#123;</span><br><span class="line">	if (!vis[i]) &#123;</span><br><span class="line">		vis[i] &#x3D; 1;</span><br><span class="line">		tree[step] &#x3D; i;</span><br><span class="line"></span><br><span class="line">		dfs(step + 1, leaf - 1, node - 1);</span><br><span class="line"></span><br><span class="line">		vis[i] &#x3D; 0;</span><br><span class="line">		tree[step] &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="update函数"><a href="#update函数" class="headerlink" title="update函数"></a>update函数</h2><p>在枚举出一种二叉树之后，要计算他的宽度并和目前的最优解比较。这里首先使用一个val数组来记录各个节点处的权重：</p>
<ol>
<li>如果是木棍，那么他的重量等于他的两个子节点之和；</li>
<li>如果是挂坠，那么重量就是该挂坠的重量。</li>
</ol>
<p>之后使用findedge函数计算宽度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void update(int num) &#123;</span><br><span class="line">memset(val, 0, sizeof(val));</span><br><span class="line">for (int i &#x3D; num; i &gt;&#x3D; 1; i--) &#123;</span><br><span class="line">	if (tree[i] &lt; 0) val[i] &#x3D; val[i * 2] + val[i * 2 + 1];</span><br><span class="line">	else if(tree[i]&gt;0) val[i] &#x3D; w[tree[i]];</span><br><span class="line">&#125;</span><br><span class="line">left &#x3D; DBL_MAX;</span><br><span class="line">right &#x3D; DBL_MIN;</span><br><span class="line"></span><br><span class="line">findedge(double(0), 1);</span><br><span class="line">double fin &#x3D; right - left;</span><br><span class="line">if (fin &lt; r) &#123;</span><br><span class="line">	ans &#x3D; max(ans, fin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="findedge函数"><a href="#findedge函数" class="headerlink" title="findedge函数"></a>findedge函数</h2><p>利用天平平衡，力矩为0计算宽度。nl * a = nr * b。如果该节点是一个木棍，那么需要计算他的子节点的偏移量，过程与前面一样，所以整体上构成了一个递归的结构。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   void findedge(double mid, int cur) &#123;</span><br><span class="line">int a &#x3D; cur * 2;</span><br><span class="line">int b &#x3D; cur * 2 + 1;</span><br><span class="line">double nl &#x3D; mid - ((double)val[b] &#x2F; (val[a] + val[b]));</span><br><span class="line">double nr &#x3D; mid + ((double)val[a] &#x2F; (val[a] + val[b]));</span><br><span class="line"></span><br><span class="line">left &#x3D; min(left, nl);</span><br><span class="line">right &#x3D; max(right, nr);</span><br><span class="line"></span><br><span class="line">if (tree[cur] &lt; 0) &#123;</span><br><span class="line">	findedge(nl, a);</span><br><span class="line">	findedge(nr, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>小球下落</title>
    <url>/2020/01/20/%E5%B0%8F%E7%90%83%E4%B8%8B%E8%90%BD/</url>
    <content><![CDATA[<h1 id="uva-679-小球下落"><a href="#uva-679-小球下落" class="headerlink" title="uva 679 小球下落"></a>uva 679 小球下落</h1><p>&ensp;许多的小球一个一个的从一棵满二叉树上掉下来组成一个新满二叉树，每一时间，一个正在下降的球第一个访问的是非叶子节点。然后继续下降时，或者走右子树，或者走左子树，直到访问到叶子节点。<br>决定球运动方向的是每个节点的布尔值。最初，所有的节点都是 FALSE，当访问到一个节点时，如果这个节点是 FALSE，则这个球把它变成 TRUE，然后从左子树走，继续它的旅程。如果节点是TRUE，则球也会改变它为 FALSE，而接下来从右子树走。满二叉树的标记方法如下图。<br>因为所有的节点最初为 FALSE，所以第一个球将会访问节点 1，节点 2 和节点 4，转变节点的布尔值后在在节点 8 停止。第二个球将会访问节点 1、3、6，在节点 12 停止。；明显地，第三个球在它停止之前，会访问节点 1、2、5，在节点 10 停止。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>对于二叉树，有结论编号为i的节点的左子树编号为2i,右子树为2i+1</li>
<li>如果用一个数组存二叉树，并进行遍历，会TEL，并且数组占很大空间</li>
<li>发现只要知道是第几个通过该节点的小球，那么就可以知道这一步他落到左子树还是右子树</li>
<li>如果I为奇数，那么他是第（I+1）/2个向左走的小球，如果I为偶数，那么他是第I/2个向右走的小球。<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   #include&lt;iostream&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;小球下落in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;小球下落out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   int main() &#123;</span><br><span class="line">int T;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">while (T--) &#123;</span><br><span class="line">	int num, depth;</span><br><span class="line">	cin &gt;&gt; depth &gt;&gt; num;</span><br><span class="line">	int No &#x3D; 1;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; depth-1; i++) &#123;</span><br><span class="line">		if (num % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">			No &#x3D; 2 * No;</span><br><span class="line">			num &#x3D; (num + 1) &#x2F; 2;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			No &#x3D; 2 * No + 1;</span><br><span class="line">			num &#x3D; num &#x2F; 2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; No &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1></li>
<li>关注该关注的，并找规律很重要</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>消防车</title>
    <url>/2020/01/20/%E6%B6%88%E9%98%B2%E8%BD%A6/</url>
    <content><![CDATA[<h1 id="UVA-208-消防车"><a href="#UVA-208-消防车" class="headerlink" title="UVA 208 消防车"></a>UVA 208 消防车</h1><p>给你一张图，输入x，y表示xy见有一条边。输出从1到z所有的遍历方案（字典序）。每个节点从1到N标号。 有多组数据，每组数据以0 0结束。 （注意，刚开始的输入不是节点或边的数目） 输入输出格式可以参考样例. 数据范围（节点总数N&lt;21）</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>本题要求输出所有的完整的路径，即要沿着一条路走到头，所以使用dfs</li>
<li>辅助用bfs判断依次是否存在路径，否则会超时</li>
<li>本题中各层的path之间不会影响，因为递归是走到头再返回的。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   #include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line"># pragma warning(disable:4996)</span><br><span class="line">FILE *fin &#x3D; freopen(&quot;习题7-1in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">FILE *fout &#x3D; freopen(&quot;习题7-1out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 20+5;</span><br><span class="line">map&lt;int, vector&lt;int&gt;&gt; g;</span><br><span class="line">bool bfs();</span><br><span class="line">void dfs(int u,int step);</span><br><span class="line">int goal, cnt,kase &#x3D; 0;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int path[maxn];</span><br><span class="line">struct edge &#123;</span><br><span class="line">int x, y;</span><br><span class="line">edge(int x, int y) :x(x), y(y) &#123;&#125;</span><br><span class="line">bool operator &lt; (const edge&amp;a) const &#123; return x &lt; a.x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">int a, b;</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;goal) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">	g.clear();</span><br><span class="line">	printf(&quot;CASE %d:\n&quot;, ++kase);</span><br><span class="line">	while (scanf(&quot;%d %d&quot;, &amp;a, &amp;b) &amp;&amp; a) &#123;</span><br><span class="line">		g[a].push_back(b);</span><br><span class="line">		g[b].push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; maxn; i++)</span><br><span class="line">		sort(g[i].begin(), g[i].end());</span><br><span class="line">	cnt &#x3D; 0;</span><br><span class="line">	memset(vis, 0, sizeof(0));</span><br><span class="line">	if (!bfs()) &#123;&#x2F;&#x2F;优化，否则会T</span><br><span class="line">		cnt &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		vis[1] &#x3D; 1;</span><br><span class="line">		dfs(1,0);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;There are %d routes from the firestation to streetcorner %d.\n&quot;, cnt,goal);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool bfs() &#123;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(1);</span><br><span class="line">while (!q.empty()) &#123;</span><br><span class="line">	int u &#x3D; q.front(); q.pop();</span><br><span class="line">	if (u &#x3D;&#x3D; goal) &#123;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; g[u].size(); i++) &#123;</span><br><span class="line">		int v &#x3D; g[u][i];</span><br><span class="line">		if (!vis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			vis[v] &#x3D; 1;</span><br><span class="line">			q.push(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">memset(vis, 0, sizeof(vis));</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int u,int step) &#123;</span><br><span class="line">path[step] &#x3D; u;</span><br><span class="line">if (u &#x3D;&#x3D; goal) &#123;</span><br><span class="line">	printf(&quot;%d&quot;, path[0]);</span><br><span class="line">	for (int i &#x3D;1; i &lt;&#x3D; step; i++)</span><br><span class="line">		printf(&quot; %d&quot;, path[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	cnt++;</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 0; i &lt; g[u].size(); i++) &#123;</span><br><span class="line">	int v &#x3D; g[u][i];</span><br><span class="line">	if (vis[v]) continue;</span><br><span class="line">	vis[v] &#x3D; 1;</span><br><span class="line">	dfs(v,step+1);</span><br><span class="line">	vis[v] &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>网格动物</title>
    <url>/2020/01/20/%E7%BD%91%E6%A0%BC%E5%8A%A8%E7%89%A9/</url>
    <content><![CDATA[<h1 id="UVA-1602-网格动物"><a href="#UVA-1602-网格动物" class="headerlink" title="UVA 1602 网格动物"></a>UVA 1602 网格动物</h1><p>输入n,w,h(1&lt;=n&lt;=10,1&lt;=w,h&lt;=n).求能放在w*h网格里的不同的n连块的个数(平移,旋转,翻转算一种)</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>如果对于每次的输入计算结果，会超时，所以先打表。</p>
</li>
<li><p>题目问有多少种连通块，所以直观的想到不断的在格子周围扩展格子，然后判断是否重复   ，不重复则加入到集合中。</p>
</li>
<li><p>主要的数据结构为set(set(node))[maxn]，点的集合构成一种连通格，相同连通数的图构成i连通块的动物集合。i格连通的动物存在数组下标为i的集合中。使用点集来存图，一方面可以节省空间，另一方面便于实现平移旋转翻转</p>
</li>
<li><p>还需要实现平移，旋转，翻转</p>
<ol>
<li>平移：统一平移到原点</li>
<li>旋转：顺时针旋转90度，画个图就明白了</li>
<li>翻转：实现是关于x轴翻转</li>
</ol>
</li>
<li><p>打表：打表是一个迭代枚举的过程，后代是对前一代节点周围区域的扩展。由于normal的过程，所以不需要判断越界问题，即使出现负坐标，normal也会将他平移到原点。之后，在循环n,w,h将对应结果存在一个三维数组中即可。</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="打表"><a href="#打表" class="headerlink" title="打表"></a>打表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void get_ans() &#123;</span><br><span class="line">g start;</span><br><span class="line">start.insert(node(0, 0));</span><br><span class="line">animals[1].insert(start);</span><br><span class="line">for (int i &#x3D; 2; i &lt;&#x3D; maxn; i++)</span><br><span class="line">	for (set&lt;g&gt;::iterator j &#x3D; animals[i - 1].begin(); j !&#x3D; animals[i - 1].end(); j++)</span><br><span class="line">		for (g::iterator k &#x3D; (*j).begin(); k !&#x3D; (*j).end(); k++) &#123;</span><br><span class="line">			int r &#x3D; k-&gt;r, c &#x3D; k-&gt;c;</span><br><span class="line">			for (int w &#x3D; 0; w &lt; 4; w++) &#123;</span><br><span class="line">				node nd(r + dx[w], c + dy[w]);</span><br><span class="line">				if (!(*j).count(nd))</span><br><span class="line">					insert(*j, nd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for (int n &#x3D; 1; n &lt;&#x3D; maxn; n++)</span><br><span class="line">	for (int w &#x3D; 1; w &lt;&#x3D; maxn; w++)</span><br><span class="line">		for (int h &#x3D; 1; h &lt;&#x3D; maxn; h++) &#123;</span><br><span class="line">			int sum &#x3D; 0;</span><br><span class="line">			for (set&lt;g&gt;::iterator p &#x3D; animals[n].begin(); p !&#x3D; animals[n].end(); p++) &#123;</span><br><span class="line">				int maxx &#x3D; 0, maxy &#x3D; 0;</span><br><span class="line">				for (g::iterator q &#x3D; (*p).begin(); q !&#x3D; (*p).end(); q++) &#123;</span><br><span class="line">					maxx &#x3D; max(maxx, q-&gt;r);</span><br><span class="line">					maxy &#x3D; max(maxy, q-&gt;c);</span><br><span class="line">				&#125;</span><br><span class="line">				if (max(maxx, maxy) &lt; max(w, h) &amp;&amp; min(maxx, maxy) &lt; min(w, h)) sum++;</span><br><span class="line">			&#125;</span><br><span class="line">			ans[n][w][h] &#x3D; sum;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判重及旋转-平移，翻转"><a href="#判重及旋转-平移，翻转" class="headerlink" title="判重及旋转,平移，翻转"></a>判重及旋转,平移，翻转</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">g normal(const g&amp; p) &#123;</span><br><span class="line">int minx &#x3D; p.begin()-&gt;r, miny &#x3D; p.begin()-&gt;c;</span><br><span class="line">for (g::iterator i &#x3D; p.begin(); i !&#x3D; p.end(); i++) &#123;</span><br><span class="line">	minx &#x3D; min(minx, i-&gt;r);</span><br><span class="line">	miny &#x3D; min(miny, i-&gt;c);</span><br><span class="line">&#125;</span><br><span class="line">g p2;</span><br><span class="line">for (g::iterator i &#x3D; p.begin(); i !&#x3D; p.end(); i++)</span><br><span class="line">	p2.insert(node(i-&gt;r - minx, i-&gt;c - miny));</span><br><span class="line">return p2;</span><br><span class="line">&#125;</span><br><span class="line">g turn(const g&amp;p) &#123;</span><br><span class="line">g p2;</span><br><span class="line">for (g::iterator i &#x3D; p.begin(); i !&#x3D; p.end(); i++)</span><br><span class="line">	p2.insert(node(i-&gt;c, -i-&gt;r));</span><br><span class="line">return normal(p2);</span><br><span class="line">&#125;</span><br><span class="line">g filp(const g&amp;p) &#123;</span><br><span class="line">g p2;</span><br><span class="line">for (g::iterator i &#x3D; p.begin(); i !&#x3D; p.end(); i++)</span><br><span class="line">	p2.insert(node(i-&gt;r, -i-&gt;c));</span><br><span class="line">return normal(p2);</span><br><span class="line">&#125;</span><br><span class="line">void insert(const g&amp; p, node nd) &#123;</span><br><span class="line">g p2 &#x3D; p;</span><br><span class="line">p2.insert(nd);</span><br><span class="line">p2 &#x3D; normal(p2);</span><br><span class="line">int n &#x3D; p2.size();</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">	if (animals[n].count(p2)) return;</span><br><span class="line">	p2 &#x3D; turn(p2);</span><br><span class="line">&#125;</span><br><span class="line">p2 &#x3D; filp(p2);</span><br><span class="line">for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">	if (animals[n].count(p2)) return;</span><br><span class="line">	p2 &#x3D; turn(p2);</span><br><span class="line">&#125;</span><br><span class="line">animals[n].insert(p2);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">int r, c;</span><br><span class="line">node(int r &#x3D; 0, int c &#x3D; 0) :r(r), c(c) &#123;&#125;</span><br><span class="line">bool operator &lt; (const node &amp;a) const &#123; return r &lt; a.r || r &#x3D;&#x3D; a.r &amp;&amp; c &lt; a.c; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">typedef set&lt;node&gt; g;</span><br><span class="line">const int maxn &#x3D; 10;</span><br><span class="line">int dx[] &#x3D; &#123; 1,-1,0,0 &#125;;</span><br><span class="line">int dy[] &#x3D; &#123; 0,0,1,-1 &#125;;</span><br><span class="line">g normal(const g&amp; p);</span><br><span class="line">g turn(const g&amp; p);</span><br><span class="line">g filp(const g&amp; p);</span><br><span class="line">void insert(const g&amp; p, node nd);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, h, w;</span><br><span class="line">get_ans();</span><br><span class="line">while (cin &gt;&gt; n &gt;&gt; w &gt;&gt; h)</span><br><span class="line">	cout &lt;&lt; ans[n][w][h] &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂计算</title>
    <url>/2020/01/20/%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="UVA-1374-快速幂计算"><a href="#UVA-1374-快速幂计算" class="headerlink" title="UVA 1374 快速幂计算"></a>UVA 1374 快速幂计算</h1><p>初始有x，问经过多少次乘除可以得到目标值n。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>与埃及积分有相似之处，可以采用迭代加深搜的方法。由于题干要求每次都是两项的积，所以不能用二分求幂。</p>
</li>
<li><p>关于剪枝</p>
<ol start="2">
<li>如果当前序列的最大数乘以2<sup>maxd-d</sup>&lt;n，则应该剪枝。因为即使剩余的maxd-d层都是乘以当前序列的最大值(即最大的幂次乘以2，即左移一位)仍然小于n，则说明这一支不可能达到n了，故需要剪掉。</li>
</ol>
</li>
<li><p>关于节点排序：为了更快的接近目标，应该优先扩展较大的数，优先加法再试减法。这样可以在最后一次迭代中，无需等待整个解答树扩展完成即可找到解。</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int res[50];</span><br><span class="line">int maxd;</span><br><span class="line">bool dfs(int d, int maxn);</span><br><span class="line">int n;</span><br><span class="line">int main() &#123;</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">	for (maxd &#x3D; 0;; maxd++)</span><br><span class="line">		if (dfs(0, 1)) break;</span><br><span class="line">	printf(&quot;%d\n&quot;, maxd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool dfs(int d, int maxn) &#123;&#x2F;&#x2F;当前的步数d，当前的最大值maxn</span><br><span class="line">if (d &#x3D;&#x3D; maxd)</span><br><span class="line">	if (maxn &#x3D;&#x3D; n || maxn &lt;&lt; (maxd - d) &#x3D;&#x3D; n) return true;</span><br><span class="line">if (maxn &lt;&#x3D; 0 || maxn &lt;&lt; (maxd - d) &lt; n) return false;</span><br><span class="line">res[d] &#x3D; maxn;</span><br><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; d; i++) &#123;</span><br><span class="line">	if (dfs(d + 1, maxn + res[i])) return true;</span><br><span class="line">	if (dfs(d + 1, maxn - res[i])) return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/2020/01/20/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="uva-1592-数据库"><a href="#uva-1592-数据库" class="headerlink" title="uva 1592 数据库"></a>uva 1592 数据库</h1><p>输入一个n行m列的数据库，是否存在两个不同行r1，r2和两个不同列c1，c2，使得这两行和两列相同。（即（r1,c1）和（r2,c1）相同，（r1,c2）和（r2,c2）相同）</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>由于最终要判断是否相同，所以可以将字符串映射为一个值，以减少比较的时间</li>
<li>主循环中，在c1,c2下循环r，并将（r,c1）,(r,c2)存成一个二元组，将二元组映射为当前的行号，如果图中已存在这样的二元组，那么对应的值即为r2，当前行为r1。</li>
<li>由于有以二元组为键类型的图，所以结构体中要重写“&lt;”，否则会报错<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    #include&lt;iostream&gt;</span><br><span class="line">    #include&lt;string&gt;</span><br><span class="line">    #include&lt;set&gt;</span><br><span class="line">    #include&lt;map&gt;</span><br><span class="line">    #include&lt;vector&gt;</span><br><span class="line">    using namespace std;</span><br><span class="line">    map&lt;string, int&gt; location;</span><br><span class="line">    set&lt;string&gt; same;</span><br><span class="line">    vector&lt;int&gt; str[100000];</span><br><span class="line">    typedef struct point &#123;</span><br><span class="line">    	int x;</span><br><span class="line">    	int y;</span><br><span class="line">    	point(int x, int y) :x(x), y(y) &#123;&#125;</span><br><span class="line">    	bool operator &lt; (const point&amp; r) const &#123; return x &lt; r.x || x &#x3D;&#x3D; r.x&amp;&amp;y &lt; r.y; &#125;</span><br><span class="line">    &#125;point;</span><br><span class="line">※※注意此处重写“&lt;”的方法</span><br><span class="line"></span><br><span class="line">	int main() &#123;</span><br><span class="line">	int r, c;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;r, &amp;c) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">		getchar();</span><br><span class="line">		same.clear();</span><br><span class="line">		location.clear();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) str[i].clear();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; c; j++) &#123;</span><br><span class="line">				string s;</span><br><span class="line">				char cs &#x3D; getchar();</span><br><span class="line">				while (cs !&#x3D; &#39;,&#39;&amp;&amp;cs !&#x3D; &#39;\n&#39;) &#123;</span><br><span class="line">					s +&#x3D; cs;</span><br><span class="line">					cs &#x3D; getchar();</span><br><span class="line">				&#125;</span><br><span class="line">				if (!same.count(s)) &#123;</span><br><span class="line">					location[s] &#x3D; i * r + j;</span><br><span class="line">					same.insert(s);</span><br><span class="line">				&#125;</span><br><span class="line">				str[i].push_back(location[s]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">**利用set和map，将每种字符串映射为唯一的值**</span><br><span class="line"></span><br><span class="line">		map&lt;point, int&gt; data;</span><br><span class="line">		for (int c1 &#x3D; 0; c1 &lt; c; c1++) &#123;</span><br><span class="line">			for (int c2 &#x3D; c1 + 1; c2 &lt; c; c2++) &#123;</span><br><span class="line">				data.clear();</span><br><span class="line">				for (int r1 &#x3D; 0; r1 &lt; r; r1++) &#123;</span><br><span class="line">					int x &#x3D; str[r1][c1];</span><br><span class="line">					int y &#x3D; str[r1][c2];</span><br><span class="line">					point p(x, y);</span><br><span class="line">					if (!data.count(p)) data[p] &#x3D; r1;</span><br><span class="line">					else &#123;</span><br><span class="line">						cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl &lt;&lt; data[p] + 1 &lt;&lt; &quot; &quot; &lt;&lt; r1 + 1 &lt;&lt; endl</span><br><span class="line">							&lt;&lt; c1 + 1 &lt;&lt;&quot; &quot;&lt;&lt; c2 + 1 &lt;&lt; endl;</span><br><span class="line">						goto here;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">		here:;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1></li>
<li>本题在循环前的映射与集合栈计算机类似，本题中目的是减少比较时的时间</li>
<li>本题应把两列最为一个整体，否则需要四重循环，会TEL</li>
<li>学习结构体初始化和重写操作符的方法。</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>木块问题</title>
    <url>/2020/01/20/%E6%9C%A8%E5%9D%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="UVa101-木块游戏"><a href="#UVa101-木块游戏" class="headerlink" title="UVa101 木块游戏"></a>UVa101 木块游戏</h1><h3 id="输入n，得到编号为0n-1的木块，分别摆放在顺序排列编号为0n-1的位置。现对这些木块进行操作，操作分为四种"><a href="#输入n，得到编号为0n-1的木块，分别摆放在顺序排列编号为0n-1的位置。现对这些木块进行操作，操作分为四种" class="headerlink" title="输入n，得到编号为0n-1的木块，分别摆放在顺序排列编号为0n-1的位置。现对这些木块进行操作，操作分为四种:"></a>输入n，得到编号为0<del>n-1的木块，分别摆放在顺序排列编号为0</del>n-1的位置。现对这些木块进行操作，操作分为四种:</h3><h3 id="1、move-a-onto-b：把木块a、b上的木块放回各自的原位，再把a放到b上；"><a href="#1、move-a-onto-b：把木块a、b上的木块放回各自的原位，再把a放到b上；" class="headerlink" title="1、move a onto b：把木块a、b上的木块放回各自的原位，再把a放到b上；"></a>1、move a onto b：把木块a、b上的木块放回各自的原位，再把a放到b上；</h3><h3 id="2、move-a-over-b：把a上的木块放回各自的原位，再把a发到含b的堆上；"><a href="#2、move-a-over-b：把a上的木块放回各自的原位，再把a发到含b的堆上；" class="headerlink" title="2、move a over b：把a上的木块放回各自的原位，再把a发到含b的堆上；"></a>2、move a over b：把a上的木块放回各自的原位，再把a发到含b的堆上；</h3><h3 id="3、pile-a-onto-b：把b上的木块放回各自的原位，再把a连同a上的木块移到b上；"><a href="#3、pile-a-onto-b：把b上的木块放回各自的原位，再把a连同a上的木块移到b上；" class="headerlink" title="3、pile a onto b：把b上的木块放回各自的原位，再把a连同a上的木块移到b上；"></a>3、pile a onto b：把b上的木块放回各自的原位，再把a连同a上的木块移到b上；</h3><h3 id="4、pile-a-over-b：把a连同a上木块移到含b的堆上。"><a href="#4、pile-a-over-b：把a连同a上木块移到含b的堆上。" class="headerlink" title="4、pile a over b：把a连同a上木块移到含b的堆上。"></a>4、pile a over b：把a连同a上木块移到含b的堆上。</h3><h3 id="当输入quit时，结束操作并输出0-n-1的位置上的木块情况"><a href="#当输入quit时，结束操作并输出0-n-1的位置上的木块情况" class="headerlink" title="当输入quit时，结束操作并输出0~n-1的位置上的木块情况"></a>当输入quit时，结束操作并输出0~n-1的位置上的木块情况</h3><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>10</p>
<p>move 9 onto 1</p>
<p>move 8 over 1</p>
<p>move 7 over 1</p>
<p>move 6 over 1</p>
<p>pile 8 over 6</p>
<p>pile 8 over 5</p>
<p>move 2 over 1</p>
<p>move 4 over 9</p>
<p>quit</p>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p> 0: 0</p>
<p> 1: 1 9 2 4</p>
<p> 2:</p>
<p> 3: 3</p>
<p> 4:</p>
<p> 5: 5 8 7 6</p>
<p> 6:</p>
<p> 7:</p>
<p> 8:</p>
<p> 9:</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h3 id="通过四种指令的描述，可以注意到，move指令与把a上的木块全部归位相联系；onto指令与把b上方的木块归位相联系；并且每条指令都包含把a-或a的上方的木块-移动到b上方的部分；因此，应该对应以上三点来写各模块；"><a href="#通过四种指令的描述，可以注意到，move指令与把a上的木块全部归位相联系；onto指令与把b上方的木块归位相联系；并且每条指令都包含把a-或a的上方的木块-移动到b上方的部分；因此，应该对应以上三点来写各模块；" class="headerlink" title="通过四种指令的描述，可以注意到，move指令与把a上的木块全部归位相联系；onto指令与把b上方的木块归位相联系；并且每条指令都包含把a(或a的上方的木块)移动到b上方的部分；因此，应该对应以上三点来写各模块；"></a>通过四种指令的描述，可以注意到，move指令与把a上的木块全部归位相联系；onto指令与把b上方的木块归位相联系；并且每条指令都包含把a(或a的上方的木块)移动到b上方的部分；因此，应该对应以上三点来写各模块；</h3><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="模块一"><a href="#模块一" class="headerlink" title="模块一"></a>模块一</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">查找编号为a的木块所在堆和高度，用引用传递</span><br><span class="line"></span><br><span class="line">    void find(int a, int &amp;pa, int &amp;h) &#123;</span><br><span class="line">    	for (pa &#x3D; 0; pa &lt; n; pa++) &#123;</span><br><span class="line">    		for (h &#x3D; 0; h &lt; p[pa].size(); h++) &#123;</span><br><span class="line">    			if (p[pa][h] &#x3D;&#x3D; a) return;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="模块二"><a href="#模块二" class="headerlink" title="模块二"></a>模块二</h2><p>把a堆高度为h的木块的所有木块归位。注意，本题中的归位是把a放回初始的堆里即可，不考虑初始高度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> void clear_above(int a, int h) &#123;</span><br><span class="line">    	for (int i &#x3D; h + 1; i &lt; p[a].size(); i++) &#123;</span><br><span class="line">    		p[p[a][i]].push_back(p[a][i]);</span><br><span class="line">    	&#125;</span><br><span class="line">    	p[a].resize(h + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模块三"><a href="#模块三" class="headerlink" title="模块三"></a>模块三</h2><p>把p堆高度为h及其上方的木块整体移动到p2堆顶:1.移动2.截断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   void pile_onto(int p1, int h, int p2) &#123;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; h; i &lt; p[p1].size(); i++) &#123;</span><br><span class="line">	p[p2].push_back(p[p1][i]);</span><br><span class="line">&#125;</span><br><span class="line">p[p1].resize(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模块四"><a href="#模块四" class="headerlink" title="模块四"></a>模块四</h2><p>输出各堆的序列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void print()&#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt; &quot;:&quot;;</span><br><span class="line">	for (int j &#x3D; 0; j &lt; p[i].size(); j++) &#123;</span><br><span class="line">		cout &lt;&lt; &quot; &quot; &lt;&lt; p[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) p[i].push_back(i);</span><br><span class="line">string s1, s2;</span><br><span class="line">int a, b;</span><br><span class="line">while (cin &gt;&gt; s1 &gt;&gt; a &gt;&gt; s2 &gt;&gt; b) &#123;</span><br><span class="line">	int pa, pb, ha, hb;</span><br><span class="line">	find(a, pa, ha);</span><br><span class="line">	find(b, pb, hb);</span><br><span class="line">	if (pa &#x3D;&#x3D; pb) continue;&#x2F;&#x2F;非法指令</span><br><span class="line">	</span><br><span class="line">	if (s1 &#x3D;&#x3D; &quot;move&quot;) clear_above(pa, ha);</span><br><span class="line">	if (s2 &#x3D;&#x3D; &quot;onto&quot;) clear_above(pb, hb);</span><br><span class="line">	pile_onto(pa, ha, pb);</span><br><span class="line">&#125;</span><br><span class="line">print();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><ol>
<li>本题应主要学习他的拆分思路,以及引用传递的运用。</li>
<li>学习vector类，vector<typename> xname;</li>
<li>学习vector的基本方法，push_back(要插入的元素) 和 resize(元素个数);</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2020/01/20/%E6%A0%91/</url>
    <content><![CDATA[<h1 id="uva-548-树"><a href="#uva-548-树" class="headerlink" title="uva 548 树"></a>uva 548 树</h1><p>&ensp;输入一个二叉树的中序和后序遍历，请你输出一个叶子节点，该叶子节点到根的数值总和最小，且这个叶子是编号最小的那个。 输入： 您的程序将从输入文件中读取两行(直到文件结尾)。第一行是树的中序遍历值序列,第二行是树的后序遍历值序列。所有值将不同，大于零且小于或等于10000.二叉树的节1&lt;=N&lt;=10000。 输出： 对于每个树描述，您应该输出最小值路径的叶节点的值。存在多路径最小的情况下，您应该选择终端叶子节点上具有最小值的那条路径，且输出那个最小值的终端叶子。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>根据中序和后序序列构造二叉树</p>
</li>
<li><p>递归遍历二叉树，每一步走左右子树中权值较小的一个</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    #include&lt;iostream&gt;</span><br><span class="line">    #include&lt;string&gt;</span><br><span class="line">    #include&lt;sstream&gt;</span><br><span class="line">    # pragma warning(disable:4996)</span><br><span class="line">    # define LOCAL</span><br><span class="line">    # ifdef LOCAL</span><br><span class="line">    FILE *fin &#x3D; freopen(&quot;树in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    FILE *fout &#x3D; freopen(&quot;树out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    # endif </span><br><span class="line">    using namespace std;</span><br><span class="line">    # define maxn 10000</span><br><span class="line">    int n &#x3D; 0;</span><br><span class="line">    bool read(int *a) &#123;</span><br><span class="line">&gt;数组为参数的时候可以用指针，传首地址</span><br><span class="line"></span><br><span class="line">    	string s;</span><br><span class="line">    	getline(cin, s);</span><br><span class="line">    	stringstream ss(s);</span><br><span class="line">&gt;注意此处，用ss来读取一行不定数量的以空格分隔的数字</span><br><span class="line"></span><br><span class="line">    	n &#x3D; 0;</span><br><span class="line">    	int x;</span><br><span class="line">    	while (ss &gt;&gt; x) a[n++] &#x3D; x;</span><br><span class="line">    	return n &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int post_order[maxn], in_order[maxn],lch[maxn],rch[maxn];</span><br><span class="line">    </span><br><span class="line">&gt;其中rch[i]表示编号为i的节点的右孩子</span><br><span class="line">&#96;</span><br><span class="line">    int build(int l1, int r1, int l2, int r2) &#123;</span><br><span class="line">    	if (l1 &gt; r1) return 0;&#x2F;&#x2F;空树</span><br><span class="line">&gt;本题中以权值代表编号，为0表示节点不存在</span><br><span class="line"></span><br><span class="line">    	int root &#x3D; post_order[r2];&#x2F;&#x2F;后序序列的最后一个</span><br><span class="line">    	int p &#x3D; l1;</span><br><span class="line">    	while (in_order[p] !&#x3D; root) p++;</span><br><span class="line">    	int cnt &#x3D; p-l1;&#x2F;&#x2F;左子树中节点个数</span><br><span class="line">    	</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;分别在左右子树中递归遍历</span><br><span class="line">    	lch[root] &#x3D; build(l1, p - 1, l2 , l2 + cnt - 1);</span><br><span class="line">    	rch[root] &#x3D; build(p + 1, r1, l2 + cnt, r2 - 1);</span><br><span class="line">    	return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int best, best_sum;</span><br><span class="line">    void dfs(int u, int sum) &#123;</span><br><span class="line">    	sum +&#x3D; u;</span><br><span class="line">    	if (!lch[u] &amp;&amp; !rch[u]) &#123;&#x2F;&#x2F;如果u是叶子节点</span><br><span class="line">    		if (sum &lt; best_sum || (best_sum &#x3D;&#x3D; sum &amp;&amp; u &lt; best)) </span><br><span class="line">			&#123;</span><br><span class="line">    			best &#x3D; u;</span><br><span class="line">    			best_sum &#x3D; sum;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    </span><br><span class="line">    	if (lch[u]) dfs(lch[u], sum);</span><br><span class="line">    	if (rch[u]) dfs(rch[u], sum);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    int main() &#123;</span><br><span class="line">    	while (read(in_order)) &#123;</span><br><span class="line">    		read(post_order);</span><br><span class="line">    		build(0, n - 1, 0, n - 1);</span><br><span class="line">    		best_sum &#x3D; 1e9;&#x2F;&#x2F;</span><br><span class="line">    		dfs(post_order[n - 1], 0);</span><br><span class="line">    		cout &lt;&lt; best &lt;&lt; endl;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1></li>
<li><p>输入也可以写成子函数的形式</p>
</li>
<li><p>学习中后造树和递归遍历二叉树的方法</p>
<pre><code>void dfs(树根指针){
if(左子树为空（为0）&amp;&amp;右子树为空（为0）)
    {

        return 0;
    }
if(左孩子不为空) dfs（左孩子）
if(右孩子不为空) dfs（右孩子）
}</code></pre></li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>破坏正方形</title>
    <url>/2020/01/20/%E7%A0%B4%E5%9D%8F%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="UVA-1603-破坏正方形"><a href="#UVA-1603-破坏正方形" class="headerlink" title="UVA 1603 破坏正方形"></a>UVA 1603 破坏正方形</h1><p>一个 n×n的网格,共 2×n×(n+1)条边,现在已经删除了一些边,问至 少还需删去多少边,可以使得剩下的边不能构成正方形。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>可以采用迭代加深度深搜，或者回溯法解决</p>
</li>
<li><p>搜索对象可以是木棍或者正方形，对应不同的剪枝</p>
<ol>
<li>如果搜索对象是木棍，那么可以将每个木棍影响的正方形数量记录下来，从大到小排序。当最大影响数量为1时，可以停止搜索，结果为当前层数+剩余正方形数。这是因为如果最大影响数为1，说明剩余正方形之间没有耦合，删除任一木棍，至多减少1个正方形。</li>
<li>如果搜索对象是正方形，那么应该从小正方形开始破坏。本题中采用这种方法。</li>
</ol>
</li>
<li><p>此外，还需要找规律，寻找各行各列，竖线横线的标号关系。以标记构成正方形的边。</p>
</li>
<li><p>本题中判断是否为正方形，<strong>通过size数组和full数组，分别记录第cnt个正方形实际有的边和应该有的边，如果二者相等，那么是一个完整的正方形</strong></p>
</li>
<li><p>本题中使用了回溯法，因为搜素深度有明显的上界2<em>n</em>(n+1)，其中n为边长。</p>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void dfs(int d) &#123;</span><br><span class="line">if (d &gt;&#x3D; maxd) return;</span><br><span class="line">int next &#x3D; getNext();</span><br><span class="line">if (next &#x3D;&#x3D; 0) &#123;</span><br><span class="line">	maxd &#x3D; d;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">for (int j &#x3D; 1; j &lt;&#x3D; sum; j++) &#123;</span><br><span class="line">	if (in[next][j])</span><br><span class="line">	&#123;</span><br><span class="line">		for (int k &#x3D; 1; k &lt;&#x3D; cnt; k++)&#x2F;&#x2F;删掉火柴棍</span><br><span class="line">			if (in[k][j]) Size[k]--;</span><br><span class="line">		dfs(d + 1);</span><br><span class="line">		for (int k &#x3D; 1; k &lt;&#x3D; cnt; k++)&#x2F;&#x2F;复原</span><br><span class="line">			if (in[k][j]) Size[k]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在删除木棍和回溯的部分，由于判断是才用size[i]==full[i]，所以in[k][j]处必有火柴。</li>
</ol>
<h2 id="getr-getc-求横竖线编号"><a href="#getr-getc-求横竖线编号" class="headerlink" title="getr,getc 求横竖线编号"></a>getr,getc 求横竖线编号</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">inline int getr(int r, int c) &#123;</span><br><span class="line">return r * (2 * n + 1) + c + 1;</span><br><span class="line">&#125;</span><br><span class="line">inline int getc(int r, int c) &#123;</span><br><span class="line">return r * (2 * n + 1) + c + n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="get-cnt-填充size数组和full数组"><a href="#get-cnt-填充size数组和full数组" class="headerlink" title="get_cnt 填充size数组和full数组"></a>get_cnt 填充size数组和full数组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">inline void get_cnt() &#123;</span><br><span class="line">int a, b, e, f;</span><br><span class="line">cnt &#x3D; 0;</span><br><span class="line">for (int len &#x3D; 1; len &lt;&#x3D; n; len++) &#123;</span><br><span class="line">	for (int r &#x3D; 0; r + len &lt;&#x3D; n; r++) &#123;</span><br><span class="line">		for (int c &#x3D; 0; c + len &lt;&#x3D; n; c++) &#123;</span><br><span class="line">			++cnt;</span><br><span class="line">			full[cnt] &#x3D; len * 4;</span><br><span class="line">			Size[cnt] &#x3D; 0;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				a &#x3D; getr(r, c + i);</span><br><span class="line">				b &#x3D; getr(r + len, c + i);</span><br><span class="line">				e &#x3D; getc(r + i, c);</span><br><span class="line">				f &#x3D; getc(r + i, c + len);</span><br><span class="line">				in[cnt][a] &#x3D; true;</span><br><span class="line">				in[cnt][b] &#x3D; true;</span><br><span class="line">				in[cnt][e] &#x3D; true;</span><br><span class="line">				in[cnt][f] &#x3D; true;</span><br><span class="line">				Size[cnt] +&#x3D; sticks[a] + sticks[b] + sticks[e] + sticks[f];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>注意这种判断的思维。</li>
</ol>
<h2 id="main-函数"><a href="#main-函数" class="headerlink" title="main 函数"></a>main 函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int n, maxd, cnt, sum;</span><br><span class="line">bool sticks[2 * maxn*(maxn + 1) + 1];</span><br><span class="line">int Size[625];</span><br><span class="line">int full[625];</span><br><span class="line">int in[625][2 * maxn*(maxn + 1) + 1];</span><br><span class="line">int main() &#123;</span><br><span class="line">int T, k, tmp;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">while (T--) &#123;</span><br><span class="line">	scanf(&quot;%d\n%d&quot;, &amp;n, &amp;k);</span><br><span class="line">	memset(sticks, 1, sizeof(sticks));</span><br><span class="line">	memset(in, 0, sizeof(in));</span><br><span class="line">	while (k--) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;tmp);</span><br><span class="line">		sticks[tmp] &#x3D; false;</span><br><span class="line">	&#125;</span><br><span class="line">	sum &#x3D; 2 * n*(n + 1);</span><br><span class="line">	maxd &#x3D; sum;</span><br><span class="line">	get_cnt();</span><br><span class="line">	dfs(0);</span><br><span class="line">	printf(&quot;%d\n&quot;, maxd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>空间结构</title>
    <url>/2020/01/20/%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="UVA-806-空间结构"><a href="#UVA-806-空间结构" class="headerlink" title="UVA 806 空间结构"></a>UVA 806 空间结构</h1><p><img src="/img_UVA%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/6.png" alt=""></p>
<p><img src="/img_UVA%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0/7.png" alt=""></p>
<p>一个四分树是由一个方格的结构组成的，如图：（就是上面的三个图）。</p>
<p>那些像素点可以构成一个四分树，如图：（就是上面的那个树）。</p>
<p>我们规定，NW=1,NE=2,SW=3,SE=4，而一个节点所构成的数字串可以认为是一个五进制数，将它们排序后输出。</p>
<p>例如：上图中地四号节点的路径为NE,SW，所以是32532_5325​ （五进制数）=171017_{10}1710​（十进制数）</p>
<p>那么上树所对应的一传数列为：（在十进制下）</p>
<p>9 14 17 22 23 44 63 69 88 94 113\text{9 14 17 22 23 44 63 69 88 94 113} 9 14 17 22 23 44 63 69 88 94 113</p>
<p>你的任务是在这两者之间转换。</p>
<p>注意，数串中的数字顺序是从叶子到根的，别搞错了。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>对于n&gt;0的情况，需要将矩阵转化为四分树。</p>
<p> 采用递归算法，每次递归四分之一块，如果遇到范围内纯黑或纯白，则返回。并且在遇到纯黑时，将序列存入向量中。</p>
<p> 注意：要先判断整个图是否为纯黑或者纯白。</p>
<p> 然后将五进制转化为十进制</p>
</li>
<li><p>对于n&lt;0的情况，将四分树转化为矩阵<br> 先将十进制转化为五进制，并在字符串尾部添加*，以标识叶子节点<br> 采用递归算法，每次根据当前字符，来选择下一步递归的范围。当遇到叶子节点时，将当前层的范围内的点涂黑</p>
<p> 注意：pre向量中的每个元素，代表一条从根到叶子的路径，所以要用循环配合递归。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   using namespace std;</span><br><span class="line">   </span><br><span class="line">   vector&lt;int&gt; number;</span><br><span class="line">   vector&lt;string&gt; pre;</span><br><span class="line">   char g[64][64];</span><br><span class="line">   int n;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">   	int first &#x3D; 1;</span><br><span class="line">   	int kase &#x3D; 0;</span><br><span class="line">   	while (cin &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">   		if (first) first &#x3D; 0; else cout &lt;&lt; endl;</span><br><span class="line">   		cout &lt;&lt; &quot;Image &quot; &lt;&lt; ++kase &lt;&lt; endl;</span><br><span class="line">   		number.clear();</span><br><span class="line">   		pre.clear();</span><br><span class="line">   		memset(g, &#39;.&#39;, sizeof(g));</span><br><span class="line">   		getchar();</span><br><span class="line"></span><br><span class="line">   		if (n &gt; 0) &#123;</span><br><span class="line">   			for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">   				for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">   					cin &gt;&gt; g[i][j];</span><br><span class="line">   		</span><br><span class="line">   		</span><br><span class="line">   			if (judge(0, 0, n,&#39;0&#39;)) number.push_back(0);</span><br><span class="line">			&#x2F;&#x2F;纯黑的情况</span><br><span class="line">   			else if (judge(0, 0, n,&#39;1&#39;));&#x2F;&#x2F;纯白</span><br><span class="line">   			</span><br><span class="line">   			else &#123;</span><br><span class="line">   				matrix(&quot;1&quot;, 0, 0, n &#x2F; 2);</span><br><span class="line">   				matrix(&quot;2&quot;, 0, n &#x2F; 2, n &#x2F; 2);</span><br><span class="line">   				matrix(&quot;3&quot;, n &#x2F; 2, 0, n &#x2F; 2);</span><br><span class="line">   				matrix(&quot;4&quot;, n &#x2F; 2, n &#x2F; 2, n &#x2F; 2);</span><br><span class="line">   				ten();</span><br><span class="line">   			&#125;</span><br><span class="line">   			</span><br><span class="line">   			</span><br><span class="line">   			sort(number.begin(), number.end());</span><br><span class="line">   			if (!number.empty()) &#123;</span><br><span class="line">   				for (int i &#x3D; 0; i &lt; number.size(); i++)</span><br><span class="line">   				&#123;</span><br><span class="line">   					cout &lt;&lt; number[i];</span><br><span class="line">   					if ((i + 1) % 12 &#x3D;&#x3D; 0||i&#x3D;&#x3D;number.size()-1) cout &lt;&lt; endl;</span><br><span class="line">   					else cout &lt;&lt; &quot; &quot;;</span><br><span class="line">   				&#125;</span><br><span class="line">   			&#125;</span><br><span class="line">   </span><br><span class="line">   			cout &lt;&lt; &quot;Total number of black nodes &#x3D; &quot; &lt;&lt; number.size() &lt;&lt; endl;    			</span><br><span class="line">   		&#125;</span><br><span class="line"></span><br><span class="line">   		if (n &lt; 0) &#123;</span><br><span class="line">   </span><br><span class="line">   			string s;</span><br><span class="line">   			bool flag &#x3D; false;</span><br><span class="line">   			bool zero &#x3D; false;</span><br><span class="line">   			for (;;) &#123;</span><br><span class="line">   				int a;</span><br><span class="line">   				&#x2F;&#x2F;由于输入的结束标志-1不一定出现在哪里，所以</span><br><span class="line">				&#x2F;&#x2F;要设置标志</span><br><span class="line">   				for (int i &#x3D; 0; i &lt; 12; i++) &#123;</span><br><span class="line">   					cin &gt;&gt; a;</span><br><span class="line">   					if (a &#x3D;&#x3D; -1) &#123;</span><br><span class="line">   						flag &#x3D; true;</span><br><span class="line">   						break;</span><br><span class="line">   					&#125;</span><br><span class="line">   					if (a &#x3D;&#x3D; 0)zero &#x3D; true;</span><br><span class="line">   					number.push_back(a);</span><br><span class="line">   				&#125;</span><br><span class="line">   				if (flag) break;</span><br><span class="line">   			&#125;	</span><br><span class="line">   			if (zero) &#123;</span><br><span class="line">			&#x2F;&#x2F;如果包含0，代表它是一个只有一个节点的树</span><br><span class="line">   				memset(g, &#39;*&#39;, sizeof(g));</span><br><span class="line">   			&#125;</span><br><span class="line">   			else &#123;</span><br><span class="line">   				five();</span><br><span class="line">   				for (int i &#x3D; 0; i &lt; pre.size(); i++) &#123;</span><br><span class="line">   					int p &#x3D; 0;</span><br><span class="line">   					draw(pre[i], p, 0, 0, abs(n));</span><br><span class="line">   				&#125;</span><br><span class="line">   			&#125;</span><br><span class="line">   			</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   			for (int i &#x3D; 0; i &lt; abs(n); i++) &#123;</span><br><span class="line">   				for (int j &#x3D; 0; j &lt; abs(n); j++)</span><br><span class="line">   					cout &lt;&lt; g[i][j];</span><br><span class="line">   				cout &lt;&lt; endl;</span><br><span class="line">   			&#125;</span><br><span class="line">   		&#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="judge-判断r，c为起点的边长为w的正方形中是否权威ch色"><a href="#judge-判断r，c为起点的边长为w的正方形中是否权威ch色" class="headerlink" title="judge 判断r，c为起点的边长为w的正方形中是否权威ch色"></a>judge 判断r，c为起点的边长为w的正方形中是否权威ch色</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  bool judge(int r, int c, int w,char ch) &#123;</span><br><span class="line">&#x2F;&#x2F; ch为0代表是否纯黑，为1代表是否纯白</span><br><span class="line">  	for (int i &#x3D; r; i &lt; r + w; i++)</span><br><span class="line">  		for (int j &#x3D; c; j &lt; c + w; j++)</span><br><span class="line">  			if (g[i][j] &#x3D;&#x3D; ch)</span><br><span class="line">  				return false;</span><br><span class="line">  	return true;	&#x2F;&#x2F;任何情况下都要有return否则会RE</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="matrix-递归记录路径信息，当遇到纯黑的块时，递归返回"><a href="#matrix-递归记录路径信息，当遇到纯黑的块时，递归返回" class="headerlink" title="matrix 递归记录路径信息，当遇到纯黑的块时，递归返回"></a>matrix 递归记录路径信息，当遇到纯黑的块时，递归返回</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void matrix(string str, int r, int c, int w) &#123;</span><br><span class="line">	</span><br><span class="line">	if (judge(r, c, w,&#39;0&#39;)) &#123;</span><br><span class="line">		pre.push_back(str);	&#x2F;&#x2F;纯黑则递归到头，将序列保存</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (judge(r, c, w,&#39;1&#39;)) return;</span><br><span class="line">	else &#123;</span><br><span class="line">		matrix(str + &quot;1&quot;, r, c, w &#x2F; 2);</span><br><span class="line">		matrix(str + &quot;2&quot;, r, c + w &#x2F; 2, w &#x2F; 2);</span><br><span class="line">		matrix(str + &quot;3&quot;, r + w &#x2F; 2, c, w &#x2F; 2);</span><br><span class="line">		matrix(str + &quot;4&quot;, r + w &#x2F; 2, c + w &#x2F; 2, w &#x2F; 2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ten-将五进制的路径信息转成转十进制数"><a href="#ten-将五进制的路径信息转成转十进制数" class="headerlink" title="ten 将五进制的路径信息转成转十进制数"></a>ten 将五进制的路径信息转成转十进制数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void ten() &#123;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; pre.size(); i++) &#123;</span><br><span class="line">		int temp &#x3D; 0;</span><br><span class="line">		for (int j &#x3D; pre[i].size() - 1; j &gt;&#x3D; 0; j--)</span><br><span class="line">			temp +&#x3D; (pre[i][j] - &#39;0&#39;)*pow(5, j);</span><br><span class="line">		number.push_back(temp);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="draw-在r-c开始边长为w范围内填充s-p-开始的颜色"><a href="#draw-在r-c开始边长为w范围内填充s-p-开始的颜色" class="headerlink" title="draw 在r,c开始边长为w范围内填充s[p]开始的颜色"></a>draw 在r,c开始边长为w范围内填充s[p]开始的颜色</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void draw(const string s, int &amp;p, int r, int c, int w) &#123;</span><br><span class="line"></span><br><span class="line">	if (p &#x3D;&#x3D; s.length()) return;</span><br><span class="line">	char ch &#x3D; s[p++];</span><br><span class="line">	switch (ch - &#39;0&#39;)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	case 1:	draw(s, p, r, c, w &#x2F; 2); break;</span><br><span class="line">	case 2: draw(s, p, r, c + w &#x2F; 2, w &#x2F; 2); break;</span><br><span class="line">	case 3:	draw(s, p, r + w &#x2F; 2, c, w &#x2F; 2); break;</span><br><span class="line">	case 4:	draw(s, p, r + w &#x2F; 2, c + w &#x2F; 2, w &#x2F; 2); break;</span><br><span class="line">	default:</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	if (ch &#x3D;&#x3D; &#39;*&#39;) &#123;</span><br><span class="line">		for (int i &#x3D; r; i &lt; r + w; i++)</span><br><span class="line">			for (int j &#x3D; c; j &lt; c + w; j++) &#123;</span><br><span class="line">				</span><br><span class="line">					g[i][j] &#x3D; &#39;*&#39;;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="five-将10进制数转成五进制路径信息"><a href="#five-将10进制数转成五进制路径信息" class="headerlink" title="five 将10进制数转成五进制路径信息"></a>five 将10进制数转成五进制路径信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> void five() &#123;</span><br><span class="line"> 	for (int i &#x3D; 0; i &lt; number.size(); i++) &#123;</span><br><span class="line"> 		int temp &#x3D; 0;</span><br><span class="line"> 		while (number[i]) &#123;</span><br><span class="line"> 			temp *&#x3D; 10;		&#x2F;&#x2F;注意此处要先乘10</span><br><span class="line"> 			temp +&#x3D; number[i] % 5;</span><br><span class="line"> 			number[i] &#x3D; number[i] &#x2F; 5;</span><br><span class="line"> 		&#125;</span><br><span class="line"> </span><br><span class="line"> 		pre.push_back(to_string(temp) + &#39;*&#39;);</span><br><span class="line">&#x2F;&#x2F;加*以标识叶子</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li>本题加深了对递归问题的理解，使用递归算法也不是仅仅用递归实现，要搭配循环，减小递归代码的编写难度。</li>
<li>理清思路再写递归，注意认清递归结束条件，不要模糊。</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>集合栈计算机</title>
    <url>/2020/01/20/%E9%9B%86%E5%90%88%E6%A0%88%E8%AE%A1%E7%AE%97%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="UVA-12096-※集合栈计算机※"><a href="#UVA-12096-※集合栈计算机※" class="headerlink" title="UVA 12096 ※集合栈计算机※"></a>UVA 12096 ※集合栈计算机※</h1><p> 输入的命令有如下几种： PUSH：将空集{}压栈 DUP：将栈顶元素复制一份压入栈中 UNION：先进行两次弹栈，将获得的集合A和B取并集，将结果压栈 INTERSECTION：先进行两次弹栈，将获得的集合A和B取交集，将结果压栈 ADD：先进行两次弹栈，将获得的集合A和B中，先出栈的集合（如A先）加入到后出栈的集合，将结果压栈 输出每一步操作后栈顶集合的元素的个数。<br>（输入：先输入测试次数，再输入操作次数，再输入具体操作）</p>
<pre><code>Sample Input
2
9
PUSH
DUP
ADD
PUSH
ADD
DUP
ADD
DUP
UNION
5
PUSH
PUSH
ADD
PUSH
INTERSECT

Sample Output
0
0
1
0
1
1
2
***
0
0
1
0
0</code></pre><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>首先考虑集合的存储问题：由于有集合作为元素插入到另一个集合的情况，所以不能直接定义集合类型的栈。考虑将集合映射到值(map)，另用一个向量存集合本身。</li>
<li>按照题干输入输出判断操作即可。注意后三种操作可以合并简化代码</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><ol>
<li>set_union(A.begin(),A.end(),B.begin(),B.end(),inserter( C1 , C1.begin() ) );前四个参数依次是第一的集合的头尾，第二个集合的头尾。第五个参数的意思是将集合A、B取合集后的结果存入集合C中。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    # define ALL(x) x.begin(),x.end()</span><br><span class="line">    # define INS(x) inserter(x,x.begin())</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;INS(x)插入迭代器，插入而非覆盖</span><br><span class="line">[inserter](https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_37456764&#x2F;article&#x2F;details&#x2F;83019250).</span><br><span class="line"></span><br><span class="line">    using namespace std;</span><br><span class="line">    typedef set&lt;int&gt; Set;</span><br><span class="line">    map&lt;Set, int&gt; id;&#x2F;&#x2F;将每个集合对应一个编号，编号是在向量中的下标</span><br><span class="line">    vector&lt;Set&gt; Setcache;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	while (n--) &#123;</span><br><span class="line">		int m;</span><br><span class="line">		cin &gt;&gt; m;</span><br><span class="line">		stack&lt;int&gt; s;</span><br><span class="line">		while (m--) &#123;</span><br><span class="line">			string op;</span><br><span class="line">			cin &gt;&gt; op;</span><br><span class="line">			if (op[0] &#x3D;&#x3D; &#39;P&#39;) s.push(ID(Set()));</span><br><span class="line">			&#x2F;&#x2F;空集入栈，注意此处空集的写法</span><br><span class="line">			else if (op[0] &#x3D;&#x3D; &#39;D&#39;) s.push(s.top());</span><br><span class="line">			else &#123;</span><br><span class="line">				Set x1 &#x3D; Setcache[s.top()]; s.pop();</span><br><span class="line">				&#x2F;&#x2F;不同直接用pop赋值，因为pop的返回值为void</span><br><span class="line">				Set x2 &#x3D; Setcache[s.top()]; s.pop();</span><br><span class="line">				Set x;</span><br><span class="line">				if (op[0] &#x3D;&#x3D; &#39;U&#39;) set_union(ALL(x1), ALL(x2), INS(x));</span><br><span class="line">				if (op[0] &#x3D;&#x3D; &#39;I&#39;) set_intersection(ALL(x1), ALL(x2), INS(x));</span><br><span class="line">				if (op[0] &#x3D;&#x3D; &#39;A&#39;) &#123; x &#x3D; x2; x.insert(ID(x1)); &#125;</span><br><span class="line">				s.push(ID(x));</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; Setcache[s.top()].size() &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;***&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ID-既是插入又是查询"><a href="#ID-既是插入又是查询" class="headerlink" title="ID  既是插入又是查询"></a>ID  既是插入又是查询</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int ID(Set x) &#123;</span><br><span class="line">	if (id.count(x)) return id[x];&#x2F;&#x2F;存在则返回id</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;不存在则添加</span><br><span class="line">	Setcache.push_back(x);</span><br><span class="line">	return id[x] &#x3D; Setcache.size() - 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li>本题主要注重多种STL的结合使用，尤其是集合映射为整型的处理方式</li>
<li>记住题中交并集的函数，set_union(参数为5个迭代器),set_intersection(参数为5个迭代器);要配合两处define使用</li>
<li>注意模拟多种操作时提取相同部分简化代码，也降低出错的可能性和调试难度。</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>黄金图形</title>
    <url>/2020/01/20/%E9%BB%84%E9%87%91%E5%9B%BE%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="UVA-225-黄金图形"><a href="#UVA-225-黄金图形" class="headerlink" title="UVA 225 黄金图形"></a>UVA 225 黄金图形</h1><p>平面上有k个障碍点。 从(0,0)点出发，第一次走1个单位，第二次走2个单位，……， 第n次走n个单位，恰好回到(0,0)。 要求只能沿着东南西北方向走，且每次必须转弯90°（不能沿着同一个方向继续走，也不能后退）。 走出的图形可以自交，但不能经过障碍点，如图 7-25所示。每个转折点只能走一次。 输入n、k（1≤n≤20，0≤k≤50）和所有障碍点的坐标，输出所有满足要求的移动序列（用 news表示北、东、西、南），按照字典序从小到大排列，最后输出移动序列的总数。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>又要输出所有的路径，所以直观的想到用dfs。dfs中处理好可以移动的方向即可。</li>
<li>本题的特殊之处在于，障碍格可能出现负坐标。由于本题中最长边长n小于等于20，所以采用给(0,0)点以及障碍物点加一个比较大的值来消负号。我是假设n=20，那么一共也就能走1+2+…20/2=105，所以我加了一个120.</li>
<li>注意：卡了很久的原因主要是题干中要求最长边等于n，这条件不仅是限定搜索深度的。他还要求必须包含长度为n的边。</li>
<li>注意每个转折点只能走一次的条件。这个转折点是指每一步走完之后的终点。</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 20;</span><br><span class="line">void dfs(int r, int c, int dir, int step);</span><br><span class="line">int dx[] &#x3D; &#123; 1,0,0,-1 &#125;;&#x2F;&#x2F;东北南西</span><br><span class="line">int dy[] &#x3D; &#123; 0,1,-1,0 &#125;;</span><br><span class="line">int cnt, n;</span><br><span class="line">bool g[maxn * maxn + 1][maxn * maxn + 1];</span><br><span class="line">char direction[] &#x3D; &#123; &#39;e&#39;,&#39;n&#39;,&#39;s&#39;,&#39;w&#39; &#125;;&#x2F;&#x2F;此处元素顺序是为了按字典序进行搜索,注意dx和dy要与此处配合</span><br><span class="line">int path[maxn*maxn];</span><br><span class="line">bool vis[maxn*maxn + 1][maxn*maxn+ 1];</span><br><span class="line">int stax, stay;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int T;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">int k;</span><br><span class="line">while (T--)</span><br><span class="line">&#123;</span><br><span class="line">	int x, y;</span><br><span class="line">	memset(g, 1, sizeof(g));</span><br><span class="line">	memset(path, 0, sizeof(path));</span><br><span class="line">	</span><br><span class="line">	scanf(&quot;%d\n%d&quot;, &amp;n, &amp;k);</span><br><span class="line">	vector&lt;int&gt; tmpx;</span><br><span class="line">	vector&lt;int&gt; tmpy;</span><br><span class="line">	stax &#x3D; stay &#x3D; 120;</span><br><span class="line">	cnt &#x3D; 0;</span><br><span class="line">	while (k--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d %d&quot;, &amp;x, &amp;y);</span><br><span class="line">		g[x + stax][y + stay] &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		dfs(stax, stay, i, 1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;Found %d golygon(s).\n\n&quot;, cnt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dfs-从-r-c-处开始沿着dir方向走step步，注意要先走再判断"><a href="#dfs-从-r-c-处开始沿着dir方向走step步，注意要先走再判断" class="headerlink" title="dfs 从(r,c)处开始沿着dir方向走step步，注意要先走再判断"></a>dfs 从(r,c)处开始沿着dir方向走step步，注意要先走再判断</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void dfs(int r, int c, int dir, int step) &#123;</span><br><span class="line">path[step] &#x3D; dir;</span><br><span class="line">for (int i &#x3D; 0; i &lt; step; i++) &#123;</span><br><span class="line">	r +&#x3D; dx[dir];</span><br><span class="line">	c +&#x3D; dy[dir];</span><br><span class="line">	if (!g[r][c] || r &lt; 0 || c &lt; 0 ) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (vis[r][c]) return;</span><br><span class="line">if (step &gt;&#x3D; n) &#123;</span><br><span class="line">	if (r &#x3D;&#x3D; (stax) &amp;&amp; c &#x3D;&#x3D; (stay)) &#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; step; i++)</span><br><span class="line">			printf(&quot;%c&quot;, direction[path[i]]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vis[r][c] &#x3D; 1;</span><br><span class="line">if (dir &#x3D;&#x3D; 0 || dir &#x3D;&#x3D; 3) &#123;</span><br><span class="line">	dfs(r, c, 1, step + 1);</span><br><span class="line">	dfs(r, c, 2, step + 1);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">	dfs(r, c, 0, step + 1);</span><br><span class="line">	dfs(r, c, 3, step + 1);</span><br><span class="line">&#125;</span><br><span class="line">vis[r][c] &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的重建</title>
    <url>/2020/01/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%87%8D%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="uva-536-二叉树的重建-先中造树"><a href="#uva-536-二叉树的重建-先中造树" class="headerlink" title="uva 536 二叉树的重建 (先中造树)"></a>uva 536 二叉树的重建 (先中造树)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">   #include&lt;string&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;习题6-3in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;习题6-3out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   typedef struct node &#123;</span><br><span class="line">   	struct node *lchild, *rchild;</span><br><span class="line">   	char data;</span><br><span class="line">   &#125;node, *ptr;</span><br><span class="line">   ptr Create(char *pre, char *in, int n)</span><br><span class="line">   &#123;</span><br><span class="line">   	ptr s;</span><br><span class="line">   </span><br><span class="line">   	if (n &#x3D;&#x3D; 1)</span><br><span class="line">   	&#123;</span><br><span class="line">   		s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">   		s-&gt;data &#x3D; *pre;</span><br><span class="line">   		s-&gt;lchild &#x3D; s-&gt;rchild &#x3D; NULL;</span><br><span class="line">   		return s;</span><br><span class="line">   	&#125;</span><br><span class="line">   	char *p;</span><br><span class="line">   	for (p &#x3D; in; p &lt; in + n; p++)</span><br><span class="line">   		if (*p &#x3D;&#x3D; *pre) break;</span><br><span class="line">   	int k &#x3D; p - in;</span><br><span class="line">   	s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">   	s-&gt;data &#x3D; *p;</span><br><span class="line">   	s-&gt;lchild &#x3D; s-&gt;rchild &#x3D; NULL;</span><br><span class="line">   	if (k) s-&gt;lchild &#x3D; Create(pre + 1, in, k);</span><br><span class="line">   	if (n - k - 1) s-&gt;rchild &#x3D; Create(pre + k + 1, p + 1, n - k - 1);</span><br><span class="line">   	return s;</span><br><span class="line">   &#125;</span><br><span class="line">   int lastorder(ptr T)</span><br><span class="line">   &#123;</span><br><span class="line">   	if (!T) return 0;</span><br><span class="line">   	lastorder(T-&gt;lchild);</span><br><span class="line">   	lastorder(T-&gt;rchild);</span><br><span class="line">   	printf(&quot;%c&quot;, T-&gt;data);</span><br><span class="line">   	return 1;</span><br><span class="line">   &#125;</span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">   </span><br><span class="line">   	string pre, in;</span><br><span class="line">   	while (cin &gt;&gt; pre &gt;&gt; in) &#123;</span><br><span class="line">   		int n &#x3D; pre.length();</span><br><span class="line">   		ptr T &#x3D; Create(&amp;pre[0], &amp;in[0], n);</span><br><span class="line">   		lastorder(T);</span><br><span class="line">   		cout &lt;&lt; endl;</span><br><span class="line">   	&#125;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的层序遍历</title>
    <url>/2020/01/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="uva-122-树的层序遍历"><a href="#uva-122-树的层序遍历" class="headerlink" title="uva 122 树的层序遍历"></a>uva 122 树的层序遍历</h1><p>树状结构在电脑科学的许多领域中都相当重要。本问题牵涉到建立树及走访树。</p>
<p>给你一二元树，你的任务是写一个程式来列印依「阶层（level-order）」走访的结果。在本问题中，二元树的每个节点含有一个正整数，并且节点的数目最少1个，最多256个。</p>
<p>在「阶层」走访中，依阶层从低到高，同阶层从左到右的次序来列印。例如以下的二元树阶层走访的结果为：5, 4, 8, 11, 13, 4, 7, 2, 1</p>
<p>在本问题中，二元树以节点来表示。每个节点以一对(n,s)来表示。n代表此节点的值，s为一字串，代表从根节点到达此节点的路径。其中L代表往左，R代表往右。所以在上方的图中内容为13的节点其表示法为(13,RL)，而内容为2的节点其表示法为(2,LLR)，而根节点为(5,)。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>先根据给出的对，构造二叉树，在借助队列层序遍历</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    #include&lt;iostream&gt;</span><br><span class="line">    #include&lt;string&gt;</span><br><span class="line">    #include&lt;queue&gt;</span><br><span class="line">    # pragma warning(disable:4996)</span><br><span class="line">    # define LOCAL</span><br><span class="line">    # ifdef LOCAL</span><br><span class="line">    FILE *fin &#x3D; freopen(&quot;树的层序遍历in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    FILE *fout &#x3D; freopen(&quot;树的层序遍历out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    # endif </span><br><span class="line">    using namespace std;</span><br><span class="line">    struct node &#123;</span><br><span class="line">    	bool have_val;</span><br><span class="line">    	int v;</span><br><span class="line">    	node *left, *right;</span><br><span class="line">    	node() :have_val(false), left(NULL), right(NULL) &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    node* root;</span><br><span class="line">    node * newnode() &#123;</span><br><span class="line">    </span><br><span class="line">    	return new node();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">	bool flag;</span><br><span class="line">	void addnode(string s, int v) &#123;</span><br><span class="line">	node * u &#x3D; root;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; s.length()-1; i++)</span><br><span class="line">		if (s[i] &#x3D;&#x3D; &#39;L&#39;) &#123;</span><br><span class="line">			if (u-&gt;left &#x3D;&#x3D; NULL)</span><br><span class="line">				u-&gt;left &#x3D; newnode();</span><br><span class="line">			u &#x3D; u-&gt;left;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		else if (s[i] &#x3D;&#x3D; &#39;R&#39;) &#123;</span><br><span class="line">			if (u-&gt;right &#x3D;&#x3D; NULL)</span><br><span class="line">				u-&gt;right &#x3D; newnode();</span><br><span class="line">			u &#x3D; u-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">	if (u-&gt;have_val) &#123;</span><br><span class="line">		flag &#x3D; false;</span><br><span class="line">	&#125;</span><br><span class="line">	u-&gt;have_val &#x3D; true;	</span><br><span class="line">	u-&gt;v &#x3D; v;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	int main() &#123;</span><br><span class="line">	string s;</span><br><span class="line">	</span><br><span class="line">	while (cin.peek() !&#x3D; EOF&amp;&amp;cin.peek()!&#x3D;&#39;\n&#39;) &#123;</span><br><span class="line">		root &#x3D; newnode();</span><br><span class="line"></span><br><span class="line">		flag &#x3D; true;</span><br><span class="line"></span><br><span class="line">		while (cin &gt;&gt; s &amp;&amp; s !&#x3D; &quot;()&quot;) &#123;</span><br><span class="line">			int v;</span><br><span class="line">			sscanf(&amp;s[1], &quot;%d&quot;, &amp;v);</span><br><span class="line">&gt;※※※提取字符串中的数字的方法！！！</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F;		cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">			s &#x3D; s.substr(s.find(&#39;,&#39;) + 1);</span><br><span class="line">			addnode(s, v);</span><br><span class="line">		&#125;</span><br><span class="line">		getchar();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		if (!flag) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;not complete&quot; &lt;&lt; endl;</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		node *tmp &#x3D; root;</span><br><span class="line">		queue&lt;node *&gt; travel;</span><br><span class="line">		travel.push(tmp);</span><br><span class="line">&gt;注意层序遍历的初始值</span><br><span class="line"></span><br><span class="line">		string ans;</span><br><span class="line">		while (!travel.empty()) &#123;</span><br><span class="line">			tmp&#x3D; travel.front();</span><br><span class="line">			travel.pop();</span><br><span class="line">			</span><br><span class="line">			if (!tmp-&gt;have_val) &#123;</span><br><span class="line">				flag &#x3D; false;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			ans &#x3D;ans+&quot; &quot;+to_string( tmp-&gt;v);</span><br><span class="line">			if (tmp-&gt;left) travel.push(tmp-&gt;left);</span><br><span class="line">			if (tmp-&gt;right) travel.push(tmp-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">		flag ? cout &lt;&lt; ans.substr(1) &lt;&lt; endl : cout &lt;&lt; &quot;not complete&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li><p>首先一定要学习提取字符串中数字的方法</p>
<pre><code>：sscanf(&amp;数字起始地址,&quot;格式&quot;，&amp;存储变量名)</code></pre></li>
<li><p>动态申请空间的时候，要释放掉，否则会导致内存泄漏；</p>
</li>
<li><p>可以通过维护一个简单的内存池实现</p>
<pre><code>queue&lt;Node*&gt; freenodes;
   Node node[maxn];

void init(){
    for(int i=0;i&lt;maxn;i++)
    freenodes.push(&amp;node[i]);    
}

Node* new(){
    Node* u = freenodes.front();
    //处理u的成员变量
    freenodes.pop();
    return u;
}

void dele(Node *u){
    freenodes.push(u);
}</code></pre></li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>反片语</title>
    <url>/2020/01/20/%E5%8F%8D%E7%89%87%E8%AF%AD/</url>
    <content><![CDATA[<h1 id="uav156-反片语"><a href="#uav156-反片语" class="headerlink" title="uav156 反片语"></a>uav156 反片语</h1><p>输入一些单词，找出所有满足如下条件的单词：该单词不能通过字母重排，得到输入文本的另外一个单词。在判断是否满足条件时，字母不分大小写，但在输出时应保留输入中的大小写，按字典序进行排列(所有大写字母在所有小写字母的前面)</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>由于单词可以重拍，所有直接对各单词进行标准化，以便于使用map；map<br>为&lt;string,int&gt;，其中值对应单词出现次数；使用向量word记录原单词，向量ans记录答案序列；</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   #include&lt;iostream&gt;</span><br><span class="line">   #include&lt;map&gt;</span><br><span class="line">   #include&lt;string&gt;</span><br><span class="line">   #include&lt;vector&gt;</span><br><span class="line">   #include&lt;algorithm&gt;</span><br><span class="line">   using namespace std;</span><br><span class="line">   vector&lt;string&gt;word;</span><br><span class="line">   map&lt;string, int&gt; cnt;</span><br><span class="line">   string standard(const string &amp;in) &#123;</span><br><span class="line">string s &#x3D; in;</span><br><span class="line">for (int i &#x3D; 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">	s[i] &#x3D; tolower(s[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>此处书上是按上述方式给的，如果形参表写成const string s，之后直接操作s，并且返回s也没发现问题。</li>
<li>注意此处const的用法，编写该模块前如果认定了in仅作为输入，则加上const防止之后错误的操作。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sort(s.begin(), s.end());</span><br><span class="line">return s;</span><br><span class="line">   &#125;</span><br><span class="line">   int main() &#123;</span><br><span class="line">string s;</span><br><span class="line">while (cin &gt;&gt; s) &#123;</span><br><span class="line">	if (s[0] &#x3D;&#x3D; &#39;# &#39;)	break;</span><br><span class="line">	word.push_back(s);</span><br><span class="line">	string r &#x3D; standard(s);</span><br><span class="line">	if (!cnt.count(r)) cnt[r] &#x3D; 0;</span><br><span class="line">	cnt[r]++;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;string&gt; ans;</span><br><span class="line">for (int i &#x3D; 0; i &lt; word.size(); i++) &#123;</span><br><span class="line">	if (cnt[standard(word[i])] &#x3D;&#x3D; 1) ans.push_back(word[i]);</span><br><span class="line">&#125;</span><br><span class="line">sort(ans.begin(), ans.end());</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; ans.size(); i++) &#123;</span><br><span class="line">	cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1><ol>
<li>本题主要是map的应用，想要用map，标准化的步骤是关键。</li>
<li>map提供了”[]”运算符，map[键]=值，使得map可以像数组一样使用。事实上，map也成为”关联数组”。</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>古代象形符号</title>
    <url>/2020/01/20/%E5%8F%A4%E4%BB%A3%E8%B1%A1%E5%BD%A2%E7%AC%A6%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="uva-1103-古代象形符号"><a href="#uva-1103-古代象形符号" class="headerlink" title="uva 1103 古代象形符号"></a>uva 1103 古代象形符号</h1><p>描述： 为了理解早期文明，考古学家经常研究用古代语言编写的文本。在3000多年前的埃及使用的一种语言是基于称为象形文字的字符。如图显示了六个象形文字及其名称，在这个题目中，您需要编写一个程序来识别这六个字。 图c1<br>输入描述： 输入由几个测试用例组成，每个测试用例描述一个包含一个或多个的图像 象形文字选自图C.1所示的那些。图像以一系列水平扫描线的形式给出，这些水平扫描线由黑色像素（由1表示）和白色像素（由0表示）组成。在输入数据中，每个扫描线以十六进制表示法编码。 例如，序列将表示八个像素10011100（一个黑色像素，后面是两个白色像素，依此类推） 十六进制表示法为9c。 在十六进制中仅使用数字和小写字母a到f 编码。每个测试用例的第一行包含两个整数，H和W.H（0 &lt;H≤200）是 图像中的扫描行数。 W（0 &lt;W≤50）是每个中十六进制字符的数量 线。 接下来的H行包含图像的十六进制字符，从上到下工作。 输入图像符合以下规则： •图像仅包含图C.1中所示的象形文字。 •每个图像至少包含一个有效的象形文字。 •图像中的每个黑色像素都是有效象形文字的一部分。 •每个象形文字由一组连接的黑色像素组成，每个黑色像素至少有一个顶部，底部，左侧或右侧的其他黑色像素。 •象形文字没有触及，另一个象形文字中没有象形文字。 •对角线接触的两个黑色像素将始终具有共同的触摸黑色像素。 •象形文字可能会扭曲，但每个都有一个在拓扑上等同于其中一个的形状 图C.1中的符号。 （如果每个都可以转换，两个数字在拓扑上是等价的 通过伸展而不撕裂进入另一个。） 最后一个测试用例后跟一行包含两个零的行。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>本题中的符号可以随意压缩拉伸，所以试图去直接描述其形状是不可取的。<br>观察到每个符号的空白圈数不同，可以以此特征分辨</p>
<ol>
<li>注意：要先给这个图加上一圈白边，使得所有背景的白色部分可以连接起来。此处可以使用</li>
<li>所以总体来说要进行两次遍历</li>
<li>第一次将背景中的空白遍历</li>
<li>第二次去遍历黑圈，沿途遍历黑色周围未遍历的白色部分，对于每个黑色的连通分量，统计其周围遍历到的白色连通分量数，即白洞数。每次统计完的接完插入到一个向量中。</li>
<li>对向量排序，输出<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"># pragma warning(disable:4996)</span><br><span class="line"># define LOCAL</span><br><span class="line"># ifdef LOCAL</span><br><span class="line">FILE *fin &#x3D; freopen(&quot;古代象形符号in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">FILE *fout &#x3D; freopen(&quot;古代象形符号out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line"># endif </span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;string&gt; g;</span><br><span class="line">int vis[205][205];</span><br><span class="line">string b[] &#x3D; &#123; &quot;0000&quot;,&quot;0001&quot;,&quot;0010&quot;,&quot;0011&quot;,&quot;0100&quot;,&quot;0101&quot;,&quot;0110&quot;,&quot;0111&quot;,&quot;1000&quot;,&quot;1001&quot;,&quot;1010&quot;,&quot;1011&quot; ,&quot;1100&quot;,&quot;1101&quot;,&quot;1110&quot;,&quot;1111&quot; &#125;;</span><br><span class="line">char c[] &#x3D; &#123; &#39;W&#39;,&#39;A&#39;,&#39;K&#39;,&#39;J&#39;,&#39;S&#39;,&#39;D&#39; &#125;;</span><br><span class="line">int dx[] &#x3D; &#123; -1,0,1,0 &#125;;</span><br><span class="line">int dy[] &#x3D; &#123; 0,-1,0,1 &#125;;</span><br><span class="line">struct Node &#123;</span><br><span class="line">	int x, y;</span><br><span class="line">	Node(int x, int y) :x(x), y(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int H, W, cnt, num;</span><br><span class="line">bool notOk(int a, int b) &#123;</span><br><span class="line">	return vis[a][b] || a &lt; 0 || a &gt;&#x3D; g.size() || b &lt; 0 || b &gt;&#x3D; g[a].size();</span><br><span class="line">&#125;</span><br><span class="line">void dfs(Node u, char c) &#123;</span><br><span class="line">	vis[u.x][u.y] &#x3D; 1;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">		int a &#x3D; u.x + dx[i];</span><br><span class="line">		int b &#x3D; u.y + dy[i];</span><br><span class="line">		if (notOk(a, b)) continue;</span><br><span class="line">		if (c &#x3D;&#x3D; &#39;1&#39;&amp;&amp; g[a][b] &#x3D;&#x3D; &#39;0&#39;) &#123;</span><br><span class="line"></span><br><span class="line">			cnt++;</span><br><span class="line">			dfs(Node(a, b), &#39;0&#39;);</span><br><span class="line">		&#125;</span><br><span class="line">		if (g[a][b] &#x3D;&#x3D; c) dfs(Node(a, b), c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int kase &#x3D; 0;</span><br><span class="line">	while (cin &gt;&gt; H &gt;&gt; W &amp;&amp; H) &#123;</span><br><span class="line"></span><br><span class="line">		getchar();</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		g.clear();</span><br><span class="line">		g.resize(H + 2);</span><br><span class="line">		g.front() &#x3D; string(W * 4 + 2, &#39;0&#39;);&#x2F;&#x2F;加一层白边</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; H; ++i) &#123;&#x2F;&#x2F;读取输入</span><br><span class="line">			g[i] &#x3D; &quot;0&quot;;&#x2F;&#x2F;加一层白边</span><br><span class="line">			string s;</span><br><span class="line">			getline(cin, s);</span><br><span class="line">			for (char c : s)</span><br><span class="line">			&#123;</span><br><span class="line">				if (isdigit(c)) g[i] +&#x3D; b[c - &#39;0&#39;];</span><br><span class="line">				else g[i] +&#x3D; b[c - &#39;a&#39; + 10];</span><br><span class="line">			&#125;</span><br><span class="line">			g[i] +&#x3D; &quot;0&quot;;&#x2F;&#x2F;加一层白边</span><br><span class="line">		&#125;</span><br><span class="line">		g.back() &#x3D; string(W * 4 + 2, &#39;0&#39;);&#x2F;&#x2F;加一层白边</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		dfs(Node(0, 0), &#39;0&#39;);</span><br><span class="line"></span><br><span class="line">		string ans;</span><br><span class="line">		for (int i &#x3D; 1; i &lt; g.size(); i++) &#123;</span><br><span class="line">			for (int j &#x3D; 1; j &lt; g[i].size(); j++) &#123;</span><br><span class="line">				if (!vis[i][j] &amp;&amp; g[i][j] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">					cnt &#x3D; 0;</span><br><span class="line">					dfs(Node(i, j), &#39;1&#39;);</span><br><span class="line">					ans +&#x3D; c[cnt];</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++kase &lt;&lt; &quot;: &quot;;</span><br><span class="line"></span><br><span class="line">		sort(ans.begin(), ans.end());</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1></li>
<li>注意DRY问题，本题中的dfs的写法非常值得学习</li>
<li>利用向量的直接赋值来添加百变，减少了时间复杂度</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>城市正视图</title>
    <url>/2020/01/20/%E5%9F%8E%E5%B8%82%E6%AD%A3%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="uva221-城市正视图"><a href="#uva221-城市正视图" class="headerlink" title="uva221 城市正视图"></a>uva221 城市正视图</h1><p>&ensp;如图5-4所示，有n（n≤100）个建筑物。左侧是俯视图（左上角为建筑物编号，右下角为高度），右侧是从南向北看的正视图。<br>输入每个建筑物左下角坐标（即x、y坐标的最小值）、宽度（即x方向的长度）、深度（即y方向的长度）和高度（以上数据均为实数），输出正视图中能看到的所有建筑物，按照左下角x坐标从小到大进行排序。左下角x坐标相同时，按y坐标从小到大排序。</p>
<p>&ensp;输入保证不同的x坐标不会很接近（即任意两个x坐标要么完全相同，要么差别足够大，不会引起精度问题）。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>需要对横坐标进行离散化，然后判断每个区间中点是否可以看见。</li>
<li>判断一个建筑是否在某个坐标处可见：首先，要包含这个点。其次，其他包含这个点的建筑没有比他靠近南边，并且比他高的。<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct bulid &#123;</span><br><span class="line">	double x, y, w, d, h;</span><br><span class="line">	int id;</span><br><span class="line">	bool operator &lt;(const bulid&amp;r) const&#123; return x &lt; r.x || x &#x3D;&#x3D; r.x&amp;&amp;y &lt; r.y; &#125;</span><br><span class="line">&#125;b[105];</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>注意此处要重写小于号，用于后面的sort</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int n;</span><br><span class="line">bool cover(int id, double mx) &#123;</span><br><span class="line">	return mx &gt;&#x3D; b[id].x &amp;&amp; mx &lt;&#x3D; b[id].x + b[id].w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>判断id号建筑是否包办mx这个点</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool visable(int id, double mx) &#123;</span><br><span class="line">	if (!cover(id, mx)) return false;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (b[i].y &lt; b[id].y&amp;&amp;b[i].h &gt;&#x3D; b[id].h&amp;&amp;cover(i, mx)) return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>判断id号建筑是否在mx点处可见</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  int main() &#123;</span><br><span class="line">  	int kase &#x3D; 0;</span><br><span class="line">int first &#x3D; 1;</span><br><span class="line">while (cin &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line"></span><br><span class="line">if (first) first &#x3D; 0;</span><br><span class="line">else cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">int x[2*105]&#123;&#125;;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">	cin &gt;&gt; b[i].x &gt;&gt; b[i].y &gt;&gt; b[i].w &gt;&gt; b[i].d &gt;&gt; b[i].h;</span><br><span class="line">	b[i].id &#x3D; i + 1;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>对坐标进行离散化，把连续的坐标变成离散的区间</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	x[2 * i] &#x3D; b[i].x;</span><br><span class="line">	x[2 * i + 1] &#x3D; b[i].x + b[i].w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sort(b, b + n);</span><br><span class="line">sort(x, x + 2 * n);</span><br><span class="line"></span><br><span class="line">int m &#x3D; unique(x, x + 2 * n) - x;</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>对x去重，unique返回值为一个地址，所以要减去x转成索引位置</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;For map # &quot; &lt;&lt;++kase &lt;&lt; &quot;, the visible buildings are numbered as follows:&quot; &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; b[0].id ;</span><br><span class="line">		for (int i &#x3D; 1; i &lt; n; i++) &#123;&#x2F;&#x2F;循环所有的建筑</span><br><span class="line">			bool vis &#x3D; false;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; m - 1; j++) &#123;&#x2F;&#x2F;循环所有区间</span><br><span class="line">				if (visable(i, (x[j] + x[j + 1]) &#x2F; 2)) &#123;</span><br><span class="line">				&#x2F;&#x2F;如果id号建筑在该区间中点可见，则在整个区间可见</span><br><span class="line">					vis &#x3D; true;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			if (vis) cout &lt;&lt;&quot; &quot;&lt;&lt; b[i].id;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>带宽</title>
    <url>/2020/01/20/%E5%B8%A6%E5%AE%BD/</url>
    <content><![CDATA[<h1 id="uva-140-带宽"><a href="#uva-140-带宽" class="headerlink" title="uva 140 带宽"></a>uva 140 带宽</h1><p>题意： 给一个最多8个结点的无向图，把结点重排后对于图中每条边(u,v)，u和v在排列中的最大距离称为该排列的带宽。求带宽最小的排列.</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>本题是带优化的穷举法—-回溯法的应用</li>
<li>所谓回溯法，就是在遍历的过程中构建树和删除树(剪枝)，如果可以确定该子树中不含有问题的解，则放弃对该子树的搜索，返回到上层的父节点，继续下一步深度优先搜索。</li>
<li>类比到本题中，有两种情况可以剪枝：<ol>
<li>对于节点u来说，假设u有m个相邻的节点，那么最理想的情况就是这m个节点紧跟在u后面，这样的节点带宽为m，而其他任何非理想情况的带宽至少为m+1。所以，如果即使都是最好情况仍然大于目前的最优解，那么应该直接剪枝</li>
<li>如果当前节点的带宽已经大于最小带宽，那么说明这个位置不能放这个位置不能放i，即放回到上层，再又上层执行vis[i] = 0来回溯</li>
</ol>
</li>
<li>由于A即使在没有成功运行到底的情况下，也会被改变，所以要将每次的结果更新到另一个数组里，采用memcpy函数</li>
<li><strong>本题由于n=8，可通过直接枚举排列并计算的方法实现</strong>，尝试后发现速度更快<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">输入A:FB;B:GC;D:GC;F:AGH;E:HD </span><br><span class="line">    #	</span><br><span class="line">*&#x2F;</span><br><span class="line">using namespace std;</span><br><span class="line">   map&lt;int, set&lt;int&gt;&gt; xl;</span><br><span class="line">   int n;</span><br><span class="line">   int A[10],ans[10];</span><br><span class="line">   int vis[26];</span><br><span class="line">   int minb &#x3D; 100000000;</span><br><span class="line">int main() &#123;</span><br><span class="line">   	string line;</span><br><span class="line">   	while (getline(cin, line) &amp;&amp; line !&#x3D; &quot;# &quot;) &#123;</span><br><span class="line">   		xl.clear();</span><br><span class="line">   		memset(A, -1, sizeof(A));</span><br><span class="line">   		bool flag &#x3D; true;</span><br><span class="line">   		char u;</span><br><span class="line">   		for (int i &#x3D; 0; i &lt; line.length(); i++) &#123;</span><br><span class="line">   			if (isalpha(line[i])) &#123;</span><br><span class="line">   				if (flag) &#123;</span><br><span class="line">   					u &#x3D; line[i] - &#39;A&#39;;</span><br><span class="line">   					flag &#x3D; false;</span><br><span class="line">   					xl[line[i] - &#39;A&#39;];</span><br><span class="line">   				&#125;</span><br><span class="line">   				else &#123;</span><br><span class="line">   					xl[u].insert(line[i] - &#39;A&#39;);</span><br><span class="line">   					xl[line[i] - &#39;A&#39;].insert(u);</span><br><span class="line">   				&#125;</span><br><span class="line">   			&#125;</span><br><span class="line">   			else if (line[i] &#x3D;&#x3D; &#39;;&#39;) flag &#x3D; true;</span><br><span class="line">   		&#125;</span><br><span class="line">   		n &#x3D; xl.size();</span><br><span class="line">   		memset(vis, 0, sizeof(vis));</span><br><span class="line">   		memset(ans, 0, sizeof(ans));</span><br><span class="line">   		minb &#x3D; 100000000;</span><br><span class="line">   		dfs(0, 0);</span><br><span class="line">   		for (int i &#x3D; 0; i &lt; n; i++) cout &lt;&lt; char(&#39;A&#39; + ans[i]) &lt;&lt; &quot; &quot;;</span><br><span class="line">   		cout &lt;&lt; &quot;-&gt; &quot;&lt;&lt;minb &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"> void dfs(int cur, int B) &#123;</span><br><span class="line"> 	if (cur &#x3D;&#x3D; n)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		&#x2F;&#x2F;能到这，说明已经是最优解了，所以要更新ans和最小带宽</span><br><span class="line">memcpy(ans, A, sizeof(int)*n);</span><br><span class="line"> 		minb &#x3D; B;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	else for (auto it &#x3D; xl.begin(); it !&#x3D; xl.end();it++) &#123;</span><br><span class="line"></span><br><span class="line"> 		int i &#x3D; it-&gt;first;</span><br><span class="line"> 		if (!vis[i]) &#123;&#x2F;&#x2F;vis[i]用来保证是个排列</span><br><span class="line"> 			int m &#x3D; 0;</span><br><span class="line"> 			for (int j &#x3D; 0; j &lt; cur; j++)</span><br><span class="line"> 				if (!vis[A[j]] &amp;&amp; xl[i].count(A[j])) </span><br><span class="line"> 					m++;</span><br><span class="line"> 			if (m &gt;&#x3D; minb) return;&#x2F;&#x2F;对应剪枝一</span><br><span class="line"> </span><br><span class="line"> 			int ok &#x3D; 1;</span><br><span class="line"> 			A[cur] &#x3D; i;</span><br><span class="line"> 			for (int j &#x3D; 0; j &lt; cur; j++) &#123;</span><br><span class="line"> 				</span><br><span class="line"> 				if (xl[i].count(A[j])) &#123;</span><br><span class="line"> 					int w &#x3D; cur - j;</span><br><span class="line"> 					if (w &gt; B) B &#x3D; w;</span><br><span class="line"> 					if (B &gt;&#x3D; minb) return;   			</span><br><span class="line"> 				&#125;    					</span><br><span class="line"> 			&#125;</span><br><span class="line"> </span><br><span class="line"> 			if (ok) &#123;</span><br><span class="line"> 				vis[i] &#x3D; 1;</span><br><span class="line"> 				dfs(cur + 1, B);</span><br><span class="line"> 				vis[i] &#x3D; 0;&#x2F;&#x2F;回溯：要么是到头了，回溯来找其他解；要么是中间返回，回溯以求正确解</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="直接生成排列法全部代码"><a href="#直接生成排列法全部代码" class="headerlink" title="直接生成排列法全部代码"></a>直接生成排列法全部代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 10;</span><br><span class="line">int id[256], letter[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  char input[1000];</span><br><span class="line">  while(scanf(&quot;%s&quot;, input) &#x3D;&#x3D; 1 &amp;&amp; input[0] !&#x3D; &#39;#&#39;) &#123;</span><br><span class="line">    &#x2F;&#x2F; 给每个字母一个编号 </span><br><span class="line">    int n &#x3D; 0;</span><br><span class="line">    for(char ch &#x3D; &#39;A&#39;; ch &lt;&#x3D; &#39;Z&#39;; ch++)</span><br><span class="line">      if(strchr(input, ch) !&#x3D; NULL) &#123;</span><br><span class="line">        id[ch] &#x3D; n++;</span><br><span class="line">        letter[id[ch]] &#x3D; ch;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 澶勭悊杈撳叆</span><br><span class="line">    int len &#x3D; strlen(input), p &#x3D; 0, q &#x3D; 0;</span><br><span class="line">    vector&lt;int&gt; u, v;&#x2F;&#x2F;u为起点列表，q为与任意节点相连的节点列表 ，一个(u(i),v(i))对 对应一条边 </span><br><span class="line">    for(;;) &#123;</span><br><span class="line">      while(p &lt; len &amp;&amp; input[p] !&#x3D; &#39;:&#39;) p++;</span><br><span class="line">      if(p &#x3D;&#x3D; len) break;</span><br><span class="line">      while(q &lt; len &amp;&amp; input[q] !&#x3D; &#39;;&#39;) q++;</span><br><span class="line">      for(int i &#x3D; p+1; i &lt; q; i++) &#123;</span><br><span class="line">        u.push_back(id[input[p-1]]);</span><br><span class="line">        v.push_back(id[input[i]]);</span><br><span class="line">      &#125;</span><br><span class="line">      p++; q++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int P[maxn], bestP[maxn], pos[maxn], ans &#x3D; n;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) P[i] &#x3D; i;</span><br><span class="line">    do &#123;</span><br><span class="line">      for(int i &#x3D; 0; i &lt; n; i++) pos[P[i]] &#x3D; i; &#x2F;&#x2F; 生成一种排列 </span><br><span class="line">      int bandwidth &#x3D; 0;</span><br><span class="line">      for(int i &#x3D; 0; i &lt; u.size(); i++)</span><br><span class="line">        bandwidth &#x3D; max(bandwidth, abs(pos[u[i]] - pos[v[i]])); &#x2F;&#x2F; 计算带宽 </span><br><span class="line">      if(bandwidth &lt; ans) &#123;</span><br><span class="line">        ans &#x3D; bandwidth;</span><br><span class="line">        memcpy(bestP, P, sizeof(P));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; while(next_permutation(P, P+n));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 输出结果 </span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) printf(&quot;%c &quot;, letter[bestP[i]]);</span><br><span class="line">    printf(&quot;-&gt; %d\n&quot;, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>并行程序模拟</title>
    <url>/2020/01/20/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<h1 id="uva-210-并行程序模拟"><a href="#uva-210-并行程序模拟" class="headerlink" title="uva 210 并行程序模拟"></a>uva 210 并行程序模拟</h1><p>你的任务是模拟n个程序（按输入顺序编号1~n）的并行执行。每个程序包含不超过25条语句。</p>
<p>格式一共是5种：赋值（var=constant），打印（print var），lock，unlock，end，耗时分别为t1,t2,t3,t4,t5.</p>
<p>变量用一个小写字母表示，初始时为0，为所有并行程序共有，且它的值始终保持在[0,100]内，所以一个程序对某一个变量的赋值会影响到另外一个程序。</p>
<p>每个时刻只能是一个程序处于运行状态，其他程序处于等待状态。运行状态之中的的程序每次最多分配Q个单位时间，一旦在未执行完程序时超过分配时间，这个程序则会被插入等待队列，然后从其的队首取出一共程序继续执行。而初始的等待队列为按照输入程序排入。</p>
<p>但是由于lock和unlock命令的出现，这个顺序会被改变。</p>
<p>lock的作用是申请对所有变量的独占访问，unlock则是解除对所有变量的独占访问，且它们一定成对出现。当一个程序已经对所有的变量独占访问后，其他程序若试图执行lock，无论其是否耗尽分配时间，都会被放在一个阻止队列的尾部，且当那个程序解除的时候，则会从阻止队列的头部的程序进入等待队列的头部。</p>
<p>现在给出n,t1,t2,t3,t4,t5,Qn,t_1,t_2,t_3,t_4,t_5,Qn,t1​,t2​,t3​,t4​,t5​,Q以及nnn个程序，你需要输出所有printprintprint命令执行输出的值。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>对于每个程序，将它所对应的代码存到一个队列中，所有的程序构成一个队列数组。</li>
<li>运行时定义三个队列，分别为等待，阻塞和运行，里面存程序的编号。</li>
<li>在等待队列不空的情况下持续循环。每次取等待队列首部的程序作为当前运行的程序队列，即running队列。</li>
<li>运行过程中，不断从running的队首取元素，分析代码，调用analysis函数运行指令，并返回相应时间。注意加锁和解锁的过程要特殊处理。</li>
<li>每次t-=返回的耗时，running队列弹出一条语句。</li>
<li>如果分配的时间片内没有完成，则将对应程序的编号插入等待队列的队尾，并且更新对应程序剩余代码。</li>
<li>锁机制使用全局变量lockKey实现，为false时可以进行加锁，否则将后来的想加锁的程序放入等待进程。注意此时不要弹出lock指令。<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="analysis-分析语句"><a href="#analysis-分析语句" class="headerlink" title="analysis 分析语句"></a>analysis 分析语句</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int analysis(string s) &#123;</span><br><span class="line">   	if (s.find(&#39;&#x3D;&#39;) !&#x3D; -1) &#123;</span><br><span class="line">   		int m &#x3D; s.find(&#39;&#x3D;&#39;);</span><br><span class="line">   		string l &#x3D; s.substr(0, m - 1);</span><br><span class="line">   		string r &#x3D; s.substr(m + 2);</span><br><span class="line">   		value[l] &#x3D; r;</span><br><span class="line">   		return tim[0];</span><br><span class="line">   	&#125;</span><br><span class="line">   	else if (s.substr(0, 5) &#x3D;&#x3D; &quot;print&quot;) &#123;</span><br><span class="line">   		string a &#x3D; s.substr(6);</span><br><span class="line">   		cout &lt;&lt; waiting.front() + 1 &lt;&lt; &quot;: &quot;;</span><br><span class="line">   		if(value.count(a)) cout&lt;&lt; value[a] &lt;&lt; endl;</span><br><span class="line">   		else cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;</span><br><span class="line">   		return tim[1];</span><br><span class="line">   	&#125;</span><br><span class="line">   	else if (s &#x3D;&#x3D; &quot;lock&quot;) &#123;</span><br><span class="line">   		if (!lockKey) &#123;</span><br><span class="line">   			lockKey &#x3D; true;</span><br><span class="line">   			return tim[2];</span><br><span class="line">   		&#125;</span><br><span class="line">   		else return -1;</span><br><span class="line">   </span><br><span class="line">   	&#125;</span><br><span class="line">   	else if (s &#x3D;&#x3D; &quot;unlock&quot;) &#123;</span><br><span class="line">   		lockKey &#x3D; false;</span><br><span class="line">   		return -2;</span><br><span class="line">   	&#125;</span><br><span class="line">   	else if (s &#x3D;&#x3D; &quot;end&quot;) &#123;</span><br><span class="line">   		return tim[4];</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="main-运行程序的过程"><a href="#main-运行程序的过程" class="headerlink" title="main 运行程序的过程"></a>main 运行程序的过程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"># define maxn 500</span><br><span class="line">int tim[5];&#x2F;&#x2F;记录每个操作的时间</span><br><span class="line">map&lt;string, string&gt; value;</span><br><span class="line">deque&lt;int&gt; waiting;&#x2F;&#x2F;等待队列，存队列的ID（数组中的下标）</span><br><span class="line">int quota;&#x2F;&#x2F;配额</span><br><span class="line"></span><br><span class="line">bool lockKey &#x3D; false;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	bool first &#x3D; true;</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		if (first) first &#x3D; false;</span><br><span class="line">		else cout &lt;&lt; endl;</span><br><span class="line">		queue&lt;string&gt; pro[maxn];&#x2F;&#x2F;所有程序的指令序列</span><br><span class="line">	</span><br><span class="line">		queue&lt;int&gt; block;&#x2F;&#x2F;阻塞队列</span><br><span class="line">		value.clear();</span><br><span class="line">		waiting.clear();</span><br><span class="line">		int n;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 5; i++) cin &gt;&gt; tim[i];</span><br><span class="line"></span><br><span class="line">		cin &gt;&gt; quota; getchar();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			string s;</span><br><span class="line">			while (getline(cin, s)) &#123;</span><br><span class="line">				pro[i].push(s);</span><br><span class="line">				if (s &#x3D;&#x3D; &quot;end&quot;) break;</span><br><span class="line">			&#125;</span><br><span class="line">			waiting.push_back(i);</span><br><span class="line">		&#125;</span><br><span class="line">		while (!waiting.empty()) &#123;</span><br><span class="line">			queue&lt;string&gt; running &#x3D; pro[waiting.front()];</span><br><span class="line">			int t &#x3D; quota;</span><br><span class="line">			bool flag &#x3D; true;</span><br><span class="line">			while (!running.empty() &amp;&amp; t&gt;0) &#123;</span><br><span class="line">				int w &#x3D; analysis(running.front());</span><br><span class="line">				if (w &#x3D;&#x3D; -1) &#123;&#x2F;&#x2F;说明不是第一次执行到lock</span><br><span class="line">					block.push(waiting.front());</span><br><span class="line">					flag &#x3D; false;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				if (w &#x3D;&#x3D; -2) &#123;</span><br><span class="line">					if (!block.empty()) &#123;</span><br><span class="line">						int now &#x3D; waiting.front();</span><br><span class="line">						waiting.pop_front();</span><br><span class="line">						waiting.push_front(block.front());</span><br><span class="line">						block.pop();</span><br><span class="line">						waiting.push_front(now);</span><br><span class="line">					&#125;</span><br><span class="line">					w &#x3D; tim[3];</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line"></span><br><span class="line">				t -&#x3D; w;</span><br><span class="line">				running.pop();</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			if (flag &amp;&amp; !running.empty()) &#123;</span><br><span class="line"></span><br><span class="line">				waiting.push_back(waiting.front());</span><br><span class="line">			&#125;</span><br><span class="line">			pro[waiting.front()] &#x3D; running;</span><br><span class="line"></span><br><span class="line">			waiting.pop_front();</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="简化版代码-思路一致"><a href="#简化版代码-思路一致" class="headerlink" title="简化版代码 思路一致"></a>简化版代码 思路一致</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">deque&lt;int&gt; readyQ;</span><br><span class="line">queue&lt;int&gt; blockQ;</span><br><span class="line">int n, quantum, c[5], var[26], ip[maxn]; </span><br><span class="line">bool locked;</span><br><span class="line">char prog[maxn][10];</span><br><span class="line"></span><br><span class="line">void run(int pid) &#123;</span><br><span class="line">  int q &#x3D; quantum;</span><br><span class="line">  while(q &gt; 0) &#123;</span><br><span class="line">    char *p &#x3D; prog[ip[pid]];</span><br><span class="line">    switch(p[2]) &#123;</span><br><span class="line">      case &#39;&#x3D;&#39;:</span><br><span class="line">        var[p[0] - &#39;a&#39;] &#x3D; isdigit(p[5]) ? (p[4] - &#39;0&#39;) * 10 + p[5] - &#39;0&#39; : p[4] - &#39;0&#39;;</span><br><span class="line">        &#x2F;&#x2F;因为至多是两位数 </span><br><span class="line">        q -&#x3D; c[0];</span><br><span class="line">        break;</span><br><span class="line">      case &#39;i&#39;: &#x2F;&#x2F; print</span><br><span class="line">        printf(&quot;%d: %d\n&quot;, pid+1, var[p[6] - &#39;a&#39;]);</span><br><span class="line">        q -&#x3D; c[1];</span><br><span class="line">        break;</span><br><span class="line">      case &#39;c&#39;: &#x2F;&#x2F; lock</span><br><span class="line">        if(locked) &#123; blockQ.push(pid); return; &#125;</span><br><span class="line">        locked &#x3D; true;</span><br><span class="line">        q -&#x3D; c[2];</span><br><span class="line">        break;</span><br><span class="line">      case &#39;l&#39;: &#x2F;&#x2F; unlock</span><br><span class="line">        locked &#x3D; false;</span><br><span class="line">        if(!blockQ.empty()) &#123;</span><br><span class="line">          int pid2 &#x3D; blockQ.front(); blockQ.pop();</span><br><span class="line">          readyQ.push_front(pid2);</span><br><span class="line">        &#125;</span><br><span class="line">        q -&#x3D; c[3];</span><br><span class="line">        break;</span><br><span class="line">      case &#39;d&#39;: &#x2F;&#x2F; end</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    ip[pid]++;</span><br><span class="line">  &#125;</span><br><span class="line">  readyQ.push_back(pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int T;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">  while(T--) &#123;</span><br><span class="line">    scanf(&quot;%d %d %d %d %d %d %d\n&quot;, &amp;n, &amp;c[0], &amp;c[1], &amp;c[2], &amp;c[3], &amp;c[4], &amp;quantum);</span><br><span class="line">    memset(var, 0, sizeof(var));</span><br><span class="line"></span><br><span class="line">    int line &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">      fgets(prog[line++], maxn, stdin);</span><br><span class="line">      ip[i] &#x3D; line - 1;</span><br><span class="line">      while(prog[line - 1][2] !&#x3D; &#39;d&#39;)</span><br><span class="line">        fgets(prog[line++], maxn, stdin);</span><br><span class="line">      readyQ.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    locked &#x3D; false;</span><br><span class="line">    while(!readyQ.empty()) &#123;</span><br><span class="line">      int pid &#x3D; readyQ.front(); readyQ.pop_front();</span><br><span class="line">      run(pid);</span><br><span class="line">    &#125;</span><br><span class="line">    if(T) printf(&quot;\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>打印队列</title>
    <url>/2020/01/20/%E6%89%93%E5%8D%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="uva12100-打印队列"><a href="#uva12100-打印队列" class="headerlink" title="uva12100 打印队列"></a>uva12100 打印队列</h1><p>&ensp;学生会里只有一台打印机，但是有很多文件需要打印，因此打印任务不可避免地需要等待。有些打印任务比较急，有些不那么急，所以每个任务都有一个1～9间的优先级，优先级越高表示任务越急。</p>
<p>&ensp;打印机的运作方式如下：首先从打印队列里取出一个任务J，如果队列里有比J更急的任务，则直接把J放到打印队列尾部，否则打印任务J（此时不会把它放回打印队列）。 输入打印队列中各个任务的优先级以及所关注的任务在队列中的位置（队首位置为0），输出该任务完成的时刻。所有任务都需要1分钟打印。例如，打印队列为{1,1,9,1,1,1}，目前处于队首的任务最终完成时刻为5。</p>
<p>&ensp;输入T 接下来T组数据 每组数据输入N，TOP。接下来N个数，TOP代表队列首</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>通过两个队列实现，一个是优先级队列，其队首即为当前允许出队的优先级；另一个是打印队列</li>
<li>只有当优先级队列的队首等于打印队列的队首的时候（当前要打印的任务优先级最高）时，才能打印；否则将打印队列的队首插到队尾</li>
<li>由于最终要根据在初始队列中的位置选择输出，所以既要记录优先级又要记录初始位置。</li>
<li>优先级队列与元素无关，所以用int型即可<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   &#x2F;&#x2F;list存打印请求队列，如果优先级队列pq的队首比list大，说明队列中还有优先级更高的任务，则将list的队首放在队尾</span><br><span class="line">   &#x2F;&#x2F;只有当pq的队首等于list的队首的时候，list才输出，pq才出队!!!</span><br><span class="line">   #include&lt;iostream&gt;</span><br><span class="line">   #include&lt;vector&gt;</span><br><span class="line">   #include&lt;queue&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;习题5-7in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;习题5-7out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   int n;</span><br><span class="line">   struct node &#123;</span><br><span class="line">   	int f;</span><br><span class="line">   	int pos;</span><br><span class="line">   	node(int f, int pos) :f(f), pos(pos) &#123;&#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   int main() &#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">while (n--)</span><br><span class="line">&#123;</span><br><span class="line">	queue&lt;node&gt; list;</span><br><span class="line">	priority_queue&lt;int&gt; pq;</span><br><span class="line">	int m, pos;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; pos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">		int x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		pq.push(x);</span><br><span class="line">		list.push(node(x,i));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	int time &#x3D; 0;</span><br><span class="line">	while(!list.empty()&amp;&amp;!pq.empty())&#123;</span><br><span class="line">		if (list.front().f &lt; pq.top()) &#123;</span><br><span class="line">			list.push(list.front());</span><br><span class="line">			list.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		else if (list.front().f &#x3D;&#x3D; pq.top()) &#123;</span><br><span class="line">			if (list.front().pos &#x3D;&#x3D; pos) break;</span><br><span class="line">			</span><br><span class="line">				list.pop();</span><br><span class="line">				pq.pop();&#x2F;&#x2F;！！只有成功打印了，优先级队列才队</span><br><span class="line">				time++;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; time+1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h1></li>
<li>首先是学习了优先级队列，优先级队列是每次都挑出优先级最大的，而不是重排队列。</li>
<li>以后应该明确每个STL应该关注的点，像是这里的优先级队列，只需关注级数数值即可，无需定义为node型</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>UnixIS命令</title>
    <url>/2020/01/20/UnixIS%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="unix-is-命令"><a href="#unix-is-命令" class="headerlink" title="unix is 命令"></a>unix is 命令</h1><p>输入正整数n 以及n个文件名，排序后按列优先的方式左对齐输出。假设最长文件名有M字符，则最右边有M字符，其他列都是M+2 字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  #include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">  # pragma warning(disable:4996)</span><br><span class="line">  # define LOCAL</span><br><span class="line">  # ifdef LOCAL</span><br><span class="line">  FILE *fin &#x3D; freopen(&quot;unix命令in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">  FILE *fout &#x3D; freopen(&quot;unix命令out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">  # endif &#x2F;&#x2F; LOCAL</span><br><span class="line">  using namespace std;</span><br><span class="line">  void print(const string &amp;in, int len, char extra) &#123;</span><br><span class="line">&#x2F;&#x2F;输出字符串s，长度不足len时补字符extra</span><br><span class="line">  	cout &lt;&lt; in;</span><br><span class="line">  	for (int i &#x3D; 0; i &lt; len - in.length(); i++) cout &lt;&lt; extra;</span><br><span class="line">  &#125;</span><br><span class="line">  int main() &#123;</span><br><span class="line">  	int n;</span><br><span class="line">  </span><br><span class="line">  	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">  		int m &#x3D; 0;</span><br><span class="line">  		print(&quot;&quot;, 60, &#39;-&#39;);</span><br><span class="line">  		cout &lt;&lt; endl;</span><br><span class="line">  		vector&lt;string&gt; s;</span><br><span class="line">  		for (int i &#x3D; 0; i &lt; n;i++) &#123;</span><br><span class="line">  			string in;</span><br><span class="line">  			cin &gt;&gt; in;</span><br><span class="line">  			s.push_back(in);</span><br><span class="line">  			m &#x3D; max(m, (int)in.length());</span><br><span class="line">  		&#125;</span><br><span class="line">  		sort(s.begin(), s.end());</span><br><span class="line">  </span><br><span class="line">  		&#x2F;*cout &lt;&lt; &quot;**********************************&quot; &lt;&lt; endl;</span><br><span class="line">  		for (int i &#x3D; 0; i &lt; s.size(); i++) cout &lt;&lt; s[i] &lt;&lt; endl;</span><br><span class="line">  		cout &lt;&lt; &quot;**********************************&quot; &lt;&lt; endl;*&#x2F;</span><br><span class="line">  		int cols &#x3D; (60 - m) &#x2F; (m + 2) + 1;</span><br><span class="line">  		int rows &#x3D; (n - 1) &#x2F; cols + 1;</span><br><span class="line">  		for (int r &#x3D; 0; r &lt; rows; r++) &#123;</span><br><span class="line">  			for (int c &#x3D; 0; c &lt; cols; c++) &#123;</span><br><span class="line">  				int idx &#x3D; c * rows + r;</span><br><span class="line">  				if (idx &lt; n) print(s[idx], c &#x3D;&#x3D; cols - 1 ? m : m + 2, &#39; &#39;);</span><br><span class="line">  			&#125;</span><br><span class="line">  			cout &lt;&lt; endl;</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>八皇后问题</title>
    <url>/2020/01/20/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>/*<br>恰好每行每列各放置一个皇后，如果用A[x]表示第x行皇后的列号，则问题变成了一个全排列生成问题。<br>*/</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   #include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;八皇后in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;八皇后out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   int print_num &#x3D; 1;</span><br><span class="line">   int tot &#x3D; 0;</span><br><span class="line">   int n;</span><br><span class="line">   int A[100];</span><br><span class="line">   int vis[100][100];</span><br><span class="line">   void search(int cur) &#123;</span><br><span class="line">ios::sync_with_stdio(false);</span><br><span class="line">if (cur &#x3D;&#x3D; n) &#123;</span><br><span class="line">	if (print_num &lt;&#x3D; 3) &#123;</span><br><span class="line">		cout &lt;&lt; A[0];</span><br><span class="line">		for (unsigned int i &#x3D; 1; i &lt; n; i++)</span><br><span class="line">			cout &lt;&lt; &quot; &quot;&lt;&lt; A[i] ;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		print_num++;</span><br><span class="line">	&#125;</span><br><span class="line">	tot++;</span><br><span class="line">&#125;</span><br><span class="line">else for (unsigned int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">	if (!vis[0][i] &amp;&amp; !vis[1][cur + i] &amp;&amp; !vis[2][cur - i + n]) &#123;</span><br><span class="line">		&#x2F;&#x2F;对于(i,cur)</span><br><span class="line">		&#x2F;&#x2F;以cur+i来标识副对角线，cur-i来标识主对角线，由于主对角线可能为负</span><br><span class="line">		&#x2F;&#x2F;所以要加上n</span><br><span class="line">		A[cur] &#x3D; i + 1;</span><br><span class="line">		&#x2F;&#x2F;对于(cur,i)处要么有子要么无子--&gt;回溯的两种情况</span><br><span class="line">		vis[0][i] &#x3D; vis[1][cur + i] &#x3D; vis[2][cur - i + n] &#x3D; 1;</span><br><span class="line">		search(cur + 1);</span><br><span class="line">		vis[0][i] &#x3D; vis[1][cur + i] &#x3D; vis[2][cur - i + n] &#x3D; 0;&#x2F;&#x2F;非常关键，回溯法中修改的辅助</span><br><span class="line">															 &#x2F;&#x2F;局部变量，一定要及时恢复原状</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   int main() &#123;</span><br><span class="line">   	ios::sync_with_stdio(false);</span><br><span class="line">   	cin &gt;&gt; n;</span><br><span class="line">   	search(0);</span><br><span class="line">   	cout &lt;&lt; tot &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>八数码</title>
    <url>/2020/01/20/%E5%85%AB%E6%95%B0%E7%A0%81/</url>
    <content><![CDATA[<h1 id="八数码-P1379"><a href="#八数码-P1379" class="headerlink" title="八数码 P1379"></a>八数码 P1379</h1><p>有一个3*3的网格，给定一个初始局面，问至少多少步能到达目标局面.</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>经典的隐式图最短路径问题。</li>
<li>sizeof(字符串)会计算结束符。对于二维的字符数组，对某一行用sizeof不会计算结束符，可能产生问题。</li>
<li>一般的bfs采用队列，但是本题中由于状态是八个元素的信息，所以采用了类似链表的方法近似队列。在编辑书稿中也使用了类似的方式，只不过那个题是dfs，迭代加深搜实现的。</li>
<li>本题可以使用bfs是因为每一步的状态不是无限的。</li>
<li>注意rear++和front++的位置</li>
<li>dist数组是必要的</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int maxn &#x3D; 1000000;</span><br><span class="line">bool bfs();</span><br><span class="line">bool can_insert(int s);</span><br><span class="line">char st[maxn][9];</span><br><span class="line">int dx[] &#x3D; &#123; 1,-1,0,0 &#125;;</span><br><span class="line">int dy[] &#x3D; &#123; 0,0,1,-1 &#125;;   </span><br><span class="line">int dist[maxn];</span><br><span class="line">char goal[] &#x3D; &#123;&quot;123804765&quot;&#125;;</span><br><span class="line">int front, rear;</span><br><span class="line">std::set&lt;int&gt; vis;</span><br><span class="line">int main() &#123;</span><br><span class="line">	scanf(&quot;%s&quot;, st[1]);</span><br><span class="line">	if (bfs()) printf(&quot;%d&quot;, dist[front]);</span><br><span class="line">	else printf(&quot;-1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">bool bfs() &#123;</span><br><span class="line">	front &#x3D; 1, rear &#x3D; 2;</span><br><span class="line">	while (front &lt; rear) &#123;</span><br><span class="line">		if (memcmp(goal,st[front], sizeof(st[front])) &#x3D;&#x3D; 0) return true;</span><br><span class="line">		int z &#x3D; 0;</span><br><span class="line">		while (st[front][z] !&#x3D; &#39;0&#39;) z++;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">			int newx &#x3D; z &#x2F; 3 + dx[i];</span><br><span class="line">			int newy &#x3D; z % 3 + dy[i];</span><br><span class="line">			if (newx &lt; 0 || newx &gt;&#x3D; 3 || newy &lt; 0 || newy &gt;&#x3D; 3) continue;</span><br><span class="line">			int newz &#x3D; newx * 3 + newy;</span><br><span class="line">			memcpy(st[rear], st[front], sizeof(char)*9);</span><br><span class="line">			st[rear][newz] &#x3D; st[front][z];</span><br><span class="line">			st[rear][z] &#x3D; st[front][newz];</span><br><span class="line">			dist[rear] &#x3D; dist[front] + 1;</span><br><span class="line">			if(can_insert(rear)) rear++;</span><br><span class="line">		&#125;</span><br><span class="line">		front++;</span><br><span class="line">	&#125;</span><br><span class="line">		return false;</span><br><span class="line">&#125;</span><br><span class="line">bool can_insert(int s) &#123;</span><br><span class="line">	int v &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 9; i++) v &#x3D; v * 10 + st[s][i] - &#39;0&#39;;</span><br><span class="line">	if (!vis.count(v)) &#123;</span><br><span class="line">		vis.insert(v);</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>埃及分数</title>
    <url>/2020/01/20/%E5%9F%83%E5%8F%8A%E5%88%86%E6%95%B0/</url>
    <content><![CDATA[<h1 id="UVA-12258-埃及分数"><a href="#UVA-12258-埃及分数" class="headerlink" title="UVA 12258 埃及分数"></a>UVA 12258 埃及分数</h1><p>输入出a,b,k，然后输入k个数，要求这k个数不出现在结果中。埃及分数是将任何一个分数a/b，转换成1/x1+1/x2+1/x3…的形式。好的解应该是项数最少的，对于相同项数的解，最小的分数值越大越好。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>由于本题中深度没有上限，而且加数的选择也没有上届，因此如果用广度有限遍历，可能连一层都遍历不完。</li>
<li>使用迭代加深度搜索解决。不断枚举深度的上限maxd，每次搜索深度不超过maxd的节点。<strong>这样只要解的深度有限，那么一定可以在有限的时间内枚举得到</strong>；</li>
<li>关于剪枝：本题中，如果剩余的maxd-d+1项都是1/i，但是和仍然小于目标a/b，那么说明项数不够，则不需要继续递归下去。</li>
<li>关于约分：使用到gcd算法，求出g = gcd(a,b)，那么a/b 可以转换成(a/g)/(b/g)；</li>
<li>关于inline:使用inline之后，时间从2290减到1380。不能使用inline的情况包括<ol>
<li>不适用于包含复杂控制语句的函数</li>
<li>不适用于直接递归函数</li>
</ol>
</li>
</ol>
<p><strong>但是是否真的设置为内联，由编译器决定</strong></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="dfs-深度搜索"><a href="#dfs-深度搜索" class="headerlink" title="dfs 深度搜索"></a>dfs 深度搜索</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   bool dfs(int d, LL from, LL a, LL b) &#123;</span><br><span class="line">if (d &#x3D;&#x3D; maxd) &#123;</span><br><span class="line">	if (b%a || avoid.count(b &#x2F; a)) return false;</span><br><span class="line"></span><br><span class="line">	v[d] &#x3D; b &#x2F; a;</span><br><span class="line">	if (better(d)) memcpy(ans, v, sizeof(LL)*(d + 1)); &#x2F;&#x2F;0~d</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">bool ok &#x3D; false;</span><br><span class="line">from &#x3D; max(from, get_first(a, b));</span><br><span class="line">for (LL i &#x3D; from;; i++) &#123;</span><br><span class="line">	if (b*(maxd - d + 1) &lt;&#x3D; a * i) break;</span><br><span class="line">	&#x2F;&#x2F;如果a&#x2F;b &gt;&#x3D; (maxd-d+1)*&#x2F;(1&#x2F;i)，则剪枝</span><br><span class="line">	if (avoid.count(i)) continue;</span><br><span class="line">	v[d] &#x3D; i;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;这一部分目的是计算a&#x2F;b-1&#x2F;i</span><br><span class="line">	LL a2 &#x3D; a * i - b;</span><br><span class="line">	LL b2 &#x3D; b * i;</span><br><span class="line">	LL g &#x3D; gcd(a, b);</span><br><span class="line">	if (dfs(d + 1, i + 1, a2 &#x2F; g, b2 &#x2F; g)) ok &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line">return ok;</span><br></pre></td></tr></table></figure>
<h2 id="better-比较函数"><a href="#better-比较函数" class="headerlink" title="better 比较函数"></a>better 比较函数</h2><ol>
<li>要求最小的分数值越大越好，即是要求分母最大的数越小越好。所以从i=d开始比较。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">inline bool better(int d) &#123;</span><br><span class="line">for (int i &#x3D; d; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">	if (ans[i] !&#x3D; v[i])</span><br><span class="line">		return ans[i] &#x3D;&#x3D; -1 || ans[i] &gt; v[i];</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="gcd-固定的"><a href="#gcd-固定的" class="headerlink" title="gcd 固定的"></a>gcd 固定的</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">inline LL gcd(LL a, LL b) &#123;</span><br><span class="line">if (b &#x3D;&#x3D; 0) return a;</span><br><span class="line">return gcd(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="get-first-返回1-从-lt-a-b的最小的"><a href="#get-first-返回1-从-lt-a-b的最小的" class="headerlink" title="get_first 返回1/从&lt;=a/b的最小的"></a>get_first 返回1/从&lt;=a/b的最小的</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">inline LL get_first(LL a, LL b) </span><br><span class="line">&#123; return b &#x2F; a + 1; &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>安迪的第一本字典</title>
    <url>/2020/01/20/%E5%AE%89%E8%BF%AA%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<h1 id="UVa10815-安迪的第一本字典"><a href="#UVa10815-安迪的第一本字典" class="headerlink" title="UVa10815 安迪的第一本字典"></a>UVa10815 安迪的第一本字典</h1><p>输入一个文本，找出所有不同的单词(连续字母序列)，按字典序从小到大输出，单词不区分大小写</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>主要利用set自动排序的特性实现字典序;主要工作是分割单词，即连续字母序列</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    #include&lt;iostream&gt;</span><br><span class="line">    #include&lt;string&gt;</span><br><span class="line">	#include&lt;sstream&gt;</span><br><span class="line">	#include&lt;set&gt;</span><br><span class="line">	using namespace std;</span><br><span class="line">	set&lt;string&gt; dir;</span><br><span class="line">	int main() &#123;</span><br><span class="line">	string s, buf;</span><br><span class="line">	while (cin &gt;&gt; s) &#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">			if (isalpha(s[i])) s[i] &#x3D; tolower(s[i]);</span><br><span class="line">			else s[i] &#x3D; &#39; &#39;;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	将文本存在s中，遍历s；遇到字母，则都转为小写，防止排序出错；若字母序列中断，则插入一个空格，这样在之后向buf中输入的时候，单词即可分开。</span><br><span class="line">	*&#x2F;</span><br><span class="line"></span><br><span class="line">		stringstream ss(s);</span><br><span class="line">		while (ss &gt;&gt; buf) dir.insert(buf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (set&lt;string&gt;::iterator it &#x3D; dir.begin(); it !&#x3D; dir.end(); it++)</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">主要这一段stringstream以及迭代器的用法；迭代器可以理解为一个指针</span><br></pre></td></tr></table></figure>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>本题主要是对set的应用</p>
<ol>
<li>要学习set的声明和基本使用：insert(插入元素)；</li>
<li>要学习拆分单词的技巧</li>
<li>要学习迭代器的使用方法</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>宝箱</title>
    <url>/2020/01/20/%E5%AE%9D%E7%AE%B1/</url>
    <content><![CDATA[<h1 id="UVA-12325-宝箱"><a href="#UVA-12325-宝箱" class="headerlink" title="UVA 12325 宝箱"></a>UVA 12325 宝箱</h1><p>你有一个体积为N的箱子和两种数量无限的宝物。宝物1的体积为S1，价值为V1:；宝物2的体积为S2，价值为V2。输入均为32位带符号整数。 计算最多能装多大价值的宝物。（每种宝物都必须拿非负整数个）。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>可以选择枚举宝藏1的个数，然后尽可能多的拿宝物2；或者；但是当n和s1,s2的差距较大的时候，这种方法不奏效。</li>
<li>假设宝物1取总体积S2，宝物2取总体积S1，且二者总价值相等，即S1<em>V2 == S2</em>V1。那么当V1较大时，宝藏1至多取S2-1个，否则可用S1个宝物二替换。同理，如果V2较大，那么宝物2至多取S1-1个.因此，枚举量只有S1和S2。</li>
<li>解决TLE：<ol>
<li>当N/S1比较小时，枚举宝物1的个数，时间复杂度为O(N/S1)；否则，当N/S2比较小时，枚举宝物2的个数，时间复杂度为O(N/S2)。</li>
<li>因此枚举的时间复杂度为O(max(S1,S2))</li>
</ol>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">typedef long long int64;</span><br><span class="line">using std::swap; using std::max;</span><br><span class="line">int main() &#123;</span><br><span class="line">int T, id &#x3D; 0; scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">while (T--) &#123;</span><br><span class="line">	int n, s1, v1, s2, v2; scanf(&quot;%d %d %d %d %d&quot;, &amp;n, &amp;s1, &amp;v1, &amp;s2, &amp;v2);</span><br><span class="line">	if (s1 &gt; s2) swap(s1, s2), swap(v1, v2);&#x2F;&#x2F;目的是使得S2&gt;S1</span><br><span class="line">	int64 ans &#x3D; 0;</span><br><span class="line">	if (n &#x2F; s2 &gt;&#x3D; 65536) &#123;	&#x2F;&#x2F;S2&gt;S1，如果除以S2都大于65536，说明S2就很小，那么S1更小，那么使用特殊枚举。</span><br><span class="line">		for (int64 i &#x3D; 0; i &lt;&#x3D; s1; i++) ans &#x3D; max(ans, v2 * i + (n - s2 * i) &#x2F; s1 * v1);</span><br><span class="line">		for (int64 i &#x3D; 0; i &lt;&#x3D; s2; i++) ans &#x3D; max(ans, v1 * i + (n - s1 * i) &#x2F; s2 * v2);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;&#x2F;&#x2F;否则枚举宝物2的数量。</span><br><span class="line">		for (int64 i &#x3D; 0; s2 * i &lt;&#x3D; n; i++) ans &#x3D; max(ans, v2 * i + (n - s2 * i) &#x2F; s1 * v1);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;Case # %d: %lld\n&quot;, ++id, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑书稿</title>
    <url>/2020/01/20/%E7%BC%96%E8%BE%91%E4%B9%A6%E7%A8%BF/</url>
    <content><![CDATA[<h1 id="UVA-11212-编辑书稿"><a href="#UVA-11212-编辑书稿" class="headerlink" title="UVA 11212 编辑书稿"></a>UVA 11212 编辑书稿</h1><p>你有一篇n(2≤n≤9)个自然段组成的文章，希望将它们排列成1，2，…，n。可以用Ctrl+X（剪切）和Ctrl+V（粘贴）快捷键来完成任务。每次可以剪切一段连续的自然段，粘贴时按照顺序粘贴。注意，剪贴板只有一个，所以不能连续剪切两次，只能剪切和粘贴交替。例如，为了将{2，4，1，5，3，6}变为升序，可以剪切1将其放到2前，然后剪切3将其放到4前。再如，排列{3，4，5，1，2}，只需一次剪切和一次粘贴即可——将{3，4，5}放在{1，2}后，或者将{1，2}放在{3，4，5}前。 </p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li><p>典型的状态空间搜索问题，其中的状态是1-n的排列。排列最多有9！个。但是由于剪切和粘贴的位置不定，所以搜索空间很大。</p>
</li>
<li><p>关于剪枝</p>
<ol>
<li>每次只剪切一段连续的数字，不破坏已经有序的串。</li>
<li>每次剪切至多使后继数字不正确的个数减少3个。考虑abc变成acb时，a b c 三段的末尾的数字。</li>
</ol>
</li>
<li><p>迭代加深搜。迭代以获得下一次递归调用的初始状态，深度搜索来找解。迭代的时候需要枚举剪切的长度，剪切和粘贴的起始位置。注意循环的边界问题。</p>
</li>
<li><p>进行剪切和粘贴的时候，要分情况，因为涉及到其他元素往前移动还是往后移动的问题。</p>
<ol>
<li>如果start位置在pos后面，那么粘贴之后，需要将pos之后到start的元素向后移动len位。</li>
<li>同理如果start在pos前面，则需要从pos开始到start之前的元素向前移动len位。</li>
</ol>
</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="dfs"><a href="#dfs" class="headerlink" title="dfs()"></a>dfs()</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool dfs(int d) &#123;</span><br><span class="line">if (d &#x3D;&#x3D; maxd) </span><br><span class="line">	return not_inorder(d) &#x3D;&#x3D; 0;</span><br><span class="line">if (d * 3 + not_inorder(d) &gt; 3 * maxd) return false; &#x2F;&#x2F;每次剪切时后继不正确的数字个数至多减少三个</span><br><span class="line">													&#x2F;&#x2F;考虑abc变成acb，那么受影响的至多是a b c的最后一个数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;枚举剪切的起始位置和长度</span><br><span class="line">int next &#x3D; d + 1;</span><br><span class="line">for (rint len &#x3D; 0; len &lt; T; len++) &#123;</span><br><span class="line">	for (rint start &#x3D; 0; start &lt;&#x3D; T - len; start++) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;如果试图剪切有序串，那么剪枝</span><br><span class="line">		if (start &gt; 0 &amp;&amp; in[d][start - 1] &#x3D;&#x3D; in[d][start] - 1) continue;</span><br><span class="line">		if (start + len &lt; T &amp;&amp; in[d][start + d - 1] &#x3D;&#x3D; in[d][start + d] - 1) continue;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;枚举粘贴的起始位置</span><br><span class="line">		for (rint pos &#x3D; 0; pos &lt;&#x3D; T - len; pos++)</span><br><span class="line">		&#123;</span><br><span class="line">			&#x2F;&#x2F;也不能粘到自己里面</span><br><span class="line">			if (pos &gt;&#x3D; start &amp;&amp; pos &lt; start + len) continue;</span><br><span class="line">			for (rint i &#x3D; 0; i &lt; T; i++) in[next][i] &#x3D; in[d][i];</span><br><span class="line">			&#x2F;&#x2F;粘贴</span><br><span class="line">			for (rint i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">				in[next][pos + i] &#x3D; in[d][start + i];</span><br><span class="line"></span><br><span class="line">			if (pos &lt; start)</span><br><span class="line">				for (rint i(pos); i &lt; start; ++i)</span><br><span class="line">					in[next][i + len] &#x3D; in[d][i];</span><br><span class="line">			else</span><br><span class="line">				for (rint i(pos); i &gt; start; --i)</span><br><span class="line">					in[next][i - len] &#x3D; in[d][i];</span><br><span class="line">			if (dfs(next)) return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="not-inorder-返回后继不正确的数字的个数"><a href="#not-inorder-返回后继不正确的数字的个数" class="headerlink" title="not_inorder() 返回后继不正确的数字的个数"></a>not_inorder() 返回后继不正确的数字的个数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   inline int not_inorder(int d) &#123;</span><br><span class="line">int ret(0);</span><br><span class="line">for (int i(0); i &lt; T - 1; ++i)</span><br><span class="line">	ret +&#x3D; in[d][i + 1] !&#x3D; in[d][i] + 1;</span><br><span class="line">return ret + (in[d][T - 1] !&#x3D; (T - 1));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="刘老师版-比我的快好多好多"><a href="#刘老师版-比我的快好多好多" class="headerlink" title="刘老师版 比我的快好多好多"></a>刘老师版 比我的快好多好多</h2><ol>
<li>枚举剪切的始末位置和粘贴的起始位置。首先备份待操作数组a，枚举剪切的始末位置，记录剪切后剩余元素到数组b，并记录元素个数为cnt。</li>
<li>然后在0~cnt范围内枚举粘贴的起始位置，之后是最直观的复制。</li>
<li>然后递归求解，如果走不通，再将a数组的备份拷贝回来。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 9;</span><br><span class="line">int n, a[maxn];</span><br><span class="line"></span><br><span class="line">bool is_sorted() &#123;</span><br><span class="line">  for(int i &#x3D; 0; i &lt; n-1; i++)</span><br><span class="line">    if(a[i] &gt;&#x3D; a[i+1]) return false;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; the number of integers with incorrect successor</span><br><span class="line">int h() &#123;</span><br><span class="line">  int cnt &#x3D; 0;</span><br><span class="line">  for(int i &#x3D; 0; i &lt; n-1; i++)</span><br><span class="line">    if(a[i]+1 !&#x3D; a[i+1]) cnt++;</span><br><span class="line">  if(a[n-1] !&#x3D; n) cnt++;</span><br><span class="line">  return cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool dfs(int d, int maxd) &#123;</span><br><span class="line">  if(d*3 + h() &gt; maxd*3) return false;</span><br><span class="line">  if(is_sorted()) return true;</span><br><span class="line"></span><br><span class="line">  int b[maxn], olda[maxn];</span><br><span class="line">  memcpy(olda, a, sizeof(a));</span><br><span class="line">  for(int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">   for(int j &#x3D; i; j &lt; n; j++) &#123;</span><br><span class="line">     &#x2F;&#x2F; cut</span><br><span class="line">     int cnt &#x3D; 0;</span><br><span class="line">     for(int k &#x3D; 0; k &lt; n; k++)</span><br><span class="line">       if(k &lt; i || k &gt; j) b[cnt++] &#x3D; a[k];</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; insert before position k</span><br><span class="line">	 &#x2F;&#x2F;剩余元素中枚举粘贴位置</span><br><span class="line">     for(int k &#x3D; 0; k &lt;&#x3D; cnt; k++) &#123;</span><br><span class="line">       int cnt2 &#x3D; 0;</span><br><span class="line">       for(int p &#x3D; 0; p &lt; k; p++) a[cnt2++] &#x3D; b[p];</span><br><span class="line">       for(int p &#x3D; i; p &lt;&#x3D; j; p++) a[cnt2++] &#x3D; olda[p];</span><br><span class="line">       for(int p &#x3D; k; p &lt; cnt; p++) a[cnt2++] &#x3D; b[p];</span><br><span class="line"></span><br><span class="line">       if(dfs(d+1, maxd)) return true;</span><br><span class="line">       memcpy(a, olda, sizeof(a));</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int solve() &#123;</span><br><span class="line">  if(is_sorted()) return 0;</span><br><span class="line">  int max_ans &#x3D; 5; &#x2F;&#x2F; after experiments, we found ans &lt;&#x3D; 5 for n &lt;&#x3D; 9</span><br><span class="line">  for(int maxd &#x3D; 1; maxd &lt; max_ans; maxd++)</span><br><span class="line">    if(dfs(0, maxd)) return maxd;</span><br><span class="line">  return max_ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int kase &#x3D; 0;</span><br><span class="line">  while(scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n) &#123;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">    printf(&quot;Case %d: %d\n&quot;, ++kase, solve());</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>Abbott的复仇</title>
    <url>/2020/01/20/Abbott%E7%9A%84%E5%A4%8D%E4%BB%87/</url>
    <content><![CDATA[<h1 id="UVA-816-ABBOTT的复仇"><a href="#UVA-816-ABBOTT的复仇" class="headerlink" title="UVA 816 ABBOTT的复仇"></a>UVA 816 ABBOTT的复仇</h1><p>给出一个箭头迷宫，在每个路口处，如果你从某个方向进入了该路口，那么路口的地面上在靠近你的方向会画有一组箭头，它们相对于你的方向可以是向左，向前，向右，或者是它们的任意组合。</p>
<p>当你从某一方向进入某个入口时，下一步只能在这个入口对应方向上标记的箭头中选一个方向继续行进。在起点时，可以选择任何方向。</p>
<p>给出起点和终点，求它们之间的最短路径。</p>
<p>每条边的长度为1</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>对于迷宫问题，一般采用遍历的方法去找出口，本题中采用广度优先遍历。</li>
<li>本题特殊在进入每个交叉点的方向不同，允许他出去的方向也不同。采用map来存储进入方向和出去方向的对应关系，因为一个进入方向对应的出去方向不唯一，所以采用map&lt;int,set<int>&gt; 来存储</li>
<li>每个位置不同进入方向的转向也可以是用二进制法记录</li>
<li>本题主要是细节问题比较多。并且因为图的大小至多为9*9，所以也可以使用高维数组</li>
</ol>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  using namespace std;</span><br><span class="line">  const int dr[] &#x3D; &#123; -1,0,1,0 &#125;;</span><br><span class="line">  const int dc[] &#x3D; &#123; 0,1,0,-1 &#125;;</span><br><span class="line"></span><br><span class="line">  struct Node &#123;</span><br><span class="line">&#x2F;&#x2F;节点 表示当前位置</span><br><span class="line">  	int r;</span><br><span class="line">  	int c;</span><br><span class="line">  	int dir;</span><br><span class="line">  	Node() &#123;&#125;;</span><br><span class="line">  	Node(int r, int c, int dir &#x3D; -5) :r(r), c(c), dir(dir) &#123;&#125;</span><br><span class="line">  	bool operator&lt;(const Node &amp;a) const &#123;</span><br><span class="line">  		return r &lt; a.r || r &#x3D;&#x3D; a.r&amp;&amp;c &lt; a.c || r &#x3D;&#x3D; a.r&amp;&amp;c &#x3D;&#x3D; a.c&amp;&amp;dir &lt; a.dir;</span><br><span class="line">  	&#125;</span><br><span class="line">  	bool operator!&#x3D;(const Node &amp;a) const &#123;</span><br><span class="line">  		return r !&#x3D; a.r || c !&#x3D; a.c || dir !&#x3D; a.dir;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  Node sta, over;</span><br><span class="line">  string dirs &#x3D; &quot;NESW&quot;;</span><br><span class="line">  int dir_id(char c) &#123; return dirs.find(c); &#125;</span><br><span class="line">  string turns &#x3D; &quot;FLR&quot;;</span><br><span class="line">  int turn_id(char c) &#123; return turns.find(c); &#125;</span><br><span class="line">  </span><br><span class="line">  map&lt;int, map&lt;int, map&lt;int, set&lt;int&gt;&gt;&gt;&gt; maze;&#x2F;&#x2F;r,c,dir,turn</span><br><span class="line">  set&lt;Node&gt;have_travel;</span><br><span class="line">  map&lt;Node, Node&gt; path;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  Node walk(const Node &amp;u, int turn) &#123;</span><br><span class="line">&#x2F;&#x2F;※非常nb的简化</span><br><span class="line">  	int dir &#x3D; u.dir;</span><br><span class="line">  	if (turn &#x3D;&#x3D; 1) dir &#x3D; (dir + 3) % 4;&#x2F;&#x2F;顺时针走一步</span><br><span class="line">  	if (turn &#x3D;&#x3D; 2) dir &#x3D; (dir + 1) % 4;&#x2F;&#x2F;逆时针走一个</span><br><span class="line">  	return Node(u.r + dr[dir], u.c + dc[dir], dir);</span><br><span class="line">  &#125;</span><br><span class="line">  int main() &#123;</span><br><span class="line">  	string name;</span><br><span class="line">  	while (getline(cin, name) &amp;&amp; name !&#x3D; &quot;END&quot;)</span><br><span class="line">  	&#123;</span><br><span class="line">  		path.clear();</span><br><span class="line">  		have_travel.clear();</span><br><span class="line">  		maze.clear();</span><br><span class="line">  		cout &lt;&lt; name &lt;&lt; endl &lt;&lt; &quot; &quot;;</span><br><span class="line">  		char ch;</span><br><span class="line">  		cin &gt;&gt; sta.r &gt;&gt; sta.c &gt;&gt; ch &gt;&gt; over.r &gt;&gt; over.c;</span><br><span class="line">  		sta.dir &#x3D; dir_id(ch);</span><br><span class="line">  </span><br><span class="line">  		int a &#x3D; sta.r, b &#x3D; sta.c;</span><br><span class="line">  	</span><br><span class="line">  		sta.r +&#x3D; dr[sta.dir];</span><br><span class="line">  		sta.c +&#x3D; dc[sta.dir];</span><br><span class="line">  		&#x2F;&#x2F;得到入口和出口，并从入口处走了一步</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  		int r, c;</span><br><span class="line">  		while (cin &gt;&gt; r &amp;&amp; r) &#123;</span><br><span class="line">  			cin &gt;&gt; c;</span><br><span class="line">  			string s;</span><br><span class="line">  			while (cin &gt;&gt; s &amp;&amp; s !&#x3D; &quot;*&quot;) &#123;</span><br><span class="line">  </span><br><span class="line">  				for (int i &#x3D; 1; i &lt; s.length(); i++) &#123;</span><br><span class="line">  					maze[r][c][dir_id(s[0])].insert(turn_id(s[i]));</span><br><span class="line">  					&#x2F;存下每个(x,y)处，进入方向和出去方向的对应关系</span><br><span class="line">  				&#125;</span><br><span class="line">  			&#125;</span><br><span class="line">  </span><br><span class="line">  		&#125;</span><br><span class="line">  		getchar();</span><br><span class="line">  		queue&lt;Node&gt; q;</span><br><span class="line">  		vector&lt;Node&gt; ans;</span><br><span class="line">  </span><br><span class="line">  		bool flag &#x3D; false;</span><br><span class="line">  		if (sta.c &#x3D;&#x3D; over.c &amp;&amp; sta.r &#x3D;&#x3D; over.r) &#123;</span><br><span class="line">  			flag &#x3D; true;</span><br><span class="line">  		&#125;</span><br><span class="line">  		else &#123;</span><br><span class="line">  			q.push(sta);</span><br><span class="line">  			ans.push_back(over);</span><br><span class="line">  		&#125;</span><br><span class="line">  		&#x2F;&#x2F;开始广度优先遍历</span><br><span class="line">  		while (!q.empty()) &#123;</span><br><span class="line">  			Node u &#x3D; q.front(); q.pop();</span><br><span class="line">  			if (u.r &#x3D;&#x3D; over.r&amp;&amp;u.c &#x3D;&#x3D; over.c) &#123;</span><br><span class="line">  				over &#x3D; u;</span><br><span class="line">  				flag &#x3D; true;</span><br><span class="line">  				break;</span><br><span class="line">  			&#125;</span><br><span class="line">  			for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">  				&#x2F;&#x2F;四个方向尝试走</span><br><span class="line">  				Node v &#x3D; walk(u, i);</span><br><span class="line">  				if (maze[u.r][u.c][u.dir].count(i)</span><br><span class="line">  					&amp;&amp; !have_travel.count(v)</span><br><span class="line">  					)&#x2F;&#x2F;能走：该进入方向能通向出去的方向；该点没被遍历过</span><br><span class="line">  				&#123;</span><br><span class="line">  					have_travel.insert(v);</span><br><span class="line">  					path[v] &#x3D; u;</span><br><span class="line">  					q.push(v);</span><br><span class="line">  				&#125;</span><br><span class="line">  </span><br><span class="line">  			&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  		&#125;</span><br><span class="line">  		if (!flag) &#123;</span><br><span class="line">  			cout &lt;&lt; &quot; No Solution Possible&quot; &lt;&lt; endl;</span><br><span class="line">  			continue;</span><br><span class="line">  		&#125;</span><br><span class="line">  		Node u &#x3D; path[over];</span><br><span class="line">  </span><br><span class="line">  		&#x2F;&#x2F;迭代输出路径</span><br><span class="line">  		while (u !&#x3D; sta) &#123;</span><br><span class="line">  			if (!path.count(u)) break;</span><br><span class="line">  			ans.push_back(u);</span><br><span class="line">  			u &#x3D; path[u];</span><br><span class="line">  		&#125;</span><br><span class="line">  		ans.push_back(sta);</span><br><span class="line">  		ans.push_back(Node(a, b, 0));</span><br><span class="line">  </span><br><span class="line">  		for (int i &#x3D; ans.size() - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">  			cout &lt;&lt; &quot; (&quot; &lt;&lt; ans[i].r &lt;&lt; &quot;,&quot; &lt;&lt; ans[i].c &lt;&lt; &quot;)&quot;;</span><br><span class="line">  			if ((ans.size() - i) % 10 &#x3D;&#x3D; 0 &amp;&amp; i) cout &lt;&lt; endl &lt;&lt; &quot; &quot;;</span><br><span class="line">  		&#125;</span><br><span class="line">  		cout &lt;&lt; endl;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="又是欣赏刘老师代码的一天"><a href="#又是欣赏刘老师代码的一天" class="headerlink" title="又是欣赏刘老师代码的一天"></a>又是欣赏刘老师代码的一天</h2><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Node &#123;&#x2F;&#x2F;三元组存储节点</span><br><span class="line">  int r, c, dir; </span><br><span class="line">  Node(int r&#x3D;0, int c&#x3D;0, int dir&#x3D;0):r(r),c(c),dir(dir) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 10;</span><br><span class="line">const char* dirs &#x3D; &quot;NESW&quot;; &#x2F;&#x2F; 此处和walk函数，dx,dy相互配合</span><br><span class="line">const char* turns &#x3D; &quot;FLR&quot;;</span><br><span class="line"></span><br><span class="line">int has_edge[maxn][maxn][4][3];</span><br><span class="line">int d[maxn][maxn][4];</span><br><span class="line">Node p[maxn][maxn][4];</span><br><span class="line">int r0, c0, dir, r1, c1, r2, c2;</span><br><span class="line"></span><br><span class="line">int dir_id(char c) &#123; return strchr(dirs, c) - dirs; &#125;</span><br><span class="line">int turn_id(char c) &#123; return strchr(turns, c) - turns; &#125;</span><br><span class="line"></span><br><span class="line">const int dr[] &#x3D; &#123;-1, 0, 1, 0&#125;;</span><br><span class="line">const int dc[] &#x3D; &#123;0, 1, 0, -1&#125;;</span><br><span class="line"></span><br><span class="line">Node walk(const Node&amp; u, int turn) &#123;</span><br><span class="line">  int dir &#x3D; u.dir;</span><br><span class="line">  if(turn &#x3D;&#x3D; 1) dir &#x3D; (dir + 3) % 4; &#x2F;&#x2F; 閫嗘椂閽?</span><br><span class="line">  if(turn &#x3D;&#x3D; 2) dir &#x3D; (dir + 1) % 4; &#x2F;&#x2F; 椤烘椂閽?</span><br><span class="line">  return Node(u.r + dr[dir], u.c + dc[dir], dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  while(read_case()) &#123;</span><br><span class="line">    solve();</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="inside-判断合法，由于图比较小，并且没有直接给出边界，所以判断难点比较宽泛"><a href="#inside-判断合法，由于图比较小，并且没有直接给出边界，所以判断难点比较宽泛" class="headerlink" title="inside 判断合法，由于图比较小，并且没有直接给出边界，所以判断难点比较宽泛"></a>inside 判断合法，由于图比较小，并且没有直接给出边界，所以判断难点比较宽泛</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool inside(int r, int c) &#123;</span><br><span class="line">  return r &gt;&#x3D; 1 &amp;&amp; r &lt;&#x3D; 9 &amp;&amp; c &gt;&#x3D; 1 &amp;&amp; c &lt;&#x3D; 9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="read-case-记录读入的数据，注意起始点为给的初始位置的下一步"><a href="#read-case-记录读入的数据，注意起始点为给的初始位置的下一步" class="headerlink" title="read_case 记录读入的数据，注意起始点为给的初始位置的下一步"></a>read_case 记录读入的数据，注意起始点为给的初始位置的下一步</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool read_case() &#123;</span><br><span class="line">  char s[99], s2[99];</span><br><span class="line">  if(scanf(&quot;%s%d%d%s%d%d&quot;, s, &amp;r0, &amp;c0, s2, &amp;r2, &amp;c2) !&#x3D; 6) return false;</span><br><span class="line">  printf(&quot;%s\n&quot;, s);</span><br><span class="line"></span><br><span class="line">  dir &#x3D; dir_id(s2[0]);</span><br><span class="line">  r1 &#x3D; r0 + dr[dir];</span><br><span class="line">  c1 &#x3D; c0 + dc[dir];</span><br><span class="line"></span><br><span class="line">  memset(has_edge, 0, sizeof(has_edge));</span><br><span class="line">  for(;;) &#123;</span><br><span class="line">    int r, c;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;r);</span><br><span class="line">    if(r &#x3D;&#x3D; 0) break;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;c);</span><br><span class="line">    while(scanf(&quot;%s&quot;, s) &#x3D;&#x3D; 1 &amp;&amp; s[0] !&#x3D; &#39;*&#39;) &#123;</span><br><span class="line">      for(int i &#x3D; 1; i &lt; strlen(s); i++)</span><br><span class="line">        has_edge[r][c][dir_id(s[0])][turn_id(s[i])] &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="print-ans-打印路径，由于记录时是逆序的，所以要多处理下"><a href="#print-ans-打印路径，由于记录时是逆序的，所以要多处理下" class="headerlink" title="print_ans 打印路径，由于记录时是逆序的，所以要多处理下"></a>print_ans 打印路径，由于记录时是逆序的，所以要多处理下</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void print_ans(Node u) &#123;</span><br><span class="line"></span><br><span class="line">  vector&lt;Node&gt; nodes;</span><br><span class="line">  for(;;) &#123;</span><br><span class="line">    nodes.push_back(u);</span><br><span class="line">    if(d[u.r][u.c][u.dir] &#x3D;&#x3D; 0) break;</span><br><span class="line">    u &#x3D; p[u.r][u.c][u.dir];</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.push_back(Node(r0, c0, dir));</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 鎵撳嵃瑙ｏ紝姣忚10涓?</span><br><span class="line">  int cnt &#x3D; 0;</span><br><span class="line">  for(int i &#x3D; nodes.size()-1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">    if(cnt % 10 &#x3D;&#x3D; 0) printf(&quot; &quot;);</span><br><span class="line">    printf(&quot; (%d,%d)&quot;, nodes[i].r, nodes[i].c);</span><br><span class="line">    if(++cnt % 10 &#x3D;&#x3D; 0) printf(&quot;\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if(nodes.size() % 10 !&#x3D; 0) printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="solve-深搜的过程，父节点采用三维数组记录"><a href="#solve-深搜的过程，父节点采用三维数组记录" class="headerlink" title="solve 深搜的过程，父节点采用三维数组记录"></a>solve 深搜的过程，父节点采用三维数组记录</h2><ol>
<li>注意此题认为同一个点不同方向进入也是不同的，所以访问标志等都是三维数组</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">  queue&lt;Node&gt; q;</span><br><span class="line">  memset(d, -1, sizeof(d));</span><br><span class="line">  Node u(r1, c1, dir);</span><br><span class="line">  d[u.r][u.c][u.dir] &#x3D; 0;</span><br><span class="line">  q.push(u);</span><br><span class="line">  while(!q.empty()) &#123;</span><br><span class="line">    Node u &#x3D; q.front(); q.pop();</span><br><span class="line">    if(u.r &#x3D;&#x3D; r2 &amp;&amp; u.c &#x3D;&#x3D; c2) &#123; print_ans(u); return; &#125;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">      Node v &#x3D; walk(u, i);</span><br><span class="line">      if(has_edge[u.r][u.c][u.dir][i] &amp;&amp; inside(v.r, v.c) &amp;&amp; d[v.r][v.c][v.dir] &lt; 0) &#123;</span><br><span class="line">        d[v.r][v.c][v.dir] &#x3D; d[u.r][u.c][u.dir] + 1;</span><br><span class="line">        p[v.r][v.c][v.dir] &#x3D; u;</span><br><span class="line">        q.push(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;  No Solution Possible\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>S树</title>
    <url>/2020/01/20/S%E6%A0%91/</url>
    <content><![CDATA[<h1 id="uva712-S树"><a href="#uva712-S树" class="headerlink" title="uva712 S树"></a>uva712 S树</h1><p>给一棵满二叉树，每一层代表一个010101变量，取000时往左走，取111时往右走。例如下图中两个图都对应表达式x1∧(x2∨x3)x_1\land (x_2\lor x_3)x1​∧(x2​∨x3​)。<br>给出所有叶子的值以及一些查询（即每个变量xix_ixi​的取值），求每个查询到达的叶子的值。例如有444个查询：000000000，010010010，111111111，110110110，则输出应为001100110011。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>n0 = n2+1;本题中直到叶子节点数，又是满二叉树，所以非叶子节点共n0-1个，所以直接从n0开始存叶子节点。</li>
<li>对于每个查询，遇到1代表向右走，k = 2<em>k+1;遇到0带表k = 2</em>k；最终会走到叶子节点，将他们输出即可；<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   #include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;习题6-2in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;习题6-2out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   int n, m, kase &#x3D; 0;</span><br><span class="line">   int main() &#123;</span><br><span class="line">while (cin &gt;&gt; m &amp;&amp; m) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;S-Tree # &quot; &lt;&lt; ++kase &lt;&lt; &quot;:&quot; &lt;&lt; endl;</span><br><span class="line">	getchar();</span><br><span class="line">	string s;</span><br><span class="line">	getline(cin, s);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	getline(cin, s);</span><br><span class="line"></span><br><span class="line">	int first &#x3D; s.length();</span><br><span class="line">	map&lt;long long , char&gt; leaf;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; s.length(); i++) leaf[first++] &#x3D; s[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; n; getchar();</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		getline(cin, s);</span><br><span class="line">		int k &#x3D; 1;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; s.length(); j++) &#123;</span><br><span class="line">			if (s[j] &#x3D;&#x3D; &#39;0&#39;) k *&#x3D; 2;</span><br><span class="line">			else k &#x3D; k * 2 + 1;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; leaf[k];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>Tex中的引导</title>
    <url>/2020/01/20/Tex%E4%B8%AD%E7%9A%84%E5%BC%95%E5%AF%BC/</url>
    <content><![CDATA[<h1 id="TEx-中的引导"><a href="#TEx-中的引导" class="headerlink" title="TEx 中的引导"></a>TEx 中的引导</h1><p>/*<br>在TeX中，左双引号是“``”，有双引号是“’’”.输入一篇包<br>含双引号的文章，你的任务是把它转换乘TeX的格式<br>*/</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   #include&lt;iostream&gt;</span><br><span class="line">   #include&lt;cstring&gt;</span><br><span class="line">   #pragma warning(disable :4996)</span><br><span class="line">   &#x2F;&#x2F;# define LOCAL</span><br><span class="line">   int main() &#123;</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   	FILE *fin, *fout;</span><br><span class="line">   	fin &#x3D; freopen(&quot;Texin.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   	fout &#x3D; freopen(&quot;Texout.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif &#x2F;&#x2F; LOCAL</span><br><span class="line">&#x2F;&#x2F;本题特点是可以边读边写</span><br><span class="line">int c;&#x2F;&#x2F;c要定义为整型，因为文件结束会返回一个特殊标记EOF，它是一个整型；</span><br><span class="line">int p &#x3D; 1;</span><br><span class="line">while ((c &#x3D; getchar())!&#x3D; EOF) &#123;&#x2F;&#x2F;c&#x3D;getchar()一定要先括起来，因为等于和不等于同级，从右侧开始</span><br><span class="line">	if (c &#x3D;&#x3D; &#39;&quot;&#39;) &#123;</span><br><span class="line">		printf(&quot;%s&quot;, p ? &quot;&#96;&#96;&quot; : &quot;&#39;&#39;&quot;);</span><br><span class="line">		p &#x3D; !p;&#x2F;&#x2F;这个反转非常的灵性</span><br><span class="line">	&#125;</span><br><span class="line">	else printf(&quot;%c&quot;, c);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>8259</title>
    <url>/2019/11/18/8259/</url>
    <content><![CDATA[<h1 id="I-O概述"><a href="#I-O概述" class="headerlink" title="I/O概述"></a>I/O概述</h1><h2 id="I-O方式概述"><a href="#I-O方式概述" class="headerlink" title="I/O方式概述"></a>I/O方式概述</h2><ol>
<li>基本输入输出方式<ol>
<li>程序控制I/O<ol>
<li>无条件传送方式</li>
<li>查询方式</li>
<li>中断方式</li>
</ol>
</li>
<li>DMA方式</li>
</ol>
</li>
</ol>
<h2 id="I-O接口概述"><a href="#I-O接口概述" class="headerlink" title="I/O接口概述"></a>I/O接口概述</h2><ol>
<li>CPU对外设的访问实质上就是对I/O接口电路中相应端口的访问。</li>
<li>端口地址由译码电路实现。</li>
<li>内存地址和I/O地址可以统一编址/独立编址。</li>
</ol>
<h3 id="I-O基本的并行输入-输出接口"><a href="#I-O基本的并行输入-输出接口" class="headerlink" title="I/O基本的并行输入/输出接口"></a>I/O基本的并行输入/输出接口</h3><ol>
<li>输入三态门，输出锁存器</li>
</ol>
<h1 id="程序查询I-O方式"><a href="#程序查询I-O方式" class="headerlink" title="程序查询I/O方式"></a>程序查询I/O方式</h1><ol>
<li>无条件方式：见题4</li>
<li>查询方式：需询问忙信号；详情见题6。<ol>
<li>多外设的查询控制<ol>
<li><img src="/微机原理_img/2.png" style="zoom:80%"></li>
<li><img src="/微机原理_img/3.png" style="zoom:80%"></li>
</ol>
</li>
</ol>
</li>
<li>中断方式</li>
</ol>
<h1 id="中断方式"><a href="#中断方式" class="headerlink" title="中断方式"></a>中断方式</h1><h2 id="中断概述"><a href="#中断概述" class="headerlink" title="中断概述"></a>中断概述</h2><ol>
<li><p>中断：CPU暂停现行程序，转而处理随机到来的事件。</p>
</li>
<li><p>基本模型</p>
 <img src="/微机原理_img/4.png" style="zoom:80%"></li>
<li><p>中断过程：</p>
<ol>
<li>中断响应：<ol>
<li>在每条指令的最后一个时钟周期，CPU检测INTR或NMI信号。</li>
<li>断点保护：<ol>
<li>将OSW的内容压入堆栈。</li>
<li>自动关中断：IF=0,TF=0</li>
<li>将CS的内容压入堆栈。</li>
<li>将IP的内容压入堆栈。</li>
</ol>
</li>
<li>中断判优：<ol>
<li>优先处理优先级较高的中断。如果当前正在执行低优先级任务，那么允许它会被高优先级的中断源所中断—中断嵌套。</li>
<li>优先级相同，则遵照先来先服务原则。</li>
</ol>
</li>
<li>识别中断源<ol>
<li>软件查询：将中断信号从数据总线读入，用程序进行判断。</li>
<li>中断矢量法：由中断源提供中断类型，CPU根据类型确定中断源。</li>
</ol>
</li>
<li>获得中断服务程序的首地址<ol>
<li>中断服务子程序的工作：<ol>
<li>保护现场(PUSH reg)</li>
<li>开中断(STI)</li>
<li>进行中断处理</li>
<li>关中断(CLI)</li>
<li>恢复现场(POP reg)</li>
<li>中断返回(IRET)</li>
</ol>
</li>
</ol>
</li>
<li>中断返回：执行中断返回指令IRET，将内存中保存的断点信息弹出到IP、CS和FLAG中。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="Intel-16位中断系统"><a href="#Intel-16位中断系统" class="headerlink" title="Intel 16位中断系统"></a>Intel 16位中断系统</h2><h3 id="x86中断响应过程"><a href="#x86中断响应过程" class="headerlink" title="x86中断响应过程"></a>x86中断响应过程</h3><img src="/微机原理_img/5.png" style="zoom:80%">

<ol>
<li>Flags(标志寄存器)、CS(代码段寄存器)、IP(指令指针寄存器)压入栈，关中断(CLI)</li>
<li>第一次INTA，通知CPU要进行中断。</li>
<li>第二次INTA，取中断向量码。</li>
<li>取得中断向量地址：由于一个中断向量占4B，所以要乘4。</li>
<li>在中断向量中得到基址放入IP，得到偏移放入(CS)</li>
<li>跳转到CS和IP共同指向的地址执行中断处理程序。</li>
<li>执行到IRET（中断返回）时返回。弹出栈中IP,CS,Flags。</li>
</ol>
<h2 id="8259"><a href="#8259" class="headerlink" title="8259"></a>8259</h2><ol>
<li>内部结构<ol>
<li>中断请求寄存器IRR：某位为1代表对应位有中断。</li>
<li>中断服务寄存器ISR:某位为1代表对应位正在被服务。</li>
<li>中断屏蔽寄存器IMR：某位为1代表不应该为该信号向CPU发中断。</li>
</ol>
</li>
<li>引脚 <img src="/微机原理_img/7.png" style="zoom:80%"></li>
<li>8259工作方式：<ol>
<li>中断结束方式：<ol>
<li>非自动：通过中断处理程序提供EOI（特殊/一般）</li>
<li>自动：在第2个INTA后沿自动执行。</li>
</ol>
</li>
<li>缓冲方式：缓冲/非缓冲</li>
<li>嵌套方式<ol>
<li>一般嵌套：单片/从片</li>
<li>特殊全嵌套：<strong>仅主片</strong></li>
</ol>
</li>
<li>屏蔽方式：一般屏蔽，特殊屏蔽</li>
<li>优先级规定<ol>
<li>固定优先级：0最大</li>
<li>循环优先级 自动/指定</li>
</ol>
</li>
</ol>
</li>
<li>嵌套方式：<ol>
<li>一般嵌套方式：只有更高优先级的事件可以打断当前中断处理过程而被服务</li>
<li>特殊全前嵌套方式：一中断正被处理时，允许同级或更高优先级的事件打断当前的中断处理过程而被服务。</li>
</ol>
</li>
<li>中断方式<ol>
<li>自动EOI：因不保留当前正在服务的中断状态不能用于中断嵌套方式。</li>
<li>SEOI：由CPU发出一条SEOI命令，该EOI命令指出了所要复位的ISR信号。<strong>用于特殊屏蔽方式</strong></li>
<li>NSEOI ：由CPU发出正常EOI命令，使得ISRi=1中优先级最高的那一位复位。<strong>用于一般屏蔽方式</strong></li>
<li>在特殊全嵌套下，只有当从属PIC的中断全部处理完后，才向主PIC发EOI命令。</li>
</ol>
</li>
<li>优先级规定<ol>
<li>固定优先级：0最大，7最小。</li>
<li>循环优先级：<ol>
<li>自动循环优先级：初始优先级可编程，之后当某个中断请求被处理后，其优先级自动将为最低，原本它的下一优先级中断升为最高级。</li>
</ol>
</li>
<li>指定优先级：通过OCW2</li>
</ol>
</li>
</ol>
<h2 id="8259级联"><a href="#8259级联" class="headerlink" title="8259级联"></a>8259级联</h2><ol>
<li><p>最多支持64个中断源，n片级联支持7n+1个中断源。</p>
</li>
<li><p>级联方式见本</p>
 <img src="/微机原理_img/8.png" style="zoom:80%">
</li>
<li><p>中断响应方式</p>
<ol>
<li>主控8259：在第一个INTA周期，清IRR相应位， 设置ISR相应位，送级联地址CAS0～CAS2。 </li>
<li>从属8259：读级联地址，若与识别地址（ICW3） 一致，则接收INTA信号，清除相应IRR位、置位 相应ISR位；在第二个INTA周期将中断向量码 （ICW2）输出至数据总线。 </li>
<li>若中断源直接连在主控8259的IR端（由ICW3确 定），则中断向量由主控8259提供。</li>
</ol>
</li>
<li><p>8259编程</p>
<ol>
<li><p>初始化过程，向ICW1-ICW4写入。</p>
</li>
<li><p>操作方式编程：向OW1-OW3写入。</p>
</li>
<li><p>内部存储器的访问方法</p>
 <img src="/微机原理_img/9.png" style="zoom:80%"></li>
<li><p>初始化流程</p>
 <img src="/微机原理_img/10.png">

</li>
</ol>
</li>
</ol>
<h2 id="初始化编程"><a href="#初始化编程" class="headerlink" title="初始化编程"></a>初始化编程</h2><ol>
<li><p>ICW1 初始化字<br> ICW1写入后：清除ISR,IMR；将中断<strong>优先级</strong>设成初始默认；设定为<strong>一般屏蔽</strong>方式；采用<strong>非自动中断结束</strong>方式；状态读出逻辑阈值为IRR</p>
 <img src="/微机原理_img/11.png" style="zoom:80%">

<ol>
<li>LTIM(触发方式)：=1高电平触发；=0上升沿触发；</li>
<li>SNGL（级联控制）=1单片；=0级联；</li>
<li>IC4（ICW4控制）：=1写ICW4;=0不写ICW4；</li>
</ol>
</li>
<li><p>ICW2 中断向量码</p>
 <img src="/微机原理_img/12.png" style="zoom:80%">
 1. D7-D3：为中断向量码的高5位，D2-D0为中断源序号</li>
<li><p>ICW3 级联控制字</p>
 <img src="/微机原理_img/12.png" style="zoom:80%">
 1. 主片的ICW3中Si=1代表对应线上连接了从片
 2. 从片D2-D0说明连接到主片的哪个引脚上。
 3. 中断响应时，主片通过级联线CAS2-CAS0送出被允许中断的从片标识码，各从片用自己的ICW3与CAS2-CAS0比较，二者一样从片才发送中断向量码。</li>
<li><p>ICW4 中断结束方式字</p>
 <img src="/微机原理_img/13.png" style="zoom:80%">
 1. SFNM =1特殊全嵌套；=0一般嵌套；
 2. AEOI =1自动EOI方式；=0非自动EOI方式；
 3. <img src="/微机原理_img/18.png" style="zoom:80%">

</li>
</ol>
<h2 id="操作方式编程"><a href="#操作方式编程" class="headerlink" title="操作方式编程"></a>操作方式编程</h2><p><strong>OCW1</strong>必须写入<strong>奇地址</strong>（<strong>A0=1</strong>）</p>
<p><strong>OCW2，OCW3</strong>必须写入<strong>偶地址</strong>(<strong>A0=0</strong>)</p>
<ol>
<li><p>OCW1 中断屏蔽字</p>
 <img src="/微机原理_img/14.png" style="zoom:80%">

<ol>
<li>其中Mi=1代表IRi被屏蔽；=0允许IRi中断。</li>
<li>A0=1时，读OCW1可读出设置。</li>
</ol>
</li>
<li><p>OCW2 中断结束和优先级循环</p>
 <img src="/微机原理_img/15.png" style="zoom:80%">

<ol>
<li>L2-L0 指定优先级/EOI编码</li>
<li>R 循环优先级</li>
<li>SL 只当优先级/只当EOI</li>
<li>EOI 执行结束中断命令<img src="/微机原理_img/16.png" style="zoom:80%">
</li>
</ol>
</li>
<li><p>OCW3 屏蔽方式和读出控制字</p>
 <img src="/微机原理_img/17.png" style="zoom:80%">

<ol>
<li>读IRR/ISR 写入此命令后，对同一地址，即可得到IRR和ISR内容。</li>
<li>比如，CPU将D2=1写入OCW3，再对同一地址读入，如果I=1代表有中断，中断请求号为R2-R0；可反复查询。</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>8255</title>
    <url>/2019/11/06/8255/</url>
    <content><![CDATA[<h1 id="非DMA方式传送数据"><a href="#非DMA方式传送数据" class="headerlink" title="非DMA方式传送数据"></a>非DMA方式传送数据</h1><h2 id="中断方式"><a href="#中断方式" class="headerlink" title="中断方式"></a>中断方式</h2><ol>
<li><p>单向</p>
 <img src="/微机原理_img/19.png" style="zoom:80%">

<ol>
<li>输出设备:OBF 代表输出缓冲区满，低电平有效；ACK为负脉冲确认信号。</li>
<li>输入设备：IBF代表输入缓冲区满，高电平标识已满，低电平表示为空；STB为锁存信号。</li>
</ol>
</li>
<li><p>双向</p>
</li>
</ol>
<img src="/微机原理_img/20.png" style="zoom:80%">
    1. 有三个寄存器，一个用于输入，一个用于输出，另一个是状态寄存器用于标识输入/输出。

<h1 id="8255-可编程并行接口"><a href="#8255-可编程并行接口" class="headerlink" title="8255 可编程并行接口"></a>8255 可编程并行接口</h1><img src="/微机原理_img/21.png" style="zoom:80%">
    ※ A组包括A口和C口高四位；B组包括B口和C口低四位

<ol>
<li>8255的工作方式：包括方式0（输入），方式1（单向输入/输出），方式2（双向）</li>
<li>地址线00(A),01<br>(B),10(C),11(控制)</li>
</ol>
<h2 id="方式0-基本输入输出"><a href="#方式0-基本输入输出" class="headerlink" title="方式0 基本输入输出"></a>方式0 基本输入输出</h2><p>复位信号有效时，三个口都变成方式0。</p>
<h2 id="方式1-选通输入输出"><a href="#方式1-选通输入输出" class="headerlink" title="方式1 选通输入输出"></a>方式1 选通输入输出</h2><p>当A/B工作在方式1下时，需要借用C口的三个引脚做一对握手信号和一个中断信号。</p>
<img src="/微机原理_img/22.png" style="zoom:80%">

<ol>
<li><p>A,B都作为输出时</p>
 <img src="/微机原理_img/23.png" style="zoom:80%">
</li>
<li><p>A,B都作为输入时</p>
 <img src="/微机原理_img/24.png" style="zoom:80%">
</li>
<li><p>其中PC6,PC2做可中断允许位，高电平有效。</p>
</li>
<li><p>方式1下可以通过查询PC7来判断忙。</p>
</li>
</ol>
<h2 id="方式2-双向输入输出方式"><a href="#方式2-双向输入输出方式" class="headerlink" title="方式2 双向输入输出方式"></a>方式2 双向输入输出方式</h2><p>需要借用C口的五个引脚：PC0~PC7，做两对握手信号和一个中断信号。</p>
<ol start="4">
<li>控制字</li>
</ol>
<img src="/微机原理_img/25.png" style="zoom:80%">

<p>可通过读C口状态字，检测A口B口状态。</p>
<h1 id="8253-可编程定时器"><a href="#8253-可编程定时器" class="headerlink" title="8253 可编程定时器"></a>8253 可编程定时器</h1><h2 id="方式-0-产生一定宽度的负脉冲"><a href="#方式-0-产生一定宽度的负脉冲" class="headerlink" title="方式 0    产生一定宽度的负脉冲"></a>方式 0    产生一定宽度的负脉冲</h2><img src="/微机原理_img/26.png" style="zoom:80%">    

<ol>
<li>GATE:高电平允许计数</li>
<li>OUTPUT:在GATE为1的情况下，从写入计数初值开始，持续n*T的负脉冲。</li>
</ol>
<h2 id="方式-1-可编程单稳"><a href="#方式-1-可编程单稳" class="headerlink" title="方式 1 可编程单稳"></a>方式 1 可编程单稳</h2><img src="/微机原理_img/27.png" style="zoom:80%">    

<ol>
<li>GATE:上升沿表示开始计数</li>
<li>OUTPUT:写入计数初值后，等一个GATE上升沿装载，等一个时钟下降沿开始计数。每给一个上升沿，重新开始计数。</li>
</ol>
<h2 id="方式-2-产生周期负脉冲"><a href="#方式-2-产生周期负脉冲" class="headerlink" title="方式 2 产生周期负脉冲"></a>方式 2 产生周期负脉冲</h2><img src="/微机原理_img/28.png" style="zoom:80%">    

<ol>
<li>GATE:低电平禁止计数，高电平允许计数，上升沿重新装载。</li>
<li>OUTPUT:写入计数初值后，等一个上升沿开始计数。每给一个上升沿，重新开始计数。</li>
</ol>
<h2 id="方式-3-方波发生器"><a href="#方式-3-方波发生器" class="headerlink" title="方式 3 方波发生器"></a>方式 3 方波发生器</h2><img src="/微机原理_img/29.png" style="zoom:80%">    

<ol>
<li>GATE:低电平禁止计数，高电平允许计数，上升沿重新装载。</li>
<li>OUTPUT：产生周期性方波。如果n为奇数，那么高电平时从n+1开始，低电平从n-1开始。</li>
</ol>
<h2 id="方式-4-软件触发选通"><a href="#方式-4-软件触发选通" class="headerlink" title="方式 4 软件触发选通"></a>方式 4 软件触发选通</h2><img src="/微机原理_img/30.png" style="zoom:80%">    

<ol>
<li>GATE:低电平禁止计数，高电平允许计数。</li>
<li>OUTPUT:写入计数初值，等一个<strong>时钟</strong>下降沿开始计数。</li>
</ol>
<h2 id="方式-5-产生周期负脉冲"><a href="#方式-5-产生周期负脉冲" class="headerlink" title="方式 5 产生周期负脉冲"></a>方式 5 产生周期负脉冲</h2><img src="/微机原理_img/31.png" style="zoom:80%">    

<ol>
<li>GATE：上升沿开始计数。</li>
<li>OUTPUT:产生n*T的周期性正脉冲。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/微机原理_img/32.png" style="zoom:80%">    

<h2 id="控制字"><a href="#控制字" class="headerlink" title="控制字"></a>控制字</h2><ol>
<li><img src="/微机原理_img/34.png" style="zoom:80%"></li>
</ol>
<p><strong>二进制下，最大定时时常为65536个时钟周期，对应0000H</strong><br>2.<br><img src="/微机原理_img/33.png" style="zoom:80%"><br>    1.<br>    <strong>初始化的时候，要求先初始化方式字，再装入各计数器的计数值</strong><br>    2. 先写低8位，再写高8位。</p>
<h2 id="单个定时器"><a href="#单个定时器" class="headerlink" title="单个定时器"></a>单个定时器</h2><ol>
<li>若时钟频率2MHz，则Tclk=0.5us</li>
<li>单个定时器的最大定时时间为65536×0.5us=32.768ms</li>
</ol>
<h2 id="多个计时器串联增加最长定时时间"><a href="#多个计时器串联增加最长定时时间" class="headerlink" title="多个计时器串联增加最长定时时间"></a>多个计时器串联增加最长定时时间</h2><ol>
<li><img src="/微机原理_img/35.png" style="zoom:80%">
 1. 适用于要求方波或周期性负脉冲的情况。
 2. 对负脉冲宽度没有要求
 3. 单定时器不够
</li>
<li><img src="/微机原理_img/36.png" style="zoom:80%">

</li>
</ol>
<p>3.<img src="/微机原理_img/37.png" style="zoom:80%"></p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
</search>
