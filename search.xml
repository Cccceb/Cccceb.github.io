<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>201412-4</title>
    <url>/2020/03/30/201412-4/</url>
    <content><![CDATA[<h1 id="最优灌溉"><a class="markdownIt-Anchor" href="#最优灌溉"></a> 最优灌溉</h1>
<p><strong>问题描述</strong></p>
<p>雷雷承包了很多片麦田，为了灌溉这些麦田，雷雷在第一个麦田挖了一口很深的水井，所有的麦田都从这口井来引水灌溉。<br />
　　为了灌溉，雷雷需要建立一些水渠，以连接水井和麦田，雷雷也可以利用部分麦田作为“中转站”，利用水渠连接不同的麦田，这样只要一片麦田能被灌溉，则与其连接的麦田也能被灌溉。<br />
　　现在雷雷知道哪些麦田之间可以建设水渠和建设每个水渠所需要的费用（注意不是所有麦田之间都可以建立水渠）。请问灌溉所有麦田最少需要多少费用来修建水渠。</p>
<p><strong>输入格式</strong></p>
<p>输入的第一行包含两个正整数n, m，分别表示麦田的片数和雷雷可以建立的水渠的数量。麦田使用1, 2, 3, ……依次标号。<br />
　　接下来m行，每行包含三个整数ai, bi, ci，表示第ai片麦田与第bi片麦田之间可以建立一条水渠，所需要的费用为ci。</p>
<p><strong>输出格式</strong></p>
<p>输出一行，包含一个整数，表示灌溉所有麦田所需要的最小费用。</p>
<p><strong>样例输入</strong></p>
<p>4 4<br />
1 2 1<br />
2 3 4<br />
2 4 2<br />
3 4 3</p>
<p><strong>样例输出</strong></p>
<p>6</p>
<p><strong>样例说明</strong></p>
<p>建立以下三条水渠：麦田1与麦田2、麦田2与麦田4、麦田4与麦田3。</p>
<p><strong>评测用例规模与约定</strong></p>
<p>前20%的评测用例满足：n≤5。<br />
　　前40%的评测用例满足：n≤20。<br />
　　前60%的评测用例满足：n≤100。<br />
　　所有评测用例都满足：1≤n≤1000，1≤m≤100,000，1≤ci≤10,000。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<p>最小生成树。前几年是真简单啊</p>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	edge(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> w):a(a),b(b),w(w)&#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge&amp; x) &#123;</span><br><span class="line">		<span class="keyword">return</span> w &lt; x.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Tree[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findroot</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Tree[p] == <span class="number">-1</span>) <span class="keyword">return</span> p;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = findroot(Tree[p]);</span><br><span class="line">		Tree[p] = tmp;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">union_</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rp = findroot(p);</span><br><span class="line">	<span class="keyword">int</span> rq = findroot(q);</span><br><span class="line">	<span class="keyword">if</span> (rp != rq) &#123;</span><br><span class="line">		Tree[rq] = rp;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; g;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(Tree, <span class="number">-1</span>, <span class="keyword">sizeof</span>(Tree));</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">int</span> a, b, w;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">		g.push_back(edge(a, b, w));</span><br><span class="line">	&#125;</span><br><span class="line">	sort(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> a = g[i].a;</span><br><span class="line">		<span class="keyword">int</span> b = g[i].b;</span><br><span class="line">		<span class="keyword">int</span> w = g[i].w;</span><br><span class="line">		<span class="keyword">if</span> (union_(a, b)) &#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			ans += w;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cnt == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201312-4</title>
    <url>/2020/03/30/201312-4/</url>
    <content><![CDATA[<h1 id="有趣的数"><a class="markdownIt-Anchor" href="#有趣的数"></a> 有趣的数</h1>
<p><strong>问题描述</strong></p>
<p>我们把一个数称为有趣的，当且仅当：<br />
　　1. 它的数字只包含0, 1, 2, 3，且这四个数字都出现过至少一次。<br />
　　2. 所有的0都出现在所有的1之前，而所有的2都出现在所有的3之前。<br />
　　3. 最高位数字不为0。<br />
　　因此，符合我们定义的最小的有趣的数是2013。除此以外，4位的有趣的数还有两个：2031和2301。<br />
　　请计算恰好有n位的有趣的数的个数。由于答案可能非常大，只需要输出答案除以1000000007的余数。</p>
<p><strong>输入格式</strong></p>
<p>输入只有一行，包括恰好一个正整数n (4 ≤ n ≤ 1000)。</p>
<p><strong>输出格式</strong></p>
<p>输出只有一行，包括恰好n 位的整数中有趣的数的个数除以1000000007的余数。</p>
<p><strong>样例输入</strong></p>
<p>4</p>
<p><strong>样例输出</strong></p>
<p>3</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>
<p>由于规则限制，每一位能选的数都与之前位的状态有关，所以是个dp问题</p>
</li>
<li>
<p>将状态进行分类可得，前i位数字使用情况包括</p>
<ol>
<li>只含2</li>
<li>只含2、0</li>
<li>只含2、3</li>
<li>只含2、0、3</li>
<li>只含2、0、1</li>
<li>含4种数字。</li>
</ol>
</li>
<li>
<p>如果现在要尝试填充第i位，第i位则有6中状态。以状态5为例,设j = i - 1。则第i位的来源包括</p>
<ol>
<li>第j位的状态5扩展，在第i位填1或2</li>
<li>从j位的专题2扩展，在第i位填1</li>
<li>dp[i][4] = (dp[i - 1][1] + dp[i - 1][4] * 2) % Mod;</li>
</ol>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[maxn][<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> Mod = <span class="number">1000000007</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="comment">/*6种状态</span></span><br><span class="line"><span class="comment">	1、只含2</span></span><br><span class="line"><span class="comment">	2、只含2、0</span></span><br><span class="line"><span class="comment">	3、只含2、3</span></span><br><span class="line"><span class="comment">	4、只含2、0、3</span></span><br><span class="line"><span class="comment">	5、只含2、0、1</span></span><br><span class="line"><span class="comment">	6、含4种数字。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">		dp[i][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line">		dp[i][<span class="number">1</span>] = (dp[i - <span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">1</span>] * <span class="number">2</span>) % Mod;   <span class="comment">// 0 2 （状态0第i位只能为2，状态1第i位可以为0或2，所以要乘2，后面以此类推）</span></span><br><span class="line">		dp[i][<span class="number">2</span>] = (dp[i - <span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">2</span>]) % Mod;     <span class="comment">// 2 3</span></span><br><span class="line">		dp[i][<span class="number">3</span>] = (dp[i - <span class="number">1</span>][<span class="number">1</span>] + dp[i - <span class="number">1</span>][<span class="number">2</span>] + dp[i - <span class="number">1</span>][<span class="number">3</span>] * <span class="number">2</span>) % Mod;   <span class="comment">// 0 2 3</span></span><br><span class="line">		dp[i][<span class="number">4</span>] = (dp[i - <span class="number">1</span>][<span class="number">1</span>] + dp[i - <span class="number">1</span>][<span class="number">4</span>] * <span class="number">2</span>) % Mod;  <span class="comment">// 0 1 2</span></span><br><span class="line">		dp[i][<span class="number">5</span>] = (dp[i - <span class="number">1</span>][<span class="number">3</span>] + dp[i - <span class="number">1</span>][<span class="number">4</span>] + dp[i - <span class="number">1</span>][<span class="number">5</span>] * <span class="number">2</span>) % Mod; <span class="comment">// 0 1 2 3</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, dp[n][<span class="number">5</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201409-4</title>
    <url>/2020/03/30/201409-4/</url>
    <content><![CDATA[<h1 id="最优配餐"><a class="markdownIt-Anchor" href="#最优配餐"></a> 最优配餐</h1>
<p><strong>问题描述</strong></p>
<p>栋栋最近开了一家餐饮连锁店，提供外卖服务。随着连锁店越来越多，怎么合理的给客户送餐成为了一个急需解决的问题。<br />
　　栋栋的连锁店所在的区域可以看成是一个n×n的方格图（如下图所示），方格的格点上的位置上可能包含栋栋的分店（绿色标注）或者客户（蓝色标注），有一些格点是不能经过的（红色标注）。<br />
　　方格图中的线表示可以行走的道路，相邻两个格点的距离为1。栋栋要送餐必须走可以行走的道路，而且不能经过红色标注的点。</p>
<p><img src="http://118.190.20.162/RequireFile.do?fid=383qHJjQ" alt="img" /><br />
　　送餐的主要成本体现在路上所花的时间，每一份餐每走一个单位的距离需要花费1块钱。每个客户的需求都可以由栋栋的任意分店配送，每个分店没有配送总量的限制。<br />
　　现在你得到了栋栋的客户的需求，请问在最优的送餐方式下，送这些餐需要花费多大的成本。</p>
<p><strong>输入格式</strong></p>
<p>输入的第一行包含四个整数n, m, k, d，分别表示方格图的大小、栋栋的分店数量、客户的数量，以及不能经过的点的数量。<br />
　　接下来m行，每行两个整数xi, yi，表示栋栋的一个分店在方格图中的横坐标和纵坐标。<br />
　　接下来k行，每行三个整数xi, yi, ci，分别表示每个客户在方格图中的横坐标、纵坐标和订餐的量。（注意，可能有多个客户在方格图中的同一个位置）<br />
　　接下来d行，每行两个整数，分别表示每个不能经过的点的横坐标和纵坐标。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示最优送餐方式下所需要花费的成本。</p>
<p><strong>样例输入</strong></p>
<p>10 2 3 3<br />
1 1<br />
8 8<br />
1 5 1<br />
2 3 3<br />
6 7 2<br />
1 2<br />
2 2<br />
6 8</p>
<p><strong>样例输出</strong></p>
<p>29</p>
<p><strong>评测用例规模与约定</strong></p>
<p>前30%的评测用例满足：1&lt;=n &lt;=20。<br />
　　前60%的评测用例满足：1&lt;=n&lt;=100。<br />
　　所有评测用例都满足：1&lt;=n&lt;=1000，1&lt;=m, k, d&lt;=n^2。可能有多个客户在同一个格点上。每个客户的订餐量不超过1000，每个客户所需要的餐都能被送到。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>把每个分店看作一个起点。对图进行 bfs</li>
<li>由于是无权图，所以先到客户位置的一定是离他最近的分店。</li>
<li><strong>注意 结果可能会超过int的范围</strong></li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	ll <span class="built_in">step</span>;</span><br><span class="line">	node(<span class="keyword">int</span> x, <span class="keyword">int</span> y, ll <span class="built_in">step</span> = <span class="number">0</span>) :x(x), y(y), <span class="built_in">step</span>(<span class="built_in">step</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123; <span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line"><span class="keyword">int</span> goal[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, k, d;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(goal, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;k, &amp;d);</span><br><span class="line">	<span class="keyword">int</span> a, b,w;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">		q.push(node(a, b));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">		goal[a][b] += w;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">		vis[a][b] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		node u = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">if</span> (vis[u.x][u.y]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[u.x][u.y] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> <span class="built_in">step</span> = u.<span class="built_in">step</span>;</span><br><span class="line">		ans += goal[u.x][u.y] * <span class="built_in">step</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> newx = u.x + dx[i];</span><br><span class="line">			<span class="keyword">int</span> newy = u.y + dy[i];</span><br><span class="line">			<span class="keyword">if</span> (vis[newx][newy]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (newx&lt;<span class="number">1</span> || newx&gt;n || newy&lt;<span class="number">1</span> || newy&gt;n) <span class="keyword">continue</span>;</span><br><span class="line">			q.push(node(newx, newy, <span class="built_in">step</span> + <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201609-3</title>
    <url>/2020/03/30/201609-3/</url>
    <content><![CDATA[<h1 id="炉石传说"><a class="markdownIt-Anchor" href="#炉石传说"></a> 炉石传说</h1>
<p>* 玩家会控制一些<strong>角色</strong>，每个角色有自己的<strong>生命值</strong>和<strong>攻击力</strong>。当生命值小于等于 0 时，该角色<strong>死亡</strong>。角色分为<strong>英雄</strong>和<strong>随从</strong>。<br />
　　* 玩家各控制一个英雄，游戏开始时，英雄的生命值为 30，攻击力为 0。当英雄死亡时，游戏结束，英雄未死亡的一方获胜。<br />
　　* 玩家可在游戏过程中召唤随从。棋盘上每方都有 7 个可用于放置随从的空位，从左到右一字排开，被称为<strong>战场</strong>。当随从死亡时，它将被从战场上移除。<br />
　　* 游戏开始后，两位玩家轮流进行操作，每个玩家的连续一组操作称为一个<strong>回合</strong>。<br />
　　* 每个回合中，当前玩家可进行零个或者多个以下操作：<br />
　　1) <strong>召唤随从</strong>：玩家召唤一个随从进入战场，随从具有指定的生命值和攻击力。<br />
　　2) <strong>随从攻击</strong>：玩家控制自己的某个随从攻击对手的英雄或者某个随从。<br />
　　3) <strong>结束回合</strong>：玩家声明自己的当前回合结束，游戏将进入对手的回合。该操作一定是一个回合的最后一个操作。<br />
　　* 当随从攻击时，攻击方和被攻击方会同时对彼此造成等同于自己攻击力的<strong>伤害</strong>。受到伤害的角色的生命值将会减少，数值等同于受到的伤害。例如，随从 <em>X</em> 的生命值为 <em>HX</em>、攻击力为 <em>AX</em>，随从 <em>Y</em> 的生命值为 <em>HY</em>、攻击力为 <em>AY</em>，如果随从 <em>X</em> 攻击随从 <em>Y</em>，则攻击发生后随从 <em>X</em> 的生命值变为 <em>HX</em> - <em>AY</em>，随从 <em>Y</em> 的生命值变为 <em>HY</em> - <em>AX</em>。攻击发生后，角色的生命值可以为负数。<br />
　　本题将给出一个游戏的过程，要求编写程序模拟该游戏过程并输出最后的局面。</p>
<p>输入格式</p>
<p>输入第一行是一个整数 <em>n</em>，表示操作的个数。接下来 <em>n</em> 行，每行描述一个操作，格式如下：<br />
　　<action> <arg1> <arg2> …<br />
　　其中<action>表示操作类型，是一个字符串，共有 3 种：summon表示召唤随从，attack表示随从攻击，end表示结束回合。这 3 种操作的具体格式如下：<br />
　　* summon <position> <attack> <health>：当前玩家在位置<position>召唤一个生命值为<health>、攻击力为<attack>的随从。其中<position>是一个 1 到 7 的整数，表示召唤的随从出现在战场上的位置，原来该位置及右边的随从都将顺次向右移动一位。<br />
　　* attack <attacker> <defender>：当前玩家的角色<attacker>攻击对方的角色 <defender>。<attacker>是 1 到 7 的整数，表示发起攻击的本方随从编号，<defender>是 0 到 7 的整数，表示被攻击的对方角色，0 表示攻击对方英雄，1 到 7 表示攻击对方随从的编号。<br />
　　* end：当前玩家结束本回合。<br />
　　注意：随从的编号会随着游戏的进程发生变化，当召唤一个随从时，玩家指定召唤该随从放入战场的位置，此时，原来该位置及右边的所有随从编号都会增加 1。而当一个随从死亡时，它右边的所有随从编号都会减少 1。任意时刻，战场上的随从总是从1开始连续编号。</p>
<p>输出格式</p>
<p>输出共 5 行。<br />
　　第 1 行包含一个整数，表示这 <em>n</em> 次操作后（以下称为 <em>T</em> 时刻）游戏的胜负结果，1 表示先手玩家获胜，-1 表示后手玩家获胜，0 表示游戏尚未结束，还没有人获胜。<br />
　　第 2 行包含一个整数，表示 <em>T</em> 时刻先手玩家的英雄的生命值。<br />
　　第 3 行包含若干个整数，第一个整数 <em>p</em> 表示 <em>T</em> 时刻先手玩家在战场上存活的随从个数，之后 <em>p</em> 个整数，分别表示这些随从在 <em>T</em> 时刻的生命值（按照从左往右的顺序）。<br />
　　第 4 行和第 5 行与第 2 行和第 3 行类似，只是将玩家从先手玩家换为后手玩家。</p>
<p>样例输入</p>
<p>8<br />
summon 1 3 6<br />
summon 2 4 2<br />
end<br />
summon 1 4 5<br />
summon 1 2 1<br />
attack 1 2<br />
end<br />
attack 1 1</p>
<p>样例输出</p>
<p>0<br />
30<br />
1 2<br />
30<br />
1 2</p>
<p>样例说明</p>
<p>按照样例输入从第 2 行开始逐行的解释如下：<br />
　　1. 先手玩家在位置 1 召唤一个生命值为 6、攻击力为 3 的随从 A，是本方战场上唯一的随从。<br />
　　2. 先手玩家在位置 2 召唤一个生命值为 2、攻击力为 4 的随从 B，出现在随从 A 的右边。<br />
　　3. 先手玩家回合结束。<br />
　　4. 后手玩家在位置 1 召唤一个生命值为 5、攻击力为 4 的随从 C，是本方战场上唯一的随从。<br />
　　5. 后手玩家在位置 1 召唤一个生命值为 1、攻击力为 2 的随从 D，出现在随从 C 的左边。<br />
　　6. 随从 D 攻击随从 B，双方均死亡。<br />
　　7. 后手玩家回合结束。<br />
　　8. 随从 A 攻击随从 C，双方的生命值都降低至 2。</p>
<p>评测用例规模与约定</p>
<p>* 操作的个数0 ≤ <em>n</em> ≤ 1000。<br />
　　* 随从的初始生命值为 1 到 100 的整数，攻击力为 0 到 100 的整数。<br />
　　* 保证所有操作均合法，包括但不限于：<br />
　　1) 召唤随从的位置一定是合法的，即如果当前本方战场上有 <em>m</em> 个随从，则召唤随从的位置一定在 1 到 <em>m</em> + 1 之间，其中 1 表示战场最左边的位置，<em>m</em> + 1 表示战场最右边的位置。<br />
　　2) 当本方战场有 7 个随从时，不会再召唤新的随从。<br />
　　3) 发起攻击和被攻击的角色一定存在，发起攻击的角色攻击力大于 0。<br />
　　4) 一方英雄如果死亡，就不再会有后续操作。<br />
　　* 数据约定：<br />
　　前 20% 的评测用例召唤随从的位置都是战场的最右边。<br />
　　前 40% 的评测用例没有 attack 操作。<br />
　　前 60% 的评测用例不会出现随从死亡的情况。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li><strong>注意 本题虽然说了一方死亡之后不会有操作，但是说话如同放屁</strong></li>
<li>我用一个向量存所有的随从，给每个随从一个编号，战场的局面用编号记录。玩家编号是0和1</li>
<li>召唤操作就是数组的插入，按顺序移动。</li>
<li>攻击后判断是否死亡，死亡的及时删除即可</li>
<li>注意统计存活的随从时，不要将玩家算进去</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sc</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> health;</span><br><span class="line">	<span class="keyword">int</span> attack;</span><br><span class="line">	Sc(<span class="keyword">int</span> health, <span class="keyword">int</span> attack) :health(health), attack(attack) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> numSc[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;Sc&gt; tot;</span><br><span class="line"><span class="keyword">int</span> place[<span class="number">2</span>][<span class="number">8</span>];<span class="comment">//战场</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> no, <span class="keyword">int</span> index, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">7</span>; i &gt; index; i--) &#123;</span><br><span class="line">		place[p][i] = place[p][i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	numSc[p]++;</span><br><span class="line">	place[p][index] = no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">		place[p][i] = place[p][i + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	numSc[p]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">summon</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> attack, <span class="keyword">int</span> health, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="function">Sc <span class="title">sc</span><span class="params">(health, attack)</span></span>;</span><br><span class="line">	tot.push_back(sc);</span><br><span class="line">	insert(tot.<span class="built_in">size</span>() - <span class="number">1</span>, index, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attack</span><span class="params">(<span class="keyword">int</span> attacker, <span class="keyword">int</span> defener, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> id1 = place[p][attacker];</span><br><span class="line">	<span class="keyword">int</span> id2 = place[!p][defener];</span><br><span class="line">	Sc &amp;my = tot[id1];</span><br><span class="line">	Sc &amp;pa = tot[id2];</span><br><span class="line">	my.health -= pa.attack;</span><br><span class="line">	pa.health -= my.attack;</span><br><span class="line">	<span class="keyword">if</span> (defener&amp;&amp;pa.health &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">remove</span>(defener, !p);</span><br><span class="line">	<span class="keyword">if</span> (my.health &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">remove</span>(attacker, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	summon(<span class="number">0</span>, <span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line">	summon(<span class="number">0</span>, <span class="number">0</span>, <span class="number">30</span>, <span class="number">1</span>);</span><br><span class="line">	numSc[<span class="number">0</span>] = numSc[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">string</span> oper;</span><br><span class="line">	<span class="keyword">int</span> p, a, h, p2;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">turn</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; oper;</span><br><span class="line">		<span class="keyword">if</span> (oper[<span class="number">0</span>] == <span class="string">'s'</span>) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; p &gt;&gt; a &gt;&gt; h;</span><br><span class="line">			summon(p, a, h, <span class="built_in">turn</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper[<span class="number">0</span>] == <span class="string">'a'</span>) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; p &gt;&gt; p2;</span><br><span class="line">			attack(p, p2, <span class="built_in">turn</span>);</span><br><span class="line">			<span class="keyword">if</span> (!tot[<span class="number">0</span>].health || !tot[<span class="number">1</span>].health)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (oper[<span class="number">0</span>] == <span class="string">'e'</span>) &#123;</span><br><span class="line">			<span class="built_in">turn</span> = !<span class="built_in">turn</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (tot[<span class="number">0</span>].health &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//1胜利</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (tot[<span class="number">1</span>].health &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"0"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt;= <span class="number">1</span>; p++) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; tot[p].health &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; numSc[p];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numSc[p]; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (place[p][i]) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; tot[place[p][i]].health;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201604-4</title>
    <url>/2020/03/30/201604-4/</url>
    <content><![CDATA[<h1 id="游戏"><a class="markdownIt-Anchor" href="#游戏"></a> 游戏</h1>
<h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2>
<p>小明在玩一个电脑游戏，游戏在一个<em>n</em>×<em>m</em>的方格图上进行，小明控制的角色开始的时候站在第一行第一列，目标是前往第<em>n</em>行第<em>m</em>列。<br />
　方格图上有一些方格是始终安全的，有一些在一段时间是危险的，如果小明控制的角色到达一个方格的时候方格是危险的，则小明输掉了游戏，如果小明的角色到达了第<em>n</em>行第<em>m</em>列，则小明过关。第一行第一列和第<em>n</em>行第<em>m</em>列永远都是安全的。<br />
　每个单位时间，小明的角色必须向上下左右四个方向相邻的方格中的一个移动一格。<br />
　经过很多次尝试，小明掌握了方格图的安全和危险的规律：每一个方格出现危险的时间一定是连续的。并且，小明还掌握了每个方格在哪段时间是危险的。<br />
　现在，小明想知道，自己最快经过几个时间单位可以达到第<em>n</em>行第<em>m</em>列过关。</p>
<h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2>
<p>输入的第一行包含三个整数<em>n</em>, <em>m</em>, <em>t</em>，用一个空格分隔，表示方格图的行数<em>n</em>、列数<em>m</em>，以及方格图中有危险的方格数量。<br />
　接下来<em>t</em>行，每行4个整数<em>r</em>, <em>c</em>, <em>a</em>, <em>b</em>，表示第<em>r</em>行第<em>c</em>列的方格在第<em>a</em>个时刻到第<em>b</em>个时刻之间是危险的，包括<em>a</em>和<em>b</em>。游戏开始时的时刻为0。输入数据保证<em>r</em>和<em>c</em>不同时为1，而且当<em>r</em>为<em>n</em>时<em>c</em>不为<em>m</em>。一个方格只有一段时间是危险的（或者说不会出现两行拥有相同的<em>r</em>和<em>c</em>）。</p>
<h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2>
<p>输出一个整数，表示小明最快经过几个时间单位可以过关。输入数据保证小明一定可以过关。</p>
<h2 id="样例输入"><a class="markdownIt-Anchor" href="#样例输入"></a> 样例输入</h2>
<p>3 3 3<br />
2 1 1 1<br />
1 3 2 10<br />
2 2 2 10</p>
<h2 id="样例输出"><a class="markdownIt-Anchor" href="#样例输出"></a> 样例输出</h2>
<p>6</p>
<h2 id="样例说明"><a class="markdownIt-Anchor" href="#样例说明"></a> 样例说明</h2>
<p>第2行第1列时刻1是危险的，因此第一步必须走到第1行第2列。<br />
　第二步可以走到第1行第1列，第三步走到第2行第1列，后面经过第3行第1列、第3行第2列到达第3行第3列。</p>
<p>评测用例规模与约定</p>
<p>前30%的评测用例满足：0 &lt; <em>n</em>, <em>m</em> ≤ 10，0 ≤ <em>t</em> &lt; 99。<br />
　所有评测用例满足：0 &lt; <em>n</em>, <em>m</em> ≤ 100，0 ≤ <em>t</em> &lt; 9999，1 ≤ <em>r</em> ≤ <em>n</em>，1 ≤ <em>c</em> ≤ <em>m</em>，0 ≤ <em>a</em> ≤ <em>b</em> ≤ 100。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>将边权看作1，则本题是无向图最短路问题</li>
<li>根据测试例可以发现，题中允许重复访问点。但是同一个时间点不能反复经过一个点，因为没有意义。所以vis数组应该为三位</li>
<li>使用bfs来求最短路径即可</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">int dx[] &#x3D; &#123; 1,0,-1,0 &#125;;</span><br><span class="line">int dy[] &#x3D; &#123; 0,-1,0,1 &#125;;</span><br><span class="line">int a[maxn][maxn];</span><br><span class="line">int b[maxn][maxn];</span><br><span class="line">int vis[maxn][maxn][300];</span><br><span class="line">int dis[maxn][maxn];</span><br><span class="line">int change[1000000];</span><br><span class="line">struct node &#123;</span><br><span class="line">	int x, y, t;</span><br><span class="line">	node(int x,int y,int t):x(x),y(y),t(t)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int n, m;</span><br><span class="line">int ans;</span><br><span class="line">void bfs() &#123;</span><br><span class="line">	queue&lt;node&gt; q;</span><br><span class="line">	node beg(1, 1, 0);</span><br><span class="line">	q.push(beg);</span><br><span class="line">	vis[1][1][0] &#x3D; 1;</span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		node f &#x3D; q.front(); q.pop();</span><br><span class="line">		int x &#x3D; f.x;</span><br><span class="line">		int y &#x3D; f.y;</span><br><span class="line">		&#x2F;&#x2F;printf(&quot;%d %d %d\n&quot;, x, y, f.t);</span><br><span class="line">		if (x &#x3D;&#x3D; n &amp;&amp; y &#x3D;&#x3D; m) &#123;</span><br><span class="line">			ans &#x3D; f.t;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">			int newx &#x3D; x + dx[i];</span><br><span class="line">			int newy &#x3D; y + dy[i];</span><br><span class="line">			int newt &#x3D; f.t + 1;</span><br><span class="line">			if (newx&lt;1 || newx&gt;n || newy&lt;1 || newy&gt;m) continue;</span><br><span class="line">			if (vis[newx][newy][f.t + 1]) continue;</span><br><span class="line">			if (newt&lt;a[newx][newy] || newt&gt;b[newx][newy]) &#123;</span><br><span class="line">				vis[newx][newy][newt] &#x3D; 1;</span><br><span class="line">				q.push(node(newx, newy, newt));</span><br><span class="line">			&#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int t;</span><br><span class="line">	int x, y, xa, xb;</span><br><span class="line">	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t);</span><br><span class="line">	memset(a, -1, sizeof(a));</span><br><span class="line">	memset(b, -1, sizeof(b));</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	memset(change, 0, sizeof(change));</span><br><span class="line">	for (int i &#x3D; 0; i &lt; t; i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d%d%d&quot;, &amp;x, &amp;y, &amp;xa, &amp;xb);</span><br><span class="line">		change[xa] &#x3D; change[xb] &#x3D; 1;</span><br><span class="line">		a[x][y] &#x3D; xa;</span><br><span class="line">		b[x][y] &#x3D; xb;</span><br><span class="line">	&#125;</span><br><span class="line">	bfs();</span><br><span class="line">	printf(&quot;%d&quot;, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201403-4</title>
    <url>/2020/03/30/201403-4/</url>
    <content><![CDATA[<h1 id="无线网络"><a class="markdownIt-Anchor" href="#无线网络"></a> 无线网络</h1>
<p><strong>问题描述</strong></p>
<p>目前在一个很大的平面房间里有 n 个无线路由器,每个无线路由器都固定在某个点上。任何两个无线路由器只要距离不超过 r 就能互相建立网络连接。<br />
　　除此以外,另有 m 个可以摆放无线路由器的位置。你可以在这些位置中选择至多 k 个增设新的路由器。<br />
　　你的目标是使得第 1 个路由器和第 2 个路由器之间的网络连接经过尽量少的中转路由器。请问在最优方案下中转路由器的最少个数是多少?</p>
<p><strong>输入格式</strong></p>
<p>第一行包含四个正整数 n,m,k,r。(2 ≤ n ≤ 100,1 ≤ k ≤ m ≤ 100, 1 ≤ r ≤ 108)。<br />
　　接下来 n 行,每行包含两个整数 xi 和 yi,表示一个已经放置好的无线 路由器在 (xi, yi) 点处。输入数据保证第 1 和第 2 个路由器在仅有这 n 个路由器的情况下已经可以互相连接(经过一系列的中转路由器)。<br />
　　接下来 m 行,每行包含两个整数 xi 和 yi,表示 (xi, yi) 点处可以增设 一个路由器。<br />
　　输入中所有的坐标的绝对值不超过 108,保证输入中的坐标各不相同。</p>
<p><strong>输出格式</strong></p>
<p>输出只有一个数,即在指定的位置中增设 k 个路由器后,从第 1 个路 由器到第 2 个路由器最少经过的中转路由器的个数。</p>
<p><strong>样例输入</strong></p>
<p>5 3 1 3<br />
0 0<br />
5 5<br />
0 3<br />
0 5<br />
3 5<br />
3 3<br />
4 4<br />
3 0</p>
<p><strong>样例输出</strong></p>
<p>2</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>将坐标 构建成图，然后bfs即可</li>
<li>构建图时，借助t数组使得i j 间距离和j i间距离，只计算一次</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">bool</span> t[maxn][maxn];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p pair<span class="meta-string">&lt;ll,ll&gt;;</span></span></span><br><span class="line">ll r;</span><br><span class="line">pair&lt;ll, ll&gt; node[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">step</span>[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(<span class="built_in">step</span>, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="built_in">step</span>));</span><br><span class="line">	<span class="keyword">int</span> beg = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> goal = <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="built_in">step</span>[beg] = <span class="number">0</span>;</span><br><span class="line">	q.push(beg);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">if</span> (u == goal) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">step</span>[v] == <span class="number">-1</span> || <span class="built_in">step</span>[v] &gt; <span class="built_in">step</span>[u] + <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="built_in">step</span>[v] = <span class="built_in">step</span>[u] + <span class="number">1</span>;</span><br><span class="line">				q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">step</span>[goal]<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%lld"</span>, &amp;n, &amp;m, &amp;k, &amp;r);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;node[i].first, &amp;node[i].second);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= m + n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;node[i].first, &amp;node[i].second);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (t[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">sqrt</span>((node[i].first - node[j].first)*(node[i].first - node[j].first)</span><br><span class="line">				+ (node[i].second - node[j].second)*(node[i].second - node[j].second)) &gt; r) <span class="keyword">continue</span>;</span><br><span class="line">			g[i].push_back(j);</span><br><span class="line">			g[j].push_back(i);</span><br><span class="line">			t[i][j] = t[j][i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, bfs());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201509-4</title>
    <url>/2020/03/30/201509-4/</url>
    <content><![CDATA[<h1 id="高速公路"><a class="markdownIt-Anchor" href="#高速公路"></a> 高速公路</h1>
<h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2>
<p>某国有<em>n</em>个城市，为了使得城市间的交通更便利，该国国王打算在城市之间修一些高速公路，由于经费限制，国王打算第一阶段先在部分城市之间修一些单向的高速公路。<br />
　　现在，大臣们帮国王拟了一个修高速公路的计划。看了计划后，国王发现，有些城市之间可以通过高速公路直接（不经过其他城市）或间接（经过一个或多个其他城市）到达，而有的却不能。如果城市A可以通过高速公路到达城市B，而且城市B也可以通过高速公路到达城市A，则这两个城市被称为便利城市对。<br />
　　国王想知道，在大臣们给他的计划中，有多少个便利城市对。</p>
<h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2>
<p>输入的第一行包含两个整数<em>n</em>, <em>m</em>，分别表示城市和单向高速公路的数量。<br />
　　接下来<em>m</em>行，每行两个整数<em>a</em>, <em>b</em>，表示城市<em>a</em>有一条单向的高速公路连向城市<em>b</em>。</p>
<h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2>
<p>输出一行，包含一个整数，表示便利城市对的数量。</p>
<h2 id="样例输入"><a class="markdownIt-Anchor" href="#样例输入"></a> 样例输入</h2>
<p>5 5<br />
1 2<br />
2 3<br />
3 4<br />
4 2<br />
3 5</p>
<h2 id="样例输出"><a class="markdownIt-Anchor" href="#样例输出"></a> 样例输出</h2>
<p>3</p>
<h2 id="样例说明"><a class="markdownIt-Anchor" href="#样例说明"></a> 样例说明</h2>
<p><img src="http://118.190.20.162/RequireFile.do?fid=4HG9GgbF" alt="img" /><br />
　　城市间的连接如图所示。有3个便利城市对，它们分别是(2, 3), (2, 4), (3, 4)，请注意(2, 3)和(3, 2)看成同一个便利城市对。</p>
<h2 id="评测用例规模与约定"><a class="markdownIt-Anchor" href="#评测用例规模与约定"></a> 评测用例规模与约定</h2>
<p>前30%的评测用例满足1 ≤ <em>n</em> ≤ 100, 1 ≤ <em>m</em> ≤ 1000；<br />
　　前60%的评测用例满足1 ≤ <em>n</em> ≤ 1000, 1 ≤ <em>m</em> ≤ 10000；<br />
　　所有评测用例满足1 ≤ <em>n</em> ≤ 10000, 1 ≤ <em>m</em> ≤ 100000。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>本题在求强连通分量数，使用Tarjan算法</li>
<li>关于tarjan算法
<ol>
<li>大体思路是在深度搜索的过程中，给遍历到的结点一个编号，用dfn记录。</li>
<li>如果遍历过程中遍历到重复的点，说明出现了环。以low[i]记录第i个节点所在连通分量的根节点(取该连通分量中编号的最小值)</li>
<li>过程中用一个栈来记录形成环前所遍历的所有结点</li>
<li>走了一圈回来，仍能保持自身dfn==low的点即为该连通分量的根</li>
<li>学习用前向链表存图</li>
</ol>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 10000 + 5;</span><br><span class="line">int m, n;</span><br><span class="line">vector&lt;int&gt; g[maxn];</span><br><span class="line">bool instack[maxn];&#x2F;&#x2F;instack[i]表示i是否还在栈里</span><br><span class="line">int dfn[maxn];&#x2F;&#x2F;dfn[]表示是否被dfs过</span><br><span class="line">int low[maxn];&#x2F;&#x2F;该子树中，且仍在栈中的最小时间戳</span><br><span class="line">int clk &#x3D; 0;</span><br><span class="line">int ans &#x3D; 0;</span><br><span class="line">stack&lt;int&gt; s;</span><br><span class="line">void tarjan(int u) &#123;</span><br><span class="line">	low[u] &#x3D; dfn[u] &#x3D; ++clk;</span><br><span class="line">	s.push(u);</span><br><span class="line">	instack[u] &#x3D; 1;</span><br><span class="line">	for (int v : g[u]) &#123;</span><br><span class="line">		if (!dfn[v]) &#123;</span><br><span class="line">			tarjan(v);</span><br><span class="line">			low[u] &#x3D; min(low[u], low[v]);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (instack[v])</span><br><span class="line">			low[u] &#x3D; min(low[u], dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	if (low[u] &#x3D;&#x3D; dfn[u]) &#123;</span><br><span class="line">		int cnt &#x3D; 0;</span><br><span class="line">		while (1)</span><br><span class="line">		&#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			int tp &#x3D; s.top(); s.pop();</span><br><span class="line">			instack[tp] &#x3D; 0;</span><br><span class="line">			if (tp &#x3D;&#x3D; u) break;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cnt &gt; 1) ans +&#x3D; cnt * (cnt - 1) &#x2F; 2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">	int a, b;</span><br><span class="line">	memset(dfn, 0, sizeof(dfn));</span><br><span class="line">	memset(instack, 0, sizeof(instack));</span><br><span class="line">	for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">		g[a].push_back(b);</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; ++i)</span><br><span class="line">		if (!dfn[i])</span><br><span class="line">			tarjan(i);</span><br><span class="line">	printf(&quot;%d&quot;, ans);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前向链表存图"><a class="markdownIt-Anchor" href="#前向链表存图"></a> 前向链表存图</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct EDGE</span><br><span class="line">&#123;</span><br><span class="line">    int to;int next;int from;</span><br><span class="line">&#125;edge[maxn*10],ed[maxn*10];</span><br><span class="line">void add(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    edge[++sum].next&#x3D;head[x];</span><br><span class="line">    edge[sum].from&#x3D;x;</span><br><span class="line">    edge[sum].to&#x3D;y;</span><br><span class="line">    head[x]&#x3D;sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201503-4</title>
    <url>/2020/03/30/201503-4/</url>
    <content><![CDATA[<h1 id="网络延时"><a class="markdownIt-Anchor" href="#网络延时"></a> 网络延时</h1>
<h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2>
<p>给定一个公司的网络，由<em>n</em>台交换机和<em>m</em>台终端电脑组成，交换机与交换机、交换机与电脑之间使用网络连接。交换机按层级设置，编号为1的交换机为根交换机，层级为1。其他的交换机都连接到一台比自己上一层的交换机上，其层级为对应交换机的层级加1。所有的终端电脑都直接连接到交换机上。<br />
　　当信息在电脑、交换机之间传递时，每一步只能通过自己传递到自己所连接的另一台电脑或交换机。请问，电脑与电脑之间传递消息、或者电脑与交换机之间传递消息、或者交换机与交换机之间传递消息最多需要多少步。</p>
<h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2>
<p>输入的第一行包含两个整数<em>n</em>, <em>m</em>，分别表示交换机的台数和终端电脑的台数。<br />
　　第二行包含<em>n</em> - 1个整数，分别表示第2、3、……、<em>n</em>台交换机所连接的比自己上一层的交换机的编号。第<em>i</em>台交换机所连接的上一层的交换机编号一定比自己的编号小。<br />
　　第三行包含<em>m</em>个整数，分别表示第1、2、……、<em>m</em>台终端电脑所连接的交换机的编号。</p>
<h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2>
<p>输出一个整数，表示消息传递最多需要的步数。</p>
<h2 id="样例输入"><a class="markdownIt-Anchor" href="#样例输入"></a> 样例输入</h2>
<p>4 2<br />
1 1 3<br />
2 1</p>
<h2 id="样例输出"><a class="markdownIt-Anchor" href="#样例输出"></a> 样例输出</h2>
<p>4</p>
<h2 id="样例说明"><a class="markdownIt-Anchor" href="#样例说明"></a> 样例说明</h2>
<p>样例的网络连接模式如下，其中圆圈表示交换机，方框表示电脑：<br />
<img src="http://118.190.20.162/RequireFile.do?fid=F9GfBRHL" alt="img" /><br />
　　其中电脑1与交换机4之间的消息传递花费的时间最长，为4个单位时间。</p>
<h2 id="样例输入-2"><a class="markdownIt-Anchor" href="#样例输入-2"></a> 样例输入</h2>
<p>4 4<br />
1 2 2<br />
3 4 4 4</p>
<h2 id="样例输出-2"><a class="markdownIt-Anchor" href="#样例输出-2"></a> 样例输出</h2>
<p>4</p>
<h2 id="样例说明-2"><a class="markdownIt-Anchor" href="#样例说明-2"></a> 样例说明</h2>
<p>样例的网络连接模式如下：<br />
<img src="http://118.190.20.162/RequireFile.do?fid=LYDFDEbt" alt="img" /><br />
　　其中电脑1与电脑4之间的消息传递花费的时间最长，为4个单位时间。</p>
<h2 id="评测用例规模与约定"><a class="markdownIt-Anchor" href="#评测用例规模与约定"></a> 评测用例规模与约定</h2>
<p>前30%的评测用例满足：<em>n</em> ≤ 5, <em>m</em> ≤ 5。<br />
　　前50%的评测用例满足：<em>n</em> ≤ 20, <em>m</em> ≤ 20。<br />
　　前70%的评测用例满足：<em>n</em> ≤ 100, <em>m</em> ≤ 100。<br />
　　所有评测用例都满足：1 ≤ <em>n</em> ≤ 10000，1 ≤ <em>m</em> ≤ 10000。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>本题要计算树中两点间的最大距离，<strong>即图的直径</strong></li>
<li>方法是，从任一点出发，用bfs或者dfs求得离该点最远的点，即为树的一个端点。再从这个端点出发，找离他最远的点，为另一个端点。两点间距离即为图的直径</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000</span> + <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> beg)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	q.push(beg);</span><br><span class="line">	dis[beg] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">		vis[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">			dis[v] = dis[u] + <span class="number">1</span>;</span><br><span class="line">			q.push(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> maxx = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> node = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (dis[i] &gt; maxx) &#123;</span><br><span class="line">			maxx = dis[i];</span><br><span class="line">			node = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">		g[a].push_back(i);</span><br><span class="line">		g[i].push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">		g[a].push_back(n + i);</span><br><span class="line">		g[n + i].push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> n1 = bfs(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> n2 = bfs(n1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, dis[n2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201612-3</title>
    <url>/2020/03/30/201612-3/</url>
    <content><![CDATA[<h1 id="权限查询"><a class="markdownIt-Anchor" href="#权限查询"></a> 权限查询</h1>
<p>问题描述</p>
<p>授权 (authorization) 是各类业务系统不可缺少的组成部分，系统用户通过授权机制获得系统中各个模块的操作权限。<br />
　　本题中的授权机制是这样设计的：每位用户具有若干角色，每种角色具有若干权限。例如，用户 david 具有 manager 角色，manager 角色有 crm:2 权限，则用户 david 具有 crm:2 权限，也就是 crm 类权限的第 2 等级的权限。<br />
　　具体地，用户名和角色名称都是由小写字母组成的字符串，长度不超过 32。权限分为分等级权限和不分等级权限两大类。分等级权限由权限类名和权限等级构成，中间用冒号“:”分隔。其中权限类名也是由小写字母组成的字符串，长度不超过 32。权限等级是一位数字，从 0 到 9，数字越大表示权限等级越高。系统规定如果用户具有某类某一等级的权限，那么他也将自动具有该类更低等级的权限。例如在上面的例子中，除 crm:2 外，用户 david 也具有 crm:1 和 crm:0 权限。不分等级权限在描述权限时只有权限类名，没有权限等级（也没有用于分隔的冒号）。<br />
　　给出系统中用户、角色和权限的描述信息，你的程序需要回答多个关于用户和权限的查询。查询可分为以下几类：<br />
　　* 不分等级权限的查询：如果权限本身是不分等级的，则查询时不指定等级，返回是否具有该权限；<br />
　　* 分等级权限的带等级查询：如果权限本身分等级，查询也带等级，则返回是否具有该类的该等级权限；<br />
　　* 分等级权限的不带等级查询：如果权限本身分等级，查询不带等级，则返回具有该类权限的等级；如果不具有该类的任何等级权限，则返回“否”。</p>
<p>输入格式</p>
<p>输入第一行是一个正整数 <em>p</em>，表示不同的权限类别的数量。紧接着的 <em>p</em> 行被称为 P 段，每行一个字符串，描述各个权限。对于分等级权限，格式为 <category>:<level>，其中 <category> 是权限类名，<level> 是该类权限的最高等级。对于不分等级权限，字符串只包含权限类名。<br />
　　接下来一行是一个正整数 <em>r</em>，表示不同的角色数量。紧接着的 <em>r</em> 行被称为 R 段，每行描述一种角色，格式为<br />
　　<role> <s> &lt;privilege 1&gt; &lt;privilege 2&gt; … <privilege s><br />
　　其中 <role> 是角色名称，<s> 表示该角色具有多少种权限。后面 <s> 个字符串描述该角色具有的权限，格式同 P 段。<br />
　　接下来一行是一个正整数 <em>u</em>，表示用户数量。紧接着的 <em>u</em> 行被称为 U 段，每行描述一个用户，格式为<br />
　　<user> <t> &lt;role 1&gt; &lt;role 2&gt; … <role t><br />
　　其中 <user> 是用户名，<t> 表示该用户具有多少种角色。后面 <t> 个字符串描述该用户具有的角色。<br />
　　接下来一行是一个正整数 <em>q</em>，表示权限查询的数量。紧接着的 <em>q</em> 行被称为 Q 段，每行描述一个授权查询，格式为 <user> <privilege>，表示查询用户 <user> 是否具有 <privilege> 权限。如果查询的权限是分等级权限，则查询中的 <privilege> 可指定等级，表示查询该用户是否具有该等级的权限；也可以不指定等级，表示查询该用户具有该权限的等级。对于不分等级权限，只能查询该用户是否具有该权限，查询中不能指定等级。</p>
<p>输出格式</p>
<p>输出共 <em>q</em> 行，每行为 false、true，或者一个数字。false 表示相应的用户不具有相应的权限，true 表示相应的用户具有相应的权限。对于分等级权限的不带等级查询，如果具有权限，则结果是一个数字，表示该用户具有该权限的（最高）等级。如果用户不存在，或者查询的权限没有定义，则应该返回 false。</p>
<p>样例输入</p>
<p>3<br />
crm:2<br />
git:3<br />
game<br />
4<br />
hr 1 crm:2<br />
it 3 crm:1 git:1 game<br />
dev 2 git:3 game<br />
qa 1 git:2<br />
3<br />
alice 1 hr<br />
bob 2 it qa<br />
charlie 1 dev<br />
9<br />
alice game<br />
alice crm:2<br />
alice git:0<br />
bob git<br />
bob poweroff<br />
charlie game<br />
charlie crm<br />
charlie git:3<br />
malice game</p>
<p>样例输出</p>
<p>false<br />
true<br />
false<br />
2<br />
false<br />
true<br />
false<br />
true<br />
false</p>
<p>样例说明</p>
<p>样例输入描述的场景中，各个用户实际的权限如下：<br />
　　* 用户 alice 具有 crm:2 权限<br />
　　* 用户 bob 具有 crm:1、git:2 和 game 权限<br />
　　* 用户 charlie 具有 git:3 和 game 权限<br />
　　* 用户 malice 未描述，因此不具有任何权限</p>
<p>评测用例规模与约定</p>
<p>评测用例规模：<br />
　　* 1 ≤ <em>p</em>, <em>r</em>, <em>u</em> ≤ 100<br />
　　* 1 ≤ <em>q</em> ≤ 10 000<br />
　　* 每个用户具有的角色数不超过 10，每种角色具有的权限种类不超过 10<br />
　　约定：<br />
　　* 输入保证合法性，包括：<br />
　　1) 角色对应的权限列表（R 段）中的权限都是之前（P 段）出现过的，权限可以重复出现，如果带等级的权限重复出现，以等级最高的为准<br />
　　2) 用户对应的角色列表（U 段）中的角色都是之前（R 段）出现过的，如果多个角色都具有某一分等级权限，以等级最高的为准<br />
　　3) 查询（Q 段）中的用户名和权限类名不保证在之前（U 段和 P 段）出现过<br />
　　* 前 20% 的评测用例只有一种角色<br />
　　* 前 50% 的评测用例权限都是不分等级的，查询也都不带等级</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>
<p>本题的P段其实没用</p>
</li>
<li>
<p>用三个map存，分别是map&lt;string, string&gt; r[maxn];map&lt;string, int&gt; id;map&lt;string, vector&lt;string&gt;&gt; u;</p>
</li>
<li>
<p>其中r[i]标识第i个角色的权限列表，id记录每个角色名对应的编号，u存每个用户的角色列表。<strong>注意角色的权限列表中可能出现重复权限，需要取最高的权限</strong></p>
</li>
<li>
<p><strong>注意 ios::sync_with_stdio(false);后不可与c语言函数混用，包括getchar！！！！</strong></p>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; r[maxn];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; id;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; u;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readp</span><span class="params">(<span class="built_in">string</span> &amp;sp, <span class="built_in">string</span> &amp;level)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> index = sp.<span class="built_in">find</span>(<span class="string">":"</span>);</span><br><span class="line">	<span class="keyword">if</span> (index != <span class="number">-1</span>) &#123;</span><br><span class="line">		level = sp.substr(index + <span class="number">1</span>);</span><br><span class="line">		sp = sp.substr(<span class="number">0</span>, index);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		level = <span class="string">"10"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> user, <span class="built_in">string</span> sp, <span class="built_in">string</span> level)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!u.count(user)) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"false"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">string</span> maxl = <span class="string">"0"</span>;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">false</span>;<span class="comment">//标识是否查道了</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; u[user].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> idx = id[u[user][i]];<span class="comment">//角色编号</span></span><br><span class="line">		<span class="keyword">if</span> (!r[idx].count(sp)) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">string</span> le = r[idx][sp];</span><br><span class="line">			<span class="keyword">if</span> (level != <span class="string">"10"</span>) &#123;<span class="comment">//分等级的按等级查询</span></span><br><span class="line">				<span class="keyword">if</span> (level &lt;= le) &#123;</span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="string">"true"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (le == <span class="string">"10"</span>) &#123;</span><br><span class="line">					<span class="comment">//不分等级的查询</span></span><br><span class="line">					<span class="built_in">cout</span> &lt;&lt; <span class="string">"true"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (le &gt; maxl||maxl==<span class="string">"0"</span>) &#123;</span><br><span class="line">						flag = <span class="literal">true</span>;</span><br><span class="line">						maxl = le;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!flag) <span class="built_in">cout</span> &lt;&lt; <span class="string">"false"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; maxl &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; c;</span><br><span class="line">	<span class="built_in">string</span> sp;</span><br><span class="line">	<span class="built_in">string</span> level;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//读p段</span></span><br><span class="line">		getline(<span class="built_in">cin</span>, sp);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> role;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//读p段</span></span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; role;</span><br><span class="line">		id[role] = ++cnt;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; sp;</span><br><span class="line">			readp(sp, level);</span><br><span class="line">			<span class="keyword">if</span> (r[cnt].count(sp) &amp;&amp; level &lt;= r[cnt][sp])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			r[cnt][sp] = level;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">string</span> user;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//读u段</span></span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; user;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; role;</span><br><span class="line">			u[user].push_back(role);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//读p段</span></span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; user;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; sp;</span><br><span class="line">		readp(sp, level);</span><br><span class="line">		<span class="comment">//cout &lt;&lt; user &lt;&lt; " " &lt;&lt; sp &lt;&lt; " ";</span></span><br><span class="line">		search(user, sp, level);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201609-4</title>
    <url>/2020/03/30/201609-4/</url>
    <content><![CDATA[<h1 id="交通规划"><a class="markdownIt-Anchor" href="#交通规划"></a> 交通规划</h1>
<h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2>
<p>G国国王来中国参观后，被中国的高速铁路深深的震撼，决定为自己的国家也建设一个高速铁路系统。<br />
　建设高速铁路投入非常大，为了节约建设成本，G国国王决定不新建铁路，而是将已有的铁路改造成高速铁路。现在，请你为G国国王提供一个方案，将现有的一部分铁路改造成高速铁路，使得任何两个城市间都可以通过高速铁路到达，而且从所有城市乘坐高速铁路到首都的最短路程和原来一样长。请你告诉G国国王在这些条件下最少要改造多长的铁路。</p>
<h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2>
<p>输入的第一行包含两个整数<em>n</em>, <em>m</em>，分别表示G国城市的数量和城市间铁路的数量。所有的城市由1到<em>n</em>编号，首都为1号。<br />
　接下来<em>m</em>行，每行三个整数<em>a</em>, <em>b</em>, <em>c</em>，表示城市<em>a</em>和城市<em>b</em>之间有一条长度为<em>c</em>的双向铁路。这条铁路不会经过<em>a</em>和<em>b</em>以外的城市。</p>
<h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2>
<p>输出一行，表示在满足条件的情况下最少要改造的铁路长度。</p>
<h2 id="样例输入"><a class="markdownIt-Anchor" href="#样例输入"></a> 样例输入</h2>
<p>4 5<br />
1 2 4<br />
1 3 5<br />
2 3 2<br />
2 4 3<br />
3 4 2</p>
<h2 id="样例输出"><a class="markdownIt-Anchor" href="#样例输出"></a> 样例输出</h2>
<p>11</p>
<h2 id="评测用例规模与约定"><a class="markdownIt-Anchor" href="#评测用例规模与约定"></a> 评测用例规模与约定</h2>
<p>对于20%的评测用例，1 ≤ <em>n</em> ≤ 10，1 ≤ <em>m</em> ≤ 50；<br />
　对于50%的评测用例，1 ≤ <em>n</em> ≤ 100，1 ≤ <em>m</em> ≤ 5000；<br />
　对于80%的评测用例，1 ≤ <em>n</em> ≤ 1000，1 ≤ <em>m</em> ≤ 50000；<br />
　对于100%的评测用例，1 ≤ <em>n</em> ≤ 10000，1 ≤ <em>m</em> ≤ 100000，1 ≤ <em>a</em>, <em>b</em> ≤ n，1 ≤ <em>c</em> ≤ 1000。输入保证每个城市都可以通过铁路达到首都。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>由于要保证最短路径不变，所以考虑使用dij来保证是最短路径</li>
<li>对于相同长度的路径，可以将这一步可能走的最小值记录在cost里</li>
<li>最后统计到所有点的cost的和</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 10000 + 5;</span><br><span class="line">struct edge &#123;</span><br><span class="line">	int to;</span><br><span class="line">	int w;</span><br><span class="line">	edge(int to, int w) :to(to), w(w) &#123;&#125;</span><br><span class="line">	bool operator &lt; (const edge &amp; a)const &#123;</span><br><span class="line">		return w &gt; a.w;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; g[maxn];</span><br><span class="line">int dis[maxn];</span><br><span class="line">int vis[maxn];</span><br><span class="line">int cost[maxn];</span><br><span class="line">void dij() &#123;</span><br><span class="line">	memset(dis, -1, sizeof(dis));</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	memset(cost, -1, sizeof(cost));</span><br><span class="line">	edge beg(1, 0);</span><br><span class="line">	dis[1] &#x3D; 0;</span><br><span class="line">	cost[1] &#x3D; 0;</span><br><span class="line">	priority_queue&lt;edge&gt; pq;</span><br><span class="line">	pq.push(beg);</span><br><span class="line">	while (!pq.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		edge x &#x3D; pq.top(); pq.pop();</span><br><span class="line">		int u &#x3D; x.to;</span><br><span class="line">		if (vis[u]) continue;</span><br><span class="line">		vis[u] &#x3D; 1;</span><br><span class="line">		for (edge y : g[u]) &#123;</span><br><span class="line">			int v &#x3D; y.to;</span><br><span class="line">			if (vis[v]) continue;</span><br><span class="line">			if (dis[v] &#x3D;&#x3D; -1 || dis[v] &gt; dis[u] + y.w)</span><br><span class="line">				dis[v] &#x3D; dis[u] + y.w;</span><br><span class="line">			if (cost[v] &#x3D;&#x3D; -1 || (dis[v] &#x3D;&#x3D; dis[u] + y.w&amp;&amp;cost[v] &gt; y.w))</span><br><span class="line">				cost[v] &#x3D; y.w;</span><br><span class="line">			pq.push(edge(v, dis[v]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">	int a, b, w;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;w);</span><br><span class="line">		g[a].push_back(edge(b, w));</span><br><span class="line">		g[b].push_back(edge(a, w));</span><br><span class="line">	&#125;</span><br><span class="line">	dij();</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">		ans +&#x3D; cost[i];</span><br><span class="line">	printf(&quot;%d&quot;, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201612-4</title>
    <url>/2020/03/30/201612-4/</url>
    <content><![CDATA[<h1 id="压缩编码"><a class="markdownIt-Anchor" href="#压缩编码"></a> 压缩编码</h1>
<h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2>
<p>给定一段文字，已知单词<em>a</em>1, <em>a</em>2, …, <em>an</em>出现的频率分别<em>t</em>1, <em>t</em>2, …, <em>tn</em>。可以用01串给这些单词编码，即将每个单词与一个01串对应，使得任何一个单词的编码（对应的01串）不是另一个单词编码的前缀，这种编码称为前缀码。<br />
　使用前缀码编码一段文字是指将这段文字中的每个单词依次对应到其编码。一段文字经过前缀编码后的长度为：<br />
　<em>L</em>=<em>a</em>1的编码长度×<em>t</em>1+<em>a</em>2的编码长度×<em>t</em>2+…+ <em>an</em>的编码长度×<em>tn</em>。<br />
　定义一个前缀编码为字典序编码，指对于1 ≤ <em>i</em> &lt; <em>n</em>，<em>ai</em>的编码（对应的01串）的字典序在<em>ai</em>+1编码之前，即<em>a</em>1, <em>a</em>2, …, <em>an</em>的编码是按字典序升序排列的。<br />
　例如，文字E A E C D E B C C E C B D B E中， 5个单词A、B、C、D、E出现的频率分别为1, 3, 4, 2,  5，则一种可行的编码方案是A:000, B:001, C:01, D:10,  E:11，对应的编码后的01串为1100011011011001010111010011000111，对应的长度<em>L</em>为3×1+3×3+2×4+2×2+2×5=34。<br />
　在这个例子中，如果使用哈夫曼(Huffman)编码，对应的编码方案是A:000, B:01, C:10, D:001, E:11，虽然最终文字编码后的总长度只有33，但是这个编码不满足字典序编码的性质，比如C的编码的字典序不在D的编码之前。<br />
　在这个例子中，有些人可能会想的另一个字典序编码是A:000, B:001, C:010, D:011, E:1，编码后的文字长度为35。<br />
　请找出一个字典序编码，使得文字经过编码后的长度<em>L</em>最小。在输出时，你只需要输出最小的长度<em>L</em>，而不需要输出具体的方案。在上面的例子中，最小的长度<em>L</em>为34。</p>
<h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2>
<p>输入的第一行包含一个整数<em>n</em>，表示单词的数量。<br />
　第二行包含<em>n</em>个整数，用空格分隔，分别表示<em>a</em>1, <em>a</em>2, …, <em>an</em>出现的频率，即<em>t</em>1, <em>t</em>2, …, <em>tn</em>。请注意<em>a</em>1, <em>a</em>2, …, <em>an</em>具体是什么单词并不影响本题的解，所以没有输入<em>a</em>1, <em>a</em>2, …, <em>an</em>。</p>
<h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2>
<p>输出一个整数，表示文字经过编码后的长度<em>L</em>的最小值。</p>
<h2 id="样例输入"><a class="markdownIt-Anchor" href="#样例输入"></a> 样例输入</h2>
<p>5<br />
1 3 4 2 5</p>
<h2 id="样例输出"><a class="markdownIt-Anchor" href="#样例输出"></a> 样例输出</h2>
<p>34</p>
<h2 id="样例说明"><a class="markdownIt-Anchor" href="#样例说明"></a> 样例说明</h2>
<p>这个样例就是问题描述中的例子。如果你得到了35，说明你算得有问题，请自行检查自己的算法而不要怀疑是样例输出写错了。</p>
<p>评测用例规模与约定</p>
<p>对于30%的评测用例，1 ≤ <em>n</em> ≤ 10，1 ≤ <em>ti</em> ≤ 20；<br />
　对于60%的评测用例，1 ≤ <em>n</em> ≤ 100，1 ≤ <em>ti</em> ≤ 100；<br />
　对于100%的评测用例，1 ≤ <em>n</em> ≤ 1000，1 ≤ <em>ti</em> ≤ 10000。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>首先想到haffman，但是不能保证字典序。因此，不能取权重最小的两堆和并，而是要取相邻的两堆合并。</li>
<li>目标是选取相邻的两堆合在一起使得操作的花费最小，也就是石子问题</li>
<li>石子dp问题
<ol>
<li>用dp[i][j]表示将第i堆和第j堆合并的最小花销。</li>
<li>设存在一个k，有dp[i][k]+dp[k+1][j]使得dp[i][j]取了最小值，那么p[i][j] = k</li>
<li>用sum[i]表示形成第i堆石子的花费</li>
</ol>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">const int inf &#x3D; 0x08080808;</span><br><span class="line">int sum[maxn];</span><br><span class="line">int p[maxn][maxn];</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line">int a[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	sum[0] &#x3D; 0;</span><br><span class="line">	memset(dp, inf, sizeof(dp));</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	sum[0] &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">		dp[i][i] &#x3D; 0;</span><br><span class="line">		p[i][i] &#x3D; i;</span><br><span class="line">		sum[i] &#x3D; sum[i - 1] + a[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int len &#x3D; 2; len &lt;&#x3D; n; len++) &#123;</span><br><span class="line">		for (int i &#x3D; 1; i + len - 1 &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			int j &#x3D; i + len - 1;</span><br><span class="line">			for (int k &#x3D; p[i][j - 1]; k &lt;&#x3D; p[i + 1][j]; ++k) &#123;</span><br><span class="line">				int val &#x3D; dp[i][k] + dp[k+1][j] + sum[j] - sum[i - 1];</span><br><span class="line">				if (dp[i][j] &gt; val) &#123;</span><br><span class="line">					dp[i][j] &#x3D; val;</span><br><span class="line">					p[i][j] &#x3D; k;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;%d&quot;, dp[1][n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201703-3</title>
    <url>/2020/03/30/201703-3/</url>
    <content><![CDATA[<h1 id="markdown"><a class="markdownIt-Anchor" href="#markdown"></a> Markdown</h1>
<p>问题描述</p>
<p>Markdown 是一种很流行的轻量级标记语言（lightweight markup language），广泛用于撰写带格式的文档。例如以下这段文本就是用 Markdown 的语法写成的：　　这些用 Markdown 写成的文本，尽管本身是纯文本格式，然而读者可以很容易地看出它的文档结构。同时，还有很多工具可以自动把 Markdown 文本转换成 HTML 甚至 Word、PDF 等格式，取得更好的排版效果。例如上面这段文本通过转化得到的 HTML 代码如下所示：　　本题要求由你来编写一个 Markdown 的转换工具，完成 Markdown 文本到 HTML 代码的转换工作。简化起见，本题定义的 Markdown 语法规则和转换规则描述如下：　　●区块：区块是文档的顶级结构。本题的 Markdown 语法有 3 种区块格式。在输入中，相邻两个区块之间用一个或多个空行分隔。输出时删除所有分隔区块的空行。　　○段落：一般情况下，连续多行输入构成一个段落。段落的转换规则是在段落的第一行行首插入 <code>&lt;p&gt;</code>，在最后一行行末插入 <code>&lt;/p&gt;</code>。　　○标题：每个标题区块只有一行，由若干个 <code>#</code> 开头，接着一个或多个空格，然后是标题内容，直到行末。<code>#</code> 的个数决定了标题的等级。转换时，<code># Heading</code> 转换为 <code>&lt;h1&gt;Heading&lt;/h1&gt;</code>，<code>## Heading</code> 转换为 <code>&lt;h2&gt;Heading&lt;/h2&gt;</code>，以此类推。标题等级最深为 6。　　○无序列表：无序列表由若干行组成，每行由 <code>*</code> 开头，接着一个或多个空格，然后是列表项目的文字，直到行末。转换时，在最开始插入一行 <code>&lt;ul&gt;</code>，最后插入一行 <code>&lt;/ul&gt;</code>；对于每行，<code>* Item</code> 转换为 <code>&lt;li&gt;Item&lt;/li&gt;</code>。本题中的无序列表只有一层，不会出现缩进的情况。　　●行内：对于区块中的内容，有以下两种行内结构。　　○强调：<code>_Text_</code> 转换为 <code>&lt;em&gt;Text&lt;/em&gt;</code>。强调不会出现嵌套，每行中 <code>_</code> 的个数一定是偶数，且不会连续相邻。注意 <code>_Text_</code> 的前后不一定是空格字符。　　○超级链接：<code>[Text](Link)</code> 转换为 <code>&lt;a href=&quot;Link&quot;&gt;Text&lt;/a&gt;</code>。超级链接和强调可以相互嵌套，但每种格式不会超过一层。</p>
<p>输入格式</p>
<p>输入由若干行组成，表示一个用本题规定的 Markdown 语法撰写的文档。</p>
<p>输出格式</p>
<p>输出由若干行组成，表示输入的 Markdown 文档转换成产生的 HTML 代码。</p>
<p>样例输入</p>
<p># Hello</p>
<p>Hello, world!</p>
<p>样例输出</p>
<p>&lt;h1&gt;Hello&lt;/h1&gt;</p>
<p>&lt;p&gt;Hello, world!&lt;/p&gt;</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>直观的是本题分为两部分，一本分处理区块，一部分处理句内</li>
<li>需要注意的是，连接和强调是可以嵌套的，所以两个功能要分开写到不同的函数中</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">p2</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> &amp;idx, <span class="keyword">bool</span> flag)</span></span>;<span class="comment">//flag为真，则在函数内输出结果，适用于print直接调用的情况</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">p1</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> &amp;idx, <span class="keyword">bool</span> flag)</span> </span>&#123;<span class="comment">//处理强调</span></span><br><span class="line">	<span class="keyword">int</span> len = s.length();</span><br><span class="line">	<span class="built_in">string</span> ans;</span><br><span class="line">	<span class="keyword">while</span> (idx &lt; len)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (s[idx] == <span class="string">'_'</span>) &#123;</span><br><span class="line">			<span class="comment">//强调</span></span><br><span class="line">			ans += <span class="string">"&lt;em&gt;"</span>;</span><br><span class="line">			idx++;</span><br><span class="line">			<span class="keyword">while</span> (s[idx] != <span class="string">'_'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (s[idx] == <span class="string">'['</span>)</span><br><span class="line">					ans += p2(s, idx, <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					ans += s[idx++];</span><br><span class="line">			&#125;</span><br><span class="line">			ans += <span class="string">"&lt;/em&gt;"</span>;</span><br><span class="line">			idx++;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">p2</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> &amp;idx, <span class="keyword">bool</span> flag)</span> </span>&#123;<span class="comment">//处理链接</span></span><br><span class="line">	<span class="keyword">int</span> len = s.length();</span><br><span class="line">	<span class="built_in">string</span> ans;</span><br><span class="line">	<span class="keyword">while</span> (idx &lt; len)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (s[idx] == <span class="string">'['</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = idx + <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">string</span> <span class="built_in">text</span>;</span><br><span class="line">			<span class="keyword">while</span> (s[idx] != <span class="string">']'</span>&amp;&amp;idx &lt; len) &#123;</span><br><span class="line">				<span class="keyword">if</span> (s[idx] == <span class="string">'_'</span>) &#123;</span><br><span class="line">					<span class="built_in">text</span> += s.substr(tmp, idx - tmp);</span><br><span class="line">					<span class="built_in">text</span> += p1(s, idx, <span class="number">0</span>);</span><br><span class="line">					tmp = idx;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> idx++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">text</span> += s.substr(tmp, idx - tmp);</span><br><span class="line">			idx += <span class="number">2</span>;</span><br><span class="line">			tmp = idx;</span><br><span class="line">			<span class="built_in">string</span> link;</span><br><span class="line">			<span class="keyword">while</span> (s[idx] != <span class="string">')'</span>&amp;&amp;idx &lt; len) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (s[idx] == <span class="string">'_'</span>) &#123;</span><br><span class="line">					link += s.substr(tmp, idx - tmp);</span><br><span class="line">					link += p1(s, idx, <span class="number">0</span>);</span><br><span class="line">					tmp = idx;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> idx++;</span><br><span class="line">			&#125;</span><br><span class="line">			link += s.substr(tmp, idx - tmp);</span><br><span class="line">			ans += <span class="string">"&lt;a href=\""</span> + link + <span class="string">"\"&gt;"</span> + <span class="built_in">text</span> + <span class="string">"&lt;/a&gt;"</span>;</span><br><span class="line">			idx++;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = s.length();</span><br><span class="line">	<span class="keyword">while</span> (idx &lt; len)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (s[idx] == <span class="string">'_'</span>) &#123;</span><br><span class="line">			<span class="comment">//强调</span></span><br><span class="line">			p1(s, idx, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s[idx] == <span class="string">'['</span>) &#123;</span><br><span class="line">			p2(s, idx, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; s[idx];</span><br><span class="line">			idx++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="comment">//string line = "[_Text_](Link)";</span></span><br><span class="line">	<span class="comment">//print(line, 0);</span></span><br><span class="line">	<span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">	<span class="keyword">bool</span> p = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">bool</span> ul = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (getline(<span class="built_in">cin</span>, <span class="built_in">line</span>)) &#123;</span><br><span class="line">		<span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> len = <span class="built_in">line</span>.length();</span><br><span class="line">		<span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (p) &#123;</span><br><span class="line">				p = <span class="literal">false</span>;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/p&gt;\n"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (ul) &#123;</span><br><span class="line">				ul = <span class="literal">false</span>;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/ul&gt;\n"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">line</span>[idx] == <span class="string">'#'</span>) &#123;</span><br><span class="line">			<span class="comment">//标题</span></span><br><span class="line">			<span class="keyword">while</span> (<span class="built_in">line</span>[idx] == <span class="string">'#'</span>) idx++;</span><br><span class="line">			<span class="keyword">int</span> level = idx;</span><br><span class="line">			<span class="keyword">while</span> (<span class="built_in">line</span>[idx] == <span class="string">' '</span>&amp;&amp;idx &lt; len)</span><br><span class="line">			&#123;</span><br><span class="line">				idx++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;h"</span> &lt;&lt; level &lt;&lt; <span class="string">"&gt;"</span>;</span><br><span class="line">			<span class="built_in">print</span>(<span class="built_in">line</span>, idx);</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/h"</span> &lt;&lt; level &lt;&lt; <span class="string">"&gt;\n"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">line</span>[idx] == <span class="string">'*'</span>) &#123;</span><br><span class="line">			<span class="comment">//无序列表</span></span><br><span class="line">			idx++;</span><br><span class="line">			<span class="keyword">while</span> (<span class="built_in">line</span>[idx] == <span class="string">' '</span>&amp;&amp;idx &lt; len)</span><br><span class="line">			&#123;</span><br><span class="line">				idx++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (ul == <span class="literal">false</span>) &#123;</span><br><span class="line">				ul = <span class="literal">true</span>;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;ul&gt;\n"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;li&gt;"</span>;</span><br><span class="line">			<span class="built_in">print</span>(<span class="built_in">line</span>, idx);</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/li&gt;\n"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (p == <span class="literal">false</span>) &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;p&gt;"</span>;</span><br><span class="line">				p = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">			<span class="built_in">print</span>(<span class="built_in">line</span>, idx);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/p&gt;\n"</span>;</span><br><span class="line">	<span class="keyword">if</span> (ul)</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;/ul&gt;\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201703-4</title>
    <url>/2020/03/30/201703-4/</url>
    <content><![CDATA[<h1 id="地铁修建"><a class="markdownIt-Anchor" href="#地铁修建"></a> 地铁修建</h1>
<h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2>
<p>A市有n个交通枢纽，其中1号和n号非常重要，为了加强运输能力，A市决定在1号到n号枢纽间修建一条地铁。<br />
　地铁由很多段隧道组成，每段隧道连接两个交通枢纽。经过勘探，有m段隧道作为候选，两个交通枢纽之间最多只有一条候选的隧道，没有隧道两端连接着同一个交通枢纽。<br />
　现在有n家隧道施工的公司，每段候选的隧道只能由一个公司施工，每家公司施工需要的天数一致。而每家公司最多只能修建一条候选隧道。所有公司同时开始施工。<br />
　作为项目负责人，你获得了候选隧道的信息，现在你可以按自己的想法选择一部分隧道进行施工，请问修建整条地铁最少需要多少天。</p>
<h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2>
<p>输入的第一行包含两个整数<em>n</em>, <em>m</em>，用一个空格分隔，分别表示交通枢纽的数量和候选隧道的数量。<br />
　第2行到第<em>m</em>+1行，每行包含三个整数<em>a</em>, <em>b</em>, <em>c</em>，表示枢纽<em>a</em>和枢纽<em>b</em>之间可以修建一条隧道，需要的时间为<em>c</em>天。</p>
<h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2>
<p>输出一个整数，修建整条地铁线路最少需要的天数。</p>
<h2 id="样例输入"><a class="markdownIt-Anchor" href="#样例输入"></a> 样例输入</h2>
<p>6 6<br />
1 2 4<br />
2 3 4<br />
3 6 7<br />
1 4 2<br />
4 5 5<br />
5 6 6</p>
<h2 id="样例输出"><a class="markdownIt-Anchor" href="#样例输出"></a> 样例输出</h2>
<p>6</p>
<h2 id="样例说明"><a class="markdownIt-Anchor" href="#样例说明"></a> 样例说明</h2>
<p>可以修建的线路有两种。<br />
　第一种经过的枢纽依次为1, 2, 3, 6，所需要的时间分别是4, 4, 7，则整条地铁线需要7天修完；<br />
　第二种经过的枢纽依次为1, 4, 5, 6，所需要的时间分别是2, 5, 6，则整条地铁线需要6天修完。<br />
　第二种方案所用的天数更少。</p>
<h2 id="评测用例规模与约定"><a class="markdownIt-Anchor" href="#评测用例规模与约定"></a> 评测用例规模与约定</h2>
<p>对于20%的评测用例，1 ≤ <em>n</em> ≤ 10，1 ≤ <em>m</em> ≤ 20；<br />
　对于40%的评测用例，1 ≤ <em>n</em> ≤ 100，1 ≤ <em>m</em> ≤ 1000；<br />
　对于60%的评测用例，1 ≤ <em>n</em> ≤ 1000，1 ≤ <em>m</em> ≤ 10000，1 ≤ <em>c</em> ≤ 1000；<br />
　对于80%的评测用例，1 ≤ <em>n</em> ≤ 10000，1 ≤ <em>m</em> ≤ 100000；<br />
　对于100%的评测用例，1 ≤ <em>n</em> ≤ 100000，1 ≤ <em>m</em> ≤ 200000，1 ≤ <em>a</em>, <em>b</em> ≤ <em>n</em>，1 ≤ <em>c</em> ≤ 1000000。</p>
<p>所有评测用例保证在所有候选隧道都修通时1号枢纽可以通过隧道到达其他所有枢纽。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>由于需要取最大值最小的情况，所以想到用kruskal算法</li>
<li>之后就是在kruskal中，加入判断，当1和n连通时退出即可</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 200000 + 5;</span><br><span class="line">#define inf  1e6+5</span><br><span class="line">int n, m;</span><br><span class="line">struct edge &#123;</span><br><span class="line">	int a,b;</span><br><span class="line">	int w;</span><br><span class="line">	edge(int a, int b, int w) :a(a), b(b), w(w) &#123;&#125;</span><br><span class="line">	bool operator &lt; (const edge&amp; a) const &#123; return w &lt; a.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; g;</span><br><span class="line">int Tree[maxn];</span><br><span class="line">int findroot(int p) &#123;</span><br><span class="line">	if (Tree[p] &#x3D;&#x3D; -1) return p;</span><br><span class="line">	else &#123;</span><br><span class="line">		int tmp &#x3D; findroot(Tree[p]);</span><br><span class="line">		Tree[p] &#x3D; tmp;</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool union_(int p, int q) &#123;</span><br><span class="line">	int rp &#x3D; findroot(p);</span><br><span class="line">	int rq &#x3D; findroot(q);</span><br><span class="line">	if (rp !&#x3D; rq) &#123;</span><br><span class="line">		Tree[rp] &#x3D; rq;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">	int a, b, w;</span><br><span class="line">	memset(Tree, -1, sizeof(Tree));</span><br><span class="line">	for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;w);</span><br><span class="line">		g.push_back(edge(a, b, w));</span><br><span class="line">	&#125;</span><br><span class="line">	sort(g.begin(), g.end());</span><br><span class="line">	int maxx &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; g.size(); i++) &#123;</span><br><span class="line">		int a &#x3D; g[i].a;</span><br><span class="line">		int b &#x3D; g[i].b;</span><br><span class="line">		int w &#x3D; g[i].w;</span><br><span class="line">		if (union_(a, b)) &#123;</span><br><span class="line">			if (maxx &lt; w) maxx &#x3D; w;</span><br><span class="line">			if (findroot(1) &#x3D;&#x3D; findroot(n)) break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d&quot;, maxx);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201709-4</title>
    <url>/2020/03/30/201709-4/</url>
    <content><![CDATA[<h1 id="通信网络"><a class="markdownIt-Anchor" href="#通信网络"></a> 通信网络</h1>
<h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2>
<p>某国的军队由<em>N</em>个部门组成，为了提高安全性，部门之间建立了<em>M</em>条通路，每条通路只能单向传递信息，即一条从部门<em>a</em>到部门<em>b</em>的通路只能由<em>a</em>向<em>b</em>传递信息。信息可以通过中转的方式进行传递，即如果<em>a</em>能将信息传递到<em>b</em>，<em>b</em>又能将信息传递到<em>c</em>，则<em>a</em>能将信息传递到<em>c</em>。一条信息可能通过多次中转最终到达目的地。<br />
　由于保密工作做得很好，并不是所有部门之间都互相知道彼此的存在。只有当两个部门之间可以直接或间接传递信息时，他们才彼此知道对方的存在。部门之间不会把自己知道哪些部门告诉其他部门。<br />
<img src="http://118.190.20.162/RequireFile.do?fid=yHg9gf9q" alt="img" /><br />
　上图中给了一个4个部门的例子，图中的单向边表示通路。部门1可以将消息发送给所有部门，部门4可以接收所有部门的消息，所以部门1和部门4知道所有其他部门的存在。部门2和部门3之间没有任何方式可以发送消息，所以部门2和部门3互相不知道彼此的存在。<br />
　现在请问，有多少个部门知道所有<em>N</em>个部门的存在。或者说，有多少个部门所知道的部门数量（包括自己）正好是<em>N</em>。</p>
<h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2>
<p>输入的第一行包含两个整数<em>N</em>, <em>M</em>，分别表示部门的数量和单向通路的数量。所有部门从1到<em>N</em>标号。<br />
　接下来<em>M</em>行，每行两个整数<em>a</em>, <em>b</em>，表示部门<em>a</em>到部门<em>b</em>有一条单向通路。</p>
<h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2>
<p>输出一行，包含一个整数，表示答案。</p>
<h2 id="样例输入"><a class="markdownIt-Anchor" href="#样例输入"></a> 样例输入</h2>
<p>4 4<br />
1 2<br />
1 3<br />
2 4<br />
3 4</p>
<h2 id="样例输出"><a class="markdownIt-Anchor" href="#样例输出"></a> 样例输出</h2>
<p>2</p>
<h2 id="样例说明"><a class="markdownIt-Anchor" href="#样例说明"></a> 样例说明</h2>
<p>部门1和部门4知道所有其他部门的存在。</p>
<h2 id="评测用例规模与约定"><a class="markdownIt-Anchor" href="#评测用例规模与约定"></a> 评测用例规模与约定</h2>
<p>对于30%的评测用例，1 ≤ <em>N</em> ≤ 10，1 ≤ <em>M</em> ≤ 20；<br />
　对于60%的评测用例，1 ≤ <em>N</em> ≤ 100，1 ≤ <em>M</em> ≤ 1000；<br />
　对于100%的评测用例，1 ≤ <em>N</em> ≤ 1000，1 ≤ <em>M</em> ≤ 10000。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>分别以每个点为起点进行深度搜索，将能到达的点进行标记</li>
<li>遍历连接矩阵connect[][]</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1100;</span><br><span class="line">vector&lt;int&gt; g[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">bool connect[maxn][maxn];</span><br><span class="line">int n, m;</span><br><span class="line">void init() &#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">	int a, b;</span><br><span class="line">	memset(connect, 0, sizeof(connect));</span><br><span class="line">	for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">		g[a].push_back(b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dfs(int u, int v) &#123;</span><br><span class="line">	if (vis[v]) return;</span><br><span class="line">	vis[v] &#x3D; 1;</span><br><span class="line">	connect[u][v] &#x3D; connect[v][u] &#x3D; 1;</span><br><span class="line">	for (int i : g[v]) &#123;</span><br><span class="line">		dfs(u, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	init();</span><br><span class="line">	int cnt &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		dfs(i, i);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">		int j;</span><br><span class="line">		for (j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">			if (!connect[i][j]) break;</span><br><span class="line">		if (j &#x3D;&#x3D; n + 1) cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d&quot;, cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201803-4</title>
    <url>/2020/03/30/201803-4/</url>
    <content><![CDATA[<h1 id="棋局评估"><a class="markdownIt-Anchor" href="#棋局评估"></a> 棋局评估</h1>
<p><img src="/ccf_img/8.png" alt="" /></p>
<p><img src="/ccf_img/9.png" alt="" /></p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>这是一个博弈论问题，一方想要让得分尽可能高，另一方想要令得分尽可能低（因为是负的）</li>
<li>以dfs(t)表示每一步棋，t=1或2.当t=1时，返回局面的最大值，当t=2时，返回局面的最小值。每下一步，就要判断是否因为走了这一步赢得比赛。如果赢了，则return；否则换手走下一步</li>
<li>注意判断初始情况是否已经结束</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 3;</span><br><span class="line">int g[maxn][maxn];</span><br><span class="line">int anst;</span><br><span class="line">inline int count() &#123;</span><br><span class="line">	int cnt &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; maxn; i++)</span><br><span class="line">		for (int j &#x3D; 0; j &lt; maxn; j++)</span><br><span class="line">			if (g[i][j] &#x3D;&#x3D; 0)</span><br><span class="line">				cnt++;</span><br><span class="line">	return cnt;</span><br><span class="line">&#125;</span><br><span class="line">inline int is_over(int i, int j, int t) &#123;</span><br><span class="line">	bool flag &#x3D; false;</span><br><span class="line">	if (g[0][j] &#x3D;&#x3D; t &amp;&amp; g[1][j] &#x3D;&#x3D; t &amp;&amp; g[2][j] &#x3D;&#x3D; t)</span><br><span class="line">		flag &#x3D; true;</span><br><span class="line">	if (g[i][0] &#x3D;&#x3D; t &amp;&amp; g[i][1] &#x3D;&#x3D; t &amp;&amp; g[i][2] &#x3D;&#x3D; t) flag &#x3D; true;</span><br><span class="line">	if (g[0][0] &#x3D;&#x3D; t &amp;&amp; g[1][1] &#x3D;&#x3D; t &amp;&amp; g[2][2] &#x3D;&#x3D; t) flag &#x3D; true;</span><br><span class="line">	if (g[0][2] &#x3D;&#x3D; t &amp;&amp; g[1][1] &#x3D;&#x3D; t &amp;&amp; g[2][0] &#x3D;&#x3D; t) flag &#x3D; true;</span><br><span class="line">	if (flag)</span><br><span class="line">		if (t &#x3D;&#x3D; 1)</span><br><span class="line">			return count() + 1;</span><br><span class="line">		else</span><br><span class="line">			return -(count() + 1);</span><br><span class="line">	else return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dfs(int t) &#123;</span><br><span class="line">	if (count() &#x3D;&#x3D; 0) return 0;</span><br><span class="line">	int maxx &#x3D; -10, minn &#x3D; 10;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 3; i++)</span><br><span class="line">		for (int j &#x3D; 0; j &lt; 3; j++) &#123;</span><br><span class="line">			if (g[i][j] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				g[i][j] &#x3D; t;</span><br><span class="line">				int w &#x3D; is_over(i, j, t);</span><br><span class="line">				if (w) &#123;&#x2F;&#x2F;因为这一步赢了，则返回</span><br><span class="line">						g[i][j] &#x3D; 0;</span><br><span class="line">						return t &#x3D;&#x3D; 1 ? max(maxx, w) : min(minn, w);</span><br><span class="line">				&#125;</span><br><span class="line">				if (t &#x3D;&#x3D; 1) maxx &#x3D; max(dfs(2), maxx);</span><br><span class="line">				else  minn &#x3D; min(dfs(1), minn);</span><br><span class="line">				g[i][j] &#x3D; 0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	return t &#x3D;&#x3D; 1 ? maxx : minn;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 3; i++)</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 3; j++)</span><br><span class="line">				scanf(&quot;%d&quot;, &amp;g[i][j]);</span><br><span class="line">		bool flag &#x3D; false;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 3; i++)</span><br><span class="line">			if (is_over(i, i, 1)) &#123;</span><br><span class="line">				anst &#x3D; 1;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		if (!flag)</span><br><span class="line">			for (int i &#x3D; 0; i &lt; 3; i++)</span><br><span class="line">				if (is_over(i, i, 2)) &#123;</span><br><span class="line">					anst &#x3D; 2;</span><br><span class="line">					flag &#x3D; true;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">		if (flag) &#123;</span><br><span class="line">			if (anst &#x3D;&#x3D; 2) printf(&quot;-&quot;);</span><br><span class="line">			printf(&quot;%d\n&quot;, count()+1);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			printf(&quot;%d\n&quot;, dfs(1));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201712-4</title>
    <url>/2020/03/30/201712-4/</url>
    <content><![CDATA[<h1 id="行车路线"><a class="markdownIt-Anchor" href="#行车路线"></a> 行车路线</h1>
<h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2>
<p>小明和小芳出去乡村玩，小明负责开车，小芳来导航。<br />
　小芳将可能的道路分为大道和小道。大道比较好走，每走1公里小明会增加1的疲劳度。小道不好走，如果连续走小道，小明的疲劳值会快速增加，连续走<em>s</em>公里小明会增加<em>s</em>2的疲劳度。<br />
　例如：有5个路口，1号路口到2号路口为小道，2号路口到3号路口为小道，3号路口到4号路口为大道，4号路口到5号路口为小道，相邻路口之间的距离都是2公里。如果小明从1号路口到5号路口，则总疲劳值为(2+2)2+2+22=16+2+4=22。<br />
　现在小芳拿到了地图，请帮助她规划一个开车的路线，使得按这个路线开车小明的疲劳度最小。</p>
<h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2>
<p>输入的第一行包含两个整数<em>n</em>, <em>m</em>，分别表示路口的数量和道路的数量。路口由1至<em>n</em>编号，小明需要开车从1号路口到<em>n</em>号路口。<br />
　接下来<em>m</em>行描述道路，每行包含四个整数<em>t</em>, <em>a</em>, <em>b</em>, <em>c</em>，表示一条类型为<em>t</em>，连接<em>a</em>与<em>b</em>两个路口，长度为<em>c</em>公里的双向道路。其中<em>t</em>为0表示大道，<em>t</em>为1表示小道。保证1号路口和<em>n</em>号路口是连通的。</p>
<h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2>
<p>输出一个整数，表示最优路线下小明的疲劳度。</p>
<h2 id="样例输入"><a class="markdownIt-Anchor" href="#样例输入"></a> 样例输入</h2>
<p>6 7<br />
1 1 2 3<br />
1 2 3 2<br />
0 1 3 30<br />
0 3 4 20<br />
0 4 5 30<br />
1 3 5 6<br />
1 5 6 1</p>
<h2 id="样例输出"><a class="markdownIt-Anchor" href="#样例输出"></a> 样例输出</h2>
<p>76</p>
<h2 id="样例说明"><a class="markdownIt-Anchor" href="#样例说明"></a> 样例说明</h2>
<p>从1走小道到2，再走小道到3，疲劳度为52=25；然后从3走大道经过4到达5，疲劳度为20+30=50；最后从5走小道到6，疲劳度为1。总共为76。</p>
<h2 id="数据规模和约定"><a class="markdownIt-Anchor" href="#数据规模和约定"></a> 数据规模和约定</h2>
<p>对于30%的评测用例，1 ≤ <em>n</em> ≤ 8，1 ≤ <em>m</em> ≤ 10；<br />
　对于另外20%的评测用例，不存在小道；<br />
　对于另外20%的评测用例，所有的小道不相交；<br />
　对于所有评测用例，1 ≤ <em>n</em> ≤ 500，1 ≤ <em>m</em> ≤ 105，1 ≤ <em>a</em>, <em>b</em> ≤ <em>n</em>，<em>t</em>是0或1，<em>c</em> ≤ 105。保证答案不超过106。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>基本思路是dij算法，由于小路的存在，花费的计算需要特殊处理</li>
<li>结构体中xw表示目前累计的小路的疲劳值，如果xw不为0
<ol>
<li>如果接下来要走的也是小路，那么(a+b+c)<sup>2</sup> = ((a+b)<sup>2</sup>)<sup>2</sup>+c<sup>2</sup>+2(a+b)c</li>
<li>如果接下来要走的是大路，那么xw=0</li>
</ol>
</li>
<li>由于小路的疲劳值有累积效应，所以相同疲劳值而沿着大路和小路到达同一地点也不是一个情况。因此vis和dis都是二维的</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 500 + 5;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int to;</span><br><span class="line">	int w;</span><br><span class="line">	int t;</span><br><span class="line">	int xw;</span><br><span class="line">	node(int to, int w, int t, int xw &#x3D; 0) :to(to), w(w), t(t), xw(xw) &#123;&#125;</span><br><span class="line">	bool operator &lt; (const node&amp;a) const &#123; return w &gt; a.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt; g[maxn];</span><br><span class="line">int bfs();</span><br><span class="line">int n, m;</span><br><span class="line">int main() &#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">	int t, a, b, w;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d%d%d&quot;, &amp;t, &amp;a, &amp;b, &amp;w);</span><br><span class="line">		g[a].push_back(node(b, w, t));</span><br><span class="line">		g[b].push_back(node(a, w, t));</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d&quot;, bfs());</span><br><span class="line">&#125;</span><br><span class="line">int vis[maxn][2];</span><br><span class="line">int dis[maxn][2];</span><br><span class="line">int bfs() &#123;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	memset(dis, -1, sizeof(dis));</span><br><span class="line">	priority_queue&lt;node&gt; pq;</span><br><span class="line">	node beg(1, 0, 0);</span><br><span class="line">	pq.push(beg);</span><br><span class="line">	dis[1][0] &#x3D; 0;</span><br><span class="line">	dis[1][1] &#x3D; 0;</span><br><span class="line">	while (!pq.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		node u &#x3D; pq.top(); pq.pop();</span><br><span class="line">		int now &#x3D; u.to;</span><br><span class="line">		if (vis[now][u.t]) continue;</span><br><span class="line">		vis[now][u.t] &#x3D; 1;</span><br><span class="line">		for (node i : g[now]) &#123;</span><br><span class="line">			int next &#x3D; i.to;</span><br><span class="line">			int w &#x3D; 0;</span><br><span class="line">			if (!vis[next][i.t]) &#123;</span><br><span class="line">				if (i.t &#x3D;&#x3D; 0)  w &#x3D; i.w;</span><br><span class="line">				else if (i.t &#x3D;&#x3D; 1) &#123;</span><br><span class="line">					if (u.t &#x3D;&#x3D; 1)</span><br><span class="line">						w &#x3D; i.w * i.w + 2 * i.w*sqrt(u.xw);</span><br><span class="line">					else w &#x3D; i.w*i.w;</span><br><span class="line">				&#125;</span><br><span class="line">				if (w &gt; 1e6 || w &lt; 0) continue;</span><br><span class="line">				if (dis[next][i.t] &#x3D;&#x3D; -1 || dis[next][i.t] &gt; dis[now][u.t] + w) &#123;</span><br><span class="line">					dis[next][i.t] &#x3D; dis[now][u.t] + w;</span><br><span class="line">					node nt(next, dis[next][i.t], i.t);</span><br><span class="line">					if (i.t &#x3D;&#x3D; 1)</span><br><span class="line">						nt.xw &#x3D; u.xw + w;</span><br><span class="line">					pq.push(nt);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (dis[n][0] &#x3D;&#x3D; -1) return dis[n][1];</span><br><span class="line">	else if (dis[n][1] &#x3D;&#x3D; -1) return dis[n][0];</span><br><span class="line">	else return min(dis[n][1], dis[n][0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201803-3</title>
    <url>/2020/03/30/201803-3/</url>
    <content><![CDATA[<h1 id="url映射"><a class="markdownIt-Anchor" href="#url映射"></a> URL映射</h1>
<h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2>
<p>URL 映射是诸如 Django、Ruby on Rails 等网页框架 (web frameworks) 的一个重要组件。对于从浏览器发来的 HTTP 请求，URL  映射模块会解析请求中的 URL 地址，并将其分派给相应的处理代码。现在，请你来实现一个简单的 URL 映射功能。<br />
　本题中 URL 映射功能的配置由若干条 URL 映射规则组成。当一个请求到达时，URL 映射功能会将请求中的 URL  地址按照配置的先后顺序逐一与这些规则进行匹配。当遇到第一条完全匹配的规则时，匹配成功，得到匹配的规则以及匹配的参数。若不能匹配任何一条规则，则匹配失败。<br />
　本题输入的 URL 地址是以斜杠 / 作为分隔符的路径，保证以斜杠开头。其他合法字符还包括大小写英文字母、阿拉伯数字、减号 -、下划线 _  和小数点 .。例如，/person/123/ 是一个合法的 URL 地址，而 /person/123? 则不合法（存在不合法的字符问号  ?）。另外，英文字母区分大小写，因此 /case/ 和 /CAse/ 是不同的 URL 地址。<br />
　对于 URL 映射规则，同样是以斜杠开始。除了可以是正常的 URL 地址外，还可以包含参数，有以下 3 种：<br />
　字符串 <str>：用于匹配一段字符串，注意字符串里不能包含斜杠。例如，abcde0123。<br />
　整数 <int>：用于匹配一个不带符号的整数，全部由阿拉伯数字组成。例如，01234。<br />
　路径 <path>：用于匹配一段字符串，字符串可以包含斜杠。例如，abcd/0123/。<br />
　以上 3 种参数都必须匹配非空的字符串。简便起见，题目规定规则中 <str> 和 <int>  前面一定是斜杠，后面要么是斜杠，要么是规则的结束（也就是该参数是规则的最后一部分）。而 <path>  的前面一定是斜杠，后面一定是规则的结束。无论是 URL 地址还是规则，都不会出现连续的斜杠。</p>
<h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2>
<p>输入第一行是两个正整数 <em>n</em> 和 <em>m</em>，分别表示 URL 映射的规则条数和待处理的 URL 地址个数，中间用一个空格字符分隔。<br />
　第 2 行至第 <em>n</em>+1 行按匹配的先后顺序描述 URL 映射规则的配置信息。第 <em>i</em>+1 行包含两个字符串 <em>pi</em> 和 <em>ri</em>，其中 <em>pi</em> 表示 URL 匹配的规则，<em>ri</em> 表示这条 URL 匹配的名字。两个字符串都非空，且不包含空格字符，两者中间用一个空格字符分隔。<br />
　第 <em>n</em>+2 行至第 <em>n</em>+<em>m</em>+1 行描述待处理的 URL 地址。第 <em>n</em>+1+<em>i</em> 行包含一个字符串 <em>qi</em>，表示待处理的 URL 地址，字符串中不包含空格字符。</p>
<h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2>
<p>输入共 <em>m</em> 行，第 <em>i</em> 行表示 <em>qi</em> 的匹配结果。如果匹配成功，设匹配了规则 <em>pj</em> ，则输出对应的 <em>rj</em>。同时，如果规则中有参数，则在同一行内依次输出匹配后的参数。注意整数参数输出时要把前导零去掉。相邻两项之间用一个空格字符分隔。如果匹配失败，则输出 404。</p>
<h2 id="样例输入"><a class="markdownIt-Anchor" href="#样例输入"></a> 样例输入</h2>
<p>5 4<br />
/articles/2003/ special_case_2003<br />
/articles/<int>/ year_archive<br />
/articles/<int>/<int>/ month_archive<br />
/articles/<int>/<int>/<str>/ article_detail<br />
/static/<path> static_serve<br />
/articles/2004/<br />
/articles/1985/09/aloha/<br />
/articles/hello/<br />
/static/js/jquery.js</p>
<h2 id="样例输出"><a class="markdownIt-Anchor" href="#样例输出"></a> 样例输出</h2>
<p>year_archive 2004<br />
article_detail 1985 9 aloha<br />
404<br />
static_serve js/jquery.js</p>
<h2 id="样例说明"><a class="markdownIt-Anchor" href="#样例说明"></a> 样例说明</h2>
<p>对于第 1 个地址 /articles/2004/，无法匹配第 1 条规则，可以匹配第 2 条规则，参数为 2004。<br />
　对于第 2 个地址 /articles/1985/09/aloha/，只能匹配第 4 条规则，参数依次为 1985、9（已经去掉前导零）和 aloha。<br />
　对于第 3 个地址 /articles/hello/，无法匹配任何一条规则。<br />
　对于第 4 个地址 /static/js/jquery.js，可以匹配最后一条规则，参数为 js/jquery.js。</p>
<h2 id="数据规模和约定"><a class="markdownIt-Anchor" href="#数据规模和约定"></a> 数据规模和约定</h2>
<p>1 ≤ <em>n</em> ≤ 100，1 ≤ <em>m</em> ≤ 100。<br />
　所有输入行的长度不超过 100 个字符（不包含换行符）。<br />
　保证输入的规则都是合法的。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<p>疯狂拆分字符串即可</p>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">string get_in;</span><br><span class="line">map&lt;string, vector&lt;string&gt;&gt; dir;</span><br><span class="line">vector&lt;string&gt; cmp;</span><br><span class="line">vector&lt;string&gt; ans;</span><br><span class="line">void turn(string s) &#123;</span><br><span class="line">	int nn &#x3D; s.find(&#39; &#39;);</span><br><span class="line">	string  name &#x3D; s.substr(nn + 1);</span><br><span class="line">	s &#x3D; s.substr(0, nn+1);</span><br><span class="line">	s &#x3D; s.substr(1);</span><br><span class="line">	int pos &#x3D; 0;</span><br><span class="line">	vector&lt;string&gt; tmp;</span><br><span class="line">	while ((pos &#x3D; s.find(&#39;&#x2F;&#39;)) !&#x3D; -1 || (pos &#x3D; s.find(&#39; &#39;)) !&#x3D; -1) &#123;</span><br><span class="line">		if (pos)</span><br><span class="line">			tmp.push_back(s.substr(0, pos));</span><br><span class="line">		s &#x3D; s.substr(pos + 1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dir[name] &#x3D; tmp;</span><br><span class="line">&#125;</span><br><span class="line">void turn_1(string s) &#123;</span><br><span class="line">	if (s[s.length() - 1] !&#x3D; &#39;&#x2F;&#39;)s +&#x3D; &quot;&#x2F;&quot;;</span><br><span class="line">	s &#x3D; s.substr(1);</span><br><span class="line">	int pos &#x3D; 0;</span><br><span class="line">	cmp.clear();</span><br><span class="line">	while ((pos &#x3D; s.find(&#39;&#x2F;&#39;)) !&#x3D; -1) &#123;</span><br><span class="line">		cmp.push_back(s.substr(0, pos));</span><br><span class="line">		s &#x3D; s.substr(pos + 1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool dig(string s) &#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; s.length(); i++) </span><br><span class="line">		if (!isdigit(s[i])) return false;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">bool alp(string s) &#123;</span><br><span class="line">	int len &#x3D; s.length();</span><br><span class="line">	for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (s[i] &gt;&#x3D; &#39;A&#39;&amp;&amp;s[i] &lt;&#x3D; &#39;Z&#39;) continue;</span><br><span class="line">		else if (s[i] &gt;&#x3D; &#39;a&#39;&amp;&amp;s[i] &lt;&#x3D; &#39;z&#39;) continue;</span><br><span class="line">		else if (s[i] &gt;&#x3D; &#39;0&#39;&amp;&amp;s[i] &lt;&#x3D; &#39;9&#39;) continue;</span><br><span class="line">		else if (s[i] &#x3D;&#x3D; &#39;-&#39; || s[i] &#x3D;&#x3D; &#39;.&#39; || s[i] &#x3D;&#x3D; &#39;_&#39;) continue;</span><br><span class="line">		else if (s[i] &#x3D;&#x3D; &#39;&#x2F;&#39;) continue;</span><br><span class="line">		else return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">bool compare() &#123;</span><br><span class="line">	for (auto i &#x3D; dir.begin(); i !&#x3D; dir.end(); i++) &#123;</span><br><span class="line">		int now &#x3D; 0;</span><br><span class="line">		vector&lt;string&gt; c &#x3D; i-&gt;second;</span><br><span class="line">		int j;</span><br><span class="line">		for (j &#x3D; 0; j &lt; c.size() &amp;&amp; now &lt; cmp.size(); j++) &#123;</span><br><span class="line">			if (cmp[now] &#x3D;&#x3D; c[j]) &#123; now++; continue; &#125;</span><br><span class="line">			else if (c[j] &#x3D;&#x3D; &quot;&lt;int&gt;&quot;&amp;&amp;dig(cmp[now])) &#123; ans.push_back(cmp[now]); now++; continue; &#125;</span><br><span class="line">			else if (c[j] &#x3D;&#x3D; &quot;&lt;str&gt;&quot;&amp;&amp;alp(cmp[now])) &#123; ans.push_back(cmp[now]); now++; continue; &#125;</span><br><span class="line">			else if (c[j] &#x3D;&#x3D; &quot;&lt;path&gt;&quot;) &#123;</span><br><span class="line">				if (!now)</span><br><span class="line">					ans.push_back(get_in);</span><br><span class="line"></span><br><span class="line">				else &#123;</span><br><span class="line">					int p &#x3D; get_in.find(cmp[now - 1]);</span><br><span class="line">					ans.push_back(get_in.substr(p + cmp[now - 1].length() + 1));</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				cout &lt;&lt; i-&gt;first;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				now &#x3D; 0;</span><br><span class="line">				ans.clear();</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (now &#x3D;&#x3D; cmp.size() &amp;&amp; j &#x3D;&#x3D; c.size()) &#123;</span><br><span class="line">			cout &lt;&lt; i-&gt;first;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		ans.clear();</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">	int n, m;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	string s;</span><br><span class="line">	getline(cin, s);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		getline(cin, s);</span><br><span class="line">		turn(s);</span><br><span class="line">	&#125;</span><br><span class="line">	for (int j &#x3D; 0; j &lt; m; j++) &#123;</span><br><span class="line">		getline(cin, get_in);</span><br><span class="line">		turn_1(get_in);</span><br><span class="line">		bool flag &#x3D; compare();</span><br><span class="line">		if (!ans.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			for (int k &#x3D; 0; k &lt; ans.size(); k++)</span><br><span class="line">			&#123;</span><br><span class="line">				if (dig(ans[k])) &#123;</span><br><span class="line">					if (ans[k] &#x3D;&#x3D; &quot;0&quot;) &#123;</span><br><span class="line">						cout &lt;&lt; &quot; 0&quot;;</span><br><span class="line">						continue;</span><br><span class="line">					&#125;</span><br><span class="line">					int kk;</span><br><span class="line">					for (kk &#x3D; 0; kk &lt; ans[k].size() &amp;&amp; ans[k][kk] &#x3D;&#x3D; &#39;0&#39;; kk++);</span><br><span class="line">					cout &lt;&lt; &quot; &quot; &lt;&lt; ans[k].substr(kk);</span><br><span class="line">				&#125;</span><br><span class="line">				else cout &lt;&lt; &quot; &quot; &lt;&lt; ans[k];</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">			ans.clear();</span><br><span class="line">		&#125;</span><br><span class="line">		else if (!flag) cout &lt;&lt; &quot;404&quot; &lt;&lt; endl;</span><br><span class="line">		else cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201809-3</title>
    <url>/2020/03/30/201809-3/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>描述：</th>
<th><img src="http://118.190.20.162/RequireFile.do?fid=FH8TRMFr" alt="img" /> <img src="http://118.190.20.162/RequireFile.do?fid=6tGGttRh" alt="img" /> <img src="http://118.190.20.162/RequireFile.do?fid=hfE8g2FF" alt="img" /> <img src="http://118.190.20.162/RequireFile.do?fid=3bTyJMHd" alt="img" /></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>不需要构建这个树，只需要记录每个标签的缩进即可表明父子关系。</li>
<li>所以只需要存每个标签的名称和其属性的名称，注意标签要忽略大小写</li>
<li>查询时，首先匹配最后一级，然后不断向前找。注意同一级的标签只能匹配一个，所以要记录目前匹配的标签缩进。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> cnt;</span><br><span class="line">	<span class="built_in">string</span> label, id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">lower</span><span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">		s[i] = <span class="built_in">tolower</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line">node nodes[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; s, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t = s.<span class="built_in">size</span>() - <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> now = nodes[fa].cnt;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = fa - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; t &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nodes[i].cnt &gt; nodes[i + <span class="number">1</span>].cnt) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (nodes[i].label == s[t] || nodes[i].id == s[t]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nodes[i].cnt &lt; now) &#123;</span><br><span class="line">				now = nodes[i].cnt;</span><br><span class="line">				t--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		getline(<span class="built_in">cin</span>, <span class="built_in">line</span>);</span><br><span class="line">		<span class="keyword">int</span> pos1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">line</span>.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">line</span>[i] == <span class="string">'.'</span>) pos1++;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		node xx;</span><br><span class="line">		<span class="built_in">string</span> label;</span><br><span class="line">		<span class="built_in">string</span> id;</span><br><span class="line">		<span class="keyword">int</span> pos2 = <span class="built_in">line</span>.<span class="built_in">find</span>(<span class="string">'#'</span>);</span><br><span class="line">		<span class="keyword">if</span> (pos2 == <span class="number">-1</span>) &#123;</span><br><span class="line">			label = <span class="built_in">line</span>.substr(pos1);</span><br><span class="line">			id = <span class="string">""</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			label = <span class="built_in">line</span>.substr(pos1, pos2 - pos1 - <span class="number">1</span>);</span><br><span class="line">			id = <span class="built_in">line</span>.substr(pos2);</span><br><span class="line">		&#125;</span><br><span class="line">		lower(label);</span><br><span class="line">		xx.label = label;</span><br><span class="line">		xx.id = id;</span><br><span class="line">		xx.cnt = pos1;</span><br><span class="line">		nodes[i] = xx;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		getline(<span class="built_in">cin</span>, <span class="built_in">line</span>);</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tmp;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">		<span class="keyword">int</span> pos = <span class="built_in">line</span>.<span class="built_in">find</span>(<span class="string">' '</span>);</span><br><span class="line">		<span class="keyword">while</span> (pos != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			tmp.push_back(<span class="built_in">line</span>.substr(<span class="number">0</span>, pos));</span><br><span class="line">			<span class="built_in">line</span> = <span class="built_in">line</span>.substr(pos + <span class="number">1</span>);</span><br><span class="line">			pos = <span class="built_in">line</span>.<span class="built_in">find</span>(<span class="string">' '</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pos == <span class="number">-1</span>) pos = <span class="number">0</span>;</span><br><span class="line">		tmp.push_back(<span class="built_in">line</span>.substr(pos));</span><br><span class="line">		<span class="keyword">if</span> (tmp[<span class="number">0</span>][<span class="number">0</span>] != <span class="string">'#'</span>)</span><br><span class="line">			lower(tmp[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">int</span> len = tmp.<span class="built_in">size</span>();</span><br><span class="line">		<span class="built_in">string</span> now = tmp[len - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nodes[i].label == now || nodes[i].id == now) &#123;</span><br><span class="line">				<span class="keyword">if</span> (search(tmp, i))</span><br><span class="line">					ans.push_back(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans.<span class="built_in">size</span>());</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" %d"</span>, ans[i] + <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201812-4</title>
    <url>/2020/03/30/201812-4/</url>
    <content><![CDATA[<h1 id="数据中心"><a class="markdownIt-Anchor" href="#数据中心"></a> 数据中心</h1>
<p><img src="/ccf_img/7.png" alt="" /></p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<p>典型的 最小生成树问题，采用kruskal算法，保留所有生成边中的最大值</p>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100000 + 5;</span><br><span class="line">struct edge &#123;</span><br><span class="line">	int a,b;</span><br><span class="line">	int w;</span><br><span class="line">	bool operator &lt; (const edge &amp;a) const &#123; return w &lt; a.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">edge g[maxn];</span><br><span class="line">int Tree[maxn];</span><br><span class="line">int ans;</span><br><span class="line">int root(int p) &#123;</span><br><span class="line">	if (Tree[p] &#x3D;&#x3D; -1) return p;</span><br><span class="line">	else &#123;</span><br><span class="line">		int tmp &#x3D; root(Tree[p]);</span><br><span class="line">		Tree[p] &#x3D; tmp;</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">inline bool union_(int p,int q)&#123;</span><br><span class="line">	int rp &#x3D; root(p);</span><br><span class="line">	int rq &#x3D; root(q);</span><br><span class="line">	if (rp &#x3D;&#x3D; rq) return false;</span><br><span class="line">	Tree[rq] &#x3D; rp;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	int beg;</span><br><span class="line">	ans &#x3D; 0;</span><br><span class="line">	memset(Tree, -1, sizeof(Tree));</span><br><span class="line">	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;beg);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, &amp;g[i].a, &amp;g[i].b, &amp;g[i].w);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(g, g + m);</span><br><span class="line">	int bian &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">		int a &#x3D; g[i].a;</span><br><span class="line">		int b &#x3D; g[i].b;</span><br><span class="line">		if (union_(a, b)) &#123;</span><br><span class="line">			bian++;</span><br><span class="line">			if (ans &lt; g[i].w)</span><br><span class="line">				ans &#x3D; g[i].w;</span><br><span class="line">			if (bian &#x3D;&#x3D; n - 1) break;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d&quot;,ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201903-3</title>
    <url>/2020/03/30/201903-3/</url>
    <content><![CDATA[<h1 id="损坏的raid5"><a class="markdownIt-Anchor" href="#损坏的raid5"></a> 损坏的RAID5</h1>
<p><img src="/ccf_img/3.png" alt="" /></p>
<p><img src="/ccf_img/4.png" alt="" /></p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<p>本题的关键在于推出第x行j列的磁盘编号是 disk = (n - k % (n + 1) + y % n + 1) % (n + 1)</p>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int N &#x3D; 1e3 + 7;</span><br><span class="line">const string base &#x3D; &quot;0123456789ABCDEF&quot;;</span><br><span class="line">string dt[N];</span><br><span class="line">int n, s, l, max_k;</span><br><span class="line">int to_int(char ch) &#123;</span><br><span class="line">	if (ch &gt;&#x3D; &#39;0&#39; &amp;&amp; ch &lt;&#x3D; &#39;9&#39;) return ch - &#39;0&#39;;</span><br><span class="line">	else  return ch - &#39;A&#39; + 10;</span><br><span class="line">&#125;</span><br><span class="line">void _xor(string&amp; ans, string str) &#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; str.size(); i++) &#123;</span><br><span class="line">		int x &#x3D; to_int(ans[i]);</span><br><span class="line">		int y &#x3D; to_int(str[i]);</span><br><span class="line">		ans[i] &#x3D; base[(x ^ y)];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">string get_xor(int disk, int _start) &#123;</span><br><span class="line">	string ans(8, &#39;0&#39;);</span><br><span class="line">	for (int i &#x3D; 0; i &lt;&#x3D; n; i++)</span><br><span class="line">		if (i !&#x3D; disk)</span><br><span class="line">			_xor(ans, dt[i].substr(_start, 8));</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ios::sync_with_stdio(false);</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; s &gt;&gt; l;</span><br><span class="line">	n -&#x3D; 1; &#x2F;&#x2F; (n块数据,1块冗余)</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; l; i++) &#123;</span><br><span class="line">		int id;</span><br><span class="line">		cin &gt;&gt; id;</span><br><span class="line">		cin &gt;&gt; dt[id];</span><br><span class="line">		&#x2F;&#x2F; cin&gt;&gt;id&gt;&gt;dt[id]; 这样不知道为啥错误</span><br><span class="line">		max_k &#x3D; dt[id].size() &#x2F; 8 &#x2F; s;</span><br><span class="line">	&#125;</span><br><span class="line">	int m; cin &gt;&gt; m;</span><br><span class="line">	while (m--) &#123;</span><br><span class="line">		int x; cin &gt;&gt; x;</span><br><span class="line">		int y &#x3D; x &#x2F; s;</span><br><span class="line">		int k &#x3D; y &#x2F; n;</span><br><span class="line">		int disk &#x3D; (n - k % (n + 1) + y % n + 1) % (n + 1);</span><br><span class="line">		if (k &gt;&#x3D; max_k) cout &lt;&lt; &quot;-\n&quot;;</span><br><span class="line">		else  if (dt[disk].size() !&#x3D; 0) &#123;</span><br><span class="line">			int _start &#x3D; 8 * (k * s + x % s);</span><br><span class="line">			cout &lt;&lt; dt[disk].substr(_start, 8) &lt;&lt; &quot;\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (dt[disk].size() &#x3D;&#x3D; 0 &amp;&amp; l &#x3D;&#x3D; n) &#123;</span><br><span class="line">			int _start &#x3D; 8 * (k * s + x % s);</span><br><span class="line">			cout &lt;&lt; get_xor(disk, _start) &lt;&lt; &quot;\n&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		else  cout &lt;&lt; &quot;-\n&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201903-4</title>
    <url>/2020/03/30/201903-4/</url>
    <content><![CDATA[<h1 id="消息传递接口"><a class="markdownIt-Anchor" href="#消息传递接口"></a> 消息传递接口</h1>
<p><img src="/ccf_img/5.png" alt="" /></p>
<p><img src="/ccf_img/6.png" alt="" /></p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>直接用队列会超时，所以用数组模拟队列，以beg[i]记录第i个程序下一步应该执行的指令，以over[i]表示第i个程序的最后一条指令。</li>
<li>主要过程是遍历所有程序，依次尝试出队，如果能对应上，才真正出队。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 10000 + 5;</span><br><span class="line">int T, n;</span><br><span class="line">struct opt &#123;</span><br><span class="line">	char op;</span><br><span class="line">	int n;</span><br><span class="line">&#125;;</span><br><span class="line">opt oper[maxn][9];</span><br><span class="line">int beg[maxn];</span><br><span class="line">int over[maxn];</span><br><span class="line">bool front(int id, opt &amp;x) &#123;</span><br><span class="line">	int a &#x3D; beg[id];</span><br><span class="line">	int b &#x3D; over[id];</span><br><span class="line">	if (a &gt;&#x3D; b)  return false;</span><br><span class="line">	x &#x3D; oper[id][a];</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">int vis[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;T, &amp;n);</span><br><span class="line">	getchar();</span><br><span class="line">	string line;</span><br><span class="line">	opt t;</span><br><span class="line"></span><br><span class="line">	int ed;</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			ed &#x3D; 0;</span><br><span class="line">			getline(cin, line);</span><br><span class="line">			stringstream ss(line);</span><br><span class="line">			while (ss &gt;&gt; t.op) &#123;</span><br><span class="line">				ss &gt;&gt; t.n;</span><br><span class="line">				oper[i][ed++] &#x3D; t;</span><br><span class="line">			&#125;</span><br><span class="line">			beg[i] &#x3D; 0;</span><br><span class="line">			over[i] &#x3D; ed;</span><br><span class="line">		&#125;</span><br><span class="line">		bool flag;</span><br><span class="line">		int done &#x3D; 0;</span><br><span class="line">		do</span><br><span class="line">		&#123;</span><br><span class="line">			flag &#x3D; false;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">				opt a, b;</span><br><span class="line">				if (!front(i, a)) &#123;</span><br><span class="line">					if (!vis[i]) &#123;</span><br><span class="line">						done++;</span><br><span class="line">						vis[i] &#x3D; 1;</span><br><span class="line">					&#125;</span><br><span class="line">					continue;</span><br><span class="line">				&#125;</span><br><span class="line">				int x &#x3D; a.n;</span><br><span class="line">				if (!front(x, b)) break;</span><br><span class="line">				if (b.n !&#x3D; i) continue;</span><br><span class="line">				if (a.op &#x3D;&#x3D; b.op) continue;</span><br><span class="line">				beg[i]++;</span><br><span class="line">				beg[x]++;</span><br><span class="line">				flag &#x3D; true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; while (flag);</span><br><span class="line">		if (flag || done &#x3D;&#x3D; n) printf(&quot;0\n&quot;);</span><br><span class="line">		else printf(&quot;1\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201909-5</title>
    <url>/2020/03/30/201909-5/</url>
    <content><![CDATA[<h1 id="城市规划"><a class="markdownIt-Anchor" href="#城市规划"></a> 城市规划</h1>
<table>
<thead>
<tr>
<th>问题描述：</th>
<th><img src="http://118.190.20.162/RequireFile.do?fid=qrnMyreg" alt="img" /> <img src="http://118.190.20.162/RequireFile.do?fid=82geHDaL" alt="img" /></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>有这样一条边，该边将树分割成两部分，其上下方子树的结点间路径需要通过该边。设该边权重为w，上方子树中有重要结点t个，下方子树有重要结点k-t个，则该边对结果的贡献为t*(k-t)*w，其中t*(k-t)表示上下方子树中结点的一种组合。</li>
<li>现用d[u][i]来表示以u结点为根的树中选择i个重要结点的情况下的最短路径和。</li>
<li>d[u][i+j]的状态可能来源于d[u][i]+d[v][j]，其中v是u的子树。可理解为从u的树中选取i个重要节点，从其子树中选择j个结点。则d[u][i + j] = min(1ll*d[u][i + j], 1ll* buf[u][i] + d[v][j] + j * (k - j)*w); <strong>注意此处的1ll转型非常重要，虽然最终结果一定在int内，但是中间的路径和可能超过。包含路径和的问题都应该作此考虑</strong></li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, w;</span><br><span class="line">	edge(<span class="keyword">int</span> to, <span class="keyword">int</span> w) :to(to), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; g[maxn];</span><br><span class="line"><span class="keyword">bool</span> impor[maxn];</span><br><span class="line"><span class="keyword">int</span> num[maxn];<span class="comment">//num[i]表示以i为根的子树中有多少重要结点</span></span><br><span class="line"><span class="keyword">int</span> d[maxn][<span class="number">102</span>], buf[maxn][<span class="number">102</span>];</span><br><span class="line"><span class="keyword">int</span> n, k, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	d[u][<span class="number">0</span>] = <span class="number">0</span>;	<span class="comment">//初始情况下，一个都不选，路径和为0</span></span><br><span class="line">	<span class="keyword">if</span> (impor[u]) &#123;<span class="comment">//如果当前的点是重要结点，那么选择自己的话，路径和仍为0，包含重要节点数为1</span></span><br><span class="line">		d[u][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		num[u] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (edge i : g[u]) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = i.to;</span><br><span class="line">		<span class="keyword">int</span> w = i.w;</span><br><span class="line">		<span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		dp(v, u);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; i++)</span><br><span class="line">			buf[u][i] = d[u][i];</span><br><span class="line">		<span class="keyword">int</span> nu = <span class="built_in">min</span>(k, num[u]);</span><br><span class="line">		<span class="keyword">int</span> nv = <span class="built_in">min</span>(k, num[v]);</span><br><span class="line">		num[u] += num[v];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nu; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= nv &amp;&amp; i + j &lt;= k; j++) &#123;</span><br><span class="line">				d[u][i + j] = <span class="built_in">min</span>(<span class="number">1l</span>l*d[u][i + j], <span class="number">1l</span>l * buf[u][i] + d[v][j] + j * (k - j)*w);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">	<span class="keyword">int</span> a, b, w;</span><br><span class="line">	<span class="built_in">memset</span>(impor, <span class="number">0</span>, <span class="keyword">sizeof</span>(impor));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">		impor[a] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">		g[a].push_back(edge(b, w));</span><br><span class="line">		g[b].push_back(edge(a, w));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">	dp(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, d[<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>Abbott的复仇</title>
    <url>/2020/03/30/Abbott%E7%9A%84%E5%A4%8D%E4%BB%87/</url>
    <content><![CDATA[<h1 id="uva-140-abbott的复仇"><a class="markdownIt-Anchor" href="#uva-140-abbott的复仇"></a> UVA 140 ABBOTT的复仇</h1>
<p>给出一个箭头迷宫，在每个路口处，如果你从某个方向进入了该路口，那么路口的地面上在靠近你的方向会画有一组箭头，它们相对于你的方向可以是向左，向前，向右，或者是它们的任意组合。</p>
<p>当你从某一方向进入某个入口时，下一步只能在这个入口对应方向上标记的箭头中选一个方向继续行进。在起点时，可以选择任何方向。</p>
<p>给出起点和终点，求它们之间的最短路径。</p>
<p>每条边的长度为1</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>对于迷宫问题，一般采用遍历的方法去找出口，本题中采用广度优先遍历。</li>
<li>本题特殊在进入每个交叉点的方向不同，允许他出去的方向也不同。采用map来存储进入方向和出去方向的对应关系，因为一个进入方向对应的出去方向不唯一，所以采用map&lt;int,set<int>&gt; 来存储</li>
</ol>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   #include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;Abbott的复仇in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;Abbott的复仇out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   const int dr[] &#x3D; &#123; -1,0,1,0 &#125;;</span><br><span class="line">   const int dc[] &#x3D; &#123; 0,1,0,-1 &#125;;</span><br><span class="line">&#x2F;&#x2F;注意此处写法，简化代码</span><br><span class="line">   struct Node &#123;</span><br><span class="line">	&#x2F;&#x2F;节点 表示当前位置</span><br><span class="line">   	int r;</span><br><span class="line">   	int c;</span><br><span class="line">   	int dir;</span><br><span class="line">   	Node() &#123;&#125;;</span><br><span class="line">   	Node(int r, int c, int dir &#x3D; -5) :r(r), c(c), dir(dir) &#123;&#125;</span><br><span class="line">   	bool operator&lt;(const Node &amp;a) const &#123;</span><br><span class="line">   		return r &lt; a.r || r &#x3D;&#x3D; a.r&amp;&amp;c &lt; a.c || r &#x3D;&#x3D; a.r&amp;&amp;c &#x3D;&#x3D; a.c&amp;&amp;dir &lt; a.dir;</span><br><span class="line">   	&#125;</span><br><span class="line">   	bool operator!&#x3D;(const Node &amp;a) const &#123;</span><br><span class="line">   		return r !&#x3D; a.r || c !&#x3D; a.c || dir !&#x3D; a.dir;</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   Node sta, over;</span><br><span class="line">   string dirs &#x3D; &quot;NESW&quot;;</span><br><span class="line">   int dir_id(char c) &#123; return dirs.find(c); &#125;</span><br><span class="line">   string turns &#x3D; &quot;FLR&quot;;</span><br><span class="line">   int turn_id(char c) &#123; return turns.find(c); &#125;</span><br><span class="line">   </span><br><span class="line">   map&lt;int, map&lt;int, map&lt;int, set&lt;int&gt;&gt;&gt;&gt; maze;&#x2F;&#x2F;r,c,dir,turn</span><br><span class="line">   set&lt;Node&gt;have_travel;</span><br><span class="line">   map&lt;Node, Node&gt; path;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   Node walk(const Node &amp;u, int turn) &#123;</span><br><span class="line">	&#x2F;&#x2F;※非常nb的简化</span><br><span class="line">   	int dir &#x3D; u.dir;</span><br><span class="line">   	if (turn &#x3D;&#x3D; 1) dir &#x3D; (dir + 3) % 4;&#x2F;&#x2F;顺时针走一步</span><br><span class="line">   	if (turn &#x3D;&#x3D; 2) dir &#x3D; (dir + 1) % 4;&#x2F;&#x2F;逆时针走一个</span><br><span class="line">   	return Node(u.r + dr[dir], u.c + dc[dir], dir);</span><br><span class="line">   &#125;</span><br><span class="line">   int main() &#123;</span><br><span class="line">   	string name;</span><br><span class="line">   	while (getline(cin, name) &amp;&amp; name !&#x3D; &quot;END&quot;)</span><br><span class="line">   	&#123;</span><br><span class="line">   		path.clear();</span><br><span class="line">   		have_travel.clear();</span><br><span class="line">   		maze.clear();</span><br><span class="line">   		cout &lt;&lt; name &lt;&lt; endl &lt;&lt; &quot; &quot;;</span><br><span class="line">   		char ch;</span><br><span class="line">   		cin &gt;&gt; sta.r &gt;&gt; sta.c &gt;&gt; ch &gt;&gt; over.r &gt;&gt; over.c;</span><br><span class="line">   		sta.dir &#x3D; dir_id(ch);</span><br><span class="line">   </span><br><span class="line">   		int a &#x3D; sta.r, b &#x3D; sta.c;</span><br><span class="line">   	</span><br><span class="line">   		sta.r +&#x3D; dr[sta.dir];</span><br><span class="line">   		sta.c +&#x3D; dc[sta.dir];</span><br><span class="line">   		&#x2F;&#x2F;得到入口和出口，并从入口处走了一步</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   		int r, c;</span><br><span class="line">   		while (cin &gt;&gt; r &amp;&amp; r) &#123;</span><br><span class="line">   			cin &gt;&gt; c;</span><br><span class="line">   			string s;</span><br><span class="line">   			while (cin &gt;&gt; s &amp;&amp; s !&#x3D; &quot;*&quot;) &#123;</span><br><span class="line">   </span><br><span class="line">   				for (int i &#x3D; 1; i &lt; s.length(); i++) &#123;</span><br><span class="line">   					maze[r][c][dir_id(s[0])].insert(turn_id(s[i]));</span><br><span class="line">   					&#x2F;存下每个(x,y)处，进入方向和出去方向的对应关系</span><br><span class="line">   				&#125;</span><br><span class="line">   			&#125;</span><br><span class="line">   </span><br><span class="line">   		&#125;</span><br><span class="line">   		getchar();</span><br><span class="line">   		queue&lt;Node&gt; q;</span><br><span class="line">   		vector&lt;Node&gt; ans;</span><br><span class="line">   </span><br><span class="line">   		bool flag &#x3D; false;</span><br><span class="line">   		if (sta.c &#x3D;&#x3D; over.c &amp;&amp; sta.r &#x3D;&#x3D; over.r) &#123;</span><br><span class="line">   			flag &#x3D; true;</span><br><span class="line">   		&#125;</span><br><span class="line">   		else &#123;</span><br><span class="line">   			q.push(sta);</span><br><span class="line">   			ans.push_back(over);</span><br><span class="line">   		&#125;</span><br><span class="line">   		&#x2F;&#x2F;开始广度优先遍历</span><br><span class="line">   		while (!q.empty()) &#123;</span><br><span class="line">   			Node u &#x3D; q.front(); q.pop();</span><br><span class="line">   			if (u.r &#x3D;&#x3D; over.r&amp;&amp;u.c &#x3D;&#x3D; over.c) &#123;</span><br><span class="line">   				over &#x3D; u;</span><br><span class="line">   				flag &#x3D; true;</span><br><span class="line">   				break;</span><br><span class="line">   			&#125;</span><br><span class="line">   			for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">   				&#x2F;&#x2F;四个方向尝试走</span><br><span class="line">   				Node v &#x3D; walk(u, i);</span><br><span class="line">   				if (maze[u.r][u.c][u.dir].count(i)</span><br><span class="line">   					&amp;&amp; !have_travel.count(v)</span><br><span class="line">   					)&#x2F;&#x2F;能走：该进入方向能通向出去的方向；该点没被遍历过</span><br><span class="line">   				&#123;</span><br><span class="line">   					have_travel.insert(v);</span><br><span class="line">   					path[v] &#x3D; u;</span><br><span class="line">   					q.push(v);</span><br><span class="line">   				&#125;</span><br><span class="line">   </span><br><span class="line">   			&#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   		&#125;</span><br><span class="line">   		if (!flag) &#123;</span><br><span class="line">   			cout &lt;&lt; &quot; No Solution Possible&quot; &lt;&lt; endl;</span><br><span class="line">   			continue;</span><br><span class="line">   		&#125;</span><br><span class="line">   		Node u &#x3D; path[over];</span><br><span class="line">   </span><br><span class="line">   		&#x2F;&#x2F;迭代输出路径</span><br><span class="line">   		while (u !&#x3D; sta) &#123;</span><br><span class="line">   			if (!path.count(u)) break;</span><br><span class="line">   			ans.push_back(u);</span><br><span class="line">   			u &#x3D; path[u];</span><br><span class="line">   		&#125;</span><br><span class="line">   		ans.push_back(sta);</span><br><span class="line">   		ans.push_back(Node(a, b, 0));</span><br><span class="line">   </span><br><span class="line">   		for (int i &#x3D; ans.size() - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">   			cout &lt;&lt; &quot; (&quot; &lt;&lt; ans[i].r &lt;&lt; &quot;,&quot; &lt;&lt; ans[i].c &lt;&lt; &quot;)&quot;;</span><br><span class="line">   			if ((ans.size() - i) % 10 &#x3D;&#x3D; 0 &amp;&amp; i) cout &lt;&lt; endl &lt;&lt; &quot; &quot;;</span><br><span class="line">   		&#125;</span><br><span class="line">   		cout &lt;&lt; endl;</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>201909-4</title>
    <url>/2020/03/30/201909-4/</url>
    <content><![CDATA[<h1 id="推荐系统"><a class="markdownIt-Anchor" href="#推荐系统"></a> 推荐系统</h1>
<p><img src="/ccf_img/1.png" alt="" /></p>
<p><img src="/ccf_img/2.png" alt="" /></p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>主要问题在于按照三种属性排序会导致超时，所以疯狂的空间换时间，才勉强通过。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">int limit[55];</span><br><span class="line">#define rint register int</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">	int id;</span><br><span class="line">	int type;</span><br><span class="line">	node(int type, int id) :type(type), id(id) &#123;&#125;</span><br><span class="line">	bool operator &lt; (const node&amp;a) const &#123;</span><br><span class="line">		return type &lt; a.type || type &#x3D;&#x3D; a.type&amp;&amp;id &lt; a.id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;int, set&lt;node&gt;, greater&lt;int&gt;&gt; a;</span><br><span class="line">map&lt;node, int&gt; lab;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;&#x2F;&#x2F;m类商品</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;m, &amp;n);</span><br><span class="line">	int id, score;</span><br><span class="line">	for (rint i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;id, &amp;score);</span><br><span class="line">		for (rint j &#x3D; 0; j &lt; m; j++) &#123;</span><br><span class="line">			a[score].insert(node(j, id));</span><br><span class="line">			lab[node(j, id)] &#x3D; score;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int opnum;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;opnum);</span><br><span class="line">	int op;</span><br><span class="line">	int type, comm;</span><br><span class="line">	for (rint iii &#x3D; 0; iii &lt; opnum; iii++) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;op);</span><br><span class="line"></span><br><span class="line">		if (op &#x3D;&#x3D; 1) &#123;</span><br><span class="line">			</span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;type, &amp;comm, &amp;score);</span><br><span class="line">			a[score].insert(node(type, comm));</span><br><span class="line">			lab[node(type, comm)] &#x3D; score;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (op &#x3D;&#x3D; 2) &#123;</span><br><span class="line">			</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;type, &amp;comm);</span><br><span class="line">			node label &#x3D; node(type, comm);</span><br><span class="line">			score &#x3D; lab[label];</span><br><span class="line">			a[score].erase(node(type, comm));</span><br><span class="line">			lab.erase(label);</span><br><span class="line">			if (a[score].empty()) </span><br><span class="line">				a.erase(score);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		else if (op &#x3D;&#x3D; 3) &#123;</span><br><span class="line">			int maxt;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;maxt);</span><br><span class="line">			for (rint j &#x3D; 0; j &lt; m; ++j)</span><br><span class="line">				scanf(&quot;%d&quot;, &amp;limit[j]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			vector&lt;vector&lt;int&gt;&gt; top(m);</span><br><span class="line">			for (auto i &#x3D; a.begin(); i !&#x3D; a.end() &amp;&amp; maxt &gt; 0; ++i) &#123;</span><br><span class="line">				for (auto j &#x3D; i-&gt;second.begin(); j !&#x3D; i-&gt;second.end() &amp;&amp; maxt &gt; 0; ++j) &#123;</span><br><span class="line">					if (limit[j-&gt;type] &lt;&#x3D; 0)  continue;</span><br><span class="line">					--limit[j-&gt;type];</span><br><span class="line">					top[j-&gt;type].push_back(j-&gt;id);</span><br><span class="line">					--maxt;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			for (rint i &#x3D; 0; i &lt; m; ++i) &#123;</span><br><span class="line">				if (top[i].empty()) printf(&quot;-1\n&quot;);</span><br><span class="line">				else &#123;</span><br><span class="line">					for (rint j &#x3D; 0; j &lt; top[i].size(); ++j) &#123;</span><br><span class="line">						printf(&quot;%d &quot;, top[i][j]);</span><br><span class="line">					&#125;</span><br><span class="line">					printf(&quot;\n&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP认证目录</title>
    <url>/2020/03/30/CSP%E8%AE%A4%E8%AF%81%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="201312-4"><a class="markdownIt-Anchor" href="#201312-4"></a> <a href="/2020/03/30/201312-4/">201312-4</a></h2>
<h2 id="201403-4"><a class="markdownIt-Anchor" href="#201403-4"></a> <a href="/2020/03/30/201403-4/">201403-4</a></h2>
<h2 id="201409-4"><a class="markdownIt-Anchor" href="#201409-4"></a> <a href="/2020/03/30/201409-4/">201409-4</a></h2>
<h2 id="201412-4"><a class="markdownIt-Anchor" href="#201412-4"></a> <a href="/2020/03/30/201412-4/">201412-4</a></h2>
<h2 id="201503-4"><a class="markdownIt-Anchor" href="#201503-4"></a> <a href="/2020/03/30/201503-4/">201503-4</a></h2>
<h2 id="201509-4"><a class="markdownIt-Anchor" href="#201509-4"></a> <a href="/2020/03/30/201509-4/">201509-4</a></h2>
<h2 id="201604-4"><a class="markdownIt-Anchor" href="#201604-4"></a> <a href="/2020/03/30/201604-4/">201604-4</a></h2>
<h2 id="201609-3"><a class="markdownIt-Anchor" href="#201609-3"></a> <a href="/2020/03/30/201609-3/">201609-3</a></h2>
<h2 id="201609-4"><a class="markdownIt-Anchor" href="#201609-4"></a> <a href="/2020/03/30/201609-4/">201609-4</a></h2>
<h2 id="201612-3"><a class="markdownIt-Anchor" href="#201612-3"></a> <a href="/2020/03/30/201612-3/">201612-3</a></h2>
<h2 id="201612-4"><a class="markdownIt-Anchor" href="#201612-4"></a> <a href="/2020/03/30/201612-4/">201612-4</a></h2>
<h2 id="201703-3"><a class="markdownIt-Anchor" href="#201703-3"></a> <a href="/2020/03/30/201703-3/">201703-3</a></h2>
<h2 id="201703-4"><a class="markdownIt-Anchor" href="#201703-4"></a> <a href="/2020/03/30/201703-4/">201703-4</a></h2>
<h2 id="201709-4"><a class="markdownIt-Anchor" href="#201709-4"></a> <a href="/2020/03/30/201709-4/">201709-4</a></h2>
<h2 id="201712-4"><a class="markdownIt-Anchor" href="#201712-4"></a> <a href="/2020/03/30/201712-4/">201712-4</a></h2>
<h2 id="201803-3"><a class="markdownIt-Anchor" href="#201803-3"></a> <a href="/2020/03/30/201803-3/">201803-3</a></h2>
<h2 id="201803-4"><a class="markdownIt-Anchor" href="#201803-4"></a> <a href="/2020/03/30/201803-4/">201803-4</a></h2>
<h2 id="201809-3"><a class="markdownIt-Anchor" href="#201809-3"></a> <a href="/2020/03/30/201809-3/">201809-3</a></h2>
<h2 id="201812-4"><a class="markdownIt-Anchor" href="#201812-4"></a> <a href="/2020/03/30/201812-4/">201812-4</a></h2>
<h2 id="201903-3"><a class="markdownIt-Anchor" href="#201903-3"></a> <a href="/2020/03/30/201903-3/">201903-3</a></h2>
<h2 id="201903-4"><a class="markdownIt-Anchor" href="#201903-4"></a> <a href="/2020/03/30/201903-4/">201903-4</a></h2>
<h2 id="201909-4"><a class="markdownIt-Anchor" href="#201909-4"></a> <a href="/2020/03/30/201909-4/">201909-4</a></h2>
<h2 id="201909-5"><a class="markdownIt-Anchor" href="#201909-5"></a> <a href="/2020/03/30/201909-5/">201909-5</a></h2>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>DB3</title>
    <url>/2020/03/30/DB3/</url>
    <content><![CDATA[<img src="/DB3_img/1.png" style="zoom:80%">
<img src="/DB3_img/2.png" style="zoom:80%">
<img src="/DB3_img/3.png" style="zoom:80%">
<img src="/DB3_img/4.png" style="zoom:80%">
<img src="/DB3_img/5.png" style="zoom:80%">
<h1 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h1>
<h2 id="索引分类"><a class="markdownIt-Anchor" href="#索引分类"></a> 索引分类</h2>
<ol>
<li>
<p>普通索引：索引表的Search-key项中的<strong>每一索引值对应全部取该值的基本表中的记录</strong>。普通索引通过索引<br />
表的指针项指向一个单链表来实现，该链表的每个结点的数<br />
据项指向一条物理记录。</p>
</li>
<li>
<p>单一索引：<strong>每一个索引值只对应唯一的数据记录</strong>。当建立单一索引后，索引项不可以再插入已有值，但可<br />
以插入多个空值，这等同于在建表时对索引列增加一个<br />
UNIQUE约束；同样，当建立单一索引时，如果待索引项存<br />
在相同值则不能建立。</p>
</li>
<li>
<p>聚簇索引：**索引项顺序与表中数据记录的物理顺序一致。**即基本表是按照索引表的Search-key项的排列次序<br />
组织存储的，因此，一个基本表只能建立一个聚簇索引。<br />
注：聚簇索引适应于很少对基本表进行增删操作和对变长列<br />
进行修改操作的情况(?)。</p>
</li>
</ol>
<img src="/DB3_img/6.png" style="zoom:80%">
<img src="/DB3_img/7.png" style="zoom:80%">
<img src="/DB3_img/8.png" style="zoom:80%">
<img src="/DB3_img/9.png" style="zoom:80%">
<img src="/DB3_img/10.png" style="zoom:80%">
<img src="/DB3_img/11.png" style="zoom:80%">
<img src="/DB3_img/12.png" style="zoom:80%">
<img src="/DB3_img/13.png" style="zoom:80%">
<img src="/DB3_img/14.png" style="zoom:80%">
<img src="/DB3_img/15.png" style="zoom:80%">
<img src="/DB3_img/16.png" style="zoom:80%">
<img src="/DB3_img/17.png" style="zoom:80%">
<img src="/DB3_img/18.png" style="zoom:80%">
<img src="/DB3_img/19.png" style="zoom:80%">
<img src="/DB3_img/20.png" style="zoom:80%">
<img src="/DB3_img/21.png" style="zoom:80%">
<img src="/DB3_img/22.png" style="zoom:80%">]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>DB4</title>
    <url>/2020/03/30/DB4/</url>
    <content><![CDATA[<p>数据库的安全性是指保护数据库，防止因用户非法使用数据库造成数据泄漏、更改或破坏。</p>
<p>数据库系统的安全：包括计算机安全和数据库安全。</p>
<h1 id="数据库安全性控制"><a class="markdownIt-Anchor" href="#数据库安全性控制"></a> 数据库安全性控制</h1>
<p>数据库安全性控制的常用方法：用户标识和鉴定、存取控制、视图、审计、数据加密。</p>
<h2 id="用户标识与鉴别"><a class="markdownIt-Anchor" href="#用户标识与鉴别"></a> 用户标识与鉴别</h2>
<ol>
<li>用户标识与鉴别是系统提供的最外层安全保护措施。</li>
<li>基本方法：系统通过一定方式让用户标识自己的身份或名字。</li>
</ol>
<h2 id="自主存取控制-授权与回收"><a class="markdownIt-Anchor" href="#自主存取控制-授权与回收"></a> 自主存取控制-授权与回收</h2>
<h3 id="存取控制机制的功能"><a class="markdownIt-Anchor" href="#存取控制机制的功能"></a> 存取控制机制的功能</h3>
<ol>
<li>存取控制机制的组成：
<ol>
<li>定义存取权限</li>
<li>检查存取权限</li>
</ol>
</li>
<li>用户权限定义和合法权检查机制一起组成了DBMS的安全子系统</li>
</ol>
<h3 id="常用存取控制方法"><a class="markdownIt-Anchor" href="#常用存取控制方法"></a> 常用存取控制方法</h3>
<ol>
<li>自主存取控制：
<ol>
<li>同一用户对不同对象有不同的存储权限。</li>
<li>不同用户对同一对象也有不同的存储权限。</li>
<li>用户还可以将其拥有的存储权限转授给其他用户。</li>
<li><strong>优点</strong>：能够通过授权机制有效的控制其他用户对敏感数据的存取。</li>
<li><strong>缺点</strong>：
<ol>
<li>可能存在数据的无意泄漏。</li>
<li><strong>原因</strong>：这种机制仅仅通过对数据的存取权限来进行安全控制，而对数据本身并无安全性标记。</li>
<li><strong>解决</strong>：对系统控制下的所有主客体实施强制存取控制。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="授权与回收"><a class="markdownIt-Anchor" href="#授权与回收"></a> 授权与回收</h3>
<ol>
<li>授权语法：见本</li>
<li>注意：
<ol>
<li>DBA拥有数据库操作的所有权限，可以将权限赋给其他用户。</li>
<li>建立数据库对象的的用户称为该对象的属主，他拥有该对象的所有操作权限。</li>
<li>授权给全体用户是PUBLIC。</li>
<li>若指定了WITH GRANT OPTION子句，则获得某种权限的用户还可以把这种权限再授予别的用户。否则，不能传播该权限。</li>
</ol>
</li>
<li>回收权限REVOKE</li>
<li>授权图：用户拥有授权当且仅当存在从授权图的根到代表该用户的节点的路径。</li>
</ol>
<h3 id="数据库角色被命名的一组与数据库操作相关的权限"><a class="markdownIt-Anchor" href="#数据库角色被命名的一组与数据库操作相关的权限"></a> 数据库角色：被命名的一组与数据库操作相关的权限。</h3>
<ol>
<li>数据库角色
<ol>
<li>角色是权限的集合。</li>
<li>可以为一组具有相同权限的用户创建一个角色。</li>
</ol>
</li>
<li>相关语法：见本</li>
</ol>
<h3 id="权限总结"><a class="markdownIt-Anchor" href="#权限总结"></a> 权限总结</h3>
<ol>
<li>DBA拥有对数据库中所有对象的所有权限，并可以根据应用<br />
的需要将不同的权限授予不同的用户；</li>
<li>用户对自己建立的基本表和视图拥有全部的操作权限，并且<br />
可以用GRANT语句把其中某些权限授予其他用户；</li>
<li>被授权的用户如果有“继续授权”的许可，还可以把获得的<br />
权限再授予其他用户；</li>
<li>所有授予出去的权力在必要时可以用REVOKE语句收回；</li>
<li>使用角色管理数据库可以简化授权的过程；</li>
</ol>
<h2 id="强制存取控制"><a class="markdownIt-Anchor" href="#强制存取控制"></a> 强制存取控制</h2>
<ol>
<li>强制存取控制：
<ol>
<li>对每一个数据对象都标以一定的密级。</li>
<li>对每一个用户都授予一个级别的许可证。</li>
<li>对于任意的一个对象，只有具有合法许可证的用户才能存取。</li>
</ol>
</li>
<li>敏感度标记： 绝密（Top Secret、机密（Secret）、秘密（Confidential）、公开（Public）。</li>
<li>强制存取控制规则
<ol>
<li>仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体。</li>
<li>仅当主体的许可证级别等于客体的密级时，主体才能写相应客体。</li>
</ol>
</li>
<li>DAC和MAC关系
<ol>
<li>二者共同构成DBMS的安全机制。因为较高安全性级别提供的安全保护要包含较低级别的所有保护。</li>
<li>安全性检查，要先进行DAC检查，通过DAC检查的数据对象再由系统进行MAC检查，只有都通过的才能进行存取。</li>
</ol>
</li>
</ol>
<h2 id="视图机制"><a class="markdownIt-Anchor" href="#视图机制"></a> 视图机制</h2>
<ol>
<li>视图机制与授权机制配合使用共同提供安全性。
<ol>
<li>先用视图屏蔽掉一部分保密数据。</li>
<li>再进一步在视图上定义存取权限。</li>
<li>间接实现了支持存取谓词的用户权限定义。</li>
</ol>
</li>
</ol>
<h2 id="审计"><a class="markdownIt-Anchor" href="#审计"></a> 审计</h2>
<ol>
<li>审计：将用户对数据库的所有操作记录在上面。</li>
</ol>
<h2 id="数据加密"><a class="markdownIt-Anchor" href="#数据加密"></a> 数据加密</h2>
<ol>
<li>加密方法
<ol>
<li>替换方法：将明文中的每一个字符都转换维密文中的每一个字符。</li>
<li>置换方法：将明文的字符按不同的顺序重新排列。</li>
<li>混合方法</li>
</ol>
</li>
</ol>
<h1 id="统计数据库安全性"><a class="markdownIt-Anchor" href="#统计数据库安全性"></a> 统计数据库安全性</h1>
<ol>
<li>统计数据库的特点
<ol>
<li>允许用户查询聚集类型信息。</li>
<li>不允许查询单个记录信息。</li>
</ol>
</li>
<li>统计数据库的问题
<ol>
<li>隐藏的信息通道</li>
<li>从合法的查询中推导出不合法的信息。</li>
</ol>
</li>
<li>统计数据库的规则
<ol>
<li>任何查询至少要涉及N（N足够大）个以上的记录。</li>
<li>任意两个查询的相交数据项不能超过M个。</li>
<li>任一用户的查询次数不能超过1+(N-2)/M次。</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>DB5</title>
    <url>/2020/03/30/DB5/</url>
    <content><![CDATA[<ol>
<li>数据库的完整性：防止数据库中出现不合语义数据。</li>
<li>完整性控制机制：
<ol>
<li>完整性约束条件定义机制。</li>
<li>完整性检查机</li>
<li>违约处理.</li>
</ol>
</li>
<li>关系型数据库的三类完整性约束：实体完整性、参照完整性、用户定义完整性。</li>
</ol>
<h1 id="实体完整性"><a class="markdownIt-Anchor" href="#实体完整性"></a> 实体完整性</h1>
<ol>
<li>实体完整性定义：
<ol>
<li>单属性构成的码：定义为列级或表级约束条件。</li>
<li>多属性构成的码：只可定义为表级约束条件。</li>
</ol>
</li>
<li>实体完整性检查和违约处理
<ol>
<li>检查主码是否唯一；检查主码的各个属性值是否为空。</li>
</ol>
</li>
</ol>
<h1 id="参照完整性"><a class="markdownIt-Anchor" href="#参照完整性"></a> 参照完整性</h1>
<ol>
<li>参照完整性定义：若属性F是基本关系R的外码，它与基本关系S的码Ks相对应，则对于R中每个元组在F上的取值必须满足
<ol>
<li>参照关系R和被参照关系S不一定是不同的关系。</li>
<li>外码中若有多个属性，若其一为NULL，则需全NULL。</li>
</ol>
</li>
</ol>
<h1 id="用户定义完整性"><a class="markdownIt-Anchor" href="#用户定义完整性"></a> 用户定义完整性</h1>
<ol>
<li>使用CHECK见本。</li>
</ol>
<h1 id="完整性约束命名子句"><a class="markdownIt-Anchor" href="#完整性约束命名子句"></a> 完整性约束命名子句</h1>
<ol>
<li>CONSTRAINT</li>
</ol>
<h1 id="域中的完整性限制"><a class="markdownIt-Anchor" href="#域中的完整性限制"></a> 域中的完整性限制</h1>
<p>CREATE DOMAIN,DOMAIN相当于一个自定义的数据类型。</p>
<h1 id="触发器"><a class="markdownIt-Anchor" href="#触发器"></a> 触发器</h1>
<ol>
<li>
<p>触发器：用户定义在关系表上的 一类由事件驱动的特殊存储过程</p>
 <img src="/DB5_img/1.png" style="zoom:80%">
</li>
<li>
<p>注</p>
<ol>
<li>触发器可以在触发事件之前或之后执行。</li>
<li>触发事件为INSERT/DELETE/UPDATE（SELECT不触发）</li>
<li>分为行级触发器和语句级触发器</li>
<li>触发器被激活时，执行触发体。</li>
<li>同一个表上的触发器，先执行BEFORE触发器，再执行SQL，再执行AFTER触发器。</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>Gergovia的酒交易</title>
    <url>/2020/03/30/Gergovia%E7%9A%84%E9%85%92%E4%BA%A4%E6%98%93/</url>
    <content><![CDATA[<h1 id="uva-11054-gergovia的酒交易"><a class="markdownIt-Anchor" href="#uva-11054-gergovia的酒交易"></a> UVA 11054 Gergovia的酒交易</h1>
<p>n个等距村庄,每个村庄要么买酒要么卖酒,把k个单位的酒运到相邻村庄去需要k*酒的需求的劳动力,问最少需要多少劳动力才能满足所有的村庄的要求。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>等价转换，考虑最左侧的村庄
<ol>
<li>假设a1&gt;0,则需要从其他的村庄向1运a1单位的酒，等价于只有村庄2-n，且第二个村庄的需求量为a1+a2。</li>
<li>再举个例子，如果a1&lt;0,a2&gt;0，由于供需平衡，a1的酒需要全部运出，耗费劳动力|a1|，剩余的酒从a2运走需要||a1|-a2| = a1+a2</li>
</ol>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">		long long ans &#x3D; 0, left &#x3D; 0, a;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%lld&quot;, &amp;a);</span><br><span class="line">			ans +&#x3D; abs(left);</span><br><span class="line">			left +&#x3D; a;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>DB6</title>
    <url>/2020/03/30/DB6/</url>
    <content><![CDATA[<h1 id="关系模式设计引论"><a class="markdownIt-Anchor" href="#关系模式设计引论"></a> 关系模式设计引论</h1>
<h2 id="关系的外延和内涵"><a class="markdownIt-Anchor" href="#关系的外延和内涵"></a> 关系的外延和内涵</h2>
<ol>
<li>外延：关系模型的值，即关系模型中的数据，是动态的。</li>
<li>内涵：对关系、属性、域的定义和说明，即关系模型的定义。</li>
</ol>
<img src="/DB6_img/1.png" style="zoom:1%">
<h2 id="关系模式的存储异常"><a class="markdownIt-Anchor" href="#关系模式的存储异常"></a> 关系模式的存储异常</h2>
<p>例：描述学校的数据库有如下属性：<br />
学生的学号(Sno)、所在系(Sdept)、系主任姓名(Mname)、课<br />
程名(Cname)、成绩(Grade)<br />
关系模式 ：Student ( Sno, Sdept, Mname, Cname, Grade )</p>
<ol>
<li><strong>问题</strong>：
<ol>
<li>数据冗余太大：每行中系主任的姓名重复出现。</li>
<li>更新异常：假如某系更换主任后，系统必须修改所有与该系相关的学生。</li>
<li>插入异常：对于新成立的系中没有学生，也无法把主任存入。</li>
<li>删除异常：如果某个系学生全部毕业了，删除学生的同时，该系主任也没了。</li>
</ol>
</li>
<li><strong>原因</strong> 由于各属性见存在某些依赖关系</li>
<li><strong>解决</strong> 通过模式分解，分解为两个关系模式Student ( Sno, Sdept,<br />
Cname, Grade )和 Dept ( Sdept, Mname ) 。</li>
</ol>
<h1 id="规范化函数依赖"><a class="markdownIt-Anchor" href="#规范化函数依赖"></a> 规范化（函数依赖)</h1>
<h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2>
<ol>
<li>
<p>函数依赖（简称FD）<br />
设R(U)是一个属性集U上的关系模式，X和Y是U的<br />
子集。若对于R(U)的任意一个可能的关系r，r中不可能<br />
存在两个元组在X上的属性值相等， 而在Y上的属性值<br />
不等， 则称 “X函数确定Y” 或 “Y函数依赖于X”，记<br />
作X→Y(读作X决定Y)。X称为这个函数依赖的决定因素<br />
(Determinant)。</p>
<p>说明：<br />
1. 函数依赖不是指关系模式R的某个或某些关系实例满足的约束条件，而是指R的所有关系实例均要满足的约束条件。<br />
2. 函数依赖是语义范畴的概念。只能根据数据的语义来确定函数依赖。</p>
</li>
<li>
<p><strong>几种特殊的函数依赖</strong>：在关系模式R(U)中，对于U的子集X和Y</p>
<ol>
<li>若X→Y，但Y X，则称X→Y是非平凡的函数依赖</li>
<li>若X→Y，但Y  X，则称X→Y是平凡的函数依赖</li>
<li>若X→Y，并且Y→X，则记为X←→Y。(X与Y相互决定)</li>
<li>若Y不函数依赖于X，则记为X→Y。</li>
</ol>
</li>
<li>
<p><strong>完全函数依赖</strong><br />
<img src="/DB6_img/2.png" style="zoom:1%"></p>
</li>
<li>
<p><strong>传递函数依赖</strong></p>
 <img src="/DB6_img/3.png" style="zoom:1%">
</li>
<li>
<p><strong>候选码</strong>：设K为关系模式R&lt;U, F&gt;中的属性或属性组。若K F<br />
U，则K称为R的一个候选码(Candidate Key)。若关系模<br />
式R有多个候选码，则选定其中的一个做为主码(Primary<br />
key)。候选码常常简称为码。</p>
<ol>
<li>具有决定性和最小性。</li>
<li>主属性：<strong>所有</strong>候选码中出现的属性。</li>
<li>非主属性：不出现在候选码中的属性</li>
<li>全码：由关系模式的所有属性构成的码</li>
</ol>
</li>
<li>
<p><strong>外码</strong>：关系模式 R 中属性或属性组X 并非R 的码，但 X 是<br />
另一个关系模式的码，则称 X 是R 的外部码(Foreign key),<br />
也称外码。</p>
</li>
</ol>
<h2 id="范式"><a class="markdownIt-Anchor" href="#范式"></a> 范式</h2>
<h3 id="一范式-保持列的原子性"><a class="markdownIt-Anchor" href="#一范式-保持列的原子性"></a> 一范式 保持列的原子性</h3>
<p>如果一个关系模式R的所有属性都是不可分的基本<br />
数据项，则称关系R为第一范式的关系模式(First Normal<br />
Form)，简称关系R属于一范式，记为：R∈1NF。</p>
<h3 id="二范式-非主属性都完全依赖于-r-的候选键"><a class="markdownIt-Anchor" href="#二范式-非主属性都完全依赖于-r-的候选键"></a> 二范式 非主属性都完全依赖于 R 的候选键</h3>
<p>若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于R的码，则R∈2NF。</p>
<h3 id="三范式-非主属性都不传递依赖于-r-的候选键"><a class="markdownIt-Anchor" href="#三范式-非主属性都不传递依赖于-r-的候选键"></a> 三范式 非主属性都不传递依赖于 R 的候选键</h3>
<p>属性不依赖于其它非主属性</p>
<p>主键和其他列有直接的联系</p>
<img src="/DB6_img/4.png" style="zoom:1%">
<ol>
<li>
<p>定理：满足三范式，则一定满足二范式。</p>
</li>
<li>
<p>证明</p>
 <img src="/DB6_img/5.png" style="zoom:1%">
</li>
</ol>
<h3 id="bcnf-每个属性都不传递依赖于-r-的候选键"><a class="markdownIt-Anchor" href="#bcnf-每个属性都不传递依赖于-r-的候选键"></a> BCNF 每个属性都不传递依赖于 R 的候选键</h3>
<p>所有函数依赖关系中，自变量皆含有一个及以上的候选键</p>
<ol>
<li>
<p>多值依赖：在关系模式R(X,Y,Z)的任一关系r中，如果存在元组t,s，使得t[X]=s[X]，就必然存在元组w,v∈r，使得w[X]=v[X]=t[X] (=s[X])，而 w[Y]=t[Y], w[Z]=s[Z]; v[Y]=s[Y], v[Z]=t[Z] (即交换t,s在Y上的分量构成的新元组必然在r中)，则称Y多值依赖于X，记为X→→Y。 这里，X、Y、Z是U的子集，且Z=U-X-Y。</p>
<p><strong>没有直接联系、但有间接的联系称为多值依赖的数据依赖。</strong></p>
<ol>
<li>类似于部分函数依赖，但是函数就是唯一确定的关系；多值依赖却不能唯一确定。</li>
<li>若X→→Y，而Z＝Ф，则称X→→Y为平凡的多值依赖，否则称X→→Y为非平凡的多值依赖。</li>
<li><strong>非平凡函数依赖，平凡多值依赖比较好</strong></li>
</ol>
</li>
<li>
<p>多值依赖的性质：</p>
 <img src="/DB6_img/6.png" style="zoom:1%">
 <img src="/DB6_img/7.png" style="zoom:1%">
</li>
<li>
<p>多值依赖 &amp; 函数依赖</p>
 <img src="/DB6_img/8.png" style="zoom:1%">
 <img src="/DB6_img/9.png" style="zoom:1%">
</li>
</ol>
<p><a href="%22https://blog.csdn.net/w2011212787/article/details/52351668%22">函数依赖与多值依赖</a></p>
<img src="/DB6_img/11.png" style="zoom:1%">
<ol start="4">
<li>BCNF</li>
</ol>
<p>不存在任何字段对任一候选关键字段的传递函数依赖</p>
<p>如果有不依赖于候选码的其他函数依赖，则不满足BCNF</p>
<img src="/DB6_img/21.png" style="zoom:1%">
<h3 id="四范式-完全的一一对应"><a class="markdownIt-Anchor" href="#四范式-完全的一一对应"></a> 四范式 完全的一一对应</h3>
<ol start="5">
<li>四范式是BCNF的子集</li>
</ol>
<img src="/DB6_img/10.png" style="zoom:1%">
<h1 id="公理系统"><a class="markdownIt-Anchor" href="#公理系统"></a> 公理系统</h1>
<h2 id="armstrong-公理系统"><a class="markdownIt-Anchor" href="#armstrong-公理系统"></a> Armstrong 公理系统</h2>
<ol>
<li>
<p>公理系统</p>
 <img src="/DB6_img/12.png" style="zoom:1%">
</li>
<li>
<p>定律</p>
<ol>
<li>自反律：X能决定他的子集</li>
<li>增广律：若X-&gt;Y,那么XZ-&gt;YZ</li>
<li>传递律：若X-&gt;Y,Y-&gt;Z，则X-&gt;Z</li>
</ol>
</li>
<li>
<p>推理规则</p>
<ol>
<li>合并规则：若X-&gt;Y,X-&gt;，则X-&gt;YZ</li>
<li>分解规则：若X-&gt;Y,Z是Y的子集，那么X-&gt;Z</li>
<li>伪传递规则：若X-&gt;Y,WY-&gt;Z,则WX-&gt;Z</li>
</ol>
</li>
<li>
<p>定理：X-&gt;A1A2…Ak成立的充分必要条件是X-&gt;Ai成立(i=1,2,…,k)</p>
</li>
</ol>
<h2 id="函数依赖集的闭包"><a class="markdownIt-Anchor" href="#函数依赖集的闭包"></a> 函数依赖集的闭包</h2>
<ol>
<li>定义：在关系模式R&lt;U，F&gt;中为F所逻辑蕴含的函数依<br />
赖的全体叫作 F的闭包(Closure)，记为F<sup>+</sup>。</li>
<li>F<sup>+</sup>的意义：包含了给定函数依赖集F(部分)所蕴含的属性集U上的全部函数依赖。但是依赖信息太多，难于利用。</li>
</ol>
<h2 id="属性集的闭包"><a class="markdownIt-Anchor" href="#属性集的闭包"></a> 属性集的闭包</h2>
<ol>
<li>
<p>定义：设F为属性集U上的一组函数依赖，X是U的子集， X关于<br />
函数依赖集F 的闭包(Closure of X under F ) X<sub>F</sub><sup>+</sup> ={ A |<br />
X→A能由F 根据Armstrong公理导出}。</p>
</li>
<li>
<p>X<sub>F</sub><sup>+</sup>的求法</p>
 <img src="/DB6_img/13.png" style="zoom:1%">
</li>
<li>
<p>定理1：设F为属性集U上的一组函数依赖，X，Y 是U的子集， X→Y能由F 根据Armstrong公理导出的充分必要条件是Y 是X<sub>F</sub><sup>+</sup>的子集。</p>
</li>
<li>
<p>定理2：Armstrong公理系统是有效的、完备的。</p>
</li>
</ol>
<h2 id="最小函数依赖集"><a class="markdownIt-Anchor" href="#最小函数依赖集"></a> 最小函数依赖集</h2>
<ol>
<li>
<p>定义：假设在关系模式R&lt;U, F&gt;上有两个函数依赖集F和 G。如果F＋=G+，则称<strong>F和G是等价的，或称F与G相互覆盖。</strong></p>
</li>
<li>
<p>定理：F<sup>+</sup>=G<sup>+</sup>，当且仅当F是G<sup>+</sup>的子集且G是F<sup>+</sup>的子集。</p>
</li>
<li>
<p>如果函数依赖集F满足下列条件，则称F为一个<strong>极小函数依赖集</strong>。亦称为最小依赖集或最小覆盖。</p>
<ol>
<li>F中任一函数依赖的右部仅含有一个属性；</li>
<li>F中不存在这样的函数依赖X→A，使得F与F－{X→A}等价；(去除多余的函数依赖)</li>
<li>F中不存在这样的函数依赖X→A，X有真子集Z使得 (F－{X→A} )∪{Z→A}与F等价。（去除左部的冗余属性）</li>
</ol>
</li>
<li>
<p>最小函数依赖集的求解算法</p>
 <img src="/DB6_img/14.png" style="zoom:1%">
</li>
<li>
<p>一个给定的函数依赖集F的最小函数集不是唯一的。</p>
</li>
</ol>
<h2 id="候选码求解算法"><a class="markdownIt-Anchor" href="#候选码求解算法"></a> 候选码求解算法</h2>
<ol>
<li>
<p>注意</p>
<ol>
<li>码是可以确定一个元组的所有信息的属性名或属性名组，差不多理解为主键，并且主键加其他任意属性名也是码。</li>
<li>候选码的真子集中不存在码。</li>
<li>主码就是主键的意思，主码是任意一个候选码，注意是任意的一个。而且主码也可能是一个属性名组。</li>
</ol>
</li>
<li>
<p>对于给定的关系模式R&lt;U, F&gt;，依照函数依赖集F将U中的属性分为以下四类：</p>
<ol>
<li><strong>L类属性</strong>: 在F中只出现在函数依赖的左部的属性；</li>
<li><strong>R类属性</strong>: 在F中只出现在函数依赖的右部的属性；</li>
<li><strong>LR类属性</strong>: 分别出现在F中的函数依赖左部和右部的属性；</li>
<li><strong>N类属性</strong>: 不在F中的函数依赖中出现的属性。</li>
</ol>
<p>有<strong>结论</strong></p>
<ol>
<li>L类属性和N类属性必包含于任何候选码中；</li>
<li>R类属性必不包含于任何候选码中；</li>
<li>LR类属性不能确定是否在候选码中。</li>
</ol>
</li>
<li>
<p>算法<br />
<img src="/DB6_img/15.png" style="zoom:1%"></p>
 <img src="/DB6_img/16.png" style="zoom:1%">
 <img src="/DB6_img/17.png" style="zoom:1%">
 <img src="/DB6_img/18.png" style="zoom:1%">
</li>
</ol>
<h1 id="模式分解"><a class="markdownIt-Anchor" href="#模式分解"></a> 模式分解</h1>
<ol>
<li>目的：未来更好的存储，在使用中通过自然连接还原为分解前的关系模式。</li>
</ol>
<h2 id="无损连接性"><a class="markdownIt-Anchor" href="#无损连接性"></a> 无损连接性</h2>
<p>要求自然连接后与原模式相同。</p>
<h3 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h3>
<p>就好像在模拟自然连接</p>
<p>过程见本。</p>
<h3 id="定理"><a class="markdownIt-Anchor" href="#定理"></a> 定理</h3>
<p>用于一分为二判定</p>
<ol>
<li>
<p>R分成R1和R2，具有无损连结性的充要条件是：U1∩U2-&gt;U1-U2属于F<sup>+</sup>或U1∩U2-&gt;U2-U1属于F<sup>+</sup>。</p>
</li>
<li>
<p>关系模式R&lt;U, D&gt;中，D为R中的函数依赖FD和多<br />
值依赖MVD的集合。则X→→Y成立的充要条件是R的<br />
分解ρ={ R1&lt;XY, F1&gt;，R2 &lt;XZ, F2&gt; }具有无损连接性，<br />
其中Z=U－X－Y。</p>
</li>
</ol>
<h2 id="函数依赖性"><a class="markdownIt-Anchor" href="#函数依赖性"></a> 函数依赖性</h2>
<p>若原函数依赖的闭包和分解后函数依赖的闭包的和相等，那么就保持函数依赖性。</p>
<p>例题见本。</p>
<h2 id="模式分解结论"><a class="markdownIt-Anchor" href="#模式分解结论"></a> 模式分解结论</h2>
<ol>
<li>无损连结性和函数依赖性互不包含，可能只能满足其中一个。</li>
<li>无损连结性分解能达到4NF</li>
<li>函数依赖性分解可达到3NF，未必达到BCNF</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>DB7</title>
    <url>/2020/03/30/DB7/</url>
    <content><![CDATA[<h1 id="数据库的设计方法"><a class="markdownIt-Anchor" href="#数据库的设计方法"></a> 数据库的设计方法</h1>
<ol>
<li>新奥尔良法:将数据库设计分为四个阶段：需求分析、概念设计、逻辑设计和物理设计。</li>
<li>基于ER模型的设计方法：使用ER模型来设计数据库的概念模型。</li>
<li>3NF的设计方法：用关系数据理论指导逻辑模型的设计。</li>
<li>ODL方法：用面向对象的概念和属于来说明数据库结构。</li>
</ol>
<h2 id="数据库设计中的各级模式"><a class="markdownIt-Anchor" href="#数据库设计中的各级模式"></a> 数据库设计中的各级模式</h2>
<img src="/DB7_img/1.png">
<h1 id="需求分析"><a class="markdownIt-Anchor" href="#需求分析"></a> 需求分析</h1>
<p>需求分析的重点是调查、收集与分析用户在数据管理中的信息要求、处理要求、安全性与完整性要求。</p>
<h2 id="需求信息的收集"><a class="markdownIt-Anchor" href="#需求信息的收集"></a> 需求信息的收集</h2>
<p>即了解用户的组织机构设置、主要业务活动和职能及对新系统的要求。</p>
<h2 id="需求信息的分析"><a class="markdownIt-Anchor" href="#需求信息的分析"></a> 需求信息的分析</h2>
<p>步骤</p>
<h3 id="确定系统边界"><a class="markdownIt-Anchor" href="#确定系统边界"></a> 确定系统边界</h3>
<h3 id="业务流程分析"><a class="markdownIt-Anchor" href="#业务流程分析"></a> 业务流程分析</h3>
<p>使用数据流图</p>
<ol>
<li>
<p>表达方式</p>
<ol>
<li>圆圈：表示一次处理过程</li>
<li>有向线：表示数据流</li>
<li>双线段：表示存储的信息</li>
</ol>
 <img src="/DB7_img/2.png">
</li>
<li>
<p>分析方法</p>
<ol>
<li>自顶向下，逐层分解</li>
<li>先主干后分支</li>
</ol>
</li>
<li>
<p>建立<strong>数据字典</strong></p>
<ol>
<li>数据字典是各类数据描述的集合，通常以表格的形式详细地描述业务处理过程中用到的各类数据</li>
<li>数据字典的内容包括数据项、数据结构、数据流、数据存储、处理过程等五部分。</li>
<li>数据流：可以是数据项，也可以是数据结构，表示数据的来源和去向。</li>
<li>数据存储：xx表。包括数据存储名、说明、输入数据流、输出数据流、组成成份、数据量、存取方式、存取频度等。</li>
<li>处理过程：加工处理过程定义和说明。</li>
</ol>
</li>
</ol>
<h1 id="概念结构设计"><a class="markdownIt-Anchor" href="#概念结构设计"></a> 概念结构设计</h1>
<p>概念结构设计就是将现实事物以不依赖于任何数据模<br />
型的方式加以描述，目的在于以符号化的形式正确地反映<br />
现实事物及事物与事物间的联系。概念结构设计的内容就<br />
是建立概念模型。</p>
<h2 id="概念结构设计四种策略"><a class="markdownIt-Anchor" href="#概念结构设计四种策略"></a> 概念结构设计四种策略</h2>
<h3 id="自顶向下"><a class="markdownIt-Anchor" href="#自顶向下"></a> 自顶向下</h3>
<p>即首先定义全局概念结构的框架，然后逐步细化。</p>
<h3 id="自底向上"><a class="markdownIt-Anchor" href="#自底向上"></a> 自底向上</h3>
<p>即首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构。</p>
<h3 id="逐步扩张"><a class="markdownIt-Anchor" href="#逐步扩张"></a> 逐步扩张</h3>
<p>即首先确定核心业务的概念结构，然后以此为中心向外扩张，最终实现全局概念结构。</p>
<h3 id="混合策略"><a class="markdownIt-Anchor" href="#混合策略"></a> 混合策略</h3>
<p>即将自顶向下和自底向上两种策略结合使用，首先确定全局框架，划分为若干个局部概念模型，再采取自底向上的策略实现各局部概念模型，加以合并实现全局概念模型。</p>
<h2 id="抽象现实事物的三种方法"><a class="markdownIt-Anchor" href="#抽象现实事物的三种方法"></a> 抽象现实事物的三种方法</h2>
<p>分类；聚集；概括</p>
<h2 id="设计局部视图"><a class="markdownIt-Anchor" href="#设计局部视图"></a> 设计局部视图</h2>
<p>步骤</p>
<h3 id="选择局部应用"><a class="markdownIt-Anchor" href="#选择局部应用"></a> 选择局部应用</h3>
<h3 id="设计分e-r图"><a class="markdownIt-Anchor" href="#设计分e-r图"></a> 设计分E-R图</h3>
<h2 id="确定实体与属性的两条准则"><a class="markdownIt-Anchor" href="#确定实体与属性的两条准则"></a> 确定实体与属性的两条准则</h2>
<ol>
<li>属性是不可再分的数据项，属性不可以再有属性</li>
<li>属性不能与其他实体发生联系，联系只能存在于实体与<br />
实体之间</li>
<li>例如职工(职工号，姓名，年龄，职称)，其中的职称如果<br />
与工资、住房和福利挂勾(即有联系)，则应该单独作为<br />
实体，而职工与职称间构成联系</li>
</ol>
<h2 id="视图集成"><a class="markdownIt-Anchor" href="#视图集成"></a> 视图集成</h2>
<img src="/DB7_img/4.png">
<p>选择两个具有相同实体的E-R图，通过相同实体将两个ER图连结起来构成一个E-R图，然后再与其它E-R图连结直到将<br />
所有的局部E-R图全部连结成一个E-R图，称为全局E-R图</p>
<h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h3>
<ol>
<li>可以完整地描述企业的信息及其联系</li>
<li>另一方面在集成过程中可以解决冲突和消除冗余。</li>
</ol>
<h3 id="分e-r图之间的三类冲突"><a class="markdownIt-Anchor" href="#分e-r图之间的三类冲突"></a> 分E-R图之间的三类冲突</h3>
<ol>
<li>属性冲突</li>
<li>命名冲突</li>
<li>结构冲突：同一对象在某一分E-R图中被抽象为实体而在另一分E-R图中又被抽象为属性，需要统一。</li>
</ol>
<h3 id="冗余"><a class="markdownIt-Anchor" href="#冗余"></a> 冗余</h3>
<p>注意从一个实体到另一个实体存在多条路的情况，要检查能否消除冗余。</p>
<h1 id="逻辑结构设计"><a class="markdownIt-Anchor" href="#逻辑结构设计"></a> 逻辑结构设计</h1>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>Python可视化目录</title>
    <url>/2020/03/30/Python%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="matplotlib代码示例"><a class="markdownIt-Anchor" href="#matplotlib代码示例"></a> <a href="/Python%E5%8F%AF%E8%A7%86%E5%8C%96/matplotlib%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/">matplotlib代码示例</a></h2>
<h2 id="matplotlib基础"><a class="markdownIt-Anchor" href="#matplotlib基础"></a> <a href="/Python%E5%8F%AF%E8%A7%86%E5%8C%96/matplotlib%E5%9F%BA%E7%A1%80/">matplotlib基础</a></h2>
<h2 id="numpy代码示例"><a class="markdownIt-Anchor" href="#numpy代码示例"></a> <a href="/Python%E5%8F%AF%E8%A7%86%E5%8C%96/numpy%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/">numpy代码示例</a></h2>
<h2 id="numpy基础"><a class="markdownIt-Anchor" href="#numpy基础"></a> <a href="/Python%E5%8F%AF%E8%A7%86%E5%8C%96/numpy%E5%9F%BA%E7%A1%80/">numpy基础</a></h2>
<h2 id="pandas代码示例"><a class="markdownIt-Anchor" href="#pandas代码示例"></a> <a href="/Python%E5%8F%AF%E8%A7%86%E5%8C%96/pandas%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/">pandas代码示例</a></h2>
<h2 id="pandas基础"><a class="markdownIt-Anchor" href="#pandas基础"></a> <a href="/Python%E5%8F%AF%E8%A7%86%E5%8C%96/pandas%E5%9F%BA%E7%A1%80/">pandas基础</a></h2>
<h2 id="pandas高级代码示例"><a class="markdownIt-Anchor" href="#pandas高级代码示例"></a> <a href="/Python%E5%8F%AF%E8%A7%86%E5%8C%96/pandas%E9%AB%98%E7%BA%A7%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/">pandas高级代码示例</a></h2>
<h2 id="pandas高级"><a class="markdownIt-Anchor" href="#pandas高级"></a> <a href="/Python%E5%8F%AF%E8%A7%86%E5%8C%96/pandas%E9%AB%98%E7%BA%A7/">pandas高级</a></h2>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>Hali-Bula的晚会</title>
    <url>/2020/03/30/Hali-Bula%E7%9A%84%E6%99%9A%E4%BC%9A/</url>
    <content><![CDATA[<h1 id="uva-1220-hali-bula的晚会"><a class="markdownIt-Anchor" href="#uva-1220-hali-bula的晚会"></a> UVA 1220 Hali-Bula的晚会</h1>
<p>公司里有n(n&lt;=200)个人形成一个树状结构，即除了老板之外每个员工都有唯一的直属上司。要求选尽量多的人，但不能同时选择一个人和他的直属上司。问：最多能选多少人，以及在人数最多的前提下方案是否唯一。</p>
<p>输入：第一行一个数n;第二行输入老板的名字;以下的n-1行中,每行是一位员工的名字和其直属上司的名字(英文单词,长度为1到100),两个名字之间有空格隔开,'0’为输入结束的标识符。</p>
<p>输出：一行,输出一个数字，表示最大的访客数量。并再同一行输出单词’Yes’或’No’，代表目前方案是否唯一。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>参考最大独立集，不过本题实现与那篇不同</li>
<li>本题的特殊之处在于需要需要判断唯一性，<strong>我认为唯一性的原则是取判断导出当前状态的状态是否是唯一方案</strong></li>
<li>由于每个点处决策只有两种，选或不选，所以用d[maxn][2]表示以u为根的子树中，能达到的最大人数。0表示不取u，1表示取u。f[maxn][2]来表示相应状态是否是唯一的，具体的f的判定见注释</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; id;</span><br><span class="line"><span class="keyword">int</span> d[maxn][<span class="number">2</span>], f[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ID</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!id.count(s))</span><br><span class="line">		id[s] = cnt++;</span><br><span class="line">	<span class="keyword">return</span> id[s];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	f[u][k] = <span class="number">1</span>;</span><br><span class="line">	d[u][k] = k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">//如果取了u，那么他的孩子不能取</span></span><br><span class="line">			<span class="comment">//所以d[u][1]只能来源于d[v][0]</span></span><br><span class="line">			<span class="comment">//所以f取决于f[v][0]</span></span><br><span class="line">			d[u][<span class="number">1</span>] += dp(v, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (f[v][<span class="number">0</span>] == <span class="number">0</span>) f[u][<span class="number">1</span>] = <span class="number">0</span>;	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//如果不取u，那么v可取可不取</span></span><br><span class="line">			<span class="comment">//因为要求最大人数，所以u的状态来自要取二者最大值</span></span><br><span class="line">			<span class="comment">//所以f取决于子树的最大状态的f</span></span><br><span class="line">			d[u][<span class="number">0</span>] += <span class="built_in">max</span>(dp(v, <span class="number">0</span>), dp(v, <span class="number">1</span>));</span><br><span class="line">			<span class="keyword">if</span> (d[v][<span class="number">0</span>] == d[v][<span class="number">1</span>]) f[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (d[v][<span class="number">0</span>] &gt; d[v][<span class="number">1</span>] &amp;&amp; f[v][<span class="number">0</span>] == <span class="number">0</span>) f[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (d[v][<span class="number">1</span>] &gt; d[v][<span class="number">0</span>] &amp;&amp; f[v][<span class="number">1</span>] == <span class="number">0</span>) f[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> d[u][k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">string</span> s1, s2;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		id.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			g[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s1;</span><br><span class="line">		ID(s1);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">			g[ID(s2)].push_back(ID(s1));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, <span class="built_in">max</span>(dp(<span class="number">0</span>, <span class="number">0</span>), dp(<span class="number">0</span>, <span class="number">1</span>)));</span><br><span class="line">		<span class="keyword">bool</span> unique = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (d[<span class="number">0</span>][<span class="number">0</span>] &gt; d[<span class="number">0</span>][<span class="number">1</span>] &amp;&amp; f[<span class="number">0</span>][<span class="number">0</span>]) unique = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (d[<span class="number">0</span>][<span class="number">1</span>] &gt; d[<span class="number">0</span>][<span class="number">0</span>] &amp;&amp; f[<span class="number">0</span>][<span class="number">1</span>]) unique = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (unique) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>Iptables实验目录</title>
    <url>/2020/03/30/Iptables%E5%AE%9E%E9%AA%8C%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="iptablesexp基础"><a class="markdownIt-Anchor" href="#iptablesexp基础"></a> <a href="/2020/03/30/iptables">IptablesExp基础</a></h2>
<h2 id="源代码代码仓库"><a class="markdownIt-Anchor" href="#源代码代码仓库"></a> <a href="https://github.com/Cccceb/BTF.git">源代码代码仓库</a></h2>
<p>​	    本次实验通过设置 iptables 规则，来实现防火墙功能。iptables 本身不是</p>
<p>防火墙，它可以理解为一个客户端代理，通过 iptables 来设定规则，最终运行</p>
<p>在 netfilter 框架下。</p>
<p>​	    Iptables 中有四链五表，用来过滤所有进出的报文。防火墙的功能是对经过</p>
<p>的报文匹配规则，然后执行对应的动作。对于每个关卡，都不止一条规则，故称</p>
<p>为链。将那些具有相同规则的集合叫做表。链包括 INPUT、OUTPU、PREROURING(路</p>
<p>由前)、FORWARD(转发)、POSTROUTING(路由后)。同时，在 iptables 中预定义了</p>
<p>四种表，分别是负责过滤的 filter 表、负责网络地址转换的 nat 表、负责拆解</p>
<p>报文做出修改的 mangle 表以及关闭 nat 表上启用的连接追踪机制的 raw 表。本</p>
<p>次实验中主要涉及了前两个表。</p>
<p>​		通过本次实验，学习了很多关于 iptables 以及网络、安全方面的知识。我</p>
<p>将学到的知识治理成以下三个实验内容：主机防火墙、网络防火墙、NAT 转换。</p>
<p>在理论课的过程中，老师经常提及 Dos 攻击。所以，在学习了 socket 编程</p>
<p>之后，用 C 语言实现了两台虚拟机之间建立 TCP 连接。最终模拟了防御 Dos 攻击</p>
<p>的情况，形成了实验四。</p>
<p>​		总的来说，本次实验我递进式的做了四个实验，分别是主机防火墙、网络防</p>
<p>火墙、NAT 动作、TCP 连接与 DoS 防御。</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot目录</title>
    <url>/2020/03/30/SpringBoot%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="spring-boot笔记"><a class="markdownIt-Anchor" href="#spring-boot笔记"></a> <a href="/2020/03/30/SpringBoot%E7%AC%94%E8%AE%B0/">Spring Boot笔记</a></h2>
<h2 id="spring杂记"><a class="markdownIt-Anchor" href="#spring杂记"></a> <a href="/2020/03/30/Spring%E6%9D%82%E8%AE%B0/">Spring杂记</a></h2>
<h2 id="stomp"><a class="markdownIt-Anchor" href="#stomp"></a> <a href="/2020/03/30/STOMP/">STOMP</a></h2>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>Shuffle的播放记录</title>
    <url>/2020/03/30/Shuffle%E7%9A%84%E6%92%AD%E6%94%BE%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="uva-12174-shuffle的播放记录"><a class="markdownIt-Anchor" href="#uva-12174-shuffle的播放记录"></a> UVA 12174 Shuffle的播放记录</h1>
<p>音乐播放器有一个所谓乱序播放功能，假设一共有s首歌，一开始会给这些歌随机排序，全部播放完毕后再随机排序，继续播放，以此类推。注：当s首歌播完前不会重新排序，所以播放记录里每s首歌都是1~s的排列.给出一个长度为n（1&lt;=s,n&lt;=100000) 的播放记录（不一定从最开始记录）xi（1&lt;=xi&lt;=s).统计下一次随机排序所发生的时间有多少种可能性。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>统计可能性，就是统计当前序列有多少种分法。</li>
<li>连续s个数是一段，想到滑动窗口问题，并且这个题的窗口大小相对固定。需要做的是找到所有可能的段的起始点，再验证哪些能作为整体的划分的开头。</li>
<li>段的起始点，有三种情况
<ol>
<li>位于播放列表开头的不完整段。这时判断条件是开头i个元素都是不重复的</li>
<li>完整的段。要求窗口内没有重复的数字</li>
<li>位于结尾的不完整的段。与开头的类似，只是判断条件为n+s-i个元素都是不重复的。等价于后面i个元素都是不重复的。</li>
</ol>
</li>
<li>本题还要注意一些边界条件和数组大小</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="solve"><a class="markdownIt-Anchor" href="#solve"></a> solve</h2>
<ol>
<li>先找到段的起始点，用ok[i]表示，再依次判断每个段起始点能否成为整个划分的开头</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">	int tot &#x3D; 0;&#x2F;&#x2F;记录不重复数字总数</span><br><span class="line">	fill(cnt + 1, cnt + s + 1, 0); &#x2F;&#x2F;cnt[i]表示值i出现的次数</span><br><span class="line">	fill(ok, ok + n + s + 1, 0);   &#x2F;&#x2F;ok[i]&#x3D;&#x3D;1表示第i个窗口内没有重复元素</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n+s+1; i++) &#123;</span><br><span class="line">		if (tot &#x3D;&#x3D; s) ok[i] &#x3D; 1;</span><br><span class="line">		if (i &lt; s&amp;&amp;tot &#x3D;&#x3D; i) </span><br><span class="line">			ok[i] &#x3D; 1;</span><br><span class="line">		if (i &gt; n&amp;&amp;tot &#x3D;&#x3D; n+s-i) </span><br><span class="line">			ok[i] &#x3D; 1;&#x2F;&#x2F;n+s-i 从后往前数的第i个</span><br><span class="line"></span><br><span class="line">		if (i &#x3D;&#x3D; n + s) break;;</span><br><span class="line">		if (a[i] !&#x3D; -1 &amp;&amp; --cnt[a[i]] &#x3D;&#x3D; 0) tot--;</span><br><span class="line">		if (a[i + s] !&#x3D; -1 &amp;&amp; cnt[a[i+s]]++ &#x3D;&#x3D; 0) tot++;&#x2F;&#x2F;窗口滑动一格</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;验证每个起始点</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; s; i++) &#123;</span><br><span class="line">		int valid &#x3D; 1;</span><br><span class="line">		for (int j &#x3D; i; j &lt; n + s + 1; j +&#x3D; s)</span><br><span class="line">			if (!ok[j]) valid &#x3D; 0;;</span><br><span class="line">		if (valid) ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	if (ans &#x3D;&#x3D; n + 1) ans &#x3D; s; &#x2F;&#x2F; special case</span><br><span class="line">	printf(&quot;%d\n&quot;, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100000 + 5;</span><br><span class="line"></span><br><span class="line">int s, n;</span><br><span class="line">int a[maxn*3+1];&#x2F;&#x2F;前后各空出s的空间，防止溢出</span><br><span class="line">int cnt[maxn];&#x2F;&#x2F;记录每个数字的出现次数</span><br><span class="line">int ok[maxn*3+1];&#x2F;&#x2F;ok[i]&#x3D;&#x3D;1表示第i个滑动窗口中没有重复数字</span><br><span class="line"></span><br><span class="line">void solve();</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d %d&quot;, &amp;s, &amp;n);</span><br><span class="line">		fill(a, a + n + 2 * s, -1);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i+s]);</span><br><span class="line">		solve();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql基本语法</title>
    <url>/2020/03/30/Mysql%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="mysql基础"><a class="markdownIt-Anchor" href="#mysql基础"></a> Mysql基础</h1>
<h2 id="数据库相关概念"><a class="markdownIt-Anchor" href="#数据库相关概念"></a> 数据库相关概念</h2>
<p>一、数据库的好处<br />
1、可以持久化数据到本地<br />
2、结构化查询</p>
<p>二、数据库的常见概念 ★<br />
1、DB：数据库，存储数据的容器<br />
2、DBMS：数据库管理系统，又称为数据库软件或数据库产品，用于创建或管理DB<br />
3、SQL：结构化查询语言，用于和数据库通信的语言，不是某个数据库软件特有的，而是几乎所有的主流数据库软件通用的语言</p>
<p>三、数据库存储数据的特点<br />
1、数据存放到表中，然后表再放到库中<br />
2、一个库中可以有多张表，每张表具有唯一的表名用来标识自己<br />
3、表中有一个或多个列，列又称为“字段”，相当于java中“属性”<br />
4、表中的每一行数据，相当于java中“对象”</p>
<p>四、常见的数据库管理系统<br />
mysql、oracle、db2、sqlserver</p>
<h2 id="mysql介绍"><a class="markdownIt-Anchor" href="#mysql介绍"></a> MySql介绍</h2>
<p>一、MySQL的背景<br />
前身属于瑞典的一家公司，MySQL AB<br />
08年被sun公司收购<br />
09年sun被oracle收购</p>
<p>二、MySQL的优点<br />
1、开源、免费、成本低<br />
2、性能高、移植性也好<br />
3、体积小，便于安装<br />
三、MySQL的安装<br />
属于c/s架构的软件，一般来讲安装服务端<br />
企业版<br />
社区版</p>
<p>5.5<br />
5.6<br />
5.7<br />
8.0</p>
<p>四、MySQL服务的启动和停止<br />
方式一：通过命令行<br />
net start 服务名<br />
net stop 服务名<br />
方式二：计算机——右击——管理——服务</p>
<p>五、MySQL服务的登录和退出</p>
<p>登录：mysql 【-h 主机名 -P 端口号】 -u 用户名 -p密码</p>
<p>退出：exit或ctrl+C</p>
<h1 id="dql语言"><a class="markdownIt-Anchor" href="#dql语言"></a> DQL语言</h1>
<h2 id="基础查询"><a class="markdownIt-Anchor" href="#基础查询"></a> 基础查询</h2>
<p>一、语法<br />
select 查询列表<br />
from 表名;<br />
二、特点<br />
1、查询列表可以是字段、常量、表达式、函数，也可以是多个<br />
2、查询结果是一个虚拟表</p>
<p>三、示例<br />
1、查询单个字段<br />
select 字段名 from 表名;<br />
2、查询多个字段<br />
select 字段名，字段名 from 表名;<br />
3、查询所有字段<br />
select * from 表名<br />
4、查询常量<br />
select 常量值;<br />
注意：字符型和日期型的常量值必须用单引号引起来，数值型不需要<br />
5、查询函数<br />
select 函数名(实参列表);<br />
6、查询表达式<br />
select 100/1234;<br />
7、起别名<br />
①as<br />
②空格<br />
8、去重<br />
select distinct 字段名 from 表名;</p>
<p>9、+<br />
作用：做加法运算<br />
select 数值+数值; 直接运算<br />
select 字符+数值;先试图将字符转换成数值，如果转换成功，则继续运算；否则转换成0，再做运算<br />
select null+值;结果都为null</p>
<p>10、【补充】concat函数<br />
功能：拼接字符<br />
select concat(字符1，字符2，字符3,…);</p>
<p>11、【补充】ifnull函数<br />
功能：判断某字段或表达式是否为null，如果为null 返回指定的值，否则返回原本的值<br />
select ifnull(commission_pct,0) from employees;</p>
<p>12、【补充】isnull函数<br />
功能：判断某字段或表达式是否为null，如果是，则返回1，否则返回0</p>
<h2 id="条件查询"><a class="markdownIt-Anchor" href="#条件查询"></a> 条件查询</h2>
<p>一、语法<br />
select 查询列表<br />
from 表名<br />
where 筛选条件</p>
<p>二、筛选条件的分类<br />
1、简单条件运算符</p>
<blockquote>
<p>&lt; = &lt;&gt; != &gt;= &lt;=  &lt;=&gt;安全等于<br />
2、逻辑运算符<br />
&amp;&amp; and<br />
|| or<br />
!  not<br />
3、模糊查询<br />
like:一般搭配通配符使用，可以判断字符型或数值型<br />
通配符：%任意多个字符，_任意单个字符</p>
</blockquote>
<p>between and<br />
in<br />
is null /is not null：用于判断null值</p>
<p>is null PK &lt;=&gt;<br />
普通类型的数值	null值		可读性<br />
is null		×			√		√<br />
&lt;=&gt;		√			√		×</p>
<h2 id="排序查询"><a class="markdownIt-Anchor" href="#排序查询"></a> 排序查询</h2>
<p>一、语法<br />
select 查询列表<br />
from 表<br />
where 筛选条件<br />
order by 排序列表 【asc}desc】</p>
<p>二、特点<br />
1、asc ：升序，如果不写默认升序<br />
desc：降序</p>
<p>2、排序列表 支持 单个字段、多个字段、函数、表达式、别名</p>
<p>3、order by的位置一般放在查询语句的最后（除limit语句之外）</p>
<h2 id="常见函数"><a class="markdownIt-Anchor" href="#常见函数"></a> 常见函数</h2>
<p>一、概述<br />
功能：类似于java中的方法<br />
好处：提高重用性和隐藏实现细节<br />
调用：select 函数名(实参列表);<br />
二、单行函数<br />
1、字符函数<br />
concat:连接<br />
substr:截取子串<br />
upper:变大写<br />
lower：变小写<br />
replace：替换<br />
length：获取字节长度<br />
trim:去前后空格<br />
lpad：左填充<br />
rpad：右填充<br />
instr:获取子串第一次出现的索引<br />
2、数学函数<br />
ceil:向上取整<br />
round：四舍五入<br />
mod:取模<br />
floor：向下取整<br />
truncate:截断<br />
rand:获取随机数，返回0-1之间的小数</p>
<p>3、日期函数</p>
<p>now：返回当前日期+时间<br />
year:返回年<br />
month：返回月<br />
day:返回日<br />
date_format:将日期转换成字符<br />
curdate:返回当前日期<br />
str_to_date:将字符转换成日期<br />
curtime：返回当前时间<br />
hour:小时<br />
minute:分钟<br />
second：秒<br />
datediff:返回两个日期相差的天数<br />
monthname:以英文形式返回月</p>
<p>4、其他函数<br />
version 当前数据库服务器的版本<br />
database 当前打开的数据库<br />
user当前用户<br />
password(‘字符’)：返回该字符的密码形式<br />
md5(‘字符’):返回该字符的md5加密形式</p>
<p>5、流程控制函数</p>
<p>①if(条件表达式，表达式1，表达式2)：如果条件表达式成立，返回表达式1，否则返回表达式2<br />
②case情况1<br />
case 变量或表达式或字段<br />
when 常量1 then 值1<br />
when 常量2 then 值2<br />
…<br />
else 值n<br />
end</p>
<p>③case情况2<br />
case<br />
when 条件1 then 值1<br />
when 条件2 then 值2<br />
…<br />
else 值n<br />
end</p>
<p>三、分组函数<br />
1、分类<br />
max 最大值<br />
min 最小值<br />
sum 和<br />
avg 平均值<br />
count 计算个数</p>
<p>2、特点</p>
<p>①语法<br />
select max(字段) from 表名;</p>
<p>②支持的类型<br />
sum和avg一般用于处理数值型<br />
max、min、count可以处理任何数据类型</p>
<p>③以上分组函数都忽略null<br />
④都可以搭配distinct使用，实现去重的统计<br />
select sum(distinct 字段) from 表;<br />
⑤count函数<br />
count(字段)：统计该字段非空值的个数<br />
count(*):统计结果集的行数<br />
案例：查询每个部门的员工个数<br />
1 xx    10<br />
2 dd    20<br />
3 mm    20<br />
4 aa    40<br />
5 hh    40</p>
<p>count(1):统计结果集的行数</p>
<p>效率上：<br />
MyISAM存储引擎，count(<em>)最高<br />
InnoDB存储引擎，count(</em>)和count(1)效率&gt;count(字段)</p>
<p>⑥ 和分组函数一同查询的字段，要求是group by后出现的字段</p>
<h2 id="分组查序"><a class="markdownIt-Anchor" href="#分组查序"></a> 分组查序</h2>
<p>一、语法<br />
select 分组函数，分组后的字段<br />
from 表<br />
【where 筛选条件】<br />
group by 分组的字段<br />
【having 分组后的筛选】<br />
【order by 排序列表】</p>
<p>二、特点</p>
<pre><code>		使用关键字		筛选的表	位置
</code></pre>
<p>分组前筛选	where			原始表		group by的前面<br />
分组后筛选	having		分组后的结果	group by 的后面</p>
<h2 id="连接查询"><a class="markdownIt-Anchor" href="#连接查询"></a> 连接查询</h2>
<p>一、含义<br />
当查询中涉及到了多个表的字段，需要使用多表连接<br />
select 字段1，字段2<br />
from 表1，表2,…;</p>
<p>笛卡尔乘积：当查询多个表时，没有添加有效的连接条件，导致多个表所有行实现完全连接<br />
如何解决：添加有效的连接条件</p>
<p>二、分类</p>
<p>按年代分类：<br />
sql92：<br />
等值<br />
非等值<br />
自连接</p>
<pre><code>	也支持一部分外连接（用于oracle、sqlserver，mysql不支持）
sql99【推荐使用】
	内连接
		等值
		非等值
		自连接
	外连接
		左外
		右外
		全外（mysql不支持）
	交叉连接
</code></pre>
<p>三、SQL92语法<br />
1、等值连接<br />
语法：<br />
select 查询列表<br />
from 表1 别名,表2 别名<br />
where 表1.key=表2.key<br />
【and 筛选条件】<br />
【group by 分组字段】<br />
【having 分组后的筛选】<br />
【order by 排序字段】</p>
<p>特点：<br />
① 一般为表起别名<br />
②多表的顺序可以调换<br />
③n表连接至少需要n-1个连接条件<br />
④等值连接的结果是多表的交集部分</p>
<p>2、非等值连接<br />
语法：<br />
select 查询列表<br />
from 表1 别名,表2 别名<br />
where 非等值的连接条件<br />
【and 筛选条件】<br />
【group by 分组字段】<br />
【having 分组后的筛选】<br />
【order by 排序字段】<br />
3、自连接</p>
<p>语法：<br />
select 查询列表<br />
from 表 别名1,表 别名2<br />
where 等值的连接条件<br />
【and 筛选条件】<br />
【group by 分组字段】<br />
【having 分组后的筛选】<br />
【order by 排序字段】</p>
<p>四、SQL99语法<br />
1、内连接<br />
语法：<br />
select 查询列表<br />
from 表1 别名<br />
【inner】 join 表2 别名 on 连接条件<br />
where 筛选条件<br />
group by 分组列表<br />
having 分组后的筛选<br />
order by 排序列表<br />
limit 子句;</p>
<p>特点：<br />
①表的顺序可以调换<br />
②内连接的结果=多表的交集<br />
③n表连接至少需要n-1个连接条件</p>
<p>分类：<br />
等值连接<br />
非等值连接<br />
自连接</p>
<p>2、外连接<br />
语法：<br />
select 查询列表<br />
from 表1 别名<br />
left|right|full【outer】 join 表2 别名 on 连接条件<br />
where 筛选条件<br />
group by 分组列表<br />
having 分组后的筛选<br />
order by 排序列表<br />
limit 子句;<br />
特点：<br />
①查询的结果=主表中所有的行，如果从表和它匹配的将显示匹配行，如果从表没有匹配的则显示null<br />
②left join 左边的就是主表，right join 右边的就是主表<br />
full join 两边都是主表<br />
③一般用于查询除了交集部分的剩余的不匹配的行</p>
<p>3、交叉连接</p>
<p>语法：<br />
select 查询列表<br />
from 表1 别名<br />
cross join 表2 别名;</p>
<p>特点：<br />
类似于笛卡尔乘积</p>
<h2 id="子查询"><a class="markdownIt-Anchor" href="#子查询"></a> 子查询</h2>
<p>一、含义<br />
嵌套在其他语句内部的select语句称为子查询或内查询，<br />
外面的语句可以是insert、update、delete、select等，一般select作为外面语句较多<br />
外面如果为select语句，则此语句称为外查询或主查询</p>
<p>二、分类<br />
1、按出现位置<br />
select后面：<br />
仅仅支持标量子查询<br />
from后面：<br />
表子查询<br />
where或having后面：<br />
标量子查询<br />
列子查询<br />
行子查询<br />
exists后面：<br />
标量子查询<br />
列子查询<br />
行子查询<br />
表子查询</p>
<p>2、按结果集的行列<br />
标量子查询（单行子查询）：结果集为一行一列<br />
列子查询（多行子查询）：结果集为多行一列<br />
行子查询：结果集为多行多列<br />
表子查询：结果集为多行多列</p>
<p>三、示例<br />
where或having后面<br />
1、标量子查询<br />
案例：查询最低工资的员工姓名和工资<br />
①最低工资<br />
select min(salary) from employees</p>
<p>②查询员工的姓名和工资，要求工资=①<br />
select last_name,salary<br />
from employees<br />
where salary=(<br />
select min(salary) from employees<br />
);</p>
<p>2、列子查询<br />
案例：查询所有是领导的员工姓名<br />
①查询所有员工的 manager_id<br />
select manager_id<br />
from employees</p>
<p>②查询姓名，employee_id属于①列表的一个<br />
select last_name<br />
from employees<br />
where employee_id in(<br />
select manager_id<br />
from employees<br />
);</p>
<h2 id="分页查询"><a class="markdownIt-Anchor" href="#分页查询"></a> 分页查询</h2>
<p>一、应用场景<br />
当要查询的条目数太多，一页显示不全<br />
二、语法</p>
<p>select 查询列表<br />
from 表<br />
limit 【offset，】size;<br />
注意：<br />
offset代表的是起始的条目索引，默认从0卡死<br />
size代表的是显示的条目数</p>
<p>公式：<br />
假如要显示的页数为page，每一页条目数为size<br />
select 查询列表<br />
from 表<br />
limit (page-1)*size,size;</p>
<h2 id="联合查询"><a class="markdownIt-Anchor" href="#联合查询"></a> 联合查询</h2>
<p>一、含义<br />
union：合并、联合，将多次查询结果合并成一个结果<br />
二、语法<br />
查询语句1<br />
union 【all】<br />
查询语句2<br />
union 【all】<br />
…</p>
<p>三、意义<br />
1、将一条比较复杂的查询语句拆分成多条语句<br />
2、适用于查询多个表的时候，查询的列基本是一致</p>
<p>四、特点<br />
1、要求多条查询语句的查询列数必须一致<br />
2、要求多条查询语句的查询的各列类型、顺序最好一致<br />
3、union 去重，union all包含重复项</p>
<h2 id="查询总结"><a class="markdownIt-Anchor" href="#查询总结"></a> 查询总结</h2>
<p>语法：<br />
select 查询列表    ⑦<br />
from 表1 别名       ①<br />
连接类型 join 表2   ②<br />
on 连接条件         ③<br />
where 筛选          ④<br />
group by 分组列表   ⑤<br />
having 筛选         ⑥<br />
order by排序列表    ⑧<br />
limit 起始条目索引，条目数;  ⑨</p>
<h1 id="dml语言"><a class="markdownIt-Anchor" href="#dml语言"></a> DML语言</h1>
<h2 id="插入"><a class="markdownIt-Anchor" href="#插入"></a> 插入</h2>
<p>一、方式一<br />
语法：<br />
insert into 表名(字段名,…) values(值,…);<br />
特点：<br />
1、要求值的类型和字段的类型要一致或兼容<br />
2、字段的个数和顺序不一定与原始表中的字段个数和顺序一致<br />
但必须保证值和字段一一对应<br />
3、假如表中有可以为null的字段，注意可以通过以下两种方式插入null值<br />
①字段和值都省略<br />
②字段写上，值使用null<br />
4、字段和值的个数必须一致<br />
5、字段名可以省略，默认所有列</p>
<p>二、方式二<br />
语法：<br />
insert into 表名 set 字段=值,字段=值,…;</p>
<p>两种方式 的区别：<br />
1.方式一支持一次插入多行，语法如下：<br />
insert into 表名【(字段名,…)】 values(值，…),(值，…),…;<br />
2.方式一支持子查询，语法如下：<br />
insert into 表名<br />
查询语句;</p>
<h2 id="修改"><a class="markdownIt-Anchor" href="#修改"></a> 修改</h2>
<p>一、修改单表的记录 ★<br />
语法：update 表名 set 字段=值,字段=值 【where 筛选条件】;</p>
<p>二、修改多表的记录【补充】<br />
语法：<br />
update 表1 别名<br />
left|right|inner join 表2 别名<br />
on 连接条件<br />
set 字段=值,字段=值<br />
【where 筛选条件】;</p>
<h2 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h2>
<p>方式一：使用delete<br />
一、删除单表的记录★<br />
语法：delete from 表名 【where 筛选条件】【limit 条目数】<br />
二、级联删除[补充]<br />
语法：<br />
delete 别名1,别名2 from 表1 别名<br />
inner|left|right join 表2 别名<br />
on 连接条件<br />
【where 筛选条件】</p>
<p>方式二：使用truncate<br />
语法：truncate table 表名</p>
<p>两种方式的区别【面试题】★</p>
<p>1.truncate删除后，如果再插入，标识列从1开始<br />
delete删除后，如果再插入，标识列从断点开始<br />
2.delete可以添加筛选条件<br />
truncate不可以添加筛选条件<br />
3.truncate效率较高<br />
4.truncate没有返回值<br />
delete可以返回受影响的行数<br />
5.truncate不可以回滚<br />
delete可以回滚</p>
<h1 id="ddl语言"><a class="markdownIt-Anchor" href="#ddl语言"></a> DDL语言</h1>
<h2 id="库的管理"><a class="markdownIt-Anchor" href="#库的管理"></a> 库的管理</h2>
<p>一、创建库<br />
create database 【if not exists】 库名【 character set 字符集名】;</p>
<p>二、修改库<br />
alter database 库名 character set 字符集名;<br />
三、删除库<br />
drop database 【if exists】 库名;</p>
<h2 id="表的管理"><a class="markdownIt-Anchor" href="#表的管理"></a> 表的管理</h2>
<p>一、创建表 ★<br />
create table 【if not exists】 表名(<br />
字段名 字段类型 【约束】,<br />
字段名 字段类型 【约束】,<br />
。。。<br />
字段名 字段类型 【约束】</p>
<p>)</p>
<p>二、修改表</p>
<p>1.添加列<br />
alter table 表名 add column 列名 类型 【first|after 字段名】;<br />
2.修改列的类型或约束<br />
alter table 表名 modify column 列名 新类型 【新约束】;<br />
3.修改列名<br />
alter table 表名 change column 旧列名 新列名 类型;<br />
4 .删除列<br />
alter table 表名 drop column 列名;<br />
5.修改表名<br />
alter table 表名 rename 【to】 新表名;</p>
<p>三、删除表<br />
drop table【if exists】 表名;</p>
<p>四、复制表<br />
1、复制表的结构<br />
create table 表名 like 旧表;<br />
2、复制表的结构+数据<br />
create table 表名<br />
select 查询列表 from 旧表【where 筛选】;</p>
<h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2>
<p>一、数值型<br />
1、整型<br />
tinyint、smallint、mediumint、int/integer、bigint<br />
1         2        3          4            8</p>
<p>特点：<br />
①都可以设置无符号和有符号，默认有符号，通过unsigned设置无符号<br />
②如果超出了范围，会报out or range异常，插入临界值<br />
③长度可以不指定，默认会有一个长度<br />
长度代表显示的最大宽度，如果不够则左边用0填充，但需要搭配zerofill，并且默认变为无符号整型</p>
<p>2、浮点型<br />
定点数：decimal(M,D)<br />
浮点数:<br />
float(M,D)   4<br />
double(M,D)  8</p>
<p>特点：<br />
①M代表整数部位+小数部位的个数，D代表小数部位<br />
②如果超出范围，则报out or range异常，并且插入临界值<br />
③M和D都可以省略，但对于定点数，M默认为10，D默认为0<br />
④如果精度要求较高，则优先考虑使用定点数</p>
<p>二、字符型<br />
char、varchar、binary、varbinary、enum、set、text、blob</p>
<p>char：固定长度的字符，写法为char(M)，最大长度不能超过M，其中M可以省略，默认为1<br />
varchar：可变长度的字符，写法为varchar(M)，最大长度不能超过M，其中M不可以省略</p>
<p>三、日期型<br />
year年<br />
date日期<br />
time时间<br />
datetime 日期+时间          8<br />
timestamp 日期+时间         4   比较容易受时区、语法模式、版本的影响，更能反映当前时区的真实时间</p>
<h2 id="常见的约束"><a class="markdownIt-Anchor" href="#常见的约束"></a> 常见的约束</h2>
<p>一、常见的约束<br />
NOT NULL：非空，该字段的值必填<br />
UNIQUE：唯一，该字段的值不可重复<br />
DEFAULT：默认，该字段的值不用手动插入有默认值<br />
CHECK：检查，mysql不支持<br />
PRIMARY KEY：主键，该字段的值不可重复并且非空  unique+not null<br />
FOREIGN KEY：外键，该字段的值引用了另外的表的字段</p>
<p>主键和唯一<br />
1、区别：<br />
①、一个表至多有一个主键，但可以有多个唯一<br />
②、主键不允许为空，唯一可以为空<br />
2、相同点<br />
都具有唯一性<br />
都支持组合键，但不推荐<br />
外键：<br />
1、用于限制两个表的关系，从表的字段值引用了主表的某字段值<br />
2、外键列和主表的被引用列要求类型一致，意义一样，名称无要求<br />
3、主表的被引用列要求是一个key（一般就是主键）<br />
4、插入数据，先插入主表<br />
删除数据，先删除从表<br />
可以通过以下两种方式来删除主表的记录<br />
#方式一：级联删除<br />
ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE;</p>
<p>#方式二：级联置空<br />
ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL;</p>
<p>二、创建表时添加约束<br />
create table 表名(<br />
字段名 字段类型 not null,#非空<br />
字段名 字段类型 primary key,#主键<br />
字段名 字段类型 unique,#唯一<br />
字段名 字段类型 default 值,#默认<br />
constraint 约束名 foreign key(字段名) references 主表（被引用列）</p>
<p>)<br />
注意：<br />
支持类型		可以起约束名			<br />
列级约束		除了外键		不可以<br />
表级约束		除了非空和默认	可以，但对主键无效</p>
<p>列级约束可以在一个字段上追加多个，中间用空格隔开，没有顺序要求</p>
<p>三、修改表时添加或删除约束<br />
1、非空<br />
添加非空<br />
alter table 表名 modify column 字段名 字段类型 not null;<br />
删除非空<br />
alter table 表名 modify column 字段名 字段类型 ;</p>
<p>2、默认<br />
添加默认<br />
alter table 表名 modify column 字段名 字段类型 default 值;<br />
删除默认<br />
alter table 表名 modify column 字段名 字段类型 ;<br />
3、主键<br />
添加主键<br />
alter table 表名 add【 constraint 约束名】 primary key(字段名);<br />
删除主键<br />
alter table 表名 drop primary key;</p>
<p>4、唯一<br />
添加唯一<br />
alter table 表名 add【 constraint 约束名】 unique(字段名);<br />
删除唯一<br />
alter table 表名 drop index 索引名;<br />
5、外键<br />
添加外键<br />
alter table 表名 add【 constraint 约束名】 foreign key(字段名) references 主表（被引用列）;<br />
删除外键<br />
alter table 表名 drop foreign key 约束名;</p>
<p>四、自增长列<br />
特点：<br />
1、不用手动插入值，可以自动提供序列值，默认从1开始，步长为1<br />
auto_increment_increment<br />
如果要更改起始值：手动插入值<br />
如果要更改步长：更改系统变量<br />
set auto_increment_increment=值;<br />
2、一个表至多有一个自增长列<br />
3、自增长列只能支持数值型<br />
4、自增长列必须为一个key</p>
<p>一、创建表时设置自增长列<br />
create table 表(<br />
字段名 字段类型 约束 auto_increment<br />
)<br />
二、修改表时设置自增长列<br />
alter table 表 modify column 字段名 字段类型 约束 auto_increment<br />
三、删除自增长列<br />
alter table 表 modify column 字段名 字段类型 约束</p>
<h1 id="tcl语言"><a class="markdownIt-Anchor" href="#tcl语言"></a> TCL语言</h1>
<p>一、含义<br />
事务：一条或多条sql语句组成一个执行单位，一组sql语句要么都执行要么都不执行<br />
二、特点（ACID）<br />
A 原子性：一个事务是不可再分割的整体，要么都执行要么都不执行<br />
C 一致性：一个事务可以使数据从一个一致状态切换到另外一个一致的状态<br />
I 隔离性：一个事务不受其他事务的干扰，多个事务互相隔离的<br />
D 持久性：一个事务一旦提交了，则永久的持久化到本地</p>
<p>三、事务的使用步骤 ★<br />
了解：<br />
隐式（自动）事务：没有明显的开启和结束，本身就是一条事务可以自动提交，比如insert、update、delete<br />
显式事务：具有明显的开启和结束</p>
<p>使用显式事务：<br />
①开启事务<br />
set autocommit=0;<br />
start transaction;#可以省略</p>
<p>②编写一组逻辑sql语句<br />
注意：sql语句支持的是insert、update、delete</p>
<p>设置回滚点：<br />
savepoint 回滚点名;</p>
<p>③结束事务<br />
提交：commit;<br />
回滚：rollback;<br />
回滚到指定的地方：rollback to 回滚点名;<br />
四、并发事务<br />
1、事务的并发问题是如何发生的？<br />
多个事务 同时 操作 同一个数据库的相同数据时<br />
2、并发问题都有哪些？<br />
脏读：一个事务读取了其他事务还没有提交的数据，读到的是其他事务“更新”的数据<br />
不可重复读：一个事务多次读取，结果不一样<br />
幻读：一个事务读取了其他事务还没有提交的数据，只是读到的是 其他事务“插入”的数据<br />
3、如何解决并发问题<br />
通过设置隔离级别来解决并发问题<br />
4、隔离级别<br />
脏读		不可重复读		幻读<br />
read uncommitted:读未提交     ×                ×              ×<br />
read committed：读已提交      √                ×              ×<br />
repeatable read：可重复读     √                √              ×<br />
serializable：串行化          √                √              √</p>
<h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1>
<h2 id="视图"><a class="markdownIt-Anchor" href="#视图"></a> 视图</h2>
<p>一、含义<br />
mysql5.1版本出现的新特性，本身是一个虚拟表，它的数据来自于表，通过执行时动态生成。<br />
好处：<br />
1、简化sql语句<br />
2、提高了sql的重用性<br />
3、保护基表的数据，提高了安全性<br />
二、创建<br />
create view 视图名<br />
as<br />
查询语句;</p>
<p>三、修改<br />
方式一：<br />
create or replace view 视图名<br />
as<br />
查询语句;<br />
方式二：<br />
alter view 视图名<br />
as<br />
查询语句</p>
<p>四、删除<br />
drop view 视图1，视图2,…;<br />
五、查看<br />
desc 视图名;<br />
show create view 视图名;<br />
六、使用<br />
1.插入<br />
insert<br />
2.修改<br />
update<br />
3.删除<br />
delete<br />
4.查看<br />
select<br />
注意：视图一般用于查询的，而不是更新的，所以具备以下特点的视图都不允许更新<br />
①包含分组函数、group by、distinct、having、union、<br />
②join<br />
③常量视图<br />
④where后的子查询用到了from中的表<br />
⑤用到了不可更新的视图</p>
<p>七、视图和表的对比<br />
关键字		是否占用物理空间			使用<br />
视图	view		占用较小，只保存sql逻辑		一般用于查询<br />
表		table		保存实际的数据			增删改查</p>
<h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2>
<p>分类<br />
一、系统变量<br />
说明：变量由系统提供的，不用自定义<br />
语法：<br />
①查看系统变量<br />
show 【global|session 】variables like ‘’; 如果没有显式声明global还是session，则默认是session<br />
②查看指定的系统变量的值<br />
select @@【global|session】.变量名; 如果没有显式声明global还是session，则默认是session<br />
③为系统变量赋值<br />
方式一：<br />
set 【global|session 】 变量名=值; 如果没有显式声明global还是session，则默认是session<br />
方式二：<br />
set @@global.变量名=值;<br />
set @@变量名=值；</p>
<p>1、全局变量<br />
服务器层面上的，必须拥有super权限才能为系统变量赋值，作用域为整个服务器，也就是针对于所有连接（会话）有效</p>
<p>2、会话变量<br />
服务器为每一个连接的客户端都提供了系统变量，作用域为当前的连接（会话）</p>
<p>二、自定义变量<br />
说明：<br />
1、用户变量<br />
作用域：针对于当前连接（会话）生效<br />
位置：begin end里面，也可以放在外面<br />
使用：</p>
<p>①声明并赋值：<br />
set @变量名=值;或<br />
set @变量名:=值;或<br />
select @变量名:=值;</p>
<p>②更新值<br />
方式一：<br />
set @变量名=值;或<br />
set @变量名:=值;或<br />
select @变量名:=值;<br />
方式二：<br />
select xx into @变量名 from 表;</p>
<p>③使用<br />
select @变量名;</p>
<p>2、局部变量<br />
作用域：仅仅在定义它的begin end中有效<br />
位置：只能放在begin end中，而且只能放在第一句<br />
使用：<br />
①声明<br />
declare 变量名 类型 【default 值】;<br />
②赋值或更新<br />
方式一：<br />
set 变量名=值;或<br />
set 变量名:=值;或<br />
select @变量名:=值;<br />
方式二：<br />
select xx into 变量名 from 表;<br />
③使用<br />
select 变量名;</p>
<h2 id="存储过程和函数"><a class="markdownIt-Anchor" href="#存储过程和函数"></a> 存储过程和函数</h2>
<p>说明：都类似于java中的方法，将一组完成特定功能的逻辑语句包装起来，对外暴露名字<br />
好处：<br />
1、提高重用性<br />
2、sql语句简单<br />
3、减少了和数据库服务器连接的次数，提高了效率</p>
<h3 id="存储过程"><a class="markdownIt-Anchor" href="#存储过程"></a> 存储过程</h3>
<p>一、创建 ★<br />
create procedure 存储过程名(参数模式 参数名 参数类型)<br />
begin<br />
存储过程体<br />
end<br />
注意：<br />
1.参数模式：in、out、inout，其中in可以省略<br />
2.存储过程体的每一条sql语句都需要用分号结尾</p>
<p>二、调用<br />
call 存储过程名(实参列表)<br />
举例：<br />
调用in模式的参数：call sp1（‘值’）;<br />
调用out模式的参数：set @name; call sp1(@name);select @name;<br />
调用inout模式的参数：set @name=值; call sp1(@name); select @name;<br />
三、查看<br />
show create procedure 存储过程名;<br />
四、删除<br />
drop procedure 存储过程名;</p>
<h3 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h3>
<p>一、创建<br />
create function 函数名(参数名 参数类型) returns  返回类型<br />
begin<br />
函数体<br />
end</p>
<p>注意：函数体中肯定需要有return语句<br />
二、调用<br />
select 函数名(实参列表);<br />
三、查看<br />
show create function 函数名;<br />
四、删除<br />
drop function 函数名；</p>
<h2 id="流程控制结构"><a class="markdownIt-Anchor" href="#流程控制结构"></a> 流程控制结构</h2>
<p>说明：<br />
顺序结构：程序从上往下依次执行<br />
分支结构：程序按条件进行选择执行，从两条或多条路径中选择一条执行<br />
循环结构：程序满足一定条件下，重复执行一组语句</p>
<h3 id="分支结构"><a class="markdownIt-Anchor" href="#分支结构"></a> 分支结构</h3>
<p>特点：<br />
1、if函数<br />
功能：实现简单双分支<br />
语法：<br />
if(条件，值1，值2)<br />
位置：<br />
可以作为表达式放在任何位置<br />
2、case结构<br />
功能：实现多分支<br />
语法1：<br />
case 表达式或字段<br />
when 值1 then 语句1;<br />
when 值2 then 语句2；<br />
…<br />
else 语句n;<br />
end [case];</p>
<p>语法2：<br />
case<br />
when 条件1 then 语句1;<br />
when 条件2 then 语句2；<br />
…<br />
else 语句n;<br />
end [case];</p>
<p>位置：<br />
可以放在任何位置，<br />
如果放在begin end 外面，作为表达式结合着其他语句使用<br />
如果放在begin end 里面，一般作为独立的语句使用<br />
3、if结构<br />
功能：实现多分支<br />
语法：<br />
if 条件1 then 语句1;<br />
elseif 条件2 then 语句2;<br />
…<br />
else 语句n;<br />
end if;<br />
位置：<br />
只能放在begin end中</p>
<h3 id="循环结构"><a class="markdownIt-Anchor" href="#循环结构"></a> 循环结构</h3>
<p>位置：<br />
只能放在begin end中</p>
<p>特点：都能实现循环结构</p>
<p>对比：</p>
<p>①这三种循环都可以省略名称，但如果循环中添加了循环控制语句（leave或iterate）则必须添加名称<br />
②<br />
loop 一般用于实现简单的死循环<br />
while 先判断后执行<br />
repeat 先执行后判断，无条件至少执行一次</p>
<p>1、while<br />
语法：<br />
【名称:】while 循环条件 do<br />
循环体<br />
end while 【名称】;<br />
2、loop<br />
语法：<br />
【名称：】loop<br />
循环体<br />
end loop 【名称】;</p>
<p>3、repeat<br />
语法：<br />
【名称:】repeat<br />
循环体<br />
until 结束条件<br />
end repeat 【名称】;</p>
<p>二、循环控制语句<br />
leave：类似于break，用于跳出所在的循环<br />
iterate：类似于continue，用于结束本次循环，继续下一次</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>STOMP</title>
    <url>/2020/03/30/STOMP/</url>
    <content><![CDATA[<h1 id="stomp基础"><a class="markdownIt-Anchor" href="#stomp基础"></a> STOMP基础</h1>
<h2 id="stomp的意义"><a class="markdownIt-Anchor" href="#stomp的意义"></a> STOMP的意义</h2>
<p>http协议是无状态协议，即每次请求时都不知道前面发生的什么。而且请求只能由浏览器发起，服务器只能响应该请求，不能主动发送消息给浏览器。这种单向的协议显然在很多场景下是不适用的，比如消息推送，股票实时行情。在websocket之前，我们通常使用Ajax轮询服务器或者使用长轮询，这两种方式都极大消耗了服务端和客户端的资源。而使用websocket，我们只需要借用http协议进行握手，然后保持着一个websocket连接，直到客户端主动断开。相对于另外两种方式，websocket只发送了一次http请求，当服务器有数据时再向浏览器推送数据，减少了带宽的使用以及服务器CPU使用率。</p>
<h2 id="websocket-http-tcp-socket之间关系"><a class="markdownIt-Anchor" href="#websocket-http-tcp-socket之间关系"></a> Websocket、Http、TCP、Socket之间关系：</h2>
<ol>
<li>HTTP、WebSocket 等应用层协议，都是基于 TCP 协议来传输数据的。</li>
<li>对于 WebSocket 来说，它必须依赖 HTTP 协议进行一次握手 ，握手成功后，数据就直接从 TCP 通道传输，与 HTTP 无关了。</li>
<li>Socket并不是一种协议，而是方便我们使用TCP/IP的一种封装，而WebSocket 则不同，它是一个完整的 应用层协议，包含一套标准的 API 。</li>
</ol>
<h2 id="配置启用代理的web消息功能"><a class="markdownIt-Anchor" href="#配置启用代理的web消息功能"></a> 配置启用代理的web消息功能</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableWebSocketMessageBroker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">extends</span> <span class="title">AbstractWebSocketMessageBrokerConfigurer</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageBroker</span><span class="params">(MessageBrokerRegistry config)</span> </span>&#123;  </span><br><span class="line">        config.enableSimpleBroker(<span class="string">"/topic"</span>,<span class="string">"/queue"</span>);  </span><br><span class="line">        config.setApplicationDestinationPrefixes(<span class="string">"/app"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span> </span>&#123;  </span><br><span class="line">        registry.addEndpoint(<span class="string">"/endpoint"</span>).setAllowedOrigins(<span class="string">"*"</span>).withSockJS();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用了 @EnableWebSocketMessageBroker 注解。这表明这个配置类不仅配置了 WebSocket ，还配置了基于代理的 STOMP 消息。</li>
<li>重载了 registerStompEndpoints() 方法，将 “/endpoint” 注册为 STOMP 端点。这个路径与之前发送和接收消息的目的地路径有所不同。这是一个端点，客户端在订阅或发布消息到目的地路径前，要连接该端点。</li>
<li>重载 configureMessageBroker() 方法配置了一个简单的消息代理。这个方法是可选的，如果不重载它的话，将会自动配置一个简单的内存消息代理，用它来处理以 “/topic” 为前缀的消息。但是在本例中，我们重载了这个方法，所以消息代理将会处理前缀为 “/topic” 和 “/queue” 的消息。除此之外，发往应用程序的消息将会带有 “/app” 前缀。</li>
<li>当消息到达时，目的地的前缀将会决定消息该如何处理。
<ol>
<li>应用程序的目的地以 “/app” 作为前缀。以应用程序为目的地的消息将会直接路由到带有 @MessageMapping 注解的控制器方法中。</li>
<li>而代理的目的地以 “/topic” 和 “/queue” 作为前缀。而发送到代理上的消息，其中也包括 @MessageMapping 注解方法的返回值所形成的消息，将会路由到代理上，并最终发送到订阅这些目的地的客户端.</li>
</ol>
</li>
</ol>
<h1 id="stomp服务端实现"><a class="markdownIt-Anchor" href="#stomp服务端实现"></a> STOMP服务端实现</h1>
<p><img src="https://images2018.cnblogs.com/blog/1153954/201805/1153954-20180506222500876-639399590.png" alt="img" /></p>
<h2 id="前缀"><a class="markdownIt-Anchor" href="#前缀"></a> 前缀</h2>
<ol>
<li>以 /app 开头的消息都会被路由到带有@MessageMapping 或 @SubscribeMapping 注解的方法中；</li>
<li>以/topic 或 /queue 开头的消息都会发送到STOMP代理中，根据你所选择的STOMP代理不同，目的地的可选前缀也会有所限制；</li>
<li>以/user开头的消息会将消息重路由到某个用户独有的目的地上。</li>
</ol>
<h2 id="处理来自客户端的stomp消息"><a class="markdownIt-Anchor" href="#处理来自客户端的stomp消息"></a> 处理来自客户端的STOMP消息</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MessageMapping</span>(<span class="string">"/marco"</span>)</span><br><span class="line"><span class="meta">@SendTo</span>(<span class="string">"/topic/marco"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Shout <span class="title">stompHandle</span><span class="params">(Shout shout)</span></span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"接收到消息："</span> + shout.getMessage());</span><br><span class="line">    Shout s = <span class="keyword">new</span> Shout();</span><br><span class="line">    s.setMessage(<span class="string">"Polo!"</span>);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>方法接收一个Shout对象，该对象是用Spring的某个消息转换器将STOMP消息的负载转换的</p>
</li>
<li>
<p>尤其注意，这个处理器方法有一个返回值，<strong>这个返回值</strong>并不是返回给客户端的，而<strong>是转发给消息代理的</strong>，<strong>如果客户端想要这个返回值的话，只能从消息代理订阅</strong>。</p>
</li>
<li>
<p>@SendTo 注解重写了消息代理的目的地，如果不指定@SendTo，帧所发往的目的地会与触发处理器方法的目的地相同，只不过会添加上“/topic”前缀。</p>
</li>
<li>
<p>STOMP 仍然为这种一次性的响应提供了支持，用的@SubscribeMapping注解，与HTTP不同的是，这种请求-响应模式是异步的…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SubscribeMapping</span>(<span class="string">"/getShout"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Shout <span class="title">getShout</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Shout shout = <span class="keyword">new</span> Shout();</span><br><span class="line">    shout.setMessage(<span class="string">"Hello STOMP"</span>);</span><br><span class="line">    <span class="keyword">return</span> shout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="发送消息到客户端"><a class="markdownIt-Anchor" href="#发送消息到客户端"></a> 发送消息到客户端</h1>
<h2 id="处理消息之后发送消息"><a class="markdownIt-Anchor" href="#处理消息之后发送消息"></a> 处理消息之后发送消息</h2>
<ol>
<li>如果 @MessageMapping 注解的控制器方法有返回值的话，返回值会被发送到消息代理，只不过会添加上&quot;/topic&quot;前缀。可以使用@SendTo 重写消息目的地；</li>
<li>如果 @SubscribeMapping 注解的控制器方法有返回值的话，返回值会直接发送到客户端，不经过代理。如果加上@SendTo 注解的话，则要经过消息代理。</li>
</ol>
<h2 id="在应用的任意地方发送消息"><a class="markdownIt-Anchor" href="#在应用的任意地方发送消息"></a> 在应用的任意地方发送消息</h2>
<p>spring-websocket 定义了一个 SimpMessageSendingOperations 接口（或者使用SimpMessagingTemplate ），可以实现自由的向任意目的地发送消息，并且订阅此目的地的所有用户都能收到消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> SimpMessageSendingOperations simpMessageSendingOperations;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 广播消息，不指定用户，所有订阅此的用户都能收到消息</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> shout</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@MessageMapping</span>(<span class="string">"/broadcastShout"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadcast</span><span class="params">(Shout shout)</span> </span>&#123;</span><br><span class="line">      simpMessageSendingOperations.convertAndSend(<span class="string">"/topic/shouts"</span>, shout);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="为指定用户发送消息"><a class="markdownIt-Anchor" href="#为指定用户发送消息"></a> 为指定用户发送消息</h2>
<h3 id="基于sendtouser注解和principal参数"><a class="markdownIt-Anchor" href="#基于sendtouser注解和principal参数"></a> 基于SendToUser注解和Principal参数</h3>
<p>@SendToUser 表示要将消息发送给指定的用户，会<strong>自动在消息目的地前补上&quot;/user&quot;前缀</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MessageMapping</span>(<span class="string">"/shout"</span>)</span><br><span class="line">  <span class="meta">@SendToUser</span>(<span class="string">"/queue/notifications"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Shout <span class="title">userStomp</span><span class="params">(Principal principal, Shout shout)</span> </span>&#123;</span><br><span class="line">        String name = principal.getName();</span><br><span class="line">        String message = shout.getMessage();</span><br><span class="line">        LOGGER.info(<span class="string">"认证的名字是：&#123;&#125;，收到的消息是：&#123;&#125;"</span>, name, message);</span><br><span class="line">        <span class="keyword">return</span> shout;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>比如，最后消息会被发布在  /user/queue/notifications-username。但是问题来了，这个username是怎么来的呢？就是通过 principal 参数来获得的。那么，principal 参数又是怎么来的呢？需要在spring-websocket 的配置类中重写 configureClientInboundChannel 方法，添加上用户的认证。</p>
<h3 id="基于convertandsendtouser方法"><a class="markdownIt-Anchor" href="#基于convertandsendtouser方法"></a> 基于convertAndSendToUser方法</h3>
<p>SimpMessageSendingOperations 还提供了convertAndSendToUser()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MessageMapping</span>(<span class="string">"/singleShout"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singleUser</span><span class="params">(Shout shout, StompHeaderAccessor stompHeaderAccessor)</span> </span>&#123;</span><br><span class="line">    String message = shout.getMessage();</span><br><span class="line">    LOGGER.info(<span class="string">"接收到消息："</span> + message);</span><br><span class="line">    Principal user = stompHeaderAccessor.getUser();</span><br><span class="line">    simpMessageSendingOperations.convertAndSendToUser(user.getName(), <span class="string">"/queue/shouts"</span>, shout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>convertAndSendToUser 方法最终会把消息发送到 /user/sername/queue/shouts 目的地上。</li>
</ol>
<h2 id="处理消息异常"><a class="markdownIt-Anchor" href="#处理消息异常"></a> 处理消息异常</h2>
<p>在处理消息的时候，有可能会出错并抛出异常。因为STOMP消息异步的特点，发送者可能永远也不会知道出现了错误。@MessageExceptionHandler标注的方法能够处理消息方法中所抛出的异常。我们可以把错误发送给用户特定的目的地上，然后用户从该目的地上订阅消息，从而用户就能知道自己出现了什么错误啦…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MessageExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">@SendToUser("/queue/errors")</span><br><span class="line"><span class="function"><span class="keyword">public</span> Exception <span class="title">handleExceptions</span><span class="params">(Exception t)</span></span>&#123;</span><br><span class="line">    t.printStackTrace();</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="stomp客户端实现"><a class="markdownIt-Anchor" href="#stomp客户端实现"></a> STOMP客户端实现</h1>
<h2 id="js依赖"><a class="markdownIt-Anchor" href="#js依赖"></a> JS依赖</h2>
<p>STOMP 依赖 sockjs.js 和 stomp.min.js。stomp.min.js的下载链接：<a href="http://www.bootcdn.cn/stomp.js/" target="_blank" rel="noopener">http://www.bootcdn.cn/stomp.js/</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://cdn.bootcss.com/sockjs-client/1.1.1/sockjs.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/stomp.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="js客户端实现"><a class="markdownIt-Anchor" href="#js客户端实现"></a> JS客户端实现</h2>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*STOMP*/</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'http://localhost:8080/stomp'</span>;</span><br><span class="line"><span class="keyword">var</span> sock = <span class="keyword">new</span> SockJS(url);</span><br><span class="line"><span class="keyword">var</span> stomp = Stomp.over(sock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> strJson = <span class="built_in">JSON</span>.stringify(&#123;<span class="string">'message'</span>: <span class="string">'Marco!'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认的和STOMP端点连接</span></span><br><span class="line"><span class="comment">/*stomp.connect("guest", "guest", function (franme) &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;);*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> headers=&#123;</span><br><span class="line">    username:<span class="string">'admin'</span>,</span><br><span class="line">    password:<span class="string">'admin'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">stomp.connect(headers, <span class="function"><span class="keyword">function</span> (<span class="params">frame</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送消息</span></span><br><span class="line">    <span class="comment">//第二个参数是一个头信息的Map，它会包含在STOMP的帧中</span></span><br><span class="line">    <span class="comment">//事务支持</span></span><br><span class="line">    <span class="keyword">var</span> tx = stomp.begin();</span><br><span class="line">    stomp.send(<span class="string">"/app/marco"</span>, &#123;<span class="attr">transaction</span>: tx.id&#125;, strJson);</span><br><span class="line">    tx.commit();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//订阅服务端消息 subscribe(destination url, callback[, headers])</span></span><br><span class="line">    stomp.subscribe(<span class="string">"/topic/marco"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> content = message.body;</span><br><span class="line">        <span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(content);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"订阅的服务端消息："</span> + obj.message);</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    stomp.subscribe(<span class="string">"/app/getShout"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> content = message.body;</span><br><span class="line">        <span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(content);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"订阅的服务端直接返回的消息："</span> + obj.message);</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*以下是针对特定用户的订阅*/</span></span><br><span class="line">    <span class="keyword">var</span> adminJSON = <span class="built_in">JSON</span>.stringify(&#123;<span class="string">'message'</span>: <span class="string">'ADMIN'</span>&#125;);</span><br><span class="line">    <span class="comment">/*第一种*/</span></span><br><span class="line">    stomp.send(<span class="string">"/app/singleShout"</span>, &#123;&#125;, adminJSON);</span><br><span class="line">    stomp.subscribe(<span class="string">"/user/queue/shouts"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> content = message.body;</span><br><span class="line">        <span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(content);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"admin用户特定的消息1："</span> + obj.message);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">/*第二种*/</span></span><br><span class="line">    stomp.send(<span class="string">"/app/shout"</span>, &#123;&#125;, adminJSON);</span><br><span class="line">    stomp.subscribe(<span class="string">"/user/queue/notifications"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> content = message.body;</span><br><span class="line">        <span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(content);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"admin用户特定的消息2："</span> + obj.message);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*订阅异常消息*/</span></span><br><span class="line">    stomp.subscribe(<span class="string">"/user/queue/errors"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(message.body);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若使用STOMP 1.1 版本，默认开启了心跳检测机制（默认值都是10000ms）</span></span><br><span class="line">    stomp.heartbeat.outgoing = <span class="number">20000</span>;</span><br><span class="line"></span><br><span class="line">    stomp.heartbeat.incoming = <span class="number">0</span>; <span class="comment">//客户端不从服务端接收心跳包</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring杂记</title>
    <url>/2020/03/30/Spring%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="spring注解版ioc"><a class="markdownIt-Anchor" href="#spring注解版ioc"></a> Spring注解版IOC</h1>
<h2 id="getmapping"><a class="markdownIt-Anchor" href="#getmapping"></a> @GetMapping</h2>
<ol>
<li>
<p>使用在占位符加@pathvariable 来获取路径中的变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/dept/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Department <span class="title">getDepartment</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> departmentMapper.getDepartmentById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="configuartion"><a class="markdownIt-Anchor" href="#configuartion"></a> @Configuarti’o’n</h2>
<ol>
<li>声明一个配置类，相当于spring中的配置文件</li>
</ol>
<h2 id="bean"><a class="markdownIt-Anchor" href="#bean"></a> @Bean</h2>
<ol>
<li>给容器中注册也给Bean；类型为返回值的类型，id默认是用方法名作为id</li>
<li>使用@Bean(value = “”)修改id</li>
<li><strong>注意</strong> IOC中默认加入的组件都是单实例的</li>
</ol>
<h2 id="componentscan"><a class="markdownIt-Anchor" href="#componentscan"></a> @ComponentScan</h2>
<ol>
<li>
<p>只要包含了@Controller @Service @Repository @Component的组件就会被加入到容器中</p>
</li>
<li>
<p>可以通过@ComponentScan(value =&quot;&quot;)来指定要扫描的包</p>
</li>
<li>
<p>可以通过execludeFilter来排除包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"com.example.demo2"</span>,excludeFilters = &#123;</span><br><span class="line">        <span class="meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION,classes = &#123;</span><br><span class="line">                Controller<span class="class">.<span class="keyword">class</span>, <span class="title">Service</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">        &#125;)</span></span><br><span class="line"><span class="class">&#125;)</span></span><br></pre></td></tr></table></figure>
<p><strong>同理还有includeFilters</strong></p>
</li>
</ol>
<h2 id="scope"><a class="markdownIt-Anchor" href="#scope"></a> @Scope</h2>
<ol>
<li>
<p>用于指定作用范围</p>
<ul>
<li>
<p>prototype：多实例的：ioc容器启动并不会去调用方法创建对象放在容器中。每次获取的时候才会调用方法创建对象；</p>
</li>
<li>
<p>singleton：单实例的（默认值）：ioc容器启动会调用方法创建对象放到ioc容器中。以后每次获取就是直接从容器（map.get()）中拿，</p>
</li>
<li>
<p>request：同一次请求创建一个实例</p>
</li>
<li>
<p>session：同一个session创建一个实例</p>
</li>
</ul>
</li>
<li>
<p>懒加载：@Lazy</p>
<ul>
<li>单实例bean：默认在容器启动的时候创建对象；</li>
<li>懒加载：容器启动不创建对象。第一次使用(获取)Bean创建对象，并初始化；</li>
</ul>
</li>
</ol>
<h2 id="conditional"><a class="markdownIt-Anchor" href="#conditional"></a> @Conditional</h2>
<ol>
<li>按照一定的条件进行判断，满足条件给容器中注入Bean</li>
<li><strong>实现</strong>
<ol>
<li>写一个MyCondition类实现Condition接口，重写matches方法</li>
<li>在判断处加上Condational(MyCondtion.class)</li>
</ol>
</li>
<li>如果Conditional<strong>加载类前面</strong>，那么只有满足当前条件，这个类中配置的 所有bean才能生效</li>
</ol>
<h2 id="import"><a class="markdownIt-Anchor" href="#import"></a> @Import</h2>
<ol>
<li>
<p>@Import({MyClass.class}) 组件默认id 是全类名</p>
</li>
<li>
<p>参数还可以是实现了ImportSelector接口的MyImportSelector类</p>
<ol>
<li>
<p>重写selectImports方法，方法返回要导入的类的全类名的String 数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImport</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">"com.example.demo2.untity.Person"</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>参数还可以是实现了ImportBeanDefinitionRegistrar的类，需要重写registerBeanDefinitions方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportBeanDefinitionRegister</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> b1 = registry.containsBeanDefinition(<span class="string">"com.example.demo2.unity.Red"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> b2 = registry.containsBeanDefinition(<span class="string">"com.example.demo2.unity.Blue"</span>);</span><br><span class="line">        <span class="keyword">if</span>(b1&amp;&amp;b2)&#123;</span><br><span class="line">            RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">            registry.registerBeanDefinition(<span class="string">"rainBow"</span>,beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="factorybean"><a class="markdownIt-Anchor" href="#factorybean"></a> FactoryBean</h2>
<ol>
<li>
<p>实现FactoryBean接口重写方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactoryBean</span>  <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Color();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Color<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>在配置类中注册FactorBean</p>
</li>
<li>
<p>通过传参</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      Object bean1 = applicationContext.getBean(<span class="string">"colorFactoryBean"</span>);<span class="comment">//来获取getObject的类</span></span><br><span class="line">Object bean2 = applicationContext.getBean(<span class="string">"&amp;colorFactoryBean"</span>);<span class="comment">//来获取FactoryBean类</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="bean的生命周期"><a class="markdownIt-Anchor" href="#bean的生命周期"></a> Bean的生命周期</h2>
<h3 id="初始化和销毁方法"><a class="markdownIt-Anchor" href="#初始化和销毁方法"></a> 初始化和销毁方法</h3>
<ol>
<li>
<p>使用@Bean(initMethod =&quot;&quot;,destroyMethod=&quot;&quot;)来指定初始化和销毁方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>,destroyMethod = <span class="string">"destroy"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>单实例的情况下,在容器创建时创建,在容器销毁时销毁</li>
<li>多实例的情况下,在第一次获取时创建,而容器不管理销毁</li>
</ol>
</li>
<li>
<p>或者实体类直接实现InitializingBean, DisposableBean接口,重写销毁方法destroy和初始化方法afterPropertiesSet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cat destroy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cat afterPropertiesSet"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用**@PostConstruc**t 和 <strong>@PreDestroy</strong>分别注解初始化方法和销毁方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">House</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"house construct"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"house postconstruct"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"house destroy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="实现后置处理器重写响应方法在每一个初始化对象初始化操作前后执行"><a class="markdownIt-Anchor" href="#实现后置处理器重写响应方法在每一个初始化对象初始化操作前后执行"></a> 实现后置处理器,重写响应方法;<strong>在每一个初始化对象初始化操作前后执行</strong></h3>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"postProcessBeforeInitialization"</span>+beanName+<span class="string">"=&gt;"</span>+bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"postProcessAfterInitialization"</span>+beanName+<span class="string">"=&gt;"</span>+bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>该方法中可以处理bean,返回包装后的bean</p>
</li>
<li>
<p>BeanPostProcessor.postProcessBeforeInitialization</p>
<ul>
<li>初始化：对象创建完成，并赋值好，调用初始化方法。。。</li>
</ul>
</li>
<li>
<p>BeanPostProcessor.postProcessAfterInitialization</p>
<ul>
<li>
<p>销毁：</p>
<ul>
<li>
<pre><code> 单实例：容器关闭的时候
</code></pre>
</li>
<li>
<pre><code> 多实例：容器不会管理这个bean；容器不会调用销毁方法； 		
</code></pre>
</li>
</ul>
<ol start="4">
<li>
<p>遍历得到容器中所有的BeanPostProcessor；挨个执行beforeInitialization，</p>
<ul>
<li>一但返回null，跳出for循环，不会执行后面的BeanPostProcessor.postProcessorsBeforeInitialization</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>BeanPostProcessor原理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">populateBean(beanName, mbd, instanceWrapper);给bean进行属性赋值</span><br><span class="line">   initializeBean</span><br><span class="line">   &#123;</span><br><span class="line">   applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">   invokeInitMethods(beanName, wrappedBean, mbd);执行自定义初始化</span><br><span class="line">   applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Spring底层对 BeanPostProcessor 的使用；</p>
<ul>
<li>
<pre><code>   bean赋值，注入其他组件，@Autowired，生命周期注解功能，@Async,xxx BeanPostProcessor;
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="给属性赋值"><a class="markdownIt-Anchor" href="#给属性赋值"></a> 给属性赋值</h2>
<h3 id="value参数"><a class="markdownIt-Anchor" href="#value参数"></a> @Value(参数)</h3>
<ol>
<li>
<p>参数可以为</p>
<ul>
<li>
<p>基本数值</p>
</li>
<li>
<p>SpEL #{}</p>
</li>
<li>
<p>${}获取配置文件中的值</p>
<ul>
<li>
<p><strong>使用@PropertySource读取外部配置文件中的值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Config</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value = <span class="string">"classpath:/Person.properties"</span>)<span class="comment">//可以用String数组或PropertySources指定多个文件</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigPropertyValues</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Person</span></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;Person.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//properties</span></span><br><span class="line">Person.name=张三</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="自动装配"><a class="markdownIt-Anchor" href="#自动装配"></a> 自动装配</h2>
<ol>
<li>
<p>@Autowired自动注入:</p>
<ul>
<li>
<p>默认优先按照类型去容器中找对应的组件:applicationContext.getBean(BookDao.class);找到就赋值</p>
<p>如果找到多个相同类型的组件，再将属性的名称作为组件的id去容器中查找</p>
<p>applicationContext.getBean(“bookDao”)</p>
</li>
<li>
<p>@Qualifier(“bookDao”)：使用@Qualifier指定需要装配的组件的id，而不是使用属性名</p>
</li>
<li>
<p>自动装配默认一定要将属性赋值好，没有就会报错；</p>
<p>可以使用@Autowired(required=false);</p>
</li>
<li>
<p>@Primary：让Spring进行自动装配的时候，默认使用首选的bean；</p>
<p>也可以继续使用@Qualifier指定需要装配的bean的名字(<strong>优先级更高</strong>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BookService&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"></span><br><span class="line">BookDao  bookDao;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>@Resource自动装配</p>
<ul>
<li>不支持@Primary等</li>
</ul>
</li>
<li>
<p>@Inject自动装配</p>
<ul>
<li>还要加依赖,和Autowired功能一致</li>
</ul>
</li>
</ol>
<h3 id="autowired-构造器参数方法属性都是从容器中获取参数组件的值"><a class="markdownIt-Anchor" href="#autowired-构造器参数方法属性都是从容器中获取参数组件的值"></a> @Autowired 构造器,参数,方法,属性:都是从容器中获取参数组件的值</h3>
<ol>
<li>标注在属性上</li>
<li>标注在方法上,Spring容器创建当前对象,就会调用方法,完成赋值.方法使用的参数,自定义类型的值从IOC容器中获取</li>
<li>标注在构造器上,如果组件只有一个有参构造器,这个有参构造器的@Auotwired可以自动省略,参数位置的组件还是可以自动获取</li>
<li>@Bean标注的方法创建的对象,方法参数自动从容器中获取</li>
</ol>
<h1 id="自定义异常页面"><a class="markdownIt-Anchor" href="#自定义异常页面"></a> 自定义异常页面</h1>
<h2 id="杂记"><a class="markdownIt-Anchor" href="#杂记"></a> 杂记</h2>
<ol>
<li>@ ResponseBody 如果加载类名前，表示这个类的所有方法返回的数据直接写给浏览器，（如果是对象砖为json对象）</li>
<li>@ResponseBody 和 @ Controller 可以用@ RestController 替代</li>
<li>@ Component 把组件加入到容器中，组件就是接下来的类</li>
<li>单元测试，要import org.junit.Test</li>
<li>@Email 要求注入的数据必须是Email格式，这时注入要用@ConfigurationProoroties</li>
<li>@PostMapping 处理post请求，类似的还有
<ol>
<li>@PutMapping</li>
<li>@DeleteMapping</li>
<li>@GetMapping</li>
</ol>
</li>
<li>参数中可以加入@RequestParam(“参数名”) 这样如果前端没有填写，则会报错</li>
</ol>
<h2 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h2>
<ol>
<li>我自定义的异常被一个controller处理，之后发给异常处理器执行</li>
</ol>
<h2 id="工作"><a class="markdownIt-Anchor" href="#工作"></a> 工作</h2>
<ol>
<li>Controller中写一个类来抛出异常，用@ExceptionHandler(异常名.class)标注；
<ol>
<li>将自定义的错误名以map的形式放入request中</li>
<li>转发请求到/error(有模板引擎的情况下)</li>
</ol>
</li>
<li>component下写一个异常的处理器，继承DefaultErrorAttributes类
<ol>
<li>复写getErrorAttributes方法</li>
<li>从request中取出自定义的错误名称加入到这个类返回值的map中</li>
</ol>
</li>
</ol>
<h1 id="拦截未登录请求"><a class="markdownIt-Anchor" href="#拦截未登录请求"></a> 拦截未登录请求</h1>
<h2 id="实现handlerinterceptor接口"><a class="markdownIt-Anchor" href="#实现handlerinterceptor接口"></a> 实现HandlerInterceptor接口</h2>
<p>重写preHandle方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object user =  request.getSession().getAttribute(<span class="string">"loginUser"</span>);</span><br><span class="line">        <span class="keyword">if</span>(user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            request.setAttribute(<span class="string">"msg"</span>,<span class="string">"没有权限，请先登录"</span>);</span><br><span class="line">            request.getRequestDispatcher(<span class="string">"/login"</span>).forward(request,response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="在配置类中重写addinterceptors方法"><a class="markdownIt-Anchor" href="#在配置类中重写addinterceptors方法"></a> 在配置类中重写addInterceptors方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">    registry.addInterceptor(<span class="keyword">new</span> LoginHandlerInterceptor()).addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">        .excludePathPatterns(<span class="string">"/login"</span>,<span class="string">"/"</span>,<span class="string">"/user/login"</span>,<span class="string">"/webjars/**"</span>,<span class="string">"/asserts/**"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>/**表示路径下所有的文件</li>
<li>注意要把样式文件排除</li>
<li></li>
</ol>
<h1 id="表单提交"><a class="markdownIt-Anchor" href="#表单提交"></a> 表单提交</h1>
<h2 id="springmvc自动封装"><a class="markdownIt-Anchor" href="#springmvc自动封装"></a> SpringMVC自动封装</h2>
<ol>
<li>要求表单中name和JavaBean中的属性名保持一致</li>
</ol>
<h1 id="视图映射"><a class="markdownIt-Anchor" href="#视图映射"></a> 视图映射</h1>
<ol>
<li>
<p>@Configuration 下的类去实现WebMvcConfigure接口，重写addViewControllers()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//实现视图映射</span></span><br><span class="line">        registry.addViewController(<span class="string">"/"</span>).setViewName(<span class="string">"index"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="日志"><a class="markdownIt-Anchor" href="#日志"></a> 日志</h1>
<ol>
<li>
<p>logger要从slf4j.logger中导入</p>
</li>
<li>
<p>logger. (由低到高)</p>
<ol>
<li>trace 记录调试信息</li>
<li>debug 记录debug信息</li>
<li>info 记录自定义信息</li>
<li>warn 警告信息</li>
<li>errror 错误日志</li>
</ol>
</li>
<li>
<p>可以调整输出的日志级别，日志就会再这个级别以后的高级别生效。默认从info级别开始生效。<strong>在配置文件中，使用logging.level.包名 = 级别</strong></p>
</li>
<li>
<p>配置logging.file=日志完整路径(包括日志文件名)</p>
</li>
<li>
<p>配置logging.path=日志路径 (使用spring.log作为文件名) eg. logging.path = /spring/log</p>
</li>
<li>
<p>logging.pattern.console = 用于指定控制台输出的格式</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>S树</title>
    <url>/2020/03/30/S%E6%A0%91/</url>
    <content><![CDATA[<h1 id="uva712-s树"><a class="markdownIt-Anchor" href="#uva712-s树"></a> uva712 S树</h1>
<p>给一棵满二叉树，每一层代表一个010101变量，取000时往左走，取111时往右走。例如下图中两个图都对应表达式x1∧(x2∨x3)x_1\land (x_2\lor x_3)x1​∧(x2​∨x3​)。<br />
给出所有叶子的值以及一些查询（即每个变量xix_ixi​的取值），求每个查询到达的叶子的值。例如有444个查询：000000000，010010010，111111111，110110110，则输出应为001100110011。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>n0 = n2+1;本题中直到叶子节点数，又是满二叉树，所以非叶子节点共n0-1个，所以直接从n0开始存叶子节点。</li>
<li>对于每个查询，遇到1代表向右走，k = 2<em>k+1;遇到0带表k = 2</em>k；最终会走到叶子节点，将他们输出即可；</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   #include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;习题6-2in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;习题6-2out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   int n, m, kase &#x3D; 0;</span><br><span class="line">   int main() &#123;</span><br><span class="line">while (cin &gt;&gt; m &amp;&amp; m) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;S-Tree # &quot; &lt;&lt; ++kase &lt;&lt; &quot;:&quot; &lt;&lt; endl;</span><br><span class="line">	getchar();</span><br><span class="line">	string s;</span><br><span class="line">	getline(cin, s);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	getline(cin, s);</span><br><span class="line"></span><br><span class="line">	int first &#x3D; s.length();</span><br><span class="line">	map&lt;long long , char&gt; leaf;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; s.length(); i++) leaf[first++] &#x3D; s[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cin &gt;&gt; n; getchar();</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		getline(cin, s);</span><br><span class="line">		int k &#x3D; 1;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; s.length(); j++) &#123;</span><br><span class="line">			if (s[j] &#x3D;&#x3D; &#39;0&#39;) k *&#x3D; 2;</span><br><span class="line">			else k &#x3D; k * 2 + 1;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; leaf[k];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA习题目录</title>
    <url>/2020/03/30/UVA%E4%B9%A0%E9%A2%98%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="abbott的复仇"><a class="markdownIt-Anchor" href="#abbott的复仇"></a> <a href="/2020/03/30/Abbott%E7%9A%84%E5%A4%8D%E4%BB%87/">Abbott的复仇</a></h2>
<h2 id="gergovia的酒交易"><a class="markdownIt-Anchor" href="#gergovia的酒交易"></a> <a href="/2020/03/30/Gergovia%E7%9A%84%E9%85%92%E4%BA%A4%E6%98%93/">Gergovia的酒交易</a></h2>
<h2 id="hali-bula的晚会"><a class="markdownIt-Anchor" href="#hali-bula的晚会"></a> <a href="/2020/03/30/Hali-Bula%E7%9A%84%E6%99%9A%E4%BC%9A/">Hali-Bula的晚会</a></h2>
<h2 id="shuffle的播放记录"><a class="markdownIt-Anchor" href="#shuffle的播放记录"></a> <a href="/2020/03/30/Shuffle%E7%9A%84%E6%92%AD%E6%94%BE%E8%AE%B0%E5%BD%95/">Shuffle的播放记录</a></h2>
<h2 id="s树"><a class="markdownIt-Anchor" href="#s树"></a> <a href="/2020/03/30/S%E6%A0%91/">S树</a></h2>
<h2 id="tex中的引导"><a class="markdownIt-Anchor" href="#tex中的引导"></a> <a href="/2020/03/30/Tex%E4%B8%AD%E7%9A%84%E5%BC%95%E5%AF%BC/">Tex中的引导</a></h2>
<h2 id="unix-is-命令"><a class="markdownIt-Anchor" href="#unix-is-命令"></a> <a href="/2020/03/30/UnixIS%E5%91%BD%E4%BB%A4/">Unix IS 命令</a></h2>
<h2 id="万圣节后的早晨"><a class="markdownIt-Anchor" href="#万圣节后的早晨"></a> <a href="/2020/03/30/%E4%B8%87%E5%9C%A3%E8%8A%82%E5%90%8E%E7%9A%84%E6%97%A9%E6%99%A8/">万圣节后的早晨</a></h2>
<h2 id="不公平竞赛"><a class="markdownIt-Anchor" href="#不公平竞赛"></a> <a href="/2020/03/30/%E4%B8%8D%E5%85%AC%E5%B9%B3%E7%AB%9E%E8%B5%9B/">不公平竞赛</a></h2>
<h2 id="不无聊的序列"><a class="markdownIt-Anchor" href="#不无聊的序列"></a> <a href="/2020/03/30/%E4%B8%8D%E6%97%A0%E8%81%8A%E7%9A%84%E5%BA%8F%E5%88%97/">不无聊的序列</a></h2>
<h2 id="与非门电路"><a class="markdownIt-Anchor" href="#与非门电路"></a> <a href="/2020/03/30/%E4%B8%8E%E9%9D%9E%E9%97%A8%E7%94%B5%E8%B7%AF/">与非门电路</a></h2>
<h2 id="两亲性分子"><a class="markdownIt-Anchor" href="#两亲性分子"></a> <a href="/2020/03/30/%E4%B8%A4%E4%BA%B2%E6%80%A7%E5%88%86%E5%AD%90/">两亲性分子</a></h2>
<h2 id="二叉树的层序遍历"><a class="markdownIt-Anchor" href="#二叉树的层序遍历"></a> <a href="/2020/03/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/">二叉树的层序遍历</a></h2>
<h2 id="二叉树的重建"><a class="markdownIt-Anchor" href="#二叉树的重建"></a> <a href="/2020/03/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%87%8D%E5%BB%BA/">二叉树的重建</a></h2>
<h2 id="传说中的车"><a class="markdownIt-Anchor" href="#传说中的车"></a> <a href="/2020/03/30/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E8%BD%A6/">传说中的车</a></h2>
<h2 id="修改天平"><a class="markdownIt-Anchor" href="#修改天平"></a> <a href="/2020/03/30/%E4%BF%AE%E6%94%B9%E5%A4%A9%E5%B9%B3/">修改天平</a></h2>
<h2 id="倒水问题"><a class="markdownIt-Anchor" href="#倒水问题"></a> <a href="/2020/03/30/%E5%80%92%E6%B0%B4%E9%97%AE%E9%A2%98/">倒水问题</a></h2>
<h2 id="八数码"><a class="markdownIt-Anchor" href="#八数码"></a> <a href="/2020/03/30/%E5%85%AB%E6%95%B0%E7%A0%81/">八数码</a></h2>
<h2 id="八皇后问题"><a class="markdownIt-Anchor" href="#八皇后问题"></a> <a href="/2020/03/30/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/">八皇后问题</a></h2>
<h2 id="分数拆分"><a class="markdownIt-Anchor" href="#分数拆分"></a> <a href="/2020/03/30/%E5%88%86%E6%95%B0%E6%8B%86%E5%88%86/">分数拆分</a></h2>
<h2 id="切断圆环链"><a class="markdownIt-Anchor" href="#切断圆环链"></a> <a href="/2020/03/30/%E5%88%87%E6%96%AD%E5%9C%86%E7%8E%AF%E9%93%BE/">切断圆环链</a></h2>
<h2 id="切木棍"><a class="markdownIt-Anchor" href="#切木棍"></a> <a href="/2020/03/30/%E5%88%87%E6%9C%A8%E6%A3%8D/">切木棍</a></h2>
<h2 id="划分成回文串"><a class="markdownIt-Anchor" href="#划分成回文串"></a> <a href="/2020/03/30/%E5%88%92%E5%88%86%E6%88%90%E5%9B%9E%E6%96%87%E4%B8%B2/">划分成回文串</a></h2>
<h2 id="劲歌金曲"><a class="markdownIt-Anchor" href="#劲歌金曲"></a> <a href="/2020/03/30/%E5%8A%B2%E6%AD%8C%E9%87%91%E6%9B%B2/">劲歌金曲</a></h2>
<h2 id="单向tsp"><a class="markdownIt-Anchor" href="#单向tsp"></a> <a href="/2020/03/30/%E5%8D%95%E5%90%91TSP/">单向TSP</a></h2>
<h2 id="反片语"><a class="markdownIt-Anchor" href="#反片语"></a> <a href="/2020/03/30/%E5%8F%8D%E7%89%87%E8%AF%AD/">反片语</a></h2>
<h2 id="古代象形符号"><a class="markdownIt-Anchor" href="#古代象形符号"></a> <a href="/2020/03/30/%E5%8F%A4%E4%BB%A3%E8%B1%A1%E5%BD%A2%E7%AC%A6%E5%8F%B7/">古代象形符号</a></h2>
<h2 id="周期串"><a class="markdownIt-Anchor" href="#周期串"></a> <a href="/2020/03/30/%E5%91%A8%E6%9C%9F%E4%B8%B2/">周期串</a></h2>
<h2 id="和为0的4个值"><a class="markdownIt-Anchor" href="#和为0的4个值"></a> <a href="/2020/03/30/%E5%92%8C%E4%B8%BA0%E7%9A%844%E4%B8%AA%E5%80%BC/">和为0的4个值</a></h2>
<h2 id="唯一的雪花"><a class="markdownIt-Anchor" href="#唯一的雪花"></a> <a href="/2020/03/30/%E5%94%AF%E4%B8%80%E7%9A%84%E9%9B%AA%E8%8A%B1/">唯一的雪花</a></h2>
<h2 id="团体队列"><a class="markdownIt-Anchor" href="#团体队列"></a> <a href="/2020/03/30/%E5%9B%A2%E4%BD%93%E9%98%9F%E5%88%97/">团体队列</a></h2>
<h2 id="困难的串"><a class="markdownIt-Anchor" href="#困难的串"></a> <a href="/2020/03/30/%E5%9B%B0%E9%9A%BE%E7%9A%84%E4%B8%B2/">困难的串</a></h2>
<h2 id="图书管理系统"><a class="markdownIt-Anchor" href="#图书管理系统"></a> <a href="/2020/03/30/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">图书管理系统</a></h2>
<h2 id="在web中搜索"><a class="markdownIt-Anchor" href="#在web中搜索"></a> <a href="/2020/03/30/%E5%9C%A8Web%E4%B8%AD%E6%90%9C%E7%B4%A2/">在Web中搜索</a></h2>
<h2 id="埃及分数"><a class="markdownIt-Anchor" href="#埃及分数"></a> <a href="/2020/03/30/%E5%9F%83%E5%8F%8A%E5%88%86%E6%95%B0/">埃及分数</a></h2>
<h2 id="城市正视图"><a class="markdownIt-Anchor" href="#城市正视图"></a> <a href="/2020/03/30/%E5%9F%8E%E5%B8%82%E6%AD%A3%E8%A7%86%E5%9B%BE/">城市正视图</a></h2>
<h2 id="城市里的间谍"><a class="markdownIt-Anchor" href="#城市里的间谍"></a> <a href="/2020/03/30/%E5%9F%8E%E5%B8%82%E9%87%8C%E7%9A%84%E9%97%B4%E8%B0%8D/">城市里的间谍</a></h2>
<h2 id="多米诺效应"><a class="markdownIt-Anchor" href="#多米诺效应"></a> <a href="/2020/03/30/%E5%A4%9A%E7%B1%B3%E8%AF%BA%E6%95%88%E5%BA%94/">多米诺效应</a></h2>
<h2 id="天平难题"><a class="markdownIt-Anchor" href="#天平难题"></a> <a href="/2020/03/30/%E5%A4%A9%E5%B9%B3%E9%9A%BE%E9%A2%98/">天平难题</a></h2>
<h2 id="奇怪的气球膨胀"><a class="markdownIt-Anchor" href="#奇怪的气球膨胀"></a> <a href="/2020/03/30/%E5%A5%87%E6%80%AA%E7%9A%84%E6%B0%94%E7%90%83%E8%86%A8%E8%83%80/">奇怪的气球膨胀</a></h2>
<h2 id="安迪的第一本字典"><a class="markdownIt-Anchor" href="#安迪的第一本字典"></a> <a href="/2020/03/30/%E5%AE%89%E8%BF%AA%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E5%AD%97%E5%85%B8/">安迪的第一本字典</a></h2>
<h2 id="宝箱"><a class="markdownIt-Anchor" href="#宝箱"></a> <a href="/2020/03/30/%E5%AE%9D%E7%AE%B1/">宝箱</a></h2>
<h2 id="小球下落"><a class="markdownIt-Anchor" href="#小球下落"></a> <a href="/2020/03/30/%E5%B0%8F%E7%90%83%E4%B8%8B%E8%90%BD/">小球下落</a></h2>
<h2 id="巡逻机器人"><a class="markdownIt-Anchor" href="#巡逻机器人"></a> <a href="/2020/03/30/%E5%B7%A1%E9%80%BB%E6%9C%BA%E5%99%A8%E4%BA%BA/">巡逻机器人</a></h2>
<h2 id="工人的请愿书"><a class="markdownIt-Anchor" href="#工人的请愿书"></a> <a href="/2020/03/30/%E5%B7%A5%E4%BA%BA%E7%9A%84%E8%AF%B7%E6%84%BF%E4%B9%A6/">工人的请愿书</a></h2>
<h2 id="巴比伦塔"><a class="markdownIt-Anchor" href="#巴比伦塔"></a> <a href="/2020/03/30/%E5%B7%B4%E6%AF%94%E4%BC%A6%E5%A1%94/">巴比伦塔</a></h2>
<h2 id="带宽"><a class="markdownIt-Anchor" href="#带宽"></a> <a href="/2020/03/30/%E5%B8%A6%E5%AE%BD/">带宽</a></h2>
<h2 id="平均值"><a class="markdownIt-Anchor" href="#平均值"></a> <a href="/2020/03/30/%E5%B9%B3%E5%9D%87%E5%80%BC/">平均值</a></h2>
<h2 id="并行程序模拟"><a class="markdownIt-Anchor" href="#并行程序模拟"></a> <a href="/2020/03/30/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F/">并行程序模拟</a></h2>
<h2 id="循环小数"><a class="markdownIt-Anchor" href="#循环小数"></a> <a href="/2020/03/30/%E5%BE%AA%E7%8E%AF%E5%B0%8F%E6%95%B0/">循环小数</a></h2>
<h2 id="快速幂计算"><a class="markdownIt-Anchor" href="#快速幂计算"></a> <a href="/2020/03/30/%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%A1%E7%AE%97/">快速幂计算</a></h2>
<h2 id="战场"><a class="markdownIt-Anchor" href="#战场"></a> <a href="/2020/03/30/%E6%88%98%E5%9C%BA/">战场</a></h2>
<h2 id="打印队列"><a class="markdownIt-Anchor" href="#打印队列"></a> <a href="/2020/03/30/%E6%89%93%E5%8D%B0%E9%98%9F%E5%88%97/">打印队列</a></h2>
<h2 id="抄书"><a class="markdownIt-Anchor" href="#抄书"></a> <a href="/2020/03/30/%E6%8A%84%E4%B9%A6/">抄书</a></h2>
<h2 id="括号序列"><a class="markdownIt-Anchor" href="#括号序列"></a> <a href="/2020/03/30/%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/">括号序列</a></h2>
<h2 id="排序与检索"><a class="markdownIt-Anchor" href="#排序与检索"></a> <a href="/2020/03/30/%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%A3%80%E7%B4%A2/">排序与检索</a></h2>
<h2 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> <a href="/2020/03/30/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></h2>
<h2 id="旅行"><a class="markdownIt-Anchor" href="#旅行"></a> <a href="/2020/03/30/%E6%97%85%E8%A1%8C/">旅行</a></h2>
<h2 id="旋转游戏"><a class="markdownIt-Anchor" href="#旋转游戏"></a> <a href="/2020/03/30/%E6%97%8B%E8%BD%AC%E6%B8%B8%E6%88%8F/">旋转游戏</a></h2>
<h2 id="最大连续和问题"><a class="markdownIt-Anchor" href="#最大连续和问题"></a> <a href="/2020/03/30/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C%E9%97%AE%E9%A2%98/">最大连续和问题</a></h2>
<h2 id="木块问题"><a class="markdownIt-Anchor" href="#木块问题"></a> <a href="/2020/03/30/%E6%9C%A8%E5%9D%97%E9%97%AE%E9%A2%98/">木块问题</a></h2>
<h2 id="树"><a class="markdownIt-Anchor" href="#树"></a> <a href="/2020/03/30/%E6%A0%91/">树</a></h2>
<h2 id="树的最大独立集"><a class="markdownIt-Anchor" href="#树的最大独立集"></a> <a href="/2020/03/30/%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86/">树的最大独立集</a></h2>
<h2 id="流水线调度"><a class="markdownIt-Anchor" href="#流水线调度"></a> <a href="/2020/03/30/%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%B0%83%E5%BA%A6/">流水线调度</a></h2>
<h2 id="消防车"><a class="markdownIt-Anchor" href="#消防车"></a> <a href="/2020/03/30/%E6%B6%88%E9%98%B2%E8%BD%A6/">消防车</a></h2>
<h2 id="滑动窗口最小问题"><a class="markdownIt-Anchor" href="#滑动窗口最小问题"></a> <a href="/2020/03/30/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%B0%8F%E9%97%AE%E9%A2%98/">滑动窗口最小问题</a></h2>
<h2 id="煎饼"><a class="markdownIt-Anchor" href="#煎饼"></a> <a href="/2020/03/30/%E7%85%8E%E9%A5%BC/">煎饼</a></h2>
<h2 id="照明系统设计"><a class="markdownIt-Anchor" href="#照明系统设计"></a> <a href="/2020/03/30/%E7%85%A7%E6%98%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">照明系统设计</a></h2>
<h2 id="环形跑道"><a class="markdownIt-Anchor" href="#环形跑道"></a> <a href="/2020/03/30/%E7%8E%AF%E5%BD%A2%E8%B7%91%E9%81%93/">环形跑道</a></h2>
<h2 id="理想路径"><a class="markdownIt-Anchor" href="#理想路径"></a> <a href="/2020/03/30/%E7%90%86%E6%83%B3%E8%B7%AF%E5%BE%84/">理想路径</a></h2>
<h2 id="破坏正方形"><a class="markdownIt-Anchor" href="#破坏正方形"></a> <a href="/2020/03/30/%E7%A0%B4%E5%9D%8F%E6%AD%A3%E6%96%B9%E5%BD%A2/">破坏正方形</a></h2>
<h2 id="移动木块"><a class="markdownIt-Anchor" href="#移动木块"></a> <a href="/2020/03/30/%E7%A7%BB%E5%8A%A8%E6%9C%A8%E5%9D%97/">移动木块</a></h2>
<h2 id="空间结构"><a class="markdownIt-Anchor" href="#空间结构"></a> <a href="/2020/03/30/%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84/">空间结构</a></h2>
<h2 id="素数环"><a class="markdownIt-Anchor" href="#素数环"></a> <a href="/2020/03/30/%E7%B4%A0%E6%95%B0%E7%8E%AF/">素数环</a></h2>
<h2 id="编辑书稿"><a class="markdownIt-Anchor" href="#编辑书稿"></a> <a href="/2020/03/30/%E7%BC%96%E8%BE%91%E4%B9%A6%E7%A8%BF/">编辑书稿</a></h2>
<h2 id="缩点"><a class="markdownIt-Anchor" href="#缩点"></a> <a href="/2020/03/30/%E7%BC%A9%E7%82%B9/">缩点</a></h2>
<h2 id="网格动物"><a class="markdownIt-Anchor" href="#网格动物"></a> <a href="/2020/03/30/%E7%BD%91%E6%A0%BC%E5%8A%A8%E7%89%A9/">网格动物</a></h2>
<h2 id="联合国大楼"><a class="markdownIt-Anchor" href="#联合国大楼"></a> <a href="/2020/03/30/%E8%81%94%E5%90%88%E5%9B%BD%E5%A4%A7%E6%A5%BC/">联合国大楼</a></h2>
<h2 id="邮件传输代理的交互"><a class="markdownIt-Anchor" href="#邮件传输代理的交互"></a> <a href="/2020/03/30/%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E4%BB%A3%E7%90%86%E7%9A%84%E4%BA%A4%E4%BA%92/">邮件传输代理的交互</a></h2>
<h2 id="防线"><a class="markdownIt-Anchor" href="#防线"></a> <a href="/2020/03/30/%E9%98%B2%E7%BA%BF/">防线</a></h2>
<h2 id="集合栈计算机"><a class="markdownIt-Anchor" href="#集合栈计算机"></a> <a href="/2020/03/30/%E9%9B%86%E5%90%88%E6%A0%88%E8%AE%A1%E7%AE%97%E6%9C%BA/">集合栈计算机</a></h2>
<h2 id="颜色的长度"><a class="markdownIt-Anchor" href="#颜色的长度"></a> <a href="/2020/03/30/%E9%A2%9C%E8%89%B2%E7%9A%84%E9%95%BF%E5%BA%A6/">颜色的长度</a></h2>
<h2 id="黄金图形"><a class="markdownIt-Anchor" href="#黄金图形"></a> <a href="/2020/03/30/%E9%BB%84%E9%87%91%E5%9B%BE%E5%BD%A2/">黄金图形</a></h2>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>Tex中的引导</title>
    <url>/2020/03/30/Tex%E4%B8%AD%E7%9A%84%E5%BC%95%E5%AF%BC/</url>
    <content><![CDATA[<h1 id="tex-中的引导"><a class="markdownIt-Anchor" href="#tex-中的引导"></a> TEx 中的引导</h1>
<p>/*<br />
在TeX中，左双引号是“``”，有双引号是“’’”.输入一篇包<br />
含双引号的文章，你的任务是把它转换乘TeX的格式<br />
*/</p>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   #include&lt;iostream&gt;</span><br><span class="line">   #include&lt;cstring&gt;</span><br><span class="line">   #pragma warning(disable :4996)</span><br><span class="line">   &#x2F;&#x2F;# define LOCAL</span><br><span class="line">   int main() &#123;</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   	FILE *fin, *fout;</span><br><span class="line">   	fin &#x3D; freopen(&quot;Texin.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   	fout &#x3D; freopen(&quot;Texout.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif &#x2F;&#x2F; LOCAL</span><br><span class="line">&#x2F;&#x2F;本题特点是可以边读边写</span><br><span class="line">int c;&#x2F;&#x2F;c要定义为整型，因为文件结束会返回一个特殊标记EOF，它是一个整型；</span><br><span class="line">int p &#x3D; 1;</span><br><span class="line">while ((c &#x3D; getchar())!&#x3D; EOF) &#123;&#x2F;&#x2F;c&#x3D;getchar()一定要先括起来，因为等于和不等于同级，从右侧开始</span><br><span class="line">	if (c &#x3D;&#x3D; &#39;&quot;&#39;) &#123;</span><br><span class="line">		printf(&quot;%s&quot;, p ? &quot;&#96;&#96;&quot; : &quot;&#39;&#39;&quot;);</span><br><span class="line">		p &#x3D; !p;&#x2F;&#x2F;这个反转非常的灵性</span><br><span class="line">	&#125;</span><br><span class="line">	else printf(&quot;%c&quot;, c);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>UnixIS命令</title>
    <url>/2020/03/30/UnixIS%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="unix-is-命令"><a class="markdownIt-Anchor" href="#unix-is-命令"></a> unix is 命令</h1>
<p>输入正整数n 以及n个文件名，排序后按列优先的方式左对齐输出。假设最长文件名有M字符，则最右边有M字符，其他列都是M+2 字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  #include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">  # pragma warning(disable:4996)</span><br><span class="line">  # define LOCAL</span><br><span class="line">  # ifdef LOCAL</span><br><span class="line">  FILE *fin &#x3D; freopen(&quot;unix命令in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">  FILE *fout &#x3D; freopen(&quot;unix命令out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">  # endif &#x2F;&#x2F; LOCAL</span><br><span class="line">  using namespace std;</span><br><span class="line">  void print(const string &amp;in, int len, char extra) &#123;</span><br><span class="line">&#x2F;&#x2F;输出字符串s，长度不足len时补字符extra</span><br><span class="line">  	cout &lt;&lt; in;</span><br><span class="line">  	for (int i &#x3D; 0; i &lt; len - in.length(); i++) cout &lt;&lt; extra;</span><br><span class="line">  &#125;</span><br><span class="line">  int main() &#123;</span><br><span class="line">  	int n;</span><br><span class="line">  </span><br><span class="line">  	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">  		int m &#x3D; 0;</span><br><span class="line">  		print(&quot;&quot;, 60, &#39;-&#39;);</span><br><span class="line">  		cout &lt;&lt; endl;</span><br><span class="line">  		vector&lt;string&gt; s;</span><br><span class="line">  		for (int i &#x3D; 0; i &lt; n;i++) &#123;</span><br><span class="line">  			string in;</span><br><span class="line">  			cin &gt;&gt; in;</span><br><span class="line">  			s.push_back(in);</span><br><span class="line">  			m &#x3D; max(m, (int)in.length());</span><br><span class="line">  		&#125;</span><br><span class="line">  		sort(s.begin(), s.end());</span><br><span class="line">  </span><br><span class="line">  		&#x2F;*cout &lt;&lt; &quot;**********************************&quot; &lt;&lt; endl;</span><br><span class="line">  		for (int i &#x3D; 0; i &lt; s.size(); i++) cout &lt;&lt; s[i] &lt;&lt; endl;</span><br><span class="line">  		cout &lt;&lt; &quot;**********************************&quot; &lt;&lt; endl;*&#x2F;</span><br><span class="line">  		int cols &#x3D; (60 - m) &#x2F; (m + 2) + 1;</span><br><span class="line">  		int rows &#x3D; (n - 1) &#x2F; cols + 1;</span><br><span class="line">  		for (int r &#x3D; 0; r &lt; rows; r++) &#123;</span><br><span class="line">  			for (int c &#x3D; 0; c &lt; cols; c++) &#123;</span><br><span class="line">  				int idx &#x3D; c * rows + r;</span><br><span class="line">  				if (idx &lt; n) print(s[idx], c &#x3D;&#x3D; cols - 1 ? m : m + 2, &#39; &#39;);</span><br><span class="line">  			&#125;</span><br><span class="line">  			cout &lt;&lt; endl;</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables</title>
    <url>/2020/03/30/iptables/</url>
    <content><![CDATA[<h1 id="iptables-基础"><a class="markdownIt-Anchor" href="#iptables-基础"></a> iptables 基础</h1>
<p>iptables本身不是防火墙，可以理解为一个客户端代理，通过iptables来设定规则，最终运行在netfilter框架下。</p>
<h2 id="通信过程"><a class="markdownIt-Anchor" href="#通信过程"></a> 通信过程</h2>
<p>当客户端访问服务器的时候，客户端发送报文到网卡，通过内核的TCP协议传输到用户空间的web服务器中，而此时，客户端报文的目标终点为web服务所监听的套接字。当web服务需要相应客户端请求时，web服务发出的响应报文的目标终点为客户端。netfilter作为内核的一部分，所有进出的报文都要通过这些关卡。于是，就有了input和output关卡，在iptables中，这些关卡称为链。除了通往本机的链，还有PREROURING(路由前)、FORWARD(转发)、POSTROUTING(路由后)。</p>
<img src="/Iptables_img/29.png" style="zoom:80%">
<h2 id="链"><a class="markdownIt-Anchor" href="#链"></a> 链</h2>
<ol>
<li>防火墙的功能是对经过的报文匹配规则，然后执行对应的动作。对于每个关卡，都不止一条规则，故称为链。</li>
</ol>
<h2 id="表"><a class="markdownIt-Anchor" href="#表"></a> 表</h2>
<ol>
<li>表：我们把具有相同功能的规则的集合叫做表。</li>
<li>iptables预定义了四种表
<ol>
<li>filter表：负责过滤功能，防火墙；内核模块：iptables_filter</li>
<li>nat表：负责网络地址转换功能。内核模块：iptable_nat</li>
<li>mangle表：拆解报文，做出修改，并重新封装的功能；iptables_mangle</li>
<li>raw表：关闭nat表上启用的连接追踪机制；iptable_raw<br />
也就是说，我们自定义的所有规则都是这四种分类中的规则。</li>
</ol>
</li>
</ol>
<h2 id="表链关系"><a class="markdownIt-Anchor" href="#表链关系"></a> 表链关系</h2>
<ol>
<li>prerouting：规则存在于raw,mangle,nat.</li>
<li>INPUT:规则存在于mangle,filter.</li>
<li>FORWARD:规则存在于mangle,filter.</li>
<li>OUTPUT:规则存在于raw,mangle,nat,filter.</li>
<li>POSTROUTING:规则存在于mangle,nat.</li>
<li>实际使用中，往往以表为入口，对规则进行定义。</li>
<li>表链关系：<br />
<img src="/Iptables_img/31.png" style="zoom:80%"></li>
<li>表的优先级：raw&gt;mangle&gt;nat&gt;filter</li>
<li>我们也可以在某个表中创建自定义链，将针对某个应用程序所设置的规则放置在这个自定义链中，但是自定义链接不能直接使用，之恶能被某个默认的链当作动作去调用才能起作用。</li>
</ol>
<h2 id="数据经过防火墙的流程"><a class="markdownIt-Anchor" href="#数据经过防火墙的流程"></a> 数据经过防火墙的流程</h2>
<img src="/Iptables_img/32.png" style="zoom:80%">
<h2 id="规则"><a class="markdownIt-Anchor" href="#规则"></a> 规则</h2>
<ol>
<li>规则：根据指定的匹配条件来尝试匹配每个流经此处的报文，一旦匹配成功，则由规则后面指定的处理动作进行处理。</li>
</ol>
<h1 id="iptables实际操作之规则查询"><a class="markdownIt-Anchor" href="#iptables实际操作之规则查询"></a> iptables实际操作之规则查询</h1>
<ol>
<li><strong>命令</strong> iptables -t filter -L
<ol>
<li>-t指定要操作的表</li>
<li>-L列出规则</li>
</ol>
</li>
<li>如果我们要定义过滤规则，那么我们会在filter中定义，但是具体在那条链上实现，取决于我们的工作场景。</li>
<li>举例：
<ol>
<li>我们需要禁止某个IP地址访问我们的主机，我们则需要在INPUT链上定义规则</li>
</ol>
</li>
<li><strong>命令</strong> iptables -t filter -vL INPUT 查看详细信息
<ol>
<li>pkts 对应规则匹配到的报文的个数</li>
<li>bytes 对应匹配到的报文包的大小总和。</li>
<li>target 往往表示规则对应的动作，即匹配成功后需要采取的措施。</li>
<li>prot 表示规则对应的协议，是否只针对某些协议应用次规则。</li>
<li>opt 表示规则对应的选项。</li>
<li>in 表示数据包由哪个接口流入，我们可以设置通过哪块网卡流入的报文需要匹配当前规则。</li>
<li>out 表示数据包由哪个接口流出，我们可以设置通过哪块网卡流出的报文需要匹配当前规则。</li>
<li>source 表示规则对应的源地址，可以时一个IP，也可以是一个网段。</li>
<li>destination 表示规则对应的目的地址。可以是一个IP也可以是一个网段。</li>
</ol>
</li>
<li><strong>命令</strong> iptables -nvl INPUT不进行名称反解。</li>
<li><strong>命令</strong> iptables --line-number -nvL INPUT</li>
<li>命令小节<br />
<img src="/Iptables_img/33.png" style="zoom:80%"></li>
</ol>
<img src="/Iptables_img/34.png" style="zoom:80%">
<h1 id="iptables规则管理"><a class="markdownIt-Anchor" href="#iptables规则管理"></a> iptables规则管理</h1>
<ol>
<li><strong>命令</strong> iptables -F INPUT 清空规则</li>
<li><strong>如果报文已经被前面的规则匹配到，iptables则会对报文执行相应动作，即使后面的规则也能匹配到当前报文，也没有机会对报文执行修改</strong></li>
<li>使用修改指令的时候，如果我拒绝某个源地址发来的包，但是修改时又没有指定对应的源地址，那么源地址会自动编程0.0.0.0，如果是为远程服务器配置iptables，那么正在使用的链接也会和中断。</li>
<li>REGECT&amp;DROP
<ol>
<li>DROP丢弃而不返回，ping命令所在机器永远得不到回应</li>
<li>REGECT 返回拒绝，通知目的端不可达。</li>
</ol>
</li>
<li></li>
</ol>
<img src="/Iptables_img/35.png" style="zoom:80%">
<img src="/Iptables_img/36.png" style="zoom:80%">
<img src="/Iptables_img/37.png" style="zoom:80%">
<img src="/Iptables_img/38.png" style="zoom:80%">
<h1 id="匹配条件总结"><a class="markdownIt-Anchor" href="#匹配条件总结"></a> 匹配条件总结</h1>
<h2 id="-s参数匹配源地址"><a class="markdownIt-Anchor" href="#-s参数匹配源地址"></a> -s参数：匹配源地址</h2>
<ol>
<li>可以是由逗号隔开的多个参数</li>
<li>可以通过指定子网掩码来指定某个网段</li>
<li>可以对某个地址取反，达到白（黑）名单的目的。但是存在问题，比如链上规则设定为不是某个源即进行-j操作；如果是，则继续匹配其他条件（都不匹配，则执行默认操作）。</li>
</ol>
<h2 id="-d参数匹配目的地址"><a class="markdownIt-Anchor" href="#-d参数匹配目的地址"></a> -d参数：匹配目的地址</h2>
<p><strong>取反操作与同时指定多个IP的操作不能同时使用</strong></p>
<h2 id="-p参数匹配协议类型"><a class="markdownIt-Anchor" href="#-p参数匹配协议类型"></a> -p参数：匹配协议类型</h2>
<ol>
<li>
<p>例如拒绝tcp请求</p>
<p>iptables -I INPUT -s 192.168.1.146 -d 192.168.1.156 -p tcp -j REJECT</p>
<p>使用ssh链接测试</p>
</li>
<li>
<p>-p支持的协议类型：</p>
<ol>
<li>tcp,udp,udplite,icmp,icmpv6,esp,ah,sctp,mh</li>
<li>缺省形况下，默认为-p all</li>
</ol>
</li>
</ol>
<h2 id="-i参数匹配流入的网卡-o匹配流出的网卡"><a class="markdownIt-Anchor" href="#-i参数匹配流入的网卡-o匹配流出的网卡"></a> -i参数：匹配流入的网卡 -o匹配流出的网卡</h2>
<ol>
<li>通过ifconfig查询</li>
<li>-i 网卡名 来指定匹配</li>
<li>只能用来判断流入的包，故用于
<ol>
<li>ROUTING 链</li>
<li>INPUT 链</li>
<li><strong>FORWARD 链</strong></li>
</ol>
</li>
<li>-o 用于匹配报文从哪个网卡流出，用于
<ol>
<li>OUTPUT 链</li>
<li><strong>FORWARD 链</strong></li>
<li>POSTROUTING 链</li>
</ol>
</li>
</ol>
<h2 id="-dport-扩展目的端口"><a class="markdownIt-Anchor" href="#-dport-扩展目的端口"></a> -dport 扩展目的端口</h2>
<ol>
<li>dport(destination-port)
<ol>
<li><strong>使用dport之前必须先使用-p选项</strong></li>
<li>之后使用-m指定扩展模块，缺省情况下，默认为于-p指定的协议同名。</li>
<li>最后，使用-dport指定目标端口</li>
</ol>
</li>
</ol>
<h2 id="-sport匹配源端口"><a class="markdownIt-Anchor" href="#-sport匹配源端口"></a> -sport:匹配源端口</h2>
<ol>
<li>不管是sport还是dport都可以指定端口范围，如22：25</li>
<li>multiport模块：
<ol>
<li>若要指定离散的端口，需要借助multiport模块。端口号间以逗号隔开。并且，这些端口中可以包含连续端口号。</li>
<li><strong>只有tcp,udp可以使用</strong></li>
</ol>
</li>
</ol>
<p>##<a href="%22http://www.zsythink.net/archives/1544%22">基本匹配条件总结</a></p>
<p>#<a href="%22http://www.zsythink.net/archives/1564%22">常用扩展模块</a></p>
<h2 id="iprange-扩展模块"><a class="markdownIt-Anchor" href="#iprange-扩展模块"></a> iprange 扩展模块</h2>
<ol>
<li>用于指定一系列连续的ip。包括–src-range,–dst-range。</li>
</ol>
<h2 id="string-扩展模块"><a class="markdownIt-Anchor" href="#string-扩展模块"></a> string 扩展模块</h2>
<ol>
<li>
<p>用于匹配含有某一个字符串的报文。</p>
<p>iptables -t filter -I INPUT -m string --algo bm --string “OOXX” -j REJECT</p>
<ol>
<li>-m 用于指定模块</li>
<li>–algo bm 表示用bm算法匹配。</li>
</ol>
</li>
</ol>
<h2 id="time-扩展模块"><a class="markdownIt-Anchor" href="#time-扩展模块"></a> time 扩展模块</h2>
<ol>
<li>
<p>用于限制时间</p>
<p>iptables -t filter -I OUTPUT -p tcp -dport 80 -m time --timestart 09:00:00 --timestop 18:00:00 -j REJECT</p>
<ol>
<li>可以使用timestart 和timestop 来指定起止时间。也可以通过weekdays 来指定某一天,多个天之间通过逗号隔开。也可以结合使用。</li>
<li>此外还有monthdays,datestart和datestop</li>
</ol>
</li>
</ol>
<h2 id="connlimit-扩展模块"><a class="markdownIt-Anchor" href="#connlimit-扩展模块"></a> connlimit 扩展模块</h2>
<ol>
<li>
<p>用于限制每个IP地址同时连接到server的数量。</p>
<p>iptables -I INPUT -p tcp --dport 803 -m connlimit --connlimit-above 2 -j REJECT</p>
<ol>
<li>限制每个IP最多只能让两个ssh连接到server。</li>
</ol>
</li>
<li>
<p>其实还可以配合–connlimit-mask去限制某类网段的链接数量</p>
<p>iptables -I INPUT -p tcp --dport 22 -m conlimit --connlimit-above 2 --connlimit-mask 24 -j REJECT</p>
</li>
</ol>
<h2 id="limit-扩展模块"><a class="markdownIt-Anchor" href="#limit-扩展模块"></a> limit 扩展模块</h2>
<p>对报文到达速率进行限制，即限制单位时间内流入的包的数量。</p>
<ol>
<li>iptables -t filter -I INPUT -p icmp -m limit --limit 10/minute -j ACCEPT</li>
</ol>
<p>表示每分钟最多放10个包，相当于每6秒最多放一个包。<br />
然而这样遂率并没有变，是因为第六秒的报文确实被策略匹配到了，于是执行了放行操作，但是6秒钱的报文没有被匹配到，于是自动执行默认策略，也是放行。<br />
<strong>修改</strong>：iptables -t filter -A INPUT -p icmp -j REJECT</p>
<ol start="2">
<li>
<p>–limit-burst 选项用于指明空闲时放行包的数量，默认为5.</p>
</li>
<li>
<p>limit模块工作原理：令牌桶算法<br />
想象有一个木桶，里面放了5块令牌，且目前这个桶中最多只能存放5个令牌。所有报文想要出关入关，都必须持有木桶中的令牌，这个木桶可以每6秒生成一个新的令牌。此时，如果桶已经满了，那么新生成的令牌就被丢弃。假设现在有五个报文想要进入，那么这5个报文就会去桶中找令牌，正好一人一个。此时，如果再有令牌想要进入，则没有对应的令牌可以使用。如果长时间没有人使用令牌，令牌桶中又出现了5枚令牌，也就是所谓的空闲。</p>
</li>
</ol>
<p>#<a href="%22http://www.zsythink.net/archives/1578%22">iptables 扩展匹配条件 -tcp-flags</a></p>
<p>用于匹配tcp头部的标志位，然后根据标识位的实时情况进行实时访问控制功能。</p>
<ol>
<li>
<p>iptables -t filter -I INPUT -p tcp -m tcp --dport 22 --tcp-flags SYN,ACK,FIN,RST,URG,PSH SYN -j REJECT</p>
<ol>
<li>SYN,ACK,FIN,RST,URG,PSH 表示需要匹配报文tcp头部的标志位列表</li>
<li>第二个SYN处表示，要求为1的标志位列表。不出现的标志位必须为0。</li>
<li>这条命令是拒绝tcp第一次链接。</li>
<li>可以使用-syn代替这一段。</li>
</ol>
</li>
<li>
<p>iptables -t filter -I INPUT -p tcp -m tcp --dport 22 --tcp-flags SYN,ACK,FIN,RST,URG,PSH SYN，ACK -j REJECT</p>
</li>
</ol>
<p>#<a href="%22http://www.zsythink.net/archives/1588%22">iptables udp扩展与icmp扩展</a></p>
<h2 id="udp-扩展"><a class="markdownIt-Anchor" href="#udp-扩展"></a> udp 扩展</h2>
<ol>
<li>iptables -t filter -I INPUT -p udp -m udp --dport 137 -j ACCEPT
<ol>
<li>137为端口号，samba服务的端口为137，138</li>
<li>可以指定连续的端口号 137:157</li>
</ol>
</li>
</ol>
<h2 id="icmp-扩展"><a class="markdownIt-Anchor" href="#icmp-扩展"></a> icmp 扩展</h2>
<img src="/Iptables_img/51.png" style="zoom:80%">
<ol>
<li>
<p>可以指定匹配的类型和code</p>
<p>iptables -t filter -I INPUT -p icmp -m icmp --icmp-type3/1 -j REJECT</p>
<p>表示拒绝主机不可达报文</p>
</li>
<li>
<p>还可以用icmp报文的描述名称去匹配对应类型的报文</p>
<p>iptables -t filter -I INPUT -p icmp --icmp-type “echo-request” -j REJECT</p>
</li>
</ol>
<p>#<a href="%22http://www.zsythink.net/archives/1597%22">iptables 扩展模块 state</a></p>
<p>当我们访问http时，需要放行80端口以便能够与服务端进行通信。进行ssh链接时，需要打开22端口。然而，这样并不安全，攻击者可以利用这些端口主动和我建立链接。使用state可以实现链接追踪功能。</p>
<h2 id="state基本概念"><a class="markdownIt-Anchor" href="#state基本概念"></a> state基本概念</h2>
<ol>
<li>连接：在state模块中，认为两台机器在你来我往的通信就算建立了连接。</li>
<li>连接状态包括：NEW,ESTABLISHED,RELATED,INVALID,UNTRACKED</li>
</ol>
<h2 id="指令"><a class="markdownIt-Anchor" href="#指令"></a> 指令</h2>
<ol>
<li>iptables -t filter -I INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
<ol>
<li>只有回应我们的报文能够通过防火墙。</li>
</ol>
</li>
</ol>
<p>#<a href="%22http://www.zsythink.net/archives/1604%22">iptables的黑白名单机制</a></p>
<ol>
<li>黑名单：链中设置规则的动作为drop或reject，默认动作是ACCEPT，那么匹配到规则的报文会被拒绝。</li>
<li>白名单：默认规则是DROP，链中规则的动作是ACCEPT，则被匹配到的报文才会放行，即白名单机制。</li>
</ol>
<h2 id="白名单"><a class="markdownIt-Anchor" href="#白名单"></a> 白名单</h2>
<p>#iptables -P INPUT DROP</p>
<p>#iptables -I INPUT -p tcp --dport 22 -j ACCEPT</p>
<p>#iptables -I INPUT -p tcp<br />
–dport 80 -j ACCEPT</p>
<ol>
<li>注意-F选项只是将链中规则情况，此处修改了默认规则，所以即使-F也会DROP；</li>
<li><strong>改进</strong>：将链的设置保持为ACCEPT，然后将拒绝所有请求的规则放在链尾，将放行规则放在签名，这样既实现了白名单，又保证规则清空时，管理员能够连接到主机。</li>
</ol>
<p>#iptables -I INPUT -p tcp --dport 22 -j ACCEPT</p>
<p>#iptables -I INPUT -p tcp --dport 80 -j ACCEPT</p>
<p># iptables -A INPUT -j REJECT</p>
<p>#<a href="%22http://www.zsythink.net/archives/1625%22">iptables 自定义链</a></p>
<p>由于默认链的规则非常 多，不便于管理，所以引入自定义链。</p>
<h2 id="创建自定义链"><a class="markdownIt-Anchor" href="#创建自定义链"></a> 创建自定义链</h2>
<ol>
<li>iptables -t filter -N IN_WEB</li>
</ol>
<h2 id="使用自定义链"><a class="markdownIt-Anchor" href="#使用自定义链"></a> 使用自定义链</h2>
<ol>
<li>必须被默认链引用</li>
<li>iptables -I INPUT -p tcp --dport 80 -j IN WEB</li>
<li>自定义链也可以引用其他的自定义链</li>
</ol>
<h2 id="自定义链重命名"><a class="markdownIt-Anchor" href="#自定义链重命名"></a> 自定义链重命名</h2>
<p>iptables -E IN_WEB WEB</p>
<h2 id="删除自定义链"><a class="markdownIt-Anchor" href="#删除自定义链"></a> 删除自定义链</h2>
<ol>
<li>如果被引用，则要iptables -D INPUT 1</li>
<li>如果链种含有规则，则要Iptables -t filter -F WEB</li>
<li>iptables -X WEB</li>
</ol>
<p>#<a href="%22http://www.zsythink.net/archives/1663%22">网络防火墙</a></p>
<ol>
<li>定义：处于网络入口或边缘，针对于网络入口进行防护，服务于防火墙背后的本地局域网。主要任务时过滤并转发。</li>
<li>涉及：INPUT,OUTPUT,FORWARD</li>
</ol>
<h2 id="环境准备"><a class="markdownIt-Anchor" href="#环境准备"></a> 环境准备</h2>
<ol>
<li>
<p>PC1：</p>
<ol>
<li>192.18.33.33</li>
<li>route add -net 192.18.22.0/24 gw 192.18.33.251</li>
</ol>
</li>
<li>
<p>PC2:</p>
<ol>
<li>192.18.22.22</li>
<li>route add -net 192.18.33.0/24 gw 192.18.22.251</li>
</ol>
</li>
<li>
<p>r1:</p>
<ol>
<li>ens33:192.18.33.251</li>
<li>ens37:192.18.22.251</li>
<li>cat /proc/sys/net/ipv4/ip_forward 来查看是否支持转发功能。</li>
<li>每次需要echo 1 &gt; /proc/sys/net/ipv4/ip_forward来开启转发功能</li>
</ol>
</li>
</ol>
<p>#<a href="%22http://www.zsythink.net/archives/1684%22">iptables 动作总结</a></p>
<h2 id="reject"><a class="markdownIt-Anchor" href="#reject"></a> REJECT</h2>
<ol>
<li>–reject-with :提示拒绝原因。包括：
<ol>
<li>icmp-net-unreachable</li>
<li>icmp-host-unreachable</li>
<li>icmp-port-unreachable</li>
<li>icmp-proto-unreachable(默认)</li>
<li>icmp-net-prohibited</li>
<li>icmp-host-pro-hibited</li>
<li>icmp-admin-prohibited</li>
</ol>
</li>
</ol>
<h2 id="log"><a class="markdownIt-Anchor" href="#log"></a> LOG</h2>
<ol>
<li>
<p>LOG 可以将符合条件的报文的相关信息记录到日志中。可以在后面设置具体规则对报文进一步处理。</p>
</li>
<li>
<p>可以通过tail -f /var/log/messages 来查看。</p>
</li>
<li>
<p>–log-level 来指定日志的日志级别。包括</p>
<ol>
<li>emerg</li>
<li>alert</li>
<li>crit</li>
<li>error</li>
<li>warning</li>
<li>notice</li>
<li>info</li>
<li>debug</li>
</ol>
</li>
<li>
<p>–log-prefix 来给记录到的相关信息添加标签之类的信息，以区分各种记录到的报文。</p>
</li>
</ol>
<p>iptables -I INPUT -p tcp --dport 80 -m state --state NEW -j LOG --log-prefix “want-in-from-22”<br />
#<a href="%22http://www.zsythink.net/archives/1764%22">iptables 动作总结2</a></p>
<h2 id="snat"><a class="markdownIt-Anchor" href="#snat"></a> SNAT</h2>
<p>iptables -t nat -A POSTROUTING -s 192.18.0.0/16 -j SNAT --to-source 192.18.33.251</p>
<ol>
<li>其中-A 标识将snat规则添加到POSTROUTING链的末尾。POSTROUTING可以认为是报文发出的最后一个关卡。</li>
<li>-j SNAT表示对匹配到的报文进行源地址转换。</li>
<li>–to-source表示转换成这个源</li>
</ol>
<h2 id="dnat"><a class="markdownIt-Anchor" href="#dnat"></a> DNAT</h2>
<p>按端口进行转发</p>
<ol>
<li>
<p>iptables -t nat -I PREROUTING -d 192.18.33.251 -p tcp --dport 801 -j DNAT --to-destination 192.18.22.22:80</p>
</li>
<li>
<p>注：开启端口/sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT</p>
</li>
</ol>
<h2 id="masquerade"><a class="markdownIt-Anchor" href="#masquerade"></a> MASQUERADE</h2>
<p>动态的将源地址转换为可用的IP地址。类似于SNAT而无需指明修改成哪个IP，可以适应动态变化。</p>
<ol>
<li>iptables -t nat -I POSTROUTING -s 192.18.0.0/16 -o ens33 -j MASQUERADE</li>
</ol>
<h2 id="redirect"><a class="markdownIt-Anchor" href="#redirect"></a> REDIRECT</h2>
<p>可以将本机端口进行映射。</p>
<ol>
<li>iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 801</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>不公平竞赛</title>
    <url>/2020/03/30/%E4%B8%8D%E5%85%AC%E5%B9%B3%E7%AB%9E%E8%B5%9B/</url>
    <content><![CDATA[<h1 id="uva-1609-不公平竞赛"><a class="markdownIt-Anchor" href="#uva-1609-不公平竞赛"></a> UVA 1609 不公平竞赛</h1>
<p>n支队伍(2≤n≤1024,且n是2的整数幂)打淘汰赛，每轮都是两两配对，胜者进入下一轮，如PDF中的图所示。</p>
<p>每支队伍的实力固定，并且已知每两支队伍之间的一场比赛结果（“实力固定”是指：例如，队伍1曾经胜过队伍2，则二者在今后的交锋中队伍1总获胜）。你喜欢1号队。虽然它不一定是最强的，但是它可以直接打败其他队伍中至少一半，并且对于每支1号队不能直接打败的队伍t，总是存在一支1号队能直接打败的队伍t’使得t’能直接打败t。问是否存在一种比赛安排，使得1号队夺冠？</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>要想让1队获胜，就要让所有1打不过的t与1能打过的t’先进行比赛(t’能打过t)。每一轮比赛的过程安排分一下三步（其中黑队表示1打不过的队伍，灰队表示1能打过的队伍，灰队中不都能打过黑队）</li>
<li>首先，尽量给所有的黑队匹配灰队，要求匹配的灰队能打赢黑队。打赢的灰队直接进入下一轮待用；没有匹配的黑队留在final中，看看有没有剩下的黑队能内斗一下</li>
<li>之后，给1队分配一个灰队。并将剩余的没用到的灰队放入final中待用</li>
<li>最后final中队伍任意配对即可。因为final中的黑队全都强于灰队，而胜出的黑队到底是哪一个并不重要。</li>
<li>这样做是对的，这是因为
<ol>
<li>起初1队能战胜一半的队伍，当循环一轮之后，总队伍数减少一半，黑队数也至少减少一半(自相残杀阶段),所以条件仍满足。</li>
<li>步骤1中灰色队伍联合起来可以打败所有黑色队伍，而这些灰队全部晋级，所以这样做一定有解</li>
</ol>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="main-统计初始灰队和黑队注意不要把1队算进去"><a class="markdownIt-Anchor" href="#main-统计初始灰队和黑队注意不要把1队算进去"></a> main 统计初始灰队和黑队，注意不要把1队算进去</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1024 + 5;</span><br><span class="line">char team[maxn][maxn];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; black;</span><br><span class="line">vector&lt;int&gt; gray;</span><br><span class="line"></span><br><span class="line">void solve();</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%s&quot;, team[i]+1);</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 2; i &lt;&#x3D; n; i++)</span><br><span class="line">			if (team[1][i] &#x3D;&#x3D; &#39;0&#39;)</span><br><span class="line">				black.push_back(i);</span><br><span class="line">			else gray.push_back(i);</span><br><span class="line"></span><br><span class="line">		solve();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="solve-执行三个阶段"><a class="markdownIt-Anchor" href="#solve-执行三个阶段"></a> solve 执行三个阶段</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line"></span><br><span class="line">	while (n &gt; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		vector&lt;int&gt; tgray;</span><br><span class="line">		vector&lt;int&gt; tblack;</span><br><span class="line">		vector&lt;int&gt; final;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;U1</span><br><span class="line">		for (int i &#x3D; 0; i &lt; black.size(); i++) &#123;</span><br><span class="line">			int nb &#x3D; black[i];</span><br><span class="line">			int graywin &#x3D; false;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; gray.size(); j++) &#123;</span><br><span class="line">				int &amp;ng &#x3D; gray[j];</span><br><span class="line">				if (ng &gt; 0 &amp;&amp; team[ng][nb] &#x3D;&#x3D; &#39;1&#39;) &#123;</span><br><span class="line">					printf(&quot;%d %d\n&quot;, ng, nb);</span><br><span class="line">					tgray.push_back(ng);</span><br><span class="line">					ng &#x3D; 0;</span><br><span class="line">					graywin &#x3D; true;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (!graywin) final.push_back(nb);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;U2</span><br><span class="line">		bool first &#x3D; true;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; gray.size(); i++) &#123;</span><br><span class="line">			int ng &#x3D; gray[i];</span><br><span class="line">			if (ng &gt; 0) &#123;</span><br><span class="line">				if (first) &#123;</span><br><span class="line">					printf(&quot;1 %d\n&quot;, ng);</span><br><span class="line">					first &#x3D; false;</span><br><span class="line">				&#125;</span><br><span class="line">				else final.push_back(ng);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;U3</span><br><span class="line">		for (int i &#x3D; 0; i &lt; (int)final.size(); i +&#x3D; 2) &#123;</span><br><span class="line">			printf(&quot;%d %d\n&quot;, final[i], final[i + 1]);</span><br><span class="line">			int keep &#x3D; final[i];</span><br><span class="line">			if (team[final[i + 1]][keep] &#x3D;&#x3D; &#39;1&#39;)</span><br><span class="line">				keep &#x3D; final[i + 1];</span><br><span class="line">			if (team[1][keep] &#x3D;&#x3D; &#39;1&#39;)</span><br><span class="line">				tgray.push_back(keep);</span><br><span class="line">			else tblack.push_back(keep);</span><br><span class="line">		&#125;</span><br><span class="line">		black &#x3D; tblack;</span><br><span class="line">		gray &#x3D; tgray;</span><br><span class="line">		n &gt;&gt;&#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>不无聊的序列</title>
    <url>/2020/03/30/%E4%B8%8D%E6%97%A0%E8%81%8A%E7%9A%84%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="uva-1608-不无聊的序列"><a class="markdownIt-Anchor" href="#uva-1608-不无聊的序列"></a> UVA 1608 不无聊的序列</h1>
<p>如果一个序列的任意连续子序列都至少有一个元素唯一，则称这个序列“不无聊”，否则称这个序列“无聊”。给定T个序列，求是否“无聊”。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>分治加中途相遇</li>
<li>如果在序列中A[i]只出现了一次，那么只需检查A[1…P-1]和A[p+1…n]是否满足条件。这是因为所有包含A[p]的子序列都是符合条件的，不需要检查。</li>
<li>想要直到每个元素值是否在区间内不重，可以记录这个值临近的两个值的出现位置，并与区间端点比较。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="main-填充pre和next数组"><a class="markdownIt-Anchor" href="#main-填充pre和next数组"></a> main 填充pre和next数组</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 200000 + 5;</span><br><span class="line">int n;</span><br><span class="line">int a[maxn];</span><br><span class="line">int pre[maxn], nex[maxn];</span><br><span class="line">map&lt;int, int&gt; last;</span><br><span class="line">inline bool unique(int L, int r, int v);</span><br><span class="line">bool bsearch(int l, int r);</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	int x;</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		last.clear();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">			a[i] &#x3D; x;</span><br><span class="line">			if (!last.count(x))</span><br><span class="line">				pre[i] &#x3D; -1;</span><br><span class="line">			else</span><br><span class="line">				pre[i] &#x3D; last[x];</span><br><span class="line">			last[x] &#x3D; i;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		last.clear();</span><br><span class="line">		for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			if (!last.count(a[i]))</span><br><span class="line">				nex[i] &#x3D; n;</span><br><span class="line">			else nex[i] &#x3D; last[a[i]];</span><br><span class="line">			last[a[i]] &#x3D; i;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (bsearch(0, n - 1)) printf(&quot;non-boring\n&quot;);</span><br><span class="line">		else printf(&quot;boring\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="solve-中途相遇过程注意循环和递归条件"><a class="markdownIt-Anchor" href="#solve-中途相遇过程注意循环和递归条件"></a> solve 中途相遇过程，注意循环和递归条件</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool bsearch(int l, int r) &#123;</span><br><span class="line">	if (l &gt;&#x3D; r)  return true;</span><br><span class="line">	for (int d &#x3D; 0; l + d &lt;&#x3D; r - d; d++) &#123;</span><br><span class="line">		if (unique(l, r, l + d))</span><br><span class="line">			return bsearch(l, l + d - 1) &amp;&amp; bsearch(l + d + 1, r);</span><br><span class="line"></span><br><span class="line">		if (l + d &#x3D;&#x3D; r - d) break;</span><br><span class="line"></span><br><span class="line">		if (unique(l, r, r - d))</span><br><span class="line">			return bsearch(l, r - d - 1) &amp;&amp; bsearch(r - d + 1, r);</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="unique-判断区间内是否有重复"><a class="markdownIt-Anchor" href="#unique-判断区间内是否有重复"></a> unique 判断区间内是否有重复</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool unique(int L, int R, int v) &#123;</span><br><span class="line">	return L &gt; pre[v] &amp;&amp; R &lt; nex[v];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>万圣节后的早晨</title>
    <url>/2020/03/30/%E4%B8%87%E5%9C%A3%E8%8A%82%E5%90%8E%E7%9A%84%E6%97%A9%E6%99%A8/</url>
    <content><![CDATA[<h1 id="uva-1601-万圣节后的早晨"><a class="markdownIt-Anchor" href="#uva-1601-万圣节后的早晨"></a> UVA 1601 万圣节后的早晨</h1>
<p>w h （w, h &lt;= 16)的网格有 n （ n &lt;= 3) 个小写字母（代表鬼）其余的是‘# ’（代表障碍格） 或 ‘ ’（代表空格。 要求把他们移动到对应的大写字母里。每步可以有多少个鬼同时移动（均为上下左右4个移动方向之一）， 但每步移动两个鬼不能占用同一个位置， 也不能在一步之内交换位置。输入保证空格联通，障碍联通，且在2 2子网格中至少有一个障碍格，并且最外面一层是障碍格。输入保证有解。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>是隐式图最短路径问题，通过bfs求解最短路径即可。</li>
<li>由于鬼的数量不大于3，所以统一按照3个鬼的情况编程。两个鬼看作是第三个一直不动；一个鬼同理。</li>
<li>问题主要在于有三个点，状态如何保存？访问标志如何保存？</li>
<li>由于题中说每2*2的小格中必有障碍，暗示了可移动的位置是少数，所以给空白格建立一张图。</li>
<li>通过一个索引值cnt来连接空白格的坐标，用x[cnt],y[cnt]来表示第cnt个非障碍格的坐标;用id[i][j]=cnt来记录每个位置的索引值。</li>
<li>建立空白格图，在每个空白格处可移动的空白格必然是其他的空白格。用blank[cnt][num_blank[cnt]] = id[x][y]来表示索引为cnt的空白格处可移动的方向中第num_blank[cnt]个的目的格的索引值。</li>
<li>由于本题中的图比较小，所以可以开三维数组来标记访问。此外可以使用哈希函数，编码或者set的方法来判重。本题中出入队列的值即是通过编码得到。</li>
<li>应该关注ID函数、索引值的写法、多个值同时改变构成新状态的做法。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 20;</span><br><span class="line">int id[maxn][maxn];</span><br><span class="line">int s[3], t[3];</span><br><span class="line">char g[maxn][maxn];</span><br><span class="line"></span><br><span class="line">int blank[maxn*maxn][5];</span><br><span class="line">int dist[maxn*maxn][maxn*maxn][maxn*maxn];</span><br><span class="line">int num_blank[maxn*maxn];</span><br><span class="line">int r, c, w;</span><br><span class="line"></span><br><span class="line">int dx[] &#x3D; &#123; 0, -1, 1, 0, 0 &#125;;</span><br><span class="line">int dy[] &#x3D; &#123; 0, 0, 0, -1, 1 &#125;;</span><br><span class="line">inline void read_in();</span><br><span class="line">inline int bfs();</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">while (~scanf(&quot;%d %d %d\n&quot;, &amp;c, &amp;r, &amp;w) &amp;&amp; w)</span><br><span class="line">&#123;</span><br><span class="line">	read_in();</span><br><span class="line">	printf(&quot;%d\n&quot;, bfs());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="read_in"><a class="markdownIt-Anchor" href="#read_in"></a> read_in</h2>
<p>读入数据，并用数组记录鬼的初始位置和目标位置。之后，给空白建图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">inline void read_in() &#123;</span><br><span class="line">int x[maxn*maxn];</span><br><span class="line">int y[maxn*maxn];</span><br><span class="line">for (int i &#x3D; 0; i &lt; r; i++) fgets(g[i], 20, stdin);</span><br><span class="line">int cnt &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; r; i++)</span><br><span class="line">	for (int j &#x3D; 0; j &lt; c; j++) &#123;</span><br><span class="line">		if (g[i][j] !&#x3D; &#39;# &#39;) &#123;</span><br><span class="line">			x[cnt] &#x3D; i;</span><br><span class="line">			y[cnt] &#x3D; j;</span><br><span class="line">			id[i][j] &#x3D; cnt;</span><br><span class="line">			if (islower(g[i][j])) s[g[i][j] - &#39;a&#39;] &#x3D; cnt;</span><br><span class="line">			else if (isupper(g[i][j])) t[g[i][j] - &#39;A&#39;] &#x3D; cnt;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;记录每个空白处可以走的方向</span><br><span class="line">for (int i &#x3D; 0; i &lt; cnt; i++) &#123;</span><br><span class="line">	num_blank[i] &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F;四个正方向加不动</span><br><span class="line">	for (int k &#x3D; 0; k &lt; 5; k++) &#123;</span><br><span class="line">		int nx &#x3D; x[i] + dx[k];</span><br><span class="line">		int ny &#x3D; y[i] + dy[k];</span><br><span class="line">		if (g[nx][ny] !&#x3D; &#39;# &#39;)</span><br><span class="line">			blank[i][num_blank[i]++] &#x3D; id[nx][ny];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果少于三个鬼，令另外的不动，初始位置等于末位置。</span><br><span class="line">if (w &lt;&#x3D; 2) &#123; num_blank[cnt] &#x3D; 1; blank[cnt][0] &#x3D; cnt; s[2] &#x3D; t[2] &#x3D; cnt++; &#125;</span><br><span class="line">if (w &lt;&#x3D; 1) &#123; num_blank[cnt] &#x3D; 1; blank[cnt][0] &#x3D; cnt; s[1] &#x3D; t[1] &#x3D; cnt++; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> bfs</h2>
<p>进行广度搜索，利用二进制法存储状态，沿途更新到达每个状态的步数，当走到目标状态时退出循环。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">inline int bfs() &#123;</span><br><span class="line">memset(dist, -1, sizeof(dist));</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(ID(s[0], s[1], s[2]));</span><br><span class="line">dist[s[0]][s[1]][s[2]] &#x3D; 0;</span><br><span class="line">while (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">	int u &#x3D; q.front(); q.pop();</span><br><span class="line">	int a &#x3D; (u &gt;&gt; 16) &amp; 0xff, b &#x3D; (u &gt;&gt; 8) &amp; 0xff, c &#x3D; u &amp; 0xff;</span><br><span class="line">	if (a &#x3D;&#x3D; t[0] &amp;&amp; b &#x3D;&#x3D; t[1] &amp;&amp; c &#x3D;&#x3D; t[2])</span><br><span class="line">		return dist[a][b][c];</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; num_blank[a]; i++) &#123;</span><br><span class="line">		int a2 &#x3D; blank[a][i];</span><br><span class="line">		for (int j &#x3D; 0; j &lt; num_blank[b]; j++) &#123;</span><br><span class="line">			int b2 &#x3D; blank[b][j];</span><br><span class="line">			if (!isOk(a, a2, b, b2)) continue;</span><br><span class="line"></span><br><span class="line">			for (int k &#x3D; 0; k &lt; num_blank[c]; k++) &#123;</span><br><span class="line">				int c2 &#x3D; blank[c][k];</span><br><span class="line">				if (!isOk(a, a2, c, c2) || !isOk(b, b2, c, c2)) continue;</span><br><span class="line"></span><br><span class="line">				if (dist[a2][b2][c2] &#x3D;&#x3D; -1) &#123;</span><br><span class="line">					dist[a2][b2][c2] &#x3D; dist[a][b][c] + 1;</span><br><span class="line">					q.push(ID(a2, b2, c2));</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="id-对二进制编码状态进行解码"><a class="markdownIt-Anchor" href="#id-对二进制编码状态进行解码"></a> ID 对二进制编码状态进行解码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">inline int ID(int a, int b, int c) &#123;</span><br><span class="line">return (a &lt;&lt; 16) | (b &lt;&lt; 8) | c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="isok-判断两个鬼是否占据同一个位置或者在一步之内交叉"><a class="markdownIt-Anchor" href="#isok-判断两个鬼是否占据同一个位置或者在一步之内交叉"></a> isOk 判断两个鬼是否占据同一个位置或者在一步之内交叉</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">inline bool isOk(int a1, int a2, int b1, int b2) &#123;</span><br><span class="line">return a2 !&#x3D; b2 &amp;&amp; !(a2 &#x3D;&#x3D; b1 &amp;&amp; b2 &#x3D;&#x3D; a1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>iSql</title>
    <url>/2020/06/16/iSql/</url>
    <content><![CDATA[<h1 id="my-small-sql-parser"><a class="markdownIt-Anchor" href="#my-small-sql-parser"></a> My Small Sql Parser</h1>
<ol>
<li>按照mysql语法实现的简易sql解释器，支持基本CRUD操作、支持AND, OR, NOT，支持WHERE子句中插入算数运算。不支持多表连接查询，事务等高级特性。</li>
<li>词法分析使用lex，语法分析使用yacc，语义动作处理使用C++编写</li>
<li>操作平台为 VS2019+Parser Generator</li>
<li>源码间仓库https://github.com/Cccceb/No3.second/tree/master/MySSql</li>
</ol>
<h1 id="测试1"><a class="markdownIt-Anchor" href="#测试1"></a> 测试1</h1>
<p><em><strong>测试CREATE DATABASE SHOW DATABASES DROP DATABASE USE DATABASE*</strong></em></p>
<p><em><strong>*输入：********CREATE DATABASE XJGL;*</strong></em></p>
<p><em><strong>*CREATE DATABASE JUST_FOR_TEST;*</strong></em></p>
<p><em><strong>*CREATE DATABASE JUST_FOR_TEST;*</strong></em></p>
<p><em><strong>*SHOW DATABASE;*</strong></em></p>
<p><em><strong>*DROP DATABASE JUST_FOR_TEST;*</strong></em></p>
<p><em><strong>*SHOW DATABASE;*</strong></em></p>
<p><em><strong>*USE XJGL;*</strong></em></p>
<p><em><strong>*输出********：*</strong></em></p>
<p><img src="/MyImages/wps1-1592281234789.jpg" alt="img" /></p>
<h1 id="测试2"><a class="markdownIt-Anchor" href="#测试2"></a> 测试2</h1>
<p><em><strong>*测试CREATE TABLE SHOW TABLES DROP TABLE*</strong></em></p>
<p><em><strong>*输入*</strong></em></p>
<p><em><strong>*CREATE TABLE STUDENT(SNAME CHAR(20),SAGE INT,SSEX INT);CREATE TABLE*</strong></em> 	<em><strong>*COURSE(CNAME CHAR(20),CID INT);*</strong></em></p>
<p><em><strong>*CREATE TABLE CS(SNAME CHAR(20),CID INT);*</strong></em></p>
<p><em><strong>*CREATE TABLE TEST_TABLE(COL1 CHAR(22),COL2 INT,COL3 CHAR(22));*</strong></em></p>
<p><em><strong>*CREATE TABLE TEST_TABLE(COL1 CHAR(22),COL2 INT,COL3 CHAR(22));*</strong></em></p>
<p><em><strong>*SHOW TABLES;*</strong></em></p>
<p><em><strong>*DROP TABLE TEST_TABLE;*</strong></em></p>
<p><em><strong>*SHOW TABLES;*</strong></em></p>
<p><em><strong>*输出*</strong></em></p>
<p><img src="/MyImages/wps2-1592281234789.jpg" alt="img" /></p>
<h1 id="测试3"><a class="markdownIt-Anchor" href="#测试3"></a> 测试3</h1>
<p><em><strong>*测试INSERT INTO VALUES*</strong></em></p>
<p><em><strong>*输入*</strong></em></p>
<p><em><strong>*USE XJGL;*</strong></em></p>
<p><em><strong>*INSERT INTO STUDENT(SNAME,SAGE,SSEX) VALUES (‘ZHANGSAN’,22,1);*</strong></em></p>
<p><em><strong>*INSERT INTO STUDENT VALUES (‘LISI’,23,0);*</strong></em></p>
<p><em><strong>*INSERT INTO STUDENT(SNAME,SAGE) VALUES (‘WANGWU’,21);*</strong></em></p>
<p><em><strong>*INSERT INTO STUDENT VALUES (‘ZHAOLIU’,22,1);*</strong></em></p>
<p><em><strong>*INSERT INTO STUDENT VALUES (‘XIAOBAI’,23,0);*</strong></em></p>
<p><em><strong>*INSERT INTO STUDENT VALUES (‘XIAOHEI’,19,0);*</strong></em></p>
<p><em><strong>*INSERT INTO COURSE(CNAME,CID) VALUES (‘DB’,1);*</strong></em></p>
<p><em><strong>*INSERT INTO COURSE (CNAME,CID) VALUES(‘COMPILER’,2);*</strong></em></p>
<p><em><strong>*insert into course (CNAME,CID) VALUES(‘C’,3);*</strong></em></p>
<p><img src="/MyImages/wps3-1592281234789.jpg" alt="img" /></p>
<h1 id="测试4"><a class="markdownIt-Anchor" href="#测试4"></a> 测试4</h1>
<p><em><strong>*测试单表查询*</strong></em></p>
<p><em><strong>*输入*</strong></em></p>
<p><em><strong>*USE XJGL;*</strong></em></p>
<p><em><strong>*SELECT SNAME,SAGE,SSEX FROM STUDENT;*</strong></em></p>
<p><em><strong>*SELECT SNAME,SAGE FROM STUDENT;*</strong></em></p>
<p><em><strong>*SELECT * FROM STUDENT;*</strong></em></p>
<p><em><strong>*SELECT SNAME,SAGE FROM STUDENT WHERE SAGE=21;*</strong></em></p>
<p><em><strong>*SELECT SNAME,SAGE FROM STUDENT WHERE (((SAGE=21)));*</strong></em></p>
<p><em><strong>*SELECT SNAME,SAGE,SSEX FROM STUDENT WHERE (SAGE&gt;21) AND (SSEX=0);*</strong></em></p>
<p><em><strong>*SELECT SNAME,SAGE,SSEX FROM STUDENT WHERE (SAGE&gt;21) OR (SSEX=0);*</strong></em></p>
<p><em><strong>*SELECT * FROM STUDENT WHERE SSEX!=1;*</strong></em></p>
<p><em><strong>*SELECT SNAME,SAGE FROM STUDENT WHERE SAGE&gt;21 AND SSEX=0;*</strong></em></p>
<p><em><strong>*SELECT SNAME,SAGE,SSEX  FROM STUDENT WHERE SAGE&gt;21 OR SSEX=0;*</strong></em></p>
<p><em><strong>*SELECT * from STUDENT WHERE SNAME = ‘ZHANGSAN’ OR SNAME = ‘ZHAOLIU’ AND SAGE = 21;*</strong></em></p>
<p><em><strong>*SELECT * from STUDENT WHERE SNAME = ‘ZHAOLIU’ AND SAGE = 21 OR SNAME = ‘ZHANGSAN’ ;*</strong></em></p>
<p><em><strong>*SELECT * from STUDENT WHERE (SNAME = ‘ZHANGSAN’ OR SNAME = ‘ZHAOLIU’) AND SAGE = 21;*</strong></em></p>
<p><em><strong>*SELECT * from STUDENT WHERE (SAGE = 21 AND SNAME = ‘ZHANGSAN’) OR (SAGE = 22 AND SNAME = ‘ZHAOLIU’);*</strong></em></p>
<p><em><strong>*SELECT * FROM STUDENT WHERE (SAGE = 21 OR SAGE = 19) AND (SNAME = 'XIAOHEI’OR SNAME = ‘HH’ );*</strong></em></p>
<p><img src="/MyImages/wps4-1592281234789.jpg" alt="img" /></p>
<p><img src="/MyImages/wps5-1592281234789.jpg" alt="img" /></p>
<p><img src="/MyImages/wps6-1592281234789.jpg" alt="img" /></p>
<p><img src="/MyImages/wps7-1592281234789.jpg" alt="img" /></p>
<h1 id="测试5"><a class="markdownIt-Anchor" href="#测试5"></a> 测试5</h1>
<p><em><strong>*测试带有NOT 和多AND/OR 的*</strong></em></p>
<p><em><strong>*输入*</strong></em></p>
<p><em><strong>*INSERT INTO STUDENT VALUES (‘ZHAOLIU’,23,1);*</strong></em></p>
<p><em><strong>*SELECT * FROM STUDENT WHERE NOT (SAGE =22 AND SNAME = ‘ZHAOLIU’);*</strong></em></p>
<p><em><strong>*SELECT * FROM STUDENT WHERE NOT (SAGE =22 AND SNAME = ‘ZHAOLIU’) AND SSEX = ‘1’;*</strong></em></p>
<p><em><strong>*SELECT * FROM STUDENT WHERE NOT (SAGE =22 AND SNAME = ‘ZHAOLIU’) OR SAGE = 22;*</strong></em></p>
<p><em><strong>*SELECT * from STUDENT WHERE SNAME = ‘ZHANGSAN’ OR SNAME = ‘ZHAOLIU’ AND SAGE = 21;*</strong></em></p>
<p><em><strong>*SELECT * from STUDENT WHERE (SNAME = ‘ZHANGSAN’ OR SNAME = ‘ZHAOLIU’)*</strong></em>  <em><strong>*AND*</strong></em> <em><strong>*SAGE = 21;*</strong></em></p>
<p><em><strong>*SELECT * from STUDENT WHERE (SAGE = 21 AND SNAME = ‘ZHANGSAN’) OR (SAGE = 22 AND SNAME = ‘ZHAOLIU’);*</strong></em></p>
<p><em><strong>*SELECT * FROM STUDENT WHERE (SAGE = 21 OR SAGE = 19) AND (SNAME = 'XIAOHEI’OR SNAME = ‘HH’ );*</strong></em></p>
<p><img src="/MyImages/wps8-1592281234789.jpg" alt="img" /></p>
<p><img src="/MyImages/wps9-1592281234789.jpg" alt="img" /></p>
<p><img src="/MyImages/wps10-1592281234790.jpg" alt="img" /></p>
<p><img src="/MyImages/wps11-1592281234790.jpg" alt="img" /></p>
<h1 id="测试6"><a class="markdownIt-Anchor" href="#测试6"></a> 测试6</h1>
<p><em><strong>*测试多表查询*</strong></em></p>
<p><em><strong>*输入*</strong></em></p>
<p><em><strong>*SELECT * FROM STUDENT;SELECT * FROM COURSE;*</strong></em></p>
<p><em><strong>*select * from student,course;*</strong></em></p>
<p><em><strong>*SELECT * FROM STUDENT,COURSE WHERE STUDENT.SSEX=0 AND COURSE.CID=1;*</strong></em></p>
<p><em><strong>*SELECT * FROM STUDENT,COURSE WHERE STUDENT.SAGE &gt;20 AND COURSE.CID !=1;*</strong></em></p>
<p><img src="/MyImages/wps12.jpg" alt="img" /></p>
<h1 id="测试7"><a class="markdownIt-Anchor" href="#测试7"></a> 测试7</h1>
<p><img src="/MyImages/wps13.jpg" alt="img" /></p>
<p><em><strong>*测试DELETE语句*</strong></em></p>
<p><em><strong>*输入*</strong></em></p>
<p><em><strong>*SELECT * FROM STUDENT;*</strong></em></p>
<p><em><strong>*DELETE FROM STUDENT WHERE SAGE&gt;21 AND SSEX=0;*</strong></em></p>
<p><em><strong>*SELECT * FROM STUDENT;*</strong></em></p>
<p><img src="/MyImages/wps14.jpg" alt="img" /></p>
<h1 id="测试8"><a class="markdownIt-Anchor" href="#测试8"></a> 测试8</h1>
<p><em><strong>*测试update语句*</strong></em></p>
<p><em><strong>*输入*</strong></em></p>
<p><em><strong>*SELECT * FROM STUDENT;*</strong></em></p>
<p><em><strong>*UPDATE STUDENT SET SAGE=21 WHERE SSEX=1;*</strong></em></p>
<p><em><strong>*SELECT * FROM STUDENT;*</strong></em></p>
<p><em><strong>*UPDATE STUDENT SET SAGE=27,SSEX=1 WHERE SNAME=‘ZHANGSAN’;*</strong></em></p>
<p><em><strong>*SELECT * FROM STUDENT;*</strong></em></p>
<p><img src="/MyImages/wps15.jpg" alt="img" /></p>
<h1 id="测试9"><a class="markdownIt-Anchor" href="#测试9"></a> 测试9</h1>
<p><em><strong>*测试算数运算*</strong></em></p>
<p><em><strong>*输入*</strong></em></p>
<p><em><strong>*USE XJGL;*</strong></em></p>
<p><em><strong>*SELECT * FROM STUDENT;*</strong></em></p>
<p><em><strong>*SELECT * FROM STUDENT WHERE SAGE = 20+1;*</strong></em></p>
<p><em><strong>*SELECT * FROM STUDENT WHERE SAGE = 54/2;*</strong></em></p>
<p><em><strong>*select * from STUDENT WHERE SAGE = 54 *2;*</strong></em></p>
<p><em><strong>*select * from STUDENT WHERE SAGE = -22+43;*</strong></em></p>
<p><img src="/MyImages/wps16.jpg" alt="img" /></p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>两亲性分子</title>
    <url>/2020/03/30/%E4%B8%A4%E4%BA%B2%E6%80%A7%E5%88%86%E5%AD%90/</url>
    <content><![CDATA[<h1 id="uva-1606-两亲性分子"><a class="markdownIt-Anchor" href="#uva-1606-两亲性分子"></a> UVA 1606 两亲性分子</h1>
<p>平面上有n(n≤1000)n(n&lt;=1000)个点，每个点为白点或者黑点。</p>
<p>现在需要放置一条隔板，使得隔板一侧的白点数加上另一侧的黑点数总数最大。隔板上的点可以看作任意一侧。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>基础：令隔板经过至少两个点(否则可以移动隔板使其经过两个点而总数不变</li>
<li>最直接的，枚举两个点，再计算总数，O(n<sup>3</sup>)</li>
<li>改进：先枚举一个基准点，然后以这个点为轴，旋转直线，这样就可可以动态修改两侧的点数。</li>
<li>技巧：
<ol>
<li>将黑点以当前的基准点为对称中心，将它对称过去，这样只用统计直线一端的点数就是答案</li>
<li>利用叉积判断两个向量是否反向(即旋转了180°)</li>
</ol>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="solve-枚举基准点并统计每个基准点对应的总数"><a class="markdownIt-Anchor" href="#solve-枚举基准点并统计每个基准点对应的总数"></a> solve 枚举基准点，并统计每个基准点对应的总数</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int solve() &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">	scanf(&quot;%d %d %d&quot;, &amp;in[i].x, &amp;in[i].y, &amp;flag[i]);</span><br><span class="line"></span><br><span class="line">if (n &lt;&#x3D; 2) return 2;</span><br><span class="line">node p[maxn];</span><br><span class="line">int ans &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">	int k &#x3D; 0;</span><br><span class="line">	for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">		if (j &#x3D;&#x3D; i) continue;</span><br><span class="line">		p[k].x &#x3D; in[j].x - in[i].x;</span><br><span class="line">		p[k].y &#x3D; in[j].y - in[i].y;</span><br><span class="line">		if (flag[j]) p[k].x *&#x3D; -1, p[k].y *&#x3D; -1;</span><br><span class="line">		p[k].rad &#x3D; atan2(p[k].y, p[k].x);</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(p, p + k);</span><br><span class="line">	int L &#x3D; 0, R &#x3D; 0, cnt &#x3D; 2;</span><br><span class="line">	while (L &lt; k)</span><br><span class="line">	&#123;</span><br><span class="line">		if (R &#x3D;&#x3D; L) &#123;</span><br><span class="line">			R &#x3D; (R + 1) % k;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		while (R !&#x3D; L &amp;&amp; left(p[L], p[R]))</span><br><span class="line">		&#123;</span><br><span class="line">			R &#x3D; (R + 1) % k;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		cnt--;</span><br><span class="line">		L++;</span><br><span class="line">		ans &#x3D; max(ans, cnt);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="left-判断两个向量是否反向"><a class="markdownIt-Anchor" href="#left-判断两个向量是否反向"></a> left 判断两个向量是否反向</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool left(node a, node b) &#123;</span><br><span class="line">return a.x*b.y - a.y*b.x &gt;&#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1005;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int x, y;</span><br><span class="line">	double rad;</span><br><span class="line">	bool operator &lt; (const node &amp;a) const &#123; return rad &lt; a.rad; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node in[maxn];</span><br><span class="line">int n;</span><br><span class="line">bool flag[maxn];</span><br><span class="line"></span><br><span class="line">bool left(node a, node b);</span><br><span class="line">int solve();</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n) &#123;</span><br><span class="line">		printf(&quot;%d\n&quot;, solve());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>与非门电路</title>
    <url>/2020/03/30/%E4%B8%8E%E9%9D%9E%E9%97%A8%E7%94%B5%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="uva-1607-与非门电路"><a class="markdownIt-Anchor" href="#uva-1607-与非门电路"></a> UVA 1607 与非门电路</h1>
<p>可以用与非门（NAND）来设计逻辑电路，每个NAND门有两个输入端，输出为两个输入端与非运算的结果。也就是说 两个输入都是1是输出是0，其他输入输出都是1，给出一个由m（m&lt;=200000）个NAND组成的无环电路，电路的所有n个输入（n&lt;=100000）全部连接到一个相同的输入x,请把其中的一些输入设置为常数，用最少的x完成相同功能。输出任意方案即可。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>因为只有一个输入x，所以输出只有四种可能，0,1,x,x’</li>
<li>首先令输出全0和全1，比较二者结果，如果相等，那么说明输出与x无关 ，整个电路肯定是常数。</li>
<li>否则说明与x有关。不妨设x=0时输出0，x=1时输出1。假设现在把输入从00000改成10000，如果输出为1，那么可以得到一个解x0000，否则继续尝试11000，如果输出为1，则得到一个解1x000…直到输入全1时输出为1。</li>
<li>由于m很大，所以采用二分法，二分1的个数，再计算输出。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="output-计算0~k出入为0时的输出"><a class="markdownIt-Anchor" href="#output-计算0~k出入为0时的输出"></a> output 计算0~k出入为0时的输出</h2>
<ol>
<li>注 输入格式中，负数代表从门输入，正数代表从其他门的输出来输入。数字绝对值代表门或输入的编号。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int output(int k) &#123;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">		int a &#x3D; gate[i].a;</span><br><span class="line">		int b &#x3D; gate[i].b;</span><br><span class="line">		int va &#x3D; a&lt;0 ? -a&gt;k:gate[a].o; </span><br><span class="line">		int vb &#x3D; b&lt;0 ? -b&gt;k:gate[b].o;</span><br><span class="line"></span><br><span class="line">		gate[i].o &#x3D; !(va&amp;&amp;vb);</span><br><span class="line">	&#125;</span><br><span class="line">	return gate[m].o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sovle-二分查找过程"><a class="markdownIt-Anchor" href="#sovle-二分查找过程"></a> sovle 二分查找过程</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int solve(int vn) &#123;</span><br><span class="line">	int L &#x3D; 1, R &#x3D; n;</span><br><span class="line">	while (L&lt;R)</span><br><span class="line">	&#123;</span><br><span class="line">		int m &#x3D; L + (R - L) &#x2F; 2;</span><br><span class="line">		if (output(m) &#x3D;&#x3D; vn) R &#x3D; m;</span><br><span class="line">		else L &#x3D; m+1;</span><br><span class="line">	&#125;</span><br><span class="line">	return L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxm &#x3D; 200000 + 5;</span><br><span class="line"></span><br><span class="line">int n, m;</span><br><span class="line"></span><br><span class="line">struct Gates &#123;</span><br><span class="line">	int a, b, o;</span><br><span class="line">&#125; gate[maxm];</span><br><span class="line"></span><br><span class="line">inline int output(int k);</span><br><span class="line">inline int solve(int);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d  %d&quot;, &amp;n, &amp;m);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">			scanf(&quot;%d  %d&quot;, &amp;gate[i].a, &amp;gate[i].b);</span><br><span class="line">		int v0, vn;</span><br><span class="line">		v0 &#x3D; output(0);</span><br><span class="line">		vn &#x3D; output(n);</span><br><span class="line">		if (v0 &#x3D;&#x3D; vn) &#123;</span><br><span class="line">			for (int i &#x3D; 1; i &lt;&#x3D; n; i++) printf(&quot;0&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			int ix &#x3D; solve(vn);</span><br><span class="line">			for (int i &#x3D; 1; i &lt; ix; i++) printf(&quot;0&quot;);</span><br><span class="line">			printf(&quot;x&quot;);</span><br><span class="line">			for (int i &#x3D; ix + 1; i &lt;&#x3D; n; i++) printf(&quot;1&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的层序遍历</title>
    <url>/2020/03/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="uva-122-树的层序遍历"><a class="markdownIt-Anchor" href="#uva-122-树的层序遍历"></a> uva 122 树的层序遍历</h1>
<p>树状结构在电脑科学的许多领域中都相当重要。本问题牵涉到建立树及走访树。</p>
<p>给你一二元树，你的任务是写一个程式来列印依「阶层（level-order）」走访的结果。在本问题中，二元树的每个节点含有一个正整数，并且节点的数目最少1个，最多256个。</p>
<p>在「阶层」走访中，依阶层从低到高，同阶层从左到右的次序来列印。例如以下的二元树阶层走访的结果为：5, 4, 8, 11, 13, 4, 7, 2, 1</p>
<p>在本问题中，二元树以节点来表示。每个节点以一对(n,s)来表示。n代表此节点的值，s为一字串，代表从根节点到达此节点的路径。其中L代表往左，R代表往右。所以在上方的图中内容为13的节点其表示法为(13,RL)，而内容为2的节点其表示法为(2,LLR)，而根节点为(5,)。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<p>先根据给出的对，构造二叉树，在借助队列层序遍历</p>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    #include&lt;iostream&gt;</span><br><span class="line">    #include&lt;string&gt;</span><br><span class="line">    #include&lt;queue&gt;</span><br><span class="line">    # pragma warning(disable:4996)</span><br><span class="line">    # define LOCAL</span><br><span class="line">    # ifdef LOCAL</span><br><span class="line">    FILE *fin &#x3D; freopen(&quot;树的层序遍历in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    FILE *fout &#x3D; freopen(&quot;树的层序遍历out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    # endif </span><br><span class="line">    using namespace std;</span><br><span class="line">    struct node &#123;</span><br><span class="line">    	bool have_val;</span><br><span class="line">    	int v;</span><br><span class="line">    	node *left, *right;</span><br><span class="line">    	node() :have_val(false), left(NULL), right(NULL) &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    node* root;</span><br><span class="line">    node * newnode() &#123;</span><br><span class="line">    </span><br><span class="line">    	return new node();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">	bool flag;</span><br><span class="line">	void addnode(string s, int v) &#123;</span><br><span class="line">	node * u &#x3D; root;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; s.length()-1; i++)</span><br><span class="line">		if (s[i] &#x3D;&#x3D; &#39;L&#39;) &#123;</span><br><span class="line">			if (u-&gt;left &#x3D;&#x3D; NULL)</span><br><span class="line">				u-&gt;left &#x3D; newnode();</span><br><span class="line">			u &#x3D; u-&gt;left;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		else if (s[i] &#x3D;&#x3D; &#39;R&#39;) &#123;</span><br><span class="line">			if (u-&gt;right &#x3D;&#x3D; NULL)</span><br><span class="line">				u-&gt;right &#x3D; newnode();</span><br><span class="line">			u &#x3D; u-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">	if (u-&gt;have_val) &#123;</span><br><span class="line">		flag &#x3D; false;</span><br><span class="line">	&#125;</span><br><span class="line">	u-&gt;have_val &#x3D; true;	</span><br><span class="line">	u-&gt;v &#x3D; v;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	int main() &#123;</span><br><span class="line">	string s;</span><br><span class="line">	</span><br><span class="line">	while (cin.peek() !&#x3D; EOF&amp;&amp;cin.peek()!&#x3D;&#39;\n&#39;) &#123;</span><br><span class="line">		root &#x3D; newnode();</span><br><span class="line"></span><br><span class="line">		flag &#x3D; true;</span><br><span class="line"></span><br><span class="line">		while (cin &gt;&gt; s &amp;&amp; s !&#x3D; &quot;()&quot;) &#123;</span><br><span class="line">			int v;</span><br><span class="line">			sscanf(&amp;s[1], &quot;%d&quot;, &amp;v);</span><br><span class="line">&gt;※※※提取字符串中的数字的方法！！！</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F;		cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">			s &#x3D; s.substr(s.find(&#39;,&#39;) + 1);</span><br><span class="line">			addnode(s, v);</span><br><span class="line">		&#125;</span><br><span class="line">		getchar();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		if (!flag) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;not complete&quot; &lt;&lt; endl;</span><br><span class="line">			continue;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		node *tmp &#x3D; root;</span><br><span class="line">		queue&lt;node *&gt; travel;</span><br><span class="line">		travel.push(tmp);</span><br><span class="line">&gt;注意层序遍历的初始值</span><br><span class="line"></span><br><span class="line">		string ans;</span><br><span class="line">		while (!travel.empty()) &#123;</span><br><span class="line">			tmp&#x3D; travel.front();</span><br><span class="line">			travel.pop();</span><br><span class="line">			</span><br><span class="line">			if (!tmp-&gt;have_val) &#123;</span><br><span class="line">				flag &#x3D; false;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			ans &#x3D;ans+&quot; &quot;+to_string( tmp-&gt;v);</span><br><span class="line">			if (tmp-&gt;left) travel.push(tmp-&gt;left);</span><br><span class="line">			if (tmp-&gt;right) travel.push(tmp-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">		flag ? cout &lt;&lt; ans.substr(1) &lt;&lt; endl : cout &lt;&lt; &quot;not complete&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<ol>
<li>
<p>首先一定要学习提取字符串中数字的方法<br />
：sscanf(&amp;数字起始地址,“格式”，&amp;存储变量名)</p>
</li>
<li>
<p>动态申请空间的时候，要释放掉，否则会导致内存泄漏；</p>
</li>
<li>
<p>可以通过维护一个简单的内存池实现</p>
<pre><code> queue&lt;Node*&gt; freenodes;
 Node node[maxn];

 void init(){
 	for(int i=0;i&lt;maxn;i++)
 	freenodes.push(&amp;node[i]);	
 }
 
 Node* new(){
 	Node* u = freenodes.front();
 	//处理u的成员变量
 	freenodes.pop();
 	return u;
 }

 void dele(Node *u){
 	freenodes.push(u);
 }</code></pre>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的重建</title>
    <url>/2020/03/30/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%87%8D%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="uva-536-二叉树的重建-先中造树"><a class="markdownIt-Anchor" href="#uva-536-二叉树的重建-先中造树"></a> UVA 536 二叉树的重建 (先中造树)</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">   #include&lt;string&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;习题6-3in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;习题6-3out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   typedef struct node &#123;</span><br><span class="line">   	struct node *lchild, *rchild;</span><br><span class="line">   	char data;</span><br><span class="line">   &#125;node, *ptr;</span><br><span class="line">   ptr Create(char *pre, char *in, int n)</span><br><span class="line">   &#123;</span><br><span class="line">   	ptr s;</span><br><span class="line">   </span><br><span class="line">   	if (n &#x3D;&#x3D; 1)</span><br><span class="line">   	&#123;</span><br><span class="line">   		s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">   		s-&gt;data &#x3D; *pre;</span><br><span class="line">   		s-&gt;lchild &#x3D; s-&gt;rchild &#x3D; NULL;</span><br><span class="line">   		return s;</span><br><span class="line">   	&#125;</span><br><span class="line">   	char *p;</span><br><span class="line">   	for (p &#x3D; in; p &lt; in + n; p++)</span><br><span class="line">   		if (*p &#x3D;&#x3D; *pre) break;</span><br><span class="line">   	int k &#x3D; p - in;</span><br><span class="line">   	s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">   	s-&gt;data &#x3D; *p;</span><br><span class="line">   	s-&gt;lchild &#x3D; s-&gt;rchild &#x3D; NULL;</span><br><span class="line">   	if (k) s-&gt;lchild &#x3D; Create(pre + 1, in, k);</span><br><span class="line">   	if (n - k - 1) s-&gt;rchild &#x3D; Create(pre + k + 1, p + 1, n - k - 1);</span><br><span class="line">   	return s;</span><br><span class="line">   &#125;</span><br><span class="line">   int lastorder(ptr T)</span><br><span class="line">   &#123;</span><br><span class="line">   	if (!T) return 0;</span><br><span class="line">   	lastorder(T-&gt;lchild);</span><br><span class="line">   	lastorder(T-&gt;rchild);</span><br><span class="line">   	printf(&quot;%c&quot;, T-&gt;data);</span><br><span class="line">   	return 1;</span><br><span class="line">   &#125;</span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">   </span><br><span class="line">   	string pre, in;</span><br><span class="line">   	while (cin &gt;&gt; pre &gt;&gt; in) &#123;</span><br><span class="line">   		int n &#x3D; pre.length();</span><br><span class="line">   		ptr T &#x3D; Create(&amp;pre[0], &amp;in[0], n);</span><br><span class="line">   		lastorder(T);</span><br><span class="line">   		cout &lt;&lt; endl;</span><br><span class="line">   	&#125;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能目录</title>
    <url>/2020/03/29/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="第1章人工智能的定义及其发展"><a class="markdownIt-Anchor" href="#第1章人工智能的定义及其发展"></a> <a href="/2020/06/13/%E7%AC%AC1%E7%AB%A0%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%85%B6%E5%8F%91%E5%B1%95/">第1章人工智能的定义及其发展</a></h2>
<p><img src="/MyImages/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%85%B6%E5%8F%91%E5%B1%95.png" alt="人工智能定义及其发展" /></p>
<h2 id="第2章知识表示方法"><a class="markdownIt-Anchor" href="#第2章知识表示方法"></a> <a href="/2020/06/13/%E7%AC%AC2%E7%AB%A0%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/">第2章知识表示方法</a></h2>
<p><img src="/MyImages/%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95.png" alt="知识表示方法" /></p>
<h2 id="第3章经典逻辑推理"><a class="markdownIt-Anchor" href="#第3章经典逻辑推理"></a> <a href="/2020/06/13/%E7%AC%AC3%E7%AB%A0%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91%E6%8E%A8%E7%90%86/">第3章经典逻辑推理</a></h2>
<p><img src="/MyImages/%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91%E6%8E%A8%E7%90%86.png" alt="经典逻辑推理" /></p>
<h2 id="第5章不确定性推理"><a class="markdownIt-Anchor" href="#第5章不确定性推理"></a> <a href="/2020/06/13/%E7%AC%AC5%E7%AB%A0%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E6%8E%A8%E7%90%86/">第5章不确定性推理</a></h2>
<p><img src="/MyImages/%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%8E%A8%E7%90%86.png" alt="不确定推理" /></p>
<p><img src="/MyImages/%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E6%8E%A8%E7%90%86.png" alt="不确定性推理" /></p>
<h2 id="第6章问题求解与搜索策略"><a class="markdownIt-Anchor" href="#第6章问题求解与搜索策略"></a> <a href="/2020/06/13/%E7%AC%AC6%E7%AB%A0%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%E4%B8%8E%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5/">第6章问题求解与搜索策略</a></h2>
<p><img src="/MyImages/%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%E4%B8%8E%E6%8E%A2%E7%B4%A2%E7%AD%96%E7%95%A5.png" alt="问题求解与探索策略" /></p>
<h2 id="第7章搜索策略之与或树"><a class="markdownIt-Anchor" href="#第7章搜索策略之与或树"></a> <a href="/2020/06/13/%E7%AC%AC7%E7%AB%A0%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5%E4%B9%8B%E4%B8%8E%E6%88%96%E6%A0%91/">第7章搜索策略之与或树</a></h2>
<p><img src="/MyImages/%E4%B8%8E%E6%88%96%E6%A0%91%E6%90%9C%E7%B4%A2.png" alt="与或树搜索" /></p>
<h2 id="第8章遗传算法"><a class="markdownIt-Anchor" href="#第8章遗传算法"></a> <a href="/2020/06/13/%E7%AC%AC8%E7%AB%A0%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/">第8章遗传算法</a></h2>
<p><img src="/MyImages/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95.png" alt="遗传算法" /></p>
<h2 id="第9章人工神经网络"><a class="markdownIt-Anchor" href="#第9章人工神经网络"></a> <a href="/2020/07/28/%E7%AC%AC9%E7%AB%A0%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">第9章人工神经网络</a></h2>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>修改天平</title>
    <url>/2020/03/30/%E4%BF%AE%E6%94%B9%E5%A4%A9%E5%B9%B3/</url>
    <content><![CDATA[<h1 id="uva12166-修改天平括号表示法给出树"><a class="markdownIt-Anchor" href="#uva12166-修改天平括号表示法给出树"></a> uva12166 修改天平	(括号表示法给出树)</h1>
<p>给出一个深度不超过16的二叉树，代表一个天平。每根杆都悬挂在中间，每个秤砣的重量已知。至少修改多少个秤砣的重量才能让天平平衡？</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>思考如何使得修改的天平最少：保证让总重量最多的秤砣不变。</li>
<li>用sum记录总的秤砣个数，用base记录每个对应重量的秤砣数。注意秤砣重量与所在高度有关，重w的秤砣在depth深处的总重量为w&lt;&lt;depth</li>
<li>括号表示法给出树的结构可以参考本题</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<pre class="highlight"><code class="">    #include&lt;bits/stdc++.h&gt;
    # pragma warning(disable:4996)
    # define LOCAL
    # ifdef LOCAL
    FILE *fin = freopen(&quot;习题6-6in.txt&quot;, &quot;r&quot;, stdin);
    FILE *fout = freopen(&quot;习题6-6out.txt&quot;, &quot;w&quot;, stdout);
    # endif 
    using namespace std;
    int T;
    string s;
    int sum;
    map&lt;long long, int&gt; base;
    void dfs(int depth, int p, int e) {
    	if (s[p] == '[') {
		int not_ok = 0;
		for (int i = p + 1; i != e; i++) {
			if (s[i] == '[') not_ok++;
			if (s[i] == ']') not_ok--;
			//注意此处脱括号的方法非常灵性
			if (!not_ok&amp;&amp;s[i] == ',') {
				dfs(depth + 1, p + 1, i - 1);
				dfs(depth + 1, i + 1, e - 1);
			}
		}
	}
	else {
		long long w = 0;
		for (int i = p; i &lt;= e; i++)
			w = w * 10 + s[i] - '0';
		++sum;
		++base[w &lt;&lt; depth];//sum统计砝码总数量，base[w&lt;&lt;depth]统计该总重量对应的砝码个数

	}
	}
	int main() {
	cin &gt;&gt; T;
	while (T--)
	{
		cin &gt;&gt; s;
		sum = 0;
		base.clear();
		dfs(0, 0, s.length() - 1);
		int maxn = 0;
		for (auto it = base.begin(); it != base.end(); it++)
			maxn = max(maxn, it-&gt;second);
		cout &lt;&lt; sum - maxn &lt;&lt; endl;
	}
	}</code></pre>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>传说中的车</title>
    <url>/2020/03/30/%E4%BC%A0%E8%AF%B4%E4%B8%AD%E7%9A%84%E8%BD%A6/</url>
    <content><![CDATA[<h1 id="uva-11134-传说中的车"><a class="markdownIt-Anchor" href="#uva-11134-传说中的车"></a> UVA 11134 传说中的车</h1>
<p>在一个n*n的棋盘上有n个车，并且每辆车有一个矩形的出现范围。要求安排这n辆车，使得任意两辆车不在同行或同列。如果无解输出IMPOSSIBLE，否则输出n行，为每个车的坐标。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>本题中行列是无关的，所以可以拆分成两个一维问题，使用贪心法</li>
<li>为每个列单独选择一个车来填充。对于合法的车，贪心策略是使得该车的右边界尽量小。</li>
<li>这个车没有使用过，并且它的左边界不在当前要填充的列右侧。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="solve-贪心过程"><a class="markdownIt-Anchor" href="#solve-贪心过程"></a> solve 贪心过程</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool solve(const int *a, const int *b, int *c) &#123;&#x2F;&#x2F;解决第i列放哪个</span><br><span class="line">for(int col &#x3D; 1; col &lt;&#x3D; n; col++) &#123;</span><br><span class="line">   &#x2F;&#x2F; find a rook with smalleset b that is not yet assigned</span><br><span class="line">   int rook &#x3D; -1, minb &#x3D; n+1;</span><br><span class="line">   for(int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">     if(!c[i]&amp;&amp; b[i] &lt; minb &amp;&amp; col &gt;&#x3D; a[i]) &#123; rook &#x3D; i; minb &#x3D; b[i]; &#125;</span><br><span class="line">   if(rook &lt; 0 || col &gt; minb) return false;</span><br><span class="line">   c[rook] &#x3D; col;</span><br><span class="line">&#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 5000 + 5;</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">bool solve(const int *a, const int *b, int *c);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int x1[maxn], x2[maxn], y1[maxn], y2[maxn];</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)</span><br><span class="line">&#123;</span><br><span class="line">	int  x[maxn]&#123;&#125;, y[maxn]&#123;&#125;;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">		scanf(&quot;%d %d %d %d&quot;, &amp;x1[i], &amp;y1[i], &amp;x2[i], &amp;y2[i]);</span><br><span class="line">	if (solve(x1, x2, x) &amp;&amp; solve(y1, y2, y)) &#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			printf(&quot;%d %d\n&quot;, x[i], y[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	else printf(&quot;IMPOSSIBLE\n&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>分数拆分</title>
    <url>/2020/03/30/%E5%88%86%E6%95%B0%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<h1 id="uva-10976-分数拆分"><a class="markdownIt-Anchor" href="#uva-10976-分数拆分"></a> UVA 10976 分数拆分</h1>
<p>输入正整数k，找到所有正整数x&gt;=y,使得1/k=1/x+1/y</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>枚举y，算x。x&gt;=y,1/x&lt;=1/y,则1/k-1/y=1/x&lt;=1/y，则y&lt;=2k</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 10000;</span><br><span class="line">int cnt, n;</span><br><span class="line">int ans[maxn][2];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int x, y;</span><br><span class="line">	int c;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">	cnt &#x3D; 0;</span><br><span class="line">	for (y &#x3D; n + 1; y &lt;&#x3D; 2 * n; y++) &#123;</span><br><span class="line">		if ((n*y % (y - n)))</span><br><span class="line">			continue;</span><br><span class="line">		x &#x3D; (n*y) &#x2F; (y - n);</span><br><span class="line"></span><br><span class="line">		ans[cnt][0] &#x3D; x;</span><br><span class="line">		ans[cnt][1] &#x3D; y;</span><br><span class="line">		cnt++;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;, cnt);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; cnt; i++)</span><br><span class="line">		printf(&quot;1&#x2F;%d &#x3D; 1&#x2F;%d + 1&#x2F;%d\n&quot;, n, ans[i][0], ans[i][1]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>八皇后问题</title>
    <url>/2020/03/30/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>/*<br />
恰好每行每列各放置一个皇后，如果用A[x]表示第x行皇后的列号，则问题变成了一个全排列生成问题。<br />
*/</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
# pragma warning(disable:4996)
# define LOCAL
# ifdef LOCAL
FILE *fin = freopen(&quot;八皇后in.txt&quot;, &quot;r&quot;, stdin);
FILE *fout = freopen(&quot;八皇后out.txt&quot;, &quot;w&quot;, stdout);
# endif 
using namespace std;
int print_num = 1;
int tot = 0;
int n;
int A[100];
int vis[100][100];
void search(int cur) {
ios::sync_with_stdio(false);
if (cur == n) {
	if (print_num &lt;= 3) {
		cout &lt;&lt; A[0];
		for (unsigned int i = 1; i &lt; n; i++)
			cout &lt;&lt; &quot; &quot;&lt;&lt; A[i] ;
		cout &lt;&lt; endl;
		print_num++;
	}
	tot++;
}
else for (unsigned int i = 0; i &lt; n; i++) {
	if (!vis[0][i] &amp;&amp; !vis[1][cur + i] &amp;&amp; !vis[2][cur - i + n]) {
		//对于(i,cur)
		//以cur+i来标识副对角线，cur-i来标识主对角线，由于主对角线可能为负
		//所以要加上n
		A[cur] = i + 1;
		//对于(cur,i)处要么有子要么无子--&gt;回溯的两种情况
		vis[0][i] = vis[1][cur + i] = vis[2][cur - i + n] = 1;
		search(cur + 1);
		vis[0][i] = vis[1][cur + i] = vis[2][cur - i + n] = 0;//非常关键，回溯法中修改的辅助
															 //局部变量，一定要及时恢复原状
	}
}
}
int main() {
	ios::sync_with_stdio(false);
	cin &gt;&gt; n;
	search(0);
	cout &lt;&lt; tot &lt;&lt; endl;
}</code></pre>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>八数码</title>
    <url>/2020/03/30/%E5%85%AB%E6%95%B0%E7%A0%81/</url>
    <content><![CDATA[<h1 id="八数码-p1379"><a class="markdownIt-Anchor" href="#八数码-p1379"></a> 八数码 P1379</h1>
<p>有一个3*3的网格，给定一个初始局面，问至少多少步能到达目标局面.</p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p>经典的隐式图最短路径问题。</p>
<h2 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h2>
<ol>
<li>sizeof(字符串)会计算结束符。对于二维的字符数组，对某一行用sizeof不会计算结束符，可能产生问题。</li>
<li>一般的bfs采用队列，但是本题中由于状态是八个元素的信息，所以采用了类似链表的方法近似队列。在编辑书稿中也使用了类似的方式，只不过那个题是dfs，迭代加深搜实现的。</li>
<li>本题可以使用bfs是因为每一步的状态不是无限的。</li>
<li>注意rear<ins>和front</ins>的位置</li>
<li>dist数组是必要的</li>
</ol>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<pre><code>const int maxn = 1000000;
bool bfs();
bool can_insert(int s);
char st[maxn][9];
int dx[] = { 1,-1,0,0 };
int dy[] = { 0,0,1,-1 };   
int dist[maxn];
char goal[] = {&quot;123804765&quot;};
int front, rear;
std::set&lt;int&gt; vis;
int main() {
scanf(&quot;%s&quot;, st[1]);
if (bfs()) printf(&quot;%d&quot;, dist[front]);
else printf(&quot;-1&quot;);
}
bool bfs() {
front = 1, rear = 2;
while (front &lt; rear) {
	if (memcmp(goal,st[front], sizeof(st[front])) == 0) return true;
	int z = 0;
	while (st[front][z] != '0') z++;
	for (int i = 0; i &lt; 4; i++) {
		int newx = z / 3 + dx[i];
		int newy = z % 3 + dy[i];
		if (newx &lt; 0 || newx &gt;= 3 || newy &lt; 0 || newy &gt;= 3) continue;
		int newz = newx * 3 + newy;
		memcpy(st[rear], st[front], sizeof(char)*9);
		st[rear][newz] = st[front][z];
		st[rear][z] = st[front][newz];
		dist[rear] = dist[front] + 1;
		if(can_insert(rear)) rear++;
	}
	front++;
}
	return false;
}
bool can_insert(int s) {
int v = 0;
for (int i = 0; i &lt; 9; i++) v = v * 10 + st[s][i] - '0';
if (!vis.count(v)) {
	vis.insert(v);
	return true;
}
return false;
}</code></pre>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>倒水问题</title>
    <url>/2020/03/30/%E5%80%92%E6%B0%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="uva-10603-倒水问题"><a class="markdownIt-Anchor" href="#uva-10603-倒水问题"></a> UVA 10603 倒水问题</h1>
<p>在装满水的c升被子、空的a升杯子和b升杯子，3个杯子中都没有刻度。要求在不使用其他道具的情况下，在最少的取水量下量出d升水。</p>
<ol>
<li>
<p>经典的状态空间树搜索问题，采用广度搜索</p>
<ol>
<li>每次选择取水量最小的节点进行扩展</li>
<li>扩展的方法是枚举取水杯子的编号和倒入水的杯子的编号</li>
</ol>
</li>
<li>
<p>关于存储</p>
<ol>
<li>使用三元组存储三个杯子内的状态</li>
<li>设置dist变量存到该状态的取水量</li>
<li>bfs过程中使用优先级队列，需要重写&lt;</li>
</ol>
</li>
<li>
<p>由于每次必须倒空一个或者倒满另一个，所以倒水量无需枚举。倒水量用末状态-初状态</p>
</li>
<li>
<p>访问标志：由于三个杯子总水量一定，所以使用一个二维数组即可标记</p>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> dist;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dist &gt; a.dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="solve-广度遍历过程"><a class="markdownIt-Anchor" href="#solve-广度遍历过程"></a> solve 广度遍历过程</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">	priority_queue&lt;node&gt; q;</span><br><span class="line">	<span class="keyword">int</span> cap[<span class="number">3</span>];</span><br><span class="line">	<span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">	cap[<span class="number">0</span>] = a; cap[<span class="number">1</span>] = b; cap[<span class="number">2</span>] = c;</span><br><span class="line">	node u;</span><br><span class="line">	u.dist = <span class="number">0</span>;</span><br><span class="line">	u.v[<span class="number">0</span>] = <span class="number">0</span>; u.v[<span class="number">1</span>] = <span class="number">0</span>; u.v[<span class="number">2</span>] = c;</span><br><span class="line">	q.push(u);</span><br><span class="line">	vis[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		node u = q.top(); q.pop();</span><br><span class="line">		update_ans(u);</span><br><span class="line">		<span class="keyword">if</span> (ans[d] &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">                <span class="comment">// i杯 向 j杯倒水</span></span><br><span class="line">				<span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">					<span class="keyword">if</span> (u.v[i] &gt; <span class="number">0</span> &amp;&amp; u.v[j] &lt; cap[j]) &#123;</span><br><span class="line">						<span class="keyword">int</span> amount = <span class="built_in">min</span>(cap[j], u.v[i] + u.v[j]) - u.v[j];</span><br><span class="line">						node v = u;</span><br><span class="line">						v.dist += amount;</span><br><span class="line">						v.v[i] -= amount;</span><br><span class="line">						v.v[j] += amount;</span><br><span class="line">						<span class="keyword">if</span> (!vis[v.v[<span class="number">0</span>]][v.v[<span class="number">1</span>]]) &#123;</span><br><span class="line">							vis[v.v[<span class="number">0</span>]][v.v[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">							q.push(v);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (d &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans[d] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, ans[d], d);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            d--;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="update-更新到达状态u代表的各个杯中水量的最小取水量"><a class="markdownIt-Anchor" href="#update-更新到达状态u代表的各个杯中水量的最小取水量"></a> update 更新到达状态u代表的各个杯中水量的最小取水量</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_ans</span><span class="params">(node u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> d = u.v[i];</span><br><span class="line">		<span class="keyword">if</span> (ans[d] &lt; <span class="number">0</span> || u.dist &lt; ans[d])</span><br><span class="line">			ans[d] = u.dist;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_ans</span><span class="params">(node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn][maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, a, b, c, d;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">while</span> (n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">		solve(a, b, c, d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>切木棍</title>
    <url>/2020/03/30/%E5%88%87%E6%9C%A8%E6%A3%8D/</url>
    <content><![CDATA[<h1 id="uva-10003-切木棍"><a class="markdownIt-Anchor" href="#uva-10003-切木棍"></a> UVA 10003 切木棍</h1>
<p>有一根长度为L（L＜1000）的棍子，还有n（n＜50）个切割点的位置（按照从小到大排 列）。你的任务是在这些切割点的位置处把棍子切成n＋1部分，使得总切割费用最小。每次 切割的费用等于被切割的木棍长度。例如，L=10，切割点为2, 4, 7。如果按照2, 4, 7的顺序， 费用为10＋8＋6=24，如果按照4, 2, 7的顺序，费用为10＋4＋6=20。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>设d(i,j)为切割小木棍i~j的最优费用，则d(i,j) = min(d(i,k)+d(k,j)|i&lt;k&lt;j)+a[j]-a[i],其中a[j] -a[i]为第一刀的费用</li>
<li>注意这种递归写法，与UVA的巴比伦塔有类似之处</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="dp-注意初值"><a class="markdownIt-Anchor" href="#dp-注意初值"></a> dp 注意初值</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 50 + 5;</span><br><span class="line">int vis[maxn][maxn];</span><br><span class="line">int d[maxn][maxn];</span><br><span class="line">int a[maxn];</span><br><span class="line"></span><br><span class="line">int dp(int i, int j) &#123;</span><br><span class="line">	if (i &gt;&#x3D; j - 1) return 0;</span><br><span class="line">	if (vis[i][j]) return d[i][j];</span><br><span class="line">	vis[i][j] &#x3D; 1;</span><br><span class="line">	int &amp;ans &#x3D; d[i][j];</span><br><span class="line">	ans &#x3D; -1;</span><br><span class="line">	for (int k &#x3D; i + 1; k &lt;&#x3D; j - 1; k++) &#123;</span><br><span class="line">		int v &#x3D; dp(i, k) + dp(k,j) + a[j] - a[i];</span><br><span class="line">		if (ans&lt;0 || ans&gt;v) ans &#x3D; v;</span><br><span class="line">	&#125;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	int L, n;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;L, &amp;n) &#x3D;&#x3D; 2 &amp;&amp; L) &#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">		a[0] &#x3D; 0; a[n + 1] &#x3D; L;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		printf(&quot;The minimum cutting is %d.\n&quot;, dp(0, n + 1));</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>其他技巧</title>
    <url>/2020/03/30/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="标准模板库"><a class="markdownIt-Anchor" href="#标准模板库"></a> 标准模板库</h1>
<h2 id="字符串匹配北航"><a class="markdownIt-Anchor" href="#字符串匹配北航"></a> 字符串匹配(北航)</h2>
<p>读入数据string[ ]，然后读入一个短字符串。要求查找string[ ]中和短字符串的所有匹配，输出行号、匹配字符串。匹配时不区分大小写，并且可以有一个用中括号表示的模式匹配。如“aa[123]bb”，就是说aa1bb、aa2bb、aa3bb都算匹配。</p>
<p>输入有多组数据。<br />
每组数据第一行输入n(1&lt;=n&lt;=1000)，从第二行开始输入n个字符串（不含空格），接下来输入一个匹配字符串。</p>
<p>输出匹配到的字符串的行号和该字符串（匹配时不区分大小写）。</p>
<p><strong>注意[]会有多个即可</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1005;</span><br><span class="line">string in[maxn];</span><br><span class="line">vector&lt;string&gt; tep;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (cin &gt;&gt; n)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			cin &gt;&gt; in[i];</span><br><span class="line">		string t;</span><br><span class="line">		cin &gt;&gt; t;</span><br><span class="line">		string s &#x3D; t;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; t.length(); i++)</span><br><span class="line">			s[i] &#x3D; tolower(t[i]);</span><br><span class="line"></span><br><span class="line">		tep.push_back(s);</span><br><span class="line">		int cnt &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; tep.size(); i++) &#123;</span><br><span class="line">			s &#x3D; tep[i];</span><br><span class="line">			int f1 &#x3D; s.find(&#39;[&#39;);</span><br><span class="line">			int f2 &#x3D; s.find(&#39;]&#39;);</span><br><span class="line">			if (f1 !&#x3D; -1) &#123;</span><br><span class="line">				string tp &#x3D; s.substr(f1+1, f2-f1-1);</span><br><span class="line">				cnt +&#x3D; tp.length();</span><br><span class="line">				t &#x3D; s.substr(0, f1);</span><br><span class="line">				s &#x3D; s.substr(f2 + 1);</span><br><span class="line">				for (int i &#x3D; 0; i &lt; tp.length(); i++)</span><br><span class="line">					tep.push_back(t + tp[i] + s);</span><br><span class="line">			&#125;</span><br><span class="line">			else break;</span><br><span class="line">		&#125;</span><br><span class="line">		if (!cnt) cnt &#x3D; 1;</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			t &#x3D; in[i];</span><br><span class="line">			for (int j &#x3D; tep.size()-cnt; j &lt; tep.size(); j++) &#123;</span><br><span class="line">				transform(in[i].begin(), in[i].end(), in[i].begin(), ::tolower);</span><br><span class="line">				if (in[i].find(tep[j]) !&#x3D; -1)</span><br><span class="line">				&#123;</span><br><span class="line">					cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="其他技巧"><a class="markdownIt-Anchor" href="#其他技巧"></a> 其他技巧</h1>
<h2 id="手动读入intdouble"><a class="markdownIt-Anchor" href="#手动读入intdouble"></a> 手动读入int，double</h2>
<h3 id="readint"><a class="markdownIt-Anchor" href="#readint"></a> readint</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool readint(int &amp;ret) &#123;</span><br><span class="line">	int sgn;</span><br><span class="line">	char c;</span><br><span class="line">	c &#x3D; getchar();</span><br><span class="line">	if (c &#x3D;&#x3D; EOF) return false;</span><br><span class="line">	while (c !&#x3D; &#39;-&#39;&amp;&amp;c&lt;&#39;0&#39; || c&gt;&#39;9&#39;) c &#x3D; getchar();</span><br><span class="line">	sgn &#x3D; (c &#x3D;&#x3D; &#39;-&#39;) ? -1 : 1;</span><br><span class="line">	ret &#x3D; (c &#x3D;&#x3D; &#39;-&#39;) ? 0 : (c - &#39;0&#39;);</span><br><span class="line">	while ((c &#x3D; getchar()) &gt;&#x3D; &#39;0&#39;&amp;&amp;c &lt;&#x3D; &#39;9&#39;) ret &#x3D; ret * 10 + (c - &#39;0&#39;);</span><br><span class="line">	ret *&#x3D; sgn;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="readdouble"><a class="markdownIt-Anchor" href="#readdouble"></a> readdouble</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool readdouble(double &amp;ret) &#123;</span><br><span class="line">	int sgn;</span><br><span class="line">	char c;</span><br><span class="line">	double bit &#x3D; 0.1;&#x2F;&#x2F;小数点后数位的权重</span><br><span class="line">	c &#x3D; getchar();</span><br><span class="line">	if (c &#x3D;&#x3D; EOF) return false;</span><br><span class="line">	while (c !&#x3D; &#39;-&#39;&amp;&amp;c&lt;&#39;0&#39; || c&gt;&#39;9&#39;) c &#x3D; getchar();</span><br><span class="line">	sgn &#x3D; (c &#x3D;&#x3D; &#39;-&#39;) ? -1 : 1;</span><br><span class="line">	ret &#x3D; (c &#x3D;&#x3D; &#39;-&#39;) ? 0 : (c - &#39;0&#39;);</span><br><span class="line">	while ((c &#x3D; getchar()) &gt;&#x3D; &#39;0&#39;&amp;&amp;c &lt;&#x3D; &#39;9&#39;) ret &#x3D; ret * 10 + (c - &#39;0&#39;);</span><br><span class="line">	if (c &#x3D;&#x3D; &#39; &#39; || c &#x3D;&#x3D; &#39;\n&#39;) &#123; ret *&#x3D; sgn; return true; &#125;&#x2F;&#x2F;不存在小数位</span><br><span class="line">	while ((c &#x3D; getchar()) &gt;&#x3D; &#39;0&#39;&amp;&amp;c &lt;&#x3D; &#39;9&#39;) ret +&#x3D; (c - &#39;0&#39;)*bit, bit &#x2F;&#x3D; 10;</span><br><span class="line">	ret *&#x3D; sgn;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="流氓剪枝"><a class="markdownIt-Anchor" href="#流氓剪枝"></a> 流氓剪枝</h2>
<p>没啥理由的剪枝，以保证不超时</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>划分成回文串</title>
    <url>/2020/03/30/%E5%88%92%E5%88%86%E6%88%90%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="uva-11584-划分成回文串"><a class="markdownIt-Anchor" href="#uva-11584-划分成回文串"></a> UVA 11584 划分成回文串</h1>
<p>当一个字符串正序和反序是完全相同时，我们称之为“回文串”。例如“racecar”就是一个回文串，而“fastcar”就不是。现在给一个字符串s，把它分割成若干个互不相交的回文子串，求分割的回文子串的最少个数。</p>
<p>第一行为正整数t(≤10)，表示数据组数；接下来t行，每行一个完全由小写字母组成的字符串，长度不超过1000。</p>
<p>对于每组数据，输出最少回文子串数。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>设d[i]表示在i之前最少能构成多少回文串</li>
<li>要做的是对于每个i，在0-i中寻找j，使得[j+1,i]是个回文串。对于合法的j，更新d[i]，d[i] = min(d[i], d[j] + 1)。</li>
<li>判断回文串可以采用递归的方法</li>
<li>注意一些初值的选择</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000+5;</span><br><span class="line">char s[maxn];</span><br><span class="line">int vis[maxn][maxn];</span><br><span class="line">int p[maxn][maxn];</span><br><span class="line">int d[maxn];</span><br><span class="line">bool is_pali(int l, int r) &#123;</span><br><span class="line">	if (l &gt;&#x3D; r) return true;</span><br><span class="line">	if (s[l] !&#x3D; s[r]) return false;</span><br><span class="line">	if (vis[l][r]) return p[l][r];</span><br><span class="line"></span><br><span class="line">	vis[l][r] &#x3D; 1;</span><br><span class="line"></span><br><span class="line">	p[l][r] &#x3D; is_pali(l + 1, r - 1);</span><br><span class="line">	return p[l][r];</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%s&quot;, s + 1);</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		d[0] &#x3D; 0;</span><br><span class="line">		int n &#x3D; strlen(s + 1);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			d[i] &#x3D; i + 1; &#x2F;&#x2F;至多就是前面每个字符自己是一个回文串</span><br><span class="line">			for (int j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">				if (is_pali(j+1, i))</span><br><span class="line">					d[i] &#x3D; min(d[i], d[j] + 1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, d[n]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>切断圆环链</title>
    <url>/2020/03/30/%E5%88%87%E6%96%AD%E5%9C%86%E7%8E%AF%E9%93%BE/</url>
    <content><![CDATA[<h1 id="uva-818-切断圆环链"><a class="markdownIt-Anchor" href="#uva-818-切断圆环链"></a> UVA 818 切断圆环链</h1>
<p>现在有n个圆环 ，其中可能有些已经连接在一起 现在你想拆开一些圆环与其他圆环连接，使得最后所有圆环都在一条串上 问至少需要拆开几个圆环 (n≤15)</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>应该抽象为图的问题，要解决连通性的问题。</li>
<li>首先，把所有环打开后再扣上一定可以形成一条链。所以不存在无解的情况。</li>
<li></li>
</ol>
<p>然后，我们发现n≤15，所以我们可以用二进制表示这n个环是否被打开。</p>
<ol start="4">
<li>
<p>我们可以遍历所有状态。判断这个状态是否合法即可。如何判断状态合法？我们发现只要一个状态满足一下三条条件就合法。</p>
<ol>
<li>
<p>不能有环</p>
</li>
<li>
<p>一个节点不能有3个及其以上的儿子。即：每个点的度数需要≤2</p>
</li>
<li>
<p>由于每个打开的环只能连接两个未打开的环（即两个连通分量），所以联通分量的个数必须≤要打开的环的个数＋1。</p>
</li>
</ol>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="have_cycle-判断有无环使用递归"><a class="markdownIt-Anchor" href="#have_cycle-判断有无环使用递归"></a> have_cycle 判断有无环(使用递归)</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool have_circle(int s) &#123;&#x2F;&#x2F;判断是否存在环</span><br><span class="line">	memset(used, 0, sizeof(used));</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (!used[i] &amp;&amp; !(s&amp;(1 &lt;&lt; i))) &#123;</span><br><span class="line"></span><br><span class="line">&gt; 此处条件表示i节点没有遍历过，且跳过s代表的状态</span><br><span class="line">&gt; 只有当s&#x3D;&#x3D;(1&lt;&lt;i)时，后面的条件才为假</span><br><span class="line"></span><br><span class="line">			num++;</span><br><span class="line">			if (dfs(i, -1, s))</span><br><span class="line">				return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool dfs(int u, int fa, int s) &#123;</span><br><span class="line">	used[u] &#x3D; 1;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (g[u][i]) &#123;</span><br><span class="line">			if (i &#x3D;&#x3D; fa || (s &amp; (1 &lt;&lt; i))) continue;</span><br><span class="line"></span><br><span class="line">&gt; 状态s下，该边会被切断，所以不能走下去。</span><br><span class="line"></span><br><span class="line">			if (used[i]) return true;</span><br><span class="line">			if (dfs(i, u, s)) return true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="above_two-判断是否右节点的度大于二"><a class="markdownIt-Anchor" href="#above_two-判断是否右节点的度大于二"></a> above_two 判断是否右节点的度大于二</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool above_two(int s) &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">	int cnt &#x3D; 0;</span><br><span class="line">	for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">		if (g[i][j] &amp;&amp; !(s&amp;(1 &lt;&lt; i)) &amp;&amp; !(s&amp;(1 &lt;&lt; j))) &#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			if (cnt &gt; 2) return true;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="count-统计s状态打开的环的数量"><a class="markdownIt-Anchor" href="#count-统计s状态打开的环的数量"></a> count 统计s状态打开的环的数量</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int count(int s) &#123;</span><br><span class="line">int cnt &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">	if (s&amp;(1 &lt;&lt; i)) cnt++;</span><br><span class="line">return cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 15;</span><br><span class="line">bool dfs(int u, int fa, int s);</span><br><span class="line">bool above_two(int s);</span><br><span class="line">bool have_circle(int s);</span><br><span class="line">int count(int s);</span><br><span class="line">int n, num;</span><br><span class="line">int g[maxn][maxn];</span><br><span class="line">bool used[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">int a, b;</span><br><span class="line">int kase &#x3D; 0;</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	int ans &#x3D; inf;</span><br><span class="line">	memset(g, 0, sizeof(g));</span><br><span class="line">	while (scanf(&quot;%d %d&quot;, &amp;a, &amp;b) &amp;&amp; a !&#x3D; -1) &#123;</span><br><span class="line">		g[a - 1][b - 1] &#x3D; 1;</span><br><span class="line">		g[b - 1][a - 1] &#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; (1 &lt;&lt; n); i++) &#123;</span><br><span class="line">		num &#x3D; 0;</span><br><span class="line">		if (above_two(i) || have_circle(i))</span><br><span class="line">			continue;</span><br><span class="line">		int now &#x3D; count(i);</span><br><span class="line">		if (num - 1 &lt;&#x3D; now)</span><br><span class="line">			ans &#x3D; min(ans, now);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;Set %d: Minimum links to open is %d\n&quot;, ++kase, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>劲歌金曲</title>
    <url>/2020/03/30/%E5%8A%B2%E6%AD%8C%E9%87%91%E6%9B%B2/</url>
    <content><![CDATA[<h1 id="uva-12563-劲歌金曲"><a class="markdownIt-Anchor" href="#uva-12563-劲歌金曲"></a> UVA 12563 劲歌金曲</h1>
<p>(如果当你看到这个标题的时候笑了，那么这个问题是为你准备的ヽ(￣▽￣)ﾉ)<br />
如果问一个麦霸：“你在KTV里必唱的曲目有哪些？”得到的答案通常都会包含一首“神曲”：古巨基的《劲歌金曲》。为什么呢？一般来说，KTV不会在“时间到”的时候鲁莽地把正在唱的歌切掉，而是会等它放完。例如：在还有15秒时再唱一首2分钟的歌，则实际上多唱了105秒。但是融合了37首歌曲的《劲歌金曲》长达11分18秒，如果唱这首，则相当于多长了663秒！<br />
假设你正在唱KTV，还剩t秒时间。你决定接下来只唱你最爱的n首歌（不含《劲歌金曲》）中的一些，在时间结束之前再唱一个《劲歌金曲》，使得唱的总曲目尽量多（包含《劲歌金曲》），在此前提下尽量晚的离开KTV。<br />
输入n(n&lt;=50)，t(t&lt;=10的9次方)和每首歌的长度(保证不超过3分钟)，输出唱的总曲目以及时间总长度。输入保证所有n+1首曲子的总长度严格大于t。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>0-1背包问题</li>
<li>设f[i]表示t容量的包内(时间内)总体积为i时，物品的数量(歌的数量),可以在每次输入新的歌曲时，更新那些能够“装下”这首歌的状态。</li>
<li>注意最后要留一秒来唱劲歌金曲</li>
<li>做的时候蒙住了。f[t-1]不一定是所有状态下的最大值，因为可能达不到刚好装满t-1的状态</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 50 + 5;</span><br><span class="line">const int INF &#x3D; 1000000000;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; d[i][j]: maximal number of songs from first i songs, whose total length is exactly j</span><br><span class="line">int f[maxn * 180 + 678];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	int n, t, ti;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	for (int kase &#x3D; 1; kase &lt;&#x3D; T; kase++) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;n, &amp;t);</span><br><span class="line">		memset(f, -1, sizeof(f));</span><br><span class="line">		f[0] &#x3D; 0;</span><br><span class="line">		for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;ti);</span><br><span class="line">			for (int j &#x3D; t - 1; j &gt;&#x3D; ti; j--)</span><br><span class="line">				f[j] &#x3D; max(f[j], f[j - ti] + 1);</span><br><span class="line">		&#125;</span><br><span class="line">		int ans &#x3D; t - 1;</span><br><span class="line">		for (int i &#x3D; t - 1; i &gt;&#x3D; 0; i--)&#123;</span><br><span class="line">			if (f[i] &gt; f[ans])</span><br><span class="line">				ans &#x3D; i;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line"></span><br><span class="line">		printf(&quot;Case %d: %d %d\n&quot;, kase, f[ans] + 1, ans + 678);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="附上刘老师的代码"><a class="markdownIt-Anchor" href="#附上刘老师的代码"></a> 附上刘老师的代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int maxn &#x3D; 50 + 5;</span><br><span class="line">const int INF &#x3D; 1000000000;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; d[i][j]: maximal number of songs from first i songs, whose total length is exactly j</span><br><span class="line">int n, t, len[maxn], d[2][maxn*180+678]; </span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int T;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">  for(int kase &#x3D; 1; kase &lt;&#x3D; T; kase++) &#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;t);</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;len[i]);</span><br><span class="line"></span><br><span class="line">    for(int i &#x3D; 0; i &lt; t; i++) d[0][i] &#x3D; -1;</span><br><span class="line">    d[0][0] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    int p &#x3D; 1, ans &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">      for(int j &#x3D; 0; j &lt; t; j++) &#123;</span><br><span class="line">        d[p][j] &#x3D; d[p^1][j];</span><br><span class="line">        if(j &gt;&#x3D; len[i] &amp;&amp; d[p^1][j - len[i]] &gt;&#x3D; 0)</span><br><span class="line">          d[p][j] &#x3D; max(d[p][j], d[p^1][j - len[i]] + 1);</span><br><span class="line">        ans &#x3D; max(ans, d[p][j]);</span><br><span class="line">      &#125;</span><br><span class="line">      p ^&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i &#x3D; t-1; i &gt;&#x3D; 0; i--)</span><br><span class="line">      if(d[p^1][i] &#x3D;&#x3D; ans) &#123;</span><br><span class="line">        printf(&quot;Case %d: %d %d\n&quot;, kase, ans + 1, i + 678);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2020/03/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="递推求解"><a class="markdownIt-Anchor" href="#递推求解"></a> 递推求解</h1>
<p>我理解为已知规模解的递归</p>
<h2 id="n阶楼梯上楼问题"><a class="markdownIt-Anchor" href="#n阶楼梯上楼问题"></a> N阶楼梯上楼问题</h2>
<h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3>
<ol>
<li>考虑最后一步，可以从n-2阶迈两步，或者从n-1阶迈一步。这样就将走法分成了两类，总的走法f(n)=f(n-1)+f(n-2)。而f(n-1)就是n-1阶时的走法，又可以分成两类，所以问题是一个递推问题</li>
<li>对于小规模的解，我们是知道的，f(1)=1,f(2)=2，所以递推得解</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">int f(int k) &#123;</span><br><span class="line">	if (k &#x3D;&#x3D; 1) return 1;</span><br><span class="line">	if (k &#x3D;&#x3D; 2) return 2;</span><br><span class="line">	return f(k - 1) + f(k - 2);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int k;</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;k)&#x3D;&#x3D;1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d\n&quot;, f(k));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hdu-1465-不容易系列之一"><a class="markdownIt-Anchor" href="#hdu-1465-不容易系列之一"></a> HDU 1465 不容易系列之一</h2>
<h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3>
<p>考虑n号信封里装着k号信，m号信封里装着n号信。按照k和m是否相等分成两类</p>
<ol>
<li>若k!=m，那么交换两封信后，除n号外，其余n-1封信都是错装。那么n号信有n-1中交换方式使得n号错序。此时f(n)=(n-1)*f(n-1)</li>
<li>若k==m，那么交换之后，有n-2封信错装。m有n-1种交换策略，此时，f(n)=(n-1)*f(n-2)</li>
<li>故**错装公式：f(n)=(n-1)<em>f(n-1)+(n-1)<em>f(n-2)</em></em></li>
</ol>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">long long f(int n) &#123;</span><br><span class="line">	if (n &#x3D;&#x3D; 1) return 0;</span><br><span class="line">	if (n &#x3D;&#x3D; 2) return 1;</span><br><span class="line">	return (n - 1)*(f(n - 1) + f(n - 2));</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%lld\n&quot;, f(n));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最长递增子序列-lis"><a class="markdownIt-Anchor" href="#最长递增子序列-lis"></a> 最长递增子序列 LIS</h1>
<p>用F[i]代表若递增子序列以ai结束时它的最长长度,易知F[1]=1.现假设已知F[1]-F[x-1]，依次比较ax和ai(i&lt;x)，如果ax&lt;ai，那么ax可以接在ai后面，使得子序列长度加1。取这些长度的最大值即为F[x]</p>
<h2 id="拦截导弹"><a class="markdownIt-Anchor" href="#拦截导弹"></a> 拦截导弹</h2>
<p>某国为了防御敌国的导弹袭击，开发出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭，并观测到导弹依次飞来的高度，请计算这套系统最多能拦截多少导弹。拦截来袭导弹时，必须按来袭导弹袭击的时间顺序，不允许先拦截后面的导弹，再拦截前面的导弹。<br />
求最多拦截导弹数量</p>
<h3 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h3>
<ol>
<li>本题求的是最长非递增子序列(不需连续)</li>
<li>对于第i个高度，可以将它加在它前面的比他大的序列末尾，并且保证加在最长的那条序列尾部即可</li>
<li>递推公式
<ol>
<li>f[1] =1</li>
<li>f[i] = max(1,f[j]+1) ;j&lt;i&amp;&amp;aj&gt;ai</li>
</ol>
</li>
</ol>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 30;</span><br><span class="line">int p[maxn];</span><br><span class="line">int dp[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int k;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;k) &#x3D;&#x3D; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;p[i]);</span><br><span class="line">		fill(dp, dp + k, 0);</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">			int cnt &#x3D; 1;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; i; j++)</span><br><span class="line">				if (p[j] &gt;&#x3D; p[i])</span><br><span class="line">					cnt &#x3D; max(cnt, dp[j] + 1);</span><br><span class="line">			dp[i] &#x3D; cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		int ans &#x3D; 1;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; i++)</span><br><span class="line">			ans &#x3D; max(ans, dp[i]);</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="合唱队形"><a class="markdownIt-Anchor" href="#合唱队形"></a> 合唱队形</h2>
<p>给出k个同学的身高，问在位置不变的情况下，出队几名同学可以是队列呈现中间高两边低的状态</p>
<h3 id="思路-4"><a class="markdownIt-Anchor" href="#思路-4"></a> 思路</h3>
<ol>
<li>分别从两侧求递增子序列，然后求同一位置处两侧序列和最长的，即为结果序列长度</li>
<li>假设第i人满足1中条件，那么第i个人被算了两次，别忘了减去</li>
</ol>
<h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100+5;</span><br><span class="line">int p1[maxn];</span><br><span class="line">int p2[maxn];</span><br><span class="line">int dp1[maxn];</span><br><span class="line">int dp2[maxn];</span><br><span class="line">int k;</span><br><span class="line">void update_dp(int* dp, const int*p) &#123;</span><br><span class="line">	fill(dp, dp + k, 0);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">		int cnt &#x3D; 1;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; i; j++)</span><br><span class="line">			if (p[j] &lt; p[i])</span><br><span class="line">				cnt &#x3D; max(cnt, dp[j] + 1);</span><br><span class="line">		dp[i] &#x3D; cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;k) &#x3D;&#x3D; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;p1[i]);</span><br><span class="line">			p2[k - i - 1] &#x3D; p1[i];</span><br><span class="line">		&#125;</span><br><span class="line">		update_dp(dp1, p1);</span><br><span class="line">		update_dp(dp2, p2);</span><br><span class="line"></span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">			if (ans &lt; dp1[i] + dp2[k-i-1])</span><br><span class="line">				ans &#x3D; dp1[i] + dp2[k-i-1];</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, k-ans+1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最长公共子序列-lcs"><a class="markdownIt-Anchor" href="#最长公共子序列-lcs"></a> 最长公共子序列 LCS</h1>
<p>用dp[i][j]表示S1中前i个字符与S2中前j个字符分别组成的两个前缀字符串的最长公共子串，易知dp[0][j] = 0;递推公式为</p>
<ol>
<li>dp[0][j] = dp[i][0] = 0</li>
<li>dp[i][j] = dp[i-1][j-1]+1;S1[i]==S2[j]</li>
<li>dp[i][j] = max{dp[i][j-1],dp[i-1][j]};S1[i]!=S2[j]</li>
<li>最终dp[n][m]即为最长连续字串长</li>
<li>注意循环范围</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">char s1[maxn];</span><br><span class="line">char s2[maxn];</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line">int lcs(const char *s1, const char *s2) &#123;</span><br><span class="line">	memset(dp, 0, sizeof(dp));</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; strlen(s1); i++) &#123;</span><br><span class="line">		for (int j &#x3D; 1; j &lt;&#x3D; strlen(s2); j++) &#123;</span><br><span class="line">			if (s1[i-1] !&#x3D; s2[j-1])</span><br><span class="line">				dp[i][j] &#x3D; max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">			else</span><br><span class="line">				dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return dp[strlen(s1)][strlen(s2)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="状态与状态转移方程"><a class="markdownIt-Anchor" href="#状态与状态转移方程"></a> 状态与状态转移方程</h1>
<h2 id="状态"><a class="markdownIt-Anchor" href="#状态"></a> 状态</h2>
<ol>
<li>是一个数字量</li>
<li>可以描述一个状态的特征而不需要其他的辅助信息</li>
<li>状态间的转移完全依赖于状态本身</li>
</ol>
<h2 id="状态转移"><a class="markdownIt-Anchor" href="#状态转移"></a> 状态转移</h2>
<ol>
<li>指由一个或多个状态得到新状态的过程</li>
</ol>
<h1 id="动态规划问题举例"><a class="markdownIt-Anchor" href="#动态规划问题举例"></a> 动态规划问题举例</h1>
<h2 id="hdu-1421-搬寝室"><a class="markdownIt-Anchor" href="#hdu-1421-搬寝室"></a> HDU 1421 搬寝室</h2>
<p>搬寝室是很累的,xhd深有体会.时间追述2006年7月9号,那天xhd迫于无奈要从27号楼搬到3号楼,因为10号要封楼了.看着寝室里的n件物品,xhd开始发呆,因为n是一个小于2000的整数,实在是太多了,于是xhd决定随便搬2<em>k件过去就行了.但还是会很累,因为2</em>k也不小是一个不大于n的整数.幸运的是xhd根据多年的搬东西的经验发现每搬一次的疲劳度是和左右手的物品的重量差的平方成正比(这里补充一句,xhd每次搬两件东西,左手一件右手一件).例如xhd左手拿重量为3的物品,右手拿重量为6的物品,则他搬完这次的疲劳度为(6-3)^2 = 9.现在可怜的xhd希望知道搬完这2*k件物品后的最佳状态是怎样的(也就是最低的疲劳度),请告诉他吧.</p>
<p>每组输入数据有两行,第一行有两个数n,k(2&lt;=2*k&lt;=n&lt;2000).第二行有n个整数分别表示n件物品的重量(重量是一个小于2^15的正整数).</p>
<p>对应每组输入数据,输出数据只有一个表示他的最少的疲劳度,每个一行.</p>
<h3 id="思路-5"><a class="markdownIt-Anchor" href="#思路-5"></a> 思路</h3>
<ol>
<li>
<p>设dp[i][j]表示前i件物品组成j对所消耗的体力最小；所以分成了两种情况</p>
<ol>
<li>第j对里含有第i件物品，则dp [i][j] = dp [i-2][j-1] + (a[i]-a[i-1])*(a[i]-a[i-1]);</li>
<li>不含第i件物品则有：dp [i][j] = dp [i-1][j];</li>
</ol>
</li>
<li>
<p>总上，动态转移方程为:dp[i][j]=min(dp[i-2][j-1]+(a[i]-a[i-1])*(a[i]-a[i-1]), dp[i][j]=dp[i-1][j]);</p>
</li>
</ol>
<h3 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">int dp[2010][2010], a[2010];</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, k;</span><br><span class="line">	while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;k))</span><br><span class="line">	&#123;</span><br><span class="line">		int i, j;</span><br><span class="line">		memset(a, 0, sizeof(a));</span><br><span class="line">		memset(dp, 0, sizeof(dp));</span><br><span class="line">		for (i &#x3D; 0; i &lt;&#x3D; n; i++)</span><br><span class="line">			for (j &#x3D; 1; j &lt;&#x3D; k; j++)</span><br><span class="line">				dp[i][j] &#x3D; inf;</span><br><span class="line">		for (i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">		sort(a, a + n + 1);</span><br><span class="line">		for (i &#x3D; 2; i &lt;&#x3D; n; i++)</span><br><span class="line">			for (j &#x3D; 1; j * 2 &lt;&#x3D; i; j++)</span><br><span class="line">				dp[i][j] &#x3D; min(dp[i - 1][j], dp[i - 2][j - 1] + (a[i] - a[i - 1])*(a[i] - a[i - 1]));</span><br><span class="line">		printf(&quot;%d\n&quot;, dp[n][k]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hdu-3578-greedy-tino"><a class="markdownIt-Anchor" href="#hdu-3578-greedy-tino"></a> HDU 3578 Greedy Tino</h2>
<p>未完待续</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define OFFSET 2000&#x2F;&#x2F;因为j有正负，所以添加一个偏移量，方便做题</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line">int wi[101];</span><br><span class="line">int dp[101][4001];</span><br><span class="line">int max(int a, int b, int c)&#123;</span><br><span class="line">    int flag &#x3D; a;</span><br><span class="line">    if(flag &lt; b)&#123;</span><br><span class="line">        flag &#x3D; b;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag &lt; c)&#123;</span><br><span class="line">        flag &#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i&#x3D;0;i&lt;40001;i++)</span><br><span class="line">            dp[0][i] &#x3D; -INF;</span><br><span class="line">    dp[0][OFFSET] &#x3D; 0;&#x2F;&#x2F;core</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t, n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; t; i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        wi[0] &#x3D; 0;</span><br><span class="line">         bool hasZero &#x3D; false;</span><br><span class="line">        int cnt &#x3D; 0;</span><br><span class="line">        for(int j &#x3D; 0; j &lt; n; j++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;wi[++cnt]);</span><br><span class="line">            if(wi[cnt] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                   hasZero &#x3D; true;</span><br><span class="line">                   cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n &#x3D; cnt;</span><br><span class="line">        init();</span><br><span class="line">        for(int j &#x3D; 1; j &lt;&#x3D; n; j++)&#123;</span><br><span class="line">            for(int k &#x3D; -2000; k &lt;&#x3D; 2000; k++)&#123;</span><br><span class="line">                dp[j][k+OFFSET] &#x3D; max(dp[j-1][k-wi[j]+OFFSET]+wi[j], dp[j-1][k+wi[j]+OFFSET]+wi[j], dp[j-1][k+OFFSET]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf (&quot;Case %d: &quot;, i+1);</span><br><span class="line">        if(dp[n][0+OFFSET] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            if(hasZero &#x3D;&#x3D; true)&#123;</span><br><span class="line">                printf(&quot;0\n&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                printf(&quot;-1\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            printf(&quot;%d\n&quot;, dp[n][0+OFFSET]&#x2F;2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="背包"><a class="markdownIt-Anchor" href="#背包"></a> 背包</h1>
<h2 id="0-1背包问题"><a class="markdownIt-Anchor" href="#0-1背包问题"></a> 0-1背包问题</h2>
<p>特点是每个物品只能选一件，即每个物品的数量只能出现0和1</p>
<h3 id="openj_bailian-2726"><a class="markdownIt-Anchor" href="#openj_bailian-2726"></a> OpenJ_Bailian 2726</h3>
<p>辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是辰辰，你能完成这个任务吗？</p>
<h3 id="思路-6"><a class="markdownIt-Anchor" href="#思路-6"></a> 思路</h3>
<ol>
<li>用dp[i][j]表示取前i个物品，重量不超过j时能达到的最大价值。</li>
<li>可以根据第i个物品是否取分成两类
<ol>
<li>取第i个物品，那么需要更新所有能再装下一个i的状态，即dp[i-1][j-p[i].w]</li>
<li>不取i，那么dp[i][j]=dp[i-1][j]</li>
</ol>
</li>
<li>综上，递推关系为dp[i][j] = max(dp[i-1][j], dp[i - 1][j - p[i].w] + p[i].v)</li>
<li><strong>注意</strong> 对于dp[i-1][j]下装不下第i个物品的状态，要赋值为dp[i-1][j]</li>
</ol>
<h3 id="代码-5"><a class="markdownIt-Anchor" href="#代码-5"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line">struct node &#123;</span><br><span class="line">	int w;</span><br><span class="line">	int v;</span><br><span class="line">&#125;;</span><br><span class="line">int s, m;</span><br><span class="line">node p[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;s, &amp;m) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;p[i].w, &amp;p[i].v);</span><br><span class="line"></span><br><span class="line">		memset(dp, 0, sizeof(0));</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">			for (int j &#x3D; s; j &gt;&#x3D; p[i].w; j--) &#123;</span><br><span class="line">				dp[i][j] &#x3D; max(dp[i-1][j], dp[i - 1][j - p[i].w] + p[i].v);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			for (int j &#x3D; p[i].w-1; j &gt;&#x3D; 0; j--)&#x2F;&#x2F;对于p[i].w-1~1的状态只能来自于dp[i-1][j]</span><br><span class="line">				dp[i][j] &#x3D; dp[i-1][j];</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, dp[m][s]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h3>
<ol>
<li>发现新的状态至于最近的一个状态有关，所以可以降维。</li>
<li>状态转移方程为：dp[j]=max{dp[j-p[i].w]+v,dp[i]}</li>
<li><strong>注意</strong> 更新dp时是逆序更新，这是因为在0-1背包问题中每个物品至多放入一次。逆序循环，保证了更新dp[j]时，dp[j-p[i].w]是没有放入i时的数据(dp[i-1][j-p[i].w])</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">	for (int j &#x3D; s; j &gt;&#x3D; p[i].w; j--) &#123;</span><br><span class="line">		dp[j]&#x3D;max(dp[j-p[i].w]+v,dp[i]);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完全背包问题"><a class="markdownIt-Anchor" href="#完全背包问题"></a> 完全背包问题</h2>
<p>每种物品的数量可以任意多</p>
<h3 id="hdu-1114-piggy-bank"><a class="markdownIt-Anchor" href="#hdu-1114-piggy-bank"></a> HDU 1114 Piggy-Bank</h3>
<p>有个存钱罐，已知空罐质量和满罐质量，以及n种硬币质量和价值，求罐中硬币的最小价值。</p>
<h3 id="思路-7"><a class="markdownIt-Anchor" href="#思路-7"></a> 思路</h3>
<ol>
<li>完全背包问题的区别在于，每个物品可以被选择很多次，因此dp[j]可以由已放入物品i后的数据dp[j-p[i].w]得来，所以顺序循环</li>
<li>本题求最小值，将max要换成min</li>
<li>由于要求恰好装满，所以初始时只有dp[0]=0，其他状态都不存在</li>
</ol>
<h3 id="代码-6"><a class="markdownIt-Anchor" href="#代码-6"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 10000+ 5;</span><br><span class="line">int dp[maxn];</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line">struct node &#123;</span><br><span class="line">	int w;</span><br><span class="line">	int v;</span><br><span class="line">&#125;;</span><br><span class="line">int s, m;</span><br><span class="line">node p[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;m, &amp;s);</span><br><span class="line">		s -&#x3D; m;</span><br><span class="line">		int n;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;p[i].v, &amp;p[i].w);</span><br><span class="line">		for (int i &#x3D; 0; i &lt;&#x3D; s; i++)</span><br><span class="line">			dp[i] &#x3D; INF;</span><br><span class="line">		dp[0] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; p[i].w; j &lt;&#x3D; s;j++) &#123;</span><br><span class="line">				if (dp[j - p[i].w] !&#x3D; INF)&#x2F;&#x2F;该状态存在，那么才可以产生新的状态</span><br><span class="line">					dp[j] &#x3D; min(dp[j], dp[j - p[i].w] + p[i].v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (dp[s] !&#x3D; INF)</span><br><span class="line">			printf(&quot;The minimum amount of money in the piggy-bank is %d.\n&quot;, dp[s]);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot;This is impossible.\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多重背包问题"><a class="markdownIt-Anchor" href="#多重背包问题"></a> 多重背包问题</h2>
<p>介于完全背包问题和0-1背包问题之间，每种物品数量有限。可以将k个物品看作k种物品，在进行0-1背包求解。但是这样会使时间复杂度过大。稍加改变，将该种物品分成很多堆，每堆数量为1~k-2<sup>c+1,其中c为使k-2</sup>c+1大于0的最大整数。</p>
<h3 id="hdu-2191-珍惜现在感恩生活"><a class="markdownIt-Anchor" href="#hdu-2191-珍惜现在感恩生活"></a> HDU 2191 珍惜现在，感恩生活</h3>
<p>输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1&lt;=n&lt;=100, 1&lt;=m&lt;=100),分别表示经费的金额和大米的种类，然后是m行数据，每行包含3个数p，h和c(1&lt;=p&lt;=20,1&lt;=h&lt;=200,1&lt;=c&lt;=20)，分别表示每袋的价格、每袋的重量以及对应种类大米的袋数。</p>
<p>对于每组测试数据，请输出能够购买大米的最多重量，你可以假设经费买不光所有的大米，并且经费你可以不用完。每个实例的输出占一行。</p>
<h3 id="思路-8"><a class="markdownIt-Anchor" href="#思路-8"></a> 思路</h3>
<ol>
<li>先将每个物品分成很多堆，类似二进制拆分</li>
<li>然后进行0-1背包求解</li>
</ol>
<h3 id="代码-7"><a class="markdownIt-Anchor" href="#代码-7"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 10000 + 5;</span><br><span class="line">int dp[maxn];</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line">struct node &#123;</span><br><span class="line">	int w;</span><br><span class="line">	int v;</span><br><span class="line">&#125;;</span><br><span class="line">int s, m;</span><br><span class="line">node a[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;s, &amp;m);</span><br><span class="line">		int p, h, c;</span><br><span class="line">		int cnt &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;p, &amp;h, &amp;c);</span><br><span class="line">			int t &#x3D; 1;</span><br><span class="line">			while (c &gt; t)</span><br><span class="line">			&#123;</span><br><span class="line">				c -&#x3D; t;</span><br><span class="line">				a[++cnt].w &#x3D; t * p;</span><br><span class="line">				a[cnt].v &#x3D; t * h;</span><br><span class="line">				t *&#x3D; 2;</span><br><span class="line">			&#125;</span><br><span class="line">			a[++cnt].w &#x3D; p * c;</span><br><span class="line">			a[cnt].v &#x3D; h * c;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		memset(dp, 0, sizeof(dp));</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; cnt; i++) &#123;</span><br><span class="line">			for (int j &#x3D; s; j &gt;&#x3D; a[i].w;j--) &#123;</span><br><span class="line">					dp[j] &#x3D; max(dp[j], dp[j - a[i].w] + a[i].v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;%d\n&quot;, dp[s]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>北大网课</title>
    <url>/2020/03/30/%E5%8C%97%E5%A4%A7%E7%BD%91%E8%AF%BE/</url>
    <content><![CDATA[<h1 id="哈希函数与加密体制"><a class="markdownIt-Anchor" href="#哈希函数与加密体制"></a> 哈希函数与加密体制</h1>
<ol>
<li>性质：
<ol>
<li>抗碰撞性：难以人为制造哈希碰撞。</li>
<li>单向性：前提是输入空间足够大并且输入的分布比较均匀。(如果输入空间不够大，那么把输入后面拼接一个随机数再哈希)</li>
<li>puzzle friendly:比特币特有的性质。比特币区块要求计算出来的哈希值小于等于某一个阈值。</li>
<li>难以计算，但是易于验证。</li>
</ol>
</li>
<li>比特币中用的哈希函数:SHA-256</li>
<li>账户：在本地创建一个公私钥对就是一个账户。</li>
<li>非对称加密体系：公私钥。加密用公钥，解密用私钥，且加密和解密用的是用一个人的公钥和私钥。
<ol>
<li>私钥保存在本地就行，公钥可以公开。</li>
<li>公钥相当于你的银行账号，私钥相当于银行密码。</li>
</ol>
</li>
<li>对称加密体系：加密解密使用同一个密钥，假设前提是存在一种安全的渠道把密钥分发给通信双方。</li>
<li>比特币系统中的公钥和私钥
<ol>
<li>比特币系统中的信息都是公开的</li>
<li>所以私钥用来对交易做签名。我发起一个交易，那么我拿我的私钥进行签名，发布到区块链上，别人再用我的公钥进行验证。</li>
</ol>
</li>
<li>以上所述的公私钥体制建立在有一个好的随机源上，同时每次签名操作也需要一个好的随机源。</li>
</ol>
<h1 id="比特币中的数据结构"><a class="markdownIt-Anchor" href="#比特币中的数据结构"></a> 比特币中的数据结构</h1>
<ol>
<li>哈希指针：比如一个哈希指针指向一个结构体，那么这个指针里不止存它的地址还存它的哈希值。</li>
<li>区块链&amp;普通链表
<ol>
<li>
<p>以哈希指针代替普通指针。</p>
</li>
<li>
<p>后一块的哈希指针是通过前一区块的全部内容(包括前一区块的哈希指针)计算出来的。</p>
<p><strong>这样从最后一个区块就能知道前面的区块是否被修改。</strong></p>
<p><strong>这样系统中的某些节点就不需要保存全部区块信息</strong></p>
</li>
<li>
<p>梅克尔树<br />
<img src="/Iptables_img/2.png" style="zoom:80%"></p>
<ol>
<li>每个区块内部的交易组织成梅克尔树的形式</li>
<li>区块间通过哈希指针连接在一起。</li>
</ol>
</li>
<li>
<p>比特币网络由轻节点和全结点构成，其中</p>
<ol>
<li>轻节点只保存区块头；当轻节点想确认某笔交易是否已经被写进区块链中：轻节点向全节点请求红色的哈希值，轻节点自己计算绿色的哈希值。最终，可以将得到的根哈希值和头部中的根哈希值相比较。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="btc协议比特币的共识机制"><a class="markdownIt-Anchor" href="#btc协议比特币的共识机制"></a> BTC协议：比特币的共识机制</h1>
<p>比特币需要解决问题：双花；发行</p>
<h2 id="双花问题"><a class="markdownIt-Anchor" href="#双花问题"></a> 双花问题</h2>
<ol>
<li>
<p>转账：假如A要向B和C转帐</p>
<ol>
<li>交易需要A的签名，证明是经过A统一 的。</li>
<li>需要指明A的比特币从哪来</li>
<li>注：比特币系统中的交易包括输入和输出两部分，输入部分要指明币的来源，输出部分要给出收款人的公钥的哈希。</li>
</ol>
 <img src="/Iptables_img/8.png" style="zoom:80%">
<p>注意：其中包含两种哈希指针。一种用来构成链表，另一种用来指向前面某个交易，以说明币的来源。</p>
<ol start="4">
<li>
<p>A需要知道B的公钥，B乃至所有节点也需要知道A的公钥，用来验证A的签名。因为怀疑网络中存在恶意节点，所以每个节点都需要亲自验证。</p>
<p><strong>问题</strong>：A的公钥需要A自己去公布；如果某个恶意节点伪造了转账记录，用自己的私钥去签名，再公开自己的公钥说是A的公钥，那么可以转走A上钱么？</p>
<p><strong>不</strong>，因为每个交易要去追溯币的来源，最终会追溯到币基交易，而币基交易（前面的交易）的输出正是A的哈希地址，只有当转帐中用到的公钥和这个哈希能对上，才能认为合法。<br />
2.<strong>注</strong>：加密是用接收者的公钥加密，接收者用自己的私钥解密。</p>
</li>
</ol>
</li>
<li>
<p>区块的头部，包括</p>
<ol>
<li>比特币协议版本信息</li>
<li>指向前一个区块的指针</li>
<li>梅克尔树的根哈希值</li>
<li>挖矿的难度目标阈值（整个块头的哈希要小于等于目标阈值）</li>
<li>随机数</li>
</ol>
</li>
<li>
<p>分布式共识</p>
<ol>
<li>比如分布式哈希表：需要取得共识的是哈希表中包含了哪些 键值对。</li>
</ol>
</li>
<li>
<p>比特币的共识协议：问题出现在比特币系统中部分节点是有恶意的。</p>
<ol>
<li>最简单的，想要通过投票来判断某个节点产生的区块是否正确（区块内部的交易是否都是合法的）。但是存在一个问题，就是如何判断谁有投票资格。
<ol>
<li><strong>女巫攻击</strong>：产生大量的公私钥对，极端情况下超过半数，那么他就得到了控制权。</li>
</ol>
</li>
<li>通过<strong>算力</strong>来投票，每个节点都可以在本地组装候选区块，把他认为合法的交易放进去。然后开始算能够使得头部的哈希值小于目标阈值的随机数的值，找到了这个随机数的节点就获得了记账权，向比特币网络中发布这个区块
<ol>
<li>其他节点收到这个区块后，首先验证nbits域的设置是否符合难度要求；验证头的哈希是否小于等于目标阈值。</li>
<li>然后验证body中的交易
<ol>
<li>是否是合法的签名</li>
<li>以前是否被花过</li>
</ol>
</li>
<li>即使通过了前面的检查，但是该区块不是连接在最长合法链的末尾，也不接受。因为验证交易合法性时候，只去验证他所在的分支。
<ol>
<li><strong>分叉攻击</strong>：通过向区块链中间插入某个区块来回滚某个已经发生的交易。<br />
<img src="/Iptables_img/13.png" style="zoom:80%"></li>
</ol>
</li>
<li>接受一个区块意味着沿着这个区块继续往下扩展。如果产生的链不是基于最长的链，那么他在该链上通过币基交易得到的比特币也是不被认可的非法交易。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>为什么要争夺记账权？为了币基交易的比特币奖励。</p>
</li>
<li>
<p><strong>总结</strong>：比特币系统中的共识是针对分布式账本内容-&gt;只有获得记账权的节点才有权力向账本里写东西，有权决定账本中的内容-&gt;获得记账权需要算力支持-&gt;比特币的投票是基于算力的。</p>
<ol>
<li>比特币的性质：puzzle friendly，即想计算出结果，没有捷径，只有一个个试。</li>
</ol>
</li>
</ol>
<h1 id="比特币系统的实现"><a class="markdownIt-Anchor" href="#比特币系统的实现"></a> 比特币系统的实现</h1>
<ol>
<li>比特币使用基于交易的账本模式</li>
<li>比特币系统的全节点要维护一个UTXO的数据结构（所有没被花掉的交易输出组成的集合）以检查双花问题。</li>
<li><strong>比特币激励机制2</strong>：交易费，激励争夺记账权的节点将他人的交易打包进区块。</li>
<li>想要使哈希值低于根哈希值，一个使太正nance，另一个使调整coinbase，这样搜索空间就达到了2<sup>96。</li>
<li>求解puzzle过程<br />
<img src="/Iptables_img/14.png" style="zoom:80%"></li>
</ol>
<p>其中tx那一串在实际上只需要梅克尔树的根哈希值即可。</p>
<h2 id="挖矿的概率分析"><a class="markdownIt-Anchor" href="#挖矿的概率分析"></a> 挖矿的概率分析：</h2>
<ol>
<li>每次挖矿的过程可以看作是一个伯努利试验。大量的伯努利实验构成一个伯努利程序。
<ol>
<li>性质1：无记忆性</li>
</ol>
</li>
<li>试验次数很多，但是实验成功的概率很小的时候，可以用泊松分布来近似。</li>
<li>整个系统的出块时间是服从指数分布的，平均是10分钟。这个指数分布也是无记忆的。所以将来还要挖多少时间和过去已经挖了多少时间是没有关系的。这也保证了算力强的矿工拥有成比例的优势。</li>
</ol>
<h2 id="比特币系统的总量"><a class="markdownIt-Anchor" href="#比特币系统的总量"></a> 比特币系统的总量</h2>
<ol>
<li>比特币区块奖励是固定的，每个四年减半一次，所以比特币的数量会构成一个几何序列。可以计算出一共只有2100万个比特币。</li>
</ol>
<h2 id="挖矿的意义"><a class="markdownIt-Anchor" href="#挖矿的意义"></a> 挖矿的意义</h2>
<ol>
<li>挖矿本身并不解决什么问题，但是其算力竞争对于维护比特币系统的安全性是至关重要的。只要大部分算力是掌握在诚实节点手里，那么安全性就得以保证。</li>
</ol>
<h2 id="安全性分析"><a class="markdownIt-Anchor" href="#安全性分析"></a> 安全性分析：</h2>
<ol>
<li>恶意节点能否将别人的比特币转走：<strong>不能</strong>，无法伪造签名。如果他把交易硬写到区块链里，那么诚实的节点不会认可这个交易，因为他包含了一个非法的交易</li>
<li>恶意节点能否双花（<strong>分叉攻击</strong>）
<ol>
<li>简单的防范方法是多等待几个区块（几个确认）（比特币协议中是等待6个确认），这样写入了回滚交易的区块想要使自己所在的分支成为最长合法链的难度就大大增加。</li>
</ol>
</li>
<li>恶意节点故意不包含某些交易
<ol>
<li>但是问题不大，总有诚实的节点愿意将交易写入区块。即使不在这个区块里写入，也会写在下一个区块里。</li>
<li>正常的情况下，也有可能出现这种情况，因为比特币协议要求每个区块不得大于1MB。</li>
</ol>
</li>
<li>selfish mining攻击：挖到区块先不发布，攒了一堆再去发布以争夺最长合法链
<ol>
<li><strong>不行</strong>：这对算力要求很大，起码要占据51%以上的算力才有一定的成功的可能性。但是话说回来，如果恶意节点占据了如此大的算力，比特币系统就崩盘了。</li>
<li><strong>出于盈利目的</strong>：如果一个节点的算力特别强，他挖到n+1个区块，之后不发布并立即开始挖第n+2个区块。等到侦听到有人挖到第n+1个区块的时候，他立刻将n+1和n+2个区块同时发布，那么他所在的链就成为了最长合法链，他得到的币基交易才是真实有效的。
<ol>
<li>存在很大的风险：我们只有在假设别人挖出一个的时间里，我可以挖出两个，才能获得更大的利益。如果别人挖完第一个而我没有挖出第二个，那么我只能去碰碰运气。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="比特币网络"><a class="markdownIt-Anchor" href="#比特币网络"></a> 比特币网络</h1>
<ol>
<li>比特币工作在应用层，其底层运行的是一个P2P Overlay网络，且这里的P2P网路中所有节点都是对等的。网络存在一个种子节点，可以通过它直到网络中其他节点的信息。节点之间通过TCP连接（这样有利于穿透防火墙）</li>
<li>每个节点维护一个临近节点集合(临近节点的选取是随机的，而不考虑底层拓扑结构)，消息传播采用洪范方式</li>
</ol>
<h1 id="比特币系统的挖矿难度"><a class="markdownIt-Anchor" href="#比特币系统的挖矿难度"></a> 比特币系统的挖矿难度</h1>
<ol>
<li>通过调整目标空间占搜索空间的比例来调整挖矿难度。</li>
<li>挖矿难度和目标阈值是成反比的。</li>
<li>为什么要维护挖矿难度：
<ol>
<li>如果不调整这个难度，那么随着挖矿的人数增多，设备的进步，那么相对于网路延迟来说，生成区块的速度过快，从而导致多分叉。分叉过多对系统达成共识没有帮助，也会危害到系统的安全性。</li>
<li>回顾分叉攻击：我们只有在假设大部分的算力都掌握在诚实的矿工手里的时候才能避免。如果出现多分叉，那么算力被分散，被分叉攻击的可能性大大增加。</li>
</ol>
</li>
<li>比特币系统规定每个2016个区块调整一次，大约14天一次。且增大和减小都有要求，增大不会一次性增大超过4倍，减少也不会一次减少到1/4以上。</li>
</ol>
<h1 id="比特币挖矿"><a class="markdownIt-Anchor" href="#比特币挖矿"></a> 比特币挖矿</h1>
<ol>
<li>
<p>比特币系统包括全节点和轻节点</p>
 <img src="/Iptables_img/27.png" style="zoom:80%">
<p>全节点：</p>
<ol>
<li>决定沿着那条链挖下去：缺省情况下，沿着最长合法链挖下去。</li>
<li>出现等长分叉：选择最先听到的分叉。</li>
</ol>
 <img src="/Iptables_img/28.png" style="zoom:80%">
<p>轻节点：</p>
<ol>
<li>只能检测合法链，但是不知道哪个是最长合法链。</li>
<li>轻节点假设矿工是有理智的，不会沿着非法的链挖下去。</li>
<li>轻节点在挖矿过程中，如果监听到别的节点已经挖出了新的区块，那么它只能放弃已有的区块。因为梅克尔树的跟哈希值和组成链的哈希指针都发生了变化。尽管如此，这并不可惜，因为挖矿具有无记忆性，成功的概率是没区别的。</li>
</ol>
</li>
<li>
<p>比特币的安全性保障</p>
<ol>
<li>由密码学提供：无法伪造的私钥签名。这个的前提是比特币网络中大多数节点都是好的，不会接受不合法的交易。</li>
<li>由比特币的共识机制提供</li>
</ol>
</li>
<li>
<p>矿石：使得51%以上的攻击变得容易。</p>
</li>
<li>
<p>矿石可发动的攻击：</p>
<ol>
<li>分叉攻击：</li>
<li>Boycott：比如想封锁A账户，可以在任何包含A的交易的区块被发布之后，立刻组装新的不包含A 的交易的区块，并经可能是新区块所在链变为最长合法链。</li>
</ol>
</li>
</ol>
<h1 id="比特币分叉"><a class="markdownIt-Anchor" href="#比特币分叉"></a> 比特币分叉</h1>
<ol>
<li>state fork:两个节点几乎同时挖到了区块。</li>
<li>forking attack（deliberate fork）</li>
<li>protocal fork:由于比特币协议修改导致的分叉
<ol>
<li>硬分叉：这样的分叉是永久的，只要有算力不更新软件就存在。</li>
<li>软分叉：临时性的分叉</li>
</ol>
</li>
</ol>
<h1 id="比特币的匿名性"><a class="markdownIt-Anchor" href="#比特币的匿名性"></a> 比特币的匿名性</h1>
<ol>
<li>
<p>假的匿名，类似于化名不是绝对的。而且比特币的账本是完全公开的，对匿名性一种挑战。</p>
</li>
<li>
<p>实际上不同的地址可能被关联在一起。通过推理出来。</p>
</li>
<li>
<p>如果交易只在区块链内，则不会泄漏。但是一旦和实体世界发生关联，那么就可能泄漏隐私，具体在：</p>
<ol>
<li>比特币支付</li>
<li>资金转入转出的时候</li>
</ol>
</li>
<li>
<p>提高匿名性的方法</p>
<ol>
<li>首先要实现网络层的匿名性：采用多路径转发的方法。</li>
<li>混合币</li>
</ol>
</li>
<li>
<p>保护匿名性很难的原因：（1）区块链是公开的（2）区块链具有不可修改性，一旦某一个交易暴露了身份，影响会是永久的。</p>
</li>
</ol>
<h1 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h1>
<h2 id="哈希指针"><a class="markdownIt-Anchor" href="#哈希指针"></a> 哈希指针</h2>
<ol>
<li>实际上比特币系统只有哈希没有指针。在全节点中,所有的区块是以levelDB这种键值对数据来存储,其中key为哈希值,value为区块内容。</li>
</ol>
<h2 id="区块恋"><a class="markdownIt-Anchor" href="#区块恋"></a> 区块恋</h2>
<ol>
<li>这样会严重影响私钥的安全性，因为私钥长度变短时，暴力破解的搜索空间大大降低。</li>
<li>所以应该用多重签名，其中每个私钥都是独立产生的。</li>
<li>如果两个人分手，那么所有的币都会被存在UTXO中。</li>
</ol>
<h2 id="分布式共识"><a class="markdownIt-Anchor" href="#分布式共识"></a> 分布式共识</h2>
<ol>
<li>实际上比特币并没有达成真正意义的共识。随时可能被推翻。</li>
</ol>
<h2 id="比特币的稀缺性"><a class="markdownIt-Anchor" href="#比特币的稀缺性"></a> 比特币的稀缺性</h2>
<ol>
<li>总量一定的东西并不适用于做货币。因为随着社会财富总值的增长，每单位该种货币就变得越来越值钱，先买的人就越来越富，后面的人就永远也赶不上。就像房地产。</li>
</ol>
<h1 id="以太坊概述"><a class="markdownIt-Anchor" href="#以太坊概述"></a> 以太坊概述</h1>
<ol>
<li>memory hard mining puzzle</li>
<li>以后想权益证明代替工作量证明，用类似于股权投票的方式。</li>
<li>智能合约：去中心化合约。加入参与方来自世界各地，那么手段维持合约的有效性就很困难，所以考虑写成程序，写进区块链。</li>
</ol>
<h1 id="以太坊中的账户"><a class="markdownIt-Anchor" href="#以太坊中的账户"></a> 以太坊中的账户</h1>
<ol>
<li>BTC中需要统计所有的UTXO。</li>
<li>账户天然的防护了双花问题。但是存在重放攻击。</li>
</ol>
<h2 id="重放攻击"><a class="markdownIt-Anchor" href="#重放攻击"></a> 重放攻击：</h2>
<ol>
<li>假设A给B转了一次帐，广播过一次，之后B又向网络广播这次交易。那么网络中的其他节点就会认为A又向B转账了一次。</li>
<li><strong>解决</strong>：多维护一个交易次数的属性，在签名的保护下一起发布出去。系统中的全节点维护这个交易次数值。假设A-&gt;B是第20次，那么全节点认为下次来的应该是第21，那么即使B重放，也不行。</li>
</ol>
<h2 id="外部账户"><a class="markdownIt-Anchor" href="#外部账户"></a> 外部账户</h2>
<ol>
<li>由公私钥控制，包括账户余额和交易次数。</li>
</ol>
<h2 id="合约账户"><a class="markdownIt-Anchor" href="#合约账户"></a> 合约账户</h2>
<ol>
<li>不是由公私钥对控制，也有nonce值，用来标识调用别的合约的次数。还有code，storage。但是合约账户不能主动发起交易。</li>
</ol>
<h2 id="为什么有合约"><a class="markdownIt-Anchor" href="#为什么有合约"></a> 为什么有合约</h2>
<ol>
<li>为了支持智能合约，要求参与者有相对稳定的身份。</li>
</ol>
<h1 id="以太坊状态树"><a class="markdownIt-Anchor" href="#以太坊状态树"></a> 以太坊状态树</h1>
<p>目的是建立一个账户到状态的映射。以太坊的账户为160b，状态包括余额、交易次数（代码，存储）。</p>
<h2 id="trie"><a class="markdownIt-Anchor" href="#trie"></a> Trie</h2>
<ol>
<li>
<p>优点：</p>
<ol>
<li>每个节点的分叉数目取决于取值范围。</li>
<li>查找效率取决于键的长度。</li>
<li>插入顺序不一样，得到的结构也一样。</li>
<li>更新局部性很好，每个区块对应的账户很少，伊这种结构不需要管别的分支</li>
</ol>
</li>
<li>
<p>缺点：</p>
<ol>
<li>存储浪费</li>
<li>查找效率与深度有关</li>
</ol>
</li>
</ol>
<h2 id="patricia-tree"><a class="markdownIt-Anchor" href="#patricia-tree"></a> Patricia tree</h2>
<ol>
<li>是路径压缩的trie树。键值分布稀疏的时候比较好。</li>
</ol>
<h2 id="mpt-merkle-partricia-tree"><a class="markdownIt-Anchor" href="#mpt-merkle-partricia-tree"></a> MPT Merkle Partricia Tree</h2>
<ol>
<li>路径压缩加路径压缩</li>
<li>优点：
<ol>
<li>放篡改</li>
<li>可以证明账户上的余额。</li>
<li>还可以证明某个键值是不存在的。</li>
</ol>
</li>
</ol>
<h2 id="modified-mpt"><a class="markdownIt-Anchor" href="#modified-mpt"></a> Modified MPT</h2>
<ol>
<li>以太坊的结构是一颗大的MPT包含很多小的MPT，每一个合约账户就是一颗小的MPT</li>
<li>系统中的全节点维护的不是一颗MPT，而是每产生一个新的区块就新建一颗MPT,这些树中大部分的节点是共享的，只有少数更新的节点要新建分支。</li>
<li>保留历史状态是因为可能需要回滚交易，比如分叉的时候。以太坊由于智能合约的出现，所以很难去反向推算前一个状态，所以要保存。</li>
<li>状态树中保存的是键值对，地址作为key。而value要首先经过序列化之后再存储，大致理解为变成字节数组。</li>
</ol>
<h1 id="以太坊数据结构"><a class="markdownIt-Anchor" href="#以太坊数据结构"></a> 以太坊数据结构</h1>
<h2 id="交易树也是一种mpt"><a class="markdownIt-Anchor" href="#交易树也是一种mpt"></a> 交易树–也是一种MPT</h2>
<ol>
<li>区块中的交易形成一颗交易树</li>
</ol>
<h2 id="收据树也是一种mpt"><a class="markdownIt-Anchor" href="#收据树也是一种mpt"></a> 收据树–也是一种MPT</h2>
<ol>
<li>每个交易执行完，会形成一颗收据树，记录这个交易的相关信息。交易树和收据树上的节点是一一对应的。利于快速查找执行的结果。</li>
<li>每个区块的交易树和收据树都是独立的。他们发布的交易本身我们也认为是独立的。</li>
</ol>
<h2 id="bloom-filter"><a class="markdownIt-Anchor" href="#bloom-filter"></a> bloom filter</h2>
<ol>
<li>为了在大的集合中进行查找，以支持复杂的查询操作。</li>
<li>一般的扫描存在存储问题和查找效率问题。</li>
<li>将每个元素取一个哈希，形成一个向量，其中某位为1代表该对应该哈希值的元素存在，这个向量称为摘要。</li>
<li>不支持删除操作。</li>
<li>作用：加入要查找过去十天发生的和某个智能合约相关的交易。首先，查找区块块头的bloom filter，看哪个块头的bloom filter里有我要的类型。如果某个块头里有，在去找对应收据树里的bf,看看哪个有。有的再去仔细查看。</li>
</ol>
<h2 id="以太坊的运行过程"><a class="markdownIt-Anchor" href="#以太坊的运行过程"></a> 以太坊的运行过程</h2>
<p>看成是交易驱动的状态机。状态是所有账户的状态；交易每次发布区块包含的交易，这些交易会驱动从当前的状态转移到下一个状态。</p>
<h1 id="ghost协议利于出现分叉后及时合并"><a class="markdownIt-Anchor" href="#ghost协议利于出现分叉后及时合并"></a> GHOST协议–利于出现分叉后及时合并</h1>
<ol>
<li>
<p>没有竞争称为最长合法链上的区块也会发放一定的出块奖励（7/8）称为叔父区块。下一个区块要包含所有叔父区块，同时得到1/32个出块奖励的额外报酬。最多可以包含两个叔父区块。</p>
</li>
<li>
<p>不在最长合法链上的区块都是叔父区块，即使是爷爷啥的。</p>
</li>
<li>
<p>为了防止在挖矿难度较低的时候产生叔父而不当获利，最多7代。叔父区块中的交易不执行，所以也不检查交易合法性，只检查是否符合挖矿难度。</p>
 <img src="/Iptables_img/52.png" style="zoom:80%">	
</li>
<li>
<p>GHOST机制是为了解决临时性的分叉。</p>
</li>
</ol>
<h1 id="以太坊的挖矿算法"><a class="markdownIt-Anchor" href="#以太坊的挖矿算法"></a> 以太坊的挖矿算法</h1>
<ol>
<li>求解很难，验证简单、</li>
<li>回避ASIC芯片。</li>
</ol>
<h2 id="lite币"><a class="markdownIt-Anchor" href="#lite币"></a> Lite币</h2>
<ol>
<li>基于Scrypt加密，需要大内存来保存这个数组。</li>
<li>但是设定小了，只有128K。</li>
</ol>
<h2 id="以太币"><a class="markdownIt-Anchor" href="#以太币"></a> 以太币</h2>
<ol>
<li>有两个数据集，初始一个是16M的cache，另一个是1G的DAG。DAG从cache中生成出来。轻节点只需要保存cache便于验证。</li>
<li>cache形成 ：首先从一个种子节点开始依次去哈希来填充数组。</li>
<li>DAG形成：从cache里随机读一个数，然后进行哈希计算，得到下一个要读取的数的位置。然后用cache中这个位置的数和当前的哈希值再计算出一个哈希值，反复迭代256次，将最终得到的数填充到数组的第一个位置。</li>
<li>挖矿的时候，先根据块头和nonce值计算一个哈希，这个哈希映射到数组中的某一个位置。通过这个位置和相邻位置的元素进行运算得到下一个位置，循环64次，最后得到的哈希值与目标阈值比较，看一下是否成功。不成功则换下一个nonce。</li>
<li>生成cache的seed每隔3w个区块会变一下。同时cache和DAG大小会增加1/128。</li>
</ol>
<h1 id="智能合约"><a class="markdownIt-Anchor" href="#智能合约"></a> 智能合约</h1>
<ol>
<li>外部账户可以调用合约，一个合约可以调用另一个合约。只有外部账户可以调用。</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链目录</title>
    <url>/2020/03/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="北大网课"><a class="markdownIt-Anchor" href="#北大网课"></a> <a href="/2020/03/30/%E5%8C%97%E5%A4%A7%E7%BD%91%E8%AF%BE">北大网课</a></h2>
<h2 id="区块链自学"><a class="markdownIt-Anchor" href="#区块链自学"></a> <a href="/2020/03/30/%E5%8C%BA%E5%9D%97%E9%93%BE">区块链自学</a></h2>
<h2 id="区块链小论文"><a class="markdownIt-Anchor" href="#区块链小论文"></a> <a href="/2020/03/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B0%8F%E8%AE%BA%E6%96%87">区块链小论文</a></h2>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>反片语</title>
    <url>/2020/03/30/%E5%8F%8D%E7%89%87%E8%AF%AD/</url>
    <content><![CDATA[<h1 id="uav156-反片语"><a class="markdownIt-Anchor" href="#uav156-反片语"></a> uav156 反片语</h1>
<p>输入一些单词，找出所有满足如下条件的单词：该单词不能通过字母重排，得到输入文本的另外一个单词。在判断是否满足条件时，字母不分大小写，但在输出时应保留输入中的大小写，按字典序进行排列(所有大写字母在所有小写字母的前面)</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<p>由于单词可以重拍，所有直接对各单词进行标准化，以便于使用map；map<br />
为&lt;string,int&gt;，其中值对应单词出现次数；使用向量word记录原单词，向量ans记录答案序列；</p>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<pre><code>#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
vector&lt;string&gt;word;
map&lt;string, int&gt; cnt;
string standard(const string &amp;in) {
string s = in;
for (int i = 0; i &lt; s.length(); i++) {
	s[i] = tolower(s[i]);
}
</code></pre>
<ol>
<li>此处书上是按上述方式给的，如果形参表写成const string s，之后直接操作s，并且返回s也没发现问题。</li>
<li>注意此处const的用法，编写该模块前如果认定了in仅作为输入，则加上const防止之后错误的操作。</li>
</ol>
<h1 id=""><a class="markdownIt-Anchor" href="#"></a> </h1>
<pre><code>sort(s.begin(), s.end());
return s;
}
int main() {
string s;
while (cin &gt;&gt; s) {
	if (s[0] == '# ')	break;
	word.push_back(s);
	string r = standard(s);
	if (!cnt.count(r)) cnt[r] = 0;
	cnt[r]++;
}
vector&lt;string&gt; ans;
for (int i = 0; i &lt; word.size(); i++) {
	if (cnt[standard(word[i])] == 1) ans.push_back(word[i]);
}
sort(ans.begin(), ans.end());

for (int i = 0; i &lt; ans.size(); i++) {
	cout &lt;&lt; ans[i] &lt;&lt; endl;
}
}
</code></pre>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<ol>
<li>本题主要是map的应用，想要用map，标准化的步骤是关键。</li>
<li>map提供了&quot;[]“运算符，map[键]=值，使得map可以像数组一样使用。事实上，map也成为&quot;关联数组”。</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>单向TSP</title>
    <url>/2020/03/30/%E5%8D%95%E5%90%91TSP/</url>
    <content><![CDATA[<h1 id="uva-116-单向tsp"><a class="markdownIt-Anchor" href="#uva-116-单向tsp"></a> UVA 116 单向TSP</h1>
<p>给一个m行n列（m≤10，n≤100）的整数矩阵，从第一列任何一个位置出发每次往右、右上、右下走一格，最终到达最后一列。要求经过的整数之和最小。整个矩阵是环形的，即第一行的上一行是最后一行，最后一行的下一行是第一行。输出路径上每列的行号。多解时输出字典序最小的。</p>
<p>输入：有若干组数据：每组的第1行：m和n，分别为行数和列数。每组的第2~m+1行：每行n个数，用空格分开，代表整数矩阵。</p>
<p>输出：每组有两行，第一行是每列的行号，第二行是路径的经过的整数之和。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>定义dp(i,j)为从(i,j)格除法到最后一行的最小开销。易知边界条件为dp(r-1,j) = a[r-1][j]，因此从后往前遍历，即从底边走到顶边</li>
<li>关于决策：在每一种状态dp，可能的方案有，直行，右上和右下</li>
<li>计算dp(i,j)的过程中要同时记录下一刻的行号的最小值(保证最优的条件下)。并记录达到顶边时最小的开销对应的列号列号</li>
<li>最终的答案是依据next中记录的路径进行遍历得到</li>
<li>是一个多阶段决策问题，每一列是一个阶段，每个阶段都有3种决策。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">int p[maxn][maxn];</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line">int next[maxn][maxn];</span><br><span class="line">#define inf 10000000</span><br><span class="line">int main() &#123;</span><br><span class="line">	int r, c;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;r, &amp;c) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++)</span><br><span class="line">			for (int j &#x3D; 0; j &lt; c; j++)</span><br><span class="line">				scanf(&quot;%d&quot;, &amp;p[i][j]);</span><br><span class="line"></span><br><span class="line">		int ans &#x3D; inf, first &#x3D; 0;</span><br><span class="line">		for (int j &#x3D; c - 1; j &gt;&#x3D; 0; j--) &#123; &#x2F;&#x2F;注意逆序</span><br><span class="line">			for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">				if (j &#x3D;&#x3D; c - 1) dp[i][j] &#x3D; p[i][j];&#x2F;&#x2F;边界</span><br><span class="line">				else &#123;</span><br><span class="line">					int row[3] &#x3D; &#123; i,i - 1 ,i + 1 &#125;;&#x2F;&#x2F;此处比较细节</span><br><span class="line">					if (i &#x3D;&#x3D; 0) row[1] &#x3D; r - 1;</span><br><span class="line">					if (i &#x3D;&#x3D; r - 1) row[2] &#x3D; 0;</span><br><span class="line">					sort(row, row + 3);&#x2F;&#x2F;为了字典序</span><br><span class="line"></span><br><span class="line">					dp[i][j] &#x3D; inf;</span><br><span class="line">					for (int k &#x3D; 0; k &lt; 3; k++) &#123;</span><br><span class="line">						int nv &#x3D; dp[row[k]][j + 1] + p[i][j];</span><br><span class="line">						if (nv &lt; dp[i][j]) &#123;&#x2F;&#x2F;填充dp，记录后继点</span><br><span class="line">							dp[i][j] &#x3D; nv;</span><br><span class="line">							::next[i][j] &#x3D; row[k];</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				if (j &#x3D;&#x3D; 0 &amp;&amp; dp[i][j] &lt; ans) &#123;&#x2F;&#x2F;更新答案，记录路径起始点</span><br><span class="line">					ans &#x3D; dp[i][j];</span><br><span class="line">					first &#x3D; i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;%d&quot;, first + 1);</span><br><span class="line">		for (int i &#x3D; ::next[first][0], j &#x3D; 1; j &lt; c; i &#x3D; ::next[i][j], j++)</span><br><span class="line">			printf(&quot; %d&quot;, i + 1);</span><br><span class="line">		printf(&quot;\n%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链小论文</title>
    <url>/2020/03/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%B0%8F%E8%AE%BA%E6%96%87/</url>
    <content><![CDATA[<h1 id="摘-要"><a class="markdownIt-Anchor" href="#摘-要"></a> 摘    要</h1>
<p>区块链技术在电子加密货币、存证鉴伪、供应链溯源、选举投票、物联网等场景中有广泛应用。从最初的比特币，到后来代表区块链技术2.0的以太坊，再到现在的石墨烯技术上建立的去中心化应用，区块链技术在不断的完善着。本文将针对区块链技术及其发展，从数据结构、共识机制等角度探讨自己关于这几代区块链技术的认识和理解，最后再结合一个实例来讨论区块链3.0之后的去中心化应用及发展。</p>
<p>关键词：区块链；比特币； 数据结构； 共识机制；去中心化应用</p>
<h1 id="第1章-绪-论"><a class="markdownIt-Anchor" href="#第1章-绪-论"></a> 第1章  绪 论</h1>
<h2 id="11-区块链起源"><a class="markdownIt-Anchor" href="#11-区块链起源"></a> 1.1  区块链起源</h2>
<p>2008年中本聪综合前人在加密货币上的成果提出了比特币的概念，并于2009年1月3日挖出了创世区块，实现了数字世界的价值表示与价值转移，也引发了人们对其底层技术–区块链技术的探索。在比特币之前就有很多专家进行过加密货币的研究，并给出了自己方案，如亚当·贝克的哈希现金，哈尔·芬妮的比特黄金，戴伟的B-Money等。他们的方案存在着一个共同点，就是要通过计算机的计算来创造电子现金。在这种思想的基础上，中本聪融合前人观点，设计了基于工作量证明的共识机制，使得去中心化成为可能，最终解决了数字现金的问题。</p>
<h2 id="12-以太坊"><a class="markdownIt-Anchor" href="#12-以太坊"></a> 1.2  以太坊</h2>
<p>以太坊创始人维塔利克分析了比特币系统，在比特币系统的四点不足上建立以太坊。其目标是建立一个新的区块链，内设有成熟的图灵完备的语言，可以利用这种语言来编写代码，创建合约，实现任意的状态转换。</p>
<p>以太坊的突出贡献在于实现了智能合约，使区块链技术从数字货币向数字资产转变。对于由智能合约来控制的实体资产，引用萨博的例子来说明：&quot;例如，为了防止一部车被偷窃，除非确定拥有者完成正确的&quot;挑战响应协议&quot;，否则车是不会启动激活的。例如，如果车是贷款买的，当拥有者无法偿还贷款时，智能合约将会自动启动扣押令，并将车钥匙的控制权交给银行。一旦拥有者还清贷款，智能合约就移除扣押令。&quot;总而言之，以太坊的出现使得创造通证变得简单。随着物联网技术的发展，越来越多的机器需要通证，基于区块链技术，为机器设计专用的钱包和通证将成为未来物联网发展的又一可能。</p>
<h2 id="13-eos"><a class="markdownIt-Anchor" href="#13-eos"></a> 1.3  EOS</h2>
<p>在《区块链革命》中，商业思想家唐·塔普斯科特这样写道：&quot;区块链上运行的所有计算资源可以在整体上视为一台计算机。&quot;。仔细考虑使用一条区块链所需要的资源，包括带宽资源（相当于硬盘）、计算资源（相当于CPU）、        状态资源（相当于RAM），确实和一台计算机十分相似。以太坊曾把自己定位为一台&quot;全球分布式计算机&quot;，那么EOS就是建立在这台计算机上的软件系统，他代表了区块链应用的一种发展方向，即开发一条通用的基础公链，实现一切去中心化。通过相关资料，我发现EOS已经在许多方面大异于比特币和以太坊，比如他的共识机制、        区块产生方式，账户等，并且开创性的提出了基于角色的权限系统。目前来说，区块链技术想要落地应用还有很多问题没有解决，哪条路才是切实有效的也没有定论，未来等着我们去探索。</p>
<h2 id="14-结构安排"><a class="markdownIt-Anchor" href="#14-结构安排"></a> 1.4  结构安排</h2>
<p>本文共分为三大部分，首先从比特币说起，讲述我学习到的比特币系统，阐述其数据结构、共识机制，分析安全性等。之后，讨论代表区块链2.0的以太坊，由于他的共识机制基本与比特币相同，所以主要阐述了以太坊的三种主要的数据结构。第三部分，阐述了区块链应用的可能方向以及一款基于功能类公链的应用实例–Steemit。</p>
<h1 id="第2章-比特币系统的技术原理及安全分析"><a class="markdownIt-Anchor" href="#第2章-比特币系统的技术原理及安全分析"></a> 第2章 比特币系统的技术原理及安全分析</h1>
<p>在比特币系统中第一次给出了区块链技术的定义：&quot;区块链是数字世界中进行价值表示和价值转移的技术。&quot;而比特币作为区块链硬币，他的一面是表示价值的加密数字货币或通证，另一面是进行价值转移的分布式账本与去中心网络。本章将从分布式账本与去中心网络及数据结构的角度讨论比特币系统，并分析其安全性。</p>
<h2 id="21分布式账本与去中心网络"><a class="markdownIt-Anchor" href="#21分布式账本与去中心网络"></a> 2.1分布式账本与去中心网络</h2>
<p>威廉·穆贾雅在《商业区块链》中将比特币总结为四个要点分别是：点对点电子交易；不需要金融机构；加密证据而不是中心化信用；信用存在于网络，而不是某个中心机构。</p>
<p>现如今的数字世界中的货币有三种存在形式，包括中心化的在线支付，如微信、支付宝等；中心化互联网积分，如Q币等；去中心化的电子现金。在中心化的在线支付系统中流转的货币是各种法币的映射，这些映射来的&quot;数字货币&quot;本身没有价值，其价值依赖于法币本身的购买力。同样中心化的互联网积分，其价值不与任何法币想关联，        完全由发行公司决定，且只能用于购买这家公司的服务和产品。对于比特币系统的去中心网络比特币的价值由其算法保证，即使整体的算力出现波动，算法也能在至多2016个区块后通过调整目标阈值来调整挖矿难度，从而使得比特币系统的平均出块间隔维持在10分钟左右，以此保证了比特币系统内部比特币的价值稳定（与法币的汇率不是由比特币系统决定的）。比特币的以上优点很大程度上是得益于其分布式账本和去中心网络。</p>
<p>比特币的去中心网络由由众多轻节点和全结点组成，其中全节点包含所有比特币区块链的区块数据，轻节点仅包含自己相关的数据。并且比特币网络是开放的，任何服务器都可以加入成为全结点，共同维护这个去中心网络。由于网络没有一个类似于&quot;央行&quot;的中心化组织存储信息，所以所有用户持有的比特币信息都存在一个分布式账本中，可以认为同时存储在所有全结点中。</p>
<h2 id="22比特币系统的加密体制"><a class="markdownIt-Anchor" href="#22比特币系统的加密体制"></a> 2.2比特币系统的加密体制</h2>
<p>比特币与密码学是密不可分的，从比特币&quot;账户&quot;（实际是地址）产生就使用了非对称密码体制，到每次交易签名，再到区块链内部的梅克尔树，以及区块链间的哈希指针都反应了密码学原理。</p>
<p>首先，在生成一个比特币账户时，实际上我们得到的一对公私钥对，其中公钥的哈希值即为比特币地址，作为转账交易的收付款地址；而私钥用于对我支付的每一笔交易进行签名。当我发起一笔交易时，我将用我的私钥对这笔交易记录进行签名， 同时广播出我的公钥以便其他的节点能够验证这笔交易的合法性，同时我还要为这笔交易付一点&quot;小费&quot;。这样操作下来，再等上一段时间，我的交易就会被写入区块链中成为不可逆的交易。</p>
<p>比特币系统使用的哈希函数是 SHA-256。除了哈希函数本身的抗碰撞性和单向性外，应用于比特币系统的哈希值还有puzzle friendly的性质，即要求块头的哈希值小于某个目标阈值。以及难于计算，但易于验证的性质。这些性质一方面保证了区块链上数据的不可篡改性，另一方面也为各个节点达成共识提供了基础保障。</p>
<p>此外，这种密码体制的安全性还建立在一个好的随机源上，这样才能确保有足够大的搜索空间来保证安全性。</p>
<h2 id="23比特币区块链的数据结构"><a class="markdownIt-Anchor" href="#23比特币区块链的数据结构"></a> 2.3比特币区块链的数据结构</h2>
<p>比特币区块链是一条通过哈希指针连接起来的链表。后一的区块的哈希指针是通过前一区块的全部内容(包括前一区块的哈希指针)计算出来的。这样从最后一个区块就能知道前面的区块是否被修改，使得系统中的某些节点不需要保存全部区块信息。</p>
<p>每个区块中的数据是被打包进这个区块的一系列交易，这些交易按规则形成一颗梅克尔树。梅克尔树是一颗由哈希指针连接起来的哈希树，其中叶子节点是要打包进区块的交易信息，非叶子节点是由叶子节点计算而来的哈希值。这样设计有很多好处，比如一个轻节点如果想知道自己的交易(位于第n层)是否已经被打包进区块链中，那么他只需要向全节点请求他不在的那条路径上非叶子节点的哈希值。之后，它就可以先计算要验证交易的哈希值（这一定是已知的），再将这个哈希与全节点给出的第（n-1）层的哈希值共同计算(n-2)层的哈希值，如此迭代下去，最终可以求得这笔交易所在的梅克尔树的根哈希值。将这个根哈希值与全节点给出的根哈希值比较即可验证交易。这样设计使得更多的节点能够低门槛的连入比特币系统，增加了比特币系统的活跃程度。</p>
<p>此外，区块头部中也包含着很多的重要信息，比如比特币版本协议信息，指向前一个区块的指针，梅克尔树的根哈希值，挖矿的难度目标阈值，随机数等。这些信息对于比特币系统达成共识有着至关重要的作用。</p>
<h2 id="24比特币系统的共识机制"><a class="markdownIt-Anchor" href="#24比特币系统的共识机制"></a> 2.4比特币系统的共识机制</h2>
<p>所谓共识机制，指的是众多互不相识、互不信任的节点之间就交易的合法性达成一致意见。这对于比特币这样一个去中心化的网络十分重要，只有确保了共识机制，才能保证不同账本节点上数据的一致性和正确性。</p>
<p>比特币系统所采用的策略是工作量证明。简单来说就是通过求解一个随机数来使得块头的哈希值小于一个给定的目标阈值，这个过程也称为挖矿。从概率学的角度来说，每次实验都可以看作是一次伯努利实验。当试验次数很多，而成功概率很小的时候，我们就可以用泊松分布来近似。也就是说，在比特币系统中，想要得到记账权没有任何捷径可走，只能单纯的通过反复尝试不同的随机数来求解。这也就保证了每个挖出区块的节点都是做了大量的工作来维护这条区块链，从而保证了区块链上数据的一致性。</p>
<p>比特币系统在共识机制做出了两点创新。其一是引入了奖励机制，通过比特币奖励使得区块链上节点愿意打包交易，主动维护账本，加快了一致性的达成。其二是引入了随机性的概念，尽管比特币系统不是完全可靠的，但是一般来说经过6个区块后，出问题的概率会呈指数级下降。</p>
<p>实际上，共识机制的形成过程是一个投票过程，只不过比特币系统是通过算力进行投票。拥有较大算力的节点能够优先把自己认为合法的交易打包进区块中，即通过算力给这些交易投票。</p>
<h2 id="25-比特币系统的安全分析"><a class="markdownIt-Anchor" href="#25-比特币系统的安全分析"></a> 2.5 比特币系统的安全分析</h2>
<p>首先通过一个例子来简单的说一下比特币的转账过程。假设现在甲要向乙进行转账，那么甲会发起一个转账交易，并用自己的私钥进行签名，同时将收款人的姓名写为乙的地址，并发布出去。听到这个交易的节点，首先验证nbits域的设置是否符合难度要求；验证头的哈希是否小于等于目标阈值。然后验证body中的交易是否有甲的合法签名，这笔钱以前是否被花过。第三要验证这个区块是否是连在最长合法链上。假设这个区块已经被打包进了区块链中，那么沿着这个区块继续挖的区块也会来验证这笔交易。一般来说，经过6个区块后这笔交易就可以认为是这笔交易不可篡改。针对比特币的转账过程，我探究了以下几种安全问题。</p>
<h3 id="251-伪造转账交易"><a class="markdownIt-Anchor" href="#251-伪造转账交易"></a> 2.5.1 伪造转账交易</h3>
<p>首先，考虑攻击者能否转走别人账户上的比特币。这是不可能的。第一，因为比特币系统中合法交易需要交易发起方用自己的私钥进行签名，而私钥无法伪造，所以不能成功。第二，如果恶意节点强行将交易写入区块中，那么诚实的节点也不会认可这笔交易，同时攻击者也损失了一笔出块奖励，同样说明这种攻击难以实现。</p>
<p>一般情况下，发起交易的一方要广播自己公钥来让其他节点可以验证自己的签名合法性。假设现在有一个攻击者想要转走A账户上的比特币，那么他先伪造一笔A转出的转账交易，并用自己的私钥进行签名，同时广播自己的公钥说成是A的公钥。这样能否转走A账户上的比特币呢？也是不可能的，因为A账户上的比特币一定来自之前的某一笔交易，而之前交易的收款人地址正是A的公钥的哈希。由于攻击者的公钥哈希与这个收款地址哈希对不上，其他节点就不把他作为合法交易，也不会写进区块链中。</p>
<h3 id="252回滚交易数据"><a class="markdownIt-Anchor" href="#252回滚交易数据"></a> 2.5.2回滚交易数据</h3>
<p>假设现在A要向B转账5个比特币，A签名了这个交易并发布到网络上，表面看起来B已经得到这笔交易的输出。但是如果攻击者立即发布一笔交易将这5个比特币转给自己，由于两笔交易都有A的合法签名，所以两者都会被作为合法交易打包进区块链中。同时如果攻击者具有足够多的算力将回滚交易所在的链拓展成最长链，那么交易就会被回滚。这种通过向区块链中间插入某个区块来回滚某个已经发生的交易，又称为分叉攻击。防范这种攻击的简单方式是等待六个区块的确认，这样拓展回滚交易所在的链的难度就会大大增加。</p>
<p>分叉的原因有很多，实际上，即使完全正常运作的比特币系统中也会存在分叉。可能有两个节点几乎同时挖出了新的区块，并把它广播出去。由于网络延迟和节点间距离的差异最终导致不同的节点收到了不同的合法区块。按照比特币协议，一个节点只会接受第一个收到的合法区块，所以最终会导致区块链出现分叉。但这种分叉只是暂时的，随着时间的推移，两条分叉上的算力互相竞争，最终会以一方称为绝对的最长合法链而告终。</p>
<h3 id="253掌控最长合法链"><a class="markdownIt-Anchor" href="#253掌控最长合法链"></a> 2.5.3掌控最长合法链</h3>
<p>我们知道，新的区块的内容中包含前一区块的哈希值。也就是说，在正常情况下没有前一个区块就不能产生新的区块。并且比特币系统中，合法的区块应该是位于最长合法链上。现在如果有一个恶意节点想要掌握最长合法链，当他挖出一个区块后，先不广播，而是在这个区块的基础上接着挖下一个。直到自己手里这条链变成绝对的最长合法链再一起发布出去，从而使得其中的非法交易合法化。这种攻击很难奏效，因为比特币系统是基于算力进行投票的，所以攻击者想要将自己的链变成最长合法链有很大难度。</p>
<p>挖出区块而不广播的理由可能还包括盈利目的。假设某个节点挖出了第n+1个区块，但是不立即广播，然后接着这个区块继续挖第n+2块。当有其他节点挖出第n+1块时，他立即广播第n+1和n+2块。那么由他记账的区块链就变成了最长合法链，同时得到这两个区块的出块奖励，看起来就像是一步领先，步步领先。</p>
<p>但实际上，在比特币系统中，这种行为很难成功。这样做的成功前提是在别的节点挖出一个区块的时间里，他能保证挖出两个以上区块。这样做存在很大风险，有可能一个出块奖励也得不到。</p>
<h3 id="254比特币的匿名性"><a class="markdownIt-Anchor" href="#254比特币的匿名性"></a> 2.5.4比特币的匿名性</h3>
<p>比特币系统的匿名性是很难以维护的，因为区块链是公开的，并且区块链具有不可修改性。一旦有一次交易暴露了身份，那么这个影响将是永久性的。并且比特币作为一种虚拟货币，最终会和法币相关联，一旦与实体世界发生关系，那么就可能在用比特币支付和进行资金转入转出时发生隐私的泄漏。如果先不考虑与实体世界的联系，我们可以每次转账交易都生成一个新的地址，采用多路径转发的方式，使得从交易推理出身份的难度增大，从而加强匿名性。此外，市面上还出现了牺牲性能而增强匿名性的货币，如零币零钞等基于零知识证明的加密货币。但是由于普通用户对匿名性的要求并不高，所以并未被广泛使用。</p>
<h2 id="26-总结"><a class="markdownIt-Anchor" href="#26-总结"></a> 2.6 总结</h2>
<p>以上就是我对一些感兴趣的攻击比特币系统的手段分析。上述分析基础是比特币网络中大部分节点都是诚实的，恶意节点只是少数，不会占据51%以上的算力。然而近些年出现的矿场使得算力更加聚集，历史上就曾经出现过大型矿场占据51%以上的算力的情况(他们为了防止引起恐慌，自行分解了算力)。这说明比特币系统的安全性是相对的，想要持久的维护比特币系统的安全性就要维持比特币社区的活跃度，使得诚实的节点永远占据大多数。</p>
<h1 id="第3章-以太坊"><a class="markdownIt-Anchor" href="#第3章-以太坊"></a> 第3章 以太坊</h1>
<p>维塔利克在分析了比特币系统的缺陷的基础上提出了以太坊。目标是提供一个区块链，内置有成熟的图灵完备的编程语言，用这种语言可以创建合约来编码，实现任意状态转换功能。通过这种语言，按照ERC标准，我们可以编写出自己的智能合约，进行区块链上的状态转换，进行链上数字资产的转移。其开创性的智能合约使得区块链技术从数字现金向数字资产转移，为日后的应用奠定了基础。接下来的一部分主要描述一些关于以太坊的数据结构。</p>
<h2 id="31以太坊的数据结构"><a class="markdownIt-Anchor" href="#31以太坊的数据结构"></a> 3.1以太坊的数据结构</h2>
<p>首先，以太坊区别于比特币系统，设置了账户系统。在比特币系统中，每次交易都会把余额转到另一个零钱地址中。而以太坊中为了支持智能合约，就需要参与方有相对稳定的身份，所以改用账户系统，每次交易直接增删余额。以太坊被看作是由交易驱动的状态机，所以在以太坊中要保存状态和交易。因此，以太坊设置了三种树，分别是状态树，交易树，和收据树。</p>
<h3 id="331状态树-交易树-收据树"><a class="markdownIt-Anchor" href="#331状态树-交易树-收据树"></a> 3.3.1状态树、交易树、收据树</h3>
<p>建立状态树的目的是要建立一个从账户到状态的映射。其中以太坊账户为40位十六进制数，状态中包括余额，交易次数，如果是合约账户还包括代码和存储的变量。同时，要求这颗树上的数据不可篡改，便于查找，增加，删除，同时节省存储空间。此外，应该令轻节点易于验证某个键值对是否存在。于是以太坊在传统的Trie树的基础上，压缩路径，增加哈希指针得到了Modified Merkle Partricia Tree。</p>
<p>首先说Trie树，它常被用来存储单词，进行多模式串的模式匹配。在以太坊中，由于账户是由40位十六进制数构成，所以每个节点的分支最多有17种可能（加一个结束标志）。Trie树的优点是无需排序，即使插入顺序不一样，得到的结构也是一样的；同时它还具有很好的更新局部性，由于每个区块中涉及发生的交易是少数的，采用这种结构不需要去管其他的分支，增强了修改的性能。</p>
<p>Trie树的缺点也很明显，它有很大的存储浪费，并且实际的查找效率与树的深度有关。于是进一步的考虑Partricia tree，一种路径压缩的trie树。对于基数树的每个节点，如果该节点是唯一的儿子的话，就和父节点合并。当键值分布较为稀疏的时候，更新时需要打开压缩部分的概率就比较低，性能也就更好。而以太坊的地址就恰好是这种结构。</p>
<p>借鉴比特币系统的思想，将树中指针全部换成哈希指针得到了Merkle Partricia Tree(MPT)树。而以太坊系统中使用的是略作修改的MPT树，本质上没有改变。</p>
<p>以太坊的结构是一颗大的MPT树中包含很多小的MPT树，每个小的MPT就是一个合约账户。对于全节点来说，他维护的也不是一颗MPT，而是每产生一个新的区块就新建一颗MPT，这些树中大部分节点是共享的，只有少数更新的节点可能要新建分支。</p>
<p>我通过与比特币系统的对比，发现比特币系统中不需要保存历史状态，而是通过UTXO的输入输出计算得来。但是以太坊不同，由于账户的设计，智能合约的出现，每个交易被打包进区块链的时候，其账户余额也被改变。这样设计的优点是天然的防范了双花攻击。但是如果某个交易所在区块不在最长合法链上，为了保持账户余额和合法链上得到的交易的结果是一致的，就需要对分叉部分进行回滚。我认为这就是需要保存历史状态的原因。</p>
<p>至于交易树和收据树，他们本身也是一颗MPT树。每个交易执行完，会形成一颗收据树，记录这个交易的相关信息。交易树和收据树上的节点是一一对应的。但每个区块的交易树和收据树又是相互独立的。他们发布的交易本身也被认为是相互独立的。</p>
<h3 id="332bloom-filter"><a class="markdownIt-Anchor" href="#332bloom-filter"></a> 3.3.2bloom filter</h3>
<p>以太坊为了支持一些复杂的查询的查询操作，比如查询近十天里和某个智能合约相关的交易而设计了这个数据结构。对于这个问题，可能最开始的想法就是遍历这个链将符合规则的区块挑出来，但是对于轻节点来说，他不能保存所有区块的信息，同时也存在查找效率低下的问题。</p>
<p>而bloom filter结构可以理解为一个大的向量，称为摘要。是将每个元素取一个哈希，形成的一个向量，其中某位为1代表对应该哈希值的元素存在。假如现在要查找过去十天发生的和某个智能合约相关的交易。首先，查找区块块头的bloom filter，看看哪个块头的bloom fikter里有我要的交易类型。如果某个块头里有，再去相应的收据树的bloom filter中查找。每一步轻节点都可以向全节点请求少量的信息就可以查询下去，很好的解决了问题。即使考虑哈希碰撞，那么也只会出现误报，而不会出现漏报。而误报情况可以在逐渐细化的查询中被发现。</p>
<h3 id="333cache与dag"><a class="markdownIt-Anchor" href="#333cache与dag"></a> 3.3.3cache与DAG</h3>
<p>比特币的挖矿设备从最初的CPU，转向GPU，再到现在的ASIC芯片挖矿，设备趋向于专业化，挖矿门槛越来越高。这样不利于比特币系统的安全稳定，只有当算力足够分散的时候，发动51%以上算力的攻击才很困难。为了做到杜绝ASIC芯片，以太坊在莱特币的基础上改进了挖矿算法，使得求解从纯粹的算力竞争上转向内存竞争。</p>
<p>莱特币曾经是市值仅次于比特币的一种加密货币。他首先将内存引入了挖矿算法。他基于Scrypt加密算法，需要用大的内存来保存这个数组，否则每次都要重新计算。简单来说，Scrypt算法是先通过一个种子取哈希得到数组中的第一个元素，之后再将这个元素取哈希得到第二个，反复迭代得到后面的元素。但是对于轻节点来说，他只是想验证某个区块的合法性，却需要和矿工等量的计算。这与区块链的基本理念:难于计算，易于验证相悖。考虑到这个原因，莱特币只将这个数组设置为128K，这显然太小了，对于矿机来说，完全可以通过计算来弥补内存的薄弱。</p>
<p>以太坊在莱特币的基础上进行了改进。他规定了两个数据集，16M的cache和1G的DAG，其中DAG是通过cache计算得来。轻节点只需要保存cache即可验证区块，矿工通过DAG来计算随机数使最后的哈希值低于目标阈值。</p>
<p>Cache的形成与莱特币类似，也是从一个种子节点开始依次取哈希来填充数组。对于DAG，他首先从cache里随机读一个数，然后进行哈希计算，得到下一个要读取的数的位置。然后用cache中这个位置的数和当前的哈希值再计算出一个哈希。反复迭代256次，将最终得到的数填充到DAG的第一个位置。</p>
<p>对于矿工来说，在挖矿的时候，先根据块头和nonce值计算一个哈希，这个哈希映射到数组中的某一个位置。通过这个位置和其相邻位置的元素进行运算得到下一个要计算哈希的位置。反复迭代64次，最后得到的哈希值与目标阈值比较，看一下是否满足要求，不成功则换下一个nonce尝试。</p>
<p>对于轻节点，想要验证一个区块是否符合要求，他需要这个区块的nonce以及cache数组。验证的过程与挖矿类似，只是轻节点没有保存DAG中的元素，所以用到的部分需要从cache中重新计算生成。</p>
<h2 id="32智能合约"><a class="markdownIt-Anchor" href="#32智能合约"></a> 3.2智能合约</h2>
<p>关于智能合约，其智能可以理解为是一段自动执行的代码，无需外界干预，自动自治进行，运行在以太坊虚拟机中；合约可以看作一个管家，一个&quot;自治代理&quot;，它拥有自己的账户，交易发生时自动执行一段代码。借用V神的话就是&quot;他们收到交易信息后就相当于被捅了一下，然后自动执行一段代码&quot;。</p>
<p>如果说区块链存储的是状态，那么智能合约就是用于状态转换的方式。它像是一个特别的时钟，把世界从同步转向异步。</p>
<p>智能合约的出现使得创建通证变得简单。Komhar公司曾给出过ERC20通证发行过程，大体可以表述为：一个项目通过智能合约创建通证，这个通证是实体资产或线上资产的价值表示物。投资者（用户）发起交易，向智能合约转入以太币（ETH），智能合约自动运转，在满足一定规则后，它向投资者账户转入相应数量的通证。这里的通证大多对应以太坊区块链之外的资产。因此，以太坊的出现对区块链技术转向数字资产做出了巨大贡献。</p>
<h2 id="33以太坊共识机制与ghost协议"><a class="markdownIt-Anchor" href="#33以太坊共识机制与ghost协议"></a> 3.3以太坊共识机制与GHOST协议</h2>
<p>在比特币系统中，只有在最长合法链上挖出来的区块才有出块奖励。这使得挖出分叉的节点不甘心放弃自己链，对于大的矿池来说，他很有可能不顾一切的去挖自己的链使他成为最长链。这样做的优点是便于确认区块的合法性，也在一定程度上避免了双花。但是对于以太坊来说，这样做并不合适。以太坊设有账户系统，可以杜绝双花，而且以太坊的平均出块时间设定为15秒，分叉也会成为常态。因此，以太坊引入了GHOST协议，目的是在出现分叉后及时合并。</p>
<p>GHOST协议的核心思想是对没有竞争成为最长合法链的区块也发放一定的出块奖励。同时下一&quot;代&quot;区块要包含所有的叔父区块，并得到1/32个出块奖励的额外报酬。为了防止在挖矿难度较低的时候产生叔父而不当获利，以太坊规定叔父必须是7代以内。并且叔父区块中的交易不执行，因此也不检查交易合法性，只检查这个区块是否符合挖矿难度。</p>
<p>GHOST协议一方面保证了分叉及时被合并，另一方面也减少了ASIC矿机挖矿的必要性，有利于维持分布式账本和区中心化的稳定。在回避ASIC的问题的问题上，以太坊另一个做法是每年都宣称自己即将从工作量证明转为权益证明，从而有效的将以太坊挖矿限制在GPU挖矿的级别。</p>
<h1 id="第四章-区块链的应用与steemit博客"><a class="markdownIt-Anchor" href="#第四章-区块链的应用与steemit博客"></a> 第四章 区块链的应用与Steemit博客</h1>
<h2 id="41-区块链的性质"><a class="markdownIt-Anchor" href="#41-区块链的性质"></a> 4.1 区块链的性质</h2>
<p>想要将区块链投入应用，首先要明确区块链有什么用。有人总结区块链的性质总结为以下四条。</p>
<ol>
<li>
<p>第一，是不可篡改性。要修改一个区块中的数据，那么就要修改后面所有的所有区块。而共识机制的存在使得修改大量区块的成本极高，因此篡改几乎不可能实现。2018 年3 月，在网络零售集团京东发布的《区块链技术实践白皮书》中，京东认为，&quot;区块链技术（分布式账本）的三种应用场景是：跨主体协作，需要低成本信任，存在长周期交易链条。这三个应用场景所利用的都是区块链的不可篡改特性。多主体在一个不可篡改的账本上协作，降低了信任成本。区块链账本中存储的是状态，未被涉及的数据的状态不会发生变化，且越早前的数据越难被篡改，这使得它适用于长周期交易。&quot;</p>
</li>
<li>
<p>第二，是表示价值所需要的唯一性。比特币的出现使得数字世界中出现了一种不可复制的&quot;文件&quot;。腾讯CEO马化腾说&quot;区块链确实是一项具有创新性的技术，用数字化表达唯一性，区块链可以模拟现实中的实物唯一性。&quot;百度CEO 李彦宏说：&quot;区块链到来之后，可以真正使虚拟物品变得唯一，这样的互联网跟以前的互联网会是非常不一样的。&quot;</p>
</li>
<li>
<p>第三，是智能合约。智能合约的出现使区块链上可以进行更加复杂的交易，并且交易本身也不可篡改。在以太坊白皮书中，维塔利克写道：&quot;（合约）应被看成存在于以太坊执行环境中的&quot;自治代理&quot;，它拥有自己的以太坊账户，收到交易信息，它们就相当于被捅了一下，然后它就自动执行一段代码。&quot;</p>
</li>
<li>
<p>第四，是去中心自组织。在《去中心化应用》一书中，作者西拉杰·拉瓦尔（Siraj Raval）从两个维度看现有的互联网技术产品：一个维度是，在组织上是中心化的，还是去中心化的；另一个维度是，在逻辑上是中心化的，还是去中心化的。在他看来比特币在组织上是去中心化的，在逻辑上是集中的。</p>
</li>
</ol>
<p>根据这些性质，有人总结了五条区块链通向应用平台的可能路径。分别是通用类基础公链，功能类基础公链，行业类基础公链，联盟类基础公链，基础服务。在我看来，开发专用于某个功能的基础公链更可行，接下来通过Steemit来谈一谈区块链的应用。</p>
<h2 id="42-steemit"><a class="markdownIt-Anchor" href="#42-steemit"></a> 4.2 Steemit</h2>
<p>Steemit是基于steem公链平台的社交软件，类似于博客。可以通过发文章，写评论来赚钱，但没人直接付钱。这个平台促进内容生产者发布更加优质的内容，同时屏蔽掉劣质内容。</p>
<p>Steem链中有三种代币，分别是steem，steem power,steem dollar。其中，Steem币是Steem链的基础代币。Steem Power 相当于股权，只能持有不能买卖。Steem Dollar是公链中稳定代币，无论何时，SBD只能兑换成价值一美元的Steem币，维持内部代币价格稳定。</p>
<p>当作者发布一篇文章时，并不马上得到收益。其收益真正来源于持有SP用户的点赞，这点类似于EOS的权益证明。拥有SP越多的用户点赞带来的收益也越多，同时点赞用户也会得到一部分收益，类似于矿工打包交易时的得到的手续费。此外，SP用户还可点踩，当点踩的人足够多时，Steemit会隐藏这些内容。</p>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>总的来说，区块链很有可能成为互联网上的新层次，专门用于进行价值表示和价值转移。 在其上可以建立区块链应用，以利用区块链的价值表示和价值转移特性，在链上进行数字资产的转移。同时这些数字资产被映射成链上原生资产，线上资产或线下资产，从而改变目前人类的生成生活方式，影响金融、军事、教育乃至生活的方方面面。</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>古代象形符号</title>
    <url>/2020/03/30/%E5%8F%A4%E4%BB%A3%E8%B1%A1%E5%BD%A2%E7%AC%A6%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="uva-1103-古代象形符号"><a class="markdownIt-Anchor" href="#uva-1103-古代象形符号"></a> uva 1103 古代象形符号</h1>
<p>描述： 为了理解早期文明，考古学家经常研究用古代语言编写的文本。在3000多年前的埃及使用的一种语言是基于称为象形文字的字符。如图显示了六个象形文字及其名称，在这个题目中，您需要编写一个程序来识别这六个字。 图c1<br />
输入描述： 输入由几个测试用例组成，每个测试用例描述一个包含一个或多个的图像 象形文字选自图C.1所示的那些。图像以一系列水平扫描线的形式给出，这些水平扫描线由黑色像素（由1表示）和白色像素（由0表示）组成。在输入数据中，每个扫描线以十六进制表示法编码。 例如，序列将表示八个像素10011100（一个黑色像素，后面是两个白色像素，依此类推） 十六进制表示法为9c。 在十六进制中仅使用数字和小写字母a到f 编码。每个测试用例的第一行包含两个整数，H和W.H（0 &lt;H≤200）是 图像中的扫描行数。 W（0 &lt;W≤50）是每个中十六进制字符的数量 线。 接下来的H行包含图像的十六进制字符，从上到下工作。 输入图像符合以下规则： •图像仅包含图C.1中所示的象形文字。 •每个图像至少包含一个有效的象形文字。 •图像中的每个黑色像素都是有效象形文字的一部分。 •每个象形文字由一组连接的黑色像素组成，每个黑色像素至少有一个顶部，底部，左侧或右侧的其他黑色像素。 •象形文字没有触及，另一个象形文字中没有象形文字。 •对角线接触的两个黑色像素将始终具有共同的触摸黑色像素。 •象形文字可能会扭曲，但每个都有一个在拓扑上等同于其中一个的形状 图C.1中的符号。 （如果每个都可以转换，两个数字在拓扑上是等价的 通过伸展而不撕裂进入另一个。） 最后一个测试用例后跟一行包含两个零的行。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<p>本题中的符号可以随意压缩拉伸，所以试图去直接描述其形状是不可取的。<br />
观察到每个符号的空白圈数不同，可以以此特征分辨</p>
<ol>
<li>注意：要先给这个图加上一圈白边，使得所有背景的白色部分可以连接起来。此处可以使用</li>
<li>所以总体来说要进行两次遍历</li>
<li>第一次将背景中的空白遍历</li>
<li>第二次去遍历黑圈，沿途遍历黑色周围未遍历的白色部分，对于每个黑色的连通分量，统计其周围遍历到的白色连通分量数，即白洞数。每次统计完的接完插入到一个向量中。</li>
<li>对向量排序，输出</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<pre><code>#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;string&gt;
#include&lt;algorithm&gt;
#include&lt;string.h&gt;
# pragma warning(disable:4996)
# define LOCAL
# ifdef LOCAL
FILE *fin = freopen(&quot;古代象形符号in.txt&quot;, &quot;r&quot;, stdin);
FILE *fout = freopen(&quot;古代象形符号out.txt&quot;, &quot;w&quot;, stdout);
# endif 
using namespace std;
vector&lt;string&gt; g;
int vis[205][205];
string b[] = { &quot;0000&quot;,&quot;0001&quot;,&quot;0010&quot;,&quot;0011&quot;,&quot;0100&quot;,&quot;0101&quot;,&quot;0110&quot;,&quot;0111&quot;,&quot;1000&quot;,&quot;1001&quot;,&quot;1010&quot;,&quot;1011&quot; ,&quot;1100&quot;,&quot;1101&quot;,&quot;1110&quot;,&quot;1111&quot; };
char c[] = { 'W','A','K','J','S','D' };
int dx[] = { -1,0,1,0 };
int dy[] = { 0,-1,0,1 };
struct Node {
	int x, y;
	Node(int x, int y) :x(x), y(y) {}
};
int H, W, cnt, num;
bool notOk(int a, int b) {
	return vis[a][b] || a &lt; 0 || a &gt;= g.size() || b &lt; 0 || b &gt;= g[a].size();
}
void dfs(Node u, char c) {
	vis[u.x][u.y] = 1;
	for (int i = 0; i &lt; 4; i++) {
		int a = u.x + dx[i];
		int b = u.y + dy[i];
		if (notOk(a, b)) continue;
		if (c == '1'&amp;&amp; g[a][b] == '0') {

			cnt++;
			dfs(Node(a, b), '0');
		}
		if (g[a][b] == c) dfs(Node(a, b), c);
	}
}

int main() {
	int kase = 0;
	while (cin &gt;&gt; H &gt;&gt; W &amp;&amp; H) {

		getchar();
		memset(vis, 0, sizeof(vis));
		g.clear();
		g.resize(H + 2);
		g.front() = string(W * 4 + 2, '0');//加一层白边
		for (int i = 1; i &lt;= H; ++i) {//读取输入
			g[i] = &quot;0&quot;;//加一层白边
			string s;
			getline(cin, s);
			for (char c : s)
			{
				if (isdigit(c)) g[i] += b[c - '0'];
				else g[i] += b[c - 'a' + 10];
			}
			g[i] += &quot;0&quot;;//加一层白边
		}
		g.back() = string(W * 4 + 2, '0');//加一层白边


		dfs(Node(0, 0), '0');

		string ans;
		for (int i = 1; i &lt; g.size(); i++) {
			for (int j = 1; j &lt; g[i].size(); j++) {
				if (!vis[i][j] &amp;&amp; g[i][j] == '1') {
					cnt = 0;
					dfs(Node(i, j), '1');
					ans += c[cnt];

				}


			}
		}

		cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++kase &lt;&lt; &quot;: &quot;;

		sort(ans.begin(), ans.end());

		cout &lt;&lt; ans &lt;&lt; endl;

	}

}
</code></pre>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<ol>
<li>注意DRY问题，本题中的dfs的写法非常值得学习</li>
<li>利用向量的直接赋值来添加百变，减少了时间复杂度</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链</title>
    <url>/2020/03/30/%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    <content><![CDATA[<h1 id="比特币的诞生"><a class="markdownIt-Anchor" href="#比特币的诞生"></a> 比特币的诞生</h1>
<ol>
<li>
<p>比特币目的是在数字世界，创造一个具有现金特性的事物</p>
</li>
<li>
<p>比特币组成成分</p>
<p>1）加密数字货币</p>
<p>2）分布式账本</p>
<ol start="3">
<li>去中心网络</li>
</ol>
</li>
<li>
<p>目前的电子现金系统：依靠中心化数据库和可信的第三方中介来避免双花问题</p>
</li>
<li>
<p>比特币同时做到了去中介化和去中心化</p>
<p>1） 个人与个人之间的电子现金无需可信第三方中介的介入，这是去中介化</p>
<p>2）这个电子现金的货币发行也不需要一个中心化的机构，而是由代码与社区共识完成，这是去中心化</p>
</li>
<li>
<p>比特币系统三层结构</p>
<p>1）最上一层是比特币这种电子现金。是整个系统的应用层</p>
<p>2）中间一层的功能是发行比特币与处理用户见的比特币转移。这一层也叫比特币协议，是整个系统的应用协议层。（相当于中央银行（发行货币）与银行（处理转账）等金融机构间的关系）</p>
<p>3）最底层是比特币的分布式账本和去中心化网络。这一层也被称为比特币区块链，是整个系统的通用协议层。</p>
</li>
</ol>
<h1 id="区块链"><a class="markdownIt-Anchor" href="#区块链"></a> 区块链</h1>
<ol>
<li>定义：区块链是数字世界中进行价值表示和价值转移的技术。区块链硬币一面是表示价值的加密数字货币或通证，另一面是进行价值转移的分布式账本与去中心网络。</li>
<li>通证：基于区块链的价值表示无都称为通证。</li>
</ol>
<h1 id="加密数字货币前传"><a class="markdownIt-Anchor" href="#加密数字货币前传"></a> 加密数字货币前传</h1>
<ol>
<li>大卫·乔姆：
<ol>
<li>盲签：在一张纸条上， 你选择一个只有你知道的序列号，然后我在上面签名。由于我不知道这个序列号，所以我没法再复制一份这张纸条给另一个人。</li>
<li>这个方案的缺点是：必须有一个所有参与者都薪人的中心化服务器来进行这些“数字纸条”的验证。</li>
</ol>
</li>
<li>尼克·萨博
<ol>
<li>提出智能合约。智能合约是区块链处理交易的核心方式，区块链应用的实质可被看成是一个个智能合约的组合。</li>
</ol>
</li>
<li>哈尔·芬妮
<ol>
<li>著名的PGP加密中的&quot;G&quot;</li>
</ol>
</li>
<li>中本聪
<ol>
<li>首次建立了一个去中心化，非基于信任的系统。</li>
<li>它通过已有的公钥加密方式来管理所有权，并用一个名为工作量证明的共识算法来记录谁拥有货币。</li>
</ol>
</li>
</ol>
<h1 id="中心化"><a class="markdownIt-Anchor" href="#中心化"></a> 中心化</h1>
<h2 id="数字世界中的货币有三种形式"><a class="markdownIt-Anchor" href="#数字世界中的货币有三种形式"></a> 数字世界中的货币有三种形式</h2>
<ol>
<li>中心化的在线支付：
<ol>
<li>在这些支付系统中流转的是映射到数字世界的各国法定货币（也乘法币）</li>
<li>法定货币的价值来自拥有者相信货币将来能维持其购买力，本身并无内在价值。</li>
</ol>
</li>
<li>中心化的计算机点数或互联网积分
<ol>
<li>不与物理世界的法币对应，而是由商业公司中心化发行，仅可以在一家公司的体系中使用，称为虚拟货币。如Q币</li>
</ol>
</li>
<li>去中心化的电子现金：比特币</li>
</ol>
<h2 id="比特币实现了极致的去中心化"><a class="markdownIt-Anchor" href="#比特币实现了极致的去中心化"></a> 比特币实现了极致的去中心化</h2>
<ol>
<li>威廉·穆贾雅在《商业区块链》一书中对比特币白皮书摘要进行了分析，他总结了四个要点：
<ol>
<li>点对点电子交易；</li>
<li>不需要金融机构；</li>
<li>加密证据而不是中心化的信用；</li>
<li>信用存在于网络，而不是某个中心机构。</li>
</ol>
</li>
<li>在《去中心化应用》一书中，开发者西拉杰·拉瓦尔对去中心化应用的去中心化程度进行了一番讨论。他认为，区块链可能在四个过去集中化的方面完成去中心化： 数据；财富；身份；计算。</li>
</ol>
<h2 id="比特币系统设计的五个要点"><a class="markdownIt-Anchor" href="#比特币系统设计的五个要点"></a> 比特币系统设计的五个要点：</h2>
<p>比特币的区块链系统是由分布式账本（即狭义的区块链）和去中心网络（点对点网络）组成的，形成链条的方式是工作量证明共识机制。最长链是由网络中的算力共同决定的，因而它是可信的，节点离开和加入依据的是最长链是可信的这一原则。这些组合起来形成了比特币系统。</p>
<ol>
<li>
<p>去中心化的点对点电子现金</p>
</li>
<li>
<p>分布式账本</p>
<p>比特币的区块链是基于工作量证明形成的带时间戳、存储数据的数据块和由哈希指针连接成的链条。</p>
<p>这个链条或者说账本以分布式的方式存储在比特币网络的各个节点上，因而也被称为分布式账本。</p>
</li>
<li>
<p>工作量证明</p>
</li>
<li>
<p>最长链原则</p>
</li>
<li>
<p>去中心网络</p>
</li>
</ol>
<h1 id="比特币是如何转账的"><a class="markdownIt-Anchor" href="#比特币是如何转账的"></a> 比特币是如何转账的</h1>
<h2 id="分布式账本和去中心网络"><a class="markdownIt-Anchor" href="#分布式账本和去中心网络"></a> 分布式账本和去中心网络</h2>
<ol>
<li>比特币网络由众多轻节点和全结点组成，这些结点形成一个去中心网络，其中：
<ol>
<li>全节点包含所有比特币区块链的区块数据</li>
<li>轻节点仅包含自己相关的数据。</li>
<li>比特币网络是开放的，任何服务器都可以加入成为全结点</li>
</ol>
</li>
<li>分布式账本：所有用户持有的比特币信息都存在一个分布式账本中；比特币账本可被认为同时存储在所有全结点中。</li>
<li>中心化在线支付系统的交易流程：交易双方通过中心化的交易平台中开设的账户完成交易。中心化在线支付系统维护一个中心化的账本，用户在账本上开设账户，通过密码(私钥)来与之交互。</li>
<li>比特币系统的交易过程：
<ol>
<li>
<p>每个人在比特币区块链上建立账户(地址)，获得一对公钥和私钥，地址是公钥的哈希值，我们通过私钥与地址进行交互。</p>
</li>
<li>
<p>每个人有一个钱包，钱包中装的是私钥，转账时，可以通过各自的钱包软件直接进行。</p>
</li>
<li>
<p>对比而言，对于中心化在线支付系统，它通常是由中心化的服务器来管理集中式账本。对于比特币系统，它背后的系统是一个去中心网络，网络节点共同维护一个分布式账本。</p>
<p> 比特币是记录在账本中的，看起来还是有一个“中心”？</p>
<p> 其实，这个账本是分布式地存储在去中心网络中的，因而从这个层面看，它可以看成是去中心化的。</p>
</li>
</ol>
</li>
</ol>
<h2 id="utxo未使用的交易输出"><a class="markdownIt-Anchor" href="#utxo未使用的交易输出"></a> UTXO:未使用的交易输出</h2>
<ol>
<li>比特币系统中的账户：没有账户，只有地址(是公钥的哈希值)。如果愿意可以开始无限多的钱包地址，但是系统不会汇总形成账户。</li>
<li>所以转账是从我的一个钱包地址转到你的一个钱包地址。</li>
<li>UTXO
<ol>
<li>通证经济专家孟岩曾撰写一篇文章，标题是“其实没有什么比特币，只有UTXO”，这个标题指出了，对于计算机来说比特币是什么——比特币是区块链账本上的交易输出。</li>
<li>例子：假
<ol>
<li>如我有8比特币，说明之前有一个交易把这些比特币转入我的地址，这个交易的输出未被使用，我拥有了8个比特币。</li>
<li>现在我发起一个转账交易，这个交易的输入是我拥有的这些比特币的上一个交易。我转账给你，假设对我拥有的这8毕业比的上一个交易进行签名，把这一新转账交易的输出地址设为你的钱包地址。</li>
<li>这样，这8比特币就属于你了，你拥有的是我这个交易的未使用的交易输出。等矿工把这一交易打包进新的区块，转账交易完成。</li>
<li>交易中涉及比特币的公钥和私钥的非对称加密机制。钱包地址理解为房间号和锁，私钥则相当于钥匙，钥匙可以打开对应的锁。</li>
<li>对于每一笔比特币的源头，都有一种特殊的交易–创币交易。对于矿工赢得25比特币的创币交易，它的输入是0，而输出是25个比特币进到矿工的钱包地址中。</li>
</ol>
</li>
<li>UTXO的优点（相比于账户）
<ol>
<li>
<p>UTXO设计易于确认比特币的所有权。</p>
<p>想要转账，只需要确认上一个交易时真实的，我就的确拥有这些比特币。而一个区块经过6次确认，其中的交易可被认为是真实无误的。</p>
</li>
<li>
<p>UTXO设计与区块链账本是完全融为一体的</p>
<p>区块链账本存储的是状态。区块链中的交易都是一种状态转换函数。每一个新区快和它之前的所有区块一起形成了一个新的状态。在确认之后，之前的状态就不可篡改。</p>
</li>
</ol>
</li>
<li>深入理解UXTO
<ol>
<li>比特币就是UTXO
<ol>
<li>当甲要把一笔比特币转给乙时，这个过程是把甲的钱包地址中之前的一个UTXO，用私钥进行签名，发送给乙的地址，这个过程就是一个新的交易，而乙得到的是一个新的UTXO。</li>
<li>世界上根本没有比特币，只有UTXO，你的地址中的比特币是指没花掉的交易输出。</li>
</ol>
</li>
<li>详细阐述从甲向乙的转账过程。
<ol>
<li>假设A之前通过币基交易挖矿获得了12.5个比特币，那么在它的钱包地址中，就有了相应的UTXO</li>
<li>Alice发起一个转账交易，输入是自己的上一个交易，输出是B的地址，数量是12.5比特币，A用自己的私钥进行签名。</li>
<li>当交易的区块链确认后，A的UTXO变成0.而B的地址中就多了一个UTXO，数量是12.5.</li>
<li>存在B的地址中的这些比特币只有用B的私钥进行签名才可以转账给其他人。</li>
<li>总的来说，比特币转账就是用这个地址对应的私钥打开，再加密发送到另一个地址的过程。这个私钥的打开和加密就是签名的过程。在这个过程中，接受比特币的一方不需要动用自己的私钥。</li>
</ol>
</li>
</ol>
</li>
<li>比特币存在哪儿
<ol>
<li>一方面，你的比特币是一个物理存在的一一对应的一个数据文件。比特币以一个交易的UTXO的形式存在着，每个交易都被看成是一个数据文件。</li>
<li>另一方面，比特币是区块链这个账本上的记录。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="比特币区块的数据结构"><a class="markdownIt-Anchor" href="#比特币区块的数据结构"></a> 比特币区块的数据结构</h2>
<ol>
<li>每个区块由两个部分组成–区块头部和区块数据。</li>
<li>区块头部
<ol>
<li>头部中有一个哈希指针指向上一个区块，这个哈希指针包含前一个数据块的哈希值。</li>
<li>如果前一个区块中的数据被篡改了，那么通过哈希指针就能够发现。所以，要修改一个区块中的数据，对其后的每个区块都必须相应的进行修改。</li>
</ol>
</li>
<li>区块数据：一个区块中的数据是被打包进这个区块的一系列交易。这些交易按规则打包最终形成梅克尔树。</li>
<li>区块链中的两种哈希指针：
<ol>
<li>一个是形成&quot;区块+链&quot;的链状数据结构。</li>
<li>另一个是数据块内部用来形成梅克尔树的哈希指针</li>
</ol>
</li>
</ol>
<h2 id="工作量证明共识机制"><a class="markdownIt-Anchor" href="#工作量证明共识机制"></a> 工作量证明共识机制</h2>
<ol>
<li>共识机制为什么存在：是因为这是一个非基于信任的网络，任何人无需许可都可以接入这个网络。并且，这些节点需要达成一致。共识机制即为这些节点达成一致的机制。</li>
<li>比特币的共识机制有两个与过去不同的特点
<ol>
<li>
<p>引入了奖励机制</p>
<ol>
<li>
<p>通过比特币奖励使网络中的节点愿意打包交易，维护账本。</p>
<p> 除了新区块相关奖励外，挖矿节点还可以的饿到区块中包含的所有交易付出的交易费。</p>
</li>
</ol>
</li>
<li>
<p>包含了随机性的概念</p>
<ol>
<li>
<p>比特币的共识系统并不是完全可靠的，但是经过约一小时(6个区块)后，出问题概率呈指数级下降，从实用角度来看，这个共识是可信的。</p>
 <img src="/Iptables_img/1.png" style="zoom:80%">
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="比特币的挖矿机制"><a class="markdownIt-Anchor" href="#比特币的挖矿机制"></a> 比特币的挖矿机制</h2>
<ol start="5">
<li>
<p>挖矿结点计算机的两个任务</p>
<ol>
<li>
<p>第一个任务是把比特币网络中未确认的交易按梅克尔树组装成候选区块，未被纳入的交易则往下顺延。</p>
<p>在创建候选区块时，除了普通的交易外，矿工在器中增加一个特殊的交易： 如果挖矿成功，则币基交易会凭空转出新区块的奖励比特币到矿工的钱包地址中，从而发行这些比特币出来。</p>
</li>
<li>
<p>第二个任务是进行加密哈希计算，解决一个计算难题，进行算力竞争。在众多争夺记账权的结点中，谁最先完成这个计算，它打包的区块就被加到了区块链的最后，称为最新的区块。刷先完成计算的矿工会赢得新区快对对挖矿奖励。</p>
</li>
</ol>
</li>
<li>
<p>比特币的工作量证明共识机制与它的挖矿机制</p>
<ol>
<li>向内看： 在候选区块的头部有一个32位的随机数区域，矿工需要反复调整随机数并计算，目标是让整个区块的哈希值小于一个目标值。如果尝试过所有的32位随机数可能性后，计算仍未成功，那么就要改变币基的一个随机数，接着反复计算。</li>
<li>向外看： 随着算力的增长，会调整目标值的难度使得挖出一个区块的时间始终是10分钟左右。</li>
<li>总之，比特币的经济系统是以竞争-记账-奖励循环为核心的。</li>
</ol>
</li>
</ol>
<h2 id="比特币转账过程"><a class="markdownIt-Anchor" href="#比特币转账过程"></a> 比特币转账过程</h2>
<img src="/Iptables_img/3.png" style="zoom:80%">
<h1 id="区块链的应用"><a class="markdownIt-Anchor" href="#区块链的应用"></a> 区块链的应用</h1>
<ol>
<li>总的来说，区块链让我们从信息互联网跨越到价值互联网。</li>
<li>信息传递到价值传递
<ol>
<li>
<p>区块链提供了数字世界中价值表示与价值转移</p>
 <img src="/Iptables_img/4.png" style = "zoom:80%">
</li>
<li>
<p>目前的互联网实现的是信息传递，其特征是进行信息的复制。这一特征使得在数字空间中进行价值转移时，必须依赖可信的第三方</p>
</li>
<li>
<p>未来，我们不再需要这些“信用中介”。基于区块链技术，我们可能建立一个通过网络本身进行价值表示、价值转移的全新交易基础设施。</p>
</li>
</ol>
</li>
<li>数字世界中的价值转移和价值表示
<ol>
<li>价值的转移依靠记录：比如进行房产交易，那么要做的是把记录中所有权人改为你。</li>
<li>数字世界中，可完美复制的数据文件和需要唯一性的价值表示形式形成冲突。为了防止双花问题，所以需要一个可信的第三方作为中介。所有与价值转移有关的事处于成本高，效率低的状态，互联网上的价值转移就局限在少数的价值类别上。</li>
</ol>
</li>
</ol>
<h2 id="价值表示"><a class="markdownIt-Anchor" href="#价值表示"></a> 价值表示</h2>
<ol>
<li>价值的表示是在交易中体现出来的，因此可以从价值转移来讨论价值表示。</li>
<li>传统的体系中：价值的表示需要一个中介来参与。中介维护一个集中的账本用以记录，协助完成价值转移。</li>
<li>比特币系统中，区块链的账本以分布式的方式存在于互联网上，由去中心网络的节点共同维护。只要掌握自己的私钥即可。即所有人共享一个云端账本。</li>
</ol>
<h2 id="价值转移"><a class="markdownIt-Anchor" href="#价值转移"></a> 价值转移</h2>
<ol>
<li>在基础层次上，区块链担任信用中介，协助进行价值表示和价值转移。</li>
<li>互联网的层次：
<ol>
<li>最上层，是普通用户看到的网站与App等应用。</li>
<li>中间层，是协议层，这一层过去主要是信息传递的WWW等协议。</li>
<li>最底层，是网络传输硬件和网络传输协议如TCP/IP等。</li>
</ol>
</li>
<li>区块链给互联网带来了进行价值表示和价值转移的新协议。区块链信用层协议由一组协议组成，在现有硬件网络之上，形成了一个协助我们进行价值表示和价值转移的新层次。这组协议目前仍未定性，也尚未被广泛认可，在持续发展中。</li>
</ol>
<h2 id="价值表示物数字世界中表示价值的通证"><a class="markdownIt-Anchor" href="#价值表示物数字世界中表示价值的通证"></a> 价值表示物：数字世界中表示价值的通证</h2>
<ol>
<li>以太坊创始人维塔利克写道，常被提及的应用包括：
<ol>
<li>使用链上数字资产来代表定制货币和金融工具。</li>
<li>某种基础物理设备的所有权。</li>
<li>如域名一样的不可互换的资产</li>
<li>以及复杂的应用来直接控制转移数字资产（<strong>智能合约</strong>）</li>
<li>甚至基于区块链的分布式自治组织。</li>
</ol>
</li>
<li><a href="http://c.biancheng.net/view/1908.html" target="_blank" rel="noopener">应用及以太坊简史</a></li>
<li>把数字世界中，基于区块链的各种价值表示物都称为通证。</li>
<li>总的来说，现在在数字世界中，类似于 HTML 的代表价值的语言（通证）已经准备好了。“怎么用通证，通证有什么用”等问题等待着创造性的回答。</li>
</ol>
<h2 id="区块链的第三第四定义"><a class="markdownIt-Anchor" href="#区块链的第三第四定义"></a> 区块链的第三第四定义</h2>
<img src="/Iptables_img/5.png" style = "zoom:80%">
<img src="/Iptables_img/6.png" style = "zoom:80%">
<img src="/Iptables_img/7.png" style = "zoom:80%">
<h1 id="区块链将成为互联网基础协议"><a class="markdownIt-Anchor" href="#区块链将成为互联网基础协议"></a> 区块链将成为互联网基础协议</h1>
<ol>
<li>
<p>目前互联网通信用的协议是TCP/IP协议族。通常认为包括四层：</p>
<ol>
<li>链路层：将一些数据放在电线上。</li>
<li>网络层：对数据进行路由</li>
<li>传输层：将数据持久化</li>
<li>应用层：以应用的形式提供数据的抽象。</li>
</ol>
</li>
<li>
<p>万维网协议包括三部分：</p>
<ol>
<li>文本标记语言HTML</li>
<li>文档传输协议HTTP</li>
<li>指定文档网络地址的统一资源定位符URL</li>
</ol>
</li>
<li>
<p>区块链技术作用于硬件网络之上、WWW协议旁边</p>
 <img src="/Iptables_img/9.png" style = "zoom:80%">
</li>
</ol>
<h1 id="以太坊"><a class="markdownIt-Anchor" href="#以太坊"></a> 以太坊</h1>
<ol>
<li>
<p>在软件层面加入智能合约，但在实际应用中，它真正带来巨变的是通证。</p>
<blockquote>
<p>当下，对于区块链的发展阶段划分，一个被普遍接受的分类来自区块链研究者梅兰妮·斯万，在《区块链：新经济蓝图》一书中，她将区块链分为：区块链1.0，货币；区块链2.0，合约；区块链3.0，应用。从货币到合约、再到应用是一种阶段分类，以太坊白皮书的题目即宣称，它试图成为智能合约和去中心化应用的平台。</p>
</blockquote>
</li>
<li>
<p>以太坊是区块链2.0，实现了从数字现金到数字资产的转换。</p>
</li>
</ol>
<h2 id="智能合约与去中心化的平台"><a class="markdownIt-Anchor" href="#智能合约与去中心化的平台"></a> 智能合约与去中心化的平台</h2>
<ol>
<li>
<p>维塔利克分析在比特币系统的基础上开发高级应用的三种可行路径：</p>
<ol>
<li>建立一个新的区块链</li>
<li>在比特币区块链上使用脚本。</li>
<li>在比特币区块链上建立元协议。</li>
</ol>
</li>
<li>
<p>维塔利克认为，比特币系统的主要设计UTXO和其对应的脚本语言有缺陷。他总结了四点不足：</p>
<ol>
<li>缺少图灵完备性。尽管比特币的脚本语言可以支持多种计算，但并非所有。</li>
<li>价值盲：UTXO脚本不能为账户的取款额度提供精细的控制。</li>
<li>缺少状态：UTXO只能是已花费或者未花费状态，这意味着UTXO只能用于建立简单的、一次性的合约。</li>
<li>区块链盲：UTXO看不到区块链的数据，比如区块头部的随机数、时间戳和上一个区块数据的哈希值。</li>
</ol>
 <img src="/Iptables_img/10.png" style = "zoom:80%">
</li>
<li>
<p>以太坊的目标：提供一个区块链，内置有成熟的图灵完备的编程语言，用这种语言可以创建合约来编码，实现任意<strong>状态转换</strong>功能。（他认为比特币是一个状态转换系统）。</p>
<ol>
<li>
<p>要创建一个新的区块链。</p>
</li>
<li>
<p>这个区块链的特色是，有一个实现所有计算，即所谓的图灵完备的脚本编程语言。</p>
</li>
<li>
<p>这个脚本语言可以用来创建复杂的智能合约，用以控制区块链的状态转换，也即进行链上数字资产的转移。</p>
<blockquote>
<p>关于智能合约，在以太坊白皮书中，维塔利克用的词汇是“实现预先设定规则的一段代码”（implementing arbitrary rules）。在区块链上，这些代码的用途是控制链上的数字资产的转移。关于智能合约的更多介绍见相关冷知识专栏讨论</p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>维塔利克认为在以太坊上可以开发的三大类应用</p>
<ol>
<li>金融应用：用他们的钱去管理和参与合约。这些应用包括子货币、金融衍生品、对冲合约、储蓄钱包、遗嘱，甚至雇用合约。</li>
<li>半金融应用：这里有钱的存在，但非金钱的方面所占的比例也很重。一个好例子是为了解决计算问题而设的自动执行的悬赏。</li>
<li>非金融应用：如在线投票和去中心化治理等。</li>
</ol>
</li>
</ol>
<h2 id="用智能合约管理数字资产与erc20通证标准"><a class="markdownIt-Anchor" href="#用智能合约管理数字资产与erc20通证标准"></a> 用智能合约管理数字资产与ERC20通证标准</h2>
<p>目前以太坊最常用的功能是通过编写智能合约来管理用通证表示的数字资产。</p>
<ol>
<li>比特币出现以后，出现了很多通过简单修改比特币开源代码的参数得到替代币。而以太坊的智能合约将创建通证的门槛降到了很低。</li>
</ol>
<img src="/Iptables_img/11.png" style = "zoom:80%">
<img src="/Iptables_img/10.png" style = "zoom:80%">
2. ERC721（不可互换通证标准）：比如我的一本专门题名给我的签名书和你的同一本书是不同的，二者不可互换。
3. ERC20（可互换通证）：指的是每一个通证都是一模一样的，比如任何两张100元的价值是完全相同的。符合ERC20的通证的重要用途是被用于首次代币发行的筹资。人们可以用以太币按照项目方案设定的兑换率来换取这些通证，而项目方获得以太币形式的资金。
<p><a href="http://c.biancheng.net/view/1915.html" target="_blank" rel="noopener">“V神简介”</a></p>
<h1 id="智能合约"><a class="markdownIt-Anchor" href="#智能合约"></a> 智能合约</h1>
<ol>
<li>其中智能可以理解为，按条件自动执行，无须人的干预，是自动的或者自治的。</li>
<li>其中合约应该看成是存在于以太坊执行环境中的&quot;自治代理&quot;，它拥有自己的以太坊账户，他们收到交易信息后就相当于被捅了一下，然后自动执行一段代码-----V神如是说。（类比有限状态机，自动售货机）</li>
<li>可以认为区块链存储的是状态，智能合约是它用于状态转换的方式。智能合约像是一个特别的时钟，把世界从同步转向异步。</li>
</ol>
<h2 id="智能资产用智能合约来控制实体资产"><a class="markdownIt-Anchor" href="#智能资产用智能合约来控制实体资产"></a> 智能资产：用智能合约来控制实体资产</h2>
<ol>
<li>
<p>所谓智能财产，是智能合约程序按照设定的规则控制的财产。萨博举例说明如下：</p>
<p>例如，为了防止一部车被偷窃，除非确定拥有者完成正确的“挑战响应协议”，否则车是不会启动激活的。<br />
例如，如果车是贷款买的，当拥有者无法偿还贷款时，智能合约将会自动启动扣押令，并将车钥匙的控制权交给银行。一旦拥有者还清贷款，智能合约就移除扣押令。</p>
</li>
</ol>
<p>目前来说：由比特币区块链上的智能合约控制的资产，不管是实体的还是数字的，都叫智能资产。</p>
<h2 id="以太坊的智能合约"><a class="markdownIt-Anchor" href="#以太坊的智能合约"></a> 以太坊的智能合约</h2>
<ol>
<li>以太坊的智能合约是存在于区块链上，可以被触发执行的一段程序代码，这些代码实现了某种预定的规则，是存在于以太坊执行环境中的“自治代理”。</li>
</ol>
<img src="/Iptables_img/15.png" style = "zoom:80%">
<p>注：合约账户不能自己启动运行自己的智能合约。要运行一个智能合约，需要由外部账户对合约账户发起交易，从而启动其中的代码的执行。</p>
<h2 id="以太坊的智能合约有什么用"><a class="markdownIt-Anchor" href="#以太坊的智能合约有什么用"></a> 以太坊的智能合约有什么用</h2>
<ol>
<li>创建通证，通证对应的多是以太坊区块链之外的资产。</li>
<li>图 2 是一个简明的图示，这是从 Komhar 咨询公司的一个图示重绘而来的。图示是一个典型的 ERC20 通证发行过程：一个项目通过智能合约创建通证，这个通证是实体资产或线上资产的价值表示物。投资者（用户）发起交易，向智能合约转入以太币（ETH），智能合约自动运转，在满足一定规则后，它向投资者账户转入相应数量的通证。</li>
</ol>
<img src="/Iptables_img/16.png" style = "zoom:80%">
<h1 id="令牌系统-token-systems"><a class="markdownIt-Anchor" href="#令牌系统-token-systems"></a> 令牌系统 token systems</h1>
<p>令牌：用以表示资产的通证。</p>
<ol>
<li>
<p>所有的货币或者令牌系统从根本上来说都是带有如下操作的数据库：从A中减去X单位并把X单位加到B上。前提条件是</p>
<ol>
<li>A在交易之前至少有X单位</li>
<li>交易被A批准</li>
</ol>
<p>实施令牌系统，即是把这样一个逻辑实例实施到一个合约之中。</p>
</li>
<li>
<p>区块链能方便的承载Token系统，是因为它存储的是状态。</p>
</li>
<li>
<blockquote>
<p>在《商业区块链》一书中，区块链专家威廉·穆贾雅提出了一个可以用Token系统表示的事物的分类。他把区块链中可存储的事物的首字母组成了一个单词“ATOMIC”：</p>
</blockquote>
<p>可编程的资产（assets）。</p>
<p>可编程的信任（trust）。</p>
<p>可编程的所有权（ownership）。</p>
<p>可编程的货币（money）。</p>
<p>可编程的身份（identity）。</p>
<p>可编程的合同（contracts）。</p>
</li>
</ol>
<h1 id="通证有什么用机器比人更需要通证"><a class="markdownIt-Anchor" href="#通证有什么用机器比人更需要通证"></a> 通证有什么用：机器比人更需要通证</h1>
<img src="/Iptables_img/17.png" style = "zoom:80%">
<ol>
<li>要<strong>把其他象限的价值映射到链上</strong>，用通证来表示，主要有两个途径：
<ol>
<li>路径之一是，把原本在互联网上通过中心化机构的数据库表示的价值和价值转移，切换到去中心化的区块链上来。比如常见的有网络零售的支付、社交网络的积分、游戏里的道具等，反映在图中就是从象限 ② 到象限 ③。</li>
<li>路径之二是，把实体中的资产映射到链上，通过区块链进行流通。比如常见的有：把线下的民宿、供应链金融、资产证券化（ABS）中的资产用通证进行表示，反映在图中就是从象限 ③ 到象限 ①。</li>
</ol>
</li>
</ol>
<p>但实际上，以上的路通过传统的方法已经做的够好了（我们总在考虑我们手中的加密货币能兑换多少法币，这恰恰说明了法币在价值表示上已经做的很好了）</p>
<h2 id="在机器视角看通证"><a class="markdownIt-Anchor" href="#在机器视角看通证"></a> 在机器视角看通证</h2>
<ol>
<li>
<p>令牌：初始用于通信网络，只有拥有两派的节点才能参与通信，令牌代表了权力。</p>
<blockquote>
<p>一个关于令牌的例子：假设，为了防止网络中的机器发出垃圾邮件，我们设定如下规则：个人电脑或手机在发出邮件时，需要消耗一个 token；发件邮件服务器也要消耗一个 token。如果这个邮件不被垃圾邮件规则拦截，或不被个人举报为垃圾邮件，那么在一定时间内，所消耗的 token 又会回到我们手中。</p>
</blockquote>
<p>在这里实际发生了令牌抵押，以确保我们在实施正当行为。</p>
</li>
<li>
<p>随着物联网技术的发展，越来越多的机器需要通证，我们的做法也不应该是给每一个传感器开设一个和法币对应的账户。这时，我们应该设计机器专用的钱包和通证。</p>
</li>
</ol>
<h1 id="erc20通证标准"><a class="markdownIt-Anchor" href="#erc20通证标准"></a> ERC20通证标准</h1>
<p>–是通过以太坊创建通证时得到一种规范。按照ERC20的规范可以编写一个智能合约。</p>
<p><a href="http://c.biancheng.net/view/1922.html" target="_blank" rel="noopener">详解ERC20W</a></p>
<h1 id="the-dao众筹事件与以太坊分叉"><a class="markdownIt-Anchor" href="#the-dao众筹事件与以太坊分叉"></a> The DAO众筹事件与以太坊分叉</h1>
<h2 id="分叉的存在比特币共识机制"><a class="markdownIt-Anchor" href="#分叉的存在比特币共识机制"></a> 分叉的存在：比特币共识机制</h2>
<ol>
<li>分叉方案：即从某个区块开始以太坊区块链不向前兼容，从而把 The DAO 众筹来的以太币夺回来，转移到一个恢复地址上，再还给参与众筹的人。<br />
比特币的共识机制本质上是通过算力进行的投票。在去中心化的网络中，一定程度上来说我们不存在真币和假币。你相信他是真的，愿意在包含这个交易的区块后面继续追加区块，维护这一区块链分支，那么他就是真的。日后，如果还要和其他人进行交易，并且他也认为你的比特币的起源是真实可靠的，那么你们就可以完成交易；反之，则会出现分歧，如果多数人都不站在你那边，那么你所拥有的比特币就来自非法交易。</li>
</ol>
<h1 id="设计通证用通证表示资产"><a class="markdownIt-Anchor" href="#设计通证用通证表示资产"></a> 设计通证：用通证表示资产</h1>
<p>有了智能合约和通证之后，以太坊就有了新的用途—进行数字资产的表示与交易。这使得数字资产也有了相对统一的价值表示形式，所以以太坊超越作为数字现金系统的比特币，开始解决如何表示资产等问题。</p>
<img src="/Iptables_img/18.png" style = "zoom:80%">
<h2 id="用通证将资产表示为链上的数字资产"><a class="markdownIt-Anchor" href="#用通证将资产表示为链上的数字资产"></a> 用通证将资产表示为链上的“数字资产”</h2>
<ol>
<li>
<p>通证是资产在区块链上的价值表示物，涉及的资产包括：</p>
<ol>
<li>比特币，以太币等链上的原生资产、映射到链上的线上资产、映射到链上的线下资产。</li>
</ol>
</li>
<li>
<p>我们通过以太坊区块链和他的智能合约来创建与发行代表价值的通证，然后用它去关联资产。</p>
</li>
<li>
<p>以太坊上的通证包括两种：可互换的ERC20和不可互换的ERC721。可互换的通证可类比现金，不可互换的通证类比房契。</p>
 <img src="/Iptables_img/19.png" style = "zoom:80%">
</li>
<li>
<p>链上和链下的交互包括两大部分：</p>
<ol>
<li>将链下资产与通证关联，进行通证的发行与分配。</li>
<li>在链上进行通证交易后，对链下资产进行相应的变动，并将变动在链上确认。</li>
</ol>
</li>
<li>
<p>将资产表示成通证的好处：</p>
<ol>
<li>帮助市场交易发现价格</li>
<li>在流动周转中增加资产价值。</li>
</ol>
<blockquote>
<p>其中，关于流动增加总体价值的例子，我们在现实生活中也可以体验到：二手物品的流动让买方和卖方都收益，车辆与房屋的共享提升了资源的利用效率。</p>
</blockquote>
</li>
</ol>
<h2 id="数字资产系统的去中心化交易场景"><a class="markdownIt-Anchor" href="#数字资产系统的去中心化交易场景"></a> 数字资产系统的去中心化交易场景</h2>
<p>-----以太坊的出现使得基于它的智能合约创建的各种通证都可以进行中心化或去中心化交易。</p>
<ol>
<li>
<p>通过智能合约进行链上数字资产交易：假设我们编写一个合约，售卖一种基于 ERC721 的不可互换通证，如性质类似于收藏卡的“加密猫”。每个加密猫通证各不相同，预先在智能合约中设定价格均为 10 个以太币，购买方式是先到先得。</p>
<p>这时，去中心化的数字资产交易过程如下：</p>
<ol>
<li>买方向智能合约地址转入 10 个以太币，即为发起购买邀约，智能合约担任第三方保管的角色。</li>
<li>卖方把该收藏卡（基于 ERC721 的通证）转入买方地址。</li>
<li>智能合约自动将以太币款项转入卖家账户。</li>
</ol>
<p>由于这里仅涉及以太坊区块链上的数字资产（加密猫通证和以太币）的转移，因此在链上可以完成全部过程。</p>
<p>对比 A、B 两种场景我们看到，原本中心化的中介（如淘宝与支付宝）被按预先设定规则自动执行的智能合约所取代。中心化中介被区块链（即分布式账本和去中心网络）所取代。</p>
</li>
<li>
<p>通过智能合约进行涉及线下资产的交易</p>
<ol>
<li>
<p>当交易的不是链上的数字资产时，智能合约和预言机是一对必备的组合。智能合约在链上，预言机在链下，它可以与链上的智能合约进行通信（见图4）。</p>
 <img src="/Iptables_img/20.png" style = "zoom:80%">
</li>
<li>
<p>比如，当卖家把数字文件传递给买家，买家确认之后，连接链上和链下的预言机就发出消息通知智能合约。接到消息后，智能合约执行后续的步骤，把以太币转入卖家账户。</p>
</li>
</ol>
</li>
<li>
<p>对比两个场景，我们知道</p>
<ol>
<li>有了智能合约，用通证表示的数字资产就是可编程的；</li>
<li>它是可以由计算机自动处理的；</li>
<li>如果数字资产交易各方形成一定的规则与逻辑，那么这些交易方之间可以进行完全自治的交易。</li>
</ol>
<p><strong>最终，可以大幅度降低资产流转交易的成本，提高效率，并实现智能化。</strong></p>
</li>
</ol>
<h2 id="通证的四个特征"><a class="markdownIt-Anchor" href="#通证的四个特征"></a> 通证的四个特征</h2>
<ol>
<li>中关村区块链产业联盟理事长元道指出的通证的三个要素：
<ol>
<li>第一是数字权益证明。通证必须代表一种权利，一种固有和内在的价值。</li>
<li>第二是加密。通证的真实性、防篡改性，保护隐私等特性由密码学给出。</li>
<li>第三是可流通。通证必须能够在一个网络中流通，从而随时随地都可以进行验证。</li>
</ol>
<blockquote>
<p>事实上，通证可以代表一切权益证明，从身份证到学历文凭，从货币到票据，从钥匙、门票到积分、卡券，从股票到债券，人类社会的全部权益证明都可以用通证来代表。</p>
</blockquote>
</li>
<li>第四个特点：通证是可编程的。</li>
</ol>
<p>在区块链上，可以通过智能合约自治或自动的处理通证。</p>
<img src="/Iptables_img/21.png" style = "zoom:80%">
<h2 id="通过经济系统设计和通证的发行与分配"><a class="markdownIt-Anchor" href="#通过经济系统设计和通证的发行与分配"></a> 通过经济系统设计和通证的发行与分配</h2>
<ol>
<li>回以太坊的建立过程，他起初进行了一轮众筹，严格来说，以太币的发行时中心化的，由以太币基金会发起的。但是过程时自动化的，由预先确定规则，编写后不能修改的智能合约自动执行的。
<ol>
<li>中心化的原因：用区块链上的通证来表示链上资产、线上资产、线下资产时，完全的去中心化，甚至完全无人介入的自动化通常是不可行的。资产的设计、发行的设计以及后续项目的运行，都需要有机构来发起。这个机构在一定程度上是区块链项目的中心。</li>
<li>然而中心化机构只需要在初期持续运行项目和社群，直到社区能够自行运转。随着项目的发展，社区的扩大，中心化开始弱化，甚至是最终达到去中心化的状态。</li>
</ol>
</li>
<li>通证经济体
<ol>
<li>
<p>通证经济体：是一个产业生态圈或社区，用通证来表示一个生态或社区的广义资产；借助通证来进行分配、交易。</p>
</li>
<li>
<p>核心事务：</p>
<ol>
<li>链：区块链技术的落实。</li>
<li>通证：通证的建立、分配与管理。</li>
<li>社群：用户社区与投资社区等以价值共识形成的社群。</li>
</ol>
 <img src="/Iptables_img/22.png" style = "zoom:80%">
</li>
</ol>
</li>
<li>通证经济系统的设计：一方面是和通证的价值相关的设计，另一方面是和通证的数量相关的设计。</li>
</ol>
<img src="/Iptables_img/23.png" style = "zoom:80%">
<img src="/Iptables_img/24.png" style = "zoom:80%">
4. **一个例子**：假设用通证经济系统来改造一个线下社区，那么可能的初始分配包括：投资方、团队和顾问、社区成员、留存。其中社区成员按一定规则得到的通证就是将线上资产映射到链上，用通证表示出来。之后，还需要设定规则定义生态成员如何获得通证，如何使用通证，此外还需要定义相关的经济逻辑。都确定之后，就可以通过编写智能合约来用代码实现它。
<img src="/Iptables_img/25.png" style = "zoom:80%">
<ol start="5">
<li><strong>通证，参考元道的说法是一种权利，不要局限于资产。他可以对应某种线上或线下的资产，也可能是代表某种功能的使用权</strong></li>
</ol>
<img src="/Iptables_img/26.png" style = "zoom:80%">
<h2 id="以太坊数字资产的基础设施"><a class="markdownIt-Anchor" href="#以太坊数字资产的基础设施"></a> 以太坊：数字资产的基础设施</h2>
<p>之前，在以太坊的 ERC20 标准被广泛接纳之前，要发行一个原生数字资产需要自行开发一条链，而现在我们可以基于以太坊这条公链来创建一个数字资产的价值表示物。<br />
#<a href="%22http://c.biancheng.net/view/1931.html%22">通证的分类</a></p>
<h1 id="以太坊只能合约的技术与组件"><a class="markdownIt-Anchor" href="#以太坊只能合约的技术与组件"></a> 以太坊只能合约的技术与组件</h1>
<img src="/Iptables_img/39.png" style = "zoom:80%">
<h1 id="erc721标准与加密猫"><a class="markdownIt-Anchor" href="#erc721标准与加密猫"></a> ERC721标准与加密猫</h1>
<p>加密猫—基于以太坊的ERC721标准发行的加密数字宠物，每一只猫咪<strong>各不相同</strong>。在此之前人们对以太坊的认识是，它的主要应用是用它的智能合约发行符合 ERC20 标准的可互换通证，同一种通证的一枚和另一枚是完全一样的。</p>
<h1 id="以太坊的账户"><a class="markdownIt-Anchor" href="#以太坊的账户"></a> 以太坊的账户</h1>
<p>以太币账户可以查看余额（包括以太币和其他基于ERC20标准的通证）。以太坊账户分为外部账户和合约账户。外部账户由密钥控制，合约账户由只能合约控制</p>
<img src="/Iptables_img/40.png" style = "zoom:80%">
<ol>
<li>以太坊的账户包括：一个随机数、账户余额、[合约代码]，存储</li>
</ol>
<h2 id="合约账户"><a class="markdownIt-Anchor" href="#合约账户"></a> 合约账户</h2>
<ol>
<li>只有合约账户才有代码，存储的是这个账户的以太坊虚拟机代码的哈希值。生成后不可修改，即智能合约代码不能修改。</li>
<li>合约账户可以设置多重签名</li>
</ol>
<h2 id="外部账户"><a class="markdownIt-Anchor" href="#外部账户"></a> 外部账户</h2>
<ol>
<li>外部账户可以触发交易，而合约账户不能主动发起交易，只能在被触发后执行代码。</li>
</ol>
<h2 id="以太坊的区块"><a class="markdownIt-Anchor" href="#以太坊的区块"></a> 以太坊的区块</h2>
<ol>
<li>区块中存交易，本质是状态转移函数。一个交易触发它的执行，它将相应的账户从一个状态转变成新状态，然后将新状态存储在区块链的数据区块中。</li>
<li>以梅克尔帕特丽夏树组织。</li>
</ol>
<h1 id="区块链的四大特征区块链有什么用"><a class="markdownIt-Anchor" href="#区块链的四大特征区块链有什么用"></a> 区块链的四大特征—区块链有什么用</h1>
<img src="/Iptables_img/41.png" style = "zoom:80%">
<h2 id="一-不可篡改"><a class="markdownIt-Anchor" href="#一-不可篡改"></a> 一 不可篡改</h2>
<ol>
<li>要修改一个区块中的数据，那么就要生成后面所有的区块。</li>
<li>共识机制的重要作用之一是使得修改大量区块的成本极高，从而几乎不可能。</li>
<li><strong>应用</strong>：农产品或商品溯源的应用：将它们的流通记录在区块链上，以确保数据记录不被篡改，从而提供追溯的证据。</li>
</ol>
<blockquote>
<p>2018 年 3 月，在网络零售集团京东发布的《区块链技术实践白皮书》中，京东认为，区块链技术（分布式账本）的三种应用场景是：跨主体协作，需要低成本信任，存在长周期交易链条。这三个应用场景所利用的都是区块链的不可篡改特性。多主体在一个不可篡改的账本上协作，降低了信任成本。区块链账本中存储的是状态，未被涉及的数据的状态不会发生变化，且越早前的数据越难被篡改，这使得它适用于长周期交易。</p>
</blockquote>
<h2 id="二-表示价值所需要的唯一性"><a class="markdownIt-Anchor" href="#二-表示价值所需要的唯一性"></a> 二 表示价值所需要的唯一性</h2>
<ol>
<li>中心化账本存在是因为在数字世界中，文件可以复制。</li>
</ol>
<blockquote>
<p>2018 年年初，中国的两位科技互联网企业领袖不约而同地强调了区块链带来的“唯一性”。腾讯主要创始人、CEO 马化腾说：“区块链确实是一项具有创新性的技术，用数字化表达唯一性，区块链可以模拟现实中的实物唯一性。”</p>
</blockquote>
<blockquote>
<p>百度创始人、CEO 李彦宏说：“区块链到来之后，可以真正使虚拟物品变得唯一，这样的互联网跟以前的互联网会是非常不一样的。”</p>
</blockquote>
<h2 id="三-智能合约"><a class="markdownIt-Anchor" href="#三-智能合约"></a> 三 智能合约</h2>
<ol>
<li>
<p>智能合约的出现使得基于区块链的两个人不只是可以进行简单的价值转移，而是可以设置复杂的规则，由智能合约来进行自治，自动的管理。</p>
</li>
<li>
<p>智能合约的性质：相当于一种特殊的服务端后台程序。</p>
<blockquote>
<p>在以太坊白皮书中，维塔利克写道：（合约）应被看成是存在于以太坊执行环境中的“自治代理”（autonomous agents），它拥有自己的以太坊账户，收到交易信息，它们就相当于被捅了一下，然后它就自动执行一段代码。</p>
</blockquote>
</li>
<li>
<p>编写智能合约</p>
 <img src="/Iptables_img/42.png" style = "zoom:80%">
</li>
<li>
<p><strong>区块链的新认识</strong></p>
<ol>
<li>区块链：是分布式账本技术。各方共同维护一个共享、互通、互联的账本，在此账本上就价值的确认、交易、分配达成共识。</li>
<li>区块链：是基于分布式账本技术的自治执行机制，即把区块链等同于智能合约。
<ol>
<li>在没有通证的情况下，通过智能合约的自动/自治执行，进行数字资产的交易。</li>
<li>在有通证的情况下，通过智能合约的自治执行，进行通证形式的数字资产的交易。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="四-去中心自组织"><a class="markdownIt-Anchor" href="#四-去中心自组织"></a> 四 去中心自组织</h2>
<p>----可能会失控，但失控也是一种自治。</p>
<ol>
<li>
<blockquote>
<p>在《去中心化应用》一书中，作者西拉杰·拉瓦尔（Siraj Raval）还从另一个角度进行了区分，他的这个区分有助于我们更好地理解未来的应用与组织。他从两个维度看现有的互联网技术产品：一个维度是，在组织上是中心化的，还是去中心化的；另一个维度是，在逻辑上是中心化的，还是去中心化的。</p>
</blockquote>
<p>他认为：“比特币在组织上去中心化，在逻辑上集中。”而电子邮件系统在组织上和逻辑上都是去中心化的</p>
 <img src="/Iptables_img/43.png" style = "zoom:80%">
</li>
<li>
<p><strong>区块链在技术之外的意义</strong> 可能作为基础设施支持人类的生产组织和协同的变革。这正是区块链与互联网是完全同构的又一例证，互联网也不仅仅是一项技术，它改变了人们的组织和协同。</p>
</li>
<li>
<p><strong>再看以太坊</strong> 以太坊将区块链技术带入了新的阶段，带来了智能合约和通证。作为价值表示物的通证，它的角色类似于 HTML。在有了 HTML 之后，建什么样的网站完全取决于我们的想象力。</p>
</li>
</ol>
<h1 id="区块链30"><a class="markdownIt-Anchor" href="#区块链30"></a> 区块链3.0</h1>
<h2 id="类比理解"><a class="markdownIt-Anchor" href="#类比理解"></a> 类比理解</h2>
<ol>
<li>
<p>类比操作系统的市场</p>
<blockquote>
<p>在 2016 年出版的《商业区块链》一书中，区块链专家威廉·穆贾雅以“数以百万计的区块链”（Getting to millions of blockchains）作为一个小节的标题。从整体上，他展望的未来图景是：“随着公有、私有、半私有、特殊目的以及其他类型的区块链的增长扩散，数以百万计的区块链世界将会实现。”这个说法可能展现了最可能的区块链未来图景。</p>
</blockquote>
<p>区块链的未来很可能不止是一条。</p>
</li>
<li>
<p>类比网站</p>
<blockquote>
<p>威廉·穆贾雅还做了一个虽然不甚准确但易懂的类比——“区块链将会成为新的网站”。在回顾了从 20 世纪 90 年代开始的网站发展史后，他类比指出：“每个公司一定会拥有或参与各种各样的区块链，无论它们是私有的、半私有的或公共的。”</p>
</blockquote>
</li>
<li>
<p>类比为云服务平台</p>
<ol>
<li>和现有的云不同，他们的核心功能是价值交易。</li>
</ol>
</li>
</ol>
<h2 id="作为云服务的区块链30"><a class="markdownIt-Anchor" href="#作为云服务的区块链30"></a> 作为云服务的区块链3.0</h2>
<ol>
<li>以太坊曾把自己定位为一台“全球分布式计算机”。在《区块链革命》中，商业思想家唐·塔普斯科特这样写道：“区块链上运行的所有计算资源可以在整体上视为一台计算机。”</li>
<li>区块链3.0从一个个的通证进化到一个个的应用，会使得它的基础模型可能与已知的以太坊模型有很大的不同。</li>
<li>目前，人们关注的焦点往往是性能问题，比如以太坊计划通过改用 POS 共识机制（casper）和分片技术（sharding）来提升性能，又比如人们关注 EOS 采用委托权益证明机制（DPOS）来提升性能。或许，架构也需要改变。</li>
<li>要看待这一个个应用（App），可以有两种方式：既可以把它们看成是区块链操作系统上的软件，它们用的是一条区块链的分布式账本和去中心网络；也可以把这些应用看成类似于一条条链，它们有着自己的分布式账本与去中心网络。
<ol>
<li>类比地看，在云服务出现之前，要开发一个网站或应用，我们要自己架设和运维服务器；而有了云服务之后，我们可以在云服务上开发自己的应用。在采用云服务时，一个个应用就有自己的一组专用服务器，像之前一样。类似地，如果采用类似的架构来开发区块链的应用，则可以认为，一个个应用也像有着自己的一条条独立的区块链。</li>
<li>现在的各个作为基础公链的区块链项目，做的正是云服务：以开源软件系统、分布式账本、去中心网络为基础，提供一系列和价值有关的云计算服务。</li>
<li>现在，对试图在各个领域或产业中实际应用区域链的人来说，要在区块链上开发应用，需要的正是一个类似的云服务架构：区块链的软件系统、分布式账本与去中心网络，从及一系列云计算软件服务。</li>
<li>当然，区块链云服务与现有的云服务也有很多不同：
<ol>
<li>它提供的云计算软件服务是基于分布式账本与去中心网络的。</li>
<li>软件系统通常不是由一家公司开发，而是由社区开发的，以开源方式发布。</li>
<li>去中心网络不是由一家公司运维，而是由不同主体出于经济激励而自主提供的。</li>
<li>一系列云计算软件服务也不是由一家公司提供，而是由社区提供的。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="走向应用的五条路径"><a class="markdownIt-Anchor" href="#走向应用的五条路径"></a> 走向应用的五条路径</h2>
<img src="/Iptables_img/44.png" style = "zoom:80%">
<ol>
<li>
<p>以超级账本为代表的联盟链软件：</p>
<ol>
<li>与比特币，以太坊等公有链不同，联盟链需要经过许可才能加入。联盟链有其特定的用途，较为适合大型公司在自己的内部部署使用，或部署后在自己的产业链生态中邀请合作伙伴接入，也可以由产业联盟共同部署。</li>
<li>从互联网的发展经验来看，区块链的未来只要还是开辟一套基础公链。目标是开发一条有通用功能或专一功能的公有链，并同时做三件事：开发软件，运行系统，运行社区。</li>
</ol>
</li>
<li>
<p>基础公链：通用类</p>
<p>开发一条通用类的基础公链。代表EOS（一个更快，更好，更适合应用开发的以太坊）</p>
</li>
<li>
<p>基础公链：功能类</p>
<p>开发专用于某类功能的区块链，代表IOTA（专用于物联网等），Steem和Steemit（专用于数字内容），再比如比原链（专用于数字资产交换，按白皮书披露的信息它要做到的是，连通比特世界与原子世界，实现“比特资产”（原生的数字货币、数字资产）和“原子资产”（有传统物理世界对应物）的交互与流转。 ）</p>
</li>
<li>
<p>基础公链：行业类</p>
<p>开发专用于某个行业的区块链，充分考虑该行业的特点提供相关的功能，比如保险、供应链金融、游戏、政务等。</p>
</li>
<li>
<p>基础设施 跨链的资产交易</p>
<p>可以预见的是区块链世界中必然有着很多链，甚至是非常多的链的共存。链与链之间的功能或资产的连接就变得非常重要。</p>
<blockquote>
<p>2018 年年初，新区块链项目区块基石（ArcBlock）自称是区块链 3.0，它的核心是提供跨链的协议，并以云服务的形式为开发者提供便利。另一个新项目梵塔网络（Penta）则定位在做“区块链世界的连接器”，要实现三大连接——链与链的连接、链与中心化系统的连接、链下与链上价值的连接，即为了推进区块链的应用，不只是连接不同的链，连接链上与链下，更要在需要时连接链与中心化系统。<br />
在鲸准研究院与节点资本研究中心的“侧链跨链研究报告”（2018年）中，它认为侧链与跨链在技术上大体相似，只有在谈到它们的服务对象时才需做细致的区分：一般来说，侧链服务于主链，而跨链试图改进的是链之间价值和功能的连通。其实，现在区块链领域的主要应用之一“币币交易所”实质上做的也是跨链资产的交易，只是目前采用的主要还是中心化的方式。目前，主要的交易所都推出了自己的通证（一般称平台币），并公布基础公链计划，也即准备用区块链技术来改进自身业务。</p>
</blockquote>
</li>
<li>
<p>基础设施 服务中心化应用</p>
<p>随着去中心化应用的出现，各种基础性技术服务成为刚需。如星际文件系统，分布式文件存储等。</p>
</li>
<li>
<p>区块链3.0 类比云服务</p>
 <img src="/Iptables_img/45.png" style = "zoom:80%">
</li>
</ol>
<h2 id="从多个网到多条链"><a class="markdownIt-Anchor" href="#从多个网到多条链"></a> 从多个网到多条链</h2>
<p>雷纳特·卡桑辛（Renat Khasanshyn）曾展示他基于联盟链理解的区块链应用未来。现在的各类系统，比如相互连接在一起的金融系统，是由多个中心化的数据库组成的。用区块链技术来改造这些系统，他的设想是，在合适的地方用相应的区块链来取代原来的数据库（见图 6）。从图 6 中可以看到，中心化的数据库被去中心化的区块链所取代。</p>
<h1 id="eos-比特币-以太坊"><a class="markdownIt-Anchor" href="#eos-比特币-以太坊"></a> EOS、比特币、以太坊</h1>
<ol>
<li>
<p>EOS 是一款企业操作系统（区块链软件系统）,其目的是将一切去中心化。</p>
<p>从 2017 年年中开始，经过一年的代币众筹后，它于 2018 年 6 月 15 通过由数十个区块生产者（block producer，BP，又称超级节点）组成的社区上线了主网，EOS 主网这条主要的区块链开始正式运转。</p>
</li>
<li>
<p>EOS包括三个部分：</p>
<ol>
<li>EOSIO软件，一共社区开发 的开源软件，任何人都可以参与开发、提交代码。</li>
<li>EOS币（EOS通证）</li>
<li>EOS主网：通过竞选，一批区块生产者被选出来，它们启动EOS主网。</li>
</ol>
</li>
<li>
<p>EOS账户：</p>
<ol>
<li>外部账户：由私钥控制</li>
<li>合约账户</li>
<li>与账户相关的概念：
<ol>
<li>钱包：保存密钥的客户端；</li>
<li>权限：包裹owner和active，用户可自定义各种权限。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>EOS的智能合约：<br />
其含义非常接近与linux的后台应用，节点在启动时包括缺省合约。</p>
<ol>
<li>调用方法：用户命令调用；EOSIO的send方法调用</li>
</ol>
</li>
</ol>
<h2 id="eos-vs-以太坊"><a class="markdownIt-Anchor" href="#eos-vs-以太坊"></a> EOS VS 以太坊</h2>
<img src="/Iptables_img/46.png" style="zoom:80%">
<ol>
<li>以太坊是比特币的改进，EOS是以太坊的改进（进化到应用）</li>
<li>以太坊的设计思路类似于高速公路。在这条收费高速公路上，车辆行驶需要付费。它早期募集资金，建设“高速公路”，早期投资者享有“高速公路”的主要权益。之后，一起建设与维护“高速公路”的挖矿节点也可以获得挖矿奖励与交易费收益。在以太坊网络中，由于各类项目已经基于它生成了大量的通证，以太坊网络的交易量相对较多，挖矿节点获得的交易费收益占比高于比特币。</li>
<li>EOS 的设计思路则类似于房地产开发。Block.one 公司在将土地售卖出去之后，逻辑上它用获得的资金进行基础的开发，此后每年再以类似填海造田的方式增加 5% 的土地出来。</li>
<li>EOS 网络要依靠超级节点（即区块生产者）来各自建设、共同运营，按现在的设计，这些节点共同获得每年 1% 新增发的 EOS 作为回报。其繁荣程度主要取决于超级节点能否建设号自己的地盘。</li>
<li>实际上，EOS的实际情况是：BlockOne公司募集资金开发一个名为EOSIO的开源软件。EOS社区通过这个软件运行EOS主网。EOS是对以太坊的改进，各中由EOSIO运行起来的区块链网络，也可以做以太坊能做的事。</li>
</ol>
<h2 id="eos的超级节点竞选"><a class="markdownIt-Anchor" href="#eos的超级节点竞选"></a> EOS的超级节点竞选</h2>
<ol>
<li>EOS采用的共识机制是DPOS（委托权益证明），即一些节点在获得足够多的投票后，成为见证人节点或EOS中所说的区块链生产者，<strong>负责区块的生成</strong>。</li>
<li>基于区块链的思路开发的软件系统的关键要求：
<ol>
<li>一是性能：它的去中心化网络的整体性能能否支撑大量应用。</li>
<li>二是网络：它的共识机制、经济激励和社区运营能否吸引足够多的节点加入，形成安全可靠的去中心网络。</li>
<li>三是功能：无论目标是通用类，功能类还是行业类，它是否提供了应用开发所需要的必备功能。</li>
</ol>
</li>
<li>超级节点竞选（DPOS）是一种激励。通过DPOS来刺激形成一个活跃的去中心网络，并且，超级节点竞选时与其共识机制DPOS高度匹配的。区块生产则时动态的，时刻根据投票动态调整。
<blockquote>
<p>EOS 的区块链生产者的收益分配机制是，区块生产者一共可获得每年新增出来的 1% 的 EOS 通证作为回报，其中 0.25% 按每个区块来进行奖励，0.75% 按所获投票来进行分配。可参见 2018 年 5 月 12 日项目发布的信息。</p>
</blockquote>
</li>
</ol>
<h2 id="eos-的共识机制"><a class="markdownIt-Anchor" href="#eos-的共识机制"></a> EOS 的共识机制</h2>
<p>所有的出块者都要对所有区块签名，以确保在同一时间戳或者同一区块高度上，没有区块生产者能够同时在两个区块上签名。一旦一个区块有了 15 个区块生产者的签名，该区块就被认为是不可逆的。任一区块生产者如果想在同一时间戳或者同一区块高度的两个区块上签名，就会留下密码学证据。在这一模式下，一秒之内就可以达成不可逆的共识。</p>
<ol>
<li>EOSIO 设定每0.5秒产生一个区块，每126个区块为一个周期（每个出块者6个区块，乘以21个出块者）。在每个出块周期开始时，软件会根据通证持有人投票选出21个区块生产者。每个生产的区块要获得15个以上的区块生产者的签名即变成不可逆的交易。</li>
<li>如果在计划的时间内没有成功出块，则跳过该块，产生0.5秒的空白。如果出块者错过了一个区块，并且在最近24小时内都没有产生任何区块，则这个出块者将被踢出考虑范围，直至他们通知区块链可以重新开始产生区块。这确保了网络的顺利运行。</li>
</ol>
<h1 id="区块链的不可能三角"><a class="markdownIt-Anchor" href="#区块链的不可能三角"></a> 区块链的不可能三角</h1>
<img src="/Iptables_img/47.png" style="zoom:80%">
<p>对比一下比特币和 EOS：比特币系统看重的是去中心化和安全，而牺牲了可扩展性；EOS 在一定程度上牺牲了去中心化，而去追求可扩展性与安全。</p>
<h1 id="去中心化的应用"><a class="markdownIt-Anchor" href="#去中心化的应用"></a> 去中心化的应用</h1>
<ol>
<li>
<p>EOS白皮书中给出了区块链应用的六个条件：</p>
<ol>
<li>支持百万级别的用户，需要能够处理数千万日活跃用户的区块链技术。</li>
<li>使用免费，应用开发人员需要具备灵活性，能够为用户提供免费服务；用户不必为了使用平台或从平台的服务中受益而付费。</li>
<li>轻松升级和故障修复，区块链平台必须对软件和智能合约的升级提供支持。</li>
<li>延迟低，及时地反馈是良好用户体验的基础。</li>
<li>串行性能，有些应用程序由于必须顺序执行命令，无法用并行算法进行实现。区块链需要提供强大的串行性能支持。</li>
<li>并行性能，大型应用程序需要在多个CPU和计算机之间分配工作负载。</li>
</ol>
</li>
<li>
<p>早期的应用:将会在区块链上出现原生的区块链应用或去中心化应用。</p>
</li>
<li>
<p>如果单独看一条区块链的应用，情形可能如图 2 所示。</p>
<ol>
<li>这条区块链是分布式账本与去中心网络，它提供着一系列与价值相关的数据和功能。</li>
<li>多个应用接入区块链网络。在这些应用中，有的可能是普通用户可以使用的，是网站/移动 App 与区块链应用的组合；有的可能是纯粹的区块链应用。<br />
<img src="/Iptables_img/48.png" style="zoom:80%"></li>
</ol>
</li>
<li>
<p>有的应用可能接入多个区块链，比如现在常见的应用交易所、钱包就接入多个区块链。</p>
</li>
<li>
<p>去中心化应用可以从去财富中心化和去计算中心化入手。</p>
</li>
<li>
<p>区块链3.0的先驱者EOS为应用而做的三件事：用户免费、账户与权限体系、存储系统。</p>
</li>
</ol>
<h2 id="区块链应用实例steemit博客"><a class="markdownIt-Anchor" href="#区块链应用实例steemit博客"></a> 区块链应用实例—Steemit博客</h2>
<ol>
<li>基于Steem区块链上存储价值，并按照内容贡献进行分配。</li>
<li>基于这条区块链建有多个应用：普通用户可用的 Steemit 博客平台、视频平台 DTube 等；常备的应用如区块链浏览器 <a href="http://steemd.com" target="_blank" rel="noopener">steemd.com</a> 网站。它的社区算是较为活跃的，还有其他的很多应用。</li>
</ol>
<h2 id="用户免费"><a class="markdownIt-Anchor" href="#用户免费"></a> 用户免费</h2>
<p>----用户不必为了使用平台或从平台的服务中收益而付费。</p>
<ol>
<li>
<p>使用一个区块链应用需要三种资源，均由维护这个去中心网络的计算机提供。分别是：</p>
<ol>
<li>带宽资源：带宽和日志存储。(磁盘)</li>
<li>计算资源：计算和计算积压。（CPU）</li>
<li>状态资源：状态存储。（RAM）</li>
</ol>
</li>
<li>
<p>关于状态：区块链账本中存储的是状态，比如交易账本、账户余额等，按其名字缩写为 RAM，它的性质大约相当于内存。EOS 还特别举例说明，什么应该存入状态，什么不应该存入状态。例如，一个区块链应用程序的逻辑不需要读取博客文章的内容和评论，因此它们不应该存储在区块链的状态中。但是，博客文章或评论是否存在、投票数以及其他属性，需要存在区块链的状态之中。</p>
<p><strong>简单的说，区块链是用于交易的，区块链的状态是交易账本，那么，与交易相关的信息应该存入交易账本，而与交易无关的信息不应存入交易账本。</strong></p>
</li>
<li>
<p>EOS中的三种资源的消耗机制：区块生产者（BP）公布可用的带宽（bandwidth）、计算（computation）和状态（state）的容量。EOSIO 系统允许每个账户消耗一定比例的可用资源，这个比例是根据账户将自己持有的通证存入“三天抵押合约”的数量决定的。</p>
</li>
<li>
<p>关于交易费：</p>
<ol>
<li>以太币和比特币中都需要交易的发起方设定一个交易费，付给区块链网络，从而使网络能够处理这一交易。</li>
<li>EOS的逻辑是去中心化应用程序不应该强迫它的用户为使用区块链而支付费用。具体实现是由应用自己决定采用什么方式，通常为了用户使用，应用会自行解决，从而使得用户看上去是免费的。</li>
</ol>
</li>
<li>
<p>交易成本与通证价值分开</p>
<ol>
<li>在以太坊的网络中，我们交易支付以太币，随着以太币价格的涨跌，交易成本也随之变化。</li>
<li>EOS的逻辑是使交易成本与通证价值无关。EOS的做法是，一个应用拥有的带宽、计算、状态等资源，是与其持有的通证数量有关的，但由于不需要消耗，因此一定程度上与通证价值无关。</li>
<li>如果应用开发者不持有足够多的通证，则EOS网络还有一种“将资源能力授权出去”的机制，通证持有人可以不立刻消耗可用带宽或全部资源，可以将未消耗的带宽委托或租赁给其他人。</li>
</ol>
<blockquote>
<p>根据 EOSIO 文档，这里的状态可认为指的是一个应用所占用的区块链网络的 RAM 存储空间。原文为：Storage of application state will require an application developer to hold tokens until that state is deleted.If state is never deleted,then the tokens are effectively removed from circulation.</p>
</blockquote>
<blockquote>
<p>对比以太坊和 EOS 我们可以看到，在以太坊中进行交易，个人用户需要支付交易费，而在 EOS 中进行交易，则是应用提供者需要承担成本，现在看来其中主要的成本是与 RAM 存储空间相关的。</p>
</blockquote>
</li>
</ol>
<h2 id="账户与权限体系"><a class="markdownIt-Anchor" href="#账户与权限体系"></a> 账户与权限体系</h2>
<ol>
<li>比特币：没有账户，所有比特币交易都是地址见的交换。</li>
<li>以太坊：引入了账户。每个账户包括四个信息：一个随机数、账户的余额、合约代码（如果有的话）、存储（通常为空）。分为外部账户和合约账户。这里的合约代码相当于以太坊中的自治代理。</li>
</ol>
<h3 id="eos账户"><a class="markdownIt-Anchor" href="#eos账户"></a> EOS账户</h3>
<ol>
<li>一个EOS账户可以发送动作给另一个账户，而每个账户都可以设定一个处理器来自动处理发给自己的动作。动作与处理器的结合就是智能合约。</li>
<li>EOS系统提供了一个标准的基于角色的权限系统。允许每个用户持有者定义自己的权限层次结构以及动作的分组。</li>
<li>其账户系统包含两个缺省的权限组：最高级别的缺省是owner，第二个缺省权限组是active，其他的权限组都可以由active派生出来</li>
</ol>
<h2 id="存储系统"><a class="markdownIt-Anchor" href="#存储系统"></a> 存储系统</h2>
<p>—与交易相关的数据被存储在区块链中，那么应用相关数据放在哪呢？</p>
<ol>
<li>目前EOS的想法是存储在基于IPFS的EOS存储中。</li>
</ol>
<h2 id="总结-区块链的定义七-八"><a class="markdownIt-Anchor" href="#总结-区块链的定义七-八"></a> 总结 区块链的定义七 八</h2>
<img src="/Iptables_img/49.png" style="zoom:80%">
<img src="/Iptables_img/50.png" style="zoom:80%">
<h1 id="eos账户的密钥被盗找回"><a class="markdownIt-Anchor" href="#eos账户的密钥被盗找回"></a> EOS账户的密钥被盗找回</h1>
<ol>
<li>基于它的用户权限机制</li>
<li>在这种情况下，你可以用过去 30 天中有效的 owner 权限对应的私钥，和你预先设定的账户恢复合作伙伴（account recovery partner）重置账户的私钥。这样你可能夺回了账户的所有权。</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>周期串</title>
    <url>/2020/03/30/%E5%91%A8%E6%9C%9F%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="uav-455-周期串"><a class="markdownIt-Anchor" href="#uav-455-周期串"></a> uav 455 周期串</h1>
<p>如果一个字符串可以由某个长度为kkk 的字符串重复多次得到，则称该串以kkk 为周期。例如，abcabcabcabcabcabcabcabcabcabcabcabc 以333 为周期（注意，它也以666 和121212 为周期）。</p>
<p>输入一个长度不超过808080 的字符串，输出其最小周期。</p>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<pre><code>#include&lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
# pragma warning(disable:4996)
# define LOCAL
# ifdef LOCAL
FILE *fin = freopen(&quot;习题3-8in.txt&quot;, &quot;r&quot;, stdin);
FILE *fout = freopen(&quot;习题3-8out.txt&quot;, &quot;w&quot;, stdout);
# endif 
using namespace std;
int main()
{
	int t; cin &gt;&gt; t;
	char s[85];
	while (t--)
	{
		memset(s, 0, sizeof(s));
		scanf(&quot;%s&quot;, s);
		int len = strlen(s);
		int j;
		for (int i = 1; i &lt;= len; ++i)
			if (len%i == 0)//说明长度i可以作为一个循环节
			{
				for (j = i; j &lt;= len; j++)
					if (s[j] != s[j%i])//之后都和0-i-1的字符串来比较
						break;
				if (j == len)
				{
					cout &lt;&lt; i &lt;&lt; endl;
					break;
				}
			}
		if (t)cout &lt;&lt; endl;
	}
}</code></pre>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>和为0的4个值</title>
    <url>/2020/03/30/%E5%92%8C%E4%B8%BA0%E7%9A%844%E4%B8%AA%E5%80%BC/</url>
    <content><![CDATA[<h1 id="uva-1152-和为0的4个值"><a class="markdownIt-Anchor" href="#uva-1152-和为0的4个值"></a> UVA 1152 和为0的4个值</h1>
<p>给出四个集合，从每个集合中任取一个数，问有多少种方案使得四个数和为0</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>最直观的四重循环复杂度O(n<sup>4</sup>)不可能</li>
<li>三重循环计算第四个数，之后查找这个数。如果查找使用二分查找，那么复杂度也在O(n<sup>3</sup>nlogn)</li>
<li><strong>解决</strong> 首先枚举a,b，把所有a+b记录下来放到一个有序数组中，之后枚举c,d，查一查-c-d有多少种方法写成a+b的形式。两个步骤都是n<sup>2</sup>logn，总的也是n<sup>2</sup>logn</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 4000 + 5;</span><br><span class="line">int A[maxn];</span><br><span class="line">int B[maxn];</span><br><span class="line">int C[maxn];</span><br><span class="line">int D[maxn];</span><br><span class="line">int sum[maxn*maxn];</span><br><span class="line">int upper_bound(int x, int y, int v) &#123;</span><br><span class="line">int m;</span><br><span class="line">while (x&lt;y)</span><br><span class="line">&#123;</span><br><span class="line">	m &#x3D; x + (y - x) &#x2F; 2;</span><br><span class="line">	if (sum[m] &lt;&#x3D; v) x &#x3D; m + 1;</span><br><span class="line">	else y &#x3D; m;</span><br><span class="line">&#125;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br><span class="line">int lower_bound(int x, int y, int v) &#123;</span><br><span class="line">int m;</span><br><span class="line">while (x&lt;y)</span><br><span class="line">&#123;</span><br><span class="line">	m &#x3D; x + (y - x) &#x2F; 2;</span><br><span class="line">	if (sum[m] &gt;&#x3D; v) y &#x3D; m;</span><br><span class="line">	else x &#x3D; m + 1;</span><br><span class="line">&#125;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int T;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">while (T--)</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">		scanf(&quot;%d %d %d %d&quot;, &amp;A[i], &amp;B[i], &amp;C[i], &amp;D[i]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	int index &#x3D; 0;</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++) </span><br><span class="line">			sum[index++] &#x3D; A[i] + B[j];</span><br><span class="line">	sort(sum, sum + index);</span><br><span class="line">	long long  cnt &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++) </span><br><span class="line">			cnt +&#x3D; upper_bound(0, index, -C[i] - D[j]) - lower_bound(0, index, -C[i] - D[j]);</span><br><span class="line">	printf(&quot;%lld\n&quot;, cnt);</span><br><span class="line">	if (T) printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>唯一的雪花</title>
    <url>/2020/03/30/%E5%94%AF%E4%B8%80%E7%9A%84%E9%9B%AA%E8%8A%B1/</url>
    <content><![CDATA[<h1 id="uva-11572-唯一的雪花"><a class="markdownIt-Anchor" href="#uva-11572-唯一的雪花"></a> UVA 11572 唯一的雪花</h1>
<p>求最长连续无重复子序列。输入：第一行给出样例数，对于每组数据，第一行给出序列长度n，之后n行给出每个元素的值。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>滑动窗口：优先向右扩展，如果A[R+1]已存在，那么增大L。这是因为L-R是解的情况下，增大L也必然是解，所以R不必动。</li>
<li>判断是否出现过，可以使用set(240ms),map(270ms),数组(1140ms)
<ol>
<li>set的查询，插入，删除的复杂度都是O(nlogn)</li>
<li>map[i]来记录元素i上次出现的下标，并更新到数组last。后面，如果上一次出现的下标不在目前的搜索范围内，那么可以扩展。</li>
<li>数组法可能是因为数组太大，所以速度太慢。</li>
</ol>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="set"><a class="markdownIt-Anchor" href="#set"></a> set</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000000 + 5;</span><br><span class="line">int A[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int T, n;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">  while(T--) &#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;A[i]);</span><br><span class="line"></span><br><span class="line">    set&lt;int&gt; s;</span><br><span class="line">    int L &#x3D; 0, R &#x3D; 0, ans &#x3D; 0;</span><br><span class="line">    while(R &lt; n) &#123;</span><br><span class="line">      while(R &lt; n &amp;&amp; !s.count(A[R])) s.insert(A[R++]);</span><br><span class="line">      ans &#x3D; max(ans, R - L);</span><br><span class="line">      s.erase(A[L++]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="map"><a class="markdownIt-Anchor" href="#map"></a> map</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000000 + 5;</span><br><span class="line">int A[maxn], last[maxn];</span><br><span class="line">map&lt;int, int&gt; cur;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int T, n;</span><br><span class="line">  scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">  while(T--) &#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    cur.clear();</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">      scanf(&quot;%d&quot;, &amp;A[i]);</span><br><span class="line">      if(!cur.count(A[i])) last[i] &#x3D; -1;</span><br><span class="line">      else last[i] &#x3D; cur[A[i]];</span><br><span class="line">      cur[A[i]] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int L &#x3D; 0, R &#x3D; 0, ans &#x3D; 0;</span><br><span class="line">    while(R &lt; n) &#123;</span><br><span class="line">      while(R &lt; n &amp;&amp; last[R] &lt; L) R++;</span><br><span class="line">      ans &#x3D; max(ans, R - L);</span><br><span class="line">      L++;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1e9 + 5;</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int in[1000005];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		int n;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;in[i]);</span><br><span class="line">		int L &#x3D; 0, R &#x3D; 0, ans &#x3D; 0;</span><br><span class="line">		while (L &lt;&#x3D; R &amp;&amp; R &lt; n)</span><br><span class="line">		&#123;</span><br><span class="line">			if (!vis[in[R]]) &#123; vis[in[R]] &#x3D; 1; R++; &#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				ans &#x3D; max(ans, R - L);</span><br><span class="line">				vis[in[L]] &#x3D; 0; L++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, max(ans, R - L));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>困难的串</title>
    <url>/2020/03/30/%E5%9B%B0%E9%9A%BE%E7%9A%84%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="uva-129-困难的串"><a class="markdownIt-Anchor" href="#uva-129-困难的串"></a> UVA 129 困难的串</h1>
<p>将一个包含两个相邻的重复子串的子串，称为“容易的串”，其他为“困难的串”。 输入正整数n和l,输出由前l个字符组成的，字典序第k小的困难的串。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>输出完整的串，即这条路要走到头，想到用dfs。枚举每个位置处的字符，并判断当前局面的合法性。</li>
<li>合法性：如果扩展到当前处没有导致重复子串的出现即为合法。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> dfs</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	int dfs(int cur) &#123;</span><br><span class="line">	if (cnt++ &#x3D;&#x3D; n) &#123;</span><br><span class="line">		int len &#x3D; 1;</span><br><span class="line">		cout &lt;&lt; char(&#39;A&#39; + S[0]);</span><br><span class="line">		for (int i &#x3D; 1; i &lt; cur; i++) &#123;</span><br><span class="line">			if (i&amp;&amp;i % 4 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				cout &lt;&lt; &quot; &quot;;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; char(&#39;A&#39; + S[i]);</span><br><span class="line">			if (i + 1 &lt; cur) &#123;</span><br><span class="line">				if ((i + 1) % 64 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">					cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">					cout &lt;&lt; char(&#39;A&#39; + S[++i]);</span><br><span class="line">					len++;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			len++;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; l; i++) &#123;</span><br><span class="line">		S[cur] &#x3D; i;</span><br><span class="line">		int ok &#x3D; 1;</span><br><span class="line">		for (int j &#x3D; 1; j * 2 &lt;&#x3D; cur + 1; j++) &#123;</span><br><span class="line">	&gt; 相当于在枚举循环节,关注循环条件</span><br><span class="line">			int equal &#x3D; 1;</span><br><span class="line">			for (int k &#x3D; 0; k &lt; j; k++)</span><br><span class="line">				if (S[cur - k] !&#x3D; S[cur - k - j]) &#123;</span><br><span class="line">					equal &#x3D; 0;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			if (equal) &#123;</span><br><span class="line">	&gt; 如果后一半等于前一半，则不合法</span><br><span class="line">				ok &#x3D; 0;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (ok) if (!dfs(cur + 1)) return 0;</span><br><span class="line">	&gt; 递归的搜索剩余位置</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 80;</span><br><span class="line">int cnt, n, l;</span><br><span class="line">int S[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">while (cin &gt;&gt; n &gt;&gt; l &amp;&amp; n&amp;&amp;l) &#123;</span><br><span class="line">	cnt &#x3D; 0;</span><br><span class="line">	memset(S, 0,sizeof(S));</span><br><span class="line">	dfs(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>团体队列</title>
    <url>/2020/03/30/%E5%9B%A2%E4%BD%93%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="uva540-团体队列"><a class="markdownIt-Anchor" href="#uva540-团体队列"></a> UVA540 团体队列</h1>
<p>有t个团队的人正在排一个长队。每次新来一个人时，如果他有队友在排队，那么这个新人会插队到最后一个队友的身后。如果没有任何一个队友排队，则他会排到长队的队尾。输入每个团队中所有队员的编号，要求支持如下3种指令（前两种指令可以穿插进行）。</p>
<p>ENQUEUEx：编号为x的人进入长队。</p>
<p>DEQUEUE：长队的队首出队。</p>
<p>STOP：停止模拟。</p>
<p>对于每个DEQUEUE指令，输出出队的人的编号。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>本题中涉及两种队列，一个是每个团队的队列，一个是整体的长队。所以用两个整型队列来存储。</li>
<li>由于一个团队的人一定站在一起，所以在整体的长队里，我们不关心每个人的具体位置。所以用给每个团队映射为一个编号，长队中是元素是队伍的编号</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<pre><code>/*
p117 例5-6 UVA540
*/
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
int main() {
int kase = 0;
for (;;) {
	map&lt;int, int&gt; belong;
	queue&lt;int&gt; total,team[1100];
	int n;
	cin &gt;&gt; n;
	if (!n) return 0;
	cout &lt;&lt; &quot;Scenario # &quot; &lt;&lt; ++kase &lt;&lt; endl;
	for(int i=0;i&lt;n;i++) {
		int m;
		cin &gt;&gt; m;
		while(m--) {
			int x;
			cin &gt;&gt; x;
			belong[x] = i;
		}
	}
</code></pre>
<p><strong>完成输入，并给每个队伍的成员都映射一个编号</strong></p>
<pre><code>	for (;;) {
		string cmd;
		cin &gt;&gt; cmd;
		if (cmd[0] == 'S') break;
		else {
			if (cmd[0] == 'D') {
				int t = total.front();
				cout &lt;&lt; team[t].front() &lt;&lt; endl;
				team[t].pop();
				if (team[t].empty()) total.pop();

			}
			if (cmd[0] == 'E') {
				int num;
				cin &gt;&gt; num;
				int t = belong[num];
				if (team[t].empty()) total.push(t);
				team[t].push(num);
			}
		}
	}
	cout &lt;&lt; endl;
}
}
</code></pre>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<ol>
<li>因为队伍数量不定，所以一开始想用vector，但是会出现越界，所以使用vector时，最好用push_back，不要随机访问。</li>
<li>两个指令，一个有操作数，一个没有，注意分情况输入！！</li>
<li>学习映射的方法，注意需要什么，应该关注什么。本题中，长队里只需关注各队伍的相对顺序，无需在长队中注意每个人的相对位置。</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>图书管理系统</title>
    <url>/2020/03/30/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="uva230-图书管理系统"><a class="markdownIt-Anchor" href="#uva230-图书管理系统"></a> uva230 图书管理系统</h1>
<p> 你的任务是模拟一个图书管理系统。首先输入若干图书的标题和作者（标题各不相同，以END结束），然后是若干指令：BORROW指令表示借书，RETURN指令表示还书，SHELVE指令表示把所有已归还但还没有上架的图书排序后依次插入书架并输出图书标题和插入位置（可能是第一本书或者某本书的后面）。<br />
 图书排序的方法是先按作者从小到大排，再按标题从小到大排。在处理第一条指令之前，你应当现将所有图书按照这种方式排序。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>涉及排序，想到用一个集合来存，其中元素既要包含作者名，又要包含书名，并且要先按作者名排序，再按书名排序。所以要写一个结构体，并冲写&lt;号。</li>
<li>由于指令后面只跟书名，所以还要用一个map来存储每本书的作者，以便在处理指令的时候，补全字段，从而在集合中查找</li>
<li>SHELVE是在所有return结束后一起进行，所以还要用一个容器来存归还过的书，并且也要按要求排序，所以用了一个after这个set。</li>
<li>BORROW即在集合中找到对应元素，然后擦除(要判断是否为结束迭代器，否则re)</li>
<li>RETURN即插入图书集合以及after集合</li>
<li>SHELVE时，按after中顺序结合作者名查找对应书，输出前一个迭代器指向的对象，注意first的判断即可</li>
<li>别的都十分正常，主要是注意以下erase时，要判断是否为end</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   #include&lt;iostream&gt;</span><br><span class="line">   #include&lt;string&gt;</span><br><span class="line">   #include&lt;algorithm&gt;</span><br><span class="line">   #include&lt;vector&gt;</span><br><span class="line">   #include&lt;iterator&gt;</span><br><span class="line">   #include&lt;set&gt;</span><br><span class="line">   #include&lt;map&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;习题5-8in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;习题5-8out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   string s;</span><br><span class="line">   struct node &#123;</span><br><span class="line">   	string book;</span><br><span class="line">   	string auth;</span><br><span class="line">   	node() &#123; &#125;</span><br><span class="line">   	node(string book, string auth) : book(book), auth(auth) &#123;&#125;</span><br><span class="line">   	bool operator &lt; (const node &amp;a)const &#123;</span><br><span class="line">   		return auth &lt; a.auth || (auth &#x3D;&#x3D; a.auth &amp;&amp; book &lt; a.book);</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   int main() &#123;</span><br><span class="line">set&lt;node&gt; library;</span><br><span class="line">map&lt;string, string&gt; who;</span><br><span class="line">set&lt;node&gt; after;</span><br><span class="line">while (getline(cin, s) &amp;&amp; s !&#x3D; &quot;END&quot;) &#123;</span><br><span class="line">	int f1 &#x3D; s.find(&quot;\&quot;&quot;);</span><br><span class="line">	int f2 &#x3D; s.substr(f1+1).find(&#39;&quot;&#39;);&#x2F;&#x2F;+1!!!!</span><br><span class="line">	node b(s.substr(f1 + 1, f2), s.substr(f2 + 5));</span><br><span class="line">	library.insert(b);</span><br><span class="line">	who[b.book] &#x3D; b.auth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while (getline(cin, s) &amp;&amp; s !&#x3D; &quot;END&quot;) &#123;</span><br><span class="line">	set&lt;node&gt;::iterator it;</span><br><span class="line">	int f1 &#x3D; s.find(&quot;\&quot;&quot;);</span><br><span class="line">	int f2 &#x3D; s.substr(f1 + 1).find(&#39;&quot;&#39;);</span><br><span class="line">	string bookname &#x3D; s.substr(f1 + 1,f2);</span><br><span class="line">	</span><br><span class="line">	if (s[0] &#x3D;&#x3D; &#39;B&#39;) &#123;</span><br><span class="line">		</span><br><span class="line">		it &#x3D; library.find(node(bookname, who[bookname]));</span><br><span class="line">		</span><br><span class="line">		if (it !&#x3D; library.end())	library.erase(it);</span><br><span class="line">	&#125;</span><br><span class="line">	if (s[0] &#x3D;&#x3D; &#39;R&#39;) &#123;</span><br><span class="line">		library.insert(node(bookname, who[bookname]));</span><br><span class="line">		after.insert(node(bookname, who[bookname]));</span><br><span class="line">	&#125;</span><br><span class="line">	if (s[0] &#x3D;&#x3D; &#39;S&#39;) &#123;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		for (set&lt;node&gt;::iterator i &#x3D; after.begin(); i !&#x3D; after.end();i++) &#123;&#x2F;&#x2F;输出也是先按作者名排序再按书名排序</span><br><span class="line">			bookname &#x3D; i-&gt;book;</span><br><span class="line">			it &#x3D; library.find(node(bookname, who[bookname]));</span><br><span class="line">			cout &lt;&lt; &quot;Put \&quot;&quot; &lt;&lt; bookname &lt;&lt;&quot;\&quot;&quot;;</span><br><span class="line">			if (it !&#x3D; library.begin()) cout &lt;&lt; &quot; after \&quot;&quot; &lt;&lt; (--it)-&gt;book &lt;&lt; &quot;\&quot;&quot;&lt;&lt;endl;</span><br><span class="line">			else cout &lt;&lt; &quot; first&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; &quot;END&quot; &lt;&lt; endl;</span><br><span class="line">		after.clear();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<p>存储重复的数据有时候也是必要的，不要为了那点空间，花太多力气</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>图论</title>
    <url>/2020/03/30/%E5%9B%BE%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="图论基础"><a class="markdownIt-Anchor" href="#图论基础"></a> 图论基础</h1>
<ol>
<li>邻接矩阵：适用于稠密图和需要频繁判断某特定的结点对是否相邻的情况</li>
<li>邻接链表：适用于需要大量遍历邻接节点而较少判断两个节点间关系时使用</li>
</ol>
<h1 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int maxn &#x3D; 10000000 + 5;</span><br><span class="line">int Tree[maxn];</span><br><span class="line">int setRank[maxn];</span><br><span class="line">int findRoot(int x) &#123;</span><br><span class="line">	if (Tree[x] &#x3D;&#x3D; -1) return x;</span><br><span class="line">	else &#123;</span><br><span class="line">		int tmp &#x3D; findRoot(Tree[x]);</span><br><span class="line">		Tree[x] &#x3D; tmp;</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void union_(int p, int q) &#123;</span><br><span class="line">	p &#x3D; findRoot(p);</span><br><span class="line">	q &#x3D; findRoot(q);</span><br><span class="line">	if (p !&#x3D; q)</span><br><span class="line">	&#123;</span><br><span class="line">		Tree[p] &#x3D; q;</span><br><span class="line">		setRank[q] +&#x3D; setRank[p];</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="head-of-a-gang"><a class="markdownIt-Anchor" href="#head-of-a-gang"></a> Head of a Gang</h2>
<p>每次输入两个人的名字和通话时长，有联系的两个人属于同一个组织。总的通话时长大于k且总人数大于2的组织称为一个团伙，其中权重最大的那个人是头目。现在要输出团伙总数，及每个团伙的头目，并要求按头目名字降序输出。</p>
<h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3>
<ol>
<li>需要计算每个集合的总权重，所以每次都将小树连到大树上，之后统计大树的根所包含的权重是否满足要求。</li>
<li><strong>注意</strong> memset只对0和-1有效。可使用fill实现</li>
</ol>
<blockquote>
<p>memset是一个字节一个字节设置的，取要赋的值的后8位二进制进行赋值。<br />
1的二进制是（00000000 00000000 00000000 00000001），取后8位（00000001），int型占4个字节，当初始化为1时，它把一个int的每个字节都设置为1，也就是0x01010101,二进制是00000001 00000001 00000001 00000001，十进制就是16843009。<br />
之所以输入0,-1时正确，纯属巧合。<br />
0，二进制是（00000000 00000000 00000000 00000000），取后8位（00000000），初始化后00000000 00000000 00000000 00000000结果是0<br />
-1，负数在计算机中以补码存储，二进制是（11111111 11111111 11111111 11111111），取后8位（11111111），则是11111111 11111111 11111111 11111111结果也是-1</p>
</blockquote>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">int Tree[maxn];&#x2F;&#x2F;记录根</span><br><span class="line">int setRank[maxn];&#x2F;&#x2F;记录树的大小</span><br><span class="line">int tot[maxn];&#x2F;&#x2F;记录树的权重和</span><br><span class="line">map&lt;int, string&gt; id;&#x2F;&#x2F;记录编号对应的名字</span><br><span class="line">map&lt;string, int&gt; name;&#x2F;&#x2F;记录名字对应的编号</span><br><span class="line">int g[maxn][maxn];&#x2F;&#x2F;记录两点之间的距离，不必要，可以每次union时作为参数传入</span><br><span class="line">int weight[maxn];&#x2F;&#x2F;记录每个节点的权重，每提到一次就加一次</span><br><span class="line"></span><br><span class="line">int findRoot(int x) &#123;</span><br><span class="line">	if (Tree[x] &#x3D;&#x3D; -1) return x;</span><br><span class="line">	else &#123;</span><br><span class="line">		int tmp &#x3D; findRoot(Tree[x]);</span><br><span class="line">		Tree[x] &#x3D; tmp;</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void union_(int p, int q) &#123;</span><br><span class="line">	int rootp &#x3D; findRoot(p);</span><br><span class="line">	int rootq &#x3D; findRoot(q);</span><br><span class="line">	if (rootp !&#x3D; rootq)</span><br><span class="line">	&#123;</span><br><span class="line">		if (tot[rootp] &lt; tot[rootq])&#x2F;&#x2F;每次都将小树加在大树上</span><br><span class="line">			swap(rootp, rootq);</span><br><span class="line">		Tree[rootq] &#x3D; rootp;</span><br><span class="line">		tot[rootp] +&#x3D; tot[rootq] + g[p][q];&#x2F;&#x2F;g[p][q]可以通过参数传入</span><br><span class="line">		setRank[rootp] +&#x3D; setRank[rootq];</span><br><span class="line">	&#125;</span><br><span class="line">	else tot[rootp] +&#x3D; g[q][p];&#x2F;&#x2F;即使已经在一颗树上也要加上内部联系的权重</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, a, b, m, k;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;n, &amp;k) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(Tree, -1, sizeof(Tree));</span><br><span class="line">		memset(tot, 0, sizeof(tot));</span><br><span class="line">		memset(weight, 0, sizeof(weight));</span><br><span class="line">		fill(setRank, setRank + maxn, 1);</span><br><span class="line">		name.clear();</span><br><span class="line">		string n1, n2;</span><br><span class="line">		int t;</span><br><span class="line">		int num &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; t;</span><br><span class="line">			if (!name.count(n1)) &#123;</span><br><span class="line">				name[n1] &#x3D; ++num;</span><br><span class="line">				id[num] &#x3D; n1;</span><br><span class="line">			&#125;</span><br><span class="line">			if (!name.count(n2)) &#123;</span><br><span class="line">				name[n2] &#x3D; ++num;</span><br><span class="line">				id[num] &#x3D; n2;</span><br><span class="line">			&#125;</span><br><span class="line">			int s1 &#x3D; name[n1], s2 &#x3D; name[n2];</span><br><span class="line">			g[s1][s2] &#x3D; g[s2][s1] &#x3D; t;</span><br><span class="line">			weight[s1] +&#x3D; t;</span><br><span class="line">			weight[s2] +&#x3D; t;</span><br><span class="line">			union_(name[n1], name[n2]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		vector&lt;int&gt; ans;&#x2F;&#x2F;存满足条件的集合的根节点</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; num; i++) &#123;</span><br><span class="line">			if (Tree[i] &#x3D;&#x3D; -1 &amp;&amp; tot[i] &gt; k&amp;&amp;setRank[i] &gt; 2) &#123;</span><br><span class="line">				ans.push_back(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans.size() &lt;&lt; endl;</span><br><span class="line">		map&lt;string, int&gt; gang;&#x2F;&#x2F;存满足条件集合的头目名字和集合的大小</span><br><span class="line">		for (int i &#x3D; 0; i &lt; ans.size(); i++) &#123;</span><br><span class="line">			int t &#x3D; ans[i];</span><br><span class="line">			int w &#x3D; 0;</span><br><span class="line">			int iw &#x3D; 0;</span><br><span class="line">			for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">				if ((Tree[j] &#x3D;&#x3D; t||j&#x3D;&#x3D;t) &amp;&amp; weight[j] &gt; w) &#123;</span><br><span class="line">					w &#x3D; weight[j];</span><br><span class="line">					iw &#x3D; j;</span><br><span class="line">				&#125;</span><br><span class="line">			gang[id[iw]] &#x3D; setRank[t];</span><br><span class="line">		&#125;</span><br><span class="line">		for (auto i &#x3D; gang.begin(); i !&#x3D; gang.end(); i++) </span><br><span class="line">			cout &lt;&lt; i-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; i-&gt;second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最小生成树"><a class="markdownIt-Anchor" href="#最小生成树"></a> 最小生成树</h1>
<h2 id="kruskal-又是畅通工程"><a class="markdownIt-Anchor" href="#kruskal-又是畅通工程"></a> Kruskal (又是畅通工程)</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">int Tree[maxn];&#x2F;&#x2F;记录根</span><br><span class="line">struct node &#123;</span><br><span class="line">	int a, b;</span><br><span class="line">	int w;</span><br><span class="line"></span><br><span class="line">	bool operator &lt; (const node&amp;a)const &#123; return w &lt; a.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int findRoot(int x) &#123;</span><br><span class="line">	if (Tree[x] &#x3D;&#x3D; -1) return x;</span><br><span class="line">	else &#123;</span><br><span class="line">		int tmp &#x3D; findRoot(Tree[x]);</span><br><span class="line">		Tree[x] &#x3D; tmp;</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool union_(int p, int q) &#123;</span><br><span class="line">	int rootp &#x3D; findRoot(p);</span><br><span class="line">	int rootq &#x3D; findRoot(q);</span><br><span class="line">	if (rootp !&#x3D; rootq)</span><br><span class="line">	&#123;</span><br><span class="line">		Tree[rootq] &#x3D; rootp;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">node g[maxn*maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		int m &#x3D; n * (n - 1) &#x2F; 2;</span><br><span class="line">		memset(Tree, -1, sizeof(Tree));</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++)</span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;g[i].a, &amp;g[i].b, &amp;g[i].w);</span><br><span class="line">		sort(g, g + m);</span><br><span class="line"></span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			int a &#x3D; g[i].a;</span><br><span class="line">			int b &#x3D; g[i].b;</span><br><span class="line">			if (union_(a, b))</span><br><span class="line">				ans +&#x3D; g[i].w;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="poj-2560"><a class="markdownIt-Anchor" href="#poj-2560"></a> POJ 2560</h2>
<p>不直接给出边，而是给出点的坐标，实际也是最小生成树问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">int Tree[maxn];&#x2F;&#x2F;记录根</span><br><span class="line">struct point &#123;</span><br><span class="line">	double x, y;</span><br><span class="line">	point()&#123;&#125;</span><br><span class="line">	point(double x, double y) :x(x), y(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int a, b;</span><br><span class="line">	double w;</span><br><span class="line">	node() &#123;&#125;;</span><br><span class="line">	node(int a, int b, double w) :a(a), b(b), w(w) &#123;&#125;</span><br><span class="line">	bool operator &lt; (const node&amp;a)const &#123; return w &lt; a.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int findRoot(int x) &#123;</span><br><span class="line">	if (Tree[x] &#x3D;&#x3D; -1) return x;</span><br><span class="line">	else &#123;</span><br><span class="line">		int tmp &#x3D; findRoot(Tree[x]);</span><br><span class="line">		Tree[x] &#x3D; tmp;</span><br><span class="line">		return tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool union_(int p, int q) &#123;</span><br><span class="line">	int rootp &#x3D; findRoot(p);</span><br><span class="line">	int rootq &#x3D; findRoot(q);</span><br><span class="line">	if (rootp !&#x3D; rootq)</span><br><span class="line">	&#123;</span><br><span class="line">		Tree[rootq] &#x3D; rootp;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline double getDis(point a, point b) &#123;</span><br><span class="line">	return sqrt((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y));</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(Tree, -1, sizeof(Tree));	</span><br><span class="line">		node g[maxn*maxn];</span><br><span class="line">		point p[maxn];</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%lf%lf&quot;, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">		&#125;</span><br><span class="line">		int m &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; i + 1; j &lt; n; j++) &#123;</span><br><span class="line">				g[m++] &#x3D; node(i, j, getDis(p[i], p[j]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(g, g + m);</span><br><span class="line">		double ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			int a &#x3D; g[i].a;</span><br><span class="line">			int b &#x3D; g[i].b;</span><br><span class="line">			if (union_(a, b))</span><br><span class="line">				ans +&#x3D; g[i].w;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%.2lf\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最短路径"><a class="markdownIt-Anchor" href="#最短路径"></a> 最短路径</h1>
<h2 id="flyod"><a class="markdownIt-Anchor" href="#flyod"></a> Flyod</h2>
<h3 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想"></a> 基本思想</h3>
<ol>
<li>每次加入一个节点，并分析对于每一对点，能否使二者间距离变短(不通变通)</li>
<li>使用邻接矩阵存储图</li>
<li>时间复杂度O(n<sup>3</sup>)</li>
<li>一次Floyd之后，图中所有点之间的最短路径都被确定，所以适用于多组查询的情况</li>
<li>注意初始化函数中定义自己到自己的距离为0</li>
</ol>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void init(int n) &#123;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">			ans[i][j] &#x3D; -1;</span><br><span class="line">		ans[i][i] &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void Floyd(int n) &#123;</span><br><span class="line"></span><br><span class="line">	for (int k &#x3D; 1; k &lt;&#x3D; n; k++) &#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">				if (ans[i][k] &#x3D;&#x3D; -1 || ans[k][j] &#x3D;&#x3D; -1) continue;</span><br><span class="line">				if (ans[i][j] &#x3D;&#x3D; -1 || ans[i][j] &gt; ans[i][k] + ans[k][j])</span><br><span class="line">					ans[i][j] &#x3D; ans[i][k] + ans[k][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dijkstra-单源最短路"><a class="markdownIt-Anchor" href="#dijkstra-单源最短路"></a> Dijkstra 单源最短路</h2>
<h3 id="基本思想-2"><a class="markdownIt-Anchor" href="#基本思想-2"></a> 基本思想</h3>
<ol>
<li>按照最短路径长度递增的顺序确定每一个节点的最短路径长度，即先确定的结点的最短路径长度不大于后确定的最短路径长度。这样，当确定一个节点的最短路径长度时，该最短路径上所有中间结点的最短路径长度必然已经确定。</li>
<li>用优先级队列优化后，时间复杂度O(nlogn)</li>
<li>关于实现，由于优先级队列默认调用less，即&lt;号得到递减序列。为了简化代码(其实是懒)，所以将结构体中’&lt;‘重载为’&gt;’。当然也可以priority_queue&lt;edge,vector<edge>,greater<edge>&gt;;</li>
</ol>
<h3 id="最短路径问题浙大"><a class="markdownIt-Anchor" href="#最短路径问题浙大"></a> 最短路径问题(浙大)</h3>
<p>除路长度外增加了一个花费，优先取路径长度最小，对于相同长度的取花费最小。思想一致，只需在板子外再加一个cost数组。与dis数组同理即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">struct edge &#123;</span><br><span class="line">	int to;</span><br><span class="line">	int w;</span><br><span class="line">	int c;</span><br><span class="line">	edge() &#123;&#125;</span><br><span class="line">	edge(int to, int w, int c) :to(to), w(w), c(c) &#123;&#125;</span><br><span class="line">	bool operator &lt;(const edge a) const &#123; return w &gt; a.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt;g[maxn];</span><br><span class="line">int cost[maxn];</span><br><span class="line">int dis[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">void Dij(int beg, int goal, int n) &#123;</span><br><span class="line">	memset(dis, -1, sizeof(dis));</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	memset(cost, 0, sizeof(cost));</span><br><span class="line">	dis[beg] &#x3D; 0;</span><br><span class="line">	priority_queue&lt;edge&gt; pq;</span><br><span class="line">	pq.push(edge(beg, 0, 0));</span><br><span class="line">	while (!pq.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		edge u &#x3D; pq.top(); pq.pop();</span><br><span class="line">		if (u.to &#x3D;&#x3D; goal) return;</span><br><span class="line">		if (vis[u.to]) continue;</span><br><span class="line">		vis[u.to] &#x3D; 1;</span><br><span class="line">		for (edge e : g[u.to]) &#123;</span><br><span class="line">			if (!vis[e.to]) &#123;</span><br><span class="line">				int d1 &#x3D; dis[e.to];</span><br><span class="line">				int d2 &#x3D; dis[u.to];</span><br><span class="line">				if (d1 &#x3D;&#x3D; -1 </span><br><span class="line">					||d1 &gt; d2 + e.w</span><br><span class="line">					|| (d1&#x3D;&#x3D; d2 + e.w &amp;&amp; cost[e.to] &gt; cost[u.to] + e.c)) </span><br><span class="line">				&#123;</span><br><span class="line">					dis[e.to] &#x3D; dis[u.to] + e.w;</span><br><span class="line">					cost[e.to] &#x3D; cost[u.to] + e.c;</span><br><span class="line">					pq.push(edge(e.to, dis[e.to], cost[e.to]));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	int a, b, w, c;</span><br><span class="line">	int s, t;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		if (m &#x3D;&#x3D; 0 &amp;&amp; n &#x3D;&#x3D; 0) break;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)	g[i].clear();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;w, &amp;c);</span><br><span class="line">			g[a].push_back(edge(b, w, c));</span><br><span class="line">			g[b].push_back(edge(a, w, c));</span><br><span class="line">		&#125;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;s, &amp;t);</span><br><span class="line">		Dij(s, t, n);</span><br><span class="line">		printf(&quot;%d %d\n&quot;, dis[t], cost[t]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路径上交"><a class="markdownIt-Anchor" href="#最短路径上交"></a> 最短路径(上交)</h2>
<p>N个城市，标号从0到N-1，M条道路，第K条道路（K从0开始）的长度为2^K，求编号为0的城市到其他城市的最短距离<br />
输入：第一行两个正整数N（2&lt;=N&lt;=100）M(M&lt;=500),表示有N个城市，M条道路。接下来M行两个整数，表示相连的两个城市的编号<br />
输出：N-1行，表示0号城市到其他城市的最短路，如果无法到达，输出-1，数值太大的以MOD 100000 的结果输出。</p>
<h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3>
<ol>
<li>本题是高精度整数和迪杰斯特拉算法的结合，作为综合练习。</li>
<li>主要注意一下细节问题，主要是% 运算符的重载，一开始写错了。</li>
<li>出现死循环别忘了检查输入的循环，比如是否忘了写scanf()==2</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">class BigInteger &#123;</span><br><span class="line">private:</span><br><span class="line">	const static int maxn &#x3D; 1000 + 5;</span><br><span class="line">	void init() &#123;</span><br><span class="line">		memset(digit, 0, sizeof(digit));</span><br><span class="line">		size &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">public:</span><br><span class="line">	int digit[maxn];</span><br><span class="line">	int size;</span><br><span class="line">	void set(char str[]) &#123;</span><br><span class="line">		int len &#x3D; strlen(str);</span><br><span class="line">		init();</span><br><span class="line">		for (int i &#x3D; len - 1, j &#x3D; 0, t &#x3D; 0, c &#x3D; 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			t +&#x3D; (str[i] - &#39;0&#39;)*c;</span><br><span class="line">			j++;</span><br><span class="line">			c *&#x3D; 10;</span><br><span class="line">			if (j &#x3D;&#x3D; 4 || i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				digit[size++] &#x3D; t;</span><br><span class="line">				t &#x3D; 0;</span><br><span class="line">				j &#x3D; 0;</span><br><span class="line">				c &#x3D; 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	void output() &#123;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			if (i !&#x3D; size - 1)</span><br><span class="line">				printf(&quot;%04d&quot;, digit[i]);</span><br><span class="line">			else if (digit[i])</span><br><span class="line">				printf(&quot;%d&quot;, digit[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	int operator % (int x) const &#123;</span><br><span class="line">		int remain &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--) </span><br><span class="line">			remain &#x3D; (remain * 10000 + digit[i]) % x;</span><br><span class="line">		return remain;</span><br><span class="line">	&#125;</span><br><span class="line">	BigInteger operator * (const int &amp;a) const &#123;</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] * a + cf;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">	BigInteger operator + (const  BigInteger &amp;A) const &#123;</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; size || i &lt; A.size; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] + A.digit[i] + cf;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator &lt;(const BigInteger A) const &#123;</span><br><span class="line">		if (A.size !&#x3D; size) return size &lt; A.size;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			if (digit[i] !&#x3D; A.digit[i])</span><br><span class="line">				return digit[i] &lt; A.digit[i];</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct edge &#123;</span><br><span class="line">	int to;</span><br><span class="line">	BigInteger w;</span><br><span class="line">	edge(int to, BigInteger w) :to(to), w(w) &#123;&#125;</span><br><span class="line">	bool operator &lt; (const edge&amp;a) const &#123; return a.w &lt; w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt; g[105];</span><br><span class="line">BigInteger dis[105]&#123;&#125;;</span><br><span class="line">void dij(int beg) &#123;</span><br><span class="line">	priority_queue&lt;edge&gt; pq;</span><br><span class="line">	int vis[105]&#123;&#125;;</span><br><span class="line">	memset(dis, 0, sizeof(dis));</span><br><span class="line">	char s[] &#x3D; &quot;0&quot;;</span><br><span class="line">	BigInteger ss; ss.set(s);</span><br><span class="line">	dis[beg] &#x3D; ss;</span><br><span class="line">	pq.push(edge(beg, dis[beg]));</span><br><span class="line">	while (!pq.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		edge u &#x3D; pq.top(); pq.pop();</span><br><span class="line">		if (vis[u.to]) continue;</span><br><span class="line">		vis[u.to] &#x3D; 1;</span><br><span class="line">		for (edge e : g[u.to]) &#123;</span><br><span class="line">			if (vis[e.to]) continue;</span><br><span class="line">			if (dis[e.to].size &#x3D;&#x3D; 0 || dis[u.to] + e.w &lt; dis[e.to]) &#123;</span><br><span class="line">				dis[e.to] &#x3D; dis[u.to] + e.w;</span><br><span class="line">				pq.push(edge(e.to, dis[e.to]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		char s[] &#x3D; &quot;1&quot;;</span><br><span class="line">		BigInteger c;</span><br><span class="line">		c.set(s);</span><br><span class="line">		int a, b;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">			g[a].push_back(edge(b, c));</span><br><span class="line">			g[b].push_back(edge(a, c));</span><br><span class="line">			c &#x3D; c * 2;</span><br><span class="line">		&#125;</span><br><span class="line">		dij(0);</span><br><span class="line">		for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">			if (dis[i].size)</span><br><span class="line">				printf(&quot;%d\n&quot;, dis[i] % 100000);</span><br><span class="line">			else printf(&quot;-1\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="i-wanna-go-home-poj-3767"><a class="markdownIt-Anchor" href="#i-wanna-go-home-poj-3767"></a> I wanna go home POJ 3767</h2>
<p>某国出现政治分裂，其中的城市分裂成两派，一派支持领导1，一派支持领导2。你是一名商人，在城市1，想走最短路径回到城市2，要求路径中包含至多一条跨过两个阵营的路径，求最短路径长度。</p>
<h3 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h3>
<ol>
<li>首先用dij分别求两个阵营内部，从源点1和2出发的最短距离。</li>
<li>然后枚举连接两个阵营的边，对于贯穿两个阵营的路径，尝试更新答案为d1[i]+t[i][j]+d2[j]。</li>
</ol>
<h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 600 + 5;</span><br><span class="line">struct edge &#123;</span><br><span class="line">	int to;</span><br><span class="line">	int w;</span><br><span class="line">	edge() &#123;&#125;</span><br><span class="line">	edge(int to, int w) :to(to), w(w) &#123;&#125;</span><br><span class="line">	bool operator &lt;(const edge a) const &#123; return w &gt; a.w; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt;g[maxn];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int t[maxn][maxn];</span><br><span class="line">int flag[maxn];</span><br><span class="line"></span><br><span class="line">void Dij(int beg, int n, int f, int *dis) &#123;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	dis[beg] &#x3D; 0;</span><br><span class="line">	priority_queue&lt;edge&gt; pq;</span><br><span class="line">	pq.push(edge(beg, 0));</span><br><span class="line">	while (!pq.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		edge u &#x3D; pq.top(); pq.pop();</span><br><span class="line">		if (vis[u.to]) continue;</span><br><span class="line">		vis[u.to] &#x3D; 1;</span><br><span class="line">		for (edge e : g[u.to]) &#123;</span><br><span class="line">			if (flag[e.to] !&#x3D; f) continue;</span><br><span class="line">			if (!vis[e.to]) &#123;</span><br><span class="line">				if (dis[e.to] &#x3D;&#x3D; -1 || dis[e.to] &gt; dis[u.to] + e.w)</span><br><span class="line">				&#123;</span><br><span class="line">					dis[e.to] &#x3D; dis[u.to] + e.w;</span><br><span class="line">					pq.push(edge(e.to, dis[e.to]));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	int a, b, w;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;m);</span><br><span class="line">		memset(t, -1, sizeof(t));</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) g[i].clear();</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;w);</span><br><span class="line">			if (t[a][b] &#x3D;&#x3D; -1 || w &lt; t[a][b])</span><br><span class="line">				t[a][b] &#x3D; t[b][a] &#x3D; w;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;flag[i]);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			for (int j &#x3D; 1; j &lt;&#x3D; i; j++) &#123;</span><br><span class="line">				if (t[i][j] !&#x3D; -1) &#123;</span><br><span class="line">					g[i].push_back(edge(j, t[i][j]));</span><br><span class="line">					g[j].push_back(edge(i, t[i][j]));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		int d1[maxn];</span><br><span class="line">		int d2[maxn];</span><br><span class="line">		memset(d1, -1, sizeof(d1));</span><br><span class="line">		memset(d2, -1, sizeof(d2));</span><br><span class="line">		Dij(1, n, 1, d1);</span><br><span class="line">		Dij(2, n, 2, d2);</span><br><span class="line">		int ans &#x3D; d1[2];</span><br><span class="line">		if (ans &#x3D;&#x3D; -1)</span><br><span class="line">			for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">				if (flag[i] &#x3D;&#x3D; 2 || d1[i] &#x3D;&#x3D; -1) continue;</span><br><span class="line">				for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">					if (flag[j] &#x3D;&#x3D; 1 || d2[j] &#x3D;&#x3D; -1) continue;</span><br><span class="line">					if (t[i][j] !&#x3D; -1) &#123;</span><br><span class="line">						if (ans &#x3D;&#x3D; -1 || d1[i] + t[i][j] + d2[j] &lt; ans)</span><br><span class="line">							ans &#x3D; d1[i] + t[i][j] + d2[j];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="拓扑排序"><a class="markdownIt-Anchor" href="#拓扑排序"></a> 拓扑排序</h1>
<h2 id="基本思想-3"><a class="markdownIt-Anchor" href="#基本思想-3"></a> 基本思想</h2>
<ol>
<li>每次取入度为0的点，并删除之，修改它所连接的点的入读，反复入队入度为0的点。记录总的出队点数。如果等于n说明无环，能构成拓扑序列；否则，不能构成拓扑序列。</li>
<li>时间复杂度O(N+M),其中N为顶点数，M为边数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int maxn &#x3D; 500 + 5;</span><br><span class="line">int indegree[maxn];</span><br><span class="line">vector&lt;int&gt; g[maxn];</span><br><span class="line">bool topo(int n) &#123;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	vector&lt;int&gt; ans;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) </span><br><span class="line">		if (indegree[i] &#x3D;&#x3D; 0) q.push(i);</span><br><span class="line"></span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		int u &#x3D; q.front(); q.pop();</span><br><span class="line">		ans.push_back(u);</span><br><span class="line"></span><br><span class="line">		for (int i : g[u]) &#123;</span><br><span class="line">			indegree[i]--;</span><br><span class="line">			if (indegree[i] &#x3D;&#x3D; 0)</span><br><span class="line">				q.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (ans.size() &#x3D;&#x3D; n) return true;</span><br><span class="line">	else return false;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	int a, b;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(indegree, 0, sizeof(indegree));</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)  g[i].clear();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">			g[a].push_back(b);</span><br><span class="line">			indegree[b]++;</span><br><span class="line">		&#125;</span><br><span class="line">		bool flag  &#x3D; topo(n);</span><br><span class="line">		if (flag)</span><br><span class="line">			printf(&quot;YES\n&quot;);</span><br><span class="line">		else printf(&quot;NO\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="产生冠军-hdu-2094"><a class="markdownIt-Anchor" href="#产生冠军-hdu-2094"></a> 产生冠军 HDU 2094</h2>
<p>有一群人，打乒乓球比赛，两两捉对撕杀，每两个人之间最多打一场比赛。<br />
球赛的规则如下：<br />
如果A打败了B，B又打败了C，而A与C之间没有进行过比赛，那么就认定，A一定能打败C。<br />
如果A打败了B，B又打败了C，而且，C又打败了A，那么A、B、C三者都不可能成为冠军。<br />
根据这个规则，无需循环较量，或许就能确定冠军。你的任务就是面对一群比赛选手，在经过了若干场撕杀之后，确定是否已经实际上产生了冠军。</p>
<p>输入含有一些选手群，每群选手都以一个整数n(n&lt;1000)开头，后跟n对选手的比赛结果，比赛结果以一对选手名字（中间隔一空格）表示，前者战胜后者。如果n为0，则表示输入结束。</p>
<p>对于每个选手群，若你判断出产生了冠军，则在一行中输出“Yes”，否则在一行中输出“No”。</p>
<h3 id="思路-4"><a class="markdownIt-Anchor" href="#思路-4"></a> 思路</h3>
<ol>
<li>本题技巧在于只需判断初始状态下，入度为0的点是否为1个即可。</li>
</ol>
<h3 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">int indegree[maxn];</span><br><span class="line">vector&lt;int&gt; g[maxn];</span><br><span class="line">bool topo(int n) &#123;</span><br><span class="line">	int tmp[maxn];</span><br><span class="line">	int tot &#x3D; 0;</span><br><span class="line">	memcpy(tmp, indegree, sizeof(tmp));</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) </span><br><span class="line">		if (indegree[i] &#x3D;&#x3D; 0) tot++;</span><br><span class="line">	return tot&#x3D;&#x3D;1;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;string, int&gt; id;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	int a, b;</span><br><span class="line">	while (cin &gt;&gt; m &amp;&amp; m)</span><br><span class="line">	&#123;</span><br><span class="line">		string s, y;</span><br><span class="line">		memset(indegree, 0, sizeof(indegree));</span><br><span class="line">		for (int i &#x3D; 1; i &lt; maxn; i++)  g[i].clear();</span><br><span class="line">		int num &#x3D; 1;</span><br><span class="line">		id.clear();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			cin &gt;&gt; s &gt;&gt; y;</span><br><span class="line">			if (!id.count(s))</span><br><span class="line">				id[s] &#x3D; num++;</span><br><span class="line">			if (!id.count(y))</span><br><span class="line">				id[y] &#x3D; num++;</span><br><span class="line">			a &#x3D; id[s];</span><br><span class="line">			b &#x3D; id[y];</span><br><span class="line">			g[a].push_back(b);</span><br><span class="line">			indegree[b]++;</span><br><span class="line">		&#125;</span><br><span class="line">		bool flag &#x3D; topo(num - 1);</span><br><span class="line"></span><br><span class="line">		if (flag)cout &lt;&lt; &quot;Yes&quot;;</span><br><span class="line">		else cout &lt;&lt; &quot;No&quot;;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>城市正视图</title>
    <url>/2020/03/30/%E5%9F%8E%E5%B8%82%E6%AD%A3%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="uva221-城市正视图"><a class="markdownIt-Anchor" href="#uva221-城市正视图"></a> uva221 城市正视图</h1>
<p> 如图5-4所示，有n（n≤100）个建筑物。左侧是俯视图（左上角为建筑物编号，右下角为高度），右侧是从南向北看的正视图。<br />
输入每个建筑物左下角坐标（即x、y坐标的最小值）、宽度（即x方向的长度）、深度（即y方向的长度）和高度（以上数据均为实数），输出正视图中能看到的所有建筑物，按照左下角x坐标从小到大进行排序。左下角x坐标相同时，按y坐标从小到大排序。</p>
<p> 输入保证不同的x坐标不会很接近（即任意两个x坐标要么完全相同，要么差别足够大，不会引起精度问题）。</p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<ol>
<li>需要对横坐标进行离散化，然后判断每个区间中点是否可以看见。</li>
<li>判断一个建筑是否在某个坐标处可见：首先，要包含这个点。其次，其他包含这个点的建筑没有比他靠近南边，并且比他高的。</li>
</ol>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<pre><code>#include&lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
struct bulid {
	double x, y, w, d, h;
	int id;
	bool operator &lt;(const bulid&amp;r) const{ return x &lt; r.x || x == r.x&amp;&amp;y &lt; r.y; }
}b[105];
</code></pre>
<blockquote>
<blockquote>
<p>注意此处要重写小于号，用于后面的sort</p>
</blockquote>
</blockquote>
<pre><code>int n;
bool cover(int id, double mx) {
	return mx &gt;= b[id].x &amp;&amp; mx &lt;= b[id].x + b[id].w;
}
</code></pre>
<blockquote>
<blockquote>
<p>判断id号建筑是否包办mx这个点</p>
</blockquote>
</blockquote>
<pre><code>bool visable(int id, double mx) {
	if (!cover(id, mx)) return false;
	for (int i = 0; i &lt; n; i++) {
		if (b[i].y &lt; b[id].y&amp;&amp;b[i].h &gt;= b[id].h&amp;&amp;cover(i, mx)) return false;
	}
	return true;
}
</code></pre>
<blockquote>
<blockquote>
<p>判断id号建筑是否在mx点处可见</p>
</blockquote>
</blockquote>
<pre><code>int main() {
	int kase = 0;
	int first = 1;
	while (cin &gt;&gt; n &amp;&amp; n) {
	
	if (first) first = 0;
	else cout &lt;&lt; endl;

	int x[2*105]{};
	for (int i = 0; i &lt; n; i++) {
		cin &gt;&gt; b[i].x &gt;&gt; b[i].y &gt;&gt; b[i].w &gt;&gt; b[i].d &gt;&gt; b[i].h;
		b[i].id = i + 1;
</code></pre>
<blockquote>
<blockquote>
<p>对坐标进行离散化，把连续的坐标变成离散的区间</p>
</blockquote>
</blockquote>
<pre><code>		x[2 * i] = b[i].x;
		x[2 * i + 1] = b[i].x + b[i].w;
	}


	sort(b, b + n);
	sort(x, x + 2 * n);


	int m = unique(x, x + 2 * n) - x;
</code></pre>
<blockquote>
<blockquote>
<p>对x去重，unique返回值为一个地址，所以要减去x转成索引位置</p>
</blockquote>
</blockquote>
<pre><code>	cout &lt;&lt; &quot;For map # &quot; &lt;&lt;++kase &lt;&lt; &quot;, the visible buildings are numbered as follows:&quot; &lt;&lt; endl;
	cout &lt;&lt; b[0].id ;
		for (int i = 1; i &lt; n; i++) {//循环所有的建筑
			bool vis = false;
			for (int j = 0; j &lt; m - 1; j++) {//循环所有区间
				if (visable(i, (x[j] + x[j + 1]) / 2)) {
				//如果id号建筑在该区间中点可见，则在整个区间可见
					vis = true;
					break;
				}

			}
			if (vis) cout &lt;&lt;&quot; &quot;&lt;&lt; b[i].id;

		}
		cout &lt;&lt; &quot;\n&quot;;
}
}
</code></pre>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>城市里的间谍</title>
    <url>/2020/03/30/%E5%9F%8E%E5%B8%82%E9%87%8C%E7%9A%84%E9%97%B4%E8%B0%8D/</url>
    <content><![CDATA[<h1 id="uva-1025-城市里的间谍"><a class="markdownIt-Anchor" href="#uva-1025-城市里的间谍"></a> UVA 1025 城市里的间谍</h1>
<p>某城市地铁是线性的,有n（2≤n≤50）个车站,从左到右编号1~n。有M1辆列车从第1站开始往右开,还有M2辆列车从第n站开始往左开。列车在相邻站台间所需的运行时间是固定的，因为所有列车的运行速度是相同的。在时刻0,Mario从第1站出发,目的在时刻T（0≤T≤200）会见车站n的一个间谍。在车站等车时容易被抓，所以她决定尽量躲在开动的火车上,让在车站等待的时间尽量短。列车靠站停车时间忽略不计,且Mario身手敏捷,即时两辆方向不同的列车在同一时间靠站,Mario也能完成换乘。 【输入格式】 输入文件包含数种情况，每一种情况包含以下7行：</p>
<p>第一行是一个正整数n，表示有n个车站 第二行是为T，表示Mario在时刻T见车站n的间谍 第三行有n-1个整数t1,t2,…,tn-1,其中ti表示地铁从车站i到i+1的行驶时间 第四行为M1，及从第一站出发向右开的列车数目 第五行包含M1个正整数a1,a2,…,aM1，即个列车出发的时间 第六行为M2，及从第一站出发向右开的列车数目 第七行包含M2个正整数b1,b2,…,bM2，即个列车出发的时间</p>
<p>最后一种情况以一行0结尾。</p>
<p>输出最少等待时间，如果无解则输出impossible</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>时间自然有序，所以沿着时间轴考虑问题。在每一个时刻，决策的影响因素只有当前所处的站，所以用d(i,j)表示在时刻i，车站j，最少还需要等待多少时间。易知边界条件d(T,n) = 0，其他为正无穷</li>
<li>在每个点处，有三种决策
<ol>
<li>等1分钟</li>
<li>搭乘往右开的车</li>
<li>搭乘往左开的车</li>
</ol>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 50 + 5;</span><br><span class="line">const int maxt &#x3D; 200 + 5;</span><br><span class="line">#define inf 1000000000</span><br><span class="line">int t[maxn];</span><br><span class="line">int havetrain[maxt][maxn][2];</span><br><span class="line">int dp[maxt][maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	int T;</span><br><span class="line">	int kase &#x3D; 0;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;n, &amp;T) &amp;&amp; n) &#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;t[i]);</span><br><span class="line">		memset(havetrain, 0, sizeof(havetrain));</span><br><span class="line">		int m1;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;m1);</span><br><span class="line">		int d;</span><br><span class="line">		while (m1--) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;d);</span><br><span class="line">			for (int j &#x3D; 1; j &lt; n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				if (d &lt;&#x3D; T)  havetrain[d][j][0] &#x3D; 1;</span><br><span class="line">				d +&#x3D; t[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int m2;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;m2);</span><br><span class="line">		while (m2--) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;d);</span><br><span class="line">			for (int j &#x3D; n - 1; j &gt;&#x3D; 1; j--)</span><br><span class="line">			&#123;</span><br><span class="line">				if (d &lt;&#x3D; T)  havetrain[d][j+1][1] &#x3D; 1;</span><br><span class="line">				d +&#x3D; t[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n-1; i++)	dp[T][i] &#x3D; inf;</span><br><span class="line"></span><br><span class="line">		dp[T][n] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; T - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">				dp[i][j] &#x3D; dp[i + 1][j] + 1;</span><br><span class="line">				if (j &lt; n &amp;&amp; havetrain[i][j][0] &amp;&amp; i + t[j] &lt;&#x3D; T)</span><br><span class="line">					dp[i][j] &#x3D; min(dp[i][j], dp[i + t[j]][j + 1]); &#x2F;&#x2F; 鍙?</span><br><span class="line">				if (j &gt; 1 &amp;&amp; havetrain[i][j][1] &amp;&amp; i + t[j - 1] &lt;&#x3D; T)</span><br><span class="line">					dp[i][j] &#x3D; min(dp[i][j], dp[i + t[j - 1]][j - 1]);	&#x2F;&#x2F;左</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;Case Number %d: &quot;, ++kase);</span><br><span class="line">		if (dp[0][1] &gt;&#x3D; inf) printf(&quot;impossible\n&quot;);</span><br><span class="line">		else printf(&quot;%d\n&quot;, dp[0][1]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>在Web中搜索</title>
    <url>/2020/03/30/%E5%9C%A8Web%E4%B8%AD%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="uva-1597-在web中搜索"><a class="markdownIt-Anchor" href="#uva-1597-在web中搜索"></a> uva 1597 在web中搜索</h1>
<p>输入nnn篇文章和mmm个请求（n&lt;100，m≤50000n &lt; 100\text{，}m \leq 50000n&lt;100，m≤50000），每个请求都是444种格式之一。</p>
<p>A: 找包含关键字A的文章。</p>
<p>A AND B 找同时包含关键字A和B的文章。</p>
<p>A OR B 找包含关键字A或B的文章。</p>
<p>NOT A 找不包含关键字A的文章。</p>
<p>处理询问时需要对每篇文章输出证据。前3种询问输出所有至少包含一个关键字的行。第4种询问输出不包含A的整篇文章。关键字只由小写字母组成，查找时忽略大小写。每行不超过不超过80字符，一共不超过1500行。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>主要的STL是一个map&lt;string,set<Node>&gt; 用来存储每个单词出现的段号和行号。vector<string> txt[i]来存储第i段的若干句子，一句一句的存。</li>
<li>对于AND指令，需要n2次查找两个单词出现的段落和行号，只有当两个单词出现的段落一致的时候，才输出</li>
<li>OR指令同理</li>
<li>NOT需要循环所有的段落，对于A出现的段落集合中不包括的段，将它防在答案集合中</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line"># pragma warning(disable:4996)</span><br><span class="line"># define LOCAL</span><br><span class="line"># ifdef LOCAL</span><br><span class="line">FILE *fin &#x3D; freopen(&quot;习题5-10in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">FILE *fout &#x3D; freopen(&quot;习题5-10out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line"># endif </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; txt[105];</span><br><span class="line">map&lt;string, set&lt;int&gt;&gt; which_pa;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int p;</span><br><span class="line">	int r;</span><br><span class="line">	node(int p, int r) :p(p), r(r) &#123;&#125;</span><br><span class="line">	bool operator &lt;(const node&amp;a) const &#123;</span><br><span class="line">		return p &lt; a.p || p &#x3D;&#x3D; a.p&amp;&amp;r &lt; a.r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">map&lt;string, set&lt;node&gt;&gt; words_in_where;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, m;</span><br><span class="line">	string s;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n); getchar();</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">		while (getline(cin, s) &amp;&amp; s !&#x3D; &quot;**********&quot;) &#123;</span><br><span class="line">			txt[i].push_back(s);</span><br><span class="line">			string r;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; s.length(); j++) &#123;</span><br><span class="line">				if (isalpha(s[j])) r +&#x3D; tolower(s[j]);</span><br><span class="line">				else &#123;</span><br><span class="line">					if (!r.empty()) &#123;</span><br><span class="line">						words_in_where[r].insert(node(i, txt[i].size() - 1));</span><br><span class="line">						which_pa[r].insert(i);</span><br><span class="line">					&#125;</span><br><span class="line">					r.clear();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	scanf(&quot;%d&quot;, &amp;m); getchar();</span><br><span class="line">	for (int ff &#x3D; 0; ff &lt; m; ff++) &#123;</span><br><span class="line">		getline(cin, s);</span><br><span class="line">		int orx;</span><br><span class="line">		&#x2F;&#x2F;cout &lt;&lt; endl &lt;&lt; s &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">		if ((orx &#x3D; s.find(&quot; AND &quot;)) !&#x3D; string::npos) &#123;</span><br><span class="line">			string a &#x3D; s.substr(0, orx);</span><br><span class="line">			string b &#x3D; s.substr(orx + 5);</span><br><span class="line">			&#x2F;&#x2F;	cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">			set&lt;node&gt; aw &#x3D; words_in_where[a];</span><br><span class="line">			set&lt;node&gt; bw &#x3D; words_in_where[b];</span><br><span class="line">			set&lt;node&gt; ans;</span><br><span class="line">			ans.clear();</span><br><span class="line">			if (a &#x3D;&#x3D; b) &#123;</span><br><span class="line">				for (set&lt;node&gt;::iterator it &#x3D; aw.begin(); it !&#x3D; aw.end(); it++)</span><br><span class="line">					ans.insert(*it);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				for (set&lt;node&gt;::iterator it &#x3D; aw.begin(); it !&#x3D; aw.end(); it++)</span><br><span class="line">					for (set&lt;node&gt;::iterator id &#x3D; bw.begin(); id !&#x3D; bw.end(); id++)</span><br><span class="line">						if ((*it).p &#x3D;&#x3D; (*id).p) &#123;</span><br><span class="line">							ans.insert(*it);</span><br><span class="line">							ans.insert(*id);</span><br><span class="line">						&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (ans.empty()) &#123;</span><br><span class="line">				cout &lt;&lt; &quot;Sorry, I found nothing.&quot; &lt;&lt; endl &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			int k &#x3D; ans.begin()-&gt;p;</span><br><span class="line">			for (set&lt;node&gt;::iterator it &#x3D; ans.begin(); it !&#x3D; ans.end(); it++)</span><br><span class="line">			&#123;</span><br><span class="line">				int p &#x3D; (*it).p;</span><br><span class="line">				int r &#x3D; (*it).r;</span><br><span class="line">				if (k !&#x3D; p) &#123;</span><br><span class="line">					cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;</span><br><span class="line">					k &#x3D; p;</span><br><span class="line">				&#125;</span><br><span class="line">				cout &lt;&lt; txt[p][r] &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else if ((orx &#x3D; s.find(&quot; OR &quot;)) !&#x3D; string::npos) &#123;</span><br><span class="line">			string a &#x3D; s.substr(0, orx);</span><br><span class="line">			string b &#x3D; s.substr(orx + 4);</span><br><span class="line">			&#x2F;&#x2F;cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">			set&lt;node&gt; aw &#x3D; words_in_where[a];</span><br><span class="line">			set&lt;node&gt; bw &#x3D; words_in_where[b];</span><br><span class="line">			set&lt;node&gt; ans;</span><br><span class="line">			ans.clear();</span><br><span class="line">			if (a &#x3D;&#x3D; b) &#123;</span><br><span class="line">				for (set&lt;node&gt;::iterator it &#x3D; aw.begin(); it !&#x3D; aw.end(); it++) &#123;</span><br><span class="line">					ans.insert(*it);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				for (set&lt;node&gt;::iterator it &#x3D; aw.begin(); it !&#x3D; aw.end(); it++)</span><br><span class="line">					ans.insert(*it);</span><br><span class="line">				for (set&lt;node&gt;::iterator id &#x3D; bw.begin(); id !&#x3D; bw.end(); id++)</span><br><span class="line">					ans.insert(*id);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (ans.empty()) &#123;</span><br><span class="line">				cout &lt;&lt; &quot;Sorry, I found nothing.&quot; &lt;&lt; endl &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			int k &#x3D; ans.begin()-&gt;p;</span><br><span class="line">			for (set&lt;node&gt;::iterator it &#x3D; ans.begin(); it !&#x3D; ans.end(); it++)</span><br><span class="line">			&#123;</span><br><span class="line">				int p &#x3D; (*it).p;</span><br><span class="line">				int r &#x3D; (*it).r;</span><br><span class="line">				if (k !&#x3D; p) &#123;</span><br><span class="line">					cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;</span><br><span class="line">					k &#x3D; p;</span><br><span class="line">				&#125;</span><br><span class="line">				cout &lt;&lt; txt[p][r] &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else if (s[0]&#x3D;&#x3D;&#39;N&#39;) &#123;</span><br><span class="line">			string no &#x3D; s.substr(4);</span><br><span class="line">			&#x2F;&#x2F;cout &lt;&lt; no &lt;&lt; endl;</span><br><span class="line">			bool flag &#x3D; false;</span><br><span class="line">			bool first &#x3D; true;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">				if (!which_pa[no].count(i)) &#123;</span><br><span class="line">					if (first) first &#x3D; false; else cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;</span><br><span class="line">					for (int j &#x3D; 0; j &lt; txt[i].size(); j++)</span><br><span class="line">						cout &lt;&lt; txt[i][j] &lt;&lt; endl;</span><br><span class="line">					flag &#x3D; true;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (flag) cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">			else cout &lt;&lt; &quot;Sorry, I found nothing.&quot; &lt;&lt; endl &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			&#x2F;&#x2F;cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">			if (!words_in_where.count(s)) &#123;</span><br><span class="line">				cout &lt;&lt; &quot;Sorry, I found nothing.&quot; &lt;&lt; endl &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;##    ##  </span><br><span class="line">			int k &#x3D; words_in_where[s].begin()-&gt;p;</span><br><span class="line">			for (set&lt;node&gt;::iterator it &#x3D; words_in_where[s].begin(); it !&#x3D; words_in_where[s].end(); it++) &#123;</span><br><span class="line">				int p &#x3D; (*it).p;</span><br><span class="line">				int r &#x3D; (*it).r;</span><br><span class="line">				if (k !&#x3D; p) &#123;</span><br><span class="line">					cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;</span><br><span class="line">					k &#x3D; p;</span><br><span class="line">				&#125;</span><br><span class="line">				cout &lt;&lt; txt[p][r] &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;if (first) cout &lt;&lt; &quot;Sorry, I found nothing.&quot; &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>埃及分数</title>
    <url>/2020/03/30/%E5%9F%83%E5%8F%8A%E5%88%86%E6%95%B0/</url>
    <content><![CDATA[<h1 id="uva-12258-埃及分数"><a class="markdownIt-Anchor" href="#uva-12258-埃及分数"></a> UVA 12258 埃及分数</h1>
<p>输入出a,b,k，然后输入k个数，要求这k个数不出现在结果中。埃及分数是将任何一个分数a/b，转换成1/x1+1/x2+1/x3…的形式。好的解应该是项数最少的，对于相同项数的解，最小的分数值越大越好。</p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<ol>
<li>由于本题中深度没有上限，而且加数的选择也没有上届，因此如果用广度有限遍历，可能连一层都遍历不完。</li>
<li>使用迭代加深度搜索解决。不断枚举深度的上限maxd，每次搜索深度不超过maxd的节点。<strong>这样只要解的深度有限，那么一定可以在有限的时间内枚举得到</strong>；</li>
<li>关于剪枝：本题中，如果剩余的maxd-d+1项都是1/i，但是和仍然小于目标a/b，那么说明项数不够，则不需要继续递归下去。</li>
<li>关于约分：使用到gcd算法，求出g = gcd(a,b)，那么a/b 可以转换成(a/g)/(b/g)；</li>
<li>关于inline:使用inline之后，时间从2290减到1380。不能使用inline的情况包括
<ol>
<li>不适用于包含复杂控制语句的函数</li>
<li>不适用于直接递归函数</li>
</ol>
</li>
</ol>
<p><strong>但是是否真的设置为内联，由编译器决定</strong></p>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<h3 id="dfs-深度搜索"><a class="markdownIt-Anchor" href="#dfs-深度搜索"></a> dfs 深度搜索</h3>
<pre><code>bool dfs(int d, LL from, LL a, LL b) {
if (d == maxd) {
	if (b%a || avoid.count(b / a)) return false;

	v[d] = b / a;
	if (better(d)) memcpy(ans, v, sizeof(LL)*(d + 1)); //0~d
	return true;
}
bool ok = false;
from = max(from, get_first(a, b));
for (LL i = from;; i++) {
	if (b*(maxd - d + 1) &lt;= a * i) break;
	//如果a/b &gt;= (maxd-d+1)*/(1/i)，则剪枝
	if (avoid.count(i)) continue;
	v[d] = i;

	//这一部分目的是计算a/b-1/i
	LL a2 = a * i - b;
	LL b2 = b * i;
	LL g = gcd(a, b);
	if (dfs(d + 1, i + 1, a2 / g, b2 / g)) ok = true;
}
return ok;
</code></pre>
<h3 id="比较函数"><a class="markdownIt-Anchor" href="#比较函数"></a> 比较函数</h3>
<pre><code>inline bool better(int d) {
for (int i = d; i &gt;= 0; i--) {
	if (ans[i] != v[i])
		return ans[i] == -1 || ans[i] &gt; v[i];
}
return false;
}
</code></pre>
<ol>
<li>要求最小的分数值越大越好，即是要求分母最大的数越小越好。所以从i=d开始比较。</li>
</ol>
<h3 id="gcd-固定的"><a class="markdownIt-Anchor" href="#gcd-固定的"></a> gcd 固定的</h3>
<pre><code>inline LL gcd(LL a, LL b) {
if (b == 0) return a;
return gcd(b, a%b);
}
</code></pre>
<h3 id="get_first-返回1从ab的最小的"><a class="markdownIt-Anchor" href="#get_first-返回1从ab的最小的"></a> get_first 返回1/从&lt;=a/b的最小的</h3>
<pre><code>inline LL get_first(LL a, LL b) 
{ return b / a + 1; }
</code></pre>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>天平难题</title>
    <url>/2020/03/30/%E5%A4%A9%E5%B9%B3%E9%9A%BE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="uva-1354-天平难题"><a class="markdownIt-Anchor" href="#uva-1354-天平难题"></a> UVA 1354 <a href="%22https://www.luogu.com.cn/problem/UVA1354%22">天平难题</a></h1>
<p>给出房间宽度r和s个吊坠的重量wi。设计一个尽量宽（不超过r)的天平，挂着所有挂坠。 天平由一些长度为1的木棍组成。木棍的每一端要么挂一个挂坠，要么挂另外一个木棍。设n和m分别是两端挂的总重量，a和b为两端长度，要让天平平衡，必须满足na=mb。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<p>回溯法加暴搜，通过枚举二叉树来求解，<strong>其中天平力矩平衡的条件用来计算偏移量</strong>。</p>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="dfs函数"><a class="markdownIt-Anchor" href="#dfs函数"></a> DFS函数</h2>
<p>用来遍历解答树，同时进行剪枝。只有当可扩展位置和剩余挂坠全部刚好同时用尽，才说明是一个可能的解，对于其他的情况需要进行剪枝。对于枚举二叉树中的每个节点，可能的情况又分成两种，一种是在该节点(step)处放一个木棍，那么可放置挂坠的节点数+1(别忘了回溯);另一种是在该节点处放置一个挂坠，那么可放置挂坠的位置-1，同时剩余挂坠-1(也要回溯)</p>
<pre><code>void dfs(int step, int leaf, int node) {
if (!node &amp;&amp; !leaf) {
	update(step - 1);
	return;
}
if ((!node&amp;&amp;leaf) || (node &amp;&amp; !leaf)) {
	return;
}
if (tree[step / 2] != -1) {
	dfs(step + 1, leaf, node);
	return;
}
if (leaf &lt; node) {
	tree[step] = -1;
	dfs(step + 1, leaf + 1, node);
	tree[step] = 0;
}
for (int i = 1; i &lt;= s; i++) {
	if (!vis[i]) {
		vis[i] = 1;
		tree[step] = i;

		dfs(step + 1, leaf - 1, node - 1);

		vis[i] = 0;
		tree[step] = 0;
	}
}

}
</code></pre>
<h2 id="update函数"><a class="markdownIt-Anchor" href="#update函数"></a> update函数</h2>
<p>在枚举出一种二叉树之后，要计算他的宽度并和目前的最优解比较。这里首先使用一个val数组来记录各个节点处的权重：</p>
<ol>
<li>如果是木棍，那么他的重量等于他的两个子节点之和；</li>
<li>如果是挂坠，那么重量就是该挂坠的重量。</li>
</ol>
<p>之后使用findedge函数计算宽度。</p>
<pre><code>void update(int num) {
memset(val, 0, sizeof(val));
for (int i = num; i &gt;= 1; i--) {
	if (tree[i] &lt; 0) val[i] = val[i * 2] + val[i * 2 + 1];
	else if(tree[i]&gt;0) val[i] = w[tree[i]];
}
left = DBL_MAX;
right = DBL_MIN;

findedge(double(0), 1);
double fin = right - left;
if (fin &lt; r) {
	ans = max(ans, fin);
}

}
</code></pre>
<h2 id="findedge函数"><a class="markdownIt-Anchor" href="#findedge函数"></a> findedge函数</h2>
<p>利用天平平衡，力矩为0计算宽度。nl * a = nr * b。如果该节点是一个木棍，那么需要计算他的子节点的偏移量，过程与前面一样，所以整体上构成了一个递归的结构。</p>
<pre><code>void findedge(double mid, int cur) {
int a = cur * 2;
int b = cur * 2 + 1;
double nl = mid - ((double)val[b] / (val[a] + val[b]));
double nr = mid + ((double)val[a] / (val[a] + val[b]));

left = min(left, nl);
right = max(right, nr);

if (tree[cur] &lt; 0) {
	findedge(nl, a);
	findedge(nr, b);
}
</code></pre>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>多米诺效应</title>
    <url>/2020/03/30/%E5%A4%9A%E7%B1%B3%E8%AF%BA%E6%95%88%E5%BA%94/</url>
    <content><![CDATA[<h1 id="uva-211-多米诺效应"><a class="markdownIt-Anchor" href="#uva-211-多米诺效应"></a> UVA 211 多米诺效应</h1>
<p><img src="/%E8%AE%A1%E5%AE%89%E5%AF%BC_img/2.png" alt="" /></p>
<p><img src="/%E8%AE%A1%E5%AE%89%E5%AF%BC_img/3.png" alt="" /></p>
<p><img src="/%E8%AE%A1%E5%AE%89%E5%AF%BC_img/4.png" alt="" /></p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>题干可以理解为有28个1<em>2的色块，先要拼成一个7</em>8的矩形。问有多少种方案</li>
<li>大体框架一定是深搜了。问题在于如果本题中的跨度为2。如果按照可以构成骨牌步长为2来走，可能导致中空，那么递归不会执行递归头的期望结束点。</li>
<li>改为步长为1，且认为规定图像的填充沿着右下方向延伸。所以dx，dy只需要两个方向。</li>
<li>应该注意的点还是基本问题，比如越界判定，访问标志的置位与清零等等。</li>
<li>本题的输出格式要求尤为恶心</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="dfs-部分"><a class="markdownIt-Anchor" href="#dfs-部分"></a> dfs 部分</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void dfs(int x, int y, int step) &#123;</span><br><span class="line">int newx, newy, now;</span><br><span class="line">if (step &#x3D;&#x3D; cnt) &#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; maxr; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; maxc; j++)</span><br><span class="line">			printf(ans[i][j] &lt; 10 ? &quot;   %d&quot; : &quot;  %d&quot;, ans[i][j]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	tot++;</span><br><span class="line">	printf(&quot;\n\n&quot;);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (y &#x3D;&#x3D; maxc) &#123; x++; y &#x3D; 0; &#125;</span><br><span class="line">if (vis[x][y]) dfs(x, y + 1, step);</span><br><span class="line">else &#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 2; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		newx &#x3D; x + dx[i];</span><br><span class="line">		newy &#x3D; y + dy[i];</span><br><span class="line"></span><br><span class="line">		if (newx &lt; 0 || newy &lt; 0 || newx &gt;&#x3D; maxr || newy &gt;&#x3D; maxc || vis[newx][newy])</span><br><span class="line">			continue;</span><br><span class="line">		now &#x3D; max(id[in[x][y]][in[newx][newy]], id[in[newx][newy]][in[x][y]]);</span><br><span class="line">		if (now)</span><br><span class="line">		&#123;</span><br><span class="line">			if (used[now]) continue;</span><br><span class="line"></span><br><span class="line">			ans[x][y] &#x3D; ans[newx][newy] &#x3D; now;</span><br><span class="line">			vis[newx][newy] &#x3D; 1;</span><br><span class="line">			used[now] &#x3D; 1;</span><br><span class="line"></span><br><span class="line">			dfs(x, y + 1, step + 1);</span><br><span class="line"></span><br><span class="line">			ans[x][y] &#x3D; ans[newx][newy] &#x3D; 0;</span><br><span class="line">			vis[x][y] &#x3D; vis[newx][newy] &#x3D; 0;</span><br><span class="line">			used[now] &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxr &#x3D; 7;</span><br><span class="line">const int maxc &#x3D; 8;</span><br><span class="line">int tot;</span><br><span class="line">int id[maxr][maxc];</span><br><span class="line">int ans[maxr][maxc];</span><br><span class="line">int vis[maxr][maxc];</span><br><span class="line">int in[maxr][maxc];</span><br><span class="line">int cnt;</span><br><span class="line">int used[29];</span><br><span class="line">const int dx[] &#x3D; &#123; 1,0 &#125;;</span><br><span class="line">const int dy[] &#x3D; &#123; 0,1 &#125;;</span><br><span class="line">void dfs(int x, int y, int step);</span><br><span class="line">void dfs(int x, int y);</span><br><span class="line">int main() &#123;</span><br><span class="line">int kase &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 7; i++)</span><br><span class="line">	for (int j &#x3D; i; j &lt; 7; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		id[i][j] &#x3D; ++cnt;</span><br><span class="line">	&#125;</span><br><span class="line">while (1) &#123;</span><br><span class="line"></span><br><span class="line">	tot &#x3D; 0;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	memset(used, 0, sizeof(used));</span><br><span class="line">	for (int i &#x3D; 0; i &lt; maxr; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; maxc; j++) &#123;</span><br><span class="line">			if (scanf(&quot;%d&quot;, &amp;in[i][j]) !&#x3D; 1)</span><br><span class="line">				return 0;</span><br><span class="line">		&#125;</span><br><span class="line">		scanf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if (kase) printf(&quot;\n\n\n\n\n&quot;);</span><br><span class="line">	printf(&quot;Layout #%d:\n\n\n&quot;, ++kase);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; maxr; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; maxc; j++) &#123;</span><br><span class="line">			printf(&quot;   %d&quot;, in[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">	printf(&quot;Maps resulting from layout #%d are:\n\n\n&quot;, kase);</span><br><span class="line">	dfs(0, 0, 0);</span><br><span class="line">	printf(&quot;There are %d solution(s) for layout #%d.\n&quot;, tot, kase);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>基础知识汇总</title>
    <url>/2020/06/20/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> <a href="/2020/06/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></h2>
<h2 id="数据库系统"><a class="markdownIt-Anchor" href="#数据库系统"></a> <a href="/2020/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/">数据库系统</a></h2>
<h2 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> <a href="/2020/06/20/%E7%AE%97%E6%B3%95/">算法</a></h2>
<h2 id="计算机组成原理"><a class="markdownIt-Anchor" href="#计算机组成原理"></a> <a href="/2020/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></h2>
<h2 id="计算机网络"><a class="markdownIt-Anchor" href="#计算机网络"></a> <a href="/2020/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></h2>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>基础相关</title>
    <url>/2020/03/30/%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="日期类"><a class="markdownIt-Anchor" href="#日期类"></a> 日期类</h1>
<h2 id="date"><a class="markdownIt-Anchor" href="#date"></a> Date</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const static int Month[13][2] &#x3D; &#123;</span><br><span class="line">	&#123;0,0&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;28,29&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;30,30&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;30,30&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;30,30&#125;,</span><br><span class="line">	&#123;31,31&#125;,</span><br><span class="line">	&#123;30,30&#125;,</span><br><span class="line">	&#123;31,31&#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct  Date</span><br><span class="line">&#123;</span><br><span class="line">	int year;</span><br><span class="line">	int month;</span><br><span class="line">	int day;</span><br><span class="line"></span><br><span class="line">	Date(int d, int m, int y) :year(y), day(d), month(m) &#123;&#125;;</span><br><span class="line">	bool isLeap(int year) &#123;</span><br><span class="line">		return year % 100 !&#x3D; 0 &amp;&amp; year % 4 &#x3D;&#x3D; 0 || year % 400 &#x3D;&#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void nextDay() &#123;</span><br><span class="line">		day++;</span><br><span class="line">		if (day &gt; Month[month][isLeap(year)]) &#123;</span><br><span class="line">			day &#x3D; 1;</span><br><span class="line">			month++;</span><br><span class="line">			if (month &gt; 12) &#123;</span><br><span class="line">				month &#x3D; 1;</span><br><span class="line">				year++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="打表"><a class="markdownIt-Anchor" href="#打表"></a> 打表</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int cnt &#x3D; 0;</span><br><span class="line">	Date tmp(1,1,0) ;</span><br><span class="line">	while (tmp.year&lt;&#x3D;5000)</span><br><span class="line">	&#123;</span><br><span class="line">		buf[tmp.year][tmp.month][tmp.day]  &#x3D; cnt;</span><br><span class="line">		tmp.nextDay();</span><br><span class="line">		cnt++;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求两个日期间隔多少天-日期差值"><a class="markdownIt-Anchor" href="#求两个日期间隔多少天-日期差值"></a> 求两个日期间隔多少天 日期差值</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	</span><br><span class="line">	int y1, m1, d1;</span><br><span class="line">	int y2, m2, d2;</span><br><span class="line">	while (scanf(&quot;%4d %2d %2d&quot;,&amp;y1,&amp;m1,&amp;d1))</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%4d %2d %2d&quot;, &amp;y2, &amp;m2, &amp;d2);</span><br><span class="line">		printf(&quot;%d\n&quot;, abs(buf[y1][m1][d1] - buf[y2][m2][d2])+1);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>注意输入%xd的方法。+1别忘了</li>
<li>将输入日期统一到0年1月1日为起点</li>
</ol>
<h3 id="求给定日期是星期几-day-of-week"><a class="markdownIt-Anchor" href="#求给定日期是星期几-day-of-week"></a> 求给定日期是星期几 Day of Week</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const static char NMonth[13][20] &#x3D; &#123;</span><br><span class="line">	&quot;&quot;,</span><br><span class="line">	&quot;January&quot;,</span><br><span class="line">	&quot;February&quot;,</span><br><span class="line">	&quot;March&quot;,</span><br><span class="line">	&quot;April&quot;,</span><br><span class="line">	&quot;May&quot;,</span><br><span class="line">	&quot;June&quot;,</span><br><span class="line">	&quot;July&quot;,</span><br><span class="line">	&quot;August&quot;,</span><br><span class="line">	&quot;September&quot;,</span><br><span class="line">	&quot;October&quot;,</span><br><span class="line">	&quot;November&quot;,</span><br><span class="line">	&quot;December&quot;</span><br><span class="line">&#125;;</span><br><span class="line">const static char week[7][20] &#x3D; &#123;</span><br><span class="line">	&quot;Sunday&quot;,</span><br><span class="line">	&quot;Monday&quot;,</span><br><span class="line">	&quot;Tuesday&quot;,</span><br><span class="line">	&quot;Wednesday&quot;,</span><br><span class="line">	&quot;Thursday&quot;,</span><br><span class="line">	&quot;Friday&quot;,</span><br><span class="line">	&quot;Saturday&quot;</span><br><span class="line">&#125;;</span><br><span class="line">int y, d;</span><br><span class="line">char month[20];</span><br><span class="line">while (scanf(&quot;%d%s%4d&quot;, &amp;d, month, &amp;y) !&#x3D; EOF)</span><br><span class="line">&#123;</span><br><span class="line">	int m;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; 12; i++)</span><br><span class="line">		if (!strcmp(month, NMonth[i])) &#123;</span><br><span class="line">			m &#x3D; i;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	int days &#x3D; buf[y][m][d] - buf[2020][2][5];</span><br><span class="line">	days +&#x3D; 3;</span><br><span class="line">	printf(&quot;%s\n&quot;, week[(days % 7 + 7) % 7]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure>
<ol>
<li>也是将输入日期统一到0年1月1日为起点</li>
<li>然后计算与今天的差，</li>
</ol>
<h1 id="hash"><a class="markdownIt-Anchor" href="#hash"></a> Hash</h1>
<h2 id="输出前m大的数"><a class="markdownIt-Anchor" href="#输出前m大的数"></a> 输出前m大的数</h2>
<p>将数值看成数组下标，从数组尾部开始输出m个存在的数字。</p>
<h2 id="其他使用"><a class="markdownIt-Anchor" href="#其他使用"></a> 其他使用</h2>
<ol>
<li>主要是记录每个数字出现的次数的思想</li>
</ol>
<h1 id="排版题"><a class="markdownIt-Anchor" href="#排版题"></a> 排版题</h1>
<h2 id="输出梯形"><a class="markdownIt-Anchor" href="#输出梯形"></a> 输出梯形</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">#pragma warning(disable:4996)</span><br><span class="line">const int maxn &#x3D; 1005;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">	&#123;</span><br><span class="line">		int m &#x3D; n + 2 * (n - 1);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; m-n-2*i; j++) &#123;</span><br><span class="line">				printf(&quot; &quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; n+i*2; j++) &#123;</span><br><span class="line">				printf(&quot;*&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="叠筐-hdu2074"><a class="markdownIt-Anchor" href="#叠筐-hdu2074"></a> 叠筐 HDU2074</h2>
<p>需要的时候，就把一个个大小差一圈的筐叠上去，使得从上往下看时，边筐花色交错。这个工作现在要让计算机来完成，得看你的了。<br />
输入是一个个的三元组，分别是，外筐尺寸n（n为满足0&lt;n&lt;80的奇整数），中心花色字符，外筐花色字符，后二者都为ASCII可见字符；<br />
输出叠在一起的筐图案，中心花色与外筐花色字符从内层起交错相叠，多筐相叠时，最外筐的角总是被打磨掉。叠筐与叠筐之间应有一行间隔。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 80 + 5;</span><br><span class="line">char g[maxn][maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	char a, b;</span><br><span class="line">	int first &#x3D; 1;</span><br><span class="line">	while (scanf(&quot;%d %c %c\n&quot;, &amp;n, &amp;b, &amp;a) &#x3D;&#x3D; 3)</span><br><span class="line">	&#123;</span><br><span class="line">		if (((n - 1) &#x2F; 2) % 2 &#x3D;&#x3D; 0) std::swap(a, b);</span><br><span class="line">		memset(g, b, sizeof(g));</span><br><span class="line">		if (first) first &#x3D; 0;</span><br><span class="line">		else printf(&quot;\n&quot;);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i +&#x3D; 2) &#123;</span><br><span class="line">			for (int j &#x3D; i; j &lt; n - 2 * i + i; j++) &#123;</span><br><span class="line">				g[i][j] &#x3D; g[n - i - 1][j] &#x3D; a;</span><br><span class="line">				g[j][i] &#x3D; g[j][n - i - 1] &#x3D; a;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (n !&#x3D; 1)</span><br><span class="line">			g[0][0] &#x3D; g[0][n - 1] &#x3D; g[n - 1][0] &#x3D; g[n - 1][n - 1] &#x3D; &#39; &#39;;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">				printf(&quot;%c&quot;, g[i][j]);</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="repeater"><a class="markdownIt-Anchor" href="#repeater"></a> Repeater</h2>
<p>Harmony is indispensible in our daily life and no one can live without it----may be Facer is the only exception. One day it is rumored that repeat painting will create harmony and then hundreds of people started their endless drawing. Their paintings were based on a small template and a simple method of duplicating. Though Facer can easily imagine the style of the whole picture, but he cannot find the essential harmony. Now you need to help Facer by showing the picture on computer. You will be given a template containing only one kind of character and spaces, and the template shows how the endless picture is created----use the characters as basic elements and put them in the right position to form a bigger template, and then repeat and repeat doing that. Here is an example. # #  #      &lt;-template # # So the Level 1 picture will be # #  # # # Level 2 picture will be # #     # #  #         # # #     # #      # #         #         # #   # #    # #  #        # # #    # #</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 3000 + 5;</span><br><span class="line">char g[maxn][maxn];</span><br><span class="line">char tmp[maxn][maxn];</span><br><span class="line">char tmp2[maxn][maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int p, q;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;p) &#x3D;&#x3D; 1 &amp;&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		getchar();</span><br><span class="line">		memset(g, &#39; &#39;, sizeof(g));</span><br><span class="line">		for (int i &#x3D; 0; i &lt; p; i++)</span><br><span class="line">			std::cin.getline(g[i], 6);</span><br><span class="line"></span><br><span class="line">		scanf(&quot;%d&quot;, &amp;q);</span><br><span class="line"></span><br><span class="line">		memcpy(tmp, g, sizeof(g));</span><br><span class="line">		if (q !&#x3D; 1)</span><br><span class="line">			for (int scale &#x3D; 2; scale &lt;&#x3D; q; scale++) &#123;&#x2F;&#x2F;代</span><br><span class="line">				memset(tmp2, &#39; &#39;, sizeof(tmp2));</span><br><span class="line">				int r , c ;</span><br><span class="line">				int oldr, oldc;</span><br><span class="line">				oldr &#x3D; oldc &#x3D; pow(p, scale - 1);</span><br><span class="line">				for (int i &#x3D; 0; i &lt; p; i++) &#123;</span><br><span class="line">					for (int j &#x3D; 0; j &lt; p; j++) &#123;&#x2F;&#x2F;初代模板</span><br><span class="line">						r &#x3D; i * oldr;</span><br><span class="line">						c &#x3D; j * oldc;</span><br><span class="line">						if (g[i][j] !&#x3D; &#39; &#39;) &#123;</span><br><span class="line">							for (int k &#x3D; 0; k &lt; oldr; k++) &#123;&#x2F;&#x2F;在元素处复制模板</span><br><span class="line">								for (int f &#x3D; 0; f &lt; oldc; f++)</span><br><span class="line">									tmp2[r + k][c + f] &#x3D; tmp[k][f];</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				memcpy(tmp, tmp2,sizeof(tmp2));</span><br><span class="line">			&#125;</span><br><span class="line">		for (int k &#x3D; 0; k &lt; pow(p, q); k++) &#123;</span><br><span class="line">			for (int f &#x3D; 0; f &lt; pow(p, q); f++) &#123;</span><br><span class="line"></span><br><span class="line">				printf(&quot;%c&quot;, tmp[k][f]);</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h1>
<h2 id="查找学生信息-二分查找"><a class="markdownIt-Anchor" href="#查找学生信息-二分查找"></a> 查找学生信息 二分查找</h2>
<p>输入N个学生的信息，然后进行查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">	int no;</span><br><span class="line">	string name;</span><br><span class="line">	string sex;</span><br><span class="line">	int age;</span><br><span class="line">	node() &#123;&#125;;</span><br><span class="line">	node(int no, string name, string sex, int age)</span><br><span class="line">		:no(no), name(name), sex(sex), age(age) &#123;&#125;;</span><br><span class="line">	bool operator &lt; (const node &amp;a) const &#123;</span><br><span class="line">		return no &lt; a.no;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">node stu[maxn];</span><br><span class="line">int bsearch(int l, int r, int q) &#123;</span><br><span class="line">	while (l &lt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		int m &#x3D; l + (r - l) &#x2F; 2;</span><br><span class="line">		if (stu[m].no &#x3D;&#x3D; q) return m;</span><br><span class="line">		else if (stu[m].no &gt; q) r &#x3D; m;</span><br><span class="line">		else l &#x3D; m + 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (cin&gt;&gt;n&amp;&amp;n) &#123;</span><br><span class="line">		string  b, c;</span><br><span class="line">		int a,d;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">			stu[i] &#x3D; node(a, b, c, d);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(stu, stu + n);</span><br><span class="line">		int m;</span><br><span class="line">		cin &gt;&gt; m;</span><br><span class="line">		int que;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			cin &gt;&gt; que;</span><br><span class="line">			int ans &#x3D; bsearch(0, n, que);</span><br><span class="line">			ans !&#x3D; -1 ? cout &lt;&lt; stu[ans].no&lt;&lt;&quot; &quot;&lt;&lt;stu[ans].name&lt;&lt;&quot; &quot;&lt;&lt;stu[ans].sex&lt;&lt;&quot; &quot;&lt;&lt;stu[ans].age &lt;&lt; endl </span><br><span class="line">				: cout &lt;&lt; &quot;No Answer!&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="打印极值点下标"><a class="markdownIt-Anchor" href="#打印极值点下标"></a> 打印极值点下标</h2>
<p>在一个整数数组上，对于下标为i的整数，如果它大于所有它相邻的整数， 或者小于所有它相邻的整数，则称为该整数为一个极值点，极值点的下标就是i。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 80 + 5;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line"></span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n)&#x3D;&#x3D;1&amp;&amp;n)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		int x;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		if (n &gt; 2) &#123;</span><br><span class="line">			if (a[2] &gt; a[1]) a[0] &#x3D; a[1] + 1;</span><br><span class="line">			else if(a[2] &lt; a[1]) a[0] &#x3D; a[1] - 1;</span><br><span class="line">			else a[0] &#x3D; a[1];</span><br><span class="line">		&#125;</span><br><span class="line">		if (a[n - 1] &lt; a[n]) a[n + 1] &#x3D; a[n] - 1;</span><br><span class="line">		else if (a[n - 1] &gt; a[n]) a[n + 1] &#x3D; a[n] + 1;</span><br><span class="line">		else a[n + 1] &#x3D; a[n];</span><br><span class="line"></span><br><span class="line">		int first &#x3D; 1;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			int x &#x3D; a[i] - a[i - 1];</span><br><span class="line">			int y &#x3D; a[i] - a[i + 1];</span><br><span class="line">			</span><br><span class="line">			if (x*y &gt; 0) &#123;</span><br><span class="line">				if (first) first &#x3D; 0;</span><br><span class="line">				else printf(&quot; &quot;);</span><br><span class="line">				printf(&quot;%d&quot;, i-1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找-2"><a class="markdownIt-Anchor" href="#查找-2"></a> 查找</h2>
<p>读入一组字符串（待操作的），再读入一个int n记录记下来有几条命令，总共有2中命令：1、翻转  从下标为i的字符开始到i+len-1之间的字符串倒序；2、替换  命中如果第一位为1，用命令的第四位开始到最后的字符串替换原读入的字符串下标 i 到 i+len-1的字符串。每次执行一条命令后新的字符串代替旧的字符串（即下一条命令在作用在得到的新字符串上）。     命令格式：第一位0代表翻转，1代表替换；第二位代表待操作的字符串的起始下标int i；第三位表示需要操作的字符串长度int len。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">char s[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%s&quot;,s)&#x3D;&#x3D;1)</span><br><span class="line">	&#123;</span><br><span class="line">		int n;</span><br><span class="line">		int first &#x3D; 1;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		int op, index, len;</span><br><span class="line">		char ex[maxn];</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%1d%1d%1d&quot;, &amp;op, &amp;index, &amp;len);</span><br><span class="line">			if (op) scanf(&quot;%s&quot;,ex);</span><br><span class="line">			if (op &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				for (int j &#x3D; 0; 2*j &lt; len; j++) &#123;</span><br><span class="line">					swap(s[index + j], s[index + len - j-1]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				char tmp[maxn]&#123;&#39;\0&#39;&#125;;</span><br><span class="line">				for (int j &#x3D; 0; j &lt; index; j++) tmp[j] &#x3D; s[j];</span><br><span class="line">				for (int j &#x3D; 0; j &lt; strlen(ex); j++)</span><br><span class="line">					tmp[j + index] &#x3D; ex[j];</span><br><span class="line">				for (int j &#x3D; index; j &lt; strlen(s); j++)</span><br><span class="line">					tmp[j+strlen(ex)] &#x3D; s[j+len];</span><br><span class="line"></span><br><span class="line">				memcpy(s, tmp, sizeof(tmp));</span><br><span class="line">			&#125;</span><br><span class="line">			if (first) first &#x3D; 0;</span><br><span class="line">			else printf(&quot;\n&quot;);</span><br><span class="line">			printf(&quot;%s&quot;, s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="贪心算法"><a class="markdownIt-Anchor" href="#贪心算法"></a> 贪心算法</h1>
<h2 id="fatmouses-trade"><a class="markdownIt-Anchor" href="#fatmouses-trade"></a> FatMouse’s Trade</h2>
<p>FatMouse prepared M pounds of cat food, ready to trade with the cats guarding the warehouse containing his favorite food, JavaBean.<br />
The warehouse has N rooms. The i-th room contains J[i] pounds of JavaBeans and requires F[i] pounds of cat food. FatMouse does not have to trade for all the JavaBeans in the room, instead, he may get J[i]* a% pounds of JavaBeans if he pays F[i]* a% pounds of cat food. Here a is a real number. Now he is assigning this homework to you: tell him the maximum amount of JavaBeans he can obtain.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int j;</span><br><span class="line">	int f;</span><br><span class="line">	double v;</span><br><span class="line">	bool operator &lt;(const node &amp;a) const &#123; return v &lt; a.v; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node a[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int m, n;</span><br><span class="line">	int j, f;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;m, &amp;n) &amp;&amp; m !&#x3D; -1 &amp;&amp; n !&#x3D; -1) &#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;j, &amp;f);</span><br><span class="line">			a[i].f &#x3D; f;</span><br><span class="line">			a[i].j &#x3D; j;</span><br><span class="line">			a[i].v &#x3D; double(j) &#x2F; f;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a, a + n);</span><br><span class="line">		double ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			if (m &gt; a[i].f) &#123;</span><br><span class="line">				m -&#x3D; a[i].f;</span><br><span class="line">				ans +&#x3D; a[i].j;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				ans +&#x3D; double(m) * a[i].j &#x2F; a[i].f;</span><br><span class="line">				m &#x3D; 0;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (m &lt;&#x3D; 0) break;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%.3f\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择不连续区间问题"><a class="markdownIt-Anchor" href="#选择不连续区间问题"></a> 选择不连续区间问题</h2>
<h2 id="迷瘴"><a class="markdownIt-Anchor" href="#迷瘴"></a> 迷瘴</h2>
<p>通过悬崖的yifenfei，又面临着幽谷的考验——<br />
幽谷周围瘴气弥漫，静的可怕，隐约可见地上堆满了骷髅。由于此处长年不见天日，导致空气中布满了毒素，一旦吸入体内，便会全身溃烂而死。<br />
幸好yifenfei早有防备，提前备好了解药材料（各种浓度的万能药水）。现在只需按照配置成不同比例的浓度。<br />
现已知yifenfei随身携带有n种浓度的万能药水，体积V都相同，浓度则分别为Pi%。并且知道，针对当时幽谷的瘴气情况，只需选择部分或者全部的万能药水，然后配置出浓度不大于 W%的药水即可解毒。<br />
现在的问题是：如何配置此药，能得到最大体积的当前可用的解药呢？<br />
特别说明：由于幽谷内设备的限制,只允许把一种已有的药全部混入另一种之中（即：不能出现对一种药只取它的一部分这样的操作）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">int a[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	int n, v, w;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, &amp;n, &amp;v, &amp;w);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a, a + n);</span><br><span class="line"></span><br><span class="line">		double nw &#x3D; 0;</span><br><span class="line">		int nv &#x3D; 0;</span><br><span class="line">		double tmp;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			tmp &#x3D; (nw  * nv + a[i] * v) &#x2F; (v + nv);</span><br><span class="line">			if (tmp &lt;&#x3D; w) &#123;</span><br><span class="line">				nw &#x3D; tmp;</span><br><span class="line">				nv +&#x3D; v;</span><br><span class="line">			&#125;</span><br><span class="line">			else break;</span><br><span class="line">		&#125;</span><br><span class="line">		if(nv&#x3D;&#x3D;0)</span><br><span class="line">			printf(&quot;0 0.00\n&quot;);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot;%d %.2lf\n&quot;, nv, nw&#x2F;100);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>我的实现全部使用整型避免了浮点数误差。关于<a href="https://www.cnblogs.com/crazyacking/p/4668471.html" target="_blank" rel="noopener">浮点数误差</a></li>
</ol>
<h2 id="to-fill-or-not-to-fill"><a class="markdownIt-Anchor" href="#to-fill-or-not-to-fill"></a> To Fill or Not to Fill</h2>
<p>With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go.</p>
<p>For each case, the first line contains 4 positive numbers: Cmax (&lt;= 100), the maximum capacity of the tank; D (&lt;=30000), the distance between Hangzhou and the destination city; Davg (&lt;=20), the average distance per unit gas that the car can run; and N (&lt;= 500), the total number of gas stations. Then N lines follow, each contains a pair of non-negative numbers: Pi, the unit gas price, and Di (&lt;=D), the distance between this station and Hangzhou, for i=1,…N. All the numbers in a line are separated by a space.</p>
<p>For each test case, print the cheapest price in a line, accurate up to 2 decimal places. It is assumed that the tank is empty at the beginning. If it is impossible to reach the destination, print “The maximum travel distance = X” where X is the maximum possible distance the car can run, accurate up to 2 decimal places.</p>
<h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3>
<ol>
<li>
<p>在每一站处，查找能到达的站中油价比当前站便宜的站。如果没有，则找一个相对最便宜的。</p>
<ol>
<li>如果找到了比当前站便宜的，那么在本站只需要加油到刚好到达最便宜的站。</li>
<li>如果没有比当前更便宜的，那么把油箱加满，并直接开到这个相对最便宜的站。</li>
</ol>
</li>
<li>
<p>如果在当前的站处能够到达的最大范围内都没有站</p>
<ol>
<li>如果能到达终点，那么输出总价</li>
<li>否则计算出走的最大长度，加上当前站的位置即为最大移动距离</li>
</ol>
</li>
<li>
<p>这样保证了每次都是朝着油价最便宜的站进发，同时油箱里的油比沿路的站都便宜。</p>
</li>
</ol>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 500 + 5;</span><br><span class="line">struct node &#123;</span><br><span class="line">	double price;</span><br><span class="line">	double dis;</span><br><span class="line">	bool operator &lt; (const node&amp;a) const &#123;</span><br><span class="line">		return dis &lt; a.dis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int ns &#x3D; 0;</span><br><span class="line"></span><br><span class="line">node a[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	double c, dis, cost;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%lf%lf%lf%d&quot;, &amp;c, &amp;dis, &amp;cost, &amp;n) &#x3D;&#x3D; 4)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			scanf(&quot;%lf%lf&quot;, &amp;a[i].price, &amp;a[i].dis);</span><br><span class="line">		&#x2F;&#x2F;a[n].price &#x3D; 0;</span><br><span class="line">		&#x2F;&#x2F;a[n].dis &#x3D; dis;</span><br><span class="line">		sort(a, a + n);</span><br><span class="line">		double maxd &#x3D; c * cost;</span><br><span class="line">		double nc &#x3D; 0;</span><br><span class="line">		double no &#x3D; 0;</span><br><span class="line">		int ns &#x3D; 0;</span><br><span class="line">		if (dis&#x3D;&#x3D; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;0.00\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		if (a[0].dis !&#x3D; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;The maximum travel distance &#x3D; 0.00\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		while (ns &lt; n) &#123;</span><br><span class="line">			&#x2F;&#x2F;printf(&quot;%d\n&quot;, ns);</span><br><span class="line">			double minc &#x3D; 100000;</span><br><span class="line">			int index;</span><br><span class="line">			bool havenx &#x3D; false;</span><br><span class="line">			bool cheaper &#x3D; false;</span><br><span class="line">			for (int i &#x3D; ns + 1; i &lt; n; i++) &#123;</span><br><span class="line">				if ((a[i].dis - a[ns].dis) &lt;&#x3D; maxd) &#123;&#x2F;&#x2F;有更便宜的</span><br><span class="line">					havenx &#x3D; true;</span><br><span class="line">					if (a[i].price &lt; a[ns].price) &#123;</span><br><span class="line">						cheaper &#x3D; true;</span><br><span class="line">						double d &#x3D; a[i].dis - a[ns].dis;</span><br><span class="line">						nc +&#x3D; a[ns].price*(d &#x2F; cost - no);</span><br><span class="line">						no &#x3D; 0;</span><br><span class="line">						ns &#x3D; i;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					else if (a[i].price &lt; minc) &#123;&#x2F;&#x2F;目前没有更便宜的，则记录一下相对最便宜的</span><br><span class="line">						minc &#x3D; a[i].price;</span><br><span class="line">						index &#x3D; i;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				else break;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (!cheaper &amp;&amp; (maxd &gt;&#x3D; (dis - a[ns].dis))) &#123;</span><br><span class="line">				</span><br><span class="line">				&#x2F;&#x2F;没有更便宜的，但是能直接走到终点，那么直接走</span><br><span class="line">				double d &#x3D; dis - a[ns].dis;</span><br><span class="line">				nc +&#x3D; (d &#x2F; cost - no)*a[ns].price;</span><br><span class="line">				printf(&quot;%.2lf\n&quot;, nc);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			if (!cheaper &amp;&amp; havenx) &#123;</span><br><span class="line">			</span><br><span class="line">				&#x2F;&#x2F;范围内有站，但是没有更便宜的</span><br><span class="line">				nc +&#x3D; (c - no)*a[ns].price;</span><br><span class="line">				double d &#x3D; a[index].dis - a[ns].dis;</span><br><span class="line">				no &#x3D; c - d &#x2F; cost;</span><br><span class="line">				ns &#x3D; index;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (!havenx) &#123;</span><br><span class="line">			</span><br><span class="line">				&#x2F;&#x2F;没有站也到不了终点</span><br><span class="line">				printf(&quot;The maximum travel distance &#x3D; %.2lf\n&quot;,</span><br><span class="line">					a[ns].dis + maxd);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>奇怪的气球膨胀</title>
    <url>/2020/03/30/%E5%A5%87%E6%80%AA%E7%9A%84%E6%B0%94%E7%90%83%E8%86%A8%E8%83%80/</url>
    <content><![CDATA[<h1 id="uva-12627-奇怪的气球膨胀"><a class="markdownIt-Anchor" href="#uva-12627-奇怪的气球膨胀"></a> UVA 12627 奇怪的气球膨胀</h1>
<p>一开始有一个红气球。每小时后,一个红气球会变成3个红气球和一个蓝气球,而一个 蓝气球会变成4个蓝气球。如图，分别是经过0, 1, 2, 3小时后的情况。经过k小时后, 第A~B行一共有多少个红气球?</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<p><img src="/UVA_img/8.png" alt="" /></p>
<ol>
<li>
<p>找规律加分治</p>
</li>
<li>
<p>观察两个图发现，第二章图的前两行是第一张图的平移</p>
</li>
<li>
<p>第二张图的后两行左半部分就是第一张图，右半部分全蓝</p>
</li>
<li>
<p>所以得出函数，第k张图的1~i行s(k,i)</p>
<ol>
<li>当k==0 时，s = 1;</li>
<li>当k&gt;0时
<ol>
<li>当i&lt;=2<sup>k-1</sup>时，s = 2*s(k-1,i)</li>
<li>当i&gt;2<sup>k-1</sup>时，s = s(k-1,i-2<sup>k-1</sup>)+2*红色球总数(k-1)</li>
</ol>
</li>
</ol>
</li>
<li>
<p>最终答案为s(k,B)-s(k,A-1)</p>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">long long A, B, k;</span><br><span class="line"></span><br><span class="line">long long Allred(long long k) &#123; return pow(3, k); &#125;</span><br><span class="line">long long s(long long k, long long i) &#123;</span><br><span class="line">	if (i &lt;&#x3D; 0) return 0;</span><br><span class="line">	if (k &#x3D;&#x3D; 0) return 1;</span><br><span class="line">	if (i &lt;&#x3D; (1 &lt;&lt; k - 1)) return 2 * s(k - 1, i);</span><br><span class="line">	else return s(k - 1, i - (1 &lt;&lt; (k - 1))) + 2 * Allred(k - 1);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	int kase &#x3D; 0;</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Case %d: &quot;, ++kase);</span><br><span class="line">		scanf(&quot;%lld %lld %lld&quot;, &amp;k, &amp;A, &amp;B);</span><br><span class="line">		printf(&quot;%lld\n&quot;, s(k, B) - s(k, A - 1));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>工人的请愿书</title>
    <url>/2020/03/30/%E5%B7%A5%E4%BA%BA%E7%9A%84%E8%AF%B7%E6%84%BF%E4%B9%A6/</url>
    <content><![CDATA[<h1 id="uva-12186-工人的请愿书"><a class="markdownIt-Anchor" href="#uva-12186-工人的请愿书"></a> UVA 12186 工人的请愿书</h1>
<p>某公司里有一个老板和n（n≤10^5）个员工组成树状结构，除了老板之外每个员工都有唯 一的直属上司。老板的编号为0，员工编号为1～n。工人们（即没有直接下属的员工）打算 签署一项请愿书递给老板，但是不能跨级递，只能递给直属上司。当一个中级员工（不是工 人的员工）的直属下属中不小于T%的人签字时，他也会签字并且递给他的直属上司。问： 要让公司老板收到请愿书，至少需要多少个工人签字？</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>设d(i)表示让u给上级发信，至少需要多少个工人。</li>
<li>对于i，它至少需要 c = (k*T - 1) / 100 + 1; 个下属发信才行。所以把他的子节点从小到大排序，前c个的和即为d(i)的值</li>
<li>最终答案为d(0)</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="keyword">int</span> n, T;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> k = g[u].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) &#123;</span><br><span class="line">		d.push_back(dp(v));</span><br><span class="line">	&#125;</span><br><span class="line">	sort(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">int</span> c = (k*T - <span class="number">1</span>) / <span class="number">100</span> + <span class="number">1</span>;  <span class="comment">//此处需要注意</span></span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c; i++)</span><br><span class="line">		ans += d[i];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;T)==<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; T == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) g[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">int</span> a;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">			g[a].push_back(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp(<span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>宝箱</title>
    <url>/2020/03/30/%E5%AE%9D%E7%AE%B1/</url>
    <content><![CDATA[<h1 id="uva-12325-宝箱"><a class="markdownIt-Anchor" href="#uva-12325-宝箱"></a> UVA 12325 宝箱</h1>
<p>你有一个体积为N的箱子和两种数量无限的宝物。宝物1的体积为S1，价值为V1:；宝物2的体积为S2，价值为V2。输入均为32位带符号整数。 计算最多能装多大价值的宝物。（每种宝物都必须拿非负整数个）。</p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<ol>
<li>可以选择枚举宝藏1的个数，然后尽可能多的拿宝物2；或者；但是当n和s1,s2的差距较大的时候，这种方法不奏效。</li>
<li>假设宝物1取总体积S2，宝物2取总体积S1，且二者总价值相等，即S1<em>V2 == S2</em>V1。那么当V1较大时，宝藏1至多取S2-1个，否则可用S1个宝物二替换。同理，如果V2较大，那么宝物2至多取S1-1个.因此，枚举量只有S1和S2。</li>
<li>解决TLE：
<ol>
<li>当N/S1比较小时，枚举宝物1的个数，时间复杂度为O(N/S1)；否则，当N/S2比较小时，枚举宝物2的个数，时间复杂度为O(N/S2)。</li>
<li>因此枚举的时间复杂度为O(max(S1,S2))</li>
</ol>
</li>
</ol>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<pre><code>typedef long long int64;
using std::swap; using std::max;
int main() {
int T, id = 0; scanf(&quot;%d&quot;, &amp;T);
while (T--) {
	int n, s1, v1, s2, v2; scanf(&quot;%d %d %d %d %d&quot;, &amp;n, &amp;s1, &amp;v1, &amp;s2, &amp;v2);
	if (s1 &gt; s2) swap(s1, s2), swap(v1, v2);//目的是使得S2&gt;S1
	int64 ans = 0;
	if (n / s2 &gt;= 65536) {	//S2&gt;S1，如果除以S2都大于65536，说明S2就很小，那么S1更小，那么使用特殊枚举。
		for (int64 i = 0; i &lt;= s1; i++) ans = max(ans, v2 * i + (n - s2 * i) / s1 * v1);
		for (int64 i = 0; i &lt;= s2; i++) ans = max(ans, v1 * i + (n - s1 * i) / s2 * v2);
	}
	else {//否则枚举宝物2的数量。
		for (int64 i = 0; s2 * i &lt;= n; i++) ans = max(ans, v2 * i + (n - s2 * i) / s1 * v1);
	}
	printf(&quot;Case # %d: %lld\n&quot;, ++id, ans);
}

return 0;
}
</code></pre>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>巡逻机器人</title>
    <url>/2020/03/30/%E5%B7%A1%E9%80%BB%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
    <content><![CDATA[<h1 id="uva1600-巡逻机器人"><a class="markdownIt-Anchor" href="#uva1600-巡逻机器人"></a> uva1600 巡逻机器人</h1>
<p>本题有t组数据，每组数据包含一个m*n的01矩阵，0表示能走，1表示有一个障碍物。机器人能往上下左右四个方向走动.它要从(1,1)到(m,n),可以连续翻越k个障碍物,求它从(1,1)到(m,n)的最短路径.如果不能到达输出&quot;-1&quot;.</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>本题基础是一个bfs，附加可以跳跃0的条件。</li>
<li>对无权图进行bfs的时候，走到每一个点时的步数都是一定的，所以对于每个点，应该让能够跨越障碍的机会越多越好，所以Node节点中应该包含(r,c,k,step)其中k为到达(r,c)位置时剩余的跨越障碍的机会，step为最小步数。(※如果只需要知道步数而不需要路径，则将其包在结构体里即可)</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<pre><code>#include&lt;bits/stdc++.h&gt;
# pragma warning(disable:4996)
# define LOCAL
# ifdef LOCAL
FILE *fin = freopen(&quot;习题6-5in.txt&quot;, &quot;r&quot;, stdin);
FILE *fout = freopen(&quot;习题6-5out.txt&quot;, &quot;w&quot;, stdout);
# endif 
using namespace std;
int n, x, y, k;
int g[20][20];
struct node {
	int r, c, k, step;

	node(int r, int c, int k, int step = 0) :r(r), c(c), k(k), step(step) {}
};
int step[20][20];
int dr[] = { 1, 0, -1, 0 };
int dc[] = { 0, 1, 0, -1 };
int min_step;
void bfs() {
	queue&lt;node&gt;q;
	q.push(node(0, 0, k));
	int block = 0;
	while (!q.empty()) {
		node u = q.front(); q.pop();

		if (u.r == x - 1 &amp;&amp; u.c == y - 1) {
			min_step = u.step;
			break;
		}
		for (int i = 0; i &lt; 4; i++) {
			int r = u.r + dr[i], c = u.c + dc[i];
			if (r &gt;= 0 &amp;&amp; r &lt; x&amp;&amp;c &gt;= 0 &amp;&amp; c &lt; y) {
				if (step[r][c] &lt; u.k) {//u.k是走到step[r][c]处，还剩余的跳过障碍的机会，所以要保留大的
					step[r][c] = u.k;
				}
				else continue;//如果step[r][c]更大，说明目前正在走的路不是最好的(因为bfs走到每个节点的步数是一定的
							  //所以剩余的跨越障碍的次数越多越好),不需要再走下去，所以不入队)
				if (g[r][c] == 0) q.push(node(r, c, k, u.step + 1));
				else if(u.k) q.push(node(r, c, u.k - 1, u.step + 1));
			}
		}
	}
}
int main() {
cin &gt;&gt; n;
while (n--) {

	memset(g, 0, sizeof(g));
	memset(step, -1, sizeof(step));
	cin &gt;&gt; x &gt;&gt; y;
	cin &gt;&gt; k;
	for (int i = 0; i &lt; x; i++)
		for (int j = 0; j &lt; y; j++)
			cin &gt;&gt; g[i][j];
	min_step = 999;
	bfs();
	min_step == 999 ? cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl:cout &lt;&lt; min_step &lt;&lt; endl;
}
}</code></pre>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>安迪的第一本字典</title>
    <url>/2020/03/30/%E5%AE%89%E8%BF%AA%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<h1 id="uva10815-安迪的第一本字典"><a class="markdownIt-Anchor" href="#uva10815-安迪的第一本字典"></a> UVa10815 安迪的第一本字典</h1>
<p>输入一个文本，找出所有不同的单词(连续字母序列)，按字典序从小到大输出，单词不区分大小写</p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p>主要利用set自动排序的特性实现字典序;主要工作是分割单词，即连续字母序列</p>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;sstream&gt;
#include&lt;set&gt;
using namespace std;
set&lt;string&gt; dir;
int main() {
string s, buf;
while (cin &gt;&gt; s) {
	for (int i = 0; i &lt; s.length(); i++) {
		if (isalpha(s[i])) s[i] = tolower(s[i]);
		else s[i] = ' ';
		
	}

/*
将文本存在s中，遍历s；遇到字母，则都转为小写，防止排序出错；若字母序列中断，则插入一个空格，这样在之后向buf中输入的时候，单词即可分开。
*/

	stringstream ss(s);
	while (ss &gt;&gt; buf) dir.insert(buf);
}

for (set&lt;string&gt;::iterator it = dir.begin(); it != dir.end(); it++)
	cout &lt;&lt; *it &lt;&lt; endl;
}
</code></pre>
<p>主要这一段stringstream以及迭代器的用法；迭代器可以理解为一个指针</p>
<h2 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h2>
<p>本题主要是对set的应用</p>
<ol>
<li>要学习set的声明和基本使用：insert(插入元素)；</li>
<li>要学习拆分单词的技巧</li>
<li>要学习迭代器的使用方法</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>小球下落</title>
    <url>/2020/03/30/%E5%B0%8F%E7%90%83%E4%B8%8B%E8%90%BD/</url>
    <content><![CDATA[<h1 id="uva-679-小球下落"><a class="markdownIt-Anchor" href="#uva-679-小球下落"></a> uva 679 小球下落</h1>
<p> 许多的小球一个一个的从一棵满二叉树上掉下来组成一个新满二叉树，每一时间，一个正在下降的球第一个访问的是非叶子节点。然后继续下降时，或者走右子树，或者走左子树，直到访问到叶子节点。<br />
决定球运动方向的是每个节点的布尔值。最初，所有的节点都是 FALSE，当访问到一个节点时，如果这个节点是 FALSE，则这个球把它变成 TRUE，然后从左子树走，继续它的旅程。如果节点是TRUE，则球也会改变它为 FALSE，而接下来从右子树走。满二叉树的标记方法如下图。<br />
因为所有的节点最初为 FALSE，所以第一个球将会访问节点 1，节点 2 和节点 4，转变节点的布尔值后在在节点 8 停止。第二个球将会访问节点 1、3、6，在节点 12 停止。；明显地，第三个球在它停止之前，会访问节点 1、2、5，在节点 10 停止。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>对于二叉树，有结论编号为i的节点的左子树编号为2i,右子树为2i+1</li>
<li>如果用一个数组存二叉树，并进行遍历，会TEL，并且数组占很大空间</li>
<li>发现只要知道是第几个通过该节点的小球，那么就可以知道这一步他落到左子树还是右子树</li>
<li>如果I为奇数，那么他是第（I+1）/2个向左走的小球，如果I为偶数，那么他是第I/2个向右走的小球。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   #include&lt;iostream&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;小球下落in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;小球下落out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   using namespace std;</span><br><span class="line">   int main() &#123;</span><br><span class="line">int T;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line">while (T--) &#123;</span><br><span class="line">	int num, depth;</span><br><span class="line">	cin &gt;&gt; depth &gt;&gt; num;</span><br><span class="line">	int No &#x3D; 1;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; depth-1; i++) &#123;</span><br><span class="line">		if (num % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">			No &#x3D; 2 * No;</span><br><span class="line">			num &#x3D; (num + 1) &#x2F; 2;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			No &#x3D; 2 * No + 1;</span><br><span class="line">			num &#x3D; num &#x2F; 2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; No &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<ol>
<li>关注该关注的，并找规律很重要</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>巴比伦塔</title>
    <url>/2020/03/30/%E5%B7%B4%E6%AF%94%E4%BC%A6%E5%A1%94/</url>
    <content><![CDATA[<h1 id="uva-437-巴比伦塔"><a class="markdownIt-Anchor" href="#uva-437-巴比伦塔"></a> UVA 437 巴比伦塔</h1>
<p>你可能已经听说过巴比伦塔的传说。现在这个传说的许多细节已经被遗忘。所以本着本场比赛的教育性质，我们现在会告诉你整个传说：</p>
<p>巴比伦人有n种长方形方块，每种有无限个，第i种方块的三边边长是xi,yi,zi。对于每一个方块，你可以任意选择一面作为底，这样高就随着确定了。举个例子，同一种方块，可能其中一个是竖着放的，一个是侧着放的，一个是横着放的。</p>
<p>他们想要用堆方块的方式建尽可能高的塔。问题是，只有一个方块的底的两条边严格小于另一个方块的底的两条边，这个方块才能堆在另一个上面。这意味着，一个方块甚至不能堆在一个底的尺寸与它一样的方块的上面。</p>
<p>你的任务是编写一个程序，计算出这个塔可以建出的最高的高度。</p>
<p>输入会包含至少一组数据，每组数据的第一行是一个整数n(n&lt;=30)，表示方块的种类数。 这组数据接下来的n行，每行有三个整数，表示xi,yi,zi。 输入数据会以0结束。</p>
<p>对于每组数据，输出一行，其中包含组号(从1开始)和塔最高的高度。按以下格式： Case : maximum height = __</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol start="3">
<li>每次决策的影响因素只有顶面尺寸</li>
<li>每次的顶面长宽都会严格减小，所以状态图是一个有向无环图，所以问题转换成了求DAG上的最长路径问题</li>
<li>关于状态的存储。如果使用(a,b)表示顶面面积a*b，由于ab可能很大是，所以不可行；如果用(idx,k)表示以第idx号立方体的第k号边为高，则可行。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="get_wl-将以b号边为高的第a号矩形的长宽填入数组v"><a class="markdownIt-Anchor" href="#get_wl-将以b号边为高的第a号矩形的长宽填入数组v"></a> get_wl 将以b号边为高的第a号矩形的长宽填入数组v</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void get_wl(int *v, int a, int b) &#123;&#x2F;&#x2F;将长宽填入数组</span><br><span class="line">	int idx &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 3; i++)</span><br><span class="line">		if (i !&#x3D; b)</span><br><span class="line">			v[idx++] &#x3D; block[a][i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dp-尝试填充d数组"><a class="markdownIt-Anchor" href="#dp-尝试填充d数组"></a> dp 尝试填充d数组</h2>
<p>d[i][j]表示以第i个立方体的第j条边，能达到的最大高度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int dp(int i, int j) &#123;</span><br><span class="line">	int &amp;ans &#x3D; d[i][j];</span><br><span class="line">	if (ans &gt; 0)  return ans;</span><br><span class="line">	ans &#x3D; 0;</span><br><span class="line">	int v1[2], v2[2];</span><br><span class="line">	get_wl(v1, i, j);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; 3; j++) &#123;</span><br><span class="line">			get_wl(v2, i, j);</span><br><span class="line">			if (v1[0] &gt; v2[0] &amp;&amp; v1[1] &gt; v2[1])</span><br><span class="line">				ans &#x3D; max(ans, dp(i, j));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans +&#x3D; block[i][j];</span><br><span class="line">	return ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	int kase &#x3D; 0;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 3; j++)</span><br><span class="line">				scanf(&quot;%d&quot;, &amp;block[i][j]);</span><br><span class="line">			sort(block[i], block[i] + 3);</span><br><span class="line">		&#125;</span><br><span class="line">		memset(d, 0, sizeof(d));</span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 3; j++)</span><br><span class="line">				ans &#x3D; max(ans, dp(i, j));</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;Case %d: maximum height &#x3D; %d\n&quot;, ++kase, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>平均值</title>
    <url>/2020/03/30/%E5%B9%B3%E5%9D%87%E5%80%BC/</url>
    <content><![CDATA[<h1 id="uva-1451-平均值"><a class="markdownIt-Anchor" href="#uva-1451-平均值"></a> UVA 1451 平均值</h1>
<p>给定一个长度为 n 的 01 串，选一个长度至少为  的连续子串，使得子串中数字的平均值最大。如果有多解，子串长度应尽量小；如果仍有多解，起点编号尽量小。序列中的字符编号为 1 ~ n，因此 [1,n] 就是完整的字符串。1≤n≤100000</p>
<p>例如，对于如下长度为 171717 的序列00101011011011010，如果 L=7L=7L=7 ，最大平均值为 34\frac 3 443​ （子序列为 [7,14]其长度为 8）；如果 L=5，子序列 [7,11]的平均值最大，为 4/5​。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>
<p>观察目标函数的形式，非常类似sum函数的斜率，其中sum(i)为前i项和，并且相邻两项间都是x+1,y不变或加1。所以问题转化成了寻找两点间斜率的最大值。那么哪种情况斜率最大呢？假设给点一个点Pt，现在要求Pt’使得直线PtPt’斜率最大。</p>
</li>
<li>
<p>假设Pt的x坐标为x0。假设有三个候选点Pi,Pj,Pk 且i&lt;j&lt;k&lt;t</p>
<ol>
<li>若Pj为上凸点。因为t&gt;k，所以yt&gt;=yk，画图可知，忽略点点j不会丢掉最优点。因此，所有的上凸点都可以直接忽略</li>
<li>若Pj为下凹点。那么该点与当前的枚举的结尾点的连线即为可能的最优解。但问题是，新的点的加入可能使原来的点变成上凸点，这时就应该把上凸点删除。被删除的点总时原来的下凹点中最右边的若干连续点(因此可以用栈实现)</li>
</ol>
</li>
<li>
<p>因此，主过程就是枚举终点，计算可能的起始点。对于合法的起始点，更新答案。</p>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="compare_avg-比较平均值-使用通分做差后的分子避免除法误差"><a class="markdownIt-Anchor" href="#compare_avg-比较平均值-使用通分做差后的分子避免除法误差"></a> compare_avg 比较平均值 使用通分做差后的分子避免除法误差</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int compare_avg(int x1, int x2, int x3, int x4) &#123;</span><br><span class="line">	return (sum[x2] - sum[x1-1])*(x4 - x3 + 1) - (sum[x4] - sum[x3-1])*(x2 - x1 + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="solve-枚举终点计算可能的起始点对于合法的起始点更新答案"><a class="markdownIt-Anchor" href="#solve-枚举终点计算可能的起始点对于合法的起始点更新答案"></a> solve 枚举终点，计算可能的起始点，对于合法的起始点，更新答案</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">	int ansL&#x3D;1, ansR &#x3D; L;</span><br><span class="line">	int i &#x3D; 0, j &#x3D; 0;</span><br><span class="line">	for (int t &#x3D; L; t &lt;&#x3D; n; t++) &#123;</span><br><span class="line">		&#x2F;&#x2F;p[i,j)为候选起始点</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;略过上凸点</span><br><span class="line">		while (j - i &gt; 1 &amp;&amp; compare_avg(p[j - 2], t - L, p[j - 1], t - L) &gt;&#x3D; 0) </span><br><span class="line">		&#x2F;&#x2F;当斜率下降过程中出现上升，则停止</span><br><span class="line">		j--; </span><br><span class="line"></span><br><span class="line">		p[j++] &#x3D; t - L + 1;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;找到第一个切点</span><br><span class="line">		while (j - i &gt; 1 &amp;&amp; compare_avg(p[i], t, p[i + 1], t) &lt;&#x3D; 0) i++;	</span><br><span class="line">		&#x2F;&#x2F;当斜率上升过程中出现下降，则停止</span><br><span class="line">	</span><br><span class="line">		int nans &#x3D; compare_avg(p[i], t, ansL, ansR);</span><br><span class="line">			if (nans &gt; 0 || (nans &#x3D;&#x3D; 0 &amp;&amp; t - p[i] &lt; ansR - ansL)) &#123;</span><br><span class="line">				ansL &#x3D; p[i];</span><br><span class="line">				ansR &#x3D; t;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d %d\n&quot;, ansL, ansR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100000 + 5;</span><br><span class="line">int sum[maxn];</span><br><span class="line">char s[maxn];</span><br><span class="line">int p[maxn];</span><br><span class="line">int n, L;</span><br><span class="line"></span><br><span class="line">int compare_avg(int x1, int x2, int x3, int x4);</span><br><span class="line">void solve();</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d\n&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d %d&quot;, &amp;n, &amp;L);</span><br><span class="line">		</span><br><span class="line">		scanf(&quot;%s&quot;, s + 1);</span><br><span class="line">		sum[0] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) sum[i] &#x3D; sum[i - 1] + s[i]-&#39;0&#39;;</span><br><span class="line">		solve();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>带宽</title>
    <url>/2020/03/30/%E5%B8%A6%E5%AE%BD/</url>
    <content><![CDATA[<h1 id="uva-140-带宽"><a class="markdownIt-Anchor" href="#uva-140-带宽"></a> uva 140 带宽</h1>
<p>题意： 给一个最多8个结点的无向图，把结点重排后对于图中每条边(u,v)，u和v在排列中的最大距离称为该排列的带宽。求带宽最小的排列.</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>本题是带优化的穷举法----回溯法的应用</li>
<li>所谓回溯法，就是在遍历的过程中构建树和删除树(剪枝)，如果可以确定该子树中不含有问题的解，则放弃对该子树的搜索，返回到上层的父节点，继续下一步深度优先搜索。</li>
<li>类比到本题中，有两种情况可以剪枝：
<ol>
<li>对于节点u来说，假设u有m个相邻的节点，那么最理想的情况就是这m个节点紧跟在u后面，这样的节点带宽为m，而其他任何非理想情况的带宽至少为m+1</li>
<li>如果当前节点的带宽已经大于最小带宽，那么说明这个位置不能放这个位置不能放i，即放回到上层，再又上层执行vis[i] = 0来回溯</li>
</ol>
</li>
<li>由于A即使在没有成功运行到底的情况下，也会被改变，所以要将每次的结果更新到另一个数组里，采用memcpy函数</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<pre><code>#include&lt;bits/stdc++.h&gt;
# pragma warning(disable:4996)
# define LOCAL
# ifdef LOCAL
FILE *fin = freopen(&quot;带宽in.txt&quot;, &quot;r&quot;, stdin);
FILE *fout = freopen(&quot;带宽out.txt&quot;, &quot;w&quot;, stdout);
# endif 
using namespace std;
map&lt;int, set&lt;int&gt;&gt; xl;
int n;
int A[10],ans[10];
int vis[26];
int minb = 100000000;
void dfs(int cur, int B) {
	if (cur == n)
	{
		//能到这，说明已经是最优解了，所以要更新ans和最小带宽
		memcpy(ans, A, sizeof(int)*n);
		minb = B;
	}
	else for (auto it = xl.begin(); it != xl.end();it++) {
		//由于给的点不一定是前n个，所以要用迭代器来遍历可以用的点
		int i = it-&gt;first;
		if (!vis[i]) {//vis[i]用来保证是个排列
			int m = 0;
			for (int j = 0; j &lt; cur; j++)
				if (!vis[A[j]] &amp;&amp; xl[i].count(A[j])) 
					m++;
			if (m &gt;= minb) return;//等于号很重要，用来保证是第一个最优解

			int ok = 1;
			A[cur] = i;
			for (int j = 0; j &lt; cur; j++) {
				
				if (xl[i].count(A[j])) {
					int w = cur - j;
					if (w &gt; B) B = w;
					if (B &gt;= minb) return;

					
				}
					
			}

			if (ok) {
				vis[i] = 1;
				dfs(cur + 1, B);
				vis[i] = 0;//回溯：要么是到头了，回溯来找其他解；要么是中间返回，回溯以求正确解
			}
		}
	}
}
int main() {
	string line;
	while (getline(cin, line) &amp;&amp; line != &quot;# &quot;) {
		xl.clear();
		memset(A, -1, sizeof(A));
		bool flag = true;
		char u;
		for (int i = 0; i &lt; line.length(); i++) {
			if (isalpha(line[i])) {
				if (flag) {
					u = line[i] - 'A';
					flag = false;
					xl[line[i] - 'A'];
				}
				else {
					xl[u].insert(line[i] - 'A');
					xl[line[i] - 'A'].insert(u);
				}
			}
			else if (line[i] == ';') flag = true;
		}
		n = xl.size();
		memset(vis, 0, sizeof(vis));
		memset(ans, 0, sizeof(ans));
		minb = 100000000;
		dfs(0, 0);
		for (int i = 0; i &lt; n; i++) cout &lt;&lt; char('A' + ans[i]) &lt;&lt; &quot; &quot;;
		cout &lt;&lt; &quot;-&gt; &quot;&lt;&lt;minb &lt;&lt; endl;


	}
}</code></pre>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>并行程序模拟</title>
    <url>/2020/03/30/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<h1 id="uva-210-并行程序模拟"><a class="markdownIt-Anchor" href="#uva-210-并行程序模拟"></a> uva 210 并行程序模拟</h1>
<p>你的任务是模拟nnn个程序（按输入顺序编号111~nnn）的并行执行。每个程序包含不超过25条语句。</p>
<p>格式一共是5种：赋值（var=constantvar=constantvar=constant），打印（print varvarvar），locklocklock，unlockunlockunlock，endendend，耗时分别为t1,t2,t3,t4,t5t_1,t_2,t_3,t_4,t_5t1​,t2​,t3​,t4​,t5​。</p>
<p>变量用一个小写字母表示，初始时为000，为所有并行程序共有，且它的值始终保持在[0,100][0,100][0,100]内，所以一个程序对某一个变量的赋值会影响到另外一个程序。</p>
<p>每个时刻只能是一个程序处于运行状态，其他程序处于等待状态。运行状态之中的的程序每次最多分配QQQ个单位时间，一旦在未执行完程序时超过分配时间，这个程序则会被插入等待队列，然后从其的队首取出一共程序继续执行。而初始的等待队列为按照输入程序排入。</p>
<p>但是由于locklocklock和unlockunlockunlock命令的出现，这个顺序会被改变。</p>
<p>locklocklock的作用是申请对所有变量的独占访问，unlockunlockunlock则是解除对所有变量的独占访问，且它们一定成对出现。当一个程序已经对所有的变量独占访问后，其他程序若试图执行locklocklock，无论其是否耗尽分配时间，都会被放在一个阻止队列的尾部，且当那个程序解除的时候，则会从阻止队列的头部的程序进入等待队列的头部。</p>
<p>现在给出n,t1,t2,t3,t4,t5,Qn,t_1,t_2,t_3,t_4,t_5,Qn,t1​,t2​,t3​,t4​,t5​,Q以及nnn个程序，你需要输出所有printprintprint命令执行输出的值。</p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<ol>
<li>对于每个程序，将它所对应的代码存到一个队列中，所有的程序构成一个队列数组。</li>
<li>运行时定义三个队列，分别为等待，阻塞和运行，里面存程序的编号。</li>
<li>在等待队列不空的情况下持续循环。每次取等待队列首部的程序作为当前运行的程序队列，即running队列。</li>
<li>运行过程中，不断从running的队首取元素，分析代码，调用analysis函数运行指令，并返回相应时间。注意加锁和解锁的过程要特殊处理。</li>
<li>每次t-=返回的耗时，running队列弹出一条语句。</li>
<li>如果分配的时间片内没有完成，则将对应程序的编号插入等待队列的队尾，并且更新对应程序剩余代码。</li>
</ol>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<pre><code>#include&lt;bits/stdc++.h&gt;
# define LOCAL
# ifdef LOCAL
FILE *fin = freopen(&quot;并行程序模拟in.txt&quot;, &quot;r&quot;, stdin);
FILE *fout = freopen(&quot;并行程序模拟out.txt&quot;, &quot;w&quot;, stdout);
# endif 
using namespace std;
# define maxn 500
int tim[5];//记录每个操作的时间
map&lt;string, string&gt; value;
deque&lt;int&gt; waiting;//等待队列，存队列的ID（数组中的下标）
int quota;//配额

bool lockKey = false;
int analysis(string s) {
	if (s.find('=') != -1) {
		int m = s.find('=');
		string l = s.substr(0, m - 1);
		string r = s.substr(m + 2);
		value[l] = r;
		return tim[0];
	}
	else if (s.substr(0, 5) == &quot;print&quot;) {
		string a = s.substr(6);
		cout &lt;&lt; waiting.front() + 1 &lt;&lt; &quot;: &quot;;
		if(value.count(a)) cout&lt;&lt; value[a] &lt;&lt; endl;
		else cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;
		return tim[1];
	}
	else if (s == &quot;lock&quot;) {
		if (!lockKey) {
			lockKey = true;
			return tim[2];
		}
		else return -1;

	}
	else if (s == &quot;unlock&quot;) {
	
		lockKey = false;

		return -2;
	}
	else if (s == &quot;end&quot;) {
		return tim[4];
	}
}
int main() {
	int T;
	cin &gt;&gt; T;
	bool first = true;
	while (T--) {
		if (first) first = false;
		else cout &lt;&lt; endl;
		queue&lt;string&gt; pro[maxn];
	
		queue&lt;int&gt; block;//阻塞队列
		value.clear();
		waiting.clear();
		int n;
		cin &gt;&gt; n;
		for (int i = 0; i &lt; 5; i++) cin &gt;&gt; tim[i];

		cin &gt;&gt; quota; getchar();
		for (int i = 0; i &lt; n; i++) {
			string s;
			while (getline(cin, s)) {
				pro[i].push(s);
				if (s == &quot;end&quot;) break;
			}
			waiting.push_back(i);
		}



		while (!waiting.empty()) {
			queue&lt;string&gt; running = pro[waiting.front()];
			int t = quota;
			bool flag = true;
			while (!running.empty() &amp;&amp; t&gt;0) {
				int w = analysis(running.front());
				if (w == -1) {//说明不是第一次执行到lock
					block.push(waiting.front());
					flag = false;
					break;
				}
				if (w == -2) {
					if (!block.empty()) {
						int now = waiting.front();
						waiting.pop_front();
						waiting.push_front(block.front());
						block.pop();
						waiting.push_front(now);
					}
					w = tim[3];
				}
				

				t -= w;
				running.pop();
				
			}
			if (flag &amp;&amp; !running.empty()) {

				waiting.push_back(waiting.front());
			}
			pro[waiting.front()] = running;

			waiting.pop_front();
		}
	
	}

	
}</code></pre>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>循环小数</title>
    <url>/2020/03/30/%E5%BE%AA%E7%8E%AF%E5%B0%8F%E6%95%B0/</url>
    <content><![CDATA[<h1 id="uva-202-循环小数"><a class="markdownIt-Anchor" href="#uva-202-循环小数"></a> uva 202 循环小数</h1>
<p>输入整数aaa 和bbb （0≤aaa ≤3000,1≤bbb ≤3000），输出a/b的循环小数表示以及循环节的长度。例如aaa =5，bbb =43 小数表示为0.(116279069767441860465)，循环节长度为21。 补充： 如果循环节超过50位，就在第50位后打省略号（三个点，就像“…”）</p>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   #include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">   # pragma warning(disable:4996)</span><br><span class="line">   # define LOCAL</span><br><span class="line">   # ifdef LOCAL</span><br><span class="line">   FILE *fin &#x3D; freopen(&quot;习题3-8in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">   FILE *fout &#x3D; freopen(&quot;习题3-8out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">   # endif </span><br><span class="line">   &#x2F;&#x2F;被除数出现重复，那么出现了循环节</span><br><span class="line">   const int maxn &#x3D; 100000 + 5;</span><br><span class="line">   </span><br><span class="line">   int a, b;</span><br><span class="line">   int vis[maxn], res[maxn];</span><br><span class="line">   </span><br><span class="line">   int main() &#123;</span><br><span class="line">while (scanf(&quot;%d%d&quot;, &amp;a, &amp;b) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">	memset(vis, -1, sizeof(vis));</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;※这样做可以得到所有小数</span><br><span class="line">	&#x2F;&#x2F;vis用来确定是否出现循环，res存小数部分</span><br><span class="line">	&#x2F;&#x2F;本题特殊在于一但出现一个数字重复，那么可以认为出现循环节</span><br><span class="line">	int c &#x3D; a % b, cnt &#x3D; 0;</span><br><span class="line">	c *&#x3D; 10;</span><br><span class="line">	while (vis[c] &#x3D;&#x3D; -1) &#123;</span><br><span class="line">		res[cnt] &#x3D; c &#x2F; b;</span><br><span class="line">		vis[c] &#x3D; cnt++;</span><br><span class="line">		c %&#x3D; b;</span><br><span class="line">		c *&#x3D; 10;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; repeating cycle start-position</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	int sta_pos &#x3D; vis[c];</span><br><span class="line">	printf(&quot;%d&#x2F;%d &#x3D; %d.&quot;, a, b, a &#x2F; b);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; sta_pos; i++) &#123;</span><br><span class="line">		printf(&quot;%d&quot;, res[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;(&quot;);</span><br><span class="line">	if (cnt - sta_pos &lt;&#x3D; 50) &#123;</span><br><span class="line">		for (int i &#x3D; sta_pos; i &lt; cnt; i++) &#123;</span><br><span class="line">			printf(&quot;%d&quot;, res[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		for (int i &#x3D; sta_pos; i &lt; sta_pos + 50; i++) &#123;</span><br><span class="line">			printf(&quot;%d&quot;, res[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;...&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;)\n&quot;);</span><br><span class="line">	printf(&quot;   %d &#x3D; number of digits in repeating cycle\n\n&quot;, cnt - sta_pos);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>打印队列</title>
    <url>/2020/03/30/%E6%89%93%E5%8D%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="uva12100-打印队列"><a class="markdownIt-Anchor" href="#uva12100-打印队列"></a> uva12100 打印队列</h1>
<p> 学生会里只有一台打印机，但是有很多文件需要打印，因此打印任务不可避免地需要等待。有些打印任务比较急，有些不那么急，所以每个任务都有一个1～9间的优先级，优先级越高表示任务越急。</p>
<p> 打印机的运作方式如下：首先从打印队列里取出一个任务J，如果队列里有比J更急的任务，则直接把J放到打印队列尾部，否则打印任务J（此时不会把它放回打印队列）。 输入打印队列中各个任务的优先级以及所关注的任务在队列中的位置（队首位置为0），输出该任务完成的时刻。所有任务都需要1分钟打印。例如，打印队列为{1,1,9,1,1,1}，目前处于队首的任务最终完成时刻为5。</p>
<p> 输入T 接下来T组数据 每组数据输入N，TOP。接下来N个数，TOP代表队列首</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>通过两个队列实现，一个是优先级队列，其队首即为当前允许出队的优先级；另一个是打印队列</li>
<li>只有当优先级队列的队首等于打印队列的队首的时候（当前要打印的任务优先级最高）时，才能打印；否则将打印队列的队首插到队尾</li>
<li>由于最终要根据在初始队列中的位置选择输出，所以既要记录优先级又要记录初始位置。</li>
<li>优先级队列与元素无关，所以用int型即可</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<pre><code>//list存打印请求队列，如果优先级队列pq的队首比list大，说明队列中还有优先级更高的任务，则将list的队首放在队尾
//只有当pq的队首等于list的队首的时候，list才输出，pq才出队!!!
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
# pragma warning(disable:4996)
# define LOCAL
# ifdef LOCAL
FILE *fin = freopen(&quot;习题5-7in.txt&quot;, &quot;r&quot;, stdin);
FILE *fout = freopen(&quot;习题5-7out.txt&quot;, &quot;w&quot;, stdout);
# endif 
using namespace std;
int n;
struct node {
	int f;
	int pos;
	node(int f, int pos) :f(f), pos(pos) {}
};
int main() {
cin &gt;&gt; n;
while (n--)
{
	queue&lt;node&gt; list;
	priority_queue&lt;int&gt; pq;
	int m, pos;
	cin &gt;&gt; m &gt;&gt; pos;


	for (int i = 0; i &lt; m; i++) {
		int x;
		cin &gt;&gt; x;
		pq.push(x);
		list.push(node(x,i));
	}
	
	int time = 0;
	while(!list.empty()&amp;&amp;!pq.empty()){
		if (list.front().f &lt; pq.top()) {
			list.push(list.front());
			list.pop();
		}
		else if (list.front().f == pq.top()) {
			if (list.front().pos == pos) break;
			
				list.pop();
				pq.pop();//！！只有成功打印了，优先级队列才队
				time++;
			
		}

	}
	cout &lt;&lt; time+1 &lt;&lt; endl;
}
}
</code></pre>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<ol>
<li>首先是学习了优先级队列，优先级队列是每次都挑出优先级最大的，而不是重排队列。</li>
<li>以后应该明确每个STL应该关注的点，像是这里的优先级队列，只需关注级数数值即可，无需定义为node型</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>战场</title>
    <url>/2020/03/30/%E6%88%98%E5%9C%BA/</url>
    <content><![CDATA[<h1 id="uva-11853-战场"><a class="markdownIt-Anchor" href="#uva-11853-战场"></a> UVA 11853 战场</h1>
<p>有一个1000*1000的正方形战场，战场西南角的坐标为(0,0)，西北角的坐标为(0,1000)。战场上有n个敌人，给定每个敌人的坐标和攻击半径，求能否从西边进入，从东边离开。如果有多个位置进出，则求出最北的进/出位置。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>
<p>地图比较大，敌人相对较少。转换思路，考虑能否从上边界踩着敌人到达下边界</p>
<ol>
<li>如果能，则说明敌人将战场从中分割，即无解。</li>
<li>如果不能，在选择最北的点。</li>
</ol>
</li>
<li>
<p>将问题转换成了图的连通性问题，下面给出bfs和dfs两种解法</p>
</li>
<li>
<p>dfs速度远远快于bfs</p>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> dfs</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    bool dfs(int u)</span><br><span class="line">	&#123;</span><br><span class="line">	if (vis[u]) return false;</span><br><span class="line">	vis[u] &#x3D; 1;</span><br><span class="line">	if (y[u] &lt; r[u]) return true;</span><br><span class="line">	for (int v &#x3D; 0; v &lt; n; v++) &#123;</span><br><span class="line">		if (intersect(u, v) &amp;&amp; dfs(v)) </span><br><span class="line">			return true;</span><br><span class="line">	&#125;</span><br><span class="line">	check(u);</span><br><span class="line">	return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">1. 注意是在走不通时，才更新进入点</span><br></pre></td></tr></table></figure>
<h3 id="intersect-判断两个圆是否相交"><a class="markdownIt-Anchor" href="#intersect-判断两个圆是否相交"></a> intersect 判断两个圆是否相交</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool intersect(int a, int b) &#123;</span><br><span class="line">return sqrt((x[a] - x[b])*(x[a] - x[b]) + (y[a] - y[b])*(y[a] - y[b])) &lt; r[a] + r[b];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="check-更新进入点"><a class="markdownIt-Anchor" href="#check-更新进入点"></a> check 更新进入点</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void check(int u)</span><br><span class="line">&#123;</span><br><span class="line">if (x[u] &lt; r[u]) left &#x3D; min(left, y[u] - sqrt(r[u] * r[u] - x[u] * x[u]));</span><br><span class="line">if (x[u] + r[u] &gt; W) right &#x3D; min(right, y[u] - sqrt(r[u] * r[u] - (W - x[u])*(W - x[u])));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main-函数"><a class="markdownIt-Anchor" href="#main-函数"></a> main 函数</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">#ifdef local</span><br><span class="line">freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">#endif &#x2F;&#x2F; local</span><br><span class="line">while (~scanf(&quot;%d&quot;, &amp;n)) &#123;</span><br><span class="line">	bool ok &#x3D; true;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	left &#x3D; right &#x3D; W;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, x + i, y + i, r + i);</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (r[i] + y[i] &gt;&#x3D; W &amp;&amp; dfs(i)) &#123; ok &#x3D; false; break; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (ok) printf(&quot;0.00 %.2lf 1000.00 %.2lf\n&quot;, left, right);</span><br><span class="line">	else printf(&quot;IMPOSSIBLE\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> bfs</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#pragma warning(disable:4996)</span><br><span class="line">#define LOCAL</span><br><span class="line">#ifdef LOCAL</span><br><span class="line">FILE *fin &#x3D; freopen(&quot;战场in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">FILE *fout &#x3D; freopen(&quot;战场out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">#endif </span><br><span class="line">using namespace std;</span><br><span class="line">int vis[1005];</span><br><span class="line">int n;</span><br><span class="line">double le, ri;</span><br><span class="line">struct Node &#123;</span><br><span class="line">double x, y, r;</span><br><span class="line">Node(double x, double y, double r) :x(x), y(y), r(r) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Node&gt; enemy;</span><br><span class="line">bool intersect(int u, int v) &#123;</span><br><span class="line">return sqrt(pow(enemy[u].x - enemy[v].x, 2) + pow(enemy[u].y - enemy[v].y, 2)) &lt; enemy[u].r + enemy[v].r;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line">void check_circle(int u) &#123;</span><br><span class="line">if (enemy[u].x - enemy[u].r &lt; 0)</span><br><span class="line">	le &#x3D; min(le, enemy[u].y - sqrt(enemy[u].r * enemy[u].r - enemy[u].x * enemy[u].x));</span><br><span class="line">if (enemy[u].x + enemy[u].r &gt; 1000)</span><br><span class="line">	ri &#x3D; min(ri, enemy[u].y - sqrt(enemy[u].r * enemy[u].r - (1000 - enemy[u].x) *(1000 - enemy[u].x)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool bfs(int i) &#123;</span><br><span class="line">queue&lt;int&gt; q;</span><br><span class="line">q.push(i);</span><br><span class="line">while (!q.empty()) &#123;</span><br><span class="line">	int u &#x3D; q.front(); q.pop();</span><br><span class="line">	if (enemy[u].y - enemy[u].r &lt;&#x3D; 0) &#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	vis[u] &#x3D; 1;</span><br><span class="line">	check_circle(u);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if (!vis[i] &amp;&amp; intersect(i, u))</span><br><span class="line">			q.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">while (cin &gt;&gt; n) &#123;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	enemy.clear();</span><br><span class="line">	le &#x3D; ri &#x3D; 1000;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		int x, y, r;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y &gt;&gt; r;</span><br><span class="line">		enemy.push_back(Node(x, y, r));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool flag &#x3D; true;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">		if (enemy[i].y + enemy[i].r &gt;&#x3D; 1000)</span><br><span class="line">			flag &#x3D; bfs(i);</span><br><span class="line"></span><br><span class="line">	if (!flag) &#123;</span><br><span class="line">		cout &lt;&lt; &quot;IMPOSSIBLE&quot; &lt;&lt; endl;</span><br><span class="line">		continue;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;0.00 %.2f 1000.00 %.2f\n&quot;,le, ri);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂计算</title>
    <url>/2020/03/30/%E5%BF%AB%E9%80%9F%E5%B9%82%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="uva-1374-快速幂计算"><a class="markdownIt-Anchor" href="#uva-1374-快速幂计算"></a> UVA 1374 快速幂计算</h1>
<p>初始有x，问经过多少次乘除可以得到目标值n。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>
<p>与埃及积分有相似之处，可以采用迭代加深搜的方法。</p>
</li>
<li>
<p>通过迭代得出可以得到的幂次，通过深度搜素来凑</p>
</li>
<li>
<p>关于剪枝</p>
<ol>
<li>根据题意，幂次不允许小于0，幂次=0也没用</li>
<li>如果当前序列的最大数乘以2<sup>maxd-d</sup>&lt;n，则应该剪枝。因为即使剩余的maxd-d层都是乘以当前序列的最大值(即最大的幂次乘以2，即左移一位)仍然小于n，则说明这一支不可能达到n了，故需要剪掉。</li>
</ol>
</li>
<li>
<p>关于节点排序：为了更快的接近目标，应该优先扩展较大的数，优先加法再试减法。这样可以在最后一次迭代中，无需等待整个解答树扩展完成即可找到解。</p>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> res[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> maxd;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> maxn)</span></span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (maxd = <span class="number">0</span>;; maxd++)</span><br><span class="line">            <span class="keyword">if</span> (dfs(<span class="number">0</span>, <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, maxd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> maxn)</span> </span>&#123;<span class="comment">//当前的步数d，当前的最大值maxn</span></span><br><span class="line">    <span class="keyword">if</span> (d == maxd)</span><br><span class="line">        <span class="keyword">if</span> (maxn == n || maxn &lt;&lt; (maxd - d) == n) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxn &lt;= <span class="number">0</span> || maxn &lt;&lt; (maxd - d) &lt; n) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    res[d] = maxn;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= d; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfs(d + <span class="number">1</span>, maxn + res[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (dfs(d + <span class="number">1</span>, maxn - res[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>抄书</title>
    <url>/2020/03/30/%E6%8A%84%E4%B9%A6/</url>
    <content><![CDATA[<h1 id="uva-714-抄书"><a class="markdownIt-Anchor" href="#uva-714-抄书"></a> UVA 714 抄书</h1>
<p>把一个包含m个正整数的划分成k个(1&lt;=k&lt;=m&lt;=500)非空的连续子序列，使得每个正整数恰好属于一个序列。设第i个序列的各数之和为S(i)，你的任务是让max{S(i)}最小，输出依次个数字最小的情况。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>本题的优化目标是使最大值尽量小。设P(x)表示将输入序列分成m个连续的子序列，使得所有S(i)不超过x。则本题的目标使求得使P(x)为真的最小的x</li>
<li>现在考虑x可能取值，x至少是序列中的最大元素，最大是所有序列和，那么我们可以猜一个x，然后判断是否所有的子序列和都小于这个值。沿着这个思路想到用二分法，此题得解。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="below-判断是否所有子序列的和都小于p"><a class="markdownIt-Anchor" href="#below-判断是否所有子序列的和都小于p"></a> below 判断是否所有子序列的和都小于p</h2>
<ol>
<li>每次尽量往右划分即可。第j个元素在合法情况下，放在第i个序列和第i+1个序列的区别会导致隔板数不同。但是此时我只需要知道最小的序列和，之后再贪心的输出即可。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool below(long long p) &#123;</span><br><span class="line">	int d &#x3D; 0;</span><br><span class="line">	int beg &#x3D; 1;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">		if (sum[i] - sum[beg - 1] &gt; p) &#123;</span><br><span class="line">			d++;</span><br><span class="line">			beg &#x3D; i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (a[n] &gt; p) d++;</span><br><span class="line">	&#x2F;&#x2F;printf(&quot;%d\n&quot;, p);</span><br><span class="line">	if (d &lt;&#x3D; k - 1)</span><br><span class="line">		return true;</span><br><span class="line"></span><br><span class="line">	else  return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="solve-进行二分查找并贪心输出结果"><a class="markdownIt-Anchor" href="#solve-进行二分查找并贪心输出结果"></a> solve 进行二分查找，并贪心输出结果</h2>
<ol>
<li>主要是贪心过程，因为题干要求当最大值一样小的时候，要求输出S(i)较小的。所以贪心策略是从尾部开始插入隔板，这样保证头部尽量少留元素。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line">	bool cir;</span><br><span class="line">	memset(print, 0, sizeof(print));</span><br><span class="line">	while (mins &lt; maxs)</span><br><span class="line">	&#123;</span><br><span class="line">		int p &#x3D; (mins + maxs) &#x2F; 2;</span><br><span class="line">		cir &#x3D; below(p);</span><br><span class="line">		if (cir) maxs &#x3D; p;</span><br><span class="line">		else mins &#x3D; p + 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ans &#x3D; mins;</span><br><span class="line">	&#x2F;&#x2F;printf(&quot;ans &#x3D; %d\n&quot;, ans);</span><br><span class="line">	int s &#x3D; 0;</span><br><span class="line">	int need &#x3D; k;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; n; i &gt;&#x3D; 1; i--) &#123;</span><br><span class="line">		if (s + a[i] &gt; ans || i &lt; need) &#123;&#x2F;&#x2F;注意此处剩余插入位置i不能少于待插入隔板数</span><br><span class="line">			print[i] &#x3D; 1;</span><br><span class="line">			need--;</span><br><span class="line">			s &#x3D; a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		else s +&#x3D; a[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">		printf(&quot;%d &quot;, a[i]);</span><br><span class="line">		if (print[i]) printf(&quot;&#x2F; &quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;, a[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 500 + 5;</span><br><span class="line">int n, k;</span><br><span class="line">long long a[maxn];</span><br><span class="line">long long sum[maxn];</span><br><span class="line">int print[maxn];</span><br><span class="line">long long ans;</span><br><span class="line">long long maxs, mins;</span><br><span class="line"></span><br><span class="line">bool below(long long p);</span><br><span class="line">void solve();</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d %d&quot;, &amp;n, &amp;k);</span><br><span class="line">		mins &#x3D; -1;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%lld&quot;, &amp;a[i]);</span><br><span class="line">			mins &#x3D; max(mins, a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		sum[0] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			sum[i] &#x3D; sum[i - 1] + a[i];</span><br><span class="line">		maxs &#x3D; sum[n];</span><br><span class="line">		solve();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>括号序列</title>
    <url>/2020/03/30/%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="uva-1626-括号序列"><a class="markdownIt-Anchor" href="#uva-1626-括号序列"></a> UVA 1626 括号序列</h1>
<p>我们将正规括号序列定义如下：</p>
<ol>
<li>空序列是正规括号序列。</li>
<li>如果S是一个正规括号序列，那么(S)和[S]都是正规括号序列。</li>
<li>如果A和B都是正规括号序列，那么AB是一个正规括号序列。</li>
</ol>
<p>例如，下面这些序列都是正规括号序列：</p>
<p>(),[],(()),([]),()[],()[()]</p>
<p>而下面这些不是正规括号序列：</p>
<p>(,[,),)(,([)],([]</p>
<p>给你一些含有字符’(’,’)’,’[‘和’]'的括号序列。你需要找一个最短的正规括号序列，使给定括号序列作为一个子序列包含在其中。</p>
<p>输入描述：<br />
输入第一行为一个正整数，代表数据组数。每组数据内容见下文。这一行之后跟着一个空行，每两组数据中间也有一个空行。<br />
每组输入都为一行，最多包含100个括号（字符’(’,’)’,’[‘和’]’），每两个括号之间没有空格。</p>
<p>输出描述：<br />
对于每一组数据，格式必须符合如下：<br />
输出最短的括号序列，满足题目描述，并且每两个输出之间必须有一个空行分开（最后一行没有）。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>对于一个序列是否是正规序列，要考虑其中的所有字串，想到了递归。</li>
<li>设d(i,j)表示[i,j]构成正规序列至少需要增加多少括号，则
<ol>
<li>已知的边界时d(i,i)=1,d(i+1,i) = 0</li>
<li>对于每个状态d(i,j)，来源于字串的状态。当S[i]与S[j]能匹配时，d(i,j)=d(i+1,j-1)即字串的最少增加的序列数目；或者来自于字串分割之后总共至少需要的括号数。</li>
<li>真正的d(i,j)要取他们的最小值</li>
</ol>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="init-初始化边界"><a class="markdownIt-Anchor" href="#init-初始化边界"></a> init 初始化边界</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void init() &#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">		d[i+1][i] &#x3D; 0;</span><br><span class="line">		d[i][i] &#x3D; 1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="match-判断是否匹配"><a class="markdownIt-Anchor" href="#match-判断是否匹配"></a> match 判断是否匹配</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline bool match(char c, char c2) &#123;</span><br><span class="line">	if (c &#x3D;&#x3D; &#39;(&#39;&amp;&amp;c2 &#x3D;&#x3D; &#39;)&#39;) return true;</span><br><span class="line">	if (c &#x3D;&#x3D; &#39;[&#39;&amp;&amp;c2 &#x3D;&#x3D; &#39;]&#39;) return true;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dp-采用记忆化搜索"><a class="markdownIt-Anchor" href="#dp-采用记忆化搜索"></a> dp 采用记忆化搜索</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int dp(int i, int j) &#123;</span><br><span class="line">	if (i &gt; j) return 0;</span><br><span class="line">	if (i &#x3D;&#x3D; j) return 1;</span><br><span class="line">	if (vis[i][j]) return d[i][j];</span><br><span class="line">	vis[i][j] &#x3D; 1;</span><br><span class="line">	int&amp; ans &#x3D; d[i][j];</span><br><span class="line">	ans &#x3D; inf;</span><br><span class="line">	if (match(s[i], s[j]))</span><br><span class="line">		ans &#x3D; min(ans, dp(i + 1, j - 1));</span><br><span class="line"></span><br><span class="line">	for (int k &#x3D; i; k &lt;&#x3D; j - 1; k++)</span><br><span class="line">		ans &#x3D; min(ans, dp(i, k) + dp(k + 1, j));</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="print-打印思路与dp类似注意及时return"><a class="markdownIt-Anchor" href="#print-打印思路与dp类似注意及时return"></a> print 打印，思路与dp类似，注意及时return</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int dp(int i, int j) &#123;</span><br><span class="line">	if (i &gt; j) return 0;</span><br><span class="line">	if (i &#x3D;&#x3D; j) return 1;</span><br><span class="line">	if (vis[i][j]) return d[i][j];</span><br><span class="line">	vis[i][j] &#x3D; 1;</span><br><span class="line">	int&amp; ans &#x3D; d[i][j];</span><br><span class="line">	ans &#x3D; inf;</span><br><span class="line">	if (match(s[i], s[j]))</span><br><span class="line">		ans &#x3D; min(ans, dp(i + 1, j - 1));</span><br><span class="line"></span><br><span class="line">	for (int k &#x3D; i; k &lt;&#x3D; j - 1; k++)</span><br><span class="line">		ans &#x3D; min(ans, dp(i, k) + dp(k + 1, j));</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">void print(int i, int j) &#123;</span><br><span class="line">	if (i &gt; j) return;</span><br><span class="line">	if (i &#x3D;&#x3D; j) &#123;</span><br><span class="line">		if (s[i] &#x3D;&#x3D; &#39;(&#39; || s[i] &#x3D;&#x3D; &#39;)&#39;) printf(&quot;()&quot;);</span><br><span class="line">		if (s[i] &#x3D;&#x3D; &#39;[&#39; || s[i] &#x3D;&#x3D; &#39;]&#39;) printf(&quot;[]&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	int ans &#x3D; d[i][j];</span><br><span class="line">	if (match(s[i], s[j])) &#123;</span><br><span class="line">		if (ans &#x3D;&#x3D; d[i + 1][j - 1])</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;%c&quot;, s[i]);</span><br><span class="line">			print(i + 1, j - 1);</span><br><span class="line">			printf(&quot;%c&quot;, s[j]);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int k &#x3D; i; k &lt; j; k++)</span><br><span class="line">		if (ans &#x3D;&#x3D; d[i][k] + d[k + 1][j]) &#123;</span><br><span class="line">			print(i, k), print(k + 1, j);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d\n&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		memset(d, -1, sizeof(d));</span><br><span class="line">		fgets(s, maxn, stdin);</span><br><span class="line">		n &#x3D; strlen(s)-1;</span><br><span class="line">		init();</span><br><span class="line">		&#x2F;&#x2F;printf(&quot;%d\n&quot;, dp(0, n - 1));</span><br><span class="line">		dp(0, n-1);</span><br><span class="line">		print(0, n-1);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">		if (T) printf(&quot;\n&quot;);</span><br><span class="line">		getchar();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="刘老师代码-比我快好多qaq"><a class="markdownIt-Anchor" href="#刘老师代码-比我快好多qaq"></a> 刘老师代码 比我快好多QAQ</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">char S[maxn];</span><br><span class="line">int n, d[maxn][maxn];</span><br><span class="line"></span><br><span class="line">bool match(char a, char b) &#123;</span><br><span class="line">  return (a &#x3D;&#x3D; &#39;(&#39; &amp;&amp; b &#x3D;&#x3D; &#39;)&#39;) || (a &#x3D;&#x3D; &#39;[&#39; &amp;&amp; b &#x3D;&#x3D; &#39;]&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dp() &#123;</span><br><span class="line">  for(int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">    d[i+1][i] &#x3D; 0;</span><br><span class="line">    d[i][i] &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i &#x3D; n-2; i &gt;&#x3D; 0; i--)</span><br><span class="line">    for(int j &#x3D; i+1; j &lt; n; j++) &#123;</span><br><span class="line">      d[i][j] &#x3D; n;</span><br><span class="line">      if(match(S[i], S[j])) d[i][j] &#x3D; min(d[i][j], d[i+1][j-1]);</span><br><span class="line">      for(int k &#x3D; i; k &lt; j; k++)</span><br><span class="line">        d[i][j] &#x3D; min(d[i][j], d[i][k] + d[k+1][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print(int i, int j) &#123;</span><br><span class="line">  if(i &gt; j) return ;</span><br><span class="line">  if(i &#x3D;&#x3D; j) &#123;</span><br><span class="line">    if(S[i] &#x3D;&#x3D; &#39;(&#39; || S[i] &#x3D;&#x3D; &#39;)&#39;) printf(&quot;()&quot;);</span><br><span class="line">    else printf(&quot;[]&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  int ans &#x3D; d[i][j];</span><br><span class="line">  if(match(S[i], S[j]) &amp;&amp; ans &#x3D;&#x3D; d[i+1][j-1]) &#123;</span><br><span class="line">    printf(&quot;%c&quot;, S[i]); print(i+1, j-1); printf(&quot;%c&quot;, S[j]);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int k &#x3D; i; k &lt; j; k++)</span><br><span class="line">    if(ans &#x3D;&#x3D; d[i][k] + d[k+1][j]) &#123;</span><br><span class="line">      print(i, k); print(k+1, j);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void readline(char* S) &#123;</span><br><span class="line">  fgets(S, maxn, stdin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int T;</span><br><span class="line"></span><br><span class="line">  readline(S);</span><br><span class="line">  sscanf(S, &quot;%d&quot;, &amp;T);</span><br><span class="line">  readline(S);</span><br><span class="line"></span><br><span class="line">  while(T--) &#123;</span><br><span class="line">    readline(S);</span><br><span class="line">    n &#x3D; strlen(S) - 1;</span><br><span class="line">    memset(d, -1, sizeof(d));</span><br><span class="line">    dp();</span><br><span class="line">    print(0, n-1);</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    if(T) printf(&quot;\n&quot;);</span><br><span class="line">    readline(S);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>排序与检索</title>
    <url>/2020/03/30/%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%A3%80%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="归并排序-onlogn"><a class="markdownIt-Anchor" href="#归并排序-onlogn"></a> 归并排序 O(nlogn)</h1>
<h2 id="基本步骤"><a class="markdownIt-Anchor" href="#基本步骤"></a> 基本步骤</h2>
<ol>
<li>划分问题： 把序列分成元素个数尽量相等的两半</li>
<li>递归求解： 把两半元素分别排序</li>
<li>合并问题： 把两个有序表合并成一个</li>
</ol>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void merge_sort(int *A,int x,int y,int* T)&#123;</span><br><span class="line">if(y-x&gt;1)&#123;</span><br><span class="line">	int m &#x3D; x+(y-x)&#x2F;2;</span><br><span class="line">	int p &#x3D; x,q &#x3D; m,i &#x3D; x; </span><br><span class="line">	merge_sort(A,x,m,T);</span><br><span class="line">	merge_sort(A,m,y,T);</span><br><span class="line">	while(p&lt;m||q&lt;y)&#123;</span><br><span class="line">		if(q&gt;&#x3D;y||(p&lt;m&amp;&amp;A[p]&lt;A&#x3D;[q]))</span><br><span class="line">		&#x2F;&#x2F;如果右侧表为空而左表非空或者左表元素小于右表元素，那么将左表复制到临时表</span><br><span class="line">			T[i++] &#x3D; A[p++];</span><br><span class="line">		else&#123;</span><br><span class="line">			 T[i++] &#x3D; A[q++];</span><br><span class="line">			 &#x2F;&#x2F;cnt+&#x3D;m-p;	可以统计逆序对的个数</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for(i &#x3D; x;i&lt;y;i++) A[i] &#x3D; T[i]; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>加入cnt+=m-p可以统计序列中逆序对的个数。这是因为合并的时候是按从小到大的顺序进行，当执行else语句时，说明此时右侧元素更小，此时左边还没来得及复制的元素就是左边所有比A[j]大的数，m-p即为他的个数。</li>
</ol>
<h1 id="快速排序-onlogn"><a class="markdownIt-Anchor" href="#快速排序-onlogn"></a> 快速排序 O(nlogn)</h1>
<ol>
<li>划分问题： 把数组的各个元素重排后分成左右两部分，使得左边的任意元素都小于或等于右边的任意元素</li>
<li>递归求解： 把左右两部分分别划分</li>
<li>合并问题： 不用合并，因为此时数组已经完全有序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void QSort( SqList &amp;L,  int  low,  int high) &#123;</span><br><span class="line">   if( low &lt; high)&#123;</span><br><span class="line">          pivotloc &#x3D; Partition( L, low, high);</span><br><span class="line">          QSort( L, low, pivotloc – 1);</span><br><span class="line">          QSort( L, pivotloc + 1, high);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Partition( SqList &amp;L,  int low,  int high)</span><br><span class="line">&#123; </span><br><span class="line">   L.r[0] &#x3D; L.r[low];</span><br><span class="line">   pivotkey &#x3D; L.r[low].key;</span><br><span class="line">   while( low &lt; high)&#123;</span><br><span class="line">        while( low &lt; high &amp;&amp; L.r[high].key &gt;&#x3D; pivotkey)  --high;</span><br><span class="line">        L.r[low] &#x3D; L.r[high];</span><br><span class="line">        while( low &lt; high &amp;&amp; L.r[low].key &lt;&#x3D; pivotkey)  ++low;</span><br><span class="line">        L.r[high] &#x3D; L.r[low];</span><br><span class="line">   &#125;</span><br><span class="line">   L.r[low] &#x3D; L.r[0];   </span><br><span class="line">   return low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>可以解决的问题：选择出第k大的数。序列划分成A[low,pivotkey]和A[pivotkey+1,high]两部分，比较左侧元素个数q-p+1和k的大小关系，选择在左半部递归还是在右半部递归。</li>
</ol>
<h1 id="二分查找-适用于有序序列"><a class="markdownIt-Anchor" href="#二分查找-适用于有序序列"></a> 二分查找 适用于有序序列</h1>
<ol>
<li>划分问题： 将序列分成尽量相等的两份</li>
<li>递归求解： 在左半部分或者右半部分搜素</li>
<li>合并问题： 无需合并</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">迭代(常用)</span><br><span class="line">int bsearch(int* A,int x,int y,int v)&#123;</span><br><span class="line">while(x&lt;y)&#123;</span><br><span class="line">	m &#x3D; x + (y-x)&#x2F;2;</span><br><span class="line">	if(A[m]&#x3D;&#x3D;v) return m;</span><br><span class="line">	else if(A[m]&gt;v) y &#x3D; m;</span><br><span class="line">	else x &#x3D; m+1;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>递归
int bsearch(int r,int l){
int m = r+(l-r)/2;
if(A[m]==goal) return m;
else if(goal&lt;A[m])
	return bsearch(r,m);
else return bsearch(m+1,l);
}
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 考虑新问题：</span><br><span class="line">如果数组中有多个goal，如果返回目标值的完整区间(上例程序返回中间那一个的索引)</span><br></pre></td></tr></table></figure>
<pre><code>int lower_bound(int* A,int x,int y,int v){
int m;
while(x&lt;y){
	m = x + (y-x)/2;
	if(A[m]&gt;=v) y = m;
	else x = m+1;
}
return x;
}
</code></pre>
<ol>
<li>上述程序返回v的第一个出现位置或者是返回一个下标i，在i处插入v，后面的序列仍然有序。</li>
<li>虽然搜索的区间是[x,y)，但是v可能比A[y-1]要大，所以返回值的取值范围在[x,y]。A[m]和v的关系的影响包括：
<ol>
<li>A[m]==v 时，至少找到了一个，但是左边可能还有，搜索区间变成[x,m]</li>
<li>A[m]&gt;v 时，所求位置不可能在后面，但可能是m，因此区间变成[x,m]</li>
<li>A[m]&lt;v 时，区间变成[m+1,y]</li>
</ol>
</li>
<li>相应的可以写出upper_bound，共同构成	[L,R)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int upper_bound(int* A,int x,int y,int v)&#123;</span><br><span class="line">int m;</span><br><span class="line">while(x&lt;y)&#123;</span><br><span class="line">	m &#x3D; x+(y-x)&#x2F;2;</span><br><span class="line">	if(A[m]&lt;&#x3D;v) x &#x3D; m+1;</span><br><span class="line">	else y &#x3D; m;</span><br><span class="line">&#125;</span><br><span class="line">return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="递归与分支"><a class="markdownIt-Anchor" href="#递归与分支"></a> 递归与分支</h1>
<h2 id="棋盘覆盖问题"><a class="markdownIt-Anchor" href="#棋盘覆盖问题"></a> 棋盘覆盖问题</h2>
<p>有一个2<sup>k</sup>×2<sup>k</sup>的方格棋盘，恰有一个方格是黑色的，其他是白色的。你的任务是用包含3个方格的L型牌覆盖所有白色方格。黑色方格不能被覆盖，且任意一个白色方格不能同时被两个或更多牌覆盖。问至少要用多少L型牌。</p>
<h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3>
<ol>
<li>分治法，每次将棋盘分割成4块，每块都是2<sup>k-1</sup>×2<sup>k-1</sup>。</li>
<li>对于有黑格子的块使用递归解决，没有黑格子的块构造出一个黑格子。</li>
</ol>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;（tr,tc)表示棋盘左上角坐标 (dr,dc)表示黑块坐标</span><br><span class="line">void ChessBoard(int tr,int tc,int dr,int dc,int size)</span><br><span class="line">&#123;</span><br><span class="line">    if(size&#x3D;&#x3D;1) return;</span><br><span class="line">    int t&#x3D;tile++,s&#x3D;size&#x2F;2;</span><br><span class="line"></span><br><span class="line">    if(dr&lt;tr+s &amp;&amp; dc&lt;tc+s)&#x2F;&#x2F;&#x2F;在左上角区域内</span><br><span class="line">    	ChessBoard(tr,tc,dr,dc,s);</span><br><span class="line">    else&#x2F;&#x2F;&#x2F;不在左上角区域内</span><br><span class="line">    &#123;</span><br><span class="line">        Board[tr+s-1][tc+s-1]&#x3D;t;&#x2F;&#x2F;&#x2F;用t号(用一个数字表示)L型骨牌覆盖右下角</span><br><span class="line">        ChessBoard(tr,tc,tr+s-1,tc+s-1,s);&#x2F;&#x2F;&#x2F;覆盖剩余方格</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(dr&lt;tr+s &amp;&amp; dc&gt;&#x3D;tc+s)&#x2F;&#x2F;&#x2F;在右上角区域内</span><br><span class="line">        ChessBoard(tr,tc+s,dr,dc,s);</span><br><span class="line">    else&#x2F;&#x2F;&#x2F;不在右上角的区域内</span><br><span class="line">    &#123;</span><br><span class="line">        Board[tr+s-1][tc+s]&#x3D;t;</span><br><span class="line">        ChessBoard(tr,tc+s,tr+s-1,tc+s,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(dr&gt;&#x3D;tr+s &amp;&amp; dc&lt;tc+s)</span><br><span class="line">        ChessBoard(tr+s,tc,dr,dc,s);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Board[tr+s][tc+s-1]&#x3D;t;</span><br><span class="line">        ChessBoard(tr+s,tc,tr+s,tc+s-1,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(dr&gt;&#x3D;tr+s &amp;&amp; dc&gt;&#x3D;tc+s)</span><br><span class="line">        ChessBoard(tr+s,tc+s,dr,dc,s);</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Board[tr+s][tc+s]&#x3D;t;</span><br><span class="line">        ChessBoard(tr+s,tc+s,tr+s,tc+s,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环日程表问题"><a class="markdownIt-Anchor" href="#循环日程表问题"></a> 循环日程表问题</h2>
<p>有n=2<sup>k</sup>个运动员进行网球循环赛，需要设计比赛日程表。每个选手必须与其他n-1个选手各赛一次：每个选手每天只能赛一次，循环赛一共进行n-1天。按此要求设计一张比赛日程表，该表用n行和n-1列，第i行j列为第i个选手第j天遇到的选手。</p>
<h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3>
<ol>
<li>观察紫书P230页给出的样例结果，发现结果是对称矩阵，且每一个小块处都是对称的，所以考虑使用分治法。</li>
</ol>
<h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; (1 &lt;&lt; 10);</span><br><span class="line">int table[maxn][maxn];</span><br><span class="line">void fill(int x, int y, int n);&#x2F;&#x2F;填充左上角为x,y的，长度为n的方格</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	table[0][0] &#x3D; 1;</span><br><span class="line">	fill(0, 0, n);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">			printf(&quot;%d &quot;, table[i][j]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void fill(int x, int y, int n) &#123;</span><br><span class="line">	if (n &#x3D;&#x3D; 1) return;</span><br><span class="line">	int half &#x3D; n &#x2F; 2;</span><br><span class="line"></span><br><span class="line">	table[x + half][y + half] &#x3D; table[x][y];</span><br><span class="line">	table[x + half][y] &#x3D; table[x][y + half] &#x3D; table[x][y] + half;</span><br><span class="line">	fill(x, y, half);</span><br><span class="line">	fill(x + half, y, half);</span><br><span class="line">	fill(x, y + half, half);</span><br><span class="line">	fill(x + half, y + half, half);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="巨人与鬼"><a class="markdownIt-Anchor" href="#巨人与鬼"></a> 巨人与鬼</h2>
<p>在平面上有n个巨人和n个鬼，没有三者在同一条直线上。每个巨人需要选择一个不同的鬼，向其发送质子流消灭它，质子流呈直线。质子流不能交叉，要求设计一种巨人和鬼的配对方法。</p>
<h3 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h3>
<ol>
<li>使用分治法，以连线两侧内的巨人和鬼的数量相等来分割，然后递归解决。</li>
<li>考虑最左下角的点，假设它是一个巨人，然后将其余的点按照极角从小到大排列依次检查
<ol>
<li>如果第一个点是鬼，则匹配完成，剩下的鬼和巨人一样多</li>
<li>如果第一个点是巨人，那么继续检查知道鬼和巨人一样多。</li>
<li>以这个连线为分界，分割问题，递归解决。</li>
</ol>
</li>
</ol>
<h3 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">struct node &#123;</span><br><span class="line">int x, y, flag, id;</span><br><span class="line">&#125;;</span><br><span class="line">node p[1000], base;</span><br><span class="line">int ans[1000];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void go(int l, int r);&#x2F;&#x2F;在数组中的左右边界</span><br><span class="line">bool cmp1(node &amp;a, node&amp;b) &#123; return a.y &lt; b.y || a.y &#x3D;&#x3D; b.y&amp;&amp;a.x &lt; b.x; &#125;</span><br><span class="line">bool cmp2(node &amp;a, node &amp;b) &#123;</span><br><span class="line">	return atan2((a.y - base.y), (a.x - base.x)) &lt; atan2((b.y - base.y), (b.x - base.x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int T;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">while (T--)</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d %d %d&quot;, &amp;p[i].flag, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line">		p[i].id &#x3D; i + 1;</span><br><span class="line">	&#125;</span><br><span class="line">	go(0, n - 1);</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D;n; i++)</span><br><span class="line">		printf(&quot;%d &quot;, ans[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void go(int l, int r) &#123;</span><br><span class="line">if (l &gt; r)</span><br><span class="line">	return;</span><br><span class="line">sort(p + l, p + r + 1, cmp1);</span><br><span class="line">base &#x3D; p[l];</span><br><span class="line">sort(p + l + 1, p + r + 1, cmp2);</span><br><span class="line">int c1 &#x3D; 0, c2 &#x3D; 0;</span><br><span class="line">int k &#x3D; r;</span><br><span class="line">while (!(p[k].flag !&#x3D; base.flag&amp;&amp;c1 &#x3D;&#x3D; c2))</span><br><span class="line">&#123;</span><br><span class="line">	if (p[k].flag &#x3D;&#x3D; base.flag) c1++;&#x2F;&#x2F;巨人</span><br><span class="line">	else c2++;</span><br><span class="line">	k--;</span><br><span class="line">&#125;</span><br><span class="line">ans[p[k].id] &#x3D; base.id;</span><br><span class="line">ans[base.id] &#x3D; p[k].id;</span><br><span class="line">go(l + 1, k - 1);</span><br><span class="line">go(k + 1, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="贪心法"><a class="markdownIt-Anchor" href="#贪心法"></a> 贪心法</h1>
<h2 id="乘船问题"><a class="markdownIt-Anchor" href="#乘船问题"></a> 乘船问题</h2>
<p>第一行输入s,表示测试数据的组数；<br />
每组数据的第一行包括两个整数w，n，80&lt;=w&lt;=200,1&lt;=n&lt;=300，w为一条独木舟的最大承载量,n为人数；<br />
接下来的一组数据为每个人的重量（不能大于船的承载量）；<br />
输出<br />
每组人数所需要的最少独木舟的条数。</p>
<h3 id="思路-4"><a class="markdownIt-Anchor" href="#思路-4"></a> 思路</h3>
<ol>
<li>贪心法：给最轻的人i找最重j的匹配，如果仍然超重，那么这个重人只能单独坐船。</li>
<li>证明：使用反证法
<ol>
<li>如果目前i单独乘船，那么令j和他同乘不会使总的乘船数量增多。</li>
<li>如果目前i和k同乘，那么根据假设，k应该比j轻，那么k和j交换之后k所在的船仍然不会超重。按照贪心法的过程，交换后j所在船也不会超重。</li>
<li>因此，这样贪心不会丢失最优解</li>
</ol>
</li>
</ol>
<h3 id="代码-5"><a class="markdownIt-Anchor" href="#代码-5"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 305;</span><br><span class="line">int weight[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int T, c, n;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">while (T--)</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d %d&quot;, &amp;c, &amp;n);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;weight[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int l &#x3D; 0, r &#x3D; n - 1;</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	sort(weight, weight + n);</span><br><span class="line">	while (l &lt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		if (weight[l] + weight[r] &lt;&#x3D; c)</span><br><span class="line">			l++;</span><br><span class="line">		ans++;</span><br><span class="line">		r--;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择不相交区间"><a class="markdownIt-Anchor" href="#选择不相交区间"></a> 选择不相交区间</h2>
<p>输入n个区间，从中选出尽量多的不相交区间。</p>
<h3 id="思路-5"><a class="markdownIt-Anchor" href="#思路-5"></a> 思路</h3>
<ol>
<li>
<p>首先，最明显的是如果区间A完全包含于区间B，那么应该选择区间A。所以贪心的策略是一定要选择第一个区间</p>
</li>
<li>
<p>证明： 首先对区间进行排序，b已经有序，观察a的关系</p>
<ol>
<li>如果a1&gt;a2，那么区间2包含了区间1，则应该选择区间1(依据1中讨论),并且以后的所有选中的区间i都要满足a1&lt;ai</li>
<li>在1的条件下，则a也有序。如果区间2和区间1完全不相交，那么没有影响；否则区间1和区间2只能保留一个。</li>
<li>考虑临近的区间3，区间1和区间3的重叠部分被区间2所包含，根据1中讨论，应该保留区间1。这也就说明不能因为其他区间的影响而不选择区间1，所以贪心策略成立。</li>
</ol>
</li>
<li>
<p>选择区间1后要把所有和区间1相交的区间排除在外，需要记录上一个被选择的区间编号。</p>
</li>
</ol>
<h3 id="代码-6"><a class="markdownIt-Anchor" href="#代码-6"></a> 代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line">node p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node &amp;a, node &amp;b)</span> </span>&#123; <span class="keyword">return</span> a.b &lt; b.b; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;p[i].a, &amp;p[i].b);</span><br><span class="line">		<span class="keyword">if</span> (p[i].a &gt; p[i].b)</span><br><span class="line">			swap(p[i].a, p[i].b);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(p, p + n, cmp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> l = p[<span class="number">0</span>].b;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p[i].a &gt; l) &#123;</span><br><span class="line">			ans++;</span><br><span class="line">			l = p[i].a;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"ans: %d\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间选点问题"><a class="markdownIt-Anchor" href="#区间选点问题"></a> 区间选点问题</h2>
<p>在数轴上有n个闭区间[a,b]，要求去尽量少的点，使得每个区间内都有至少一个点</p>
<h3 id="思路-6"><a class="markdownIt-Anchor" href="#思路-6"></a> 思路</h3>
<ol>
<li>如果区间1被区间2完全包含，那么在区间1内取的点必定在区间2中。</li>
<li>如果区间1和区间2部分相交，且区间2在后面，那么在区间1的尾部取点最可能在区间2中。</li>
<li>所以贪心策略是取最后一个点</li>
<li>所以首先对b进行排序，每次取最后一个点，如果某个区间的起始点超过了最后一个点的坐标，那么要更新最后一个点的位置。</li>
</ol>
<h3 id="代码-7"><a class="markdownIt-Anchor" href="#代码-7"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 1005;</span><br><span class="line">struct node &#123;</span><br><span class="line">int a, b;</span><br><span class="line">bool operator &lt; (const node &amp;x)const &#123; return b &lt; x.b || b &#x3D;&#x3D; x.b&amp;&amp;a &lt; x.a; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node p[maxn];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;n)&#x3D;&#x3D;1)</span><br><span class="line">&#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d %d&quot;, &amp;p[i].a, &amp;p[i].b);</span><br><span class="line">		if (p[i].a &gt; p[i].b)</span><br><span class="line">			swap(p[i].a, p[i].b);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(p, p + n);</span><br><span class="line">	int r &#x3D; -1;&#x2F;&#x2F;此处也可以设置为p[0].b，同时ans&#x3D;1</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (p[i].a &gt; r) &#123;</span><br><span class="line">			ans++;</span><br><span class="line">			r &#x3D; p[i].b;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;ans: %d\n&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间覆盖问题"><a class="markdownIt-Anchor" href="#区间覆盖问题"></a> 区间覆盖问题</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1005;</span><br><span class="line">int n;</span><br><span class="line">struct node &#123;</span><br><span class="line">int a, b;</span><br><span class="line">bool operator &lt; (const node &amp;x)const &#123; return a &lt; x.a || a &#x3D;&#x3D; x.a &amp;&amp; b&gt;x.b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node p[maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">int T;</span><br><span class="line">int s, t;</span><br><span class="line">s &#x3D; 0;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">while (T--)</span><br><span class="line">&#123;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">	n &#x3D; 0;</span><br><span class="line">	while (scanf(&quot;%d %d&quot;, &amp;p[n].a, &amp;p[n].b) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">		if (p[n].a &#x3D;&#x3D; 0 &amp;&amp; p[n].b &#x3D;&#x3D; 0)</span><br><span class="line">			break;</span><br><span class="line">		if (p[n].a &gt; p[n].b)</span><br><span class="line">			swap(p[n].a, p[n].b);</span><br><span class="line">		if (p[n].b &lt; t || p[n].b &lt; s) continue;</span><br><span class="line">		p[n].a &#x3D; max(p[n].a, s);</span><br><span class="line">		p[n].b &#x3D; min(p[n].b, t);</span><br><span class="line">		if (p[n].a &lt; p[n].b)</span><br><span class="line">			n++;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(p, p + n);</span><br><span class="line">	if (!n||p[0].a !&#x3D; s)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;ans: 0\n&quot;);</span><br><span class="line">		continue;</span><br><span class="line">	&#125;</span><br><span class="line">	int r &#x3D; s;</span><br><span class="line">	int ans &#x3D;0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (p[i].b &gt; r) &#123;</span><br><span class="line">			r &#x3D; p[i].b;</span><br><span class="line">			ans++;</span><br><span class="line">			printf(&quot;%d %d\n&quot;, p[i].a, p[i].b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;ans: %d\n\n&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="huffman-编码"><a class="markdownIt-Anchor" href="#huffman-编码"></a> Huffman 编码</h2>
<h3 id="huffman-树"><a class="markdownIt-Anchor" href="#huffman-树"></a> Huffman 树</h3>
<ol>
<li>n个叶子的二叉树一定对应一个前缀码。如果编码a是编码b的前缀，则a所对应的结点一定为b所对应节点的先祖，而两个叶子不会有先祖后代的关系。</li>
<li>最优前缀码一定可以写成二叉树</li>
</ol>
<h3 id="huffman-算法-onlogn"><a class="markdownIt-Anchor" href="#huffman-算法-onlogn"></a> Huffman 算法 O(nlogn)</h3>
<p>把每个字符看作一个单结点子树放在一个树集合中，每颗子树的权值等于相应字符的频率。每次取权值最小的两颗紫书合并成一颗新树，并重新放到集合中。新树的权值等于两颗子树权值之和。</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2020/06/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1>
<h2 id="基本特征"><a class="markdownIt-Anchor" href="#基本特征"></a> 基本特征</h2>
<h3 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h3>
<ol>
<li><strong>并发</strong>是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令</li>
<li>硬件上需要多流水线，多核处理器或者分布式计算机系统</li>
<li>操作系统上需要引入进程和线程，使得程序能够并发执行</li>
</ol>
<h3 id="共享"><a class="markdownIt-Anchor" href="#共享"></a> 共享</h3>
<ol>
<li>包括互斥共享和同时共享</li>
</ol>
<h3 id="虚拟"><a class="markdownIt-Anchor" href="#虚拟"></a> 虚拟</h3>
<ol>
<li><strong>虚拟技术</strong>：把一个物理实体转换为多个逻辑实体</li>
<li><strong>主要技术</strong>包括：
<ol>
<li>时分复用技术：多个进程再同一个处理器上并发执行，每个进程轮流占用处理器</li>
<li>空分复用技术：如虚拟内存技术。将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</li>
</ol>
</li>
</ol>
<h3 id="异步"><a class="markdownIt-Anchor" href="#异步"></a> 异步</h3>
<p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p>
<h2 id="基本功能"><a class="markdownIt-Anchor" href="#基本功能"></a> 基本功能</h2>
<h3 id="进程管理"><a class="markdownIt-Anchor" href="#进程管理"></a> 进程管理</h3>
<p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p>
<h3 id="内存管理"><a class="markdownIt-Anchor" href="#内存管理"></a> 内存管理</h3>
<p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p>
<h3 id="文件管理"><a class="markdownIt-Anchor" href="#文件管理"></a> 文件管理</h3>
<p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p>
<h3 id="设备管理"><a class="markdownIt-Anchor" href="#设备管理"></a> 设备管理</h3>
<p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p>
<p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p>
<h2 id="大内核和微内核"><a class="markdownIt-Anchor" href="#大内核和微内核"></a> 大内核和微内核</h2>
<img src="/MyImages/image-20200410143512321.png" alt="image-20200410143512321" style="zoom:80%;" />
<h3 id="大内核"><a class="markdownIt-Anchor" href="#大内核"></a> 大内核</h3>
<p>大内核是将操作系统功能作为一个紧密结合的整体放到内核。</p>
<p>由于各模块共享信息，因此有很高的性能。</p>
<h3 id="微内核"><a class="markdownIt-Anchor" href="#微内核"></a> 微内核</h3>
<p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p>
<p>在微内核结构下，操作系统被划分成小的、定义良好的模块，<strong>只有微内核这一个模块运行在内核态，其余模块运行在用户态。</strong></p>
<p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p>
<h2 id="中断分类"><a class="markdownIt-Anchor" href="#中断分类"></a> 中断分类</h2>
<ul>
<li>
<p>中断”是让操作系统内核夺回CPU使用权的唯一途径</p>
</li>
<li>
<p>过程：</p>
<ul>
<li>内核态-&gt;用户态：执行一条特权指令——修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权</li>
<li>用户态-&gt;内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权</li>
</ul>
</li>
<li>
<p>分类</p>
<img src="/MyImages/image-20200410132435683.png" alt="image-20200410132435683" style="zoom: 80%;" />
<ul>
<li>内中断比如除0；有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令——陷入指令，该指令会引发一个内部中断信号</li>
<li>外中断比如时钟中断</li>
</ul>
<img src="/MyImages/image-20200410142357027.png" alt="image-20200410142357027" style="zoom: 80%;" />
</li>
<li>
<p>基本原理:不同的中断信号，需要用不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置。</p>
</li>
</ul>
<h2 id="系统调用"><a class="markdownIt-Anchor" href="#系统调用"></a> 系统调用</h2>
<ul>
<li>
<p><strong>什么时候用到系统调</strong>用：系统中的各种共享资源都由操作系统内核统一掌管，因此<strong>凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式</strong>向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</p>
</li>
<li>
<p>分类</p>
<p><img src="/MyImages/image-20200410142827633.png" alt="image-20200410142827633" /></p>
</li>
<li>
<p>系统调用过程</p>
<ul>
<li>
<p>程序执行陷入指令</p>
</li>
<li>
<p>引发内中断：该中断由陷入指令 引发，因此转入相 应的中断处理程 序——即 系统调用 的入口程序</p>
</li>
<li>
<p>根据寄存器中的参数判断用户需要那种系统调用服务</p>
</li>
<li>
<p>传递系统调用参数</p>
<p>-&gt; 执行陷入指令（用户态）</p>
<p>-&gt; 执行相应的内请求核程序处理系统调用（核心态）</p>
<p>-&gt;  返回应用程序</p>
</li>
</ul>
</li>
</ul>
<h1 id="进程管理-2"><a class="markdownIt-Anchor" href="#进程管理-2"></a> 进程管理</h1>
<h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2>
<ul>
<li>
<p>进程的组成：</p>
<ul>
<li>
<p><strong>PCB 进程控制块</strong>，但凡管理时所需要的信息，都会被放在PCB中</p>
<img src="/MyImages/image-20200410143922690.png" alt="image-20200410143922690" style="zoom:80%;" />
<p><strong>PCB 是给操作系统用的。</strong></p>
</li>
<li>
<p><strong>程序段、数据段</strong>是给进程自己用的。</p>
</li>
</ul>
</li>
<li>
<p>**进程实体（进程映像）**由PCB、程序段、数据段组成。进程是动态的，进程实体（进程映像）是静态的。</p>
</li>
<li>
<p><strong>进程的特征</strong></p>
<p><img src="/MyImages/image-20200410144454179.png" alt="image-20200410144454179" /></p>
</li>
</ul>
<h2 id="进程和线程"><a class="markdownIt-Anchor" href="#进程和线程"></a> 进程和线程</h2>
<h3 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h3>
<p><strong>进程是资源分配的基本单位。</strong></p>
<p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p>
<h3 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h3>
<p><strong>线程是独立调度的基本单位</strong></p>
<p>一个进程中可以有<strong>多个线程</strong>，它们<strong>共享进程资源。</strong></p>
<p>QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p>
<h3 id="区别"><a class="markdownIt-Anchor" href="#区别"></a> 区别</h3>
<ol>
<li>
<p>资源</p>
<p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p>
</li>
<li>
<p>调度</p>
<p><strong>线程是独立调度的基本单位</strong>，在<strong>同一进程中，线程的切换不会引起进程切换</strong>，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p>
</li>
<li>
<p>系统开销</p>
<p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p>
</li>
<li>
<p>通信方面</p>
<p><strong>线程</strong>间<strong>可以通过直接读写同一进程中的数据进行通信</strong>，但是进程通信需要借助 IPC。</p>
</li>
</ol>
<h2 id="进程的组织形式"><a class="markdownIt-Anchor" href="#进程的组织形式"></a> 进程的组织形式</h2>
<img src="/MyImages/image-20200410150055787.png" alt="image-20200410150055787" style="zoom:80%;" />
<ul>
<li>
<p>链接方式</p>
<img src="/MyImages/image-20200410150137085.png" alt="image-20200410150137085" style="zoom:80%;" />
</li>
<li>
<p>索引方式</p>
<img src="/MyImages/image-20200410150259354.png" alt="image-20200410150259354" style="zoom:80%;" />
</li>
</ul>
<h2 id="进程控制"><a class="markdownIt-Anchor" href="#进程控制"></a> 进程控制</h2>
<h3 id="进程状态的切换"><a class="markdownIt-Anchor" href="#进程状态的切换"></a> 进程状态的切换</h3>
<img src="/MyImages/image-20200410150355564.png" alt="image-20200410150355564" style="zoom:80%;" />
<p>注意：</p>
<ol>
<li>
<p><strong>只有就绪态和运行态可以相互转换</strong>，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</p>
</li>
<li>
<p><strong>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间</strong>，缺少 CPU 时间会从运行态转换为就绪态。</p>
</li>
<li>
<p>实现进程控制—原语</p>
<ul>
<li>
<p>原语是一种特殊的程序， 它的执行具有原子性。 也就是说，这段程序的 运行必须一气呵成，<strong>不可中断</strong></p>
</li>
<li>
<p>如果不能“一气呵成”，就有可能导致操作系</p>
<p>统中的某些关键数据结构信息不统一的情况，</p>
<p>这会影响操作系统进行别的管理工作</p>
</li>
</ul>
</li>
<li>
<p><strong>原语</strong></p>
<ul>
<li>原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断。 可以用 <strong>“关中断指令”和“开中断指令”<strong>这两个特权指令</strong>实现原子性</strong></li>
</ul>
</li>
</ol>
<h3 id="进程控制原语"><a class="markdownIt-Anchor" href="#进程控制原语"></a> 进程控制原语</h3>
<p><img src="/MyImages/image-20200410151119920.png" alt="image-20200410151119920" /></p>
<p><img src="/MyImages/image-20200410151130433.png" alt="image-20200410151130433" /></p>
<p><img src="/MyImages/image-20200410151140239.png" alt="image-20200410151140239" /></p>
<img src="/MyImages/image-20200410151152896.png" alt="image-20200410151152896" style="zoom: 67%;" />
<h2 id="进程调度"><a class="markdownIt-Anchor" href="#进程调度"></a> 进程调度</h2>
<h3 id="进程调度算法"><a class="markdownIt-Anchor" href="#进程调度算法"></a> 进程调度算法</h3>
<h4 id="批处理系统"><a class="markdownIt-Anchor" href="#批处理系统"></a> 批处理系统</h4>
<ol>
<li><strong>先来先服务</strong>：利于长作业，而不利于短作业</li>
<li><strong>短作业优先</strong>：非抢占式调度，按估计的运行时间最短顺序调度；利于短作业，不利于长作业。</li>
<li><strong>最短剩余时间优先</strong>：抢占式的最短作业优先。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</li>
</ol>
<h4 id="交互式系统"><a class="markdownIt-Anchor" href="#交互式系统"></a> 交互式系统</h4>
<ol>
<li>
<p><strong>时间片轮转</strong>：实际的效率与时间片的大小有很大关系</p>
<ol>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果<strong>时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间</strong>。</li>
<li>而如果时间片过长，那么实时性就不能得到保证。</li>
</ol>
</li>
<li>
<p><strong>优先级调度</strong>：为每个进程分配一个优先级，按优先级进行调度。</p>
<p><strong>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</strong></p>
</li>
<li>
<p><strong>多级反馈队列</strong></p>
<img src="/MyImages/image-20200604234940574.png" alt="image-20200604234940574" style="zoom: 67%;" />
<p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,…。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p>
<p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p>
</li>
</ol>
<h4 id="实时系统"><a class="markdownIt-Anchor" href="#实时系统"></a> 实时系统</h4>
<p>实时系统要求一个请求在一个确定时间内得到响应。</p>
<p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<h2 id="进程同步"><a class="markdownIt-Anchor" href="#进程同步"></a> 进程同步</h2>
<h3 id="临界区"><a class="markdownIt-Anchor" href="#临界区"></a> 临界区</h3>
<p>对临界资源进行访问的那段代码称为临界区。</p>
<p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p>
<h3 id="同步与互斥"><a class="markdownIt-Anchor" href="#同步与互斥"></a> 同步与互斥</h3>
<ul>
<li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li>
</ul>
<h3 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h3>
<p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
<ul>
<li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>
<li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>
</ul>
<p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p>
<h3 id="管程"><a class="markdownIt-Anchor" href="#管程"></a> 管程</h3>
<ul>
<li>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而<strong>管程把控制的代码独立出来</strong>，不仅不容易出错，也使得客户端代码调用更容易。</li>
<li>管程有一个重要特性：**在一个时刻只能有一个进程使用管程。**进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</li>
<li>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</li>
</ul>
<h3 id="经典同步问题"><a class="markdownIt-Anchor" href="#经典同步问题"></a> 经典同步问题</h3>
<h4 id="哲学家问题"><a class="markdownIt-Anchor" href="#哲学家问题"></a> 哲学家问题</h4>
<p>为了防止死锁的发生，可以设置两个条件：</p>
<ul>
<li>必须同时拿起左右两根筷子；</li>
<li>只有在两个邻居都没有进餐的情况下才允许进餐。</li>
</ul>
<h4 id="读者-写者问题"><a class="markdownIt-Anchor" href="#读者-写者问题"></a> 读者-写者问题</h4>
<ul>
<li>
<p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p>
</li>
<li>
<p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(&amp;data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">        <span class="built_in">read</span>();</span><br><span class="line">        down(&amp;count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(&amp;data_mutex);</span><br><span class="line">        up(&amp;count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(&amp;data_mutex);</span><br><span class="line">        <span class="built_in">write</span>();</span><br><span class="line">        up(&amp;data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进程通信"><a class="markdownIt-Anchor" href="#进程通信"></a> 进程通信</h2>
<p><img src="/MyImages/image-20200410151426847.png" alt="image-20200410151426847" /></p>
<h3 id="进程通信-进程同步"><a class="markdownIt-Anchor" href="#进程通信-进程同步"></a> 进程通信 &amp; 进程同步</h3>
<p>进程同步与进程通信很容易混淆，它们的区别在于：</p>
<ul>
<li>进程同步：控制多个进程按一定顺序执行；</li>
<li>进程通信：进程间传输信息。</li>
</ul>
<p><strong>进程通信是一种手段，而进程同步是一种目的</strong>。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p>
<h3 id="管道"><a class="markdownIt-Anchor" href="#管道"></a> 管道</h3>
<p>它具有以下限制：</p>
<ul>
<li>只支持半双工通信（单向交替传输）；</li>
<li><strong>只能在父子进程或者兄弟进程中使用</strong>。</li>
<li>各进程要<strong>互斥</strong>地访问管道。</li>
<li>数据以<strong>字符流</strong>的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据<strong>全部取走后</strong>，管道变空，此时读进程的read()系统调用将被阻塞。</li>
<li><strong>如果没写满，就不允许读。如果没读空，就不允许写</strong>。</li>
<li><strong>数据一旦被读出，就从管道中被抛弃</strong>，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。</li>
</ul>
<h3 id="fifo"><a class="markdownIt-Anchor" href="#fifo"></a> FIFO</h3>
<ul>
<li>又称有名管道</li>
<li>FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。</li>
</ul>
<h3 id="消息队列"><a class="markdownIt-Anchor" href="#消息队列"></a> 消息队列</h3>
<ul>
<li>进程间的数据交换以<strong>格式化的消息</strong>（Message）为单位。进程通过操作系统提供的“<strong>发送消息/接收消息</strong>”两个<strong>原语</strong>进行数据交换</li>
</ul>
<ul>
<li>消息队列<strong>可以独立于读写进程存在</strong>，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>
<li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；</li>
<li><strong>读进程可以根据消息类型有选择地接收消息</strong>，而不像 FIFO 那样只能默认地接收。</li>
</ul>
<h3 id="信号量-2"><a class="markdownIt-Anchor" href="#信号量-2"></a> 信号量</h3>
<p><strong>它是一个计数器</strong>，用于为多个进程提供对共享数据对象的访问。</p>
<h3 id="共享存储"><a class="markdownIt-Anchor" href="#共享存储"></a> 共享存储</h3>
<p>两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现）</p>
<ul>
<li>
<p><strong>基于数据结构的共享</strong>：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式</p>
</li>
<li>
<p><strong>基于存储区的共享</strong>：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制， 而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。</p>
</li>
</ul>
<p>允许多个进程共享一个给定的存储区。<strong>因为数据不需要在进程之间复制</strong>，所以这是<strong>最快</strong>的一种 IPC。</p>
<p>需要<strong>使用信号量用来同步对共享存储的访问</strong>。</p>
<p>多个进程<strong>可以将同一个文件映射到它们的地址空间从而实现共享内存</strong>。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p>
<h3 id="套接字"><a class="markdownIt-Anchor" href="#套接字"></a> 套接字</h3>
<p>与其它通信机制不同的是，它可用于<strong>不同机器间的进程通信</strong>。</p>
<h2 id="线程-2"><a class="markdownIt-Anchor" href="#线程-2"></a> 线程</h2>
<ul>
<li>线程是一个基本的CPU执行单元，也是程序执行流的最小单位
<ul>
<li>进程是系统分配资源的基本单位，线程是系统调度的基本单位。从属于同一进程的各个线程共享进程的资源。</li>
</ul>
</li>
<li>优点
<ul>
<li>线程间并发，开销更小(不需要操作系统调度)</li>
<li>在多CPU环境下，各个线程也可以分派到不同的CPU上并发执行</li>
<li>增加系统的并发度</li>
</ul>
</li>
</ul>
<h3 id="线程的实现方式"><a class="markdownIt-Anchor" href="#线程的实现方式"></a> 线程的实现方式</h3>
<h4 id="用户级线程"><a class="markdownIt-Anchor" href="#用户级线程"></a> 用户级线程</h4>
<img src="/MyImages/image-20200410154146273.png" alt="image-20200410154146273" style="zoom:80%;" />
<ul>
<li>用户级线程由应用程序通过线程库实现。 所有的线程管理工作都由应用程序负责（包括线程切换）</li>
<li>用户级线程中，线程切换可以在用户态下即可完成，<strong>无需操作系统干预</strong>。</li>
<li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在（用户级线程对用户不透明，对操作系统透明）</li>
</ul>
<h4 id="内核级线程"><a class="markdownIt-Anchor" href="#内核级线程"></a> 内核级线程</h4>
<img src="/MyImages/image-20200410154205246.png" alt="image-20200410154205246" style="zoom:80%;" />
<ul>
<li>内核级线程的管理工作<strong>由操作系统内核完成</strong>。 线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</li>
<li>可以这样理解，<strong>“内核级线程”就是“从操作系统内核视角看能看到的线程</strong>”</li>
</ul>
<h4 id="综合方式"><a class="markdownIt-Anchor" href="#综合方式"></a> 综合方式</h4>
<p><img src="/MyImages/image-20200410154424552.png" alt="image-20200410154424552" /></p>
<ul>
<li>在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将n个用户级线程映射到m个内核级线程上（ n &gt;= m）</li>
<li><strong>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位</strong></li>
</ul>
<h3 id="多线程模型"><a class="markdownIt-Anchor" href="#多线程模型"></a> 多线程模型</h3>
<h4 id="一对多模型"><a class="markdownIt-Anchor" href="#一对多模型"></a> 一对多模型</h4>
<p><img src="/MyImages/image-20200410154521212.png" alt="image-20200410154521212" /></p>
<ul>
<li>一对多模型：将多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程</li>
<li><strong>优点</strong>：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li>
<li><strong>缺点</strong>：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</li>
</ul>
<h4 id="一对一模型"><a class="markdownIt-Anchor" href="#一对一模型"></a> 一对一模型</h4>
<img src="/MyImages/image-20200410154858257.png" alt="image-20200410154858257" style="zoom:80%;" />
<ul>
<li>一对一模型：一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</li>
<li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核 处理机上并行执行。</li>
<li>缺点：一个用户进程会占用多个内核级线程， 线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li>
</ul>
<h4 id="多对多模型"><a class="markdownIt-Anchor" href="#多对多模型"></a> 多对多模型</h4>
<ul>
<li>多对多模型：n 用户及线程映射到 m 个内核级线程（n &gt;= m）。每个用户进程对应 m 个内核级线程。</li>
<li>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内 核级线程，开销太大的缺点。</li>
</ul>
<h1 id="进程调度-2"><a class="markdownIt-Anchor" href="#进程调度-2"></a> 进程调度</h1>
<img src="/MyImages/image-20200410160026896.png" alt="image-20200410160026896" style="zoom:80%;" />
<h3 id="基本概念-2"><a class="markdownIt-Anchor" href="#基本概念-2"></a> 基本概念</h3>
<ul>
<li>处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</li>
</ul>
<h4 id="高级调度作业调度"><a class="markdownIt-Anchor" href="#高级调度作业调度"></a> 高级调度(作业调度)</h4>
<ul>
<li>按一定的原则从外存上处于<strong>后备队列的作业中挑选一个（或多个）作业</strong>， 给他们分配内存等必要资源，<strong>并建立相应的进程</strong>（建立PCB），以使它（们）获得竞争处理机的权利。</li>
<li>作业调入时会建立相应的PCB，作业调出时才撤销PCB</li>
</ul>
<h4 id="中级调度内存调度"><a class="markdownIt-Anchor" href="#中级调度内存调度"></a> 中级调度(内存调度)</h4>
<ul>
<li>引入了虚拟存储技术之后，可<strong>将暂时不能运行的进程调至外存等待</strong>。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。这么做的<strong>目的是为了提高内存利用率和系统吞吐量</strong>。</li>
<li>PCB常驻内存。被挂起的进程PCB会被放到的挂起队列中。</li>
</ul>
<h4 id="低级调度进程调度"><a class="markdownIt-Anchor" href="#低级调度进程调度"></a> 低级调度(进程调度)</h4>
<ul>
<li>其主要任务是按照某种方法和策略<strong>从就绪队列中选取一个进程，将处理机分配给它。</strong></li>
</ul>
<h4 id="对比"><a class="markdownIt-Anchor" href="#对比"></a> 对比</h4>
<p><img src="/MyImages/image-20200410160541491.png" alt="image-20200410160541491" /></p>
<h3 id="调度算法"><a class="markdownIt-Anchor" href="#调度算法"></a> 调度算法</h3>
<h4 id="先来先服务"><a class="markdownIt-Anchor" href="#先来先服务"></a> 先来先服务</h4>
<p><img src="/MyImages/image-20200410161834179.png" alt="image-20200410161834179" /></p>
<h4 id="最短作业优先"><a class="markdownIt-Anchor" href="#最短作业优先"></a> 最短作业优先</h4>
<p><img src="/MyImages/image-20200410162007371.png" alt="image-20200410162007371" /></p>
<h4 id="最高响应比优先"><a class="markdownIt-Anchor" href="#最高响应比优先"></a> 最高响应比优先</h4>
<p><img src="/MyImages/image-20200410162044259.png" alt="image-20200410162044259" /></p>
<h4 id="对比-2"><a class="markdownIt-Anchor" href="#对比-2"></a> 对比</h4>
<p><img src="/MyImages/image-20200410162106676.png" alt="image-20200410162106676" /></p>
<h3 id="评价指标"><a class="markdownIt-Anchor" href="#评价指标"></a> 评价指标</h3>
<h4 id="cpu利用率"><a class="markdownIt-Anchor" href="#cpu利用率"></a> CPU利用率</h4>
<p><img src="/MyImages/image-20200410161213084.png" alt="image-20200410161213084" /></p>
<h4 id="系统吞吐量"><a class="markdownIt-Anchor" href="#系统吞吐量"></a> 系统吞吐量</h4>
<p><img src="/MyImages/image-20200410161234338.png" alt="image-20200410161234338" /></p>
<h4 id="周转时间"><a class="markdownIt-Anchor" href="#周转时间"></a> 周转时间</h4>
<p><img src="/MyImages/image-20200410161257474.png" alt="image-20200410161257474" /></p>
<p><img src="/MyImages/image-20200410161312274.png" alt="image-20200410161312274" /></p>
<h4 id="等待时间"><a class="markdownIt-Anchor" href="#等待时间"></a> 等待时间</h4>
<p>等待时间，指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低</p>
<ul>
<li>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。</li>
<li>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间</li>
</ul>
<h4 id="响应时间"><a class="markdownIt-Anchor" href="#响应时间"></a> 响应时间</h4>
<p>响应时间，指从用户提交请求到首次产生响应所用的时间。</p>
<h1 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h1>
<h2 id="必要条件"><a class="markdownIt-Anchor" href="#必要条件"></a> 必要条件</h2>
<ol>
<li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。</li>
<li>不可剥夺：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。</li>
<li>请求和保持：已经得到了某个资源的进程可以再请求新的资源。</li>
<li>循环等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ol>
<h2 id="处理方法"><a class="markdownIt-Anchor" href="#处理方法"></a> 处理方法</h2>
<h3 id="鸵鸟策略"><a class="markdownIt-Anchor" href="#鸵鸟策略"></a> 鸵鸟策略</h3>
<p>不管</p>
<h3 id="死锁的检测与恢复"><a class="markdownIt-Anchor" href="#死锁的检测与恢复"></a> 死锁的检测与恢复</h3>
<ol>
<li>
<p><strong>单个资源的死锁检测</strong>：使用资源分配图，看是否存在环</p>
<p><img src="/MyImages/image-20200410164200804.png" alt="image-20200410164200804" /></p>
<ol>
<li>在资源分配图中，找出既不阻塞又不是孤点的进程 Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。如下图中，R1没有空闲资源，R2有 一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配变，使之称为孤立的结点。在下图中，P1 是满足这一条件的进程结点，于是将P1的所有边消去。</li>
<li>进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变 为非阻塞进程。在下图中，P2 就满足这样的条件。根据 1）中的方法进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的。</li>
</ol>
</li>
<li>
<p><strong>多个资源的死锁检测</strong>：银行家算法，判断能否寻找到一个不会发生死锁的资源分配序列。</p>
<p><strong><img src="/MyImages/image-20200611154613285.png" alt="image-20200611154613285" /></strong></p>
</li>
<li>
<p><strong>死锁恢复</strong></p>
<ul>
<li><strong>资源剥夺法</strong>挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li>
<li><strong>撤销进程法</strong>（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行 了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li>
<li><strong>进程回退法</strong>。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</li>
</ul>
</li>
</ol>
<h3 id="预防死锁"><a class="markdownIt-Anchor" href="#预防死锁"></a> 预防死锁</h3>
<ol>
<li><strong>破坏互斥条件</strong>
<ul>
<li>只有对必须互斥使用的资源的争抢才会导致死锁。</li>
<li>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如: SPOOLing技术：将一台物理设备虚拟成多个逻辑设备</li>
<li>缺点：并不是所有的资源都可以改造成可共享使用的资源</li>
</ul>
</li>
<li><strong>破坏请求和保持条件</strong>
<ul>
<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</li>
<li>破坏：可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前， 不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</li>
</ul>
</li>
<li><strong>破坏不可剥夺条件</strong>
<ul>
<li>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</li>
<li>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</li>
</ul>
</li>
<li><strong>破坏循环等待条件</strong>：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。
<ul>
<li>破坏：可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。</li>
</ul>
</li>
</ol>
<h3 id="避免死锁"><a class="markdownIt-Anchor" href="#避免死锁"></a> 避免死锁</h3>
<p>银行家算法</p>
<h1 id="内存管理-2"><a class="markdownIt-Anchor" href="#内存管理-2"></a> 内存管理</h1>
<h2 id="内存的装入方式"><a class="markdownIt-Anchor" href="#内存的装入方式"></a> 内存的装入方式</h2>
<h3 id="绝对装入"><a class="markdownIt-Anchor" href="#绝对装入"></a> 绝对装入</h3>
<ul>
<li>绝对装入：在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。 装入程序按照装入模块中的地址，将程序和数据装入内存。</li>
<li>只适用于单道程序环境</li>
</ul>
<h3 id="静态重定位"><a class="markdownIt-Anchor" href="#静态重定位"></a> 静态重定位</h3>
<ul>
<li>又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，<strong>指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址</strong>。可根据内存的当前情况，将装入模块装入到内存的适当位置。<strong>装入时对地址进行“重定位</strong>”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）</li>
<li>作业装入内存时，必须分配其要求的全部内存空间</li>
</ul>
<h3 id="动态重定位"><a class="markdownIt-Anchor" href="#动态重定位"></a> 动态重定位</h3>
<ul>
<li>又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，<strong>并不会立即把逻辑地址转换为物理地址</strong>，而是把<strong>地址转换推迟到程序真正要执行 时才进行</strong>。因此装入内存后所有的地址依然是逻辑地址。这种方式<strong>需要一个重定位寄存器的支持</strong>。</li>
</ul>
<h2 id="内存保护"><a class="markdownIt-Anchor" href="#内存保护"></a> 内存保护</h2>
<ul>
<li><strong>在CPU中设置一对上、下限寄存器</strong>，存放进程的上、下限地址。进程的指令要访问某个地址 时，CPU检查是否越界。</li>
<li>采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定 位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址。</li>
</ul>
<h2 id="内存空间的扩展"><a class="markdownIt-Anchor" href="#内存空间的扩展"></a> 内存空间的扩展</h2>
<h3 id="覆盖技术"><a class="markdownIt-Anchor" href="#覆盖技术"></a> 覆盖技术</h3>
<ul>
<li>将程序分为多个段（多个模块）。 常用的段常驻内存，不常用的段在需要时调入内存。
<ul>
<li>需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）</li>
<li>不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存</li>
</ul>
</li>
<li>必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点：对用户不透明，增加了用户编程负担</li>
</ul>
<h3 id="交换技术"><a class="markdownIt-Anchor" href="#交换技术"></a> 交换技术</h3>
<ul>
<li>内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）</li>
<li>对应中级调度</li>
<li>PCB常驻内存</li>
</ul>
<h3 id="虚拟存储技术"><a class="markdownIt-Anchor" href="#虚拟存储技术"></a> 虚拟存储技术</h3>
<h2 id="内存的分配和回收"><a class="markdownIt-Anchor" href="#内存的分配和回收"></a> 内存的分配和回收</h2>
<h3 id="连续分配方式"><a class="markdownIt-Anchor" href="#连续分配方式"></a> 连续分配方式</h3>
<p><img src="/MyImages/image-20200411171523066.png" alt="image-20200411171523066" /></p>
<h4 id="单一连续分配"><a class="markdownIt-Anchor" href="#单一连续分配"></a> 单一连续分配</h4>
<ul>
<li>内存分为系统区和用户区</li>
<li>内存中只能有一道用户程序，用户程序独占整个用户区空间</li>
</ul>
<h4 id="固定分区分配"><a class="markdownIt-Anchor" href="#固定分区分配"></a> 固定分区分配</h4>
<ul>
<li>将用户空间划分为若干个固定大小的分区，在每个分区中转入一道作业</li>
<li>分区大小不同，有分区大小相等的和分区大小不等的</li>
<li>需要一张分区说明表</li>
<li>有内碎片而没有外碎片</li>
</ul>
<h4 id="动态分区分配"><a class="markdownIt-Anchor" href="#动态分区分配"></a> 动态分区分配</h4>
<ul>
<li>不预先划分内存分区，而是程序进入内存时，根据进程的大小动态建立分区</li>
<li>需要空闲分区表和空闲分区链</li>
<li>没有内碎片，有外碎片</li>
<li>外碎片可以用紧缩技术解决</li>
</ul>
<h3 id="非连续分配方式"><a class="markdownIt-Anchor" href="#非连续分配方式"></a> 非连续分配方式</h3>
<p><img src="/MyImages/image-20200411172728382.png" alt="image-20200411172728382" /></p>
<h4 id="基本分页"><a class="markdownIt-Anchor" href="#基本分页"></a> 基本分页</h4>
<ul>
<li>
<p>页表：记录页面和实际存放的内存块之间的映射关系</p>
<ul>
<li>一个进程对应一张页表</li>
<li>进程的每个页面对应一个页表项</li>
<li>每个页表项的长度是相同的</li>
</ul>
</li>
<li>
<p>地址转换</p>
<ul>
<li>
<p>确定逻辑地址A 对应的“页号”P</p>
</li>
<li>
<p>找到P号页面在内存中的起始地址（需要查页表）</p>
</li>
<li>
<p>确定逻辑地址A 的“页内偏移量”W</p>
</li>
<li>
<p>逻辑地址A 对应的物理地址 = P号页面在内存中的起始地址+页内偏移量W</p>
</li>
</ul>
</li>
</ul>
<h4 id="两级页表"><a class="markdownIt-Anchor" href="#两级页表"></a> 两级页表</h4>
<p><img src="/MyImages/image-20200411175101753.png" alt="image-20200411175101753" /></p>
<h4 id="基本分段"><a class="markdownIt-Anchor" href="#基本分段"></a> 基本分段</h4>
<ul>
<li>
<p>进程地址空间按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址</p>
</li>
<li>
<p>段表</p>
<p><img src="/MyImages/image-20200411175252974.png" alt="image-20200411175252974" /></p>
</li>
<li>
<p>地址变换</p>
<img src="/MyImages/image-20200411180247662.png" alt="image-20200411180247662" style="zoom: 67%;" />
</li>
</ul>
<h4 id="段页式管理"><a class="markdownIt-Anchor" href="#段页式管理"></a> 段页式管理</h4>
<h2 id="动态分区分配算法"><a class="markdownIt-Anchor" href="#动态分区分配算法"></a> 动态分区分配算法</h2>
<p><img src="/MyImages/image-20200411172221938.png" alt="image-20200411172221938" /></p>
<h3 id="首次适应算法"><a class="markdownIt-Anchor" href="#首次适应算法"></a> 首次适应算法</h3>
<ul>
<li>每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</li>
<li><strong>实现</strong>空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链</li>
</ul>
<h3 id="最佳适应算法"><a class="markdownIt-Anchor" href="#最佳适应算法"></a> 最佳适应算法</h3>
<ul>
<li>每次选浪费最小的分区，从小容量的分区开始查找</li>
<li><strong>实现</strong>：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链，找到大小能满足要求的第一个空闲分区。</li>
</ul>
<h3 id="最坏适应算法"><a class="markdownIt-Anchor" href="#最坏适应算法"></a> 最坏适应算法</h3>
<ul>
<li>先用大空间的分区</li>
<li><strong>实现</strong>：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</li>
</ul>
<h3 id="近邻适应算法"><a class="markdownIt-Anchor" href="#近邻适应算法"></a> 近邻适应算法</h3>
<ul>
<li>每次都从上次查找结束的位置开始检索</li>
<li><strong>实现</strong>：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li>
</ul>
<h2 id="虚拟内存"><a class="markdownIt-Anchor" href="#虚拟内存"></a> 虚拟内存</h2>
<h3 id="局部性原理"><a class="markdownIt-Anchor" href="#局部性原理"></a> 局部性原理</h3>
<ul>
<li><strong>时间局部性</strong>：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）</li>
<li><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</li>
</ul>
<h3 id="虚拟内存-2"><a class="markdownIt-Anchor" href="#虚拟内存-2"></a> 虚拟内存</h3>
<ul>
<li>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存， 就可以让程序开始执行</li>
<li>主要特征
<ul>
<li>多次性：作业分成多次调入内存</li>
<li>对换性：作业无需常驻内存</li>
<li>虚拟性：从逻辑上扩展内存</li>
</ul>
</li>
</ul>
<h2 id="虚拟页式"><a class="markdownIt-Anchor" href="#虚拟页式"></a> 虚拟页式</h2>
<ul>
<li>在基本页式管理的基础上增加请求分页功能。在内存空间不够时，实现页面置换</li>
</ul>
<h3 id="缺页中断机构"><a class="markdownIt-Anchor" href="#缺页中断机构"></a> 缺页中断机构</h3>
<ul>
<li>当要访问的页面不存在时，产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断</li>
<li>此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列
<ul>
<li>如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。</li>
<li>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。</li>
</ul>
</li>
</ul>
<h3 id="地址变换"><a class="markdownIt-Anchor" href="#地址变换"></a> 地址变换</h3>
<img src="/MyImages/image-20200411183214560.png" alt="image-20200411183214560" style="zoom:80%;" />
<h2 id="页面置换算法"><a class="markdownIt-Anchor" href="#页面置换算法"></a> 页面置换算法</h2>
<img src="/MyImages/image-20200411183432240.png" alt="image-20200411183432240" style="zoom:80%;" />
<h3 id="最佳置换算法"><a class="markdownIt-Anchor" href="#最佳置换算法"></a> 最佳置换算法</h3>
<ul>
<li>每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。</li>
<li>无法实现</li>
</ul>
<h3 id="先进先出置换算法"><a class="markdownIt-Anchor" href="#先进先出置换算法"></a> 先进先出置换算法</h3>
<ul>
<li>每次选择淘汰的页面是最早进入内存的页面</li>
</ul>
<h3 id="最近最久未使用置换算法-lru"><a class="markdownIt-Anchor" href="#最近最久未使用置换算法-lru"></a> 最近最久未使用置换算法 LRU</h3>
<ul>
<li>每次淘汰的页面是最近最久未使用的页面</li>
<li><strong>实现</strong>：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t。</li>
</ul>
<h3 id="最近未使用-nru"><a class="markdownIt-Anchor" href="#最近未使用-nru"></a> 最近未使用 NRU</h3>
<p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p>
<ul>
<li>R=0，M=0</li>
<li>R=0，M=1</li>
<li>R=1，M=0</li>
<li>R=1，M=1</li>
</ul>
<p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p>
<p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p>
<h3 id="时钟置换算法"><a class="markdownIt-Anchor" href="#时钟置换算法"></a> 时钟置换算法</h3>
<ul>
<li>为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫 ᧿中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫᧿（第二轮扫᧿中一定会有访问位为0的页面，因此简单的CLOCK 算法选择一个淘汰页面最多会经过两轮扫᧿）</li>
</ul>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<p><img src="/MyImages/image-20200411183845299.png" alt="image-20200411183845299" /></p>
<h2 id="分页与分段的比较"><a class="markdownIt-Anchor" href="#分页与分段的比较"></a> 分页与分段的比较</h2>
<ul>
<li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li>
<li>地址空间的维度：分页是一维地址空间，分段是二维的。</li>
<li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li>
<li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li>
</ul>
<h1 id="设备管理-2"><a class="markdownIt-Anchor" href="#设备管理-2"></a> 设备管理</h1>
<h2 id="磁盘结构"><a class="markdownIt-Anchor" href="#磁盘结构"></a> 磁盘结构</h2>
<ul>
<li>盘面（Platter）：一个磁盘有多个盘面；</li>
<li>磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；</li>
<li>扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；</li>
<li>磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；</li>
<li>制动手臂（Actuator arm）：用于在磁道之间移动磁头；</li>
<li>主轴（Spindle）：使整个盘面转动。</li>
</ul>
<img src="/MyImages/image-20200612195239615.png" alt="image-20200612195239615" style="zoom:80%;" />
<h2 id="磁盘调度算法"><a class="markdownIt-Anchor" href="#磁盘调度算法"></a> 磁盘调度算法</h2>
<p>影响因素</p>
<ul>
<li>旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）</li>
<li>寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）</li>
<li>实际的数据传输时间</li>
</ul>
<p>其中，寻道时间最长，因此磁盘调度的<strong>主要目标是使磁盘的平均寻道时间最短</strong></p>
<h3 id="先来先服务-2"><a class="markdownIt-Anchor" href="#先来先服务-2"></a> 先来先服务</h3>
<p><strong>按照磁盘请求的顺序进行调度</strong></p>
<p>优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使<strong>平均寻道时间可能较长。</strong></p>
<h3 id="最短寻道时间优先"><a class="markdownIt-Anchor" href="#最短寻道时间优先"></a> 最短寻道时间优先</h3>
<p><strong>优先调度与当前磁头所在磁道距离最近的磁道。</strong></p>
<p>虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。</p>
<h3 id="电梯算法"><a class="markdownIt-Anchor" href="#电梯算法"></a> 电梯算法</h3>
<p><strong>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</strong></p>
<p>电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。</p>
<p>因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。</p>
<h1 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h1>
<h2 id="编译系统"><a class="markdownIt-Anchor" href="#编译系统"></a> 编译系统</h2>
<img src="/MyImages/image-20200612201710989.png" alt="image-20200612201710989" style="zoom:67%;" />
<ul>
<li>预处理阶段：处理以 # 开头的预处理命令；</li>
<li>编译阶段：翻译成汇编文件；</li>
<li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li>
<li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</li>
</ul>
<h2 id="静态链接"><a class="markdownIt-Anchor" href="#静态链接"></a> 静态链接</h2>
<p><strong>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出</strong>。链接器主要完成以下两个任务：</p>
<ul>
<li>符号解析：<strong>每个符号对应于一个函数、一个全局变量或一个静态变量</strong>，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li>
<li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li>
</ul>
<h2 id="目标文件"><a class="markdownIt-Anchor" href="#目标文件"></a> 目标文件</h2>
<ul>
<li>可执行目标文件：可以直接在内存中执行；</li>
<li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li>
<li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；</li>
</ul>
<h2 id="动态链接"><a class="markdownIt-Anchor" href="#动态链接"></a> 动态链接</h2>
<p>静态库有以下两个问题：</p>
<ul>
<li>当静态库更新时那么整个程序都要重新进行链接；</li>
<li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li>
</ul>
<p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p>
<ul>
<li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li>
<li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li>
</ul>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库目录</title>
    <url>/2020/03/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="第三章基本语法"><a class="markdownIt-Anchor" href="#第三章基本语法"></a> <a href="/2020/03/30/DB3">第三章基本语法</a></h2>
<h2 id="第四章数据库安全"><a class="markdownIt-Anchor" href="#第四章数据库安全"></a> <a href="/2020/03/30/DB4">第四章数据库安全</a></h2>
<h2 id="第五章"><a class="markdownIt-Anchor" href="#第五章"></a> <a href="/2020/03/30/DB5/">第五章</a></h2>
<h2 id="第六章"><a class="markdownIt-Anchor" href="#第六章"></a> <a href="/2020/03/30/DB6/">第六章</a></h2>
<h2 id="第七章"><a class="markdownIt-Anchor" href="#第七章"></a> <a href="/2020/03/30/DB7/">第七章</a></h2>
<h2 id="mysql基本语法"><a class="markdownIt-Anchor" href="#mysql基本语法"></a> <a href="/2020/03/30/Mysql%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">Mysql基本语法</a></h2>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统</title>
    <url>/2020/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="事务"><a class="markdownIt-Anchor" href="#事务"></a> 事务</h1>
<h2 id="acid"><a class="markdownIt-Anchor" href="#acid"></a> ACID</h2>
<h3 id="1-原子性atomicity"><a class="markdownIt-Anchor" href="#1-原子性atomicity"></a> 1. 原子性（Atomicity）</h3>
<p>**事务被视为不可分割的最小单元，**事务的所有操作要么全部提交成功，要么全部失败回滚。</p>
<p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
<h3 id="2-一致性consistency"><a class="markdownIt-Anchor" href="#2-一致性consistency"></a> 2. 一致性（Consistency）</h3>
<p>**数据库在事务执行前后都保持一致性状态。**在一致性状态下，<strong>所有事务对同一个数据的读取结果都是相同的。</strong></p>
<h3 id="3-隔离性isolation"><a class="markdownIt-Anchor" href="#3-隔离性isolation"></a> 3. 隔离性（Isolation</h3>
<p>一个事务所做的修改在最终<strong>提交以前，对其它事务是不可见的。</strong></p>
<h3 id="4-持久性durability"><a class="markdownIt-Anchor" href="#4-持久性durability"></a> 4. 持久性（Durability）</h3>
<p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，<strong>事务执行的结果也不能丢失。</strong></p>
<p>系统发生奔溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p>
<h3 id="关系"><a class="markdownIt-Anchor" href="#关系"></a> 关系</h3>
<p><img src="/MyImages/image-20200616105901714.png" alt="image-20200616105901714" /></p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对系统崩溃的情况。</li>
</ul>
<h1 id="并发一致性问题"><a class="markdownIt-Anchor" href="#并发一致性问题"></a> 并发一致性问题</h1>
<p><strong>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</strong></p>
<h2 id="丢失修改"><a class="markdownIt-Anchor" href="#丢失修改"></a> 丢失修改</h2>
<p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>
<h2 id="读脏数据"><a class="markdownIt-Anchor" href="#读脏数据"></a> 读脏数据</h2>
<p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p>
<h2 id="不可重复读"><a class="markdownIt-Anchor" href="#不可重复读"></a> 不可重复读</h2>
<p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<h2 id="幻读"><a class="markdownIt-Anchor" href="#幻读"></a> 幻读</h2>
<p>幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<h1 id="封锁"><a class="markdownIt-Anchor" href="#封锁"></a> 封锁</h1>
<h2 id="封锁粒度"><a class="markdownIt-Anchor" href="#封锁粒度"></a> 封锁粒度</h2>
<p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p>
<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p>
<p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p>
<p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>
<h2 id="封锁类型"><a class="markdownIt-Anchor" href="#封锁类型"></a> 封锁类型</h2>
<h3 id="读写锁"><a class="markdownIt-Anchor" href="#读写锁"></a> 读写锁</h3>
<ul>
<li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li>
<li>共享锁（Shared），简写为 S 锁，又称读锁。</li>
</ul>
<p>有以下两个规定：</p>
<p><img src="/MyImages/image-20200616110238903.png" alt="image-20200616110238903" /></p>
<ul>
<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>
<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>
</ul>
<h3 id="意向锁"><a class="markdownIt-Anchor" href="#意向锁"></a> 意向锁</h3>
<p><img src="/MyImages/image-20200616110259644.png" alt="image-20200616110259644" /></p>
<p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p>
<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>
<p><strong>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁</strong>，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>
<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<h2 id="封锁协议"><a class="markdownIt-Anchor" href="#封锁协议"></a> 封锁协议</h2>
<h3 id="两段锁协议"><a class="markdownIt-Anchor" href="#两段锁协议"></a> 两段锁协议</h3>
<p><img src="/MyImages/image-20200616110511632.png" alt="image-20200616110511632" /></p>
<p><strong>加锁和解锁分为两个阶段进行。</strong></p>
<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p>
<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</span><br></pre></td></tr></table></figure>
<p>但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</span><br></pre></td></tr></table></figure>
<h1 id="隔离级别"><a class="markdownIt-Anchor" href="#隔离级别"></a> 隔离级别</h1>
<h2 id="读未提交"><a class="markdownIt-Anchor" href="#读未提交"></a> 读未提交</h2>
<p>事务中的修改，即使没有提交，对其它事务也是可见的。</p>
<h2 id="读已提交"><a class="markdownIt-Anchor" href="#读已提交"></a> 读已提交</h2>
<p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>
<h2 id="可重复读"><a class="markdownIt-Anchor" href="#可重复读"></a> 可重复读</h2>
<p>保证在同一个事务中多次读取同一数据的结果是一样的。</p>
<h2 id="可串行化"><a class="markdownIt-Anchor" href="#可串行化"></a> 可串行化</h2>
<p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p>
<p>该隔离级别需要加锁实现，因为要<strong>使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</strong></p>
<h1 id="多版本并发控制-mvcc"><a class="markdownIt-Anchor" href="#多版本并发控制-mvcc"></a> 多版本并发控制 MVCC</h1>
<p>MVCC是Mysql的InnoDB实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。</p>
<h2 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想"></a> 基本思想</h2>
<p>MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。</p>
<p>在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。</p>
<p>脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。</p>
<h2 id="版本号"><a class="markdownIt-Anchor" href="#版本号"></a> 版本号</h2>
<ul>
<li>系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>
<li>事务版本号 TRX_ID ：事务开始时的系统版本号。</li>
</ul>
<h2 id="undo日志"><a class="markdownIt-Anchor" href="#undo日志"></a> Undo日志</h2>
<p>MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，<strong>该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。</strong></p>
<p><img src="/MyImages/image-20200616115846426.png" alt="image-20200616115846426" /></p>
<h2 id="readview"><a class="markdownIt-Anchor" href="#readview"></a> ReadView</h2>
<p>MVCC 维护了一个 ReadView 结构，<strong>主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, …}</strong>，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。</p>
<p><img src="/MyImages/image-20200616120505739.png" alt="image-20200616120505739" /></p>
<p>在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：</p>
<ul>
<li>TRX_ID &lt; TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。</li>
<li>TRX_ID &gt; TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。</li>
<li>TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX，需要根据隔离级别再进行判断：
<ul>
<li>提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。</li>
<li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li>
</ul>
</li>
</ul>
<p><strong>在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。</strong></p>
<h2 id="快照读与当前读"><a class="markdownIt-Anchor" href="#快照读与当前读"></a> 快照读与当前读</h2>
<h3 id="1-快照读"><a class="markdownIt-Anchor" href="#1-快照读"></a> 1. 快照读</h3>
<p>MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table ...;</span><br></pre></td></tr></table></figure>
<h3 id="2-当前读"><a class="markdownIt-Anchor" href="#2-当前读"></a> 2. 当前读</h3>
<p>MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT;</span><br><span class="line">UPDATE;</span><br><span class="line">DELETE;</span><br></pre></td></tr></table></figure>
<p>在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table WHERE ? lock in share mode;</span><br><span class="line">SELECT * FROM table WHERE ? for update;</span><br></pre></td></tr></table></figure>
<h1 id="next-key-locks"><a class="markdownIt-Anchor" href="#next-key-locks"></a> Next-Key Locks</h1>
<p>在可重复读（REPEATABLE READ）隔离级别下，<strong>使用 MVCC + Next-Key Locks 可以解决幻读问题。</strong></p>
<h2 id="record-locks"><a class="markdownIt-Anchor" href="#record-locks"></a> Record Locks</h2>
<p><strong>锁定一个记录上的索引，而不是记录本身</strong></p>
<p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p>
<h2 id="gap-locks"><a class="markdownIt-Anchor" href="#gap-locks"></a> Gap Locks</h2>
<p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> c <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>
<h2 id="next-key-locks-2"><a class="markdownIt-Anchor" href="#next-key-locks-2"></a> Next-Key Locks</h2>
<p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">(-∞, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, +∞)</span><br></pre></td></tr></table></figure>
<h1 id="关系数据库理论"><a class="markdownIt-Anchor" href="#关系数据库理论"></a> 关系数据库理论</h1>
<h2 id="函数依赖"><a class="markdownIt-Anchor" href="#函数依赖"></a> 函数依赖</h2>
<p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p>
<p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p>
<p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p>
<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p>
<h2 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h2>
<table>
<thead>
<tr>
<th>Sno</th>
<th>Sname</th>
<th>Sdept</th>
<th>Mname</th>
<th>Cname</th>
<th>Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>学生-1</td>
<td>学院-1</td>
<td>院长-1</td>
<td>课程-1</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-2</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-1</td>
<td>100</td>
</tr>
<tr>
<td>3</td>
<td>学生-3</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-2</td>
<td>95</td>
</tr>
</tbody>
</table>
<p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p>
<ul>
<li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li>
<li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li>
<li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li>
<li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li>
</ul>
<h2 id="范式"><a class="markdownIt-Anchor" href="#范式"></a> 范式</h2>
<h3 id="1-第一范式-1nf"><a class="markdownIt-Anchor" href="#1-第一范式-1nf"></a> 1. 第一范式 (1NF)</h3>
<p>属性不可分。</p>
<h3 id="2-第二范式-2nf"><a class="markdownIt-Anchor" href="#2-第二范式-2nf"></a> 2. 第二范式 (2NF)</h3>
<p>每个非主属性完全函数依赖于键码。</p>
<p>可以通过分解来满足。</p>
<p><strong>分解前</strong></p>
<table>
<thead>
<tr>
<th>Sno</th>
<th>Sname</th>
<th>Sdept</th>
<th>Mname</th>
<th>Cname</th>
<th>Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>学生-1</td>
<td>学院-1</td>
<td>院长-1</td>
<td>课程-1</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-2</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-1</td>
<td>100</td>
</tr>
<tr>
<td>3</td>
<td>学生-3</td>
<td>学院-2</td>
<td>院长-2</td>
<td>课程-2</td>
<td>95</td>
</tr>
</tbody>
</table>
<p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
<li>Sno, Cname-&gt; Grade</li>
</ul>
<p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p>
<p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p>
<p><strong>分解后</strong></p>
<p>关系-1</p>
<table>
<thead>
<tr>
<th>Sno</th>
<th>Sname</th>
<th>Sdept</th>
<th>Mname</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>学生-1</td>
<td>学院-1</td>
<td>院长-1</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
<td>院长-2</td>
</tr>
<tr>
<td>3</td>
<td>学生-3</td>
<td>学院-2</td>
<td>院长-2</td>
</tr>
</tbody>
</table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
</ul>
<p>关系-2</p>
<table>
<thead>
<tr>
<th>Sno</th>
<th>Cname</th>
<th>Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>课程-1</td>
<td>90</td>
</tr>
<tr>
<td>2</td>
<td>课程-2</td>
<td>80</td>
</tr>
<tr>
<td>2</td>
<td>课程-1</td>
<td>100</td>
</tr>
<tr>
<td>3</td>
<td>课程-2</td>
<td>95</td>
</tr>
</tbody>
</table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno, Cname -&gt; Grade</li>
</ul>
<h3 id="3-第三范式-3nf"><a class="markdownIt-Anchor" href="#3-第三范式-3nf"></a> 3. 第三范式 (3NF)</h3>
<p>非主属性不传递函数依赖于键码。</p>
<p>上面的 关系-1 中存在以下传递函数依赖：</p>
<ul>
<li>Sno -&gt; Sdept -&gt; Mname</li>
</ul>
<p>可以进行以下分解：</p>
<p>关系-11</p>
<table>
<thead>
<tr>
<th>Sno</th>
<th>Sname</th>
<th>Sdept</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>学生-1</td>
<td>学院-1</td>
</tr>
<tr>
<td>2</td>
<td>学生-2</td>
<td>学院-2</td>
</tr>
<tr>
<td>3</td>
<td>学生-3</td>
<td>学院-2</td>
</tr>
</tbody>
</table>
<p>关系-12</p>
<table>
<thead>
<tr>
<th>Sdept</th>
<th>Mname</th>
</tr>
</thead>
<tbody>
<tr>
<td>学院-1</td>
<td>院长-1</td>
</tr>
<tr>
<td>学院-2</td>
<td>院长-2</td>
</tr>
</tbody>
</table>
<h1 id="er-图"><a class="markdownIt-Anchor" href="#er-图"></a> ER 图</h1>
<p>用来进行关系型数据库系统的<strong>概念设计</strong>。</p>
<p>有三个组成部分**：实体、属性、联系**。</p>
<h2 id="实体的三种联系"><a class="markdownIt-Anchor" href="#实体的三种联系"></a> 实体的三种联系</h2>
<p>包含一对一，一对多，多对多三种。</p>
<ul>
<li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li>
<li>如果是一对一，画两个带箭头的线段；</li>
<li>如果是多对多，画两个不带箭头的线段。</li>
</ul>
<p>下图的 Course 和 Student 是一对多的关系。</p>
<p><a href="https://camo.githubusercontent.com/30b13bf542f6115d8bcecc903ed08a0f16d21304/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31643238616430352d333965352d343961322d613661312d6136663439366164626136612e706e67" target="_blank" rel="noopener"><img src="/MyImages/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31643238616430352d333965352d343961322d613661312d6136663439366164626136612e706e67" alt="img" /></a></p>
<h2 id="表示出现多次的关系"><a class="markdownIt-Anchor" href="#表示出现多次的关系"></a> 表示出现多次的关系</h2>
<p>一个实体在联系出现几次，就要用几条线连接。</p>
<p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p>
<p><a href="https://camo.githubusercontent.com/7a93b3e7d3ecd4005b1f5877303245a1663ba747/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61633932396561332d646163612d343065632d396539352d3462326661363637383234332e706e67" target="_blank" rel="noopener"><img src="/MyImages/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61633932396561332d646163612d343065632d396539352d3462326661363637383234332e706e67" alt="img" /></a></p>
<h2 id="表示子类"><a class="markdownIt-Anchor" href="#表示子类"></a> 表示子类</h2>
<p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p>
<p><a href="https://camo.githubusercontent.com/144cd455691b6d05e58c063d5272b6e1681689d4/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31343338396561342d386439362d346539362d396637362d3536346361333332346331652e706e67" target="_blank" rel="noopener"><img src="/MyImages/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31343338396561342d386439362d346539362d396637362d3536346361333332346331652e706e67" alt="img" /></a></p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘实战目录</title>
    <url>/2020/03/30/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="第1章-数据挖掘基础"><a class="markdownIt-Anchor" href="#第1章-数据挖掘基础"></a> <a href="/2020/03/30/%E7%AC%AC1%E7%AB%A0%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%9F%BA%E7%A1%80/">第1章 数据挖掘基础</a></h2>
<h2 id="第2章-python数据分析简介"><a class="markdownIt-Anchor" href="#第2章-python数据分析简介"></a> <a href="/2020/03/30/%E7%AC%AC2%E7%AB%A0python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%AE%80%E4%BB%8B/">第2章 python数据分析简介</a></h2>
<h2 id="第3章-数据探索"><a class="markdownIt-Anchor" href="#第3章-数据探索"></a> <a href="/2020/03/30/%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2/">第3章 数据探索</a></h2>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/2020/03/30/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="uva-1592-数据库"><a class="markdownIt-Anchor" href="#uva-1592-数据库"></a> uva 1592 数据库</h1>
<p>输入一个n行m列的数据库，是否存在两个不同行r1，r2和两个不同列c1，c2，使得这两行和两列相同。（即（r1,c1）和（r2,c1）相同，（r1,c2）和（r2,c2）相同）</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>由于最终要判断是否相同，所以可以将字符串映射为一个值，以减少比较的时间</li>
<li>主循环中，在c1,c2下循环r，并将（r,c1）,(r,c2)存成一个二元组，将二元组映射为当前的行号，如果图中已存在这样的二元组，那么对应的值即为r2，当前行为r1。</li>
<li>由于有以二元组为键类型的图，所以结构体中要重写“&lt;”，否则会报错</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;vector&gt;
using namespace std;
map&lt;string, int&gt; location;
set&lt;string&gt; same;
vector&lt;int&gt; str[100000];
typedef struct point {
	int x;
	int y;
	point(int x, int y) :x(x), y(y) {}
	bool operator &lt; (const point&amp; r) const { return x &lt; r.x || x == r.x&amp;&amp;y &lt; r.y; }
}point;
</code></pre>
<p>※※注意此处重写“&lt;”的方法</p>
<pre><code>int main() {
int r, c;
while (scanf(&quot;%d%d&quot;, &amp;r, &amp;c) == 2) {
	getchar();
	same.clear();
	location.clear();
	for (int i = 0; i &lt; r; i++) str[i].clear();
	for (int i = 0; i &lt; r; i++) {
		for (int j = 0; j &lt; c; j++) {
			string s;
			char cs = getchar();
			while (cs != ','&amp;&amp;cs != '\n') {
				s += cs;
				cs = getchar();
			}
			if (!same.count(s)) {
				location[s] = i * r + j;
				same.insert(s);
			}
			str[i].push_back(location[s]);
		}
	}
</code></pre>
<p><strong>利用set和map，将每种字符串映射为唯一的值</strong></p>
<pre><code>	map&lt;point, int&gt; data;
	for (int c1 = 0; c1 &lt; c; c1++) {
		for (int c2 = c1 + 1; c2 &lt; c; c2++) {
			data.clear();
			for (int r1 = 0; r1 &lt; r; r1++) {
				int x = str[r1][c1];
				int y = str[r1][c2];
				point p(x, y);
				if (!data.count(p)) data[p] = r1;
				else {
					cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl &lt;&lt; data[p] + 1 &lt;&lt; &quot; &quot; &lt;&lt; r1 + 1 &lt;&lt; endl
						&lt;&lt; c1 + 1 &lt;&lt;&quot; &quot;&lt;&lt; c2 + 1 &lt;&lt; endl;
					goto here;
				}
			}
		}
	}
	cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;
	here:;
}
}
</code></pre>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<ol>
<li>本题在循环前的映射与集合栈计算机类似，本题中目的是减少比较时的时间</li>
<li>本题应把两列最为一个整体，否则需要四重循环，会TEL</li>
<li>学习结构体初始化和重写操作符的方法。</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索</title>
    <url>/2020/03/30/%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="枚举"><a class="markdownIt-Anchor" href="#枚举"></a> 枚举</h1>
<ol>
<li>枚举要关注查找空间，查找目标，查找方式，估计时间复杂度</li>
<li>有时需要注意精度问题</li>
</ol>
<h2 id="scu-2416"><a class="markdownIt-Anchor" href="#scu-2416"></a> SCU 2416</h2>
<p>有一个总价为_XYZ_，<em>表示看不清的位。现给出火鸡的总数和一个_XYZ</em>，求最大的火鸡单价是多少，输出这两位和最大的单价。火鸡单价为正整数</p>
<p>枚举两位，判断单价是否为整数即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	int a, b, c;</span><br><span class="line">	int n;</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);</span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		int ansi &#x3D; 0, ansj &#x3D; 0;</span><br><span class="line">		int beg &#x3D; a * 1000 + b * 100 + c * 10;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123;</span><br><span class="line">			int t &#x3D; i * 10000 + beg;</span><br><span class="line">			for (int j &#x3D; 0; j &lt;&#x3D; 9; j++) &#123;</span><br><span class="line">				int now &#x3D; t + j;</span><br><span class="line">				int xx &#x3D; now &#x2F; n;</span><br><span class="line">				if (xx*n &#x3D;&#x3D; now)</span><br><span class="line">				&#123;</span><br><span class="line">					ansi &#x3D; i;</span><br><span class="line">					ansj &#x3D; j;</span><br><span class="line">					ans &#x3D; xx; </span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (ans)</span><br><span class="line">			printf(&quot;%d %d %d\n&quot;, ansi, ansj, ans);</span><br><span class="line">		else printf(&quot;0\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="广度优先搜索-bfs"><a class="markdownIt-Anchor" href="#广度优先搜索-bfs"></a> 广度优先搜索 BFS</h1>
<h2 id="hdu-1253-胜利大逃亡"><a class="markdownIt-Anchor" href="#hdu-1253-胜利大逃亡"></a> HDU 1253 胜利大逃亡</h2>
<p>大意是问能否在T时间内从(0,0,0)走到(A-1,B-1,C-1),且正好等于T时到达出口也可</p>
<h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3>
<p>三维隐式图最短路问题，使用bfs求解即可</p>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 50 + 5;</span><br><span class="line">int dx[] &#x3D; &#123; 1,-1,0,0, 0,0 &#125;;</span><br><span class="line">int dy[] &#x3D; &#123; 0,0,1,-1,0,0 &#125;;</span><br><span class="line">int dz[] &#x3D; &#123; 0,0,0,0,1,-1 &#125;;</span><br><span class="line">int A, B, C, T;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int x, y, z;</span><br><span class="line">	int t;</span><br><span class="line">	node(int x, int y, int z, int t) :x(x), y(y), z(z), t(t) &#123;&#125;</span><br><span class="line">	bool operator &#x3D;&#x3D; (const node&amp;a) const</span><br><span class="line">	&#123;</span><br><span class="line">		return x &#x3D;&#x3D; a.x&amp;&amp;y &#x3D;&#x3D; a.y&amp;&amp;z &#x3D;&#x3D; a.z;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int g[maxn][maxn][maxn];</span><br><span class="line">bool vis[maxn][maxn][maxn];</span><br><span class="line">inline bool ok(int x, int y, int z) &#123;</span><br><span class="line">	return x &gt;&#x3D; 0 &amp;&amp; x &lt; A</span><br><span class="line">		&amp;&amp;y &gt;&#x3D; 0 &amp;&amp; y &lt; B</span><br><span class="line">		&amp;&amp;z &gt;&#x3D; 0 &amp;&amp; z &lt; C;</span><br><span class="line">&#125;</span><br><span class="line">bool bfs() &#123;</span><br><span class="line">	node beg(0, 0, 0, 0);</span><br><span class="line">	node goal(A - 1, B - 1, C - 1, 0);</span><br><span class="line">	queue&lt;node&gt; q;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	q.push(beg);</span><br><span class="line">	vis[0][0][0] &#x3D; 1;</span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		node u &#x3D; q.front(); q.pop();</span><br><span class="line">		if (u &#x3D;&#x3D; goal) &#123;</span><br><span class="line">			printf(&quot;%d\n&quot;, u.t);</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		if (u.t &gt; T) &#123;</span><br><span class="line">			printf(&quot;-1\n&quot;);</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 6; i++) &#123;</span><br><span class="line">			int newx &#x3D; u.x + dx[i];</span><br><span class="line">			int newy &#x3D; u.y + dy[i];</span><br><span class="line">			int newz &#x3D; u.z + dz[i];</span><br><span class="line">			if (ok(newx, newy, newz))</span><br><span class="line">				if (!vis[newx][newy][newz] &amp;&amp; !g[newx][newy][newz]) &#123;</span><br><span class="line">					q.push(node(newx, newy, newz, u.t + 1));</span><br><span class="line">					vis[newx][newy][newz] &#x3D; 1;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;-1\n&quot;);</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int kase;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;kase);</span><br><span class="line">	while (kase--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d%d%d%d&quot;, &amp;A, &amp;B, &amp;C, &amp;T);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; A; i++)</span><br><span class="line">			for (int j &#x3D; 0; j &lt; B; j++)</span><br><span class="line">				for (int k &#x3D; 0; k &lt; C; k++)</span><br><span class="line">					scanf(&quot;%d&quot;, &amp;g[i][j][k]);</span><br><span class="line">		bfs();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非常可乐"><a class="markdownIt-Anchor" href="#非常可乐"></a> 非常可乐</h2>
<p>大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升　(正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出&quot;NO&quot;。</p>
<p>三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以&quot;0 0 0&quot;结束。</p>
<p>如果能平分的话请输出最少要倒的次数，否则输出&quot;NO&quot;。</p>
<h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3>
<ol>
<li>隐式图最短路，详细可看UVA习题中<strong>倒水问题</strong></li>
<li>值得注意的是
<ol>
<li>由于是倒水次数最小，所以不需要使用优先级队列</li>
<li>由于总水量一定，所以vis开二维足够</li>
<li>如果初始水量为奇数，一定不成功。</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">struct node &#123;</span><br><span class="line">	int c[3];</span><br><span class="line">	int t;</span><br><span class="line">&#125;;</span><br><span class="line">bool vis[maxn][maxn];</span><br><span class="line">int cap[3];</span><br><span class="line">void bfs() &#123;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	int s &#x3D; cap[0];</span><br><span class="line">	node beg;</span><br><span class="line">	beg.c[0] &#x3D; s;	beg.c[1] &#x3D; 0;	beg.c[2] &#x3D; 0;</span><br><span class="line">	beg.t &#x3D; 0;</span><br><span class="line">	vis[s][0] &#x3D; 1;</span><br><span class="line">	queue&lt;node&gt; q;</span><br><span class="line">	q.push(beg);</span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		node u &#x3D; q.front(); q.pop();</span><br><span class="line">		if ((2 * u.c[0] &#x3D;&#x3D; s &amp;&amp; 2 * u.c[1] &#x3D;&#x3D; s)</span><br><span class="line">			|| (2 * u.c[0] &#x3D;&#x3D; s &amp;&amp; 2 * u.c[2] &#x3D;&#x3D; s)</span><br><span class="line">			|| (2 * u.c[1] &#x3D;&#x3D; s &amp;&amp; 2 * u.c[2] &#x3D;&#x3D; s)) &#123;</span><br><span class="line">			printf(&quot;%d\n&quot;, u.t);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 3; i++) &#123;&#x2F;&#x2F;i向j倒水</span><br><span class="line">			if (u.c[i] &#x3D;&#x3D; 0) continue;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 3; j++) &#123;</span><br><span class="line">				if (i !&#x3D; j) &#123;</span><br><span class="line">					node v &#x3D; u;</span><br><span class="line">					int delta &#x3D; min(cap[j], v.c[i] + v.c[j]) - v.c[j];</span><br><span class="line">					v.c[i] -&#x3D; delta;</span><br><span class="line">					v.c[j] +&#x3D; delta;</span><br><span class="line">					v.t +&#x3D; 1;</span><br><span class="line">					if (!vis[v.c[0]][v.c[1]]) &#123;</span><br><span class="line">						vis[v.c[0]][v.c[1]] &#x3D; 1;</span><br><span class="line">						q.push(v);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;NO\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d%d%d&quot;, &amp;cap[0], &amp;cap[1], &amp;cap[2]) &#x3D;&#x3D; 3)</span><br><span class="line">	&#123;</span><br><span class="line">		if (cap[0] &#x3D;&#x3D; 0 &amp;&amp; cap[1] &#x3D;&#x3D; 0 &amp;&amp; cap[2] &#x3D;&#x3D; 0) break;</span><br><span class="line">		if (cap[0] % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">			printf(&quot;NO\n&quot;);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		bfs();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h1>
<h2 id="汉诺塔问题"><a class="markdownIt-Anchor" href="#汉诺塔问题"></a> 汉诺塔问题</h2>
<h3 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h3>
<ol>
<li>每次都需要借助第2个柱子将前K-1小的转移到3上.具体来说是先将k-1个盘子移动到3上，再将最大的移到2上，再将k-1个移动到1上，再将最大的移动到3上，再将k-1个移动到3上。</li>
<li>设总的移动次数为F(k)=3*F(k-1)+2</li>
</ol>
<h1 id="递归的应用"><a class="markdownIt-Anchor" href="#递归的应用"></a> 递归的应用</h1>
<h2 id="素数环"><a class="markdownIt-Anchor" href="#素数环"></a> 素数环</h2>
<p><a href="https://cccceb.github.io/2020/01/24/%E7%B4%A0%E6%95%B0%E7%8E%AF/" target="_blank" rel="noopener">详情见UVA习题素数环</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 16 + 5;</span><br><span class="line">int A[maxn];</span><br><span class="line">bool isp[10000000];</span><br><span class="line">bool vis[maxn];</span><br><span class="line">int n;</span><br><span class="line">bool is_prime(int a) &#123;</span><br><span class="line">	for (int i &#x3D; 2; i &lt; a; i++)</span><br><span class="line">		if (a%i &#x3D;&#x3D; 0) return 0;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int cur) &#123;</span><br><span class="line">	if (cur &#x3D;&#x3D; n &amp;&amp; isp[A[0] + A[cur - 1]]) &#123;</span><br><span class="line">		cout &lt;&lt; A[0];</span><br><span class="line">		for (int i &#x3D; 1; i &lt; n; i++) cout &lt;&lt; &quot; &quot; &lt;&lt; A[i];</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		for (int j &#x3D; 2; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">			if (!vis[j] &amp;&amp; isp[A[cur - 1] + j]) &#123;</span><br><span class="line">				A[cur] &#x3D; j;</span><br><span class="line">				vis[j] &#x3D; 1;</span><br><span class="line">				dfs(cur + 1);</span><br><span class="line"></span><br><span class="line">				A[cur] &#x3D; 0;</span><br><span class="line">				vis[j] &#x3D; 0;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int kase &#x3D; 0;</span><br><span class="line">	while (cin &gt;&gt; n) &#123;</span><br><span class="line">		if (kase) cout &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++kase &lt;&lt; &quot;:&quot; &lt;&lt; endl;</span><br><span class="line">		memset(vis, 0,  sizeof(vis));</span><br><span class="line">		memset(isp, 0,  sizeof(isp));</span><br><span class="line">		for (int i &#x3D; 2; i &lt;&#x3D; 2 * n; i++)</span><br><span class="line">			isp[i] &#x3D; is_prime(i);</span><br><span class="line">		A[0] &#x3D; 1;</span><br><span class="line">		isp[1] &#x3D; 1;</span><br><span class="line">		dfs(1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="油田"><a class="markdownIt-Anchor" href="#油田"></a> 油田</h2>
<p>给出一个图，判断其中有多少个@的连通块。正方向和对角线都算相连</p>
<h3 id="思路-4"><a class="markdownIt-Anchor" href="#思路-4"></a> 思路</h3>
<ol>
<li>直接深搜即可</li>
<li>走的方向i,j不同时为0，简化代码为i||j</li>
</ol>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">char g[maxn][maxn];</span><br><span class="line">int r, c;</span><br><span class="line">int vis[maxn][maxn];</span><br><span class="line">int num;</span><br><span class="line">void dfs(int x, int y) &#123;</span><br><span class="line">	if (g[x][y] !&#x3D; &#39;@&#39; || vis[x][y]) return;</span><br><span class="line">	if (x &lt; 0 || x &gt;&#x3D; r || y &lt; 0 || y &gt;&#x3D; c) return;</span><br><span class="line">	vis[x][y] &#x3D; num;</span><br><span class="line">	for (int i &#x3D; -1; i &lt;&#x3D; 1; i++) &#123;</span><br><span class="line">		for (int j &#x3D; -1; j &lt;&#x3D; 1; j++) &#123;</span><br><span class="line">			if (i || j)</span><br><span class="line">				dfs(x + i, y + j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d%d\n&quot;, &amp;r, &amp;c) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		if (r &#x3D;&#x3D; 0 &amp;&amp; c &#x3D;&#x3D; 0) break;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; c; j++)</span><br><span class="line">				scanf(&quot;%c&quot;, &amp;g[i][j]);</span><br><span class="line">			getchar();</span><br><span class="line">		&#125;</span><br><span class="line">		num &#x3D; 1;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; c; j++)</span><br><span class="line">				if (g[i][j] &#x3D;&#x3D; &#39;@&#39;&amp;&amp;!vis[i][j])</span><br><span class="line">				&#123;</span><br><span class="line">					dfs(i, j);</span><br><span class="line">					num++;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, num-1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="openj_bailian-4070-全排列"><a class="markdownIt-Anchor" href="#openj_bailian-4070-全排列"></a> OpenJ_Bailian - 4070 全排列</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int maxn &#x3D; 8;</span><br><span class="line">int p[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			p[i] &#x3D; i + 1;</span><br><span class="line">		sort(p, p + n);</span><br><span class="line">		do &#123;</span><br><span class="line">			printf(&quot;%d&quot;, p[0]);</span><br><span class="line">			for (int i &#x3D; 1; i &lt; n; i++)</span><br><span class="line">				printf(&quot; %d&quot;, p[i]);</span><br><span class="line">			printf(&quot;\n&quot;);</span><br><span class="line">		&#125; while (next_permutation(p, p + n));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="深度优先搜索-dfs"><a class="markdownIt-Anchor" href="#深度优先搜索-dfs"></a> 深度优先搜索 DFS</h1>
<h2 id="temple-of-the-bone"><a class="markdownIt-Anchor" href="#temple-of-the-bone"></a> temple of the bone</h2>
<p>S是起点，D是终点，X是墙，.是地面，问能否在T时间内到达D。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 8;</span><br><span class="line">char g[maxn][maxn];</span><br><span class="line">bool vis[maxn][maxn];</span><br><span class="line">int maxr, maxc,T;</span><br><span class="line">int dx[] &#x3D; &#123; 1,-1,0,0 &#125;;</span><br><span class="line">int dy[] &#x3D; &#123; 0,0,1,-1 &#125;;</span><br><span class="line">bool dfs(int x,int y,int t) &#123;</span><br><span class="line">	if (x &lt; 0 || x &gt;&#x3D; maxr || y &lt; 0 || y &gt;&#x3D; maxc) return false;</span><br><span class="line">	if (g[x][y] &#x3D;&#x3D; &#39;D&#39;) &#123;</span><br><span class="line">		printf(&quot;YES\n&quot;);</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	if (t &gt; T) return false;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 4; i++) &#123;</span><br><span class="line">		int newx &#x3D; x + dx[i];</span><br><span class="line">		int newy &#x3D; y + dy[i];</span><br><span class="line">		if (vis[newx][newy]||g[newx][newy]&#x3D;&#x3D;&#39;X&#39;) continue;</span><br><span class="line">		vis[newx][newy] &#x3D; 1;</span><br><span class="line">		if (dfs(newx, newy, t + 1)) return true;</span><br><span class="line">		vis[newx][newy] &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int begx, begy;</span><br><span class="line"></span><br><span class="line">	while(scanf(&quot;%d%d%d\n&quot;,&amp;maxr,&amp;maxc,&amp;T)&#x3D;&#x3D;3)&#123;</span><br><span class="line">		if (maxr &#x3D;&#x3D; 0 &amp;&amp; maxc &#x3D;&#x3D; 0 &amp;&amp; T&#x3D;&#x3D;0) break;</span><br><span class="line">		memset(vis, 0, sizeof(vis));</span><br><span class="line">		for(int i &#x3D; 0; i &lt; maxr; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt; maxc; j++) &#123;</span><br><span class="line">				scanf(&quot;%c&quot;, &amp;g[i][j]);</span><br><span class="line">				if (g[i][j] &#x3D;&#x3D; &#39;S&#39;) &#123;</span><br><span class="line">					begx &#x3D; i;</span><br><span class="line">					begy &#x3D; j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			getchar();</span><br><span class="line">		&#125;</span><br><span class="line">		if (!dfs(begx, begy, 0))</span><br><span class="line">			printf(&quot;NO\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hdu-1421-搬寝室"><a class="markdownIt-Anchor" href="#hdu-1421-搬寝室"></a> HDU 1421 搬寝室</h2>
<p>搬寝室是很累的,xhd深有体会.时间追述2006年7月9号,那天xhd迫于无奈要从27号楼搬到3号楼,因为10号要封楼了.看着寝室里的n件物品,xhd开始发呆,因为n是一个小于2000的整数,实在是太多了,于是xhd决定随便搬2<em>k件过去就行了.但还是会很累,因为2</em>k也不小是一个不大于n的整数.幸运的是xhd根据多年的搬东西的经验发现每搬一次的疲劳度是和左右手的物品的重量差的平方成正比(这里补充一句,xhd每次搬两件东西,左手一件右手一件).例如xhd左手拿重量为3的物品,右手拿重量为6的物品,则他搬完这次的疲劳度为(6-3)^2 = 9.现在可怜的xhd希望知道搬完这2*k件物品后的最佳状态是怎样的(也就是最低的疲劳度),请告诉他吧.</p>
<p>每组输入数据有两行,第一行有两个数n,k(2&lt;=2*k&lt;=n&lt;2000).第二行有n个整数分别表示n件物品的重量(重量是一个小于2^15的正整数).</p>
<p>对应每组输入数据,输出数据只有一个表示他的最少的疲劳度,每个一行.</p>
<h3 id="思路-5"><a class="markdownIt-Anchor" href="#思路-5"></a> 思路</h3>
<ol>
<li>
<p>设dp[i][j]表示前i件物品组成j对所消耗的体力最小；所以分成了两种情况</p>
<ol>
<li>第j对里含有第i件物品，则dp [i][j] = dp [i-2][j-1] + (a[i]-a[i-1])*(a[i]-a[i-1]);</li>
<li>不含第i件物品则有：dp [i][j] = dp [i-1][j];</li>
</ol>
</li>
<li>
<p>总上，动态转移方程为:dp[i][j]=min(dp[i-2][j-1]+(a[i]-a[i-1])*(a[i]-a[i-1]), dp[i][j]=dp[i-1][j]);</p>
</li>
</ol>
<h3 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">int dp[2010][2010], a[2010];</span><br><span class="line">#define inf 0x3f3f3f3f</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n, k;</span><br><span class="line">	while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;k))</span><br><span class="line">	&#123;</span><br><span class="line">		int i, j;</span><br><span class="line">		memset(a, 0, sizeof(a));</span><br><span class="line">		memset(dp, 0, sizeof(dp));</span><br><span class="line">		for (i &#x3D; 0; i &lt;&#x3D; n; i++)</span><br><span class="line">			for (j &#x3D; 1; j &lt;&#x3D; k; j++)</span><br><span class="line">				dp[i][j] &#x3D; inf;</span><br><span class="line">		for (i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">		sort(a, a + n + 1);</span><br><span class="line">		for (i &#x3D; 2; i &lt;&#x3D; n; i++)</span><br><span class="line">			for (j &#x3D; 1; j * 2 &lt;&#x3D; i; j++)</span><br><span class="line">				dp[i][j] &#x3D; min(dp[i - 1][j], dp[i - 2][j - 1] + (a[i] - a[i - 1])*(a[i] - a[i - 1]));</span><br><span class="line">		printf(&quot;%d\n&quot;, dp[n][k]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hdu-3578-greedy-tino"><a class="markdownIt-Anchor" href="#hdu-3578-greedy-tino"></a> HDU 3578 Greedy Tino</h2>
<p>未完待续</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define OFFSET 2000&#x2F;&#x2F;因为j有正负，所以添加一个偏移量，方便做题</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line">int wi[101];</span><br><span class="line">int dp[101][4001];</span><br><span class="line">int max(int a, int b, int c)&#123;</span><br><span class="line">    int flag &#x3D; a;</span><br><span class="line">    if(flag &lt; b)&#123;</span><br><span class="line">        flag &#x3D; b;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag &lt; c)&#123;</span><br><span class="line">        flag &#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i&#x3D;0;i&lt;40001;i++)</span><br><span class="line">            dp[0][i] &#x3D; -INF;</span><br><span class="line">    dp[0][OFFSET] &#x3D; 0;&#x2F;&#x2F;core</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t, n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    for(int i &#x3D; 0; i &lt; t; i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        wi[0] &#x3D; 0;</span><br><span class="line">         bool hasZero &#x3D; false;</span><br><span class="line">        int cnt &#x3D; 0;</span><br><span class="line">        for(int j &#x3D; 0; j &lt; n; j++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;wi[++cnt]);</span><br><span class="line">            if(wi[cnt] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">                   hasZero &#x3D; true;</span><br><span class="line">                   cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n &#x3D; cnt;</span><br><span class="line">        init();</span><br><span class="line">        for(int j &#x3D; 1; j &lt;&#x3D; n; j++)&#123;</span><br><span class="line">            for(int k &#x3D; -2000; k &lt;&#x3D; 2000; k++)&#123;</span><br><span class="line">                dp[j][k+OFFSET] &#x3D; max(dp[j-1][k-wi[j]+OFFSET]+wi[j], dp[j-1][k+wi[j]+OFFSET]+wi[j], dp[j-1][k+OFFSET]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf (&quot;Case %d: &quot;, i+1);</span><br><span class="line">        if(dp[n][0+OFFSET] &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            if(hasZero &#x3D;&#x3D; true)&#123;</span><br><span class="line">                printf(&quot;0\n&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                printf(&quot;-1\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            printf(&quot;%d\n&quot;, dp[n][0+OFFSET]&#x2F;2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="背包"><a class="markdownIt-Anchor" href="#背包"></a> 背包</h1>
<h2 id="0-1背包问题"><a class="markdownIt-Anchor" href="#0-1背包问题"></a> 0-1背包问题</h2>
<p>特点是每个物品只能选一件，即每个物品的数量只能出现0和1</p>
<h3 id="openj_bailian-2726"><a class="markdownIt-Anchor" href="#openj_bailian-2726"></a> OpenJ_Bailian 2726</h3>
<p>辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。” 如果你是辰辰，你能完成这个任务吗？</p>
<h3 id="思路-6"><a class="markdownIt-Anchor" href="#思路-6"></a> 思路</h3>
<ol>
<li>用dp[i][j]表示取前i个物品，重量不超过j时能达到的最大价值。</li>
<li>可以根据第i个物品是否取分成两类
<ol>
<li>取第i个物品，那么需要更新所有能再装下一个i的状态，即dp[i-1][j-p[i].w]</li>
<li>不取i，那么dp[i][j]=dp[i-1][j]</li>
</ol>
</li>
<li>综上，递推关系为dp[i][j] = max(dp[i-1][j], dp[i - 1][j - p[i].w] + p[i].v)</li>
<li><strong>注意</strong> 对于dp[i-1][j]下装不下第i个物品的状态，要赋值为dp[i-1][j]</li>
</ol>
<h3 id="代码-4"><a class="markdownIt-Anchor" href="#代码-4"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line">struct node &#123;</span><br><span class="line">	int w;</span><br><span class="line">	int v;</span><br><span class="line">&#125;;</span><br><span class="line">int s, m;</span><br><span class="line">node p[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;s, &amp;m) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;p[i].w, &amp;p[i].v);</span><br><span class="line"></span><br><span class="line">		memset(dp, 0, sizeof(0));</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">			for (int j &#x3D; s; j &gt;&#x3D; p[i].w; j--) &#123;</span><br><span class="line">				dp[i][j] &#x3D; max(dp[i-1][j], dp[i - 1][j - p[i].w] + p[i].v);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			for (int j &#x3D; p[i].w-1; j &gt;&#x3D; 0; j--)&#x2F;&#x2F;对于p[i].w-1~1的状态只能来自于dp[i-1][j]</span><br><span class="line">				dp[i][j] &#x3D; dp[i-1][j];</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, dp[m][s]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h3>
<ol>
<li>发现新的状态至于最近的一个状态有关，所以可以降维。</li>
<li>状态转移方程为：dp[j]=max{dp[j-p[i].w]+v,dp[i]}</li>
<li><strong>注意</strong> 更新dp时是逆序更新，这是因为在0-1背包问题中每个物品至多放入一次。逆序循环，保证了更新dp[j]时，dp[j-p[i].w]是没有放入i时的数据(dp[i-1][j-p[i].w])</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">	for (int j &#x3D; s; j &gt;&#x3D; p[i].w; j--) &#123;</span><br><span class="line">		dp[j]&#x3D;max(dp[j-p[i].w]+v,dp[i]);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完全背包问题"><a class="markdownIt-Anchor" href="#完全背包问题"></a> 完全背包问题</h2>
<p>每种物品的数量可以任意多</p>
<h3 id="hdu-1114-piggy-bank"><a class="markdownIt-Anchor" href="#hdu-1114-piggy-bank"></a> HDU 1114 Piggy-Bank</h3>
<p>有个存钱罐，已知空罐质量和满罐质量，以及n种硬币质量和价值，求罐中硬币的最小价值。</p>
<h3 id="思路-7"><a class="markdownIt-Anchor" href="#思路-7"></a> 思路</h3>
<ol>
<li>完全背包问题的区别在于，每个物品可以被选择很多次，因此dp[j]可以由已放入物品i后的数据dp[j-p[i].w]得来，所以顺序循环</li>
<li>本题求最小值，将max要换成min</li>
<li>由于要求恰好装满，所以初始时只有dp[0]=0，其他状态都不存在</li>
</ol>
<h3 id="代码-5"><a class="markdownIt-Anchor" href="#代码-5"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 10000+ 5;</span><br><span class="line">int dp[maxn];</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line">struct node &#123;</span><br><span class="line">	int w;</span><br><span class="line">	int v;</span><br><span class="line">&#125;;</span><br><span class="line">int s, m;</span><br><span class="line">node p[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;m, &amp;s);</span><br><span class="line">		s -&#x3D; m;</span><br><span class="line">		int n;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d%d&quot;, &amp;p[i].v, &amp;p[i].w);</span><br><span class="line">		for (int i &#x3D; 0; i &lt;&#x3D; s; i++)</span><br><span class="line">			dp[i] &#x3D; INF;</span><br><span class="line">		dp[0] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			for (int j &#x3D; p[i].w; j &lt;&#x3D; s;j++) &#123;</span><br><span class="line">				if (dp[j - p[i].w] !&#x3D; INF)&#x2F;&#x2F;该状态存在，那么才可以产生新的状态</span><br><span class="line">					dp[j] &#x3D; min(dp[j], dp[j - p[i].w] + p[i].v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (dp[s] !&#x3D; INF)</span><br><span class="line">			printf(&quot;The minimum amount of money in the piggy-bank is %d.\n&quot;, dp[s]);</span><br><span class="line">		else</span><br><span class="line">			printf(&quot;This is impossible.\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多重背包问题"><a class="markdownIt-Anchor" href="#多重背包问题"></a> 多重背包问题</h2>
<p>介于完全背包问题和0-1背包问题之间，每种物品数量有限。可以将k个物品看作k种物品，在进行0-1背包求解。但是这样会使时间复杂度过大。稍加改变，将该种物品分成很多堆，每堆数量为1~k-2<sup>c+1,其中c为使k-2</sup>c+1大于0的最大整数。</p>
<h3 id="hdu-2191-珍惜现在感恩生活"><a class="markdownIt-Anchor" href="#hdu-2191-珍惜现在感恩生活"></a> HDU 2191 珍惜现在，感恩生活</h3>
<p>输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1&lt;=n&lt;=100, 1&lt;=m&lt;=100),分别表示经费的金额和大米的种类，然后是m行数据，每行包含3个数p，h和c(1&lt;=p&lt;=20,1&lt;=h&lt;=200,1&lt;=c&lt;=20)，分别表示每袋的价格、每袋的重量以及对应种类大米的袋数。</p>
<p>对于每组测试数据，请输出能够购买大米的最多重量，你可以假设经费买不光所有的大米，并且经费你可以不用完。每个实例的输出占一行。</p>
<h3 id="思路-8"><a class="markdownIt-Anchor" href="#思路-8"></a> 思路</h3>
<ol>
<li>先将每个物品分成很多堆，类似二进制拆分</li>
<li>然后进行0-1背包求解</li>
</ol>
<h3 id="代码-6"><a class="markdownIt-Anchor" href="#代码-6"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 10000 + 5;</span><br><span class="line">int dp[maxn];</span><br><span class="line">#define INF 0x7fffffff</span><br><span class="line">struct node &#123;</span><br><span class="line">	int w;</span><br><span class="line">	int v;</span><br><span class="line">&#125;;</span><br><span class="line">int s, m;</span><br><span class="line">node a[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;s, &amp;m);</span><br><span class="line">		int p, h, c;</span><br><span class="line">		int cnt &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;p, &amp;h, &amp;c);</span><br><span class="line">			int t &#x3D; 1;</span><br><span class="line">			while (c &gt; t)</span><br><span class="line">			&#123;</span><br><span class="line">				c -&#x3D; t;</span><br><span class="line">				a[++cnt].w &#x3D; t * p;</span><br><span class="line">				a[cnt].v &#x3D; t * h;</span><br><span class="line">				t *&#x3D; 2;</span><br><span class="line">			&#125;</span><br><span class="line">			a[++cnt].w &#x3D; p * c;</span><br><span class="line">			a[cnt].v &#x3D; h * c;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		memset(dp, 0, sizeof(dp));</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; cnt; i++) &#123;</span><br><span class="line">			for (int j &#x3D; s; j &gt;&#x3D; a[i].w;j--) &#123;</span><br><span class="line">					dp[j] &#x3D; max(dp[j], dp[j - a[i].w] + a[i].v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;%d\n&quot;, dp[s]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>数学理论</title>
    <url>/2020/03/30/%E6%95%B0%E5%AD%A6%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="数位拆分"><a class="markdownIt-Anchor" href="#数位拆分"></a> 数位拆分</h1>
<p>主要注意溢出问题</p>
<h1 id="进制转换"><a class="markdownIt-Anchor" href="#进制转换"></a> 进制转换</h1>
<h2 id="数值转换"><a class="markdownIt-Anchor" href="#数值转换"></a> 数值转换</h2>
<p>将a进制的s转换成b进制输出.输入a,s,b</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000000;</span><br><span class="line">char s[maxn];</span><br><span class="line">char ans[maxn];</span><br><span class="line">const char alp[] &#x3D; &#123; &#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39; &#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">	long long a, b;</span><br><span class="line">	while (scanf(&quot;%lld%s%lld&quot;, &amp;a, s, &amp;b) &#x3D;&#x3D; 3) &#123;</span><br><span class="line">		int cf &#x3D; 1;</span><br><span class="line">		long long ten &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; strlen(s) - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			if (isdigit(s[i])) &#123;</span><br><span class="line">				ten +&#x3D; (s[i] - &#39;0&#39;)*cf;</span><br><span class="line">			&#125;</span><br><span class="line">			else if (s[i] &gt;&#x3D; &#39;a&#39;&amp;&amp;s[i] &lt;&#x3D; &#39;z&#39;) &#123;</span><br><span class="line">				ten +&#x3D; (s[i] - &#39;a&#39;+10)*cf;</span><br><span class="line">			&#125;</span><br><span class="line">			else ten +&#x3D; (s[i] - &#39;A&#39;+10)*cf;</span><br><span class="line">			cf *&#x3D; a;</span><br><span class="line">		&#125;</span><br><span class="line">		int id &#x3D; 0;</span><br><span class="line">		while (ten)</span><br><span class="line">		&#123;</span><br><span class="line">			ans[id++] &#x3D; alp[ten % b];</span><br><span class="line">			ten &#x2F;&#x3D; b;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; id - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			printf(&quot;%c&quot;, ans[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进制转换-2"><a class="markdownIt-Anchor" href="#进制转换-2"></a> 进制转换</h2>
<p>将不超过30位的非负整数转成二进制</p>
<h3 id="c"><a class="markdownIt-Anchor" href="#c"></a> C++</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 30 + 5;</span><br><span class="line">char s[maxn];</span><br><span class="line">int ans[20000];</span><br><span class="line">int num[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%s&quot;, s) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; strlen(s); i++)</span><br><span class="line">			num[i] &#x3D; s[i] - &#39;0&#39;;</span><br><span class="line">		int id &#x3D; 0;</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; strlen(s);) &#123;</span><br><span class="line">			int tmp &#x3D; 0, remain &#x3D; 0;</span><br><span class="line">			for (int j &#x3D; i; j &lt; strlen(s); j++) &#123;</span><br><span class="line">				tmp &#x3D; (10 * remain + num[j]) % 2;</span><br><span class="line">				num[j] &#x3D; (10 * remain + num[j]) &#x2F; 2;</span><br><span class="line">				remain &#x3D; tmp;</span><br><span class="line">			&#125;</span><br><span class="line">			ans[id++] &#x3D; remain;</span><br><span class="line">			while (num[i] &#x3D;&#x3D; 0&amp;&amp;i&lt;strlen(s))</span><br><span class="line">				i++;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; id - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			printf(&quot;%d&quot;, ans[i]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="java"><a class="markdownIt-Anchor" href="#java"></a> ※ Java ※</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import  java.util.*;</span><br><span class="line">import java.math.BigInteger;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner in&#x3D;new Scanner(System.in);</span><br><span class="line">        while (in.hasNext())&#123;</span><br><span class="line">            String str&#x3D;in.nextLine();</span><br><span class="line">            BigInteger a&#x3D;new BigInteger(str,10);</span><br><span class="line">            System.out.println(a.toString(2));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="补充求整型ab并保留任意位小数"><a class="markdownIt-Anchor" href="#补充求整型ab并保留任意位小数"></a> 补充：求整型a/b并保留任意位小数</h3>
<p>其中res存小数部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int c &#x3D; a % b, cnt &#x3D; 0;</span><br><span class="line">c *&#x3D; 10;</span><br><span class="line">while (cnt &lt; n) &#123;</span><br><span class="line">	res[cnt] &#x3D; c &#x2F; b;</span><br><span class="line">	vis[c] &#x3D; cnt++;</span><br><span class="line">	c %&#x3D; b;</span><br><span class="line">	c *&#x3D; 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最大公约数"><a class="markdownIt-Anchor" href="#最大公约数"></a> 最大公约数</h1>
<h2 id="辗转相除法"><a class="markdownIt-Anchor" href="#辗转相除法"></a> 辗转相除法</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int gcd(int a, int b) &#123;</span><br><span class="line">	if (!b) return a;</span><br><span class="line">	else return gcd(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最小公倍数"><a class="markdownIt-Anchor" href="#最小公倍数"></a> 最小公倍数</h1>
<p>a,b两数的最小公倍数为两数的乘积除以它们的最大公约数</p>
<h2 id="least-common-multiple-eolymp-1243"><a class="markdownIt-Anchor" href="#least-common-multiple-eolymp-1243"></a> Least Common Multiple EOlymp-1243</h2>
<p>求一系列数的最小公倍数，输入的第一行为测试组数，接下来每行的第一个数为该组数字的个数，数字限定在32bit整型范围内。输出这些数字的最小公倍数。</p>
<p>注意： n等于1直接输出；<strong>尽管a,b都是32bit，但是lcm时，a*b可能大于32b,可以使用long long或者先除法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long </span><br><span class="line">ll gcd(ll a, ll b) &#123;</span><br><span class="line">	if (b &#x3D;&#x3D; 0) return a;</span><br><span class="line">	else return gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	ll a, b, x, n;</span><br><span class="line">	getchar();</span><br><span class="line"></span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		if (n &gt; 1) &#123;</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">			ll  g &#x3D; gcd(a, b);</span><br><span class="line">			ll l &#x3D; a * b &#x2F; g;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; n - 2; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				cin &gt;&gt; x;</span><br><span class="line">				if (l%x &#x3D;&#x3D; 0) continue;</span><br><span class="line">				g &#x3D; gcd(l, x);</span><br><span class="line">				l &#x3D; l * x &#x2F; g;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			cout &lt;&lt; x &lt;&lt; endl;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="素数筛法"><a class="markdownIt-Anchor" href="#素数筛法"></a> 素数筛法</h1>
<h2 id="素数判定"><a class="markdownIt-Anchor" href="#素数判定"></a> 素数判定</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool judge(int a) &#123;</span><br><span class="line">	if (a&lt;&#x3D; 1) return false;</span><br><span class="line">	for (int i &#x3D; 2; i &lt; (int)sqrt(a) + 1; i++) &#123;</span><br><span class="line">		if (a%i &#x3D;&#x3D; 0) return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="素数筛法-2"><a class="markdownIt-Anchor" href="#素数筛法-2"></a> 素数筛法</h2>
<p>要输出不超过n的所有素数，方法是当我们得到一个素数时，即将它的所有倍数均标记为非素数，这样当我们遍历到每一个数时，它没有被任何其他的素数标记为非素数，则我们确定其为素数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">memset(notp, 0, sizeof(notp));</span><br><span class="line">		for (int i &#x3D;2; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">;			if (!notp[i]) &#123;</span><br><span class="line">				for (int j &#x3D; 2; i*j &lt; n; j++)</span><br><span class="line">					notp[i*j] &#x3D; 1;</span><br><span class="line">				if (i % 10 &#x3D;&#x3D; 1) printf(&quot;%d &quot;, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="goldbachs-conjecture"><a class="markdownIt-Anchor" href="#goldbachs-conjecture"></a> Goldbach’s Conjecture</h2>
<p>别忘了打表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; (1 &lt;&lt; 15) + 5;</span><br><span class="line">bool notp[maxn];</span><br><span class="line">int sum[maxn];</span><br><span class="line">int prime[maxn];</span><br><span class="line">int get_ans() &#123;</span><br><span class="line">	memset(sum, 0, sizeof(sum));</span><br><span class="line">	int id &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 2; i &lt; maxn; i++) &#123;</span><br><span class="line">		if (!notp[i]) &#123;</span><br><span class="line">			for (int j &#x3D; 2; i*j &lt; maxn; j++)</span><br><span class="line">				notp[i*j] &#x3D; 1;</span><br><span class="line">			prime[id++] &#x3D; i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int ix &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; id; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; id; j++) &#123;</span><br><span class="line">			int h &#x3D; prime[i] + prime[j];</span><br><span class="line">			if (h &lt; maxn) &#123;</span><br><span class="line">				sum[h]++;</span><br><span class="line">				if (i &#x3D;&#x3D; j) sum[h]++;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return ix;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	int r &#x3D; get_ans();</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;n)&#x3D;&#x3D;1&amp;&amp;n)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d\n&quot;, sum[n]&#x2F;2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分解质因数"><a class="markdownIt-Anchor" href="#分解质因数"></a> 分解质因数</h1>
<p>1不是N的质因数；若N为质数，N是N的质因数</p>
<h2 id="质因数的个数"><a class="markdownIt-Anchor" href="#质因数的个数"></a> 质因数的个数</h2>
<p>求正整数N(N&gt;1)的质因数的个数。 相同的质因数需要重复计算。如120=2*2*2*3*5，共有5个质因数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100000;</span><br><span class="line">bool notp[maxn];</span><br><span class="line">int prime[maxn];</span><br><span class="line">int res[maxn];</span><br><span class="line">int get_ans() &#123;</span><br><span class="line">	int id &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 2; i &lt; maxn; i++) &#123;</span><br><span class="line">		if (!notp[i]) &#123;</span><br><span class="line">			for (int j &#x3D; 2; i*j &lt; maxn; j++)</span><br><span class="line">				notp[i*j] &#x3D; 1;</span><br><span class="line">			prime[id++] &#x3D; i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return id;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	int r &#x3D; get_ans();</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		int id &#x3D; 0;</span><br><span class="line">		memset(res, 0, sizeof(res));</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">			if (n%prime[i] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				while (n%prime[i] &#x3D;&#x3D; 0)</span><br><span class="line">				&#123;</span><br><span class="line">					res[id]++;</span><br><span class="line">					n &#x2F;&#x3D; prime[i];</span><br><span class="line">				&#125;</span><br><span class="line">				id++;</span><br><span class="line">			&#125;</span><br><span class="line">			if (n &#x3D;&#x3D; 1) break;</span><br><span class="line">		&#125;</span><br><span class="line">		if (n !&#x3D; 1) res[id++] &#x3D; 1;&#x2F;&#x2F;若测试完2~maxn内的所有素数，n仍未被分解成1</span><br><span class="line">							&#x2F;&#x2F;则剩余的余数是一定大于maxn素因数，幂次只能为1</span><br><span class="line"></span><br><span class="line">		int sum &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; id; i++)</span><br><span class="line">			sum +&#x3D; res[i];</span><br><span class="line">		printf(&quot;%d\n&quot;, sum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>maxn取1e5而不是题干中的1e9是因为，对于每个N至多有一个大于sqrt(n)的素因数，这样只需要将小于sqrt(n)的数都除去，剩下的就是该大素因数了。</li>
</ol>
<h2 id="整除问题"><a class="markdownIt-Anchor" href="#整除问题"></a> 整除问题</h2>
<p>给定n，a求最大的k，使n！可以被a<sup>k整除但不能被a</sup>(k+1)整除。<br />
输入两个整数n(2&lt;=n&lt;=1000)，a(2&lt;=a&lt;=1000)<br />
输出一个整数</p>
<h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3>
<ol>
<li>由于n!和a^k都可能很大，所以不能直接相除来判断</li>
<li>考虑整除的特征：将n!和a分别分解成素因数的乘积。如果a能整除b，则b/a是整数，则说明a和b中的素因数种类应该相同(两个素数互质)，并且b中素因数pi的幂次应该大于等于a中pi的幂次。之后，确定b中该素因数的幂次是a中对应素因数幂次的几倍，这样最小的那个数即为所求的k。</li>
<li>由于n!很大，所以不能对n!进行素因数分解。现在的目标是想确定n!中含有的素因数p对应的幂指数。n!中每一个素因数p的倍数都至少贡献一个p因子，且1到n中p的倍数共有n/p个，则p因子数至少为n/p个。同理有n/(p*p)个整数至少贡献了两个p因子。</li>
<li>统计所有n!因子中幂次最小的即为所求的k</li>
</ol>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">bool notp[maxn];</span><br><span class="line">int prime[maxn];</span><br><span class="line">int res[maxn];</span><br><span class="line">int cnta[maxn];</span><br><span class="line">int get_ans() &#123;&#x2F;&#x2F;求范围内所有的素数</span><br><span class="line">	int id &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 2; i &lt; maxn; i++) &#123;</span><br><span class="line">		if (!notp[i]) &#123;</span><br><span class="line">			for (int j &#x3D; 2; i*j &lt; maxn; j++)</span><br><span class="line">				notp[i*j] &#x3D; 1;</span><br><span class="line">			prime[id++] &#x3D; i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return id;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int a, b;</span><br><span class="line">	int r &#x3D; get_ans();</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;b, &amp;a) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(res, 0, sizeof(res));</span><br><span class="line">		memset(cnta, 0, sizeof(cnta));</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;分解n!</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">			int n &#x3D; b;</span><br><span class="line">			while (n)</span><br><span class="line">			&#123;</span><br><span class="line">				res[i]+&#x3D;n&#x2F;prime[i];</span><br><span class="line">				n &#x2F;&#x3D; prime[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int ans &#x3D; 1e8;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;分解a</span><br><span class="line">		for (int i &#x3D; 0; i &lt; r; i++) &#123;</span><br><span class="line">			if (a%prime[i] &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				while (a%prime[i] &#x3D;&#x3D; 0)</span><br><span class="line">				&#123;</span><br><span class="line">					cnta[i]++;</span><br><span class="line">					a &#x2F;&#x3D; prime[i];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if (cnta[i] &#x3D;&#x3D; 0) continue;</span><br><span class="line">			ans &#x3D; min(ans, res[i] &#x2F; cnta[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="约数的个数"><a class="markdownIt-Anchor" href="#约数的个数"></a> 约数的个数</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int get_ans(int n) &#123;</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	int i;</span><br><span class="line">	for (i &#x3D; 1; i*i &lt; n; i++)</span><br><span class="line">		if (n%i &#x3D;&#x3D; 0) ans +&#x3D; 2;</span><br><span class="line">	if (i*i &#x3D;&#x3D; n) ans++;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T,n;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		printf(&quot;%d\n&quot;, get_ans(n));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二分求幂"><a class="markdownIt-Anchor" href="#二分求幂"></a> 二分求幂</h1>
<h2 id="人见人爱ab"><a class="markdownIt-Anchor" href="#人见人爱ab"></a> 人见人爱A^B</h2>
<p>求A<sup>B的最后三位数表示的整数。说明：A</sup>B的含义是“A的B次方”</p>
<p>输入数据包含多个测试实例，每个实例占一行，由两个正整数A和B组成（1&lt;=A,B&lt;=10000），如果A=0, B=0，则表示输入数据的结束，不做处理。</p>
<p>对于每个测试实例，请输出A^B的最后三位表示的整数，每个输出占一行。</p>
<h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3>
<ol>
<li>由于a,b比较大，所以不能直接求。注意到A^B的后三位只与A的后三位有关，只存后三位即可。</li>
<li>由于A<sup>j可以由A</sup>i次得到，可以借此减少计算次数。可到的幂次包括1,2,4,8…即a<sup>k次是可以由a的1次不断求平方得到的。我们的目标是即分解a的b次变为若干个a的2</sup>k次的积，并尽可能减少分解结果的个数。指数层面就是若2^k次的和，即二进制。可以将幂次转成二进制数，取那些为1的位</li>
</ol>
<h3 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int a, b;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;a, &amp;b) &#x3D;&#x3D; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		if (a &#x3D;&#x3D; 0 &amp;&amp; b &#x3D;&#x3D; 0) break;</span><br><span class="line">		int ans &#x3D; 1;</span><br><span class="line">		while (b)</span><br><span class="line">		&#123;</span><br><span class="line">			if (b % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">				ans *&#x3D; a;</span><br><span class="line">				ans %&#x3D; 1000;</span><br><span class="line">			&#125;</span><br><span class="line">			b &#x2F;&#x3D; 2;</span><br><span class="line">			a *&#x3D; a;	&#x2F;&#x2F;更新权重</span><br><span class="line">			a %&#x3D; 1000;	&#x2F;&#x2F;保留后三位</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hdu-2817"><a class="markdownIt-Anchor" href="#hdu-2817"></a> HDU 2817</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1 &lt;&lt; 16;</span><br><span class="line">int a[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	long long a, b, c, k;</span><br><span class="line">	while (T--) &#123;</span><br><span class="line">		scanf(&quot;%lld%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c, &amp;k);</span><br><span class="line">		if (b - a &#x3D;&#x3D; c - b) &#123;</span><br><span class="line">			long long tmp &#x3D; (b - a) % 200907;</span><br><span class="line">			a %&#x3D; 200907;</span><br><span class="line">			printf(&quot;%lld\n&quot;, (a + (k - 1)*tmp) % 200907);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;	</span><br><span class="line">			long long ans &#x3D; 1;</span><br><span class="line">			long long t &#x3D; a;</span><br><span class="line">			a &#x3D; b &#x2F; a;</span><br><span class="line">			k--;</span><br><span class="line">			while (k)</span><br><span class="line">			&#123;</span><br><span class="line">				if (k % 2 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">					ans *&#x3D; a;</span><br><span class="line">					ans %&#x3D; 200907;</span><br><span class="line">				&#125;</span><br><span class="line">				k &#x2F;&#x3D; 2;</span><br><span class="line">				a *&#x3D; a;</span><br><span class="line">				a %&#x3D; 200907;</span><br><span class="line">			&#125;</span><br><span class="line">			printf(&quot;%lld\n&quot;,((t% 200907)* ans)% 200907);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="高精度整数"><a class="markdownIt-Anchor" href="#高精度整数"></a> 高精度整数</h1>
<h2 id="大整数类"><a class="markdownIt-Anchor" href="#大整数类"></a> 大整数类</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class BigInteger &#123;</span><br><span class="line">private:</span><br><span class="line">	const static int maxn &#x3D; 1000;</span><br><span class="line">	int digit[maxn];</span><br><span class="line">	int size;	&#x2F;&#x2F;[0,size)</span><br><span class="line"></span><br><span class="line">	void init() &#123;</span><br><span class="line">		memset(digit, 0, sizeof(digit));</span><br><span class="line">		size &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	void set(char s[]) &#123;</span><br><span class="line">		init();</span><br><span class="line">		int len &#x3D; strlen(s);</span><br><span class="line">		for (int i &#x3D; len - 1, j &#x3D; 0, t &#x3D; 0, c &#x3D; 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			t +&#x3D; (s[i] - &#39;0&#39;)*c;</span><br><span class="line">			c *&#x3D; 10;</span><br><span class="line">			j++;</span><br><span class="line">			if (j &#x3D;&#x3D; 4 || i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				digit[size++] &#x3D; t;</span><br><span class="line">				j &#x3D; 0;</span><br><span class="line">				t &#x3D; 0;</span><br><span class="line">				c &#x3D; 1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void output() &#123;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			if (i !&#x3D; size - 1)</span><br><span class="line">				printf(&quot;%04d&quot;, digit[i]);	&#x2F;&#x2F;不是最高位则输出前导0</span><br><span class="line">			else printf(&quot;%d&quot;, digit[i]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BigInteger operator + (const BigInteger A) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; A.size || i &lt; size; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] + A.digit[i] + cf;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BigInteger operator * (const BigInteger &amp;A) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; A.size; j++) &#123;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">				int t &#x3D; digit[i] * A.digit[j] + cf;</span><br><span class="line">				cf &#x3D; t &#x2F; 10000;</span><br><span class="line">				ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool operator &lt; (const BigInteger&amp; A) const &#123;</span><br><span class="line">		if (A.size !&#x3D; size) return size &lt; A.size;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			if (digit[i] !&#x3D; A.digit[i])</span><br><span class="line">				return digit[i] &lt; A.digit[i];</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator &gt; (const BigInteger&amp; A) const &#123; return A &lt; *this; &#125;</span><br><span class="line">	bool operator &lt;&#x3D;(const BigInteger&amp; A) const &#123; return !(A &lt; *this); &#125;</span><br><span class="line">	bool operator &gt;&#x3D;(const BigInteger&amp; A) const &#123; return !(*this &lt; A); &#125;</span><br><span class="line">	bool operator !&#x3D;(const BigInteger&amp; A) const &#123; return *this &lt; A || A &lt; *this; &#125;</span><br><span class="line">	bool operator &#x3D;&#x3D;(const BigInteger&amp; A) const &#123; return !(*this &lt; A) &amp;&amp; !(A &lt; *this); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="n的阶乘"><a class="markdownIt-Anchor" href="#n的阶乘"></a> N的阶乘</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BigInteger operator * (int a) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; size ; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] * a + cf;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;n)&#x3D;&#x3D;1) &#123;</span><br><span class="line">		BigInteger x, y;</span><br><span class="line">		char a[] &#x3D; &quot;1&quot;;</span><br><span class="line">		x.set(a);</span><br><span class="line">		for (int i &#x3D; 2; i &lt;&#x3D; n; i++)</span><br><span class="line">			x&#x3D; x * i;</span><br><span class="line">		x.output();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进制转换清华"><a class="markdownIt-Anchor" href="#进制转换清华"></a> 进制转换(清华)</h2>
<ol>
<li>重载了对整型的除法和取余，注意这两部分写法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">class BigInteger &#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">	void init() &#123;</span><br><span class="line">		memset(digit, 0, sizeof(digit));</span><br><span class="line">		size &#x3D; 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	const static int maxn &#x3D; 10000 + 5;</span><br><span class="line">	int digit[maxn];</span><br><span class="line">	int size;</span><br><span class="line">	void set(char s[]) &#123;</span><br><span class="line">		init();</span><br><span class="line">		int len &#x3D; strlen(s);</span><br><span class="line">		for (int i &#x3D; len - 1, j &#x3D; 0, t &#x3D; 0, c &#x3D; 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			t +&#x3D; (s[i] - &#39;0&#39;)*c;</span><br><span class="line">			c *&#x3D; 10;</span><br><span class="line">			j++;</span><br><span class="line">			if (j &#x3D;&#x3D; 4 || i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">				digit[size++] &#x3D; t;</span><br><span class="line">				j &#x3D; 0;</span><br><span class="line">				t &#x3D; 0;</span><br><span class="line">				c &#x3D; 1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void output() &#123;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			if (i !&#x3D; size - 1)</span><br><span class="line">				printf(&quot;%04d&quot;, digit[i]);	&#x2F;&#x2F;不是最高位则输出前导0</span><br><span class="line">			else printf(&quot;%d&quot;, digit[i]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BigInteger operator + (const BigInteger A) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; A.size || i &lt; size; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] + A.digit[i] + cf;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	BigInteger operator * (int a) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] * a + cf;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line">	BigInteger operator * (const BigInteger &amp;A) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; A.size; j++) &#123;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">				int t &#x3D; digit[i] * A.digit[j] + cf;</span><br><span class="line">				cf &#x3D; t &#x2F; 10000;</span><br><span class="line">				ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对整型除法和取模</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	BigInteger operator &#x2F; (const int a) &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		ret.init();</span><br><span class="line">		int remain &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			int t &#x3D; (remain * 10000 + digit[i]) &#x2F; a;</span><br><span class="line">			int r &#x3D; (remain * 10000 + digit[i]) % a;</span><br><span class="line">			ret.digit[i] &#x3D; t;</span><br><span class="line">			remain &#x3D; r;</span><br><span class="line">		&#125;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			if (digit[i] !&#x3D; 0) &#123;</span><br><span class="line">				ret.size &#x3D; i;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		ret.size++;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int operator % (int x) const &#123;</span><br><span class="line">		int remain &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			int t &#x3D; (remain * 10000 + digit[i]) &#x2F; x;</span><br><span class="line">			int r &#x3D; (remain * 10000 + digit[i]) % x;</span><br><span class="line">			remain &#x3D; r;</span><br><span class="line">		&#125;</span><br><span class="line">		return remain;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bool operator &lt; (const BigInteger&amp; A) const &#123;</span><br><span class="line">		if (A.size !&#x3D; size) return size &lt; A.size;</span><br><span class="line">		for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			if (digit[i] !&#x3D; A.digit[i])</span><br><span class="line">				return digit[i] &lt; A.digit[i];</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	bool operator &gt; (const BigInteger&amp; A) const &#123; return A &lt; *this; &#125;</span><br><span class="line">	bool operator &lt;&#x3D;(const BigInteger&amp; A) const &#123; return !(A &lt; *this); &#125;</span><br><span class="line">	bool operator &gt;&#x3D;(const BigInteger&amp; A) const &#123; return !(*this &lt; A); &#125;</span><br><span class="line">	bool operator !&#x3D;(const BigInteger&amp; A) const &#123; return *this &lt; A || A &lt; *this; &#125;</span><br><span class="line">	bool operator &#x3D;&#x3D;(const BigInteger&amp; A) const &#123; return !(*this &lt; A) &amp;&amp; !(A &lt; *this); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">char s[10000];</span><br><span class="line">char ans[10000];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int m, n;</span><br><span class="line">	while (scanf(&quot;%d%d\n&quot;, &amp;m, &amp;n) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">		scanf(&quot;%s&quot;, s);</span><br><span class="line">		BigInteger a, b;</span><br><span class="line">		char s1[] &#x3D; &quot;0&quot;, s2[] &#x3D; &quot;1&quot;;</span><br><span class="line">		a.set(s1);	&#x2F;&#x2F;用来保存m进制转成的十进制数</span><br><span class="line">		b.set(s2);	&#x2F;&#x2F;记录转成10进制时候的权重</span><br><span class="line">		int len &#x3D; strlen(s);</span><br><span class="line">		for (int i &#x3D; len - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">			int t;</span><br><span class="line">			if (s[i] &gt;&#x3D; &#39;0&#39;&amp;&amp;s[i] &lt;&#x3D; &#39;9&#39;)</span><br><span class="line">				t &#x3D; s[i] - &#39;0&#39;;</span><br><span class="line">			else t &#x3D; s[i] - &#39;A&#39; + 10;</span><br><span class="line">			a &#x3D; a + b * t;</span><br><span class="line">			b &#x3D; b * m;</span><br><span class="line">		&#125;</span><br><span class="line">		int id &#x3D; 0;</span><br><span class="line">		do &#123;</span><br><span class="line">			int t &#x3D; a % n;</span><br><span class="line">			if (t &gt;&#x3D; 10) ans[id] &#x3D; t - 10 + &#39;a&#39;;</span><br><span class="line">			else ans[id] &#x3D; t + &#39;0&#39;;</span><br><span class="line">			a &#x3D; a &#x2F; n;</span><br><span class="line">			id++;</span><br><span class="line">		&#125; while (a.digit[0] !&#x3D; 0 || a.size !&#x3D; 1);</span><br><span class="line">		for (int i &#x3D; id - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">			printf(&quot;%c&quot;, ans[i]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="大整数取余小数简单代码"><a class="markdownIt-Anchor" href="#大整数取余小数简单代码"></a> 大整数取余小数简单代码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void get_mod(int x) &#123;&#x2F;&#x2F;其中大整数已经由高位到低位依次存在了str中</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; strlen(str); i++) &#123;</span><br><span class="line">		ans *&#x3D; 10;</span><br><span class="line">		ans +&#x3D; str[i] - &#39;0&#39;;</span><br><span class="line">		ans %&#x3D; mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="浮点数加法"><a class="markdownIt-Anchor" href="#浮点数加法"></a> 浮点数加法</h2>
<p>求2个浮点数相加的和 题目中输入输出中出现浮点数都有如下的形式： P1P2…Pi.Q1Q2…Qj 对于整数部分，P1P2…Pi是一个非负整数 对于小数部分，Qj不等于0</p>
<p>输入： 对于每组案例，每组测试数据占2行，分别是两个加数。</p>
<p>输出： 每组案例是n行，每组测试数据有一行输出是相应的和。输出保证一定是一个小数部分不为0的浮点数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;在上述BigInteger中加入对整型的重载加法</span><br><span class="line">BigInteger operator + (const int aa) const &#123;</span><br><span class="line">		BigInteger ret;</span><br><span class="line">		int a &#x3D; aa;</span><br><span class="line">		ret.init();</span><br><span class="line">		int cf &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">			int t &#x3D; digit[i] + a + cf;</span><br><span class="line">			cf &#x3D; t &#x2F; 10000;</span><br><span class="line">			ret.digit[ret.size++] &#x3D; t % 10000;</span><br><span class="line">			if (!cf) a &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cf)</span><br><span class="line">			ret.digit[ret.size++] &#x3D; cf;</span><br><span class="line">		return ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 1000000;</span><br><span class="line">char a[maxn], b[maxn];</span><br><span class="line">BigInteger a1, a2, b1, b2;</span><br><span class="line"></span><br><span class="line">inline int get_len(int xx) &#123;</span><br><span class="line">	int len &#x3D; 0;</span><br><span class="line">	while (xx)</span><br><span class="line">	&#123;</span><br><span class="line">		len++;</span><br><span class="line">		xx &#x2F;&#x3D; 10;</span><br><span class="line">	&#125;</span><br><span class="line">	return len;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	string x, y;</span><br><span class="line">	while (getline(cin, x)) &#123;</span><br><span class="line">		getline(cin, y);</span><br><span class="line">		int id &#x3D; x.find(&quot;.&quot;);</span><br><span class="line">		int ix &#x3D; y.find(&quot;.&quot;);</span><br><span class="line">		string s1 &#x3D; x.substr(id + 1).c_str();</span><br><span class="line">		string s2 &#x3D; y.substr(ix + 1).c_str();</span><br><span class="line">		int delen &#x3D; abs(int(s1.length() - s2.length()));</span><br><span class="line">		if (delen)&#x2F;&#x2F;将小数部分补齐成相同位数</span><br><span class="line">			if (s1.length() &lt; s2.length())</span><br><span class="line">				for (int i &#x3D; 0; i &lt; delen; i++)</span><br><span class="line">					s1 +&#x3D; &#39;0&#39;;</span><br><span class="line">			else</span><br><span class="line">				for (int i &#x3D; 0; i &lt; delen; i++)</span><br><span class="line">					s2 +&#x3D; &#39;0&#39;;</span><br><span class="line">		strcpy(a, x.substr(0, id).c_str());</span><br><span class="line">		strcpy(b, s1.c_str());</span><br><span class="line">		a1.set(a);</span><br><span class="line">		a2.set(b);</span><br><span class="line">		strcpy(a, y.substr(0, ix).c_str());</span><br><span class="line">		strcpy(b, s2.c_str());</span><br><span class="line">		b1.set(a);</span><br><span class="line">		b2.set(b);</span><br><span class="line"></span><br><span class="line">		BigInteger t &#x3D; a2 + b2;</span><br><span class="line">		int c &#x3D; 0;</span><br><span class="line">		int len &#x3D; 1;</span><br><span class="line">		int l1, l2;</span><br><span class="line">		l1 &#x3D; get_len(a2.digit[a2.size - 1]);</span><br><span class="line">		l1 &#x3D; max(l1, get_len(b2.digit[b2.size - 1]));</span><br><span class="line">		&#x2F;&#x2F;如果小数部分位数增加说明有进位。需要置进位位并在小数高位减去相应的值。</span><br><span class="line">		&#x2F;&#x2F;具体又分为两种情况</span><br><span class="line">		if (t.size &#x3D;&#x3D; a2.size) &#123;</span><br><span class="line">			l2 &#x3D; get_len(t.digit[t.size - 1]);</span><br><span class="line">			if (l1 !&#x3D; l2)</span><br><span class="line">			&#123;</span><br><span class="line">				c &#x3D; 1;</span><br><span class="line">				int xx &#x3D; b2.digit[b2.size - 1];</span><br><span class="line">				while (xx)</span><br><span class="line">				&#123;</span><br><span class="line">					len *&#x3D; 10;</span><br><span class="line">					xx &#x2F;&#x3D; 10;</span><br><span class="line">				&#125;</span><br><span class="line">				t.digit[t.size - 1] -&#x3D; len;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			c &#x3D; 1;</span><br><span class="line">			t.size--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		len &#x3D; l1 - get_len(t.digit[t.size - 1]);&#x2F;&#x2F;用于控制输出小数时的前导0</span><br><span class="line">		a2 &#x3D; a1 + b1;</span><br><span class="line">		a2 &#x3D; a2 + c;</span><br><span class="line">		a2.output();</span><br><span class="line">		printf(&quot;.&quot;);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; len; i++)</span><br><span class="line">			printf(&quot;0&quot;);</span><br><span class="line">		t.output();</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10进制-vs-2进制"><a class="markdownIt-Anchor" href="#10进制-vs-2进制"></a> 10进制 vs 2进制</h2>
<p>代码都是前面提及的。<strong>但是发现在output函数中，可能输出前导0，所以加入判定条件改为：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void output() &#123;</span><br><span class="line">	for (int i &#x3D; size - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">		if (i !&#x3D; size - 1)</span><br><span class="line">			printf(&quot;%04d&quot;, digit[i]);	&#x2F;&#x2F;不是最高位则输出前导0</span><br><span class="line">		else if(digit[i])</span><br><span class="line">			printf(&quot;%d&quot;, digit[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;本题主函数</span><br><span class="line"></span><br><span class="line">char s[1005];</span><br><span class="line">bool two[1000000000];</span><br><span class="line">int main() &#123;</span><br><span class="line">	scanf(&quot;%s&quot;, s);</span><br><span class="line">	BigInteger a, b;</span><br><span class="line">	a.set(s);</span><br><span class="line">	int id &#x3D; 0;</span><br><span class="line">	do</span><br><span class="line">	&#123;</span><br><span class="line">		two[id++] &#x3D; a % 2;</span><br><span class="line">		a &#x3D; a &#x2F; 2;</span><br><span class="line"></span><br><span class="line">	&#125; while (a.size !&#x3D; 1 || a.digit[0] !&#x3D; 0);</span><br><span class="line">	char xx[] &#x3D; &quot;0&quot;, yy[] &#x3D; &quot;1&quot;;</span><br><span class="line">	a.set(xx);&#x2F;&#x2F;0</span><br><span class="line">	b.set(yy);&#x2F;&#x2F;1</span><br><span class="line">	for (int i &#x3D; id - 1; i &gt;&#x3D; 0;i--) &#123;</span><br><span class="line"></span><br><span class="line">		a &#x3D; a + b * two[i];</span><br><span class="line">		b &#x3D; b * 2;</span><br><span class="line">	&#125;</span><br><span class="line">	a.output();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘课堂目录</title>
    <url>/2020/03/30/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E8%AF%BE%E5%A0%82%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="第1章绪论"><a class="markdownIt-Anchor" href="#第1章绪论"></a> <a href="/2020/03/30/%E7%AC%AC1%E7%AB%A0%E7%BB%AA%E8%AE%BA/">第1章绪论</a></h2>
<h2 id="第2章数据"><a class="markdownIt-Anchor" href="#第2章数据"></a> <a href="/2020/03/30/%E7%AC%AC2%E7%AB%A0%E6%95%B0%E6%8D%AE/">第2章数据</a></h2>
<h2 id="第3章数据探索"><a class="markdownIt-Anchor" href="#第3章数据探索"></a> <a href="/2020/03/30/%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2kt/">第3章数据探索</a></h2>
<h2 id="第4章决策树与模型评估"><a class="markdownIt-Anchor" href="#第4章决策树与模型评估"></a> <a href="/2020/03/30/%E7%AC%AC4%E7%AB%A0%E5%86%B3%E7%AD%96%E6%A0%91%E4%B8%8E%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/">第4章决策树与模型评估</a></h2>
<h2 id="第5章其他分类技术"><a class="markdownIt-Anchor" href="#第5章其他分类技术"></a> <a href="/2020/06/13/%E7%AC%AC5%E7%AB%A0%E5%85%B6%E4%BB%96%E5%88%86%E7%B1%BB%E6%8A%80%E6%9C%AF/">第5章其他分类技术</a></h2>
<h2 id="第6章关联规则挖掘"><a class="markdownIt-Anchor" href="#第6章关联规则挖掘"></a> <a href="/2020/06/13/%E7%AC%AC6%E7%AB%A0%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E6%8C%96%E6%8E%98/">第6章关联规则挖掘</a></h2>
<h2 id="第8章聚类分析"><a class="markdownIt-Anchor" href="#第8章聚类分析"></a> <a href="/2020/06/13/%E7%AC%AC8%E7%AB%A0%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/">第8章聚类分析</a></h2>
<h2 id="数据挖掘实验一"><a class="markdownIt-Anchor" href="#数据挖掘实验一"></a> <a href="/2020/06/13/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E9%AA%8C%E4%B8%80/">数据挖掘实验一</a></h2>
<h2 id="数据挖掘实验三"><a class="markdownIt-Anchor" href="#数据挖掘实验三"></a> <a href="/2020/06/13/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E9%AA%8C%E4%B8%89/">数据挖掘实验三</a></h2>
<h2 id="数据挖掘实验二"><a class="markdownIt-Anchor" href="#数据挖掘实验二"></a> <a href="/2020/06/13/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E9%AA%8C%E4%BA%8C/">数据挖掘实验二</a></h2>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘实验一</title>
    <url>/2020/06/13/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
    <content><![CDATA[<p><a href="https://github.com/Cccceb/No3.second.git">源码:https://github.com/Cccceb/No3.second.git</a></p>
<h1 id="实验内容"><a class="markdownIt-Anchor" href="#实验内容"></a> 实验内容</h1>
<ol>
<li>采用二分网络模型，对 ml-1m 文件夹中的“用户—电影”打分数据进行建模，考虑将用户信息、电影详细信息、以及打分分值作为该网络上的边、点的权重；</li>
<li>根据网络结构特征给出节点相似性度量指标；</li>
<li>基于相似性在二分网络上进行链路预测；</li>
<li>采用交叉验证的方法验证预测结果；</li>
<li>画出 ROC 曲线来度量预测方法的准确性。</li>
</ol>
<h1 id="分析与设计"><a class="markdownIt-Anchor" href="#分析与设计"></a> 分析与设计</h1>
<ul>
<li>
<p>首先观察数据，进行数据预处理</p>
<ul>
<li>
<p>通过观察数据，发现大部分人对电影的打分在3分及以下的人数为424918，大于3分的为575268人。所以假设打分&gt;3分为喜欢，&lt;=3分为不喜欢，尽可能减少因为数据比例对分类器准确率的影响。现在的<strong>目标是根据用户过往打分数据预测对于给定样例用户是否会喜欢。</strong></p>
<img src="D:\MyBlog\source\MyImages\image-20200419200740940.png" alt="image-20200419200740940" style="zoom: 50%;" />
</li>
<li>
<p>将用户性别标签化，0表示女，1表示男</p>
</li>
</ul>
</li>
<li>
<p><strong>转换源数据</strong>，构建用户信息和喜欢的电影类型的特征表。每个数据特征包括用户的年龄，性别，职业，以及18个电影类型的独热码(但是用实际打分代替本应为1的地方)，标签为0表示不喜欢，1表示喜欢</p>
</li>
<li>
<p><strong>分割</strong>转换后的<strong>数据集</strong>，将数据集分成训练集，验证集，和测试集，比例为6:2:2。由于样本数量较多，如果使用KNN则每次判断时间复杂度都较大。观察电影的类别，发现两个类别之间可能存在联系，比如动作类和冒险类，所以二者可能不是相互独立的。因此，选择决策树进行分类。</p>
</li>
<li>
<p>由于样本数量较多，考虑调整分类的最小样本数量，采用枚举方式尝试min_samples_split的值。利用验证集得出较好的一个参数。因此自己<strong>实现决策树算法</strong>时的参数包括(dataSet, labels,min_samples_split=1)，实现时整体思路为</p>
<ul>
<li>整体采用递归结构，首部设置的<strong>递归结束条件</strong>包括
<ul>
<li>如果待分数据集长度小于min_samples_split，则采用对数票决，多数票决的结果为正例的占比</li>
<li>如果没有更多的特征可以使用，那么对剩下的数据进行多数票决</li>
<li>如果所有数据的的标签相同，那么直接返回该标签(若为1，则返回1.0 否则返回0.0 代表是正例的概率)</li>
</ul>
</li>
<li>如果不满足头部条件，则首先<strong>选择一个最优的分类属性</strong>。我使用的是熵增益来衡量不纯度，因为我认为每个特征都是多值属性，熵增益不会产生较大偏差，但是可以减少计算量。
<ul>
<li>首先计算数据集整体的熵</li>
<li>然后循环每一个特征，计算以该特征划分数据集后的熵，计算熵增益</li>
<li>选择熵增益最大的返回</li>
</ul>
</li>
<li><strong>将数据集以最优属性划分</strong>，保存为字典的形式，递归的用分割后的子集构建子树</li>
</ul>
</li>
<li>
<p>将训练好的模型在测试集上进行测试</p>
<ul>
<li>根据我的设计，分类结果为概率值，我以0.5为分界，将值映射到{0,1}</li>
<li>之后，与测试集的标签对比得到准确率</li>
</ul>
</li>
</ul>
<h1 id="详细实现"><a class="markdownIt-Anchor" href="#详细实现"></a> 详细实现</h1>
<h3 id="数据预处理"><a class="markdownIt-Anchor" href="#数据预处理"></a> 数据预处理</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">users_cols = [<span class="string">"UserID"</span>, <span class="string">"Gender"</span>, <span class="string">"Age"</span>, <span class="string">"Occupation"</span>, <span class="string">"Zip-code"</span>]</span><br><span class="line">    users =pd.read_table(<span class="string">'./ml-1m/users.dat'</span>,sep=<span class="string">"::"</span>,names = users_cols, engine=<span class="string">'python'</span>)</span><br><span class="line">    users.loc[users[<span class="string">"Gender"</span>]==<span class="string">"F"</span>,<span class="string">"Gender"</span>] = <span class="number">0</span> <span class="comment"># 手动进行标签化，0表示F，1表示M</span></span><br><span class="line">    users.loc[users[<span class="string">"Gender"</span>]==<span class="string">"M"</span>,<span class="string">"Gender"</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="分割数据集"><a class="markdownIt-Anchor" href="#分割数据集"></a> 分割数据集</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">################################### 首先对源数据进行转换 ##################################</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_genre_names</span><span class="params">(movies)</span>:</span></span><br><span class="line">    <span class="comment"># 对每条打分信息的电影进行独热编码，得到电影类型的稀疏矩阵</span></span><br><span class="line">    genres = movies[<span class="string">"Genres"</span>]</span><br><span class="line">    genres_lst = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(genres)):</span><br><span class="line">        genres_lst += genres[i].split(<span class="string">"|"</span>)</span><br><span class="line">    genres_lst =[<span class="string">"MovieID"</span>] + list(set(genres_lst))</span><br><span class="line">    df = pd.DataFrame(columns= genres_lst)</span><br><span class="line">    df[<span class="string">"MovieID"</span>] = movies[<span class="string">"MovieID"</span>].values</span><br><span class="line">    s = pd.Series()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(genres)):</span><br><span class="line">        lst = genres[i].split(<span class="string">"|"</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(lst)):</span><br><span class="line">            df.loc[i,lst[j]]= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> df.fillna(<span class="number">0</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_users_gerners</span><span class="params">(users,X_train,path,movies = pd.read_csv<span class="params">(<span class="string">"movies_genres.csv"</span>)</span>)</span>:</span></span><br><span class="line">    <span class="comment"># 将每条打分信息中的用户信息和对电影类型的打分数据构建成新表</span></span><br><span class="line">    movie_name = [<span class="string">'Mystery'</span>, <span class="string">'Film-Noir'</span>, <span class="string">'Fantasy'</span>, <span class="string">'Comedy'</span>, <span class="string">"Children's"</span>, <span class="string">'Drama'</span>,</span><br><span class="line">                  <span class="string">'Romance'</span>, <span class="string">'Horror'</span>, <span class="string">'Thriller'</span>, <span class="string">'Sci-Fi'</span>, <span class="string">'Documentary'</span>, <span class="string">'Action'</span>,</span><br><span class="line">                  <span class="string">'Animation'</span>, <span class="string">'War'</span>, <span class="string">'Crime'</span>, <span class="string">'Musical'</span>, <span class="string">'Adventure'</span>, <span class="string">'Western'</span>]</span><br><span class="line">    feature = pd.DataFrame(np.zeros((len(X_train), <span class="number">22</span>)), columns=list(users.columns.values)+movie_name) <span class="comment"># 构建一个由用户信息和电影分类构成的空df</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X_train)):</span><br><span class="line">        u_id = X_train.loc[i,<span class="string">"UserID"</span>]</span><br><span class="line">        m_id = X_train.loc[i,<span class="string">"MovieID"</span>]			<span class="comment"># 此处的movies为上一个函数的结果</span></span><br><span class="line">        feature.loc[i,<span class="string">"UserID"</span>:<span class="string">"Occupation"</span>] = users.loc[u_id<span class="number">-1</span>,<span class="string">"UserID"</span>:<span class="string">"Occupation"</span>]</span><br><span class="line">        feature.loc[i, <span class="string">"Mystery"</span>:<span class="string">"Western"</span>] = movies.loc[movies[<span class="string">"MovieID"</span>]==m_id,<span class="string">"Mystery"</span>:<span class="string">"Western"</span>].values</span><br><span class="line">    feature.to_csv(path,encoding=<span class="string">"gbk"</span>,index=<span class="literal">False</span>)</span><br><span class="line"><span class="comment">################################## 按6:2:2 分割训练集，验证集，测试集 ########################</span></span><br><span class="line">	users,movies,ratings= read_data()</span><br><span class="line">	label = ratings[<span class="string">"Rating"</span>]</span><br><span class="line">   	label[label &lt;= <span class="number">3</span>] = <span class="number">0</span>  <span class="comment"># 为了让分割结果尽可能均匀，先进行标签化</span></span><br><span class="line">    label[label &gt; <span class="number">3</span>] = <span class="number">1</span></span><br><span class="line">    feature = pd.read_csv(<span class="string">"./feature2.csv"</span>).drop(<span class="string">"UserID"</span>,axis=<span class="number">1</span>).astype(int)</span><br><span class="line">    X_tt, X_validation, Y_tt, Y_validation = train_test_split(feature, label, test_size=<span class="number">0.2</span>)  <span class="comment"># 返回测试集，验证集，测试集标签，验证集标签</span></span><br><span class="line">    X_train, X_test, Y_train, Y_test = train_test_split(X_tt, Y_tt, test_size=<span class="number">0.25</span>)</span><br></pre></td></tr></table></figure>
<h3 id="实现决策树"><a class="markdownIt-Anchor" href="#实现决策树"></a> 实现决策树</h3>
<h4 id="计算熵"><a class="markdownIt-Anchor" href="#计算熵"></a> 计算熵</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_shannon_ent</span><span class="params">(dataSet)</span>:</span> <span class="comment"># 计算信息熵</span></span><br><span class="line">    num_entries = len(dataSet)  <span class="comment"># 返回数据集的行数</span></span><br><span class="line">    label_counts = &#123;&#125; <span class="comment"># 保存每个标签出现的次数</span></span><br><span class="line">    <span class="comment"># 为所有可能分类创建字典</span></span><br><span class="line">    <span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:<span class="comment"># 对每组特征向量进行统计</span></span><br><span class="line">        current_label = featVec[<span class="number">-1</span>] <span class="comment"># 提取标签信息</span></span><br><span class="line">        <span class="keyword">if</span> current_label <span class="keyword">not</span> <span class="keyword">in</span> label_counts.keys():<span class="comment"># 如果标签没有放入统计次数的字典，则加入</span></span><br><span class="line">            label_counts[current_label] = <span class="number">0</span></span><br><span class="line">        label_counts[current_label] += <span class="number">1</span><span class="comment"># 标签计数</span></span><br><span class="line">    shannoent = <span class="number">0.0</span></span><br><span class="line">    <span class="comment"># 以二为底求对数</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> label_counts:</span><br><span class="line">        prob = float(label_counts[key])/num_entries</span><br><span class="line">        shannoent -= prob * math.log(prob, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> shannoent</span><br></pre></td></tr></table></figure>
<h4 id="取出第axis列等于value的特征"><a class="markdownIt-Anchor" href="#取出第axis列等于value的特征"></a> 取出第axis列等于value的特征</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_dataset</span><span class="params">(dataSet, axis, value)</span>:</span><span class="comment"># 取出第axis列等于value的特征</span></span><br><span class="line">    tmp = dataSet[dataSet[:,axis]==value]</span><br><span class="line">    <span class="keyword">return</span> np.delete(tmp,axis,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="求最优划分属性"><a class="markdownIt-Anchor" href="#求最优划分属性"></a> 求最优划分属性</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choose_best</span><span class="params">(dataSet)</span>:</span> <span class="comment"># 按照信息增益，计算最好的分类标准</span></span><br><span class="line">    numFeatures = len(dataSet[<span class="number">0</span>]) - <span class="number">1</span> <span class="comment"># 减去标签</span></span><br><span class="line">    baseEntropy = calc_shannon_ent(dataSet) <span class="comment"># 整体的熵</span></span><br><span class="line">    bestInfoGain = <span class="number">0.0</span></span><br><span class="line">    bestFeature = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建唯一分类标签</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(numFeatures):</span><br><span class="line">        featList = list(dataSet[:,i])</span><br><span class="line">        uniqueValis = set(featList)</span><br><span class="line">        newEntropy = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计划每种划分的信息墒</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> uniqueValis: <span class="comment"># 循环每种取值</span></span><br><span class="line">            subDataSet = split_dataset(dataSet, i ,value) <span class="comment"># 对于第i类取值为</span></span><br><span class="line">            prob = len(subDataSet)/float(len(dataSet))</span><br><span class="line">            newEntropy += prob * calc_shannon_ent(subDataSet)</span><br><span class="line">            infoGain = baseEntropy - newEntropy</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算最好的增益墒</span></span><br><span class="line">            <span class="keyword">if</span> infoGain &gt; bestInfoGain:</span><br><span class="line">                bestInfoGain = infoGain</span><br><span class="line">                bestFeature = i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bestFeature</span><br></pre></td></tr></table></figure>
<h4 id="多数票决过程-返回正例占比"><a class="markdownIt-Anchor" href="#多数票决过程-返回正例占比"></a> 多数票决过程 返回正例占比</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majoritycnt</span><span class="params">(classList)</span>:</span> <span class="comment"># 实现多数票决函数</span></span><br><span class="line">    classCount = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> vote <span class="keyword">in</span> classList:</span><br><span class="line">        <span class="keyword">if</span> vote <span class="keyword">not</span> <span class="keyword">in</span> classCount.keys():</span><br><span class="line">            classCount[vote] = <span class="number">0</span></span><br><span class="line">        classCount[vote] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># return max(classCount,key=classCount.get)# 返回最大的值对应的键</span></span><br><span class="line">    <span class="keyword">return</span> has_key(classCount,<span class="number">1</span>)/len(classList)</span><br></pre></td></tr></table></figure>
<h3 id="构建树训练模型-主过程"><a class="markdownIt-Anchor" href="#构建树训练模型-主过程"></a> 构建树/训练模型 (主过程)</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_tree</span><span class="params">(dataSet, labels,min_samples_split=<span class="number">1</span>)</span>:</span> <span class="comment"># 创建决策树</span></span><br><span class="line">    classList = list(dataSet[:,<span class="number">-1</span>]) <span class="comment"># 得到所有的标签</span></span><br><span class="line">    <span class="keyword">if</span> len(dataSet)&lt;=min_samples_split:</span><br><span class="line">        <span class="keyword">return</span> majoritycnt(classList)</span><br><span class="line">    <span class="keyword">if</span> len(dataSet[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 停止分割直至没有更多特征，则多数票决</span></span><br><span class="line">        <span class="keyword">return</span> majoritycnt(classList)</span><br><span class="line">    <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == len(classList):</span><br><span class="line">        <span class="comment"># 停止分类直至所有类别相等,都是classList[0]</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> <span class="keyword">if</span> classList[<span class="number">0</span>] == <span class="number">1</span> <span class="keyword">else</span> <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    bestfaet = choose_best(dataSet)<span class="comment"># 根据信息熵计算最优标签</span></span><br><span class="line">    <span class="comment"># print(labels,bestfaet)</span></span><br><span class="line">    bestfaetlabel = labels[bestfaet]</span><br><span class="line">    mytree = &#123;bestfaetlabel:&#123;&#125;&#125; <span class="comment"># 根据最有特征的标签生成树</span></span><br><span class="line">    <span class="keyword">del</span>(labels[bestfaet])<span class="comment"># 删除已经使用的标签</span></span><br><span class="line">    <span class="comment"># 得到包含所有属性的列表</span></span><br><span class="line">    featvalues = list(dataSet[:,bestfaet])</span><br><span class="line">    uniquevalues = set(featvalues) <span class="comment"># 去掉重复的属性</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniquevalues: <span class="comment"># 遍历特征创建决策树</span></span><br><span class="line">        sublables = labels[:]</span><br><span class="line">        mytree[bestfaetlabel][value] = create_tree(split_dataset(dataSet, bestfaet, value), sublables,min_samples_split)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mytree</span><br></pre></td></tr></table></figure>
<ul>
<li>调用时，我将min_samples_split 设为5，这个值是最开始用sklearn的决策树时候迭代得到的，电脑这两天不太正常，所以没有重新迭代求最优参数</li>
</ul>
<h3 id="测试模型"><a class="markdownIt-Anchor" href="#测试模型"></a> 测试模型</h3>
<h4 id="预测函数"><a class="markdownIt-Anchor" href="#预测函数"></a> 预测函数</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify</span><span class="params">(inputtree, featlabels, testvec)</span>:</span><span class="comment"># 这里与构建树类似，也是递归进行，不在赘述</span></span><br><span class="line">    firststr = list(inputtree.keys())[<span class="number">0</span>]</span><br><span class="line">    seconddict = inputtree[firststr]</span><br><span class="line">    featindex = featlabels.index(firststr)</span><br><span class="line">    key = testvec[featindex]</span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> seconddict.keys(): <span class="comment"># 如果firststr没有取值为key的，那么随机一个打分</span></span><br><span class="line">        valueoffeat = np.random.rand()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        valueoffeat = seconddict[key]</span><br><span class="line">    <span class="keyword">if</span> isinstance(valueoffeat, dict):<span class="comment"># 没到叶子，继续划分</span></span><br><span class="line">        classlabel = classify(valueoffeat, featlabels, testvec)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        classlabel = valueoffeat<span class="comment"># 叶子结点，返回打分</span></span><br><span class="line">    <span class="keyword">return</span> classlabel</span><br></pre></td></tr></table></figure>
<h4 id="测试模型画出roc曲线"><a class="markdownIt-Anchor" href="#测试模型画出roc曲线"></a> 测试模型，画出ROC曲线</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_tree</span><span class="params">(inputtree, featlabels, testdata,Y_test)</span>:</span></span><br><span class="line">    prob = np.array([classify(inputtree, featlabels,testdata[i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(testdata))]).reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">    pred =np.array([<span class="number">1</span> <span class="keyword">if</span> i&gt;<span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> prob]).reshape(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">    acc = (pred==Y_test).sum()/len(Y_test)</span><br><span class="line">    print(<span class="string">"-ACC"</span>,acc)</span><br><span class="line">    <span class="keyword">return</span> acc</span><br><span class="line">    print(prob)</span><br><span class="line">    fpr, tpr, threshold = roc_curve(Y_test, prob)  <span class="comment"># 计算真正率和假正率</span></span><br><span class="line">    roc_auc = auc(fpr, tpr)  <span class="comment"># 计算auc的值</span></span><br><span class="line">    plt.figure()</span><br><span class="line">    lw = <span class="number">2</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">    plt.plot(fpr, tpr, color=<span class="string">'darkorange'</span>,</span><br><span class="line">             lw=<span class="number">2</span>*lw, label=<span class="string">'ROC curve (area = %0.3f)'</span> % roc_auc)  <span class="comment">###假正率为横坐标，真正率为纵坐标做曲线</span></span><br><span class="line">    plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], color=<span class="string">'navy'</span>, lw=lw, linestyle=<span class="string">'--'</span>)</span><br><span class="line">    plt.xlim([<span class="number">0.0</span>, <span class="number">1.0</span>])</span><br><span class="line">    plt.ylim([<span class="number">0.0</span>, <span class="number">1.0</span>])</span><br><span class="line">    plt.xlabel(<span class="string">'False Positive Rate'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'True Positive Rate'</span>)</span><br><span class="line">    plt.title(<span class="string">'Receiver operating characteristic example'</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">"lower right"</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<h3 id="十折交叉验证"><a class="markdownIt-Anchor" href="#十折交叉验证"></a> 十折交叉验证</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">  Y = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">  X_tt, X[<span class="number">9</span>], Y_tt, Y[<span class="number">9</span>] = train_test_split(feature, label, test_size=<span class="number">1</span> / <span class="number">10</span>)</span><br><span class="line">  X_tt, X[<span class="number">8</span>], Y_tt, Y[<span class="number">8</span>] = train_test_split(X_tt, Y_tt, test_size=<span class="number">1</span> / <span class="number">9</span>)</span><br><span class="line">  X_tt, X[<span class="number">7</span>], Y_tt, Y[<span class="number">7</span>] = train_test_split(X_tt, Y_tt, test_size=<span class="number">1</span> / <span class="number">8</span>)</span><br><span class="line">  X_tt, X[<span class="number">6</span>], Y_tt, Y[<span class="number">6</span>] = train_test_split(X_tt, Y_tt, test_size=<span class="number">1</span> / <span class="number">7</span>)</span><br><span class="line">  X_tt, X[<span class="number">5</span>], Y_tt, Y[<span class="number">5</span>] = train_test_split(X_tt, Y_tt, test_size=<span class="number">1</span> / <span class="number">6</span>)</span><br><span class="line">  X_tt, X[<span class="number">4</span>], Y_tt, Y[<span class="number">4</span>] = train_test_split(X_tt, Y_tt, test_size=<span class="number">1</span> / <span class="number">5</span>)</span><br><span class="line">  X_tt, X[<span class="number">3</span>], Y_tt, Y[<span class="number">3</span>] = train_test_split(X_tt, Y_tt, test_size=<span class="number">1</span> / <span class="number">4</span>)</span><br><span class="line">  X_tt, X[<span class="number">2</span>], Y_tt, Y[<span class="number">2</span>] = train_test_split(X_tt, Y_tt, test_size=<span class="number">1</span> / <span class="number">3</span>)</span><br><span class="line">  X[<span class="number">0</span>], X[<span class="number">1</span>], Y[<span class="number">0</span>], Y[<span class="number">1</span>] = train_test_split(X_tt, Y_tt, test_size=<span class="number">1</span> / <span class="number">2</span>)</span><br><span class="line">  feature = [<span class="string">'Gender'</span>, <span class="string">'Age'</span>, <span class="string">'Occupation'</span>, <span class="string">'Mystery'</span>, <span class="string">'Film-Noir'</span>,</span><br><span class="line">     <span class="string">'Fantasy'</span>, <span class="string">'Comedy'</span>, <span class="string">"Children's"</span>, <span class="string">'Drama'</span>, <span class="string">'Romance'</span>, <span class="string">'Horror'</span>,</span><br><span class="line">     <span class="string">'Thriller'</span>, <span class="string">'Sci-Fi'</span>, <span class="string">'Documentary'</span>, <span class="string">'Action'</span>, <span class="string">'Animation'</span>, <span class="string">'War'</span>,</span><br><span class="line">     <span class="string">'Crime'</span>, <span class="string">'Musical'</span>, <span class="string">'Adventure'</span>, <span class="string">'Western'</span>]</span><br><span class="line">  ACC = []</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">      columns = feature.copy()</span><br><span class="line">      print(<span class="string">"Round"</span>,i)</span><br><span class="line">      X_train = X_test = pd.DataFrame(columns=columns)</span><br><span class="line">      Y_train = Y_test =  pd.Series()</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">          <span class="keyword">if</span> i!=j:</span><br><span class="line">              X_train = X_train.append(X[j])</span><br><span class="line">              Y_train = Y_train.append(Y[j])</span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">              X_test = X[j]</span><br><span class="line">              Y_test = Y[j]</span><br><span class="line">      <span class="comment"># print(X_train.shape,Y_train.shape)</span></span><br><span class="line">      <span class="comment"># print(X_test.shape,Y_test.shape)</span></span><br><span class="line">      <span class="comment"># clf = classifier2(X_train,Y_train)</span></span><br><span class="line">      <span class="comment"># test_model2(clf, X_test, Y_test)</span></span><br><span class="line">      trainSet = np.hstack((X_train.values,Y_train.values.reshape(<span class="number">-1</span>,<span class="number">1</span>)))</span><br><span class="line">      DecTree = create_tree(trainSet, columns, <span class="number">5</span>)</span><br><span class="line">      print(DecTree)</span><br><span class="line">      ACC.append(test_tree(DecTree, feature, X_test.values, Y_test.values.reshape(<span class="number">-1</span>,<span class="number">1</span>)))</span><br><span class="line">  print(<span class="string">"Avg_Acc = "</span>,np.mean(ACC))</span><br></pre></td></tr></table></figure>
<h1 id="实验结果"><a class="markdownIt-Anchor" href="#实验结果"></a> 实验结果</h1>
<h3 id="测试集上结果"><a class="markdownIt-Anchor" href="#测试集上结果"></a> 测试集上结果</h3>
<img src="D:\MyBlog\source\MyImages\X_test_2.png" style="zoom: 33%;" />
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5CSnap6.png" alt="" /></p>
<p><strong>准确率为99.7%</strong></p>
<h3 id="交叉验证准确率"><a class="markdownIt-Anchor" href="#交叉验证准确率"></a> 交叉验证准确率</h3>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5CSnap4.png" alt="" /></p>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5CSnap5.png" alt="Snap5" /></p>
<h3 id="结果总结"><a class="markdownIt-Anchor" href="#结果总结"></a> 结果总结</h3>
<ul>
<li>经过多次尝试，目前的AUC值达到1，感到很意外。十折交叉验证的准确率为99.8%</li>
<li>第一次交叉验证时，没有在划分数据集之前就将打分二值化。导致训练集和测试集的样本分布不一致，在第5.6轮开始准确率突然下降。修改之后解决问题</li>
<li>如果结果没有问题，那么本次实验让我深刻感受到决策树的强大</li>
<li>我认为我这个树构建之后和KNN的思想比较类似。关于AUC值为1，我认为是因为由于我min_samples_split 设置的比较小，所以分类的概率值取值有限，大多数值聚集在0和1上，所以最终曲线的AUC为1。同时，我也尝试改变min_samples_split ，随着 min_samples_split 的增大，AUC值会变小。而且，我最开始全部使用sklearn库的时候AUC也是1，所以按我理解来看，没有问题。</li>
</ul>
<h1 id="心得体会"><a class="markdownIt-Anchor" href="#心得体会"></a> 心得体会</h1>
<ul>
<li>
<p>第一次进行数据挖掘，感觉无从下手。转换源数据集时进行了多次尝试，第一次是将打分数据按照用户编号聚合，计算用户对每个类型的打分平均值。以用户信息为特征，每个类型的打分为标签，训练18个二分类器。对于测试样本，首先得到该电影包含哪些类型，然后对该用户使用相应类型的二分类器，得到若干个0或1表示该用户对该电影中哪些类型喜欢，或不喜欢。最后多数票决判定对该电影整体是否喜欢。但是结果很差</p>
<ul>
<li>我认为原因是特征太少，按用户编号聚合后，样本也少，导致模型预测能力很差</li>
</ul>
<img src="D:\MyBlog\source\MyImages\X_test_roc.png" style="zoom: 33%;" />
</li>
<li>
<p>还尝试了使用用户信息和电影类型的独热码来训练模型，结果好了一些</p>
<img src="D:\MyBlog\source\MyImages\X_test_1.png" style="zoom: 33%;" />
<ul>
<li>这里使用的特征只能说明用户看了这些电影类型，而没有将是否喜欢(具体打分)考虑进去</li>
<li>所以最后用用户给每个类型的打分和用户信息为特征来训练模型，得到实验结果中的ROC曲线</li>
</ul>
</li>
<li>
<p>遇到过的问题：起初，我按照直觉将大于等于3的都认为是正例，导致最后准确率很高(83%),但是AUC很小(0.5)。后来才发现我的准确率高是因为样本分布的问题，实际模型并不可靠。本次实验令我深刻理解了ROC曲线的含义。准确率可能会受到数据分布的影响，但是ROC曲线能较好的反应模型的可信度。</p>
</li>
<li>
<p>我认为准确率高是因为训练样本足够多，比较训练集的结果和交叉验证结果可以看出随着训练样本的增多，准确率还在提高。如果避开所有训练样例中每个属性取值，那么预测结果就是完全随机的打分。这也说明了数据的重要性</p>
</li>
</ul>
<p>​																														<strong>17069130005</strong></p>
<p>​																														             <strong>崔恩博</strong></p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘实验三</title>
    <url>/2020/06/13/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E9%AA%8C%E4%B8%89/</url>
    <content><![CDATA[<p><a href="https://github.com/Cccceb/No3.second.git">源码:https://github.com/Cccceb/No3.second.git</a></p>
<h1 id="实验内容"><a class="markdownIt-Anchor" href="#实验内容"></a> 实验内容</h1>
<p>1、导入 karate.gml 中的空手道网络数据；</p>
<p>2、根据网络结构特征给出节点相似性度量指标；</p>
<p>3、采用层次聚类过程对网络数据进行聚类；</p>
<p>4、计算模块性指标 Q 值，当 Q 值最大时输出聚类结果；</p>
<p>5、采用 Cytoscape 工具，可视化聚类结果</p>
<h1 id="分析及设计"><a class="markdownIt-Anchor" href="#分析及设计"></a> 分析及设计</h1>
<h2 id="1-选择相似性度量"><a class="markdownIt-Anchor" href="#1-选择相似性度量"></a> 1. 选择相似性度量</h2>
<p>观察数据发现，给定数据是一个无向无权图，所以不能通过欧式距离来衡量距离。备选的方案包括余弦相似度，Jaccard系数和最短跳数。对于本实验，Jaccard和余弦相似度非常接近，所以我后面尝试使用了余弦相似度和最短跳数。</p>
<h2 id="2-实现层次聚类算法"><a class="markdownIt-Anchor" href="#2-实现层次聚类算法"></a> 2. 实现层次聚类算法</h2>
<ol>
<li>根据1中定义的度量可以计算出一个相似度/距离矩阵，利用这个矩阵可以进行层次聚类</li>
<li>层次聚类采用递归实现，使用一个列表存每个点所属的类。合并类的时候，将两个类标号归到二者中较小的标号上。</li>
<li>初始状态下，令每个点都是一个簇。</li>
<li>每次选择在原图中有边，而在当前状态下还没连上边的两个节点。利用参数函数(Single/MAX/组平均)计算这两个点所在簇之间的相似度，取相似度最大的两个簇进行合并，并更新列表。同时记录相关数据，便于后续绘图。</li>
<li>根据更新后的结果计算模块化度量Q，如果大于目前的最优解，则更新最优解。</li>
<li>重复4，5步直到合并为1类。</li>
</ol>
<h1 id="详细实现"><a class="markdownIt-Anchor" href="#详细实现"></a> 详细实现</h1>
<h2 id="1-计算余弦相似度"><a class="markdownIt-Anchor" href="#1-计算余弦相似度"></a> 1. 计算余弦相似度</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calCosSimilarity</span><span class="params">(g)</span>:</span></span><br><span class="line">    <span class="comment"># 计算余弦相似度，返回相似度矩阵</span></span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">34</span>):</span><br><span class="line">        tmp = []</span><br><span class="line">        sa = set(g.neighbors(i))</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">34</span>):</span><br><span class="line">            sb = set(g.neighbors(j))</span><br><span class="line">            <span class="comment"># 用两个点的邻居节点的交集/两个集合长度乘积的平方根</span></span><br><span class="line">            tmp.append(len(sa &amp; sb)/math.sqrt(len(sa)*len(sb)))</span><br><span class="line">        data.append(tmp)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    <span class="comment"># return 34- np.array(g.shortest_paths()) # 最短跳数，因为后面都是按相似度编程，所以用34-最短条数，等价于相似度</span></span><br></pre></td></tr></table></figure>
<h2 id="2-实现层次聚类"><a class="markdownIt-Anchor" href="#2-实现层次聚类"></a> 2. 实现层次聚类</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(kind,maxQ)</span>:</span></span><br><span class="line">    skind = set(kind)</span><br><span class="line">    real = <span class="number">0</span></span><br><span class="line">    null =<span class="number">0</span></span><br><span class="line">    all = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(kind))]</span><br><span class="line"></span><br><span class="line">    <span class="comment">############################ 计算模块化度量Q ####################</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(g.vcount()):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(g.vcount()):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> g.neighbors(j) <span class="keyword">and</span> kind[i] == kind[j]:</span><br><span class="line">                    real += <span class="number">1</span> <span class="comment"># real每个簇内边的个数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(g.vcount()):</span><br><span class="line">        all[kind[i]] += g.degree(i)<span class="comment"># all[i]表示标号为i的簇中节点的度的和</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> all:</span><br><span class="line">        null += (i/(<span class="number">2</span>*self.m))**<span class="number">2</span></span><br><span class="line">    nowQ = (real/(<span class="number">2</span>*self.m)) -null <span class="comment"># 带入公式计算Q值</span></span><br><span class="line">    num_kind = len(set(kind))</span><br><span class="line">    print(<span class="string">"Class："</span>, num_kind, <span class="string">"Q："</span>, nowQ)</span><br><span class="line">    print(kind)</span><br><span class="line">    self.kind[num_kind] = kind.copy() <span class="comment"># 记录一些数据用于画图</span></span><br><span class="line">    self.x.append(num_kind)</span><br><span class="line">    self.y.append(nowQ)</span><br><span class="line">    <span class="keyword">if</span> len(skind) == <span class="number">1</span>: <span class="comment"># 递归结束标志：当只剩下一个类的时候结束递归</span></span><br><span class="line">        <span class="keyword">return</span> maxQ</span><br><span class="line">    <span class="keyword">if</span> nowQ &gt; maxQ:<span class="comment"># 判断是否需要更新结果</span></span><br><span class="line">        maxQ = nowQ</span><br><span class="line">        self.res = kind.copy()</span><br><span class="line">    maxx = <span class="number">-1</span></span><br><span class="line">    tmpi,tmpj = <span class="number">-1</span>,<span class="number">-1</span></span><br><span class="line">    <span class="comment">#################### 选择相似度最大的两个簇进行合并 ######################</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(g.vcount()):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(g.vcount()):</span><br><span class="line">            <span class="comment"># 如果两个点已经在同一个簇，或者不直接相连，那么可以先跳过</span></span><br><span class="line">            <span class="keyword">if</span> i==j <span class="keyword">or</span> kind[i] == kind[j] <span class="keyword">or</span> j <span class="keyword">not</span> <span class="keyword">in</span> self.g.neighbors(i): <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 计算这两个簇之间的单链/全链/组平均相似度</span></span><br><span class="line">            tmp = fun(self.data,[x <span class="keyword">for</span> x <span class="keyword">in</span> range(g.vcount()) <span class="keyword">if</span> kind[x] == kind[i]]</span><br><span class="line">                      ,[x <span class="keyword">for</span> x <span class="keyword">in</span> range(g.vcount()) <span class="keyword">if</span> kind[x] == kind[j]])</span><br><span class="line">            <span class="keyword">if</span> tmp &gt; maxx:<span class="comment"># 记录相似度最大的两个簇</span></span><br><span class="line">                maxx = tmp</span><br><span class="line">                tmpi = i</span><br><span class="line">                tmpj = j</span><br><span class="line">    <span class="keyword">if</span> tmpi == <span class="number">-1</span> <span class="keyword">or</span> tmpj == <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> maxQ</span><br><span class="line">    <span class="keyword">if</span> tmpi &gt; tmpj:<span class="comment"># 始终保持tmpi &lt; tmpj 便于管理</span></span><br><span class="line">        tp = tmpi</span><br><span class="line">        tmpi = tmpj</span><br><span class="line">        tmpj = tp</span><br><span class="line">    old = kind[tmpj]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(kind)):<span class="comment"># 将两个簇的标号合并为较小的一个</span></span><br><span class="line">        <span class="keyword">if</span> kind[i] == old:</span><br><span class="line">            kind[i] = kind[tmpi]</span><br><span class="line">    <span class="keyword">return</span> max(solve(kind,maxQ),maxQ)</span><br></pre></td></tr></table></figure>
<h2 id="3-实现单链全链组平均"><a class="markdownIt-Anchor" href="#3-实现单链全链组平均"></a> 3. 实现单链/全链/组平均</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Singlle</span><span class="params">(data,l1,l2)</span>:</span><span class="comment"># 带入公式即可，注意是在处理相似度</span></span><br><span class="line">    <span class="comment"># li代表第i个簇的全体节点的下表列表</span></span><br><span class="line">    maxx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> l1:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> l2:</span><br><span class="line">            maxx = max(data[i][j],maxx)</span><br><span class="line">    <span class="keyword">return</span> maxx</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MAX</span><span class="params">(data,l1,l2)</span>:</span></span><br><span class="line">    minn = <span class="number">10000</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> l1:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> l2:</span><br><span class="line">            minn = min(data[i][j],minn)</span><br><span class="line">    <span class="keyword">return</span> minn</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AVG</span><span class="params">(data,l1,l2)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> l1:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> l2:</span><br><span class="line">            sum += data[i][j]</span><br><span class="line">    <span class="keyword">return</span> sum /(len(l1)*len(l2))</span><br></pre></td></tr></table></figure>
<h1 id="实验结果"><a class="markdownIt-Anchor" href="#实验结果"></a> 实验结果</h1>
<h2 id="1-基于余弦相似度"><a class="markdownIt-Anchor" href="#1-基于余弦相似度"></a> 1. 基于余弦相似度</h2>
<h3 id="11-全链"><a class="markdownIt-Anchor" href="#11-全链"></a> 1.1 全链</h3>
<p><img src="D:\MyBlog\source\MyImages\image-20200606001608081.png" alt="image-20200606001608081" style="zoom:50%;" />x轴为对应的簇数</p>
<img src="D:\MyBlog\source\MyImages\image-20200606001654629.png" alt="image-20200606001654629" style="zoom: 67%;" />
<p>最优的Q为 0.40466798159105843，合并为6类</p>
<p><strong>Cytoscape结果</strong></p>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Ckarate.gml2-1591374020604.png" alt="Cytoscape" /></p>
<h3 id="12-组平均cytoscape结果见附件"><a class="markdownIt-Anchor" href="#12-组平均cytoscape结果见附件"></a> 1.2 组平均(<strong>Cytoscape结果</strong>见附件)</h3>
<img src="D:\MyBlog\source\MyImages\image-20200606002134765.png" alt="image-20200606002134765" style="zoom:50%;" />
<img src="D:\MyBlog\source\MyImages\image-20200606002153001.png" alt="image-20200606002153001" style="zoom:67%;" />
<p>最好情况Q=0.37516436554898086被分成四类</p>
<h3 id="13-单链"><a class="markdownIt-Anchor" href="#13-单链"></a> 1.3 单链</h3>
<p>单链效果很差。从单链的特性考虑，可能是因为他更善于识别椭圆的簇，并且对噪声和离群点敏感</p>
<img src="D:\MyBlog\source\MyImages\image-20200606002349364.png" alt="image-20200606002349364" style="zoom:50%;" />
<h2 id="2-基于最短跳数"><a class="markdownIt-Anchor" href="#2-基于最短跳数"></a> 2. 基于最短跳数</h2>
<h3 id="21-组平均cytoscape结果见附件"><a class="markdownIt-Anchor" href="#21-组平均cytoscape结果见附件"></a> 2.1 组平均(Cytoscape结果见附件)</h3>
<img src="D:\MyBlog\source\MyImages\image-20200607235832677.png" alt="image-20200607235832677" style="zoom:50%;" />
<img src="D:\MyBlog\source\MyImages\image-20200607235845904.png" alt="image-20200607235845904" style="zoom: 67%;" />
<p>最好情况Q=0.41978961209730437被分成四类</p>
<h3 id="22-全链cytoscape结果见附件"><a class="markdownIt-Anchor" href="#22-全链cytoscape结果见附件"></a> 2.2 全链(Cytoscape结果见附件)</h3>
<img src="D:\MyBlog\source\MyImages\image-20200607235950956.png" alt="image-20200607235950956" style="zoom:50%;" />
<img src="D:\MyBlog\source\MyImages\image-20200607235959013.png" alt="image-20200607235959013" style="zoom:67%;" />
<p>最好情况Q=0.3921761998685076被分成三类</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<ol>
<li>整体来看，基于最小跳数的度量比基于余弦相似度的度量具有更好的Q值，全链和组平均技术比单链技术具有更好的Q值。</li>
<li>余弦相似度反应的是两个人朋友圈的交集的大小，最小跳数直观的反应两人间的距离。我认为都是有道理的度量，基于最小条数的度量结果更好可能与网络规模有关。另外对于大规模网络，计算最小跳数的复杂度也很高，我还是倾向于使用余弦相似度。</li>
<li>我认为全链技术和组平均能更全面的衡量两个簇间的距离，所以比单链的性能好。</li>
</ol>
<h1 id="心得体会"><a class="markdownIt-Anchor" href="#心得体会"></a> 心得体会</h1>
<ol>
<li>
<p>通过本次实验，实现了层次聚类算法。通过多种技术和度量标准，对比实验，将学习到的知识加以实验，令我有了直观的感受。</p>
</li>
<li>
<p>对于模块化度量的值没有概念，不知道具体多少是比较正常的数值。以后还应该多多学习，多做实验，增加经验。</p>
</li>
<li>
<p>学习的时候就感觉单链技术会导致以偏概全的情况，本次实验后发现，单链技术确实对某些问题性能较差，本次实验令我受益匪浅。</p>
<p>​</p>
<p>​																														<strong>17069130005</strong></p>
<p>​																																	<strong>崔恩博</strong></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>旅行</title>
    <url>/2020/03/30/%E6%97%85%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="uv1-1347-旅行"><a class="markdownIt-Anchor" href="#uv1-1347-旅行"></a> UV1 1347 旅行</h1>
<p>John Doe想用最小的路程游览完所有目的地。每个目的地都用坐标xi,yi表示。任何两目的地的xi都不相同。两目的地之间的路程是两点之间的直线距离。John是这样走的：他从最左边的点开始，然后只能向右走，走到最右边的点，然后他只能向左走，回到最开始的点。每个点都要走到，并且除了出发点以外每个点只能经过一次。</p>
<p>请写出一个程序求符合要求的最小路程。</p>
<p>输入： 每组数据有很多组。每组第一行的数是这一组的点数。接下来每一行代表一个点，左边是xi，右边是yi。这些行表示的点的xi是升序的。空格会在输入中随意出现。输入数据是正确的。</p>
<p>输出： 每组数据的答案占一行，答案在小数点后保留两位。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>用d(i,j)表示1~max(i,j)全部走过，且两个人的当前位置分别是i和j，还需要走多长的距离。dp(i,j)==dp(j,i)，所以规定i&gt;j</li>
<li>在每个状态下的决策是让谁走出一步</li>
<li>因为不能走相同的点，所以不管是哪个人，下一步只能走i+1,i+2,i+3…但是如果一个人走到i+2，那么就变成了1~i和i+2被走过，那么i+1没走过就无法表示成状态，因此规定只允许其中一个人走到i+1。因此状态d(i,j)只能转移到d(i+1,j)和d(i+1,i)。</li>
<li>这样规定不会丢失解，因为如果第一个人走到i+2个点，那么只能让第二个人走到第i+1个点，因此，先择让第二个人走到i+1个点不会丢解</li>
<li>边界条件：d(n-1,j) = dist(n-1,n)+dist(j,n)，其中dist(a,b)表示a,b之间的距离</li>
<li>所求结果是dist(1,2)+d(2,1)。这是因为第一步一定是某个人走到的第二个点，根据规定即d(2,1)</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 50 + 5;</span><br><span class="line">double x[maxn], y[maxn], dist[maxn][maxn], d[maxn][maxn];</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%lf%lf&quot;, &amp;x[i], &amp;y[i]);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">				dist[i][j] &#x3D; sqrt((x[i] - x[j])*(x[i] - x[j]) + (y[i] - y[j])*(y[i] - y[j]));</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; n - 1; i &gt;&#x3D; 2; i--)</span><br><span class="line">			for (int j &#x3D; 1; j &lt; i; j++) &#123;</span><br><span class="line">				if (i &#x3D;&#x3D; n - 1) d[i][j] &#x3D; dist[i][n] + dist[j][n]; &#x2F;&#x2F; 边界</span><br><span class="line">				else d[i][j] &#x3D; min(dist[i][i + 1] + d[i + 1][j], dist[j][i + 1] + d[i + 1][i]);</span><br><span class="line">			&#125;</span><br><span class="line">		printf(&quot;%.2lf\n&quot;, dist[1][2] + d[2][1]);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2020/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h1>
<h2 id="括号匹配问题"><a class="markdownIt-Anchor" href="#括号匹配问题"></a> 括号匹配问题</h2>
<p>在某个字符串（长度不超过100）中有左括号、右括号和大小写字母；规定（与常见的算数式子一样）任何一个左括号都从内到外与在它右边且距离最近的右括号匹配。写一个程序，找到无法匹配的左括号和右括号，输出原来字符串，并在下一行标出不能匹配的括号。不能匹配的左括号用&quot;$“标注,不能匹配的右括号用”?&quot;标注。</p>
<h3 id="栈中存索引"><a class="markdownIt-Anchor" href="#栈中存索引"></a> 栈中存索引</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 5;</span><br><span class="line">char s[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%s&quot;, s) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">		printf(&quot;%s\n&quot;, s);</span><br><span class="line">		stack&lt;int&gt; st;</span><br><span class="line">		char ans[maxn];</span><br><span class="line">		for (int i &#x3D; 0;i&lt;strlen(s);i++) &#123;</span><br><span class="line">			if (s[i] &#x3D;&#x3D; &#39;(&#39;) &#123;</span><br><span class="line">				ans[i] &#x3D; &#39; &#39;;</span><br><span class="line">				st.push(i);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			else if (s[i] &#x3D;&#x3D; &#39;)&#39;) &#123;</span><br><span class="line">				if (!st.empty()&amp;&amp;s[st.top()] &#x3D;&#x3D; &#39;(&#39;) &#123;</span><br><span class="line">					ans[i] &#x3D; &#39; &#39;;</span><br><span class="line">					st.pop();</span><br><span class="line">				&#125;</span><br><span class="line">				else </span><br><span class="line">					ans[i] &#x3D; &#39;?&#39;;</span><br><span class="line">			&#125;</span><br><span class="line">			else ans[i] &#x3D; &#39; &#39;;</span><br><span class="line">		&#125;</span><br><span class="line">		while (!st.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			ans[st.top()] &#x3D; &#39;$&#39;;</span><br><span class="line">			st.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		ans[strlen(s)] &#x3D; &#39;\0&#39;;</span><br><span class="line">		printf(&quot;%s\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单计算器"><a class="markdownIt-Anchor" href="#简单计算器"></a> 简单计算器</h2>
<p>读入一个只包含 +, -, *, / 的非负整数计算表达式，计算该表达式的值。测试输入包含若干测试用例，每个测试用例占一行，每行不超过200个字符，整数和运算符之间用一个空格分隔。</p>
<p>没有非法表达式。当一行中只有0时输入结束，相应的结果不要输出。</p>
<p>对每个测试用例输出1行，即该表达式的值，精确到小数点后2位。</p>
<h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3>
<ol>
<li>开一个运算符栈一个操作数栈。主要在于判断各符号间的优先级，当当前读取的符号优先级低于栈顶的时候，应该先把栈顶运算符用了。其他都是小的细节问题。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 200 + 5;</span><br><span class="line">char s[maxn];</span><br><span class="line">bool is_op(char c) &#123; return c &#x3D;&#x3D; &#39;+&#39; || c &#x3D;&#x3D; &#39;-&#39; || c &#x3D;&#x3D; &#39;*&#39; || c &#x3D;&#x3D; &#39;&#x2F;&#39;; &#125;</span><br><span class="line">bool first(char a, char b) &#123;</span><br><span class="line">	if (a &#x3D;&#x3D; &#39;*&#39; || a &#x3D;&#x3D; &#39;&#x2F;&#39;)</span><br><span class="line">		return true;</span><br><span class="line">	else if (a &#x3D;&#x3D; &#39;-&#39; || a &#x3D;&#x3D; &#39;+&#39;) &#123;</span><br><span class="line">		if (b !&#x3D; &#39;*&#39; &amp;&amp; b !&#x3D; &#39;&#x2F;&#39;)</span><br><span class="line">			return true;</span><br><span class="line">		else return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">double calu(double a, double b, char op) &#123;</span><br><span class="line">	switch (op) &#123;</span><br><span class="line">	case &#39;+&#39;:return a + b; break;</span><br><span class="line">	case &#39;-&#39;:return a - b; break;</span><br><span class="line">	case &#39;*&#39;:return a * b; break;</span><br><span class="line">	case &#39;&#x2F;&#39;:return a &#x2F; b; break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (cin.getline(s, 201) &amp;&amp; s[0] !&#x3D; &#39;0&#39;) &#123;</span><br><span class="line">		stack&lt;double&gt; num;</span><br><span class="line">		stack&lt;char&gt; op;</span><br><span class="line">		int index &#x3D; 0;</span><br><span class="line">		while (index &lt; strlen(s)) &#123;</span><br><span class="line">			if (s[index] &#x3D;&#x3D; &#39; &#39;) index++;</span><br><span class="line">			int n &#x3D; 0;</span><br><span class="line">			while (isdigit(s[index]))</span><br><span class="line">			&#123;</span><br><span class="line">				n *&#x3D; 10;</span><br><span class="line">				n +&#x3D; s[index++] - &#39;0&#39;;</span><br><span class="line">			&#125;</span><br><span class="line">			if (n) num.push(n);</span><br><span class="line">			else &#123;</span><br><span class="line">				if (op.empty()) op.push(s[index]);</span><br><span class="line">				else &#123;</span><br><span class="line"></span><br><span class="line">					while (!op.empty() &amp;&amp; first(op.top(), s[index]))</span><br><span class="line">					&#123;</span><br><span class="line">						double a &#x3D; num.top(); num.pop();</span><br><span class="line">						double b &#x3D; num.top(); num.pop();</span><br><span class="line">						char oper;</span><br><span class="line">						oper &#x3D; op.top(); op.pop();</span><br><span class="line">						num.push(calu(b, a, oper));</span><br><span class="line">					&#125;</span><br><span class="line">					op.push(s[index]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">				index++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		while (!op.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			char oper &#x3D; op.top(); op.pop();</span><br><span class="line">			double a &#x3D; num.top(); num.pop();</span><br><span class="line">			double b &#x3D; num.top(); num.pop();</span><br><span class="line">			double ans &#x3D; calu(b, a, oper);</span><br><span class="line">			num.push(ans);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;%.2lf\n&quot;, num.top());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="哈夫曼树"><a class="markdownIt-Anchor" href="#哈夫曼树"></a> 哈夫曼树</h1>
<h2 id="哈夫曼编码"><a class="markdownIt-Anchor" href="#哈夫曼编码"></a> 哈夫曼编码</h2>
<p>使用递减的优先级队列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;搬水果</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pq;</span><br><span class="line"></span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n)&#x3D;&#x3D;1 &amp;&amp;n) &#123;</span><br><span class="line">		int x;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">			pq.push(x);</span><br><span class="line">		&#125;</span><br><span class="line">		int ans &#x3D; 0;</span><br><span class="line">		while (pq.size()&gt;1) &#123;</span><br><span class="line">			int a &#x3D; pq.top(); pq.pop();</span><br><span class="line">			int b &#x3D; pq.top(); pq.pop();</span><br><span class="line">			ans +&#x3D; a + b;</span><br><span class="line">			pq.push(a + b);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树"></a> 二叉树</h1>
<h2 id="二叉树遍历-华科"><a class="markdownIt-Anchor" href="#二叉树遍历-华科"></a> 二叉树遍历 华科</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 26 + 1;</span><br><span class="line">char pre[maxn], in[maxn];</span><br><span class="line"></span><br><span class="line">typedef struct node &#123;</span><br><span class="line">	struct node *lchild, *rchild;</span><br><span class="line">	char data;</span><br><span class="line">&#125;node, *ptr;</span><br><span class="line"></span><br><span class="line">ptr create(char *pre, char *in, int n) &#123;</span><br><span class="line">	ptr s;</span><br><span class="line">	if (n &#x3D;&#x3D; 1) &#123;</span><br><span class="line">		s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">		s-&gt;data &#x3D; *pre;</span><br><span class="line">		s-&gt;rchild &#x3D; s-&gt;lchild &#x3D; NULL;</span><br><span class="line">		return s;</span><br><span class="line">	&#125;</span><br><span class="line">	char *p;</span><br><span class="line">	for (p &#x3D; in; p &lt; in + n; p++)</span><br><span class="line">		if (*p &#x3D;&#x3D; *pre) break;</span><br><span class="line">	int k &#x3D; p - in;</span><br><span class="line"></span><br><span class="line">	s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">	s-&gt;data &#x3D; *p;</span><br><span class="line">	s-&gt;rchild &#x3D; s-&gt;lchild &#x3D; NULL;</span><br><span class="line">	if (k) s-&gt;lchild &#x3D; create(pre + 1, in, k);</span><br><span class="line">	if (n - k - 1) s-&gt;rchild &#x3D; create(pre + k + 1, p + 1, n - k - 1);</span><br><span class="line">	return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void post_order(ptr T) &#123;</span><br><span class="line">	if (T-&gt;lchild) post_order(T-&gt;lchild);</span><br><span class="line">	if (T-&gt;rchild)post_order(T-&gt;rchild);</span><br><span class="line">	printf(&quot;%c&quot;, T-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%s&quot;, pre) &#x3D;&#x3D; 1) &#123;</span><br><span class="line">		scanf(&quot;%s&quot;, in);</span><br><span class="line">		ptr T &#x3D; create(&amp;pre[0], &amp;in[0], strlen(pre));</span><br><span class="line">		post_order(T);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树遍历-清华"><a class="markdownIt-Anchor" href="#二叉树遍历-清华"></a> 二叉树遍历 清华</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100 + 1;</span><br><span class="line">char pre[maxn];</span><br><span class="line">typedef struct node &#123;</span><br><span class="line">	struct node *lchild, *rchild;</span><br><span class="line">	char data;</span><br><span class="line">&#125;node, *ptr;</span><br><span class="line">ptr create(int &amp;cur, const char * pre, int n) &#123;</span><br><span class="line">	if (cur &#x3D;&#x3D; n || pre[cur] &#x3D;&#x3D; &#39;#&#39;) return NULL;</span><br><span class="line"></span><br><span class="line">	ptr s &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">	s-&gt;data &#x3D; pre[cur];</span><br><span class="line">	cur++;</span><br><span class="line">	s-&gt;lchild &#x3D; create(cur, pre, n);</span><br><span class="line">	cur++;</span><br><span class="line">	s-&gt;rchild &#x3D; create(cur, pre, n);</span><br><span class="line">	return s;</span><br><span class="line">&#125;</span><br><span class="line">void in_order(ptr T) &#123;</span><br><span class="line">	if (T-&gt;lchild !&#x3D; NULL) in_order(T-&gt;lchild);</span><br><span class="line">	printf(&quot;%c &quot;, T-&gt;data);</span><br><span class="line">	if (T-&gt;rchild !&#x3D; NULL) in_order(T-&gt;rchild);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%s&quot;, pre) &#x3D;&#x3D; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		int a &#x3D; 0;</span><br><span class="line">		ptr T &#x3D; create(a, pre, strlen(pre));</span><br><span class="line">		in_order(T);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉排序树"><a class="markdownIt-Anchor" href="#二叉排序树"></a> 二叉排序树</h1>
<h2 id="创建二叉排序树"><a class="markdownIt-Anchor" href="#创建二叉排序树"></a> 创建二叉排序树</h2>
<p><strong>此处是递归的逐个节点比较。由于二叉排序树的特殊性，也可以使用前中序遍历序列或中后序遍历序列比较</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct node &#123;</span><br><span class="line">	struct node *lchild, *rchild;</span><br><span class="line">	int data;</span><br><span class="line">&#125;node, *ptr;</span><br><span class="line"></span><br><span class="line">ptr insert(ptr T, int x) &#123;</span><br><span class="line">	if (T &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		T &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">		T-&gt;data &#x3D; x;</span><br><span class="line">		T-&gt;lchild &#x3D; T-&gt;rchild &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		if (x &gt; T-&gt;data)</span><br><span class="line">			T-&gt;rchild &#x3D; insert(T-&gt;rchild, x);</span><br><span class="line">		else if (x &lt; T-&gt;data)</span><br><span class="line">			T-&gt;lchild &#x3D; insert(T-&gt;lchild, x);</span><br><span class="line">	&#125;</span><br><span class="line">	return T;</span><br><span class="line">&#125;</span><br><span class="line">void pre_order(ptr T) &#123;</span><br><span class="line">	printf(&quot;%d &quot;, T-&gt;data);</span><br><span class="line">	if (T-&gt;lchild !&#x3D; NULL) pre_order(T-&gt;lchild);</span><br><span class="line">	if (T-&gt;rchild !&#x3D; NULL)pre_order(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void in_order(ptr T) &#123;</span><br><span class="line">	if (T-&gt;lchild !&#x3D; NULL)	in_order(T-&gt;lchild);</span><br><span class="line">	printf(&quot;%d &quot;, T-&gt;data);</span><br><span class="line">	if (T-&gt;rchild !&#x3D; NULL) in_order(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void post_order(ptr T) &#123;</span><br><span class="line">	if (T-&gt;lchild !&#x3D; NULL) post_order(T-&gt;lchild);</span><br><span class="line">	if (T-&gt;rchild !&#x3D; NULL) post_order(T-&gt;rchild);</span><br><span class="line">	printf(&quot;%d &quot;, T-&gt;data);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;,&amp;n)&#x3D;&#x3D;1)</span><br><span class="line">	&#123;</span><br><span class="line">		ptr T &#x3D; NULL;</span><br><span class="line">		int x;</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">			T &#x3D; insert(T, x);</span><br><span class="line">		&#125;</span><br><span class="line">		pre_order(T);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">		in_order(T);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">		post_order(T);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树搜索判断树同构"><a class="markdownIt-Anchor" href="#二叉树搜索判断树同构"></a> 二叉树搜索(判断树同构)</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct node &#123;</span><br><span class="line">	struct node *lchild, *rchild;</span><br><span class="line">	int data;</span><br><span class="line">&#125;node, *ptr;</span><br><span class="line"></span><br><span class="line">ptr insert(ptr T, int x) &#123;</span><br><span class="line">	if (T &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		T &#x3D; (ptr)malloc(sizeof(node));</span><br><span class="line">		T-&gt;data &#x3D; x;</span><br><span class="line">		T-&gt;lchild &#x3D; T-&gt;rchild &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		if (x &gt; T-&gt;data)</span><br><span class="line">			T-&gt;rchild &#x3D; insert(T-&gt;rchild, x);</span><br><span class="line">		else if (x &lt; T-&gt;data)</span><br><span class="line">			T-&gt;lchild &#x3D; insert(T-&gt;lchild, x);</span><br><span class="line">	&#125;</span><br><span class="line">	return T;</span><br><span class="line">&#125;</span><br><span class="line">bool equal(ptr  T1, ptr T2) &#123;</span><br><span class="line">	if (T1 &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		if (T2 &#x3D;&#x3D; NULL) return true;</span><br><span class="line">		else return false;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (T1-&gt;data &#x3D;&#x3D; T2-&gt;data)</span><br><span class="line">		return equal(T1-&gt;lchild, T2-&gt;lchild) &amp;&amp;</span><br><span class="line">		equal(T1-&gt;rchild, T2-&gt;rchild);</span><br><span class="line"></span><br><span class="line">	return false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		ptr T &#x3D; NULL;</span><br><span class="line">		char x;</span><br><span class="line">		getchar();</span><br><span class="line">		while (scanf(&quot;%c&quot;, &amp;x) &#x3D;&#x3D; 1 &amp;&amp; x !&#x3D; &#39;\n&#39;)</span><br><span class="line">			T &#x3D; insert(T, x - &#39;0&#39;);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			ptr T2 &#x3D; NULL;</span><br><span class="line">			while (scanf(&quot;%c&quot;, &amp;x) &#x3D;&#x3D; 1 &amp;&amp; x !&#x3D; &#39;\n&#39;)</span><br><span class="line">				T2 &#x3D; insert(T2, x - &#39;0&#39;);</span><br><span class="line">			if (equal(T, T2))</span><br><span class="line">				printf(&quot;YES\n&quot;);</span><br><span class="line">			else printf(&quot;NO\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除二叉排序树上的节点"><a class="markdownIt-Anchor" href="#删除二叉排序树上的节点"></a> 删除二叉排序树上的节点</h2>
<ol>
<li>找到这个节点</li>
<li>若该节点为叶子节点，则直接删除，即将其父节点指向其的指针置为空</li>
<li>若该节点仅不存在右子树，那么直接将左子树的根节点替代其位置后，删除该节点。</li>
<li>若该节点存在右子树，那么用其右子树最右下节点(即右子树中序遍历的第一个点)替换，并删除最右下节点。</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转游戏</title>
    <url>/2020/03/30/%E6%97%8B%E8%BD%AC%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="uva-1343-旋转游戏"><a class="markdownIt-Anchor" href="#uva-1343-旋转游戏"></a> UVA 1343 旋转游戏</h1>
<img src="/计安导_img/1.png">
<p>现给定一个初始状态，请使用最少的操作次数，使 “# ” 形棋盘最中间的 888 个格子里的数字相同。输入包括不超过 303030 组测试数据。每个测试数据只包括一行，包含 242424 个整数，每相邻两个整数之间用 111 个空格隔开，表示这个 “# ” 形棋盘的初始状态。（这些整数的排列顺序是从上至下，同一行的从左至右。例如 1 1 1 1 3 2 3 2 3 1 3 2 2 3 1 2 2 2 3 1 2 1 3 3\text{1 1 1 1 3 2 3 2 3 1 3 2 2 3 1 2 2 2 3 1 2 1 3 3}1 1 1 1 3 2 3 2 3 1 3 2 2 3 1 2 2 2 3 1 2 1 3 3 表示图 111 最左边的状态。）每两组测试数据之间没有换行符。输入文件以一行 000 结束。对于每组测试数据，输出两行。第一行用字符 A∼H\text{A}\sim \text{H}A∼H 输出操作的方法，每两个操作字符之间没有空格分开，如果不需要任何步数，输出 No moves needed。第二行输出最终状态中最中间的 888 个格子里的数字。如果有多组解，输出操作次数最少的一组解；如果仍有多组解，输出字典序最小的一组。任意相邻两组测试数据的输出之间不需输出换行符。</p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<ol>
<li>
<p>典型的状态空间搜索，采用迭代加深搜的方法。</p>
</li>
<li>
<p><strong>IDA*模板题</strong></p>
</li>
<li>
<p>本题中要求中间8个数是相同的，而出现的数字又限定在1，2，3中。所以可以分三次求解，这样可以减少搜素空间。以目标为1为例，这时，将元素看作为1和非1的元素，那么状态总数就变成了8个1，16个非1的全排列，即24!/(8!*16!)。</p>
</li>
<li>
<p>其实本题中的state可以定义为bool型，因为只关心比如1和非1</p>
</li>
<li>
<p>关于剪枝</p>
<ol>
<li>最直接的，由于A-F/B-E/H-C/G-D相对，所以不能回滚上一层的操作。<strong>实现时使用op数组记录对应关系</strong></li>
<li>每次旋转至多引入一个新的元素，也就是说每次回滚只能增加一个相同的元素。所以如果当前的层数d加上中间8个数字中非当前目标的数字个数大于最大个数maxd时，需要进行剪枝。</li>
</ol>
</li>
<li>
<p>关于旋转：由于输入方式比较特殊，旋转的次序固定，所以把A-H中每个元素在输入串中出现的位置手动写出。旋转时只需要模7加即可。</p>
</li>
<li>
<p>相同的思路，将中间8个格出现的位置预先写出也可简化代码。</p>
</li>
<li>
<p>与编辑书稿有相似之处</p>
</li>
</ol>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<h3 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> dfs</h3>
<pre><code>bool dfs(int d) {
if (d == maxd) {
	if (not_equal(d) == 0) return true;
	else return false;
}
int next = d + 1;
if (d + not_equal(d) &gt; maxd) return false;
for (int i = 0; i &lt; 8; i++) {
	if (d &gt; 0 &amp;&amp; op[v[d-1]]== i) continue;

	v[d] = i;
	memcpy(state[next], state[d], 24 * sizeof(int));
	for (int j = 0; j &lt; 7; j++)
		state[next][move[i][j]] = state[d][move[i][(j + 1) % 7]];
	if (dfs(next)) return true;
}
return false;
}
</code></pre>
<h3 id="update-判断是否字典序更小"><a class="markdownIt-Anchor" href="#update-判断是否字典序更小"></a> update 判断是否字典序更小</h3>
<pre><code>bool update() {
if (ans[0] != -1)
	for (int i = 0; i &lt; maxd; i++)
		if (v[i] &gt; ans[i]) return false;
		else if (v[i] &lt; ans[i]) break;
memcpy(ans, v, sizeof(int)*maxd);
return true;
}
</code></pre>
<h3 id="not_equla-统计中间八格中与当前目标不等的元素个数"><a class="markdownIt-Anchor" href="#not_equla-统计中间八格中与当前目标不等的元素个数"></a> not_equla 统计中间八格中与当前目标不等的元素个数</h3>
<pre><code>int not_equal(int d) {
int ans = 0;
for (int i = 0; i &lt; 8; i++)
	if (state[d][mid[i]] != cur_nm)	ans++;
return ans;
}
</code></pre>
<h3 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h3>
<pre><code>int maxd;
int move[8][7] = {
{0,2,6,11,15,20,22},
{1,3,8,12,17,21,23},
{10,9,8,7,6,5,4},
{19,18,17,16,15,14,13},
{23,21,17,12,8,3,1},
{22,20,15,11,6,2,0},
{13,14,15,16,17,18,19},
{4,5,6,7,8,9,10}
};
int mid[8] = { 6,7,8,11,12,15,16,17 };
int op[8] = { 5,4,7,6,1,0,3,2 };
int state[50][24];
int ans[50], v[50];
int table[24];
inline int not_equal(int d);
bool dfs(int d);
inline bool update();
int cur_nm;
int main() {
while (true)
{
	memset(ans, -1, sizeof(ans));
	scanf(&quot;%d&quot;, &amp;table[0]);
	if (!table[0]) break;
	for (int i = 1; i &lt; 24; i++)
		scanf(&quot;%d&quot;, &amp;table[i]);
	int p = 0;
	for (maxd = 0;; maxd++) {
		for (cur_nm = 1; cur_nm &lt;= 3; cur_nm++) {
			memcpy(state[0], table, 24 * sizeof(int));
			if (dfs(0) &amp;&amp; update()) 
				p = cur_nm;
		}
		if (p) break;
	}
	if (maxd)
		for (int i = 0; i &lt; maxd; i++) printf(&quot;%c&quot;, ans[i] + 'A');
	else printf(&quot;No moves needed&quot;);
	printf(&quot;\n%d\n&quot;, p);
}
}</code></pre>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>最大连续和问题</title>
    <url>/2020/03/30/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h1>
<p>给定一个长度为n的序列1,A2,···,An，求最大连续和</p>
<h1 id="onsup3sup"><a class="markdownIt-Anchor" href="#onsup3sup"></a> O(n<sup>3</sup>)</h1>
<p>枚举始末位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">for(int i&#x3D;0;i&lt;&#x3D;n;i++)</span><br><span class="line">	for(int j&#x3D;0;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">		int sum &#x3D; 0;</span><br><span class="line">		for(int k&#x3D;i;k&lt;&#x3D;j;k++)&#123;</span><br><span class="line">			sum+&#x3D;A[k];</span><br><span class="line">			tot++;</span><br><span class="line">		&#125;</span><br><span class="line">		if(sum&gt;best) best&#x3D;sum;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="onsup2sup"><a class="markdownIt-Anchor" href="#onsup2sup"></a> O(n<sup>2</sup>)</h1>
<p>先递推的求出前i项和，利用Sj-Si求出i-j的连续和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">S[0] &#x3D; 0;</span><br><span class="line">for(int i&#x3D;0;i&lt;&#x3D;n;i++) S[i] &#x3D; A[i]+S[i-1];</span><br><span class="line">for(int i&#x3D;0;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">for(int j &#x3D; i;j &lt;&#x3D; n;j++)</span><br><span class="line">brest &#x3D; max(best,S[j]-S[i-1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分治法-onlogn"><a class="markdownIt-Anchor" href="#分治法-onlogn"></a> 分治法 O(nlogn)</h1>
<ol>
<li>划分问题：将序列分成数量尽可能相等两部分</li>
<li>递归求解：分别求出完全位于左半部和完全位于右半部的最佳序列</li>
<li>合并问题：求出起点位于左半，终点位于右半的连续和序列
<ol>
<li>注：递归方程T(n) = 2T(n/2)+O(n)</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int maxsum(int* A, int x, int y)&#123;</span><br><span class="line">int v, L , R,     maxs;</span><br><span class="line">if(y-x&#x3D;&#x3D;1) return A[X];</span><br><span class="line">int m &#x3D; x+(y-x)&#x2F;2;</span><br><span class="line">int maxs &#x3D; max(maxsum(A,x,m),maxsum(A,m,y));</span><br><span class="line">int v, L, R;</span><br><span class="line">v&#x3D; 0;L &#x3D; A[m-1];</span><br><span class="line">for(int i &#x3D; m-1;i &gt;&#x3D; x;i--)</span><br><span class="line">	L &#x3D; max(L,v +&#x3D; A[i]);</span><br><span class="line">v&#x3D; 0;L &#x3D; A[m];</span><br><span class="line">for(int i &#x3D; m;i &lt; y;i++)</span><br><span class="line">	R &#x3D; max(R,v +&#x3D; A[i]);</span><br><span class="line">return max(maxs, L+R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>木块问题</title>
    <url>/2020/03/30/%E6%9C%A8%E5%9D%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="uva101-木块游戏"><a class="markdownIt-Anchor" href="#uva101-木块游戏"></a> UVa101 木块游戏</h1>
<h3 id="输入n得到编号为0n-1的木块分别摆放在顺序排列编号为0n-1的位置-现对这些木块进行操作操作分为四种"><a class="markdownIt-Anchor" href="#输入n得到编号为0n-1的木块分别摆放在顺序排列编号为0n-1的位置-现对这些木块进行操作操作分为四种"></a> 输入n，得到编号为0<sub>n-1的木块，分别摆放在顺序排列编号为0</sub>n-1的位置。现对这些木块进行操作，操作分为四种:</h3>
<h3 id="1-move-a-onto-b把木块a-b上的木块放回各自的原位再把a放到b上"><a class="markdownIt-Anchor" href="#1-move-a-onto-b把木块a-b上的木块放回各自的原位再把a放到b上"></a> 1、move a onto b：把木块a、b上的木块放回各自的原位，再把a放到b上；</h3>
<h3 id="2-move-a-over-b把a上的木块放回各自的原位再把a发到含b的堆上"><a class="markdownIt-Anchor" href="#2-move-a-over-b把a上的木块放回各自的原位再把a发到含b的堆上"></a> 2、move a over b：把a上的木块放回各自的原位，再把a发到含b的堆上；</h3>
<h3 id="3-pile-a-onto-b把b上的木块放回各自的原位再把a连同a上的木块移到b上"><a class="markdownIt-Anchor" href="#3-pile-a-onto-b把b上的木块放回各自的原位再把a连同a上的木块移到b上"></a> 3、pile a onto b：把b上的木块放回各自的原位，再把a连同a上的木块移到b上；</h3>
<h3 id="4-pile-a-over-b把a连同a上木块移到含b的堆上"><a class="markdownIt-Anchor" href="#4-pile-a-over-b把a连同a上木块移到含b的堆上"></a> 4、pile a over b：把a连同a上木块移到含b的堆上。</h3>
<h3 id="当输入quit时结束操作并输出0~n-1的位置上的木块情况"><a class="markdownIt-Anchor" href="#当输入quit时结束操作并输出0~n-1的位置上的木块情况"></a> 当输入quit时，结束操作并输出0~n-1的位置上的木块情况</h3>
<h3 id="sample-input"><a class="markdownIt-Anchor" href="#sample-input"></a> Sample Input</h3>
<p>10</p>
<p>move 9 onto 1</p>
<p>move 8 over 1</p>
<p>move 7 over 1</p>
<p>move 6 over 1</p>
<p>pile 8 over 6</p>
<p>pile 8 over 5</p>
<p>move 2 over 1</p>
<p>move 4 over 9</p>
<p>quit</p>
<h3 id="sample-output"><a class="markdownIt-Anchor" href="#sample-output"></a> Sample Output</h3>
<p>0: 0</p>
<p>1: 1 9 2 4</p>
<p>2:</p>
<p>3: 3</p>
<p>4:</p>
<p>5: 5 8 7 6</p>
<p>6:</p>
<p>7:</p>
<p>8:</p>
<p>9:</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<h3 id="通过四种指令的描述可以注意到move指令与把a上的木块全部归位相联系onto指令与把b上方的木块归位相联系并且每条指令都包含把a或a的上方的木块移动到b上方的部分因此应该对应以上三点来写各模块"><a class="markdownIt-Anchor" href="#通过四种指令的描述可以注意到move指令与把a上的木块全部归位相联系onto指令与把b上方的木块归位相联系并且每条指令都包含把a或a的上方的木块移动到b上方的部分因此应该对应以上三点来写各模块"></a> 通过四种指令的描述，可以注意到，move指令与把a上的木块全部归位相联系；onto指令与把b上方的木块归位相联系；并且每条指令都包含把a(或a的上方的木块)移动到b上方的部分；因此，应该对应以上三点来写各模块；</h3>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="模块一"><a class="markdownIt-Anchor" href="#模块一"></a> 模块一</h2>
<p>查找编号为a的木块所在堆和高度，用引用传递</p>
<pre><code>void find(int a, int &amp;pa, int &amp;h) {
	for (pa = 0; pa &lt; n; pa++) {
		for (h = 0; h &lt; p[pa].size(); h++) {
			if (p[pa][h] == a) return;
		}
	}
}
</code></pre>
<h2 id="模块二"><a class="markdownIt-Anchor" href="#模块二"></a> 模块二</h2>
<p>把a堆高度为h的木块的所有木块归位。注意，本题中的归位是把a放回初始的堆里即可，不考虑初始高度。</p>
<pre><code> void clear_above(int a, int h) {
    	for (int i = h + 1; i &lt; p[a].size(); i++) {
    		p[p[a][i]].push_back(p[a][i]);
    	}
    	p[a].resize(h + 1);
}
</code></pre>
<h2 id="模块三"><a class="markdownIt-Anchor" href="#模块三"></a> 模块三</h2>
<p>把p堆高度为h及其上方的木块整体移动到p2堆顶:1.移动2.截断</p>
<pre><code>void pile_onto(int p1, int h, int p2) {

for (int i = h; i &lt; p[p1].size(); i++) {
	p[p2].push_back(p[p1][i]);
}
p[p1].resize(h);
}
</code></pre>
<h2 id="模块四"><a class="markdownIt-Anchor" href="#模块四"></a> 模块四</h2>
<p>输出各堆的序列</p>
<pre><code>void print(){
for (int i = 0; i &lt; n; i++) {
	cout &lt;&lt; i &lt;&lt; &quot;:&quot;;
	for (int j = 0; j &lt; p[i].size(); j++) {
		cout &lt;&lt; &quot; &quot; &lt;&lt; p[i][j];
	}
	cout &lt;&lt; endl;
}
}
</code></pre>
<h2 id="主函数"><a class="markdownIt-Anchor" href="#主函数"></a> 主函数</h2>
<pre><code>int main() {
cin &gt;&gt; n;
for (int i = 0; i &lt; n; i++) p[i].push_back(i);
string s1, s2;
int a, b;
while (cin &gt;&gt; s1 &gt;&gt; a &gt;&gt; s2 &gt;&gt; b) {
	int pa, pb, ha, hb;
	find(a, pa, ha);
	find(b, pb, hb);
	if (pa == pb) continue;//非法指令
	
	if (s1 == &quot;move&quot;) clear_above(pa, ha);
	if (s2 == &quot;onto&quot;) clear_above(pb, hb);
	pile_onto(pa, ha, pb);
}
print();
return 0;
}
</code></pre>
<h1 id="心得体会"><a class="markdownIt-Anchor" href="#心得体会"></a> 心得体会</h1>
<ol>
<li>本题应主要学习他的拆分思路,以及引用传递的运用。</li>
<li>学习vector类，vector<typename> xname;</li>
<li>学习vector的基本方法，push_back(要插入的元素) 和 resize(元素个数);</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2020/03/30/%E6%A0%91/</url>
    <content><![CDATA[<h1 id="uva-548-树"><a class="markdownIt-Anchor" href="#uva-548-树"></a> uva 548 树</h1>
<p> 输入一个二叉树的中序和后序遍历，请你输出一个叶子节点，该叶子节点到根的数值总和最小，且这个叶子是编号最小的那个。 输入： 您的程序将从输入文件中读取两行(直到文件结尾)。第一行是树的中序遍历值序列,第二行是树的后序遍历值序列。所有值将不同，大于零且小于或等于10000.二叉树的节1&lt;=N&lt;=10000。 输出： 对于每个树描述，您应该输出最小值路径的叶节点的值。存在多路径最小的情况下，您应该选择终端叶子节点上具有最小值的那条路径，且输出那个最小值的终端叶子。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>根据中序和后序序列构造二叉树</li>
<li>递归遍历二叉树，每一步走左右子树中权值较小的一个</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;sstream&gt;
# pragma warning(disable:4996)
# define LOCAL
# ifdef LOCAL
FILE *fin = freopen(&quot;树in.txt&quot;, &quot;r&quot;, stdin);
FILE *fout = freopen(&quot;树out.txt&quot;, &quot;w&quot;, stdout);
# endif 
using namespace std;
# define maxn 10000
int n = 0;
bool read(int *a) {
</code></pre>
<blockquote>
<p>数组为参数的时候可以用指针，传首地址</p>
</blockquote>
<pre><code>	string s;
	getline(cin, s);
	stringstream ss(s);
</code></pre>
<blockquote>
<p>注意此处，用ss来读取一行不定数量的以空格分隔的数字</p>
</blockquote>
<pre><code>	n = 0;
	int x;
	while (ss &gt;&gt; x) a[n++] = x;
	return n &gt; 0;
}

int post_order[maxn], in_order[maxn],lch[maxn],rch[maxn];
</code></pre>
<blockquote>
<p>其中rch[i]表示编号为i的节点的右孩子<br />
`<br />
int build(int l1, int r1, int l2, int r2) {<br />
if (l1 &gt; r1) return 0;//空树<br />
本题中以权值代表编号，为0表示节点不存在</p>
</blockquote>
<pre><code>	int root = post_order[r2];//后序序列的最后一个
	int p = l1;
	while (in_order[p] != root) p++;
	int cnt = p-l1;//左子树中节点个数
	

	//分别在左右子树中递归遍历
	lch[root] = build(l1, p - 1, l2 , l2 + cnt - 1);
	rch[root] = build(p + 1, r1, l2 + cnt, r2 - 1);
	return root;
}

int best, best_sum;
void dfs(int u, int sum) {
	sum += u;
	if (!lch[u] &amp;&amp; !rch[u]) {//如果u是叶子节点
		if (sum &lt; best_sum || (best_sum == sum &amp;&amp; u &lt; best)) 
		{
			best = u;
			best_sum = sum;
		}
	}

	if (lch[u]) dfs(lch[u], sum);
	if (rch[u]) dfs(rch[u], sum);

}
int main() {
	while (read(in_order)) {
		read(post_order);
		build(0, n - 1, 0, n - 1);
		best_sum = 1e9;//
		dfs(post_order[n - 1], 0);
		cout &lt;&lt; best &lt;&lt; endl;
	}
}
</code></pre>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<ol>
<li>
<p>输入也可以写成子函数的形式</p>
</li>
<li>
<p>学习中后造树和递归遍历二叉树的方法</p>
<pre><code> void dfs(树根指针){
 if(左子树为空（为0）&amp;&amp;右子树为空（为0）)
 	{
 						
 		return 0;
 	}
 if(左孩子不为空) dfs（左孩子）
 if(右孩子不为空) dfs（右孩子）
 }</code></pre>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘实验二</title>
    <url>/2020/06/13/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E9%AA%8C%E4%BA%8C/</url>
    <content><![CDATA[<p><a href="https://github.com/Cccceb/No3.second.git">源码:https://github.com/Cccceb/No3.second.git</a></p>
<h1 id="实验内容"><a class="markdownIt-Anchor" href="#实验内容"></a> 实验内容</h1>
<p>1、 数据来源 <a href="http://archive.ics.uci.edu/ml/datasets/Congressional+Voting+Records" target="_blank" rel="noopener">http://archive.ics.uci.edu/ml/datasets/Congressional+Voting+Records</a></p>
<p>2、使用 Apriori算法，支持度设为 30%，置信度为 90%，挖掘高置信度的规则</p>
<h1 id="分析及设计"><a class="markdownIt-Anchor" href="#分析及设计"></a> 分析及设计</h1>
<h2 id="转换数据集"><a class="markdownIt-Anchor" href="#转换数据集"></a> 转换数据集</h2>
<p>首先将数据集转换为课堂常见的形式，每一条记录中如果为赞同，那么记录该列的正索引，否则记录负索引，忽略?。其中第1列，将‘republican’标记为正索引</p>
<h2 id="获取频繁项集"><a class="markdownIt-Anchor" href="#获取频繁项集"></a> 获取频繁项集</h2>
<ol>
<li>实现计算支持度的函数caluSupp，该函数通过遍历整个数据库和候选项集列表，累加每个候选集的出现次数。然后计算其支持度与支持度阈值比较，返回频繁项集和所有候选项集的支持度计数</li>
<li>[-17,-1],[1,17]构成了候选1-项集，利用上述函数计算频繁1-项集。</li>
<li>将频繁1-项集中元素进行两两合并，得到候选2-项集，再利用1中函数计算得到频繁2-项集。同时扩展所有候选项集的支持度计数</li>
<li>将频繁k-项集中元素前k-2个元素相同的项集进行两两合并得到候选k+1-项集，以支持度阈值过滤得到频繁k+1项集</li>
<li>重复步骤4直到频繁k-项集为空</li>
</ol>
<h2 id="推导关联规则"><a class="markdownIt-Anchor" href="#推导关联规则"></a> 推导关联规则</h2>
<ol>
<li>从频繁2-项集开始挖掘关联规则。对于频繁2-项集，只需要判断两两之间是否有关联关系，即对于集合{a,b}只需要计算S(a,b)/S(a)以及S(a,b)/S(b)即可</li>
<li>对于其他频繁k-项集(k&gt;2)，则需要递归判断。对于规则$$A\to B$$，其中A,B为集合，首先判断B大小为1的情况计算其置信度，并通过置信度阈值过滤。然后逐步增大B的大小(利用计算频繁项集中的合并函数)，再次计算置信度，并用阈值过滤。重复上述步骤直到B的大小=频繁k-项集大小-1时停止。返回得到的规则</li>
</ol>
<h1 id="详细实现"><a class="markdownIt-Anchor" href="#详细实现"></a> 详细实现</h1>
<h2 id="转换数据集-2"><a class="markdownIt-Anchor" href="#转换数据集-2"></a> 转换数据集</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> joblib</span><br><span class="line">dataset = pd.read_table(<span class="string">"./house-votes-84.data"</span>,sep=<span class="string">','</span>,header = <span class="literal">None</span>).values</span><br><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(dataset)):</span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(dataset[i])):</span><br><span class="line">        <span class="keyword">if</span> dataset[i,j] == <span class="string">'y'</span> <span class="keyword">or</span> dataset[i,j] == <span class="string">'republican'</span>:</span><br><span class="line">            tmp.append(j)</span><br><span class="line">        <span class="keyword">elif</span> dataset[i,j] == <span class="string">'n'</span> <span class="keyword">or</span> dataset[i,j] == <span class="string">'democrat'</span>:</span><br><span class="line">            tmp.append(-(j+<span class="number">1</span>))</span><br><span class="line">    a.append(tmp)</span><br><span class="line">joblib.dump(a,<span class="string">"MyDataset"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="获取频繁项集-2"><a class="markdownIt-Anchor" href="#获取频繁项集-2"></a> 获取频繁项集</h2>
<h3 id="计算支持度"><a class="markdownIt-Anchor" href="#计算支持度"></a> 计算支持度</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">caluSupp</span><span class="params">(dataset, Ck, minSupport)</span>:</span></span><br><span class="line">    total = <span class="number">435</span></span><br><span class="line">    Ck = list(Ck)</span><br><span class="line">    tmp = &#123;&#125;<span class="comment"># tmp用来暂存支持度计数</span></span><br><span class="line">    <span class="keyword">for</span> tid <span class="keyword">in</span> dataset:</span><br><span class="line">        <span class="keyword">for</span> can <span class="keyword">in</span> Ck:</span><br><span class="line">            <span class="keyword">if</span> can.issubset(tid): <span class="comment"># can是一个集合类型</span></span><br><span class="line">                <span class="keyword">if</span> can <span class="keyword">not</span> <span class="keyword">in</span> tmp.keys():<span class="comment"># 第一次加入初始化为1</span></span><br><span class="line">                    tmp[can] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:	<span class="comment"># 之后每次+1</span></span><br><span class="line">                    tmp[can] += <span class="number">1</span></span><br><span class="line">    frequency = []</span><br><span class="line">    supportData = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> tmp:</span><br><span class="line">        <span class="comment"># 计算支持度</span></span><br><span class="line">        support = tmp[key] / total</span><br><span class="line">        <span class="keyword">if</span> support &gt;= minSupport:</span><br><span class="line">            <span class="comment"># 将满足阈值的放入频繁项集中</span></span><br><span class="line">            frequency.append(key)</span><br><span class="line">        <span class="comment"># 记录所有的支持度</span></span><br><span class="line">        supportData[key] = support</span><br><span class="line">    <span class="keyword">return</span> frequency, supportData</span><br></pre></td></tr></table></figure>
<h3 id="apriori算法生成频繁项集"><a class="markdownIt-Anchor" href="#apriori算法生成频繁项集"></a> Apriori算法生成频繁项集</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apriori</span><span class="params">(dataSet, minSupport)</span>:</span></span><br><span class="line">    C1 = map(frozenset,[[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">17</span>)])</span><br><span class="line">    <span class="comment"># 对每一行进行 set 转换，然后存放到集合中</span></span><br><span class="line">    dataSet = list(map(set, dataSet))</span><br><span class="line">    <span class="comment"># print 'dataSet=', dataSet</span></span><br><span class="line">    <span class="comment"># 计算候选数据集 C1 在数据集 dataSet 中的支持度，并返回支持度大于 minSupport 的数据</span></span><br><span class="line">    L1, supportData = caluSupp(dataSet, C1, minSupport)</span><br><span class="line"></span><br><span class="line">    frequency = [L1] <span class="comment"># frequency为所有频繁项集</span></span><br><span class="line">    k = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> (len(frequency[k - <span class="number">2</span>]) &gt; <span class="number">0</span>):</span><br><span class="line">        <span class="comment"># 从候选2-项集开始计算，直到</span></span><br><span class="line">        Ck = aprioriGen(frequency[k - <span class="number">2</span>],k) <span class="comment"># 合并得到候选k项集</span></span><br><span class="line"></span><br><span class="line">        Lk, supK = caluSupp(dataSet, Ck, minSupport)  <span class="comment"># 计算频繁k-项集</span></span><br><span class="line">        <span class="comment"># 将新产生的项集的支持度计数加入到集合中</span></span><br><span class="line">        supportData.update(supK)</span><br><span class="line">        <span class="keyword">if</span> len(Lk) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        frequency.append(Lk)</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> frequency, supportData</span><br></pre></td></tr></table></figure>
<h3 id="上面用到的合并得到k项集函数"><a class="markdownIt-Anchor" href="#上面用到的合并得到k项集函数"></a> 上面用到的合并得到k项集函数</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aprioriGen</span><span class="params">(Lk, k)</span>:</span></span><br><span class="line">    retList = []</span><br><span class="line">    lenLk = len(Lk)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(lenLk):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, lenLk):</span><br><span class="line">            L1 = list(Lk[i])[: k - <span class="number">2</span>]</span><br><span class="line">            L2 = list(Lk[j])[: k - <span class="number">2</span>]</span><br><span class="line">            L1.sort()</span><br><span class="line">            L2.sort()</span><br><span class="line">            <span class="comment"># 对于前k-2项相同的两个集合进行合并，计入到k项集中</span></span><br><span class="line">            <span class="keyword">if</span> L1 == L2:</span><br><span class="line">                <span class="comment"># print(Lk[i] | Lk[j], Lk[i], Lk[j])</span></span><br><span class="line">                retList.append(Lk[i] | Lk[j])</span><br><span class="line">    <span class="keyword">return</span> retList</span><br></pre></td></tr></table></figure>
<h2 id="推导关联规则-2"><a class="markdownIt-Anchor" href="#推导关联规则-2"></a> 推导关联规则</h2>
<h3 id="计算置信度"><a class="markdownIt-Anchor" href="#计算置信度"></a> 计算置信度</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcConf</span><span class="params">(freqSet, subSet, supportData, brl, minConf)</span>:</span></span><br><span class="line">    <span class="comment"># subSet 是集合的列表，包含本次要判断的规则的右部集合</span></span><br><span class="line">    retList = []</span><br><span class="line">    <span class="keyword">for</span> conseq <span class="keyword">in</span> subSet:</span><br><span class="line">        conf = supportData[freqSet] / supportData[freqSet - conseq]</span><br><span class="line">        <span class="comment"># 支持度定义: a -&gt; b = support(a | b) / support(a).</span></span><br><span class="line">        <span class="keyword">if</span> conf &gt;= minConf:</span><br><span class="line">            print(freqSet - conseq, <span class="string">'-&gt;'</span>, conseq, <span class="string">'confidence:'</span>, conf)</span><br><span class="line">            brl.append((freqSet - conseq, conseq, conf))</span><br><span class="line">            retList.append(conseq)</span><br><span class="line">    <span class="keyword">return</span> retList</span><br></pre></td></tr></table></figure>
<h3 id="生成关联规则"><a class="markdownIt-Anchor" href="#生成关联规则"></a> 生成关联规则</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generateRules</span><span class="params">(L, supportData, minConf)</span>:</span></span><br><span class="line">    ruleList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(L)):<span class="comment"># L[i]为所有i-1项集构成的列表</span></span><br><span class="line">        <span class="keyword">for</span> freqSet <span class="keyword">in</span> L[i]:</span><br><span class="line">            H1 = [frozenset([item]) <span class="keyword">for</span> item <span class="keyword">in</span> freqSet] <span class="comment"># 频繁项集中所有元素形成的列表</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">1</span>:<span class="comment"># 2以上的项集，还需要递归的扩大关联规则的右部</span></span><br><span class="line">                rulesFromConseq(freqSet, H1, supportData, ruleList, minConf)</span><br><span class="line">            <span class="keyword">else</span>:<span class="comment"># 频繁2-项集，只需要计算两个置信度，所以单拿出来</span></span><br><span class="line">                calcConf(freqSet, H1, supportData, ruleList, minConf)</span><br><span class="line">    <span class="keyword">return</span> ruleList</span><br></pre></td></tr></table></figure>
<h3 id="递归的合并规则"><a class="markdownIt-Anchor" href="#递归的合并规则"></a> 递归的合并规则</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rulesFromConseq</span><span class="params">(freqSet, H, supportData, brl, minConf)</span>:</span></span><br><span class="line">    Hmp1 = calcConf(freqSet, H, supportData, brl, minConf)  <span class="comment"># 利用阈值进行过滤，返回可信度大于阈值的集合</span></span><br><span class="line">    <span class="keyword">if</span> (len(Hmp1) &gt;= <span class="number">1</span>):</span><br><span class="line">        m = len(H[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> m &lt; len(freqSet)<span class="number">-1</span>: <span class="comment"># 当关联规则的右部小于频繁项集的长度时</span></span><br><span class="line">            Hmp1 = aprioriGen(H, m+<span class="number">1</span>) <span class="comment"># 利用合并函数将规则右部扩展一位</span></span><br><span class="line">            <span class="comment"># 如果仍有满足阈值的规则，那么递归的合并规则，并进行过滤，直到没有满足阈值要求的规则</span></span><br><span class="line">            rulesFromConseq(freqSet, Hmp1, supportData, brl, minConf)</span><br></pre></td></tr></table></figure>
<h1 id="实验结果"><a class="markdownIt-Anchor" href="#实验结果"></a> 实验结果</h1>
<ul>
<li>
<p>具体输出内容见<a href="./out.txt">out.txt</a></p>
</li>
<li>
<p>在支持度阈值0.3，置信度阈值0.9的情况下，共计挖掘到2990条规则。</p>
</li>
<li>
<p>结果文件的集合中数字为每个属性的索引，索引从1开始</p>
</li>
</ul>
<h1 id="心得体会"><a class="markdownIt-Anchor" href="#心得体会"></a> 心得体会</h1>
<ul>
<li>本次实验实现了Apriori算法生成频繁项集，以及关联规则的产生，并且利用置信度进行了剪枝。通过本次实验，我更加了解算法的流程，对于一些边界处的处理也有了实际体会。</li>
<li>起初忘记用set了，还在考虑将下标转字符串作为键。后来参考了《机器学习实战》慢慢理清了思路，以后还要多多看书，才能少走弯路。</li>
</ul>
<p>​																																								<strong>17069130005</strong></p>
<p>​																																											<strong>崔恩博</strong></p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>流水线调度</title>
    <url>/2020/03/30/%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="uva-690-流水线调度"><a class="markdownIt-Anchor" href="#uva-690-流水线调度"></a> UVA 690 流水线调度</h1>
<p>题目大意：有10个任务，5个管道，每个任务需要占用不同时间的管道，给出任务所占用管道的时间，求最短需要多少时间。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>
<p>框架是dfs，且存在明显的深度上限10*n。通过枚举每个程序的起始点选择出最优解</p>
</li>
<li>
<p>如果不适用二进制法，那么循环遍历状态，判断每个段是否正被占用会消耗大量的时间，导致TLE</p>
</li>
<li>
<p>关于剪枝：</p>
<ol>
<li>即使剩余的程序都按照最好的情况执行也比目前的最优解慢，那么直接剪掉</li>
</ol>
</li>
<li>
<p>剪枝依然TLE，所以不能从头开始枚举起始点。故进行预处理。循环枚举相邻两个程序起始点间的间隔，判断有无段冲突，若没有，则记录这个间隔。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">c &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; n; i++)&#x2F;&#x2F;枚举两个程序起始点的间隔</span><br><span class="line">	if (judge(w, i)) &#123;</span><br><span class="line">		jump[c++] &#x3D; i;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="judge-判断在状态s下相邻两个程序起始点间隔为k是否会导致冲突"><a class="markdownIt-Anchor" href="#judge-判断在状态s下相邻两个程序起始点间隔为k是否会导致冲突"></a> judge 判断在状态s下，相邻两个程序起始点间隔为k是否会导致冲突</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">bool judge(const int *s, int k) &#123;&#x2F;&#x2F;判断相邻的两个程序间隔k的时间片时</span><br><span class="line">							&#x2F;&#x2F;是否会冲突</span><br><span class="line">for (int i &#x3D; 0; i &lt; 5; i++)</span><br><span class="line">	if ((s[i] &gt;&gt; k)&amp;w[i]) return false;</span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> dfs</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void dfs(int d, int time, const int *s) &#123;</span><br><span class="line">if (time + (10 - d) *jump[0] &gt;&#x3D; ans) return;</span><br><span class="line">if (d &#x3D;&#x3D; 10) &#123;</span><br><span class="line">	ans &#x3D; min(ans, time);</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 0; i &lt; c; i++) &#123;</span><br><span class="line">	if (judge(s, jump[i])) &#123;</span><br><span class="line">		int p[5];</span><br><span class="line">		for (int j &#x3D; 0; j &lt; 5; j++)</span><br><span class="line">			p[j] &#x3D; (s[j] &gt;&gt; jump[i]) ^ w[j];</span><br><span class="line"></span><br><span class="line">&gt; 尝试每一种间隔，如果不冲突，那么更新状态到p，p的二进制形式相当于s的二进制形式中1复制到右一位处 </span><br><span class="line"></span><br><span class="line">		dfs(d + 1, jump[i] + time, p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="init-初始化"><a class="markdownIt-Anchor" href="#init-初始化"></a> init 初始化</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">ans &#x3D; 10 * n;</span><br><span class="line">memset(w, 0, sizeof(w));</span><br><span class="line">char s[maxn];</span><br><span class="line">for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">	scanf(&quot;%s&quot;, s);</span><br><span class="line">	for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">		if (s[j] &#x3D;&#x3D; &#39;X&#39;) &#123;</span><br><span class="line">			w[i] |&#x3D; (1 &lt;&lt; j);&#x2F;&#x2F;记录初始状态</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">c &#x3D; 0;</span><br><span class="line">for (int i &#x3D; 0; i &lt;&#x3D; n; i++)&#x2F;&#x2F;枚举两个程序起始点的间隔</span><br><span class="line">	if (judge(w, i)) &#123;</span><br><span class="line">		jump[c++] &#x3D; i;</span><br><span class="line">	&#125;</span><br><span class="line">dfs(1, n, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int M &#x3D; 100;</span><br><span class="line">const int maxn &#x3D; 20;</span><br><span class="line">int n, c, ans, w[5], jump[M];</span><br><span class="line"></span><br><span class="line">inline bool judge(const int *s, int k);</span><br><span class="line">void dfs(int d, int time, const int *s);</span><br><span class="line">inline void init();</span><br><span class="line">int main() &#123;</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)</span><br><span class="line">&#123;</span><br><span class="line">	init();</span><br><span class="line">	printf(&quot;%d\n&quot;, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>树的最大独立集</title>
    <url>/2020/03/30/%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86/</url>
    <content><![CDATA[<h1 id="树的最大独立集"><a class="markdownIt-Anchor" href="#树的最大独立集"></a> 树的最大独立集</h1>
<p>对于一颗n个节点的无根树，选出尽可能多的节点，使得任何两个结点均不相邻，然后输入n-1条无向边，输出一个最大独立集(如果有多解，则任意输出一组)</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>以d(i)来表示以i为根节点的子树的最大独立集大小。由于本题是无向图，所以没有父子关系，可通过任选一个结点作为根节点使无根树变成有根树。</li>
<li>对于每个结点i，其决策包括选和不选。如果选i，那么不能选i的儿子，那么d(i) = 1+ d(孙子)；如果不选i，那么d(i) = d(儿子)。</li>
<li>这样就需要枚举结点i的所有子孙，很不方便。换一种思路，对每个点i，更新其父节点和祖父结点。这样对于每个结点只需记录其父节点即可，<strong>即刷表法</strong>。</li>
<li><strong>另一种实现见<a href="../Hail-Bula%E7%9A%84%E8%88%9E%E4%BC%9A/">Hail-Bula的舞会</a></strong></li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> s[maxn], gs[maxn], dp[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v : g[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		dfs(v, u);</span><br><span class="line">		s[u] += dp[v];</span><br><span class="line">		<span class="keyword">if</span> (fa != <span class="number">-1</span>)</span><br><span class="line">			gs[fa] += dp[v];</span><br><span class="line">	&#125;</span><br><span class="line">	dp[u] = <span class="built_in">max</span>(<span class="number">1</span> + gs[u], s[u]);</span><br><span class="line">	<span class="keyword">return</span> dp[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">		g[a].push_back(b);</span><br><span class="line">		g[b].push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">		<span class="built_in">memset</span>(gs, <span class="number">0</span>, <span class="keyword">sizeof</span>(gs));</span><br><span class="line">		<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">		<span class="keyword">int</span> tmp = dfs(i, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> (tmp &gt; ans)</span><br><span class="line">			ans = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>消防车</title>
    <url>/2020/03/30/%E6%B6%88%E9%98%B2%E8%BD%A6/</url>
    <content><![CDATA[<h1 id="uva-208-消防车"><a class="markdownIt-Anchor" href="#uva-208-消防车"></a> UVA 208 消防车</h1>
<p>给你一张图，输入x，y表示xy见有一条边。输出从1到z所有的遍历方案（字典序）。每个节点从1到N标号。 有多组数据，每组数据以0 0结束。 （注意，刚开始的输入不是节点或边的数目） 输入输出格式可以参考样例. 数据范围（节点总数N&lt;21）</p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<ol>
<li>本题要求输出所有的完整的路径，即要沿着一条路走到头，所以使用dfs</li>
<li>辅助用bfs判断依次是否存在路径，否则会超时</li>
<li>本题中各层的path之间不会影响，因为递归是走到头再返回的。</li>
</ol>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<pre><code>#include&lt;bits/stdc++.h&gt;
# pragma warning(disable:4996)
FILE *fin = freopen(&quot;习题7-1in.txt&quot;, &quot;r&quot;, stdin);
FILE *fout = freopen(&quot;习题7-1out.txt&quot;, &quot;w&quot;, stdout);
using namespace std;
const int maxn = 20+5;
map&lt;int, vector&lt;int&gt;&gt; g;
bool bfs();
void dfs(int u,int step);
int goal, cnt,kase = 0;
bool vis[maxn];
int path[maxn];
struct edge {
int x, y;
edge(int x, int y) :x(x), y(y) {}
bool operator &lt; (const edge&amp;a) const { return x &lt; a.x; }
};
int main() {
int a, b;
while (scanf(&quot;%d&quot;, &amp;goal) == 1) {
	g.clear();
	printf(&quot;CASE %d:\n&quot;, ++kase);
	while (scanf(&quot;%d %d&quot;, &amp;a, &amp;b) &amp;&amp; a) {
		g[a].push_back(b);
		g[b].push_back(a);
	}
	for (int i = 0; i &lt; maxn; i++)
		sort(g[i].begin(), g[i].end());
	cnt = 0;
	memset(vis, 0, sizeof(0));
	if (!bfs()) {//优化，否则会T
		cnt = 0;
	}
	else {
		vis[1] = 1;
		dfs(1,0);
	}
	printf(&quot;There are %d routes from the firestation to streetcorner %d.\n&quot;, cnt,goal);
}
}
bool bfs() {
queue&lt;int&gt; q;
q.push(1);
while (!q.empty()) {
	int u = q.front(); q.pop();
	if (u == goal) {
		memset(vis, 0, sizeof(vis));
		return true;
	}
	for (int i = 0; i &lt; g[u].size(); i++) {
		int v = g[u][i];
		if (!vis[v])
		{
			vis[v] = 1;
			q.push(v);
		}
	}
}
memset(vis, 0, sizeof(vis));
return false;
}
void dfs(int u,int step) {
path[step] = u;
if (u == goal) {
	printf(&quot;%d&quot;, path[0]);
	for (int i =1; i &lt;= step; i++)
		printf(&quot; %d&quot;, path[i]);
	printf(&quot;\n&quot;);
	cnt++;
}
for (int i = 0; i &lt; g[u].size(); i++) {
	int v = g[u][i];
	if (vis[v]) continue;
	vis[v] = 1;
	dfs(v,step+1);
	vis[v] = 0;
}
}
</code></pre>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>煎饼</title>
    <url>/2020/03/30/%E7%85%8E%E9%A5%BC/</url>
    <content><![CDATA[<h1 id="uva-120-煎饼"><a class="markdownIt-Anchor" href="#uva-120-煎饼"></a> UVA 120 煎饼</h1>
<p>给你一迭薄煎饼，请你写一个程式来指出要如何安排才能使这些薄煎饼由上到下依薄煎饼的半径由小到大排好。所有的薄煎饼半径均不相同。</p>
<p>要把薄煎饼排好序需要对这些薄煎饼做翻面（flip）的动作。方法是以一抹刀插入一迭薄煎饼中，然后做翻面的动作（也就是说在抹刀上面的薄煎饼经翻面后，会依相反的次序排列）。若一迭共有n个薄煎饼，我们定义最底下的薄煎饼的位置为1，最上面的薄煎饼位置为n。当抹刀插入位置为k时，代表从位置k到位置n的薄煎饼要做翻面的动作。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>题意是要进行排序，只不过基本操作是颠倒一个连续的子序列</li>
<li>借鉴选择排序的思想，从大到小依次将每个数排到正确的位置。</li>
<li>实现时先翻到最上面，再翻到正确位置。因为大的在下面，并且按照从大到小的顺序处理，所以当处理第i大的煎饼时，不会影响到1，2，3，···，i-1大的煎饼。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="filp-从p处开始翻"><a class="markdownIt-Anchor" href="#filp-从p处开始翻"></a> filp 从p处开始翻</h2>
<ol>
<li>使用swap函数更好理解，并且省下了辅助数组所耗费的时间和空间</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	void filp(int p) &#123;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; p - i; i++) </span><br><span class="line">		swap(in[i], in[p - i]);</span><br><span class="line">	printf(&quot;%d &quot;, n - p);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">## main </span><br><span class="line">1. 由于规模较小，所以使用order数组来确定大小关系，也可以使用max_element函数</span><br></pre></td></tr></table></figure>
<pre><code>const int maxn = 35;
int in[maxn];
int order[maxn];
int ans[maxn];
int n;
int main() {
string line;
while (getline(cin, line))
{
	cout &lt;&lt; line &lt;&lt; endl;
	stringstream ss(line);
	n = 0;
	while (ss &gt;&gt; in[n]) n++;
	memcpy(order, in, sizeof(in));
	sort(order, order + n);
	int now;
	for (int i = n - 1; i &gt;= 0;i--) {
		int now = order[i];
		for (int j = 0; j &lt; n; j++) {
			if (in[j] == now) {
				if (j == i ) break;
				if (j != 0)  filp(j);
				filp(i);
				break;
			}
		}
	}
	cout &lt;&lt;&quot;0&quot;&lt;&lt; endl;
}

}
</code></pre>
<pre class="highlight"><code class=""></code></pre>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口最小问题</title>
    <url>/2020/03/30/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="p1886-滑动窗口最小问题"><a class="markdownIt-Anchor" href="#p1886-滑动窗口最小问题"></a> P1886 滑动窗口最小问题</h1>
<p>有一个长为 nnn 的序列 aaa，以及一个大小为 kkk 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。</p>
<p><img src="/%E8%AE%A1%E5%AE%89%E5%AF%BC_img/5.png" alt="" /></p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>窗口滑动的过程，相当于删除一个元素，再插入一个元素，同时获得最大值或者最小值。相当于一个<strong>优先级队列</strong>，可以使用set来模拟一个优先级队列实现,时间复杂度O((n-k)logk)，其中插入，删除，取极值都是logk,一共需要滑动n-k次。规模大时TLE。</li>
<li>使用<strong>单调队列</strong>：队列中元素顺序与输入相同，而元素的值是有序的。因为每个元素至多被删除依次，所以总的时间复杂度在O(n)。以单调增队列为例
<ol>
<li>如果当前正在扫描的元素比队列队尾元素大，那么直接插入。如果比队尾元素小，则将元素从<strong>队尾出队</strong>，直到队尾元素小于当前元素。</li>
<li>如果插入元素后，有的元素滑动到窗口外，则应该从<strong>队头出队</strong></li>
</ol>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="单调队列"><a class="markdownIt-Anchor" href="#单调队列"></a> 单调队列</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">struct monotone_queue &#123;</span><br><span class="line">	static const int maxn &#x3D; 1e6+5;</span><br><span class="line">	int n, k, a[maxn];</span><br><span class="line">	int q[maxn], head, tail, p[maxn];&#x2F;&#x2F;q是值的队列,q是编号的队列</span><br><span class="line"></span><br><span class="line">	void read_in() &#123;</span><br><span class="line">		scanf(&quot;%d %d&quot;, &amp;n, &amp;k);</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void monotone_min() &#123;</span><br><span class="line">		int head &#x3D; 1;</span><br><span class="line">		int tail &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			while (head &lt;&#x3D; tail &amp;&amp; q[tail] &gt;&#x3D; a[i]) tail--;&#x2F;&#x2F;比当前元素大的全部从队尾出队</span><br><span class="line">			q[++tail] &#x3D; a[i];</span><br><span class="line">			p[tail] &#x3D; i;&#x2F;&#x2F;插入当前元素</span><br><span class="line">			while (p[head] &lt;&#x3D; i - k) head++;&#x2F;&#x2F;窗口外元素从队头出队</span><br><span class="line">			if (i &gt;&#x3D; k) printf(&quot;%d &quot;, q[head]);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void monotone_max() &#123;</span><br><span class="line">		int head &#x3D; 1;</span><br><span class="line">		int tail &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			while (head &lt;&#x3D; tail &amp;&amp; q[tail] &lt;&#x3D; a[i]) tail--;&#x2F;&#x2F;比当前元素小的全部从队尾出队</span><br><span class="line">			q[++tail] &#x3D; a[i];</span><br><span class="line">			p[tail] &#x3D; i;</span><br><span class="line">			while (p[head] &lt;&#x3D; i - k) head++;</span><br><span class="line">			if (i &gt;&#x3D; k) printf(&quot;%d &quot;, q[head]);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">monotone_queue mq;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	mq.read_in();</span><br><span class="line">	mq.monotone_min();</span><br><span class="line">	mq.monotone_max();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模拟优先队列"><a class="markdownIt-Anchor" href="#模拟优先队列"></a> 模拟优先队列</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1e6 + 5;</span><br><span class="line"> </span><br><span class="line">set&lt;int, less&lt;int&gt; &gt; s;</span><br><span class="line">int big[maxn], small[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, k;</span><br><span class="line">	scanf(&quot;%d %d&quot;, &amp;n, &amp;k);</span><br><span class="line"></span><br><span class="line">	int a;</span><br><span class="line">	int p1 &#x3D; 0, p2 &#x3D; 0;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">		q.push(a);</span><br><span class="line">		s.insert(a);</span><br><span class="line">		if (q.size() &#x3D;&#x3D; k) &#123;</span><br><span class="line">			int tmp &#x3D; q.front(); q.pop();</span><br><span class="line">			small[p1++] &#x3D; *(s.begin());</span><br><span class="line">			big[p2++] &#x3D; *(s.rbegin());</span><br><span class="line">			s.erase(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; p1; i++)</span><br><span class="line">		printf(&quot;%d &quot;, small[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; p2; i++)</span><br><span class="line">		printf(&quot;%d &quot;, big[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>照明系统设计</title>
    <url>/2020/03/30/%E7%85%A7%E6%98%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="uva-11400-照明系统设计"><a class="markdownIt-Anchor" href="#uva-11400-照明系统设计"></a> UVA 11400 照明系统设计</h1>
<p>题意: 给定n(n≤1000)种类型灯泡，每个灯泡给出其电压v(v≤132000)，电源花费k(k≤1000)，每个灯的花费c(c≤10) 和需求量l(1≤l≤100)l。现在通过用电压大的灯泡替换某些电压小的灯泡来减小总花费，求最小的花费。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>首先有结论，每种电压的灯泡要么全换，要么全部不换。这是因为，如果因为换1个降低成本，那么换2个也降低成本…全换了还剩一个电源钱，就很棒。</li>
<li>其次，由于题干要求只能换成电压更大的灯泡，所以先将所有种类的灯泡按电压从小到大排序。顺次遍历，对于更大电压的灯泡，依次尝试替换比他电压小的灯泡，更新状态。</li>
<li>设d(i)表示灯泡1~i的最小开销</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000 + 5;</span><br><span class="line">struct Lamp &#123;</span><br><span class="line">	int v, k, c, l;</span><br><span class="line">	bool operator &lt; (const Lamp&amp;x)const &#123; return v &lt; x.v; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Lamp lamp[maxn];</span><br><span class="line">int d[maxn];</span><br><span class="line">int s[maxn];</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1 &amp;&amp; n)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">			scanf(&quot;%d%d%d%d&quot;, &amp;lamp[i].v, &amp;lamp[i].k, &amp;lamp[i].c, &amp;lamp[i].l);</span><br><span class="line"></span><br><span class="line">		sort(lamp + 1, lamp + 1 + n);</span><br><span class="line">		s[0] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) s[i] &#x3D; s[i - 1] + lamp[i].l;</span><br><span class="line">		d[0] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			d[i] &#x3D; s[i] * lamp[i].c + lamp[i].k; </span><br><span class="line">			for (int j &#x3D; 1; j &lt;&#x3D; i; j++)</span><br><span class="line">				d[i] &#x3D; min(d[i], d[j] + (s[i] - s[j]) * lamp[i].c + lamp[i].k);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; d[n] &lt;&lt; &quot;\n&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>理想路径</title>
    <url>/2020/03/30/%E7%90%86%E6%83%B3%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="uva-1599-理想路径"><a class="markdownIt-Anchor" href="#uva-1599-理想路径"></a> UVA 1599 理想路径</h1>
<p>给定一个n个点m条边的无向图，每条边上都涂有1种颜色。求11到点n的一条路径，使得经过的边数最少，在此前提下，经过边的颜色序列最小。可能有自环与重边。输入保证至少存在一条连接1和n的道路。</p>
<p>输入共m+1行：</p>
<p>第一行2个空格整数：n和m</p>
<p>以后m行，每行空格隔开的3个整数ai,bi,ci表示在ai,bi之间有一条颜色为ci的道路。</p>
<p>输出路径序列</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>整体来说，还是无向图最短路问题，使用bfs求解。</li>
<li>问题在于路径选择需要选择字典序最小的序列，而bfs过程中并不能知道哪条路是最短的，所以无法一次性求解。</li>
<li>解决方法是从n点开始bfs，记录到其余各点的最小距离。之后再从头进行一次bfs，每次只走距离n点距离恰好减一的点走，并在其中选择字典序最小的走，这样一定走的是最短路，并且路径字典序最小。</li>
<li>为了减少队列占用的空间，实现是队列中存的是边的序号，应该关注这种写法</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="addedge-给新加入的边一个序号"><a class="markdownIt-Anchor" href="#addedge-给新加入的边一个序号"></a> addEdge 给新加入的边一个序号</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;edge&gt; E;</span><br><span class="line">vector&lt;int&gt; g[maxn];</span><br><span class="line">void addEdge(int u, int v, int w) &#123;</span><br><span class="line">	E.push_back(edge(u, v, w));</span><br><span class="line">	int size &#x3D; E.size() - 1;</span><br><span class="line">	g[u].push_back(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bfs_end-从尾部开始的bfs常规"><a class="markdownIt-Anchor" href="#bfs_end-从尾部开始的bfs常规"></a> bfs_end 从尾部开始的bfs，常规</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool vis[maxn];</span><br><span class="line">int d[maxn];</span><br><span class="line">void bfs_end() &#123;</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	d[n] &#x3D; 0;</span><br><span class="line">	vis[n] &#x3D; 1;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	q.push(n);</span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		int u &#x3D; q.front(); q.pop();</span><br><span class="line">		for (int i : g[u]) &#123;</span><br><span class="line">			int v &#x3D; E[i].b;</span><br><span class="line">			if (!vis[v])</span><br><span class="line">			&#123;</span><br><span class="line">				vis[v] &#x3D; 1;</span><br><span class="line">				d[v] &#x3D; d[u] + 1;</span><br><span class="line">				q.push(v);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bfs_sta-从正向开始bfs"><a class="markdownIt-Anchor" href="#bfs_sta-从正向开始bfs"></a> bfs_sta 从正向开始bfs</h2>
<p>此处tmp中包含了字典序最小的点，只有当真正走出这一步时，vis[i]才置1(即入队的时候)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; ans;</span><br><span class="line">void bfs_sta() &#123;</span><br><span class="line">	ans.clear();</span><br><span class="line">	memset(vis, 0, sizeof(vis));</span><br><span class="line">	vis[1] &#x3D; 1;</span><br><span class="line">	queue&lt;int&gt; q;</span><br><span class="line">	q.push(1);</span><br><span class="line">	vector&lt;int&gt; tmp;</span><br><span class="line">	int minn;</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		minn &#x3D; inf;</span><br><span class="line">		tmp.clear();</span><br><span class="line">		while (!q.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			int u &#x3D; q.front(); q.pop();</span><br><span class="line">			if (u &#x3D;&#x3D; n) return;</span><br><span class="line">			for (int i : g[u]) &#123;</span><br><span class="line">				int v &#x3D; E[i].b;</span><br><span class="line">				if (d[v] &#x3D;&#x3D; d[u] - 1) &#123;</span><br><span class="line">					if (E[i].w &lt;&#x3D; minn) &#123;</span><br><span class="line">						minn &#x3D; E[i].w;</span><br><span class="line">						tmp.push_back(i);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ans.push_back(minn);</span><br><span class="line"></span><br><span class="line">		for (int i : tmp) &#123;</span><br><span class="line">			int v &#x3D; E[i].b;</span><br><span class="line">			if (!vis[v] &amp;&amp; E[i].w &#x3D;&#x3D; minn) &#123;</span><br><span class="line">				q.push(v);</span><br><span class="line">				vis[v] &#x3D; 1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100000 + 5;</span><br><span class="line">#define inf 1000000000</span><br><span class="line">int n, m;</span><br><span class="line">struct edge &#123;</span><br><span class="line">	int a;</span><br><span class="line">	int b;</span><br><span class="line">	int w;</span><br><span class="line">	edge(int a, int b, int w) :a(a), b(b), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &#x3D;&#x3D; 2) &#123;</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) g[i].clear();</span><br><span class="line">		E.clear();</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">			int u, v, w;</span><br><span class="line">			scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">			addEdge(u, v, w);</span><br><span class="line">			addEdge(v, u, w);</span><br><span class="line">		&#125;</span><br><span class="line">		bfs_end();</span><br><span class="line">		bfs_sta();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		printf(&quot;%d\n%d&quot;, ans.size(), ans[0]);</span><br><span class="line">		for (int i &#x3D; 1; i &lt; ans.size(); i++)</span><br><span class="line">			printf(&quot; %d&quot;, ans[i]);</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>环形跑道</title>
    <url>/2020/03/30/%E7%8E%AF%E5%BD%A2%E8%B7%91%E9%81%93/</url>
    <content><![CDATA[<h1 id="uva-11093-环形跑道"><a class="markdownIt-Anchor" href="#uva-11093-环形跑道"></a> UVA 11093 环形跑道</h1>
<p>环形跑道上有n(1 &lt;= n &lt;= 100000)个加油站，编号为1~n。第i个加油站可以加油pi加仑。从加油站i开到下 一站需要qi加仑汽油。你可以选择一个加油站作为起点，起始油箱为空（但可以立即加油）。你的任务是选 择一个起点，使得可以走完一圈后回到起点。假定油箱中的油量没有上限。如果无解，输出Not possible，否则 输出可以作为起点的最小加油站编号。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>贪心法：从小编号加油站开始尝试，如果能转一圈，那么直接输出。否则，以油量不够的加油站的下一站为起点再进行尝试。</li>
<li>假设尝试从1号加油站开始走，到i号加油站加完油也到不了i+1号加油站。那么从2~i-1号加油站开始也肯定不能到，这是因为从1到2时，油箱中的油量c&gt;=0</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 100000 + 5;</span><br><span class="line">int p[maxn], q[maxn];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">void solve();</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	int kase &#x3D; 0;</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Case %d: &quot;, ++kase);</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;p[i]);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;q[i]);</span><br><span class="line">		solve();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="solve-贪心过程"><a class="markdownIt-Anchor" href="#solve-贪心过程"></a> solve 贪心过程</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void solve() &#123;</span><br><span class="line"></span><br><span class="line">	int beg &#x3D; 0;&#x2F;&#x2F;beg为起点编号</span><br><span class="line"></span><br><span class="line">	int used[maxn]&#123;&#125;;</span><br><span class="line">	bool flag;</span><br><span class="line"></span><br><span class="line">	do</span><br><span class="line">	&#123;&#x2F;&#x2F;如果试图使用已经尝试过的起点，说明尝试了一圈了</span><br><span class="line"></span><br><span class="line">		while (beg &lt; n&amp;&amp;p[beg] &lt; q[beg]) &#123;&#x2F;&#x2F;掠过若干不可能的起点并标记</span><br><span class="line">			used[beg] &#x3D; 1;</span><br><span class="line">			beg++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		if (beg &gt;&#x3D; n) break;</span><br><span class="line">		int next &#x3D; beg;&#x2F;&#x2F;到下一站耗油量q[next]</span><br><span class="line">		used[beg] &#x3D; 1;</span><br><span class="line"></span><br><span class="line">		int c &#x3D; 0;</span><br><span class="line">		flag &#x3D; true;</span><br><span class="line">		int cnt &#x3D; 0;</span><br><span class="line">		do &#123;</span><br><span class="line">			c +&#x3D; p[next];	&#x2F;&#x2F;加油</span><br><span class="line">			if (c &lt; q[next]) &#123;&#x2F;&#x2F;开不到下一站</span><br><span class="line">				next++;</span><br><span class="line">				flag &#x3D; false;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			else c -&#x3D; q[next];</span><br><span class="line">			next &#x3D; (next + 1) % n;</span><br><span class="line">		&#125; while (next !&#x3D; beg);&#x2F;&#x2F;转一圈结束</span><br><span class="line"></span><br><span class="line">		if (!flag) &#123;</span><br><span class="line">			beg &#x3D; next;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">			break;</span><br><span class="line">	&#125; while (!used[beg]);</span><br><span class="line"></span><br><span class="line">	if (!flag)</span><br><span class="line">		printf(&quot;Not possible\n&quot;);</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;Possible from station %d\n&quot;, beg + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>破坏正方形</title>
    <url>/2020/03/30/%E7%A0%B4%E5%9D%8F%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="uva-1603-破坏正方形"><a class="markdownIt-Anchor" href="#uva-1603-破坏正方形"></a> UVA 1603 破坏正方形</h1>
<p>一个 n×n的网格,共 2×n×(n+1)条边,现在已经删除了一些边,问至 少还需删去多少边,可以使得剩下的边不能构成正方形。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>
<p>可以采用迭代加深度深搜，或者回溯法解决</p>
</li>
<li>
<p>搜索对象可以是木棍或者正方形，对应不同的剪枝</p>
<ol>
<li>如果搜索对象是木棍，那么可以将每个木棍影响的正方形数量记录下来，从大到小排序。当最大影响数量为1时，可以停止搜索，结果为当前层数+剩余正方形数。这是因为如果最大影响数为1，说明剩余正方形之间没有耦合，删除任一木棍，至多减少1个正方形。</li>
<li>如果搜索对象是正方形，那么应该从小正方形开始破坏。本题中采用这种方法。</li>
</ol>
</li>
<li>
<p>此外，还需要找规律，寻找各行各列，竖线横线的标号关系。以标记构成正方形的边。</p>
</li>
<li>
<p>本题中判断是否为正方形，<strong>通过size数组和full数组，分别记录第cnt个正方形实际有的边和应该有的边，如果二者相等，那么是一个完整的正方形</strong></p>
</li>
<li>
<p>本题中使用了回溯法，因为搜素深度有明显的上界2<em>n</em>(n+1)，其中n为边长。</p>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> dfs</h2>
<pre><code>void dfs(int d) {
if (d &gt;= maxd) return;
int next = getNext();
if (next == 0) {
	maxd = d;
	return;
}
for (int j = 1; j &lt;= sum; j++) {
	if (in[next][j])
	{
		for (int k = 1; k &lt;= cnt; k++)//删掉火柴棍
			if (in[k][j]) Size[k]--;
		dfs(d + 1);
		for (int k = 1; k &lt;= cnt; k++)//复原
			if (in[k][j]) Size[k]++;
	}
}
return;
}
</code></pre>
<ol>
<li>在删除木棍和回溯的部分，由于判断是才用size[i]==full[i]，所以in[k][j]处必有火柴。</li>
</ol>
<h2 id="getrgetc-求横竖线编号"><a class="markdownIt-Anchor" href="#getrgetc-求横竖线编号"></a> getr,getc 求横竖线编号</h2>
<pre><code>inline int getr(int r, int c) {
return r * (2 * n + 1) + c + 1;
}
inline int getc(int r, int c) {
return r * (2 * n + 1) + c + n + 1;
}
</code></pre>
<h2 id="get_cnt-填充size数组和full数组"><a class="markdownIt-Anchor" href="#get_cnt-填充size数组和full数组"></a> get_cnt 填充size数组和full数组</h2>
<pre><code>inline void get_cnt() {
int a, b, e, f;
cnt = 0;
for (int len = 1; len &lt;= n; len++) {
	for (int r = 0; r + len &lt;= n; r++) {
		for (int c = 0; c + len &lt;= n; c++) {
			++cnt;
			full[cnt] = len * 4;
			Size[cnt] = 0;
			for (int i = 0; i &lt; len; i++)
			{
				a = getr(r, c + i);
				b = getr(r + len, c + i);
				e = getc(r + i, c);
				f = getc(r + i, c + len);
				in[cnt][a] = true;
				in[cnt][b] = true;
				in[cnt][e] = true;
				in[cnt][f] = true;
				Size[cnt] += sticks[a] + sticks[b] + sticks[e] + sticks[f];
			}
		}
	}
}
}
</code></pre>
<ol>
<li>注意这种判断的思维。</li>
</ol>
<h2 id="main-函数"><a class="markdownIt-Anchor" href="#main-函数"></a> main 函数</h2>
<pre><code>int n, maxd, cnt, sum;
bool sticks[2 * maxn*(maxn + 1) + 1];
int Size[625];
int full[625];
int in[625][2 * maxn*(maxn + 1) + 1];
int main() {
int T, k, tmp;
scanf(&quot;%d&quot;, &amp;T);
while (T--) {
	scanf(&quot;%d\n%d&quot;, &amp;n, &amp;k);
	memset(sticks, 1, sizeof(sticks));
	memset(in, 0, sizeof(in));
	while (k--) {
		scanf(&quot;%d&quot;, &amp;tmp);
		sticks[tmp] = false;
	}
	sum = 2 * n*(n + 1);
	maxd = sum;
	get_cnt();
	dfs(0);
	printf(&quot;%d\n&quot;, maxd);
}
}
</code></pre>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>移动木块</title>
    <url>/2020/03/30/%E7%A7%BB%E5%8A%A8%E6%9C%A8%E5%9D%97/</url>
    <content><![CDATA[<h1 id="uva-12657-移动盒子"><a class="markdownIt-Anchor" href="#uva-12657-移动盒子"></a> uva 12657 移动盒子</h1>
<p>你有n个盒子在桌子上的一条线上从左到右编号为1……n。你的任务是模拟四种操作</p>
<p>1 X Y 移动盒子编号X到盒子编号Y的左边（如果X已经在Y的左边了就忽略）</p>
<p>2 X Y 移动盒子编号X到盒子编号Y的右边（如果X已经在Y的右边了就忽略）</p>
<p>3 X Y 交换盒子编号X与盒子编号Y的位置</p>
<p>4 将整条线反转</p>
<p>操作保证合法，X不等于Y</p>
<p>举一个例子，如果n=6，操作 1 1 4然后就变成了2 3 1 4 5 6；再操作 2 3 5就变成了 2 1 4 5 3 6；再操作 3 1 6 就变成 2 6 4 5 3 1；最后操作4，就变成了 1 3 5 4 6 2</p>
<p>输入</p>
<p>最多有10组数据，每个数据会包含两个整数n,m（1≤n,m&lt;100,000）, 接下来是m行数据，表示操作。</p>
<p>输出</p>
<p>对于每组数据，输出他们奇数位置的编号的和。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<p>题中操作使得插入可以在任意位置进行（看起来双端队列好像可以，但是光标移动到HOME之后，就不是在头部插入了）</p>
<ol>
<li>考虑用双向链表，因为用数组会超时，用单向链表又不够</li>
<li>定义辅助函数link来连接链表</li>
<li>定义inv来标识4号反转指令执行了几次，如果是奇数次，那么op=3-op（即放左边变成放右边），如果是偶数次，那么不变。</li>
<li>对于指令三，需要注意当XY相邻的时候，情况不一样。代码中对于此处用了技巧，比如X在Y的相邻右侧，并且交换XY之后Y在X的右侧，则XY相邻。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    #include&lt;iostream&gt;</span><br><span class="line">    #include&lt;cstring&gt;</span><br><span class="line">    #include&lt;algorithm&gt;</span><br><span class="line">    # pragma warning(disable:4996)</span><br><span class="line">    # define LOCAL</span><br><span class="line">    # ifdef LOCAL</span><br><span class="line">    FILE *fin &#x3D; freopen(&quot;移动盒子in.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    FILE *fout &#x3D; freopen(&quot;移动盒子out.txt&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    # endif </span><br><span class="line">    # define maxn 100005</span><br><span class="line">    int left[maxn], right[maxn];</span><br><span class="line">    void link(int l, int r) &#123;</span><br><span class="line">    	left[r] &#x3D; l;</span><br><span class="line">    	right[l] &#x3D; r;</span><br><span class="line">    &#125;</span><br><span class="line">    int main() &#123;</span><br><span class="line">    	int n, m;</span><br><span class="line">	int kase &#x3D; 0;</span><br><span class="line">	while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			left[i] &#x3D; i - 1;</span><br><span class="line">			right[i] &#x3D; (i + 1) % (n + 1);</span><br><span class="line">		&#125;</span><br><span class="line">		right[0] &#x3D; 1;</span><br><span class="line">		left[0] &#x3D; n;</span><br><span class="line">		int op, x, y, inv &#x3D; 0;</span><br><span class="line"></span><br><span class="line">		while (m--) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			scanf(&quot;%d&quot;, &amp;op);</span><br><span class="line">			if (op &#x3D;&#x3D; 4) inv &#x3D; !inv;</span><br><span class="line">			else &#123;</span><br><span class="line">				scanf(&quot;%d%d&quot;, &amp;x, &amp;y);</span><br><span class="line">				if (op &#x3D;&#x3D; 3 &amp;&amp; right[y] &#x3D;&#x3D; x) std::swap(x, y);</span><br><span class="line">				if (op !&#x3D; 3 &amp;&amp; inv) op &#x3D; 3 - op;</span><br><span class="line">				if (op &#x3D;&#x3D; 1 &amp;&amp; x &#x3D;&#x3D; left[y]) continue;</span><br><span class="line">				if (op &#x3D;&#x3D; 2 &amp;&amp; x &#x3D;&#x3D; right[y]) continue;</span><br><span class="line"></span><br><span class="line">				int lx &#x3D; left[x], rx &#x3D; right[x], ly &#x3D; left[y], ry &#x3D; right[y];</span><br><span class="line">				if (op &#x3D;&#x3D; 1) &#123;</span><br><span class="line">					link(lx, rx); link(ly, x); link(x, y);</span><br><span class="line">				&#125;</span><br><span class="line">				else if (op &#x3D;&#x3D; 2) &#123;</span><br><span class="line">					link(lx, rx); link(y, x); link(x, ry);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				&#x2F;*else if (op &#x3D;&#x3D; 3) &#123;</span><br><span class="line">					if (right[y] &#x3D;&#x3D; x) &#123;</span><br><span class="line">						link(y, rx); link(ly, x); link(x, y);</span><br><span class="line">					&#125;</span><br><span class="line">					else if (left[y] &#x3D;&#x3D; x) &#123;</span><br><span class="line">						link(lx, y); link(y, x); link(x, ry);</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123;</span><br><span class="line">						link(ly, x); link(x, ry);</span><br><span class="line">						link(lx, y); link(y, rx);</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;*&#x2F;</span><br><span class="line">&lt;注释部分与下面这段等价</span><br><span class="line">				else if (op &#x3D;&#x3D; 3) &#123;</span><br><span class="line">					if (right[x] &#x3D;&#x3D; y) &#123;</span><br><span class="line">						link(lx, y); link(y, x); link(x, ry);</span><br><span class="line">					&#125;</span><br><span class="line">					else &#123; link(lx, y); link(y, rx); link(ly, x); link(x, ry); &#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		int b &#x3D; 0;</span><br><span class="line">		</span><br><span class="line">		long long ans &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">			b &#x3D; right[b];</span><br><span class="line">			&#x2F;&#x2F;std::cout &lt;&lt; i&lt;&lt;&quot;: &quot;&lt;&lt;right[b] &lt;&lt; std::endl;</span><br><span class="line">			if (i % 2 &#x3D;&#x3D; 1) ans +&#x3D; b;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;*using namespace std;</span><br><span class="line">		cout &lt;&lt; endl;*&#x2F;</span><br><span class="line">		if (inv &amp;&amp; n % 2 &#x3D;&#x3D; 0) ans &#x3D; (long long)n*(n + 1) &#x2F; 2 - ans;</span><br><span class="line"></span><br><span class="line">&gt;由于处理的时候，对于反转，只对1.2操作处理了。所以在输出的时候还要考虑：如果总数为偶数，并且反转了奇数次，那么奇数位的盒子编号才会改变</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">		printf(&quot;Case %d: %lld\n&quot;, ++kase, ans);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<ol>
<li>学习代码中处理相邻的简化方法</li>
<li>学习双向链表的辅助函数</li>
<li>如果某一操作非常费时，那么不必每一步都真的执行他</li>
<li>编号不是位置了</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>空间结构</title>
    <url>/2020/03/30/%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="uva-806-空间结构"><a class="markdownIt-Anchor" href="#uva-806-空间结构"></a> UVA 806 空间结构</h1>
<p>一个四分树是由一个方格的结构组成的，如图：（就是上面的三个图）。</p>
<p>那些像素点可以构成一个四分树，如图：（就是上面的那个树）。</p>
<p>我们规定，NW=1,NE=2,SW=3,SE=4，而一个节点所构成的数字串可以认为是一个五进制数，将它们排序后输出。</p>
<p>例如：上图中地四号节点的路径为NE,SW，所以是32532_5325​ （五进制数）=171017_{10}1710​（十进制数）</p>
<p>那么上树所对应的一传数列为：（在十进制下）</p>
<p>9 14 17 22 23 44 63 69 88 94 113\text{9 14 17 22 23 44 63 69 88 94 113} 9 14 17 22 23 44 63 69 88 94 113</p>
<p>你的任务是在这两者之间转换。</p>
<p>注意，数串中的数字顺序是从叶子到根的，别搞错了。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>
<p>对于n&gt;0的情况，需要将矩阵转化为四分树。</p>
<p>采用递归算法，每次递归四分之一块，如果遇到范围内纯黑或纯白，则返回。并且在遇到纯黑时，将序列存入向量中。</p>
<p>注意：要先判断整个图是否为纯黑或者纯白。</p>
<p>然后将五进制转化为十进制</p>
</li>
<li>
<p>对于n&lt;0的情况，将四分树转化为矩阵<br />
先将十进制转化为五进制，并在字符串尾部添加*，以标识叶子节点<br />
采用递归算法，每次根据当前字符，来选择下一步递归的范围。当遇到叶子节点时，将当前层的范围内的点涂黑</p>
<p>注意：pre向量中的每个元素，代表一条从根到叶子的路径，所以要用循环配合递归。</p>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;string.h&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
# pragma warning(disable:4996)
# define LOCAL
# ifdef LOCAL
FILE *fin = freopen(&quot;空间结构in.txt&quot;, &quot;r&quot;, stdin);
FILE *fout = freopen(&quot;空间结构out.txt&quot;, &quot;w&quot;, stdout);
# endif 
using namespace std;

vector&lt;int&gt; number;
vector&lt;string&gt; pre;
char g[64][64];
int n;
void five() {
	for (int i = 0; i &lt; number.size(); i++) {
		int temp = 0;
		while (number[i]) {
			temp *= 10;		//注意此处要先乘10
			temp += number[i] % 5;
			number[i] = number[i] / 5;
		}

		pre.push_back(to_string(temp) + '*');
		//加*以标识叶子
	}
}
void draw(const string s, int &amp;p, int r, int c, int w) {

	if (p == s.length()) return;
	char ch = s[p++];
	switch (ch - '0')
	{

	case 1:	draw(s, p, r, c, w / 2); break;
	case 2: draw(s, p, r, c + w / 2, w / 2); break;
	case 3:	draw(s, p, r + w / 2, c, w / 2); break;
	case 4:	draw(s, p, r + w / 2, c + w / 2, w / 2); break;
	default:
		break;
	}
	if (ch == '*') {
		for (int i = r; i &lt; r + w; i++)
			for (int j = c; j &lt; c + w; j++) {
				
					g[i][j] = '*';
				
			}
	}
}
bool judge(int r, int c, int w,char ch) {
	// ch为0代表是否纯黑，为1代表是否纯白
	for (int i = r; i &lt; r + w; i++)
		for (int j = c; j &lt; c + w; j++)
			if (g[i][j] == ch)
				return false;
	return true;	//任何情况下都要有return否则会RE
}
void matrix(string str, int r, int c, int w) {
	
	if (judge(r, c, w,'0')) {
		pre.push_back(str);	//纯黑则递归到头，将序列保存
		return;
	}
	else if (judge(r, c, w,'1')) return;
	else {
		matrix(str + &quot;1&quot;, r, c, w / 2);
		matrix(str + &quot;2&quot;, r, c + w / 2, w / 2);
		matrix(str + &quot;3&quot;, r + w / 2, c, w / 2);
		matrix(str + &quot;4&quot;, r + w / 2, c + w / 2, w / 2);
	}
}
void ten() {

	for (int i = 0; i &lt; pre.size(); i++) {
		int temp = 0;
		for (int j = pre[i].size() - 1; j &gt;= 0; j--)
			temp += (pre[i][j] - '0')*pow(5, j);
		number.push_back(temp);

	}
}
int main() {
	int first = 1;
	int kase = 0;
	while (cin &gt;&gt; n &amp;&amp; n) {
		if (first) first = 0; else cout &lt;&lt; endl;
		cout &lt;&lt; &quot;Image &quot; &lt;&lt; ++kase &lt;&lt; endl;

		number.clear();
		pre.clear();
		memset(g, '.', sizeof(g));
		getchar();
		if (n &gt; 0) {
			for (int i = 0; i &lt; n; i++)
				for (int j = 0; j &lt; n; j++)
					cin &gt;&gt; g[i][j];
		
		
			if (judge(0, 0, n,'0')) number.push_back(0);
			//纯黑的情况
			else if (judge(0, 0, n,'1'));//纯白
			
			else {
				matrix(&quot;1&quot;, 0, 0, n / 2);
				matrix(&quot;2&quot;, 0, n / 2, n / 2);
				matrix(&quot;3&quot;, n / 2, 0, n / 2);
				matrix(&quot;4&quot;, n / 2, n / 2, n / 2);
				ten();
			}
			
			
			sort(number.begin(), number.end());
			if (!number.empty()) {
				for (int i = 0; i &lt; number.size(); i++)
				{
					cout &lt;&lt; number[i];
					if ((i + 1) % 12 == 0||i==number.size()-1) cout &lt;&lt; endl;
					else cout &lt;&lt; &quot; &quot;;
				}
			}

			cout &lt;&lt; &quot;Total number of black nodes = &quot; &lt;&lt; number.size() &lt;&lt; endl;
			
		}
		if (n &lt; 0) {

			string s;
			bool flag = false;
			bool zero = false;
			for (;;) {
				int a;
				//由于输入的结束标志-1不一定出现在哪里，所以
				//要设置标志
				for (int i = 0; i &lt; 12; i++) {
					cin &gt;&gt; a;
					if (a == -1) {
						flag = true;
						break;
					}
					if (a == 0)zero = true;
					number.push_back(a);
				}
				if (flag) break;
			}	
			if (zero) {
			//如果包含0，代表它是一个只有一个节点的树
				memset(g, '*', sizeof(g));
			}
			else {
				five();
				for (int i = 0; i &lt; pre.size(); i++) {
					int p = 0;
					draw(pre[i], p, 0, 0, abs(n));
				}
			}
			


			for (int i = 0; i &lt; abs(n); i++) {
				for (int j = 0; j &lt; abs(n); j++)
					cout &lt;&lt; g[i][j];
				cout &lt;&lt; endl;
			}
		}


	}
}
</code></pre>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<ol>
<li>本题加深了对递归问题的理解，使用递归算法也不是仅仅用递归实现，要搭配循环，减小递归代码的编写难度。</li>
<li>理清思路再写递归，注意认清递归结束条件，不要模糊。</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>目录</title>
    <url>/2020/03/29/%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="青鸟-加密聊天社区"><a class="markdownIt-Anchor" href="#青鸟-加密聊天社区"></a> <a href="http://www.xdchat2020.xyz:8443/login" target="_blank" rel="noopener">青鸟-加密聊天社区</a></h2>
<h2 id="myssql"><a class="markdownIt-Anchor" href="#myssql"></a> <a href="/2020/06/16/iSql/">MySSql</a></h2>
<h2 id="iptables-exp"><a class="markdownIt-Anchor" href="#iptables-exp"></a> <a href="/2020/03/30/Iptables%E5%AE%9E%E9%AA%8C%E7%9B%AE%E5%BD%95/">IPtables Exp</a></h2>
<h2 id="区块链技术"><a class="markdownIt-Anchor" href="#区块链技术"></a> <a href="/2020/03/30/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9B%AE%E5%BD%95/">区块链技术</a></h2>
<h2 id="uva习题"><a class="markdownIt-Anchor" href="#uva习题"></a> <a href="/2020/03/30/UVA%E4%B9%A0%E9%A2%98%E7%9B%AE%E5%BD%95/">UVA习题</a></h2>
<h2 id="计算机视觉相关项目"><a class="markdownIt-Anchor" href="#计算机视觉相关项目"></a> <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E5%AE%9E%E9%AA%8C%E7%9B%AE%E5%BD%95/">计算机视觉相关项目</a></h2>
<h2 id="公交管理系统"><a class="markdownIt-Anchor" href="#公交管理系统"></a> <a href="/2020/07/17/%E5%85%AC%E4%BA%A4%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">公交管理系统</a></h2>
<h2 id="基础知识汇总"><a class="markdownIt-Anchor" href="#基础知识汇总"></a> <a href="/2020/06/20/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/">基础知识汇总</a></h2>
<h2 id="考研机试"><a class="markdownIt-Anchor" href="#考研机试"></a> <a href="/2020/03/30/%E8%80%83%E7%A0%94%E6%9C%BA%E8%AF%95%E7%9B%AE%E5%BD%95/">考研机试</a></h2>
<h2 id="csp认证"><a class="markdownIt-Anchor" href="#csp认证"></a> <a href="/2020/03/30/CSP%E8%AE%A4%E8%AF%81%E7%9B%AE%E5%BD%95/">CSP认证</a></h2>
<h2 id="python可视化"><a class="markdownIt-Anchor" href="#python可视化"></a> <a href="/2020/03/30/Python%E5%8F%AF%E8%A7%86%E5%8C%96%E7%9B%AE%E5%BD%95/">Python可视化</a></h2>
<h2 id="springboot"><a class="markdownIt-Anchor" href="#springboot"></a> <a href="/2020/03/30/SpringBoot%E7%9B%AE%E5%BD%95/">SpringBoot</a></h2>
<h2 id="人工智能"><a class="markdownIt-Anchor" href="#人工智能"></a> <a href="/2020/03/29/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9B%AE%E5%BD%95/">人工智能</a></h2>
<h2 id="机器学习"><a class="markdownIt-Anchor" href="#机器学习"></a> <a href="/2020/06/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%AE%E5%BD%95/">机器学习</a></h2>
<h2 id="数据挖掘-实验"><a class="markdownIt-Anchor" href="#数据挖掘-实验"></a> <a href="/2020/03/30/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E8%AF%BE%E5%A0%82%E7%9B%AE%E5%BD%95/">数据挖掘 &amp; 实验</a></h2>
<h2 id="软件工程"><a class="markdownIt-Anchor" href="#软件工程"></a> <a href="/2020/07/28/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95/">软件工程</a></h2>
<h2 id="计算机视觉基础"><a class="markdownIt-Anchor" href="#计算机视觉基础"></a> <a href="/2020/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%9B%AE%E5%BD%95/">计算机视觉基础</a></h2>
<h2 id="数据库系统"><a class="markdownIt-Anchor" href="#数据库系统"></a> <a href="/2020/03/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%AE%E5%BD%95/">数据库系统</a></h2>
<h2 id="计算机安全基础"><a class="markdownIt-Anchor" href="#计算机安全基础"></a> <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%9B%AE%E5%BD%95/">计算机安全基础</a></h2>
<h2 id="python数据分析与挖掘实战"><a class="markdownIt-Anchor" href="#python数据分析与挖掘实战"></a> <a href="/2020/03/30/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%AE%9E%E6%88%98%E7%9B%AE%E5%BD%95/">Python数据分析与挖掘实战</a></h2>
]]></content>
  </entry>
  <entry>
    <title>第1章绪论</title>
    <url>/2020/03/30/%E7%AC%AC1%E7%AB%A0%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1>
<h2 id="数据挖掘基础终点"><a class="markdownIt-Anchor" href="#数据挖掘基础终点"></a> 数据挖掘基础终点</h2>
<ol>
<li>数据：类型，质量，预处理，度量</li>
<li>分类：决策树，贝叶斯网络，机器学习</li>
<li>关联规则挖掘：Apr规则，FP-growth规则，rule generation</li>
<li>聚类：Hierarchical Methods,Partitioning Methods,density,evaluation</li>
</ol>
<h2 id="相关概念"><a class="markdownIt-Anchor" href="#相关概念"></a> 相关概念</h2>
<ol>
<li><strong>数据挖掘</strong>：从超大规模的数据中提取有价值，有意义的信息</li>
</ol>
<h2 id="分类问题"><a class="markdownIt-Anchor" href="#分类问题"></a> 分类问题</h2>
<ol>
<li>
<p><strong>训练集</strong>：含有属性和<strong>标签</strong>的记录</p>
</li>
<li>
<p><strong>分类问题</strong>：通过训练集训练的模型预测测试集的标签</p>
</li>
<li>
<p><strong>混淆矩阵</strong>：<br />
<img src="/KDD_img/1.png" alt="" /></p>
</li>
<li>
<p><strong>ROC曲线</strong>：不断调整阈值PTR与PFR间的关系</p>
<ol>
<li>对角线含义：随机猜测模型的结果</li>
<li><strong>AUC</strong>：ROC曲线下的面积</li>
</ol>
</li>
<li>
<p><strong>lift analysis</strong>：用使用模型后的效果与不使用模型的效果的比值来评价</p>
</li>
</ol>
<h2 id="聚类问题"><a class="markdownIt-Anchor" href="#聚类问题"></a> 聚类问题</h2>
<ol>
<li>数据集只有属性而<strong>没有标签</strong></li>
<li>距离度量：</li>
</ol>
<h2 id="幸存者偏差"><a class="markdownIt-Anchor" href="#幸存者偏差"></a> 幸存者偏差</h2>
<p>分析时，对于统计规律要注意幸存者偏差</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第2章python数据分析简介</title>
    <url>/2020/03/30/%E7%AC%AC2%E7%AB%A0python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="python基础"><a class="markdownIt-Anchor" href="#python基础"></a> python基础</h1>
<h2 id="列表元组相关函数"><a class="markdownIt-Anchor" href="#列表元组相关函数"></a> 列表元组相关函数</h2>
<img src="/DBB_img/1.png">
<h2 id="列表相关方法"><a class="markdownIt-Anchor" href="#列表相关方法"></a> 列表相关方法</h2>
<img src="/DBB_img/2.png">
<img src="/DBB_img/3.png">
<h2 id="字典"><a class="markdownIt-Anchor" href="#字典"></a> 字典</h2>
<ol>
<li>定义:如d = {‘today’:20,‘tomorrow’:30};或者通过dict([‘today’,20],[‘tomorrow’,30])</li>
</ol>
<h2 id="集合"><a class="markdownIt-Anchor" href="#集合"></a> 集合</h2>
<ol>
<li>定义：如s={1,2,2,3}//得到{1,2,3}</li>
<li>集合运算
<ol>
<li>| 并集</li>
<li>&amp; 交集</li>
<li>
<ul>
<li>差集//t-s在t中不在s中</li>
</ul>
</li>
<li>^ 对称差集//不同时出现在二者中</li>
</ol>
</li>
</ol>
<h2 id="函数式编程"><a class="markdownIt-Anchor" href="#函数式编程"></a> 函数式编程</h2>
<ol>
<li>
<p>map</p>
 <img src="/DBB_img/4.png">
</li>
<li>
<p>reduce</p>
 <img src="/DBB_img/5.png">
</li>
<li>
<p>filter</p>
 <img src="/DBB_img/6.png">
</li>
</ol>
<h2 id="导入库"><a class="markdownIt-Anchor" href="#导入库"></a> 导入库</h2>
<ol>
<li>from 库 import 函数/* as 别名</li>
</ol>
<h1 id="python-数据分析工具"><a class="markdownIt-Anchor" href="#python-数据分析工具"></a> Python 数据分析工具</h1>
<h2 id="numpy"><a class="markdownIt-Anchor" href="#numpy"></a> Numpy</h2>
<ol>
<li>提供多维数组</li>
</ol>
<img src="/DBB_img/7.png">
## Scipy
1. 提供了真正的矩阵，以及大量基于矩阵运算的对象和函数。
<img src="/DBB_img/8.png">
## Matplotlib
1. 主要用于二维绘图，也可以进行简单的三维绘图。
2. 如果想使用中文标签
<p><code>plt.rcParams['font.sans-serif']=['SimHei']</code></p>
<ol start="3">
<li>如果负号不能正常显示</li>
</ol>
<p><code>plt.rcParams['axes.unicode.minus']=False</code></p>
<img src="/DBB_img/9.png">
<h2 id="pandas"><a class="markdownIt-Anchor" href="#pandas"></a> Pandas</h2>
<ol>
<li>基本数据结构Series和DataFrame。Series是序列，DataFrame类似二维数组，每一列是一个Series。每个Series都带有一个对应的Index，Index可以是字母，中文，数字等</li>
</ol>
<img src="/DBB_img/10.png">
<h2 id="statsmodels"><a class="markdownIt-Anchor" href="#statsmodels"></a> StatsModels</h2>
<ol>
<li>用于数据的统计建模分析，与Pandas结合</li>
</ol>
<h2 id="scikit-learn"><a class="markdownIt-Anchor" href="#scikit-learn"></a> Scikit-Learn</h2>
<ol>
<li>完善的机器学习工具箱，包括数据预处理，分类，回归，聚类，预测和模型分析。</li>
</ol>
<img src="/DBB_img/11.png">
<h2 id="keras"><a class="markdownIt-Anchor" href="#keras"></a> Keras</h2>
<ol>
<li>Win下速度比Linux慢很多</li>
</ol>
<img src="/DBB_img/12.png">
<h2 id="gnesim"><a class="markdownIt-Anchor" href="#gnesim"></a> Gnesim</h2>
<img src="/DBB_img/13.png">
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第1章人工智能的定义及其发展</title>
    <url>/2020/06/13/%E7%AC%AC1%E7%AB%A0%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%85%B6%E5%8F%91%E5%B1%95/</url>
    <content><![CDATA[<h1 id="人工智能的定义"><a class="markdownIt-Anchor" href="#人工智能的定义"></a> 人工智能的定义</h1>
<h2 id="相关定义"><a class="markdownIt-Anchor" href="#相关定义"></a> 相关定义</h2>
<ol>
<li>智能：人类理解和学习事物的能力</li>
<li>智能机器：是一种能够呈现出人类智能行为的及其</li>
<li>人工智能：是用于研究用机器来模仿和执行人脑的某些智力功能；是智能机器所执行的通常与人类智能相关的智能行为</li>
</ol>
<h2 id="人工智能系统的分类"><a class="markdownIt-Anchor" href="#人工智能系统的分类"></a> 人工智能系统的分类</h2>
<h3 id="专家系统"><a class="markdownIt-Anchor" href="#专家系统"></a> 专家系统</h3>
<p>把专家系统技术和方法，尤其是工程控制论的反馈机制有机结合而建立的。</p>
<h3 id="模糊系统"><a class="markdownIt-Anchor" href="#模糊系统"></a> 模糊系统</h3>
<p>应用模糊集合理论的智能系统。</p>
<h3 id="神经网络系统"><a class="markdownIt-Anchor" href="#神经网络系统"></a> 神经网络系统</h3>
<p>似脑思想</p>
<h3 id="学习系统"><a class="markdownIt-Anchor" href="#学习系统"></a> 学习系统</h3>
<p>机器学习</p>
<h3 id="仿生系统"><a class="markdownIt-Anchor" href="#仿生系统"></a> 仿生系统</h3>
<p>将进化计算，特别是遗传算法机制用于人工系统和过程，则可实现一种新的智能系统，即仿生智能系统</p>
<h3 id="群智能系统"><a class="markdownIt-Anchor" href="#群智能系统"></a> 群智能系统</h3>
<p>群社会网络结构形成该群存在的一个集合，他提供了个体间交换经验只是的通信通道。</p>
<h3 id="多真体系统"><a class="markdownIt-Anchor" href="#多真体系统"></a> 多真体系统</h3>
<p>当采用多真体系统进行操作时，其操作原理随着真体结构的不同而有所差异，难以给出一个通用或统一的多真体系统结构。具有分布式系统的许多特性，如交互性，社会性，协作性，适应性和分布性等</p>
<h3 id="混合智能系统"><a class="markdownIt-Anchor" href="#混合智能系统"></a> 混合智能系统</h3>
<p>单一智能机制往往无法满足一些复杂，未知或动态系统的系统要求，就需要开发某些混合技术，取长补短。</p>
<h1 id="人工智能的研究目标和内容"><a class="markdownIt-Anchor" href="#人工智能的研究目标和内容"></a> 人工智能的研究目标和内容</h1>
<h2 id="人工智能研究的基本内容"><a class="markdownIt-Anchor" href="#人工智能研究的基本内容"></a> 人工智能研究的基本内容</h2>
<ol>
<li>认知建模</li>
<li>知识表示</li>
<li>知识推理</li>
<li>知识应用</li>
<li>机器感知</li>
<li>机器思维</li>
<li>机器学习</li>
<li>机器行为</li>
<li>智能系统构建</li>
</ol>
<h1 id="人工智能的研究与计算方法"><a class="markdownIt-Anchor" href="#人工智能的研究与计算方法"></a> 人工智能的研究与计算方法</h1>
<h2 id="人工智能的研究方法"><a class="markdownIt-Anchor" href="#人工智能的研究方法"></a> 人工智能的研究方法</h2>
<h3 id="功能模拟法"><a class="markdownIt-Anchor" href="#功能模拟法"></a> 功能模拟法</h3>
<ol>
<li>主义学派也可称为功能模拟学派。将智能活动的理论基础是物理符号<br />
系统,认知的基元是符号,认知过程是符号模式的操作处理过程。</li>
<li>功能模拟法一般采用显式知识库和推理机来处理问题,因而它能够模拟人脑的逻辑思维,便于实现人脑的高级认知功能。</li>
</ol>
<h3 id="结构模拟法"><a class="markdownIt-Anchor" href="#结构模拟法"></a> 结构模拟法</h3>
<ol>
<li>主义学派也可称为结构模拟学派。他们认为:思维的基元不是符号而是神经<br />
元,认知过程也不是符号处理过程。他们提出对人脑从结构上进行模拟,即根据人脑的生<br />
理结构和工作机理来模拟人脑的智能,属于非符号处理范畴</li>
<li>结构模拟法通过人脑神经网络、神经元之间的连接以及在神经元间的并行处理,实现对人脑智能的模拟。与功能模拟法不同,结构模拟法是基于人脑的生理模型,通过数值计算从微观上模拟人脑,实现人工智能。</li>
</ol>
<h3 id="行为模拟法"><a class="markdownIt-Anchor" href="#行为模拟法"></a> 行为模拟法</h3>
<p>行为主义学派也可称为行为模拟学派。他们认为:智能不取决于符号和神经元,而<br />
取决于感知和行动,提出智能行为的&quot;感知一动作&quot;模式。</p>
<h3 id="集成模拟法"><a class="markdownIt-Anchor" href="#集成模拟法"></a> 集成模拟法</h3>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第3章数据探索</title>
    <url>/2020/03/30/%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="数据质量分析"><a class="markdownIt-Anchor" href="#数据质量分析"></a> 数据质量分析</h1>
<p>目的是为了数据预处理做准备，为数据挖掘分析结论有效性和准确性提供基础。</p>
<ol>
<li>脏数据:不符合要求，以及不能直接进行相应分析的数据。包括：
<ol>
<li>缺失值</li>
<li>异常值</li>
<li>不一致的值</li>
<li>重复数据及含有特殊符号的数据</li>
</ol>
</li>
</ol>
<h2 id="缺失值分析"><a class="markdownIt-Anchor" href="#缺失值分析"></a> 缺失值分析</h2>
<p>指某个记录的缺失和记录中某个字段信息的缺失。</p>
<h3 id="产生原因"><a class="markdownIt-Anchor" href="#产生原因"></a> 产生原因</h3>
<ol>
<li>某些信息暂时无法获取</li>
<li>有些信息被遗漏</li>
<li>属性值不存在</li>
</ol>
<h3 id="影响"><a class="markdownIt-Anchor" href="#影响"></a> 影响</h3>
<ol>
<li>数据挖掘建模将丢失大量有效信息</li>
<li>挖掘的不确定性更加显著</li>
<li>包含空值的数据会使建模过程陷入混乱，导致不可靠的输出。</li>
</ol>
<h3 id="缺失值分析-2"><a class="markdownIt-Anchor" href="#缺失值分析-2"></a> 缺失值分析</h3>
<ol>
<li>使用统计分析可以得到缺失值的属性的个数，以及每个属性的未缺失数，缺失数和缺失率。</li>
</ol>
<h3 id="缺失值处理"><a class="markdownIt-Anchor" href="#缺失值处理"></a> 缺失值处理</h3>
<ol>
<li>对可能值进行插补和不处理等，见第四章</li>
</ol>
<h2 id="异常值分析"><a class="markdownIt-Anchor" href="#异常值分析"></a> 异常值分析</h2>
<ol>
<li>异常值指样本中的个别值，其数值明显偏离其余的观测值。</li>
<li>异常值分析：用于检验数据是否有录入错误以及不合常理的数据。</li>
</ol>
<h3 id="简单统计量分析"><a class="markdownIt-Anchor" href="#简单统计量分析"></a> 简单统计量分析</h3>
<p>先对变量做一个描述性统计，进而查看哪些数据是不合理的。如给数据设置最大值和最小值。</p>
<h3 id="3σ原则"><a class="markdownIt-Anchor" href="#3σ原则"></a> 3σ原则</h3>
<p><strong>如果数据符合正态分布</strong>，在3σ原则下，异常值被定义为一组测定值中与平均值的偏差超过3倍标准差的值。(即使不服从正态分布，也可以用原理平均值的多少倍标准差来描述)</p>
<h3 id="箱型图分析"><a class="markdownIt-Anchor" href="#箱型图分析"></a> 箱型图分析</h3>
<p><img src="/DBB_img/14.png" alt="" /></p>
<ol>
<li>
<p>异常值通常被定义为小于Q<sub>L</sub>-1.5IQR或大于Q<sub>U</sub>+1.5IQR。</p>
</li>
<li>
<p>Q<sub>L</sub>称为下四分位数，表示全部观察值中只有四分之一的数据取值比它小</p>
</li>
<li>
<p>Q<sub>U</sub>称为上四分位数，表示全部观察值中有四分之一的数据取值比他大</p>
</li>
<li>
<p>IQR 为四分位数间距。IQR=Q<sub>U</sub>-Q<sub>L</sub>，其间包含了全部观察值的一半。</p>
</li>
<li>
<p>优点：</p>
<ol>
<li>不对数据的分布形式有要求</li>
<li>判断异常值的标准时以四分位数和四分位距为标准，具有一定的鲁棒性。(25%以上的异常值才可能对四分位数产生较大的扰动)</li>
<li>箱型图识别异常值的结果比较客观。</li>
</ol>
</li>
<li>
<p>使用</p>
<p><img src="/DBB_img/15.png" alt="" /></p>
</li>
<li>
<p>异常值检测</p>
<p><img src="/DBB_img/16.png" alt="" /></p>
</li>
</ol>
<h2 id="一致性分析"><a class="markdownIt-Anchor" href="#一致性分析"></a> 一致性分析</h2>
<h3 id="数据不一致"><a class="markdownIt-Anchor" href="#数据不一致"></a> 数据不一致</h3>
<p>是指数据的矛盾性。</p>
<h3 id="原因"><a class="markdownIt-Anchor" href="#原因"></a> 原因</h3>
<ol>
<li>不一致性的产生主要发生在数据集成的过程中，可能是因为数据来自于不同的数据源</li>
<li>对重复存放的数据未能进行一致性更新造成的。(两张表中的同一个数据只改了一个)</li>
</ol>
<h1 id="数据特征分析"><a class="markdownIt-Anchor" href="#数据特征分析"></a> 数据特征分析</h1>
<h2 id="分布分析"><a class="markdownIt-Anchor" href="#分布分析"></a> 分布分析</h2>
<p>目的是揭示数据的分布特征和分布类型</p>
<h3 id="定量数据的分布分析"><a class="markdownIt-Anchor" href="#定量数据的分布分析"></a> 定量数据的分布分析</h3>
<ol>
<li>
<p>想要了解分布形式是否对称，是否存在某些特大或特小的可疑值。可绘制<strong>频率表格</strong>，绘制<strong>频率直方图</strong>，绘制<strong>茎叶图</strong>来分析</p>
</li>
<li>
<p>主要问题： 选择组数和组宽</p>
</li>
<li>
<p>步骤</p>
<ol>
<li>求极差</li>
<li>决定组数和组距</li>
<li>决定分点</li>
<li>列出频率分布表</li>
<li>绘制频率分布直方图(纵轴频率密度)</li>
</ol>
</li>
<li>
<p>原则</p>
<ol>
<li>各组间必须相互排斥</li>
<li>各组必须将所有的数据包含在内</li>
<li>各组的组宽最好相等</li>
</ol>
</li>
</ol>
<h3 id="定性数据的分布分析"><a class="markdownIt-Anchor" href="#定性数据的分布分析"></a> 定性数据的分布分析</h3>
<ol>
<li>根据变量的分类类型来分组，使用饼图和条形图来描述分布。</li>
<li>条形图的高度和饼图的面积用来代表每一类型的百分比或频数。</li>
</ol>
<h3 id="对比分析"><a class="markdownIt-Anchor" href="#对比分析"></a> 对比分析</h3>
<ol>
<li>对比分析：指把两个相互联系的指标进行比较，从数量上展示和说明研究对象规模的大小，水平的高低，速度的快慢，以及各种关系是否协调。</li>
<li>关键在于选择对比标准</li>
<li>主要包括<strong>绝对数比较</strong>，<strong>相对数比较</strong></li>
<li>相对数标胶：通过两个有联系的指标对比计算，用以反应客观现象间数量的联系程度的综合指标。相对数包括
<ol>
<li>结构相对数：同一总体内的部分数值与全部数值的比重。</li>
<li>比例相对数：同一总体中，不同部分的数值的对比，表明总体中各部分的比例关系</li>
<li>比较相对数：将同一时期的两个性质相同的指标数值进行对比，说明同类现象在不同的空间条件下的数量对比关系。</li>
<li>强度相对数：将两个性质不同但有一定联系的总量指标进行对比，用以说明现象的强度、密度和普通程度。</li>
<li>计划完成程度相对数：对某一时期实际完成数与计划数对比，用以说明计划完成程度。</li>
<li>动态对比数：同一现象在不同时期的指标数值进行对比，用以说明发展方向和变化的速度。</li>
</ol>
</li>
</ol>
<h3 id="统计量分析"><a class="markdownIt-Anchor" href="#统计量分析"></a> 统计量分析</h3>
<ol>
<li>
<p>集中趋势度量</p>
<ol>
<li>均值(加权均值)</li>
<li>频率分布表的加权平均数<br />
<img src="/DBB_img/17.png" alt="" /></li>
<li>中位数：先排序</li>
<li>众数</li>
</ol>
</li>
<li>
<p>离中趋势度量</p>
<ol>
<li>
<p>极差:对极端值非常敏感</p>
</li>
<li>
<p>标准差</p>
<p><img src="/DBB_img/18.png" alt="" /></p>
</li>
<li>
<p>变异稀疏：度量标准差相对于均值的离中趋势</p>
<p><img src="/DBB_img/19.png" alt="" /></p>
</li>
<li>
<p>四分位数间距：需要排序。间距越大说明数据的变异程度越大。</p>
</li>
</ol>
<p><img src="/DBB_img/20.png" alt="" /></p>
</li>
</ol>
<h3 id="周期性分析"><a class="markdownIt-Anchor" href="#周期性分析"></a> 周期性分析</h3>
<ol>
<li>周期性分析:探索某个变量是否随着时间变化呈现出某种周期变化趋势。</li>
</ol>
<h3 id="贡献度分析帕累托分析"><a class="markdownIt-Anchor" href="#贡献度分析帕累托分析"></a> 贡献度分析(帕累托分析)</h3>
<h3 id="相关性分析"><a class="markdownIt-Anchor" href="#相关性分析"></a> 相关性分析</h3>
<ol>
<li>
<p>用于分析连续变量之间线性相关程度的强弱，并用适当的统计指标表示。表示方法包括</p>
</li>
<li>
<p>直接绘制散点图</p>
</li>
<li>
<p>绘制散点图矩阵</p>
</li>
<li>
<p>计算相关系数</p>
<ol>
<li>
<p>Pearson相关系数：要求连续变量的取值服从正态分布</p>
<p><img src="/DBB_img/22.png" alt="" /></p>
</li>
<li>
<p>Spearman秩相关系数</p>
<p><img src="/DBB_img/23.png" alt="" /></p>
<p><img src="/DBB_img/24.png" alt="" /></p>
<ol>
<li>只要两个变量具有严格单调函数关系，那么他们就是完全Sperman相关的。</li>
</ol>
</li>
<li>
<p>判断系数：相关系数的平方；用以衡量回归方程对y的解释程度。</p>
</li>
</ol>
<p><img src="/DBB_img/25.png" alt="" /></p>
</li>
</ol>
<h1 id="主要数据探索函数"><a class="markdownIt-Anchor" href="#主要数据探索函数"></a> 主要数据探索函数</h1>
<h2 id="基本统计特征函数"><a class="markdownIt-Anchor" href="#基本统计特征函数"></a> 基本统计特征函数</h2>
<p><img src="/DBB_img/26.png" alt="" /></p>
<ol>
<li>
<p>D.corr(method=‘pearson’)，样本D可为DataFrame，返回相关系数矩阵，method参数为计算方法，支持pearson，kendall，spearman系数</p>
</li>
<li>
<p>S1.(S2,method=‘pearman’)，求S1和S2之间的相关系数。</p>
<p><img src="/DBB_img/27.png" alt="" /></p>
</li>
<li>
<p>cov()返回协方差矩阵</p>
<ol>
<li>样本D可为DataFrame</li>
<li>可用S1.cov(S2)计算两个Series之间的协方差</li>
</ol>
</li>
<li>
<p>skew/kurt</p>
<ol>
<li>计算数据样本的偏度(三阶矩)/峰度(四阶矩)</li>
</ol>
</li>
<li>
<p>describe</p>
<ol>
<li>返回一些基本统计量</li>
</ol>
</li>
</ol>
<h2 id="拓展统计特征函数"><a class="markdownIt-Anchor" href="#拓展统计特征函数"></a> 拓展统计特征函数</h2>
<p><img src="/DBB_img/28.png" alt="" /></p>
<p><img src="/DBB_img/29.png" alt="" /></p>
<ol>
<li>DataFrame或Series的对象D；D.cumsum()</li>
<li>pd.rolling_mean(D,k)每k列计算一次均值，滚动计算。</li>
</ol>
<p><img src="/DBB_img/30.png" alt="" /></p>
<h2 id="统计作图函数"><a class="markdownIt-Anchor" href="#统计作图函数"></a> 统计作图函数</h2>
<p><img src="/DBB_img/31.png" alt="" /></p>
<h3 id="plot"><a class="markdownIt-Anchor" href="#plot"></a> plot</h3>
<ol>
<li>plt.plot(x,y,S)</li>
<li>S为格式设置</li>
<li>D.plot(kind=‘xxx’)指定作图类型</li>
</ol>
<h3 id="pie"><a class="markdownIt-Anchor" href="#pie"></a> pie</h3>
<ol>
<li>plt.pie(size)绘制饼状图</li>
</ol>
<p><img src="/DBB_img/32.png" alt="" /></p>
<h3 id="hist"><a class="markdownIt-Anchor" href="#hist"></a> hist</h3>
<ol>
<li>绘制二维条形直方图</li>
</ol>
<p><img src="/DBB_img/33.png" alt="" /></p>
<h3 id="boxplot"><a class="markdownIt-Anchor" href="#boxplot"></a> boxplot</h3>
<ol>
<li>绘制箱式图</li>
</ol>
<p><img src="/DBB_img/34.png" alt="" /></p>
<h3 id="plotlogxtrueplotlogytrue"><a class="markdownIt-Anchor" href="#plotlogxtrueplotlogytrue"></a> plot(logx=True)/plot(logy=True)</h3>
<ol>
<li>绘制x或y轴的对数图形</li>
</ol>
<p><img src="/DBB_img/35.png" alt="" /></p>
<h3 id="plotyerrerror"><a class="markdownIt-Anchor" href="#plotyerrerror"></a> plot(yerr=error)</h3>
<ol>
<li>绘制误差条形图</li>
</ol>
<p><img src="/DBB_img/36.png" alt="" /></p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第1章数据挖掘基础</title>
    <url>/2020/03/30/%E7%AC%AC1%E7%AB%A0%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="数据挖掘基本概念"><a class="markdownIt-Anchor" href="#数据挖掘基本概念"></a> 数据挖掘基本概念</h1>
<ol>
<li>数据挖掘：从大量数据中挖掘处隐含的，未知的，对决策有潜在价值的关系，模式和趋势，并用这些知识和规则建立用于决策支持的模型。</li>
<li>基本任务：包括利用分类与预测，聚类分析，关联规则，时序模式，偏差检测，智能推荐等方法，提取数据中的价值。</li>
</ol>
<h1 id="数据挖掘建模过程"><a class="markdownIt-Anchor" href="#数据挖掘建模过程"></a> 数据挖掘建模过程</h1>
<h2 id="定义挖掘目标"><a class="markdownIt-Anchor" href="#定义挖掘目标"></a> 定义挖掘目标</h2>
<ol>
<li>即明确系统完成后达到什么样的效果。</li>
<li>需要分析应用领域，包括应用中的各种知识和应用目标。</li>
</ol>
<h2 id="数据取样"><a class="markdownIt-Anchor" href="#数据取样"></a> 数据取样</h2>
<ol>
<li>抽取标准：相关性；可靠性；有效性。</li>
<li>一定要保证数据的质量，衡量数据质量的标准
<ol>
<li>资料完整无缺，各类指标项齐全</li>
<li>数据准确无误，反应的都是正常状态下的水平</li>
</ol>
</li>
</ol>
<h3 id="常见抽样方式"><a class="markdownIt-Anchor" href="#常见抽样方式"></a> 常见抽样方式</h3>
<ol>
<li>随机抽样：使数据集中的每一组观测值都有相同的被抽样的概率</li>
<li>等距抽样</li>
<li>分层抽样：先将数据分成若干层次，在每个层次中的观测值都具有相同的被选用的概率，但对不同层次可设定不同概率</li>
<li>从起始顺序抽样</li>
<li>分类抽样：依据某种属性的具体取值来选择数据子集，如按客户名称分类。</li>
</ol>
<h2 id="数据搜素"><a class="markdownIt-Anchor" href="#数据搜素"></a> 数据搜素</h2>
<p>目的是对所抽取的样本数据进行搜素，审核和必要的加工处理，以保证最终的挖掘模型的质量所必须的。</p>
<h2 id="数据预处理"><a class="markdownIt-Anchor" href="#数据预处理"></a> 数据预处理</h2>
<ol>
<li>目的是减少噪声和不一致，不完整的数据。</li>
<li>主要包括：数据筛选；数据变量转换，缺失值处理，坏数据处理，数据标准化，主成分分析，属性选择，数据规约等</li>
</ol>
<h2 id="挖掘建模"><a class="markdownIt-Anchor" href="#挖掘建模"></a> 挖掘建模</h2>
<ol>
<li>首先分析本次建模属于哪类问题（分类与预测，聚类，关联规则，时序模式或者智能推荐）</li>
</ol>
<h2 id="模型评价"><a class="markdownIt-Anchor" href="#模型评价"></a> 模型评价</h2>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第3章数据探索kt</title>
    <url>/2020/03/30/%E7%AC%AC3%E7%AB%A0%E6%95%B0%E6%8D%AE%E6%8E%A2%E7%B4%A2kt/</url>
    <content><![CDATA[<h1 id="数据探索"><a class="markdownIt-Anchor" href="#数据探索"></a> 数据探索</h1>
<h2 id="目的"><a class="markdownIt-Anchor" href="#目的"></a> 目的</h2>
<ul>
<li>帮助人们选择合适的工具</li>
<li>通过观察识别出一些模式</li>
</ul>
<h2 id="工具"><a class="markdownIt-Anchor" href="#工具"></a> 工具</h2>
<ul>
<li>分析统计量</li>
<li>可视化</li>
<li>在线分析处理 OLAP</li>
</ul>
<h1 id="汇总统计"><a class="markdownIt-Anchor" href="#汇总统计"></a> 汇总统计</h1>
<p>用量化的方法捕捉值集合的特征</p>
<h2 id="频率和众数"><a class="markdownIt-Anchor" href="#频率和众数"></a> 频率和众数</h2>
<ol>
<li>用于<strong>无序的，分类的值</strong>集合</li>
<li>对于连续数据，众数<strong>通常</strong>没用；但是可能提供关于值的性质或者关于出现遗漏值的重要信息。如果使用唯一的值表示遗漏值,则该值常常表现为众数。</li>
</ol>
<h3 id="百分位数"><a class="markdownIt-Anchor" href="#百分位数"></a> 百分位数</h3>
<ol>
<li>对于<strong>有序/连续</strong>数据，考虑值集的百分位数。</li>
<li><strong>百分位数</strong> 给定一个有序的或连续的属性x和0与100之间的数p,第p个百分位数Xp是一个x值。使碍x的p%观测值小于Xp.</li>
</ol>
<h2 id="位置度量均值和中位数"><a class="markdownIt-Anchor" href="#位置度量均值和中位数"></a> 位置度量：均值和中位数</h2>
<ol>
<li>
<p>对于<strong>连续数据</strong>，广泛应用均值和中位数</p>
<img src="/MyImages/image-20200427172126395.png" style="zoom:33%;" />
</li>
<li>
<p>均值<strong>对于离群点很敏感</strong>；对于包含离群点的数据，中位数可以更稳健的提供值集合中间的估计</p>
</li>
</ol>
<h3 id="截断均值"><a class="markdownIt-Anchor" href="#截断均值"></a> 截断均值</h3>
<p>指定0和100之间的百分位数p.丢<strong>弃高端和低端(p/2)%数据</strong>,然后用常规的方法计算均值.所得的结果即是<strong>截断均值</strong>。中位数是p=100%的截断均值,而标准均值是对应于p=0%截断均值。</p>
<h2 id="散布度量极差和方差"><a class="markdownIt-Anchor" href="#散布度量极差和方差"></a> 散布度量：极差和方差</h2>
<p>连续数据的另一组常用的汇总统计是值集的弥的或散布度量。<strong>这种度量表明属性值是否散布很宽,或者是否相对集中在单个点（如均值)附近。</strong></p>
<h3 id="极差"><a class="markdownIt-Anchor" href="#极差"></a> 极差</h3>
<ol>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>e</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>−</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">range(x) = max(x) - min(x)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span></p>
</li>
<li>极差对离群点敏感</li>
</ol>
<h3 id="方差"><a class="markdownIt-Anchor" href="#方差"></a> 方差</h3>
<img src="C:\Users\崔恩博\Desktop\数据挖掘\KDD_img\14.png" style="zoom:33%;" />
<ol>
<li>因为均值可能被离群点扭曲，并且由于方差用均值计算，因此<strong>它也对离群点敏感</strong>。</li>
</ol>
<h3 id="其他三种度量定义"><a class="markdownIt-Anchor" href="#其他三种度量定义"></a> 其他三种度量定义</h3>
<p>力图减少离群点的影响</p>
<img src="/MyImages/image-20200427172603696.png" style="zoom:50%;" />
<ol>
<li>AAD 绝对平均偏差</li>
<li>MAD 中位数绝对偏差</li>
<li>IQR 四分位数极差</li>
</ol>
<h2 id="多元汇总统计"><a class="markdownIt-Anchor" href="#多元汇总统计"></a> 多元汇总统计</h2>
<ol>
<li>如果每个属性的散布可以独立于其他属性，可用上一小节的方法计算</li>
<li>对于具有连续变量的数据，数据的分布更多的用<strong>协方差矩阵</strong>表示。</li>
</ol>
<h3 id="协方差矩阵-s"><a class="markdownIt-Anchor" href="#协方差矩阵-s"></a> 协方差矩阵 S</h3>
<ol>
<li>
<p>其中S的第ij个元素Sij表示第i个属性和第j个属性的协方差。</p>
<img src="C:\Users\崔恩博\Desktop\数据挖掘\KDD_img\17.png" style="zoom:67%;" />
</li>
<li>
<p>属性的协方差是两个属性<strong>一起变化</strong>并<strong>依赖于变量大小</strong>的度量.协方差的值<strong>接近于0表明 两个变量不具有（线性)关系</strong>,但是不能仅靠观察协方差的值来确定两个变量之间的关联程度</p>
</li>
</ol>
<h3 id="相关矩阵-r"><a class="markdownIt-Anchor" href="#相关矩阵-r"></a> 相关矩阵 R</h3>
<ol>
<li>
<p>R的第ij个元素是数据的第i个和第j个属性之间的相关性。</p>
<img src="C:\Users\崔恩博\Desktop\数据挖掘\KDD_img\18.png" style="zoom: 67%;" />
<ol>
<li>Si，Sj分别是xi和xj的方差。R的对角线上的元素是correlation(,t)=1,而其他元素在-1和1之间</li>
</ol>
</li>
</ol>
<h2 id="汇总数据的其他方法"><a class="markdownIt-Anchor" href="#汇总数据的其他方法"></a> 汇总数据的其他方法</h2>
<ol>
<li>值集的倾斜度（skewness）)度量值对称地分布在均值附近的程度.</li>
<li>另外还有一些其他数据特征,很难定量地度量,例如,值的分布是否是多模态的（mulimodal),即数据具有多个&quot;肿块&quot;,大部分值集中在那里,</li>
<li>然而,在许多情况下,理解关于属性值如何分布的更复杂、更微妙的方面,最有效的方法是通过直方图观察这些值。</li>
</ol>
<h1 id="可视化"><a class="markdownIt-Anchor" href="#可视化"></a> 可视化</h1>
<h2 id="可视化的动机"><a class="markdownIt-Anchor" href="#可视化的动机"></a> 可视化的动机</h2>
<ol>
<li>动机是人们能够快速吸取大量可视化信息,并发现其中的模式</li>
<li>另一个动机是利用&quot;镇在人脑袋中&quot;的领域知识。</li>
</ol>
<h2 id="一般概念"><a class="markdownIt-Anchor" href="#一般概念"></a> 一般概念</h2>
<h3 id="表示讲数据映射到图形元素"><a class="markdownIt-Anchor" href="#表示讲数据映射到图形元素"></a> 表示：讲数据映射到图形元素</h3>
<ol>
<li>对象通常用三类方法表示
<ol>
<li>如果只考虑对象的单个分类属性，则通常根据该属性的值将兑现聚类，并把这些类作为表的项或屏幕的区域显示</li>
<li>如果对象具有多个属性，则可以将对象显示为表的一行或显示为图的一条线</li>
<li>对象常常解释为二维或三维空间中的点</li>
</ol>
</li>
<li><strong>对于序数和连续的属性，可以映射成连续的，有序的图形特征</strong></li>
<li><strong>对于分类属性，每个类别可以映射到不同的列</strong></li>
<li><strong>对于标称数据，由于值是无序的，要特别小心</strong></li>
<li>通常将对象和属性映射到图形元素，隐含的将数据中的联系映射到图形对象之间的联系</li>
</ol>
<h3 id="安排"><a class="markdownIt-Anchor" href="#安排"></a> 安排</h3>
<p>项的排列十分重要</p>
<p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%5CKDD_img%5C19.png" alt="" /></p>
<h3 id="选择"><a class="markdownIt-Anchor" href="#选择"></a> 选择</h3>
<p>删除或不突出某些对象和属性</p>
<h2 id="少量属性的可视化"><a class="markdownIt-Anchor" href="#少量属性的可视化"></a> 少量属性的可视化</h2>
<h3 id="茎叶图"><a class="markdownIt-Anchor" href="#茎叶图"></a> <strong>茎叶图</strong></h3>
<ol>
<li>
<p>可以用来观测一维整型或连续数据的分布。</p>
</li>
<li>
<p>对于简单的一类茎叶图，将值分组，其中每组包含的值除最后一位外相同。每一组是茎，而组中最后一位数字是叶。垂直画茎，水平画叶可得茎叶图</p>
   <img src="C:\Users\崔恩博\Desktop\数据挖掘\KDD_img\20.png" style="zoom: 67%;" />
</li>
</ol>
<h3 id="直方图"><a class="markdownIt-Anchor" href="#直方图"></a> 直方图</h3>
<ol>
<li>该图通过将可能的值分散到箱中,并<strong>显示落入每个箱中的对象数</strong>,显示<strong>属性值的分布</strong>。用于显示单个变量值的分布</li>
<li>如果值过多，则进行合并</li>
<li>如果是连续属性，则将值域划分成箱。</li>
</ol>
<h3 id="二维直方图"><a class="markdownIt-Anchor" href="#二维直方图"></a> <strong>二维直方图</strong></h3>
<p>将每个属性划分成区间，而两个区间定义值的二维长方体</p>
<img src="/MyImages/image-20200427174320687.png" alt="image-20200427174320687" style="zoom: 33%;" />
<h3 id="盒装图"><a class="markdownIt-Anchor" href="#盒装图"></a> <strong>盒装图</strong></h3>
<p>是另一种一维数值属性值分布的方法。<br />
<img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%5CKDD_img%5C21.png" alt="" /></p>
<ul>
<li>用途
<ul>
<li>用于比较不同的属性</li>
<li>用于判断离群点</li>
</ul>
</li>
</ul>
<h3 id="饼状图"><a class="markdownIt-Anchor" href="#饼状图"></a> <strong>饼状图</strong></h3>
<ol>
<li>通常用于具有相对较少的值的分类属性。</li>
</ol>
<h3 id="百分位数图盒经验积累分布函数"><a class="markdownIt-Anchor" href="#百分位数图盒经验积累分布函数"></a> <strong>百分位数图盒经验积累分布函数</strong></h3>
<p>对于统计分布的每个值,<strong>一个累计分布函数显示点小于该值的概率</strong>。对于每个观测值,一个经验累计分布函数显示小于该值的点的百分比。由于点的个数是有限的**,经验累计分布函数是一个阶梯函数。**</p>
<h3 id="散点图"><a class="markdownIt-Anchor" href="#散点图"></a> <strong>散点图</strong></h3>
<p>图中使用数据对象的两个属性作为x和y的值。其主要用途有</p>
<ol>
<li>图形化的显示两个属性之间的关系</li>
<li>可以用散点图考察两个属性将类分开的程度</li>
</ol>
<h2 id="可视化时间空间数据"><a class="markdownIt-Anchor" href="#可视化时间空间数据"></a> 可视化时间空间数据</h2>
<h3 id="等高线图"><a class="markdownIt-Anchor" href="#等高线图"></a> <strong>等高线图</strong></h3>
<ul>
<li>等高线图将平面划分成一些区域,区城中的第三个属性（温度或海拔高度）的值粗略地相等。等高线图的常见例子是显示地面位置海拔高度的等高线图</li>
<li>在空间网格上测量连续属性时非常有用</li>
</ul>
<h3 id="曲面图"><a class="markdownIt-Anchor" href="#曲面图"></a> <strong>曲面图</strong></h3>
<p>曲面图中第三个属性用来指示高出前两个属性定义的平面的高度</p>
<h3 id="矢量场图"><a class="markdownIt-Anchor" href="#矢量场图"></a> <strong>矢量场图</strong></h3>
<p>适用于同时需要指示方向和大小的图</p>
<h3 id="低维切片"><a class="markdownIt-Anchor" href="#低维切片"></a> <strong>低维切片</strong></h3>
<p>比如每个月份单独成图，降低维度</p>
<h2 id="可视化高维数据"><a class="markdownIt-Anchor" href="#可视化高维数据"></a> 可视化高维数据</h2>
<h3 id="矩阵"><a class="markdownIt-Anchor" href="#矩阵"></a> 矩阵</h3>
<ol>
<li><strong>如果类标号已知</strong>，则重新排列数据矩阵的次序，使得某个类的所有对象聚在一起。这样可以很容易的检查某个类的所有对象是否在某些属性熵具有相似的属性值。</li>
<li>矩阵中，由于不同属性可能具有不同的值域，<strong>则可以对属性标准化</strong></li>
</ol>
<h3 id="平行坐标系"><a class="markdownIt-Anchor" href="#平行坐标系"></a> 平行坐标系</h3>
<ol>
<li>
<p><strong>每个属性</strong>对应一个坐标轴，但是坐标轴是平行的。</p>
</li>
<li>
<p><strong>每个对象</strong>用线而不是点来表示</p>
</li>
<li>
<p>对于数据对象不太多的情况，平行坐标图可以揭示有意义的模式。</p>
</li>
<li>
<p>对于这种图，属性的顺序非常重要</p>
</li>
<li>
<p>举例</p>
<p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%5CKDD_img%5C24.png" alt="" /></p>
</li>
<li>
<p>缺点：<strong>在这种图中模式的检测可能取决于坐标轴的序。如果线交叉太多，则图形可能变得模糊不清</strong></p>
</li>
</ol>
<h3 id="星形坐标和chemoff脸"><a class="markdownIt-Anchor" href="#星形坐标和chemoff脸"></a> 星形坐标和chemoff脸</h3>
<ol>
<li>
<p><strong>星形坐标</strong>：对于高维数据，将对象的每个属性映射到图示符的一个特征，使得属性的值决定特征的准确性质。</p>
</li>
<li>
<p>举例</p>
<p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%5CKDD_img%5C25.png" alt="" /></p>
<ol>
<li>每个属性对应一个坐标轴，每个对象构成一个多边形</li>
</ol>
</li>
</ol>
<h1 id="olap和多维数据分析"><a class="markdownIt-Anchor" href="#olap和多维数据分析"></a> OLAP和多维数据分析</h1>
<h2 id="多维数据一般情况"><a class="markdownIt-Anchor" href="#多维数据一般情况"></a> 多维数据：一般情况</h2>
<ol>
<li>多维数据分析的关键目标是观察聚集量，如总和或平均值</li>
</ol>
<h3 id="多维数组表示数据两步骤"><a class="markdownIt-Anchor" href="#多维数组表示数据两步骤"></a> 多维数组表示数据两步骤</h3>
<ol>
<li>维的识别：一个对象对应于多维数组的一个单元。首先要确定哪些属性是维度，哪些属性是目标属性。
<ol>
<li>用作维度的属性必须是离散值</li>
<li>目标属性通常是计数值或离散值</li>
</ol>
</li>
<li>分析所关注的属性的识别：每个单元内容单表一个关心的目标量</li>
</ol>
<h2 id="分析多维数据"><a class="markdownIt-Anchor" href="#分析多维数据"></a> 分析多维数据</h2>
<h3 id="数据立方体计算聚集量"><a class="markdownIt-Anchor" href="#数据立方体计算聚集量"></a> 数据立方体：计算聚集量</h3>
<ol>
<li>数据的多维表示，连同所有可能的总和(聚集)称作<strong>数据立方体</strong></li>
<li>每个维的大小(属性的个数)不必相等</li>
<li>数据立方体可能多于或少于三个维</li>
<li>对于所有可能的聚合，我们指的是通过选择维度的一个适当子集并对所有剩余维度求和而得到的聚合</li>
</ol>
<h3 id="维归约和转轴"><a class="markdownIt-Anchor" href="#维归约和转轴"></a> 维归约和转轴</h3>
<ol>
<li>
<p><strong>转轴</strong> 是指在除两个维之外的所有维上的聚集。结果是一个二维交叉表，只有两个指定的维作为留下的维</p>
<p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%5CKDD_img%5C26.png" alt="" /></p>
<p>这是一个在日期和产品上转轴的例子</p>
</li>
</ol>
<h3 id="切片和切块"><a class="markdownIt-Anchor" href="#切片和切块"></a> 切片和切块</h3>
<ol>
<li><strong>切片</strong>：通过对一个或多个维指定特定的值，从整个多维数组中选择一组单元</li>
<li><strong>切块</strong>：通过指定属性值范围选择单元子集，等价于由整个数组定义子数组</li>
</ol>
<h3 id="上卷和下钻"><a class="markdownIt-Anchor" href="#上卷和下钻"></a> 上卷和下钻</h3>
<ol>
<li>针对具有层次结构的属性</li>
<li>对于每天的销售数据，可以按月统计，<strong>称为上卷</strong>，反过来，给定时间划分成月份的数据表示，称为下钻</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第5章不确定性推理</title>
    <url>/2020/06/13/%E7%AC%AC5%E7%AB%A0%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E6%8E%A8%E7%90%86/</url>
    <content><![CDATA[<h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1>
<h2 id="不确定性推理"><a class="markdownIt-Anchor" href="#不确定性推理"></a> 不确定性推理</h2>
<ol>
<li>是对不确定性知识的运用和处理</li>
<li>从不确定性的初始证据出发，运用不确定性的知识，最终推出具有一定程度不确定性的结论</li>
</ol>
<h2 id="不确定性推理中的基本问题"><a class="markdownIt-Anchor" href="#不确定性推理中的基本问题"></a> 不确定性推理中的基本问题</h2>
<ol>
<li>
<p>不确定性的表示</p>
</li>
<li>
<p>不确定性的匹配</p>
</li>
<li>
<p>组合证据的不确定性的计算</p>
<ul>
<li>
<p>最大最小法：T(E1 AND E2)=min{T(E1),T(E2)}<br />
T(E1 OR E2)=max{T(E1),T(E2)}</p>
</li>
<li>
<p>概率法：</p>
<p>T(E1 AND E2)=T(E1)×T(E2)<br />
T(E1 OR E2)=T(E1)＋T(E2)－T(E1)×T(E2)</p>
</li>
<li>
<p>有界法</p>
<p>T(E1 AND E2)=max{0,T(E1)＋T(E2)－1}<br />
T(E1 OR E2)=min{1,T(E1)＋T(E2)}</p>
<p>其中T(E)表示证据E为真的程度</p>
</li>
</ul>
</li>
<li>
<p>不确定性的更新(计算结论的不确定性)</p>
</li>
<li>
<p>结论不确定性的合成</p>
</li>
</ol>
<h2 id="不确定性推理方法的分类"><a class="markdownIt-Anchor" href="#不确定性推理方法的分类"></a> 不确定性推理方法的分类</h2>
<img src="/MyImages/1.png" style="zoom: 50%;" />
<h1 id="概率推理"><a class="markdownIt-Anchor" href="#概率推理"></a> 概率推理</h1>
<h2 id="概率论基础"><a class="markdownIt-Anchor" href="#概率论基础"></a> 概率论基础</h2>
<h3 id="样本"><a class="markdownIt-Anchor" href="#样本"></a> 样本</h3>
<ol>
<li>样本空间：在概率论中，把试验中每一个可能出现的结果称为试验的一个样本点，由全体样本点构成的集合称为样本空间。通常，用D表示样本空间。</li>
<li>随机事件：由样本点构成的集合称为随机事件。</li>
<li>运算：
<ul>
<li>
<p>并事件：事件A与事件B至少有一个发生  记为A∪B</p>
</li>
<li>
<p>交事件：事件A与事件B同时发生 记为A∩B</p>
</li>
<li>
<p>互逆事件：事件A与B之间满足A∩B=Φ, A∪B=D</p>
</li>
</ul>
</li>
<li>统计概率：在同一组条件下所进行大量重复试验时，如果事件A出现的频率总是在区间[0,1]上的一个确定常数p附近摆动，并且稳定于p，则称p为事件A的统计概率，记为P(A)。</li>
<li>条件概率：设A与B是两个随机事件，P(B)&gt;0，则称：<br />
P(A|B)=P(A∩B)/P(B)<br />
为在事件B发生的条件下事件A 的条件概率 。</li>
</ol>
<h3 id="全概率公式"><a class="markdownIt-Anchor" href="#全概率公式"></a> 全概率公式</h3>
<p>任意两个事件都互不相容，即当i≠j时，有</p>
<ul>
<li>Ai∩Aj=Φ</li>
<li>P(Ai)&gt;0 (i=1, 2, … ,n);</li>
<li>D = $$U_{i=1}^nA_i$$</li>
</ul>
<p>则对任何时间B：$$P(B)=\sum _{i=1}^nP(A_i)×P(B|A_i)$$</p>
<h3 id="贝叶斯公式"><a class="markdownIt-Anchor" href="#贝叶斯公式"></a> 贝叶斯公式</h3>
<p>设事件A1, A2,…, An满足全概率公式的条件，则对任何事件B有下式成立：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mi mathvariant="normal">∣</mi><msub><mi>A</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mfrac><mspace linebreak="newline"></mspace><mo>=</mo><mfrac><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mi mathvariant="normal">∣</mi><msub><mi>A</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mrow><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>P</mi><mo stretchy="false">(</mo><mi>B</mi><mi mathvariant="normal">∣</mi><msub><mi>A</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>A</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">P(A_i|B) = \frac {P(B|A_i)P(A_i)}{P(B)}\\
=\frac {P(B|A_i)P(A_i)}{\sum _{j=1}^nP(B|A_j)P(A_j)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.55711em;vertical-align:-1.1301100000000002em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.305708em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1301100000000002em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<ol>
<li>
<p>举例</p>
<p><img src="/MyImages/2.png" alt="" /></p>
</li>
</ol>
<h2 id="概率推理方法"><a class="markdownIt-Anchor" href="#概率推理方法"></a> 概率推理方法</h2>
<ol>
<li>用P(H|E)来衡量证据E的出现对结论H的确定性程度，即规则的静态强度。</li>
</ol>
<h3 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想"></a> 基本思想</h3>
<ol>
<li>
<p>已知前提E的概率P(E)和结论H的先验概率P(H)</p>
<p>已知H成立时E出现的条件概率P(E|H)</p>
</li>
<li>
<p>利用规则推出H在E出现的条件下的后验概率</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">∣</mi><mi>E</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>E</mi><mi mathvariant="normal">∣</mi><mi>H</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo></mrow><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">P(H|E)=\frac {P(E|H)P(H)}{P(E)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</li>
<li>
<p>如果一个前提E支持多个结论Hi，则</p>
<img src="/MyImages/3.png" style="zoom: 50%;" />
</li>
<li>
<p>如果有多个证据E<sub>i</sub>和多个结论H<sub>j</sub>，则上式可扩展为</p>
<img src="/MyImages/4.png" style="zoom: 50%;" />
</li>
</ol>
<h3 id="举例"><a class="markdownIt-Anchor" href="#举例"></a> 举例</h3>
<ol>
<li>
<p><strong>一个条件支持多个结论</strong></p>
<p>设H1,H2,H3分别是三个结论，E是支持这些结论的证据。已知：<br />
P(H1)=0.3；    P(H2)=0.4；     P(H3)=0.5<br />
P(E|H1)=0.5； P(E|H2)=0.3； P(E|H3)=0.4</p>
<p>求P(H1|E),P(H2|E)及P(H3|E)</p>
<img src="/MyImages/5.png" style="zoom: 50%;" />
<p>同理可得P(H<sub>2</sub>|E)=0.26;P(H<sub>3</sub>|E)=0.43</p>
<p><strong>结论</strong>因为P(H1)=0.3；P(H1|E)=0.32，所以E的出现支持了H1成立，其他同理</p>
</li>
<li>
<p><strong>多个条件支持多个结论</strong></p>
<p>设H1,H2,H3分别是三个结论，E1,E2是支持这些结论的证据。已知：<br />
P(H1)=0.4； P(H2)=0.3； P(H3)=0.3<br />
P(E1|H1)=0.5； P(E1|H2)=0.6； P(E1|H3)=0.3.<br />
P(E2|H1)=0.7； P(E2|H2)=0.9； P(E2|H3)=0.1</p>
<p>求P(H1|E1E2),P(H2|E1E2)及P(H3|E1E2)的值各是多少？</p>
<p><img src="/MyImages/6.png" alt="" /></p>
<p>同理可得P(E1)=0.47, P(E2)=0.58</p>
<p><strong>结论</strong>同上分析，可知E1和E2的出现，H1和H2成立的可能性不同程<br />
度的增加，H3成立的可能性下降。</p>
</li>
</ol>
<h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3>
<ol>
<li>优点：概率推理方法有较强的理论背景和良好的数学特性，<strong>当证据彼此独立时</strong>计算的复杂度比较低。</li>
<li>缺点：概率推理方法要求给出结论Hi的先验概率 P(Hi)及条件概率 P(Ej|Hi)</li>
</ol>
<h1 id="主观bayes方法"><a class="markdownIt-Anchor" href="#主观bayes方法"></a> 主观Bayes方法</h1>
<p>PROSPECTOR的不确定性推理过程，就是根据证据的概率P(E)或P(E|S)，利用LS或LN，把结论H的先验概率P(H)更新为后验概率P(H|E)的过程。</p>
<h3 id="知识不确定的表示"><a class="markdownIt-Anchor" href="#知识不确定的表示"></a> 知识不确定的表示</h3>
<ol>
<li>
<p>知识是用产生式表示的</p>
<p><strong>IF E THEN (LS,LN) H</strong></p>
</li>
<li>
<p>其中E是前提，H是结论</p>
</li>
<li>
<p>LS是规则的充分性度量。用于指出<strong>E对H的支持程度</strong>，取值范围为[0,+∞)，其定义为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>S</mi><mo>=</mo><mfrac><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>E</mi><mi mathvariant="normal">∣</mi><mi>H</mi><mo stretchy="false">)</mo></mrow><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>E</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">¬</mi><mi>H</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">LS=\frac {P(E|H)}{P(E|\lnot H)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord">¬</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</li>
<li>
<p>LN是规则的必要性度量。用于指出E对H为真的必要程度，即﹁E对H的支持程度。取值范围为[0,+∞)，其定义为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>N</mi><mo>=</mo><mfrac><mrow><mi>P</mi><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mi>H</mi><mo stretchy="false">)</mo></mrow><mrow><mi>P</mi><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">¬</mi><mi>H</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><mn>1</mn><mo>−</mo><mi>P</mi><mo stretchy="false">(</mo><mi>E</mi><mi mathvariant="normal">∣</mi><mi>H</mi><mo stretchy="false">)</mo></mrow><mrow><mn>1</mn><mo>−</mo><mi>P</mi><mo stretchy="false">(</mo><mi>E</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">¬</mi><mi>H</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">LN=\frac {P(\lnot E|H)}{P(\lnot E|\lnot H)}=\frac {1-P(E|H)}{1-P(E|\lnot H)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord">¬</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord">¬</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</li>
<li>
<p>讨论LS和LN的含义</p>
<ol>
<li>由贝叶斯公式可得</li>
</ol>
   <img src="/MyImages/7.png" style="zoom:50%;" />
<p>两式相除得</p>
   <img src="/MyImages/8.png" style="zoom:50%;" />
<ol start="2">
<li>
<p>几率函数</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><mrow><mi>P</mi><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>X</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><mrow><mn>1</mn><mo>−</mo><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">O(X)=\frac {P(X)}{P(\lnot X)}=\frac {P(X)}{1-P(X)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>O(X)与P(X)变化一致，取值范围从[0,1]放大到[0,+∞]</p>
</li>
<li>
<p>因此</p>
<img src="/MyImages/9.png" style="zoom:50%;" />
 <img src="/MyImages/0.png" style="zoom:50%;" />
</li>
</ol>
</li>
<li>
<p>LS的含义</p>
<ul>
<li>
<p>当LS&gt;1时，O(H|E)&gt;O(H)，说明E支持H。 LS越大，E对H的支持越充分。</p>
</li>
<li>
<p>当LS=1时，O(H|E)=O(H)，说明E对H没有影响。</p>
</li>
<li>
<p>当LS&lt;1时，O(H|E)&lt;O(H)，说明E不支持H。</p>
</li>
<li>
<p>当LS=0时，O(H|E)=0，说明E的存在使H为假。</p>
</li>
</ul>
</li>
<li>
<p>LN的含义</p>
<ul>
<li>当LN&gt;1时，O(H|﹁E)&gt;O(H)，说明﹁E支持H。LN越大，﹁E对H为真的支持就越强。</li>
<li>当LN=1时，O(H|﹁E)=O(H)，说明﹁E对H没有影响。</li>
<li>当LN&lt;1时，O(H|﹁E)&lt;O(H)，说明﹁E不支持H，即由于E不存在，将反对H为真。 LN越小，E的不出现就越反对H为真，这说明H越需要E的出现。</li>
<li>当LN=0时，O(H|﹁E)=0，说明E不存在将导致H为假。</li>
</ul>
</li>
<li>
<p>LS和LN的三种关系(可利用LS和LN的定义式来互推)</p>
<ul>
<li>LS&gt;1且LN&lt;1</li>
<li>LS&lt;1且LN&gt;1</li>
<li>LS=LN=1</li>
</ul>
</li>
</ol>
<h3 id="证据不确定性表示"><a class="markdownIt-Anchor" href="#证据不确定性表示"></a> 证据不确定性表示</h3>
<ol>
<li>实际应用中，如果证据E不是直接观测到的，则需要由用户根据<strong>观察S</strong>给出P(E|S) 来描述E的不确定性；但实际中P(E|S)难以给定，<strong>所以用C(E|S)代替P(E|S)</strong></li>
<li>C(E|S) 取值为[-5,5]的整数
<ul>
<li>C(E|S)=-5表示在观测S下证据E肯定不存在P(E|S)=0</li>
<li>C(E|S)= 5表示在观测S下证据E肯定存在P(E|S)=1</li>
<li>C(E|S)= 0表示S与E无关,即:P(E|S)= P(E)</li>
</ul>
</li>
</ol>
<h3 id="组合证据不确定性"><a class="markdownIt-Anchor" href="#组合证据不确定性"></a> 组合证据不确定性</h3>
<ol>
<li>
<p>当组合证据是多个单一证据的<strong>合取</strong>：</p>
<p>P(E|S)=min{ P(E1|S), P(E2|S), … ,P(En|S)}</p>
</li>
<li>
<p>当组合证据是多个单一证据的<strong>析取</strong>：</p>
<p>P(E|S)=max{P(E1|S),P(E2|S),…,P(En|S)}</p>
</li>
</ol>
<h3 id="不确定性的更新"><a class="markdownIt-Anchor" href="#不确定性的更新"></a> 不确定性的更新</h3>
<ol>
<li>
<p>根据证据E在观察S下的条件概率P(E|S) 以及LS和LN的值，把H的先验几率O(H)或先验概率P(H)更新为后验几率O(H|S)或后验概率P(H|S)</p>
</li>
<li>
<p><strong>计算后验概率</strong></p>
<p><strong>P(H|S) = P(H|E)×P(E|S)+P(H|﹁E)×P(﹁E|S)</strong></p>
<ol>
<li>
<p>若E肯定为真</p>
<p>即P(E|S)=1，则 P(﹁E|S)=0， P(H|S) = P(H|E)</p>
</li>
<li>
<p>证据E肯定为假</p>
<p>即P(E|S)=0， 则P(﹁E|S)=1， P(H|S) = P(H|﹁E)</p>
</li>
<li>
<p>证据E既非为真又非为假0&lt;P(E|S)&lt;1</p>
<ol>
<li>P(E|S)=P(E)，P(H|S) = P(H)</li>
<li>P(E|S)为其他值</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="若e肯定为真"><a class="markdownIt-Anchor" href="#若e肯定为真"></a> 若E肯定为真</h3>
<ol>
<li>
<p>有P(H|S)=P(H|E)</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>E</mi><mi mathvariant="normal">∣</mi><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mi mathvariant="normal">则</mi><mi>P</mi><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><mi>E</mi><mi mathvariant="normal">∣</mi><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mi mathvariant="normal">，</mi><mi>P</mi><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">∣</mi><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">∣</mi><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(E|S)=1 则P(\lnot E|S)=0，P(H|S)=P(H|E)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord cjk_fallback">则</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord">¬</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">则</mi><mi>O</mi><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">∣</mi><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">∣</mi><mi>E</mi><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mi>S</mi><mo>×</mo><mi>O</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">则O(H|S)=O(H|E)=LS×O(H)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">则</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span></span></span></p>
</li>
<li>
<p>已知</p>
<img src="/MyImages/10.png" style="zoom:50%;" />
</li>
<li>
<p>后两个式子移项合并有</p>
<img src="/MyImages/11.png" style="zoom:50%;" />
</li>
</ol>
<h3 id="若e肯定为假"><a class="markdownIt-Anchor" href="#若e肯定为假"></a> 若E肯定为假</h3>
<ol>
<li>
<p>有P(H|S) = P(H|﹁E)，且已知</p>
<img src="/MyImages/12.png" style="zoom:50%;" />
</li>
<li>
<p>后两个式子移项合并有</p>
<img src="/MyImages/13.png" style="zoom:50%;" />
</li>
</ol>
<h3 id="证据既非为真又非为假时"><a class="markdownIt-Anchor" href="#证据既非为真又非为假时"></a> 证据既非为真又非为假时:</h3>
<p>​	0&lt;P(E|S)&lt;1</p>
<ol>
<li>
<p>当 P(E|S)=P(E)时， 表示E与S无关，此时：</p>
<img src="/MyImages/14.png" style="zoom:33%;" />
</li>
<li>
<p>当 P(E|S) ≠ P(E)时，表示E与S相关…</p>
</li>
<li>
<p>由三个特殊值可以读构造分段线性插值函数</p>
<img src="/MyImages/15.png" style="zoom:50%;" />
</li>
</ol>
<h3 id="eh公式"><a class="markdownIt-Anchor" href="#eh公式"></a> EH公式</h3>
<ul>
<li>
<p>分段线性插值函数的解析式为（点斜式）<strong>EH公式</strong></p>
<img src="/MyImages/27.png" style="zoom:50%;" />
</li>
<li>
<p>用C(E|S) 代替EH公式中的P(E|S)，可得到等价的CP公式</p>
<img src="/MyImages/29.png" style="zoom:50%;" />
</li>
</ul>
<h3 id="主观贝叶斯方法的推理过程"><a class="markdownIt-Anchor" href="#主观贝叶斯方法的推理过程"></a> 主观贝叶斯方法的推理过程</h3>
<h4 id="基本方法"><a class="markdownIt-Anchor" href="#基本方法"></a> 基本方法</h4>
<ul>
<li>
<p>当采用初始证据进行推理时，用户提供C(E|S) ，通过CP公式就可以求出P(H|S)</p>
</li>
<li>
<p>当采用推理过程中得到的中间结论作为证据进行推理时，通过EH公式就可以求出P(H|S)</p>
</li>
<li>
<p>结论不确定性的合成</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">∣</mi><msub><mi>S</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>S</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>S</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mo>=</mo><mfrac><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">∣</mi><msub><mi>S</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>×</mo><mfrac><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">∣</mi><msub><mi>S</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>×</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>×</mo><mfrac><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>H</mi><mi mathvariant="normal">∣</mi><msub><mi>S</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo></mrow></mfrac><mo>×</mo><mi>O</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(H|S_1,S_2,...,S_n)\\
=\frac {O(H|S_1)}{O(H)}×\frac {O(H|S_2)}{O(H)}×...×\frac {O(H|S_n)}{O(H)} × O(H)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span></span></span></p>
</li>
</ul>
<h3 id="主观贝叶斯方法举例"><a class="markdownIt-Anchor" href="#主观贝叶斯方法举例"></a> 主观贝叶斯方法举例</h3>
<h4 id="已知"><a class="markdownIt-Anchor" href="#已知"></a> 已知</h4>
<ul>
<li>设有规则<br />
r1: IF  E1 THEN  (2,  0.001)  H1<br />
r2: IF  E1 AND  E2 THEN (100, 0.001) H1<br />
r3: IF  H1  THEN  (200, 0.01) H2</li>
<li>已知：<br />
P(E1) = P(E2) = 0.6，P(H1) = 0.091，P(H2) = 0.01</li>
<li>用户回答:<br />
P(E1|S1) = 0.76， P(E2|S2) = 0.68</li>
<li>求：P(H2|S1,S2) = ?</li>
</ul>
<h4 id="解"><a class="markdownIt-Anchor" href="#解"></a> 解</h4>
<ul>
<li>
<p>由已知得到的推理网络</p>
<img src="/MyImages/32.png" style="zoom:33%;" />
</li>
<li>
<p>由推理网络得到求解过程</p>
<img src="/MyImages/33.png" style="zoom:50%;" />
<ol>
<li>计算P (H1 | S1)</li>
<li>计算P (H1 | (S1  AND  S2))</li>
<li>计算P (H1 | S1, S2)</li>
<li>计算P (H2 | S1,S2)</li>
</ol>
</li>
<li>
<p>根据EH公式计算P(H1|S1)</p>
<p>由于P(E1|S1)=0.76， P(E1)=0.6，此时P(E1|S1) &gt;P(E1)，使用EH式的后半部分，得P(H1|S1)为：</p>
<img src="/MyImages/34.png" style="zoom: 67%;" />
</li>
<li>
<p>根据EH公式计算P(H1|(S1 AND S2))</p>
<p>根据合取取最小的原则，因为P(E2|S2)&lt;P(E1|S1) ，所以令P(H1|(S1 AND S2)) = P(H1|S2)</p>
<p>再用EH公式求解P(H1|S2)</p>
<img src="/MyImages/35.png" style="zoom:67%;" />
</li>
<li>
<p>计算P(H1|S1,S2)</p>
<ul>
<li>
<p>先计算O(H1|S1,S2)</p>
<img src="/MyImages/36.png" style="zoom:67%;" />
</li>
<li>
<p>根据几率函数公式计算概率</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>H</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><msub><mi>S</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>S</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mi>H</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><msub><mi>S</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>S</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><mrow><mn>1</mn><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><msub><mi>H</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><msub><mi>S</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>S</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mfrac><mo>=</mo><mfrac><mn>0.472</mn><mrow><mn>1</mn><mo>+</mo><mn>0.472</mn></mrow></mfrac><mo>=</mo><mn>0.32</mn></mrow><annotation encoding="application/x-tex">P(H_1|S_1,S_2)=\frac {O(H_1|S_1,S_2)}{1+O(H_1|S_1,S_2)}=\frac {0.472}{1+0.472}=0.32
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">4</span><span class="mord">7</span><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord">.</span><span class="mord">4</span><span class="mord">7</span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">3</span><span class="mord">2</span></span></span></span></span></p>
</li>
</ul>
</li>
<li>
<p>计算P(H2|S1,S2)</p>
<p>由于P(H1|S1,S2) =0.321&gt; P(H1)，使用EH式的后半部分，得到在当前观察S1、S2下H2的后验概率P(H2|S1,S2):</p>
<img src="/MyImages/37.png" style="zoom: 67%;" />
</li>
</ul>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<h3 id="主观贝叶斯方法的优点"><a class="markdownIt-Anchor" href="#主观贝叶斯方法的优点"></a> 主观贝叶斯方法的优点</h3>
<ul>
<li>主观Bayes方法中的计算公式大多是在概率论的基础上推导出来的，<strong>具有较坚实的理论基础</strong>。</li>
<li>知识的静态强度LS及LN是由领域专家给出，<strong>避免了大量的数据统计工作</strong>。</li>
<li>主观Bayes方法不仅给出了证据肯定存在、肯定不存在时更新后验概率的方法，还<strong>给出了证据不确定时的更新方法</strong>，实现了不确定性的逐级传递。</li>
</ul>
<h3 id="主观贝叶斯方法的缺点"><a class="markdownIt-Anchor" href="#主观贝叶斯方法的缺点"></a> 主观贝叶斯方法的缺点</h3>
<ul>
<li>它要求领域专家在给出知识时，同时给出H的先验概率P(H)，这比较困难。</li>
<li>Bayes定理要求事件间独立，使其应用受限制。</li>
</ul>
<h1 id="可信度方法"><a class="markdownIt-Anchor" href="#可信度方法"></a> 可信度方法</h1>
<h2 id="可信度概念"><a class="markdownIt-Anchor" href="#可信度概念"></a> 可信度概念</h2>
<ul>
<li>根据经验对一个事物和现象为真的相信程度称为<strong>可信度</strong>。</li>
<li>在可信度方法中，由专家给出规则或知识的可信度，从而可避免对先验概率、或条件概率的要求。</li>
</ul>
<h2 id="c-f模型"><a class="markdownIt-Anchor" href="#c-f模型"></a> C-F模型</h2>
<ul>
<li>
<p>一般形式</p>
<p>IF		E	THEN		H	(CF(H,E))</p>
</li>
<li>
<p>其中CF(H,E)∈[-1,1] 表示该知识的可信度</p>
<ul>
<li>CF(H,E)&gt;0对应于P(H|E)&gt;P(H);</li>
<li>CF(H,E)&lt;0对应于P(H|E)&lt;P(H);</li>
<li>CF(H,E)=0对应于P(H|E)=P(H);</li>
</ul>
</li>
</ul>
<h3 id="知识的不确定性"><a class="markdownIt-Anchor" href="#知识的不确定性"></a> 知识的不确定性</h3>
<p>​			<strong>$$CF(H,E)=MB(H,E)-MD(H,E)$$</strong></p>
<ul>
<li>
<p>MB为信任增长度，反映了证据对结论有利的一面</p>
<img src="/MyImages/30.png" style="zoom: 33%;" />
</li>
<li>
<p>MD为不信任增长度，反映了证据对结论不利的一面</p>
<img src="/MyImages/31.png" style="zoom:33%;" />
</li>
<li>
<p>讨论</p>
<ul>
<li>当P(H|E)&gt;P(H)时：<br />
信任增长度MB(H,E)&gt;0，<br />
不信任增长度MD(H,E)=0 。</li>
<li>当P(H|E)&lt;P(H)时，<br />
不信任增长度MD(H,E)&gt;0，<br />
信任增长度MB(H,E) =0。</li>
<li><strong>MB(H,E)与MD(H,E)是互斥的：</strong><br />
当MB(H,E)&gt;0时，MD(H,E)＝0<br />
当MD(H,E)&gt;0时，MB(H,E)＝0</li>
</ul>
</li>
</ul>
<h4 id="cfhe的计算公式"><a class="markdownIt-Anchor" href="#cfhe的计算公式"></a> CF(H,E)的计算公式</h4>
<img src="/MyImages/41.png" style="zoom:50%;" />
<ul>
<li>当且仅当P(H|E)=1时,  CF(H,E)=1</li>
<li>当且仅当P(H|E)=0时,  CF(H,E)=-1</li>
<li><strong>CF(H,E)定性地反映了P(H|E)的大小,因此可以用CF(H,E)近似表示P(H|E)的大小,从而描述了规则的可信度。</strong></li>
</ul>
<h3 id="证据的不确定性的表示"><a class="markdownIt-Anchor" href="#证据的不确定性的表示"></a> 证据的不确定性的表示</h3>
<ol>
<li>
<p>证据的不确定性也用可信度因子表示。如： CF(E)=0.6；<strong>CF(E)表示证据的强度，即动态强度，取值范围[-1，+1]</strong></p>
<ul>
<li>CF(E)&gt;0:表示证据以某种程度为真</li>
<li>CF(E)&lt;0:表示证据以某种程度为假</li>
</ul>
</li>
<li>
<p><strong>组合证据的不确定性</strong>----最大最小原则</p>
<ul>
<li>若E=E1 AND E2 AND…AND En,则<br />
CF(E)=min{CF(E1),CF(E2),…,CF(En)}</li>
<li>若E=E1 OR E2 OR…OR En,则<br />
CF(E)=max{CF(E1),CF(E2),…,CF(En)}</li>
</ul>
</li>
</ol>
<h3 id="结论的不确定性表示"><a class="markdownIt-Anchor" href="#结论的不确定性表示"></a> 结论的不确定性表示</h3>
<ol>
<li>
<p>结论H的可信度由下式计算：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>F</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo><mo>=</mo><mi>C</mi><mi>F</mi><mo stretchy="false">(</mo><mi>H</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo><mo>×</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mi>C</mi><mi>F</mi><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">CF(H)=CF(H,E)×max\{0,CF(E)\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mclose">}</span></span></span></span></span></p>
<ul>
<li>CF(H)的取值范围：[-1，+1]。</li>
<li>CF(H)&gt;0:表示结论以某种程度为真</li>
<li>CF(H)&lt;0:表示结论以某种程度为假</li>
</ul>
</li>
<li>
<p><strong>结论不确定性的合成</strong></p>
<ul>
<li>
<p>若由多条不同知识推出了相同的结论，但可信度不同，则用合成算法求出综合可信度</p>
</li>
<li>
<p>假设有</p>
<p>IF		E1	THEN		H	(CF(H,E1))<br />
IF		E2	THEN		H	(CF(H,E2))</p>
</li>
<li>
<p>计算时，首先计算CF1(H)、CF2(H)，然后带入公式计算综合可信度</p>
<img src="/MyImages/42.png" style="zoom:50%;" />
</li>
</ul>
</li>
</ol>
<h3 id="c-f模型推理示例"><a class="markdownIt-Anchor" href="#c-f模型推理示例"></a> C-F模型推理示例</h3>
<h4 id="设已知"><a class="markdownIt-Anchor" href="#设已知"></a> 设已知</h4>
<p>R1: IF	E1	THEN		H	(0.8)<br />
R2: IF	E2	THEN		H	(0.6)<br />
R3: IF	E3	THEN		H	(-0.5)<br />
R4: IF	E4 AND (E5 OR E6)	THEN		E1	(0.7)<br />
R5: IF	E7 AND E8 THEN		E3	(0.9)<br />
已知：CF(E2)=0.8, CF(E4)=0.5, CF(E5)=0.6，CF(E6)=0.7, CF(E7)=0.6, CF(E8)=0.9<br />
求：CF(H)=？</p>
<h4 id="求解"><a class="markdownIt-Anchor" href="#求解"></a> 求解</h4>
<ul>
<li>求H的三个证据的不确定性
<ul>
<li>由R4得到：<br />
CF(E1)=0.7×max{0,CF[E4 AND (E5 OR E6)]}<br />
=0.7×max{0,min{CF(E4),CF(E5 OR E6)}}<br />
=0.35</li>
<li>由R5得到：<br />
CF(E3)=0.9×max{0,CF[E7 AND E8]}<br />
=0.54</li>
</ul>
</li>
<li>求三个证据独立对结论的支持程度
<ul>
<li>由R1得到：<br />
CF1(H)=0.8×max{0,CF(E1)}=0.28</li>
<li>由R2得到：<br />
CF2(H)=0.6×max{0,CF(E2)}=0.48</li>
<li>由R2得到：<br />
CF2(H)=0.6×max{0,CF(E2)}=0.48</li>
</ul>
</li>
<li>代入不确定性合成算法
<ul>
<li>CF12(H)=CF1(H)+CF2(H)-CF1(H)×CF2(H)=0.63</li>
<li>CF123(H)=[CF12(H)+CF3(H)]/[1-min{|CF12(H)|,|CF3(H)|}]<br />
=0.49</li>
</ul>
</li>
</ul>
<h2 id="带有阈值限度的不确定性推理"><a class="markdownIt-Anchor" href="#带有阈值限度的不确定性推理"></a> 带有阈值限度的不确定性推理</h2>
<ul>
<li>一般形式 IF		E	THEN		H	(CF(H,E),λ)</li>
<li>λ是阈值，明确规定了知识运用的条件：只有当CF(E)≥λ时，该知识才能够被应用。λ的取值范围为(0,1]。</li>
</ul>
<h3 id="知识的不确定性表示"><a class="markdownIt-Anchor" href="#知识的不确定性表示"></a> 知识的不确定性表示</h3>
<p>CF(H,E)为知识的可信度，取值范围为[0,1]。</p>
<ul>
<li>CF(H,E)=0 对应于 P(H|E)=0 (证据绝对否定结论)</li>
<li>CF(H,E)=1 对应于 P(H|E)=1 (证据绝对支持结论)</li>
</ul>
<h3 id="证据不确定性的表示"><a class="markdownIt-Anchor" href="#证据不确定性的表示"></a> 证据不确定性的表示</h3>
<p>证据E的可信度仍为CF(E)，但其取值范围为：[0，1]</p>
<ul>
<li>CF(E)=1  对应于 P(E)=1   (证据绝对存在) ;</li>
<li>CF(E)=0  对应于 P(E)=0;  (证据绝对不存在)</li>
</ul>
<h3 id="结论的不确定性"><a class="markdownIt-Anchor" href="#结论的不确定性"></a> 结论的不确定性</h3>
<ol>
<li>
<p>单个规则：当CF(E)≥λ时，CF(H)=CF(H,E)×CF(E)</p>
</li>
<li>
<p>多条规则有相同的结论</p>
<p>则对满足CF(Ei)≥λi的带入公式求综合可信度</p>
</li>
</ol>
<h4 id="求综合可信的几种方法"><a class="markdownIt-Anchor" href="#求综合可信的几种方法"></a> 求综合可信的几种方法</h4>
<img src="/MyImages/43.png" style="zoom: 67%;" />
<h2 id="加权的不确定性推理"><a class="markdownIt-Anchor" href="#加权的不确定性推理"></a> 加权的不确定性推理</h2>
<p><strong>针对具有组合条件的知识不确定性的表示</strong></p>
<p>IF	E1(ω1) AND E2(ω2) AND…AND En(ωn)    THEN   H	 (CF(H,E),λ)</p>
<h3 id="知识不确定性的表示"><a class="markdownIt-Anchor" href="#知识不确定性的表示"></a> 知识不确定性的表示</h3>
<p>加权因子的取值范围一般为[0,1],且应满足归一条件，即$$0\leq w_i\leq 1,i=1,2,…,n\sum _{i=1}^nw_i=1$$</p>
<h3 id="组合证据不确定性的表示"><a class="markdownIt-Anchor" href="#组合证据不确定性的表示"></a> 组合证据不确定性的表示</h3>
<p>若有CF(E1)，CF(E2)，…，CF( En)，则组合证据的可信度为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>F</mi><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>w</mi><mi>i</mi></msub></mrow></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo>×</mo><mi>C</mi><mi>F</mi><mo stretchy="false">(</mo><msub><mi>E</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">CF(E)=\frac {1}{\sum _{i=1}^nw_i}\sum _{i=1}^{n}(w_i×CF(E_i))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.305708em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.994002em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<h3 id="结论不确定性的表示"><a class="markdownIt-Anchor" href="#结论不确定性的表示"></a> 结论不确定性的表示</h3>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>F</mi><mo stretchy="false">(</mo><mi>E</mi><mo stretchy="false">)</mo><mo>=</mo><mo>∑</mo><msub><mi>w</mi><mi>i</mi></msub><mi>C</mi><mi>F</mi><mo stretchy="false">(</mo><msub><mi>E</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">CF(E) = \sum w_iCF(E_i)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>当CF(E)≥λ时，该知识就可被应用。结论H的可信度为<strong>CF(H)=CF(H,E)×CF(E)</strong></p>
<h3 id="加权不确定性推理举例"><a class="markdownIt-Anchor" href="#加权不确定性推理举例"></a> 加权不确定性推理举例</h3>
<h4 id="已知-2"><a class="markdownIt-Anchor" href="#已知-2"></a> 已知</h4>
<p>R1: IF E1(0.6) AND E2(0.4) THEN E6(0.8,0.75)<br />
R2: IF E3(0.5) AND E4(0.3) AND E5(0.2)<br />
THEN E7(0.7,0.6)<br />
R3: IF E6(0.7) AND E7(0.3) THEN H(0.75,0.6)<br />
已知：CF(E1)=0.9, CF(E2)=0.8, CF(E3)=0.7,CF(E4)=0.6, CF(E5)=0.5<br />
求：CF(H)=?</p>
<h4 id="求解-2"><a class="markdownIt-Anchor" href="#求解-2"></a> 求解</h4>
<ul>
<li>
<p>由R1得到：<br />
CF(E1(0.6) AND E2(0.4))</p>
<p>​		=0.6×0.9+0.4×0.8</p>
<p>​		=0.86&gt;λ1=0.75<br />
∴R1可被应用。</p>
</li>
<li>
<p>由R2得到：<br />
CF(E3(0.5) AND E4(0.3) AND E5(0.2))＝0.63&gt;λ2 =0.6<br />
∴R2可被应用。</p>
</li>
<li>
<p>CF(E1(0.6) AND E2(0.4))&gt;CF(E3(0.5) AND E4(0.3) AND E5(0.2))<br />
∴R1先被应用。</p>
</li>
<li>
<p>由R1得到：CF(E6)=0.86×0.8 = 0.69</p>
</li>
<li>
<p>由R2得到：CF(E7)=0.44</p>
</li>
<li>
<p>由R3得到：<br />
CF(E6(0.7) AND E7(0.3))=0.615&gt;λ3 =0.6</p>
<p>∴R3可被应用,得到：</p>
<p>CF(H)=0.46</p>
</li>
</ul>
<h2 id="前提条件中带有可信度因子的不确定性推理"><a class="markdownIt-Anchor" href="#前提条件中带有可信度因子的不确定性推理"></a> 前提条件中带有可信度因子的不确定性推理</h2>
<p>IF	E1(cf1) AND E2(cf2) AND…AND En(cfn)    THEN   H (CF(H,E),λ)</p>
<ul>
<li>知识的前提条件不一定为真，只要前提条件满足一定的可信度，或具备一定的为真的可能性，就可以推出结论H。</li>
</ul>
<h3 id="知识不确定性的表示-2"><a class="markdownIt-Anchor" href="#知识不确定性的表示-2"></a> 知识不确定性的表示</h3>
<p>其中，cfi子条件Ei(i=1,2,…,n）的可信度。cfi在[0,1]上取值，其值由专家给出。</p>
<h3 id="证据不确定性的表示-2"><a class="markdownIt-Anchor" href="#证据不确定性的表示-2"></a> 证据不确定性的表示</h3>
<p>证据Ei的可信度记为cf’i,其取值范围在[0,1]上</p>
<h3 id="不确定性匹配算法"><a class="markdownIt-Anchor" href="#不确定性匹配算法"></a> 不确定性匹配算法</h3>
<h4 id="不带加权因子的不确定性匹配算法"><a class="markdownIt-Anchor" href="#不带加权因子的不确定性匹配算法"></a> 不带加权因子的不确定性匹配算法</h4>
<ul>
<li>知识：IF	E1(cf1) AND E2(cf2) AND…AND En(cfn)<br />
THEN   H	 (CF(H,E),λ)</li>
<li>条件：E1(cf’1)，E2(cf’2)，…， En(cf’n)</li>
<li>匹配算法：<br />
$$      max{0,cf_1-cf’_1}+max{0,cf_2-cf’_2}+…+ max{0,cf_n-cf’_n}≤λ$$
<ul>
<li>注意此处是小于等于，即$$cf_i-fc_i’\leq 0$$，即证据的实际可信度大于要求的可信度</li>
</ul>
</li>
</ul>
<h4 id="带加权因子的不确定性匹配算法"><a class="markdownIt-Anchor" href="#带加权因子的不确定性匹配算法"></a> 带加权因子的不确定性匹配算法</h4>
<ul>
<li>知识：IF	E1(cf1,ω1) AND E2(cf2,ω2) AND…AND En(cfn,ωn)<br />
THEN   H	 (CF(H,E),λ)</li>
<li>匹配算法：<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>ω</mi><mn>1</mn></msub><mo>×</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mi>c</mi><msub><mi>f</mi><mn>1</mn></msub><mo>−</mo><mi>c</mi><mi>f</mi><msub><mi mathvariant="normal">’</mi><mn>1</mn></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mn>1</mn></msub><mo>×</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mi>c</mi><msub><mi>f</mi><mn>2</mn></msub><mo>−</mo><mi>c</mi><mi>f</mi><msub><mi mathvariant="normal">’</mi><mn>2</mn></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>+</mo><mo>…</mo><mo>+</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>n</mi></msub><mo>×</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mi>c</mi><msub><mi>f</mi><mi>n</mi></msub><mo>−</mo><mi>c</mi><mi>f</mi><msub><mi mathvariant="normal">’</mi><mi>n</mi></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>≤</mo><mi>λ</mi></mrow><annotation encoding="application/x-tex">(ω_1×max\{0,cf_1-cf’_1\})+(ω_1×max\{0,cf_2-cf’_2\})+…+(ω_n×max\{0,cf_n-cf’_n\}) ≤λ
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord">’</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord">’</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord">’</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span></span></p>
</li>
</ul>
<h3 id="结论不确定性的表示-2"><a class="markdownIt-Anchor" href="#结论不确定性的表示-2"></a> 结论不确定性的表示</h3>
<h4 id="不带加权因子时"><a class="markdownIt-Anchor" href="#不带加权因子时"></a> 不带加权因子时：</h4>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>F</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mi>c</mi><msub><mi>f</mi><mn>1</mn></msub><mo>−</mo><mi>c</mi><mi>f</mi><msub><mi mathvariant="normal">’</mi><mn>1</mn></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mi>c</mi><msub><mi>f</mi><mn>2</mn></msub><mo>−</mo><mi>c</mi><mi>f</mi><msub><mi mathvariant="normal">’</mi><mn>2</mn></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>×</mo><mo>…</mo><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mi>c</mi><msub><mi>f</mi><mi>n</mi></msub><mo>−</mo><mi>c</mi><mi>f</mi><msub><mi mathvariant="normal">’</mi><mi>n</mi></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>×</mo><mi>C</mi><mi>F</mi><mo stretchy="false">(</mo><mi>H</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">CF(H)=[(1-max\{0,cf_1-cf’_1\})×(1-max\{0,cf_2-cf’_2\})×…×(1-max\{0,cf_n-cf’_n\})]×CF(H,E)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord">’</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord">’</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord">’</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mclose">)</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></span></p>
<h4 id="带加权因子时"><a class="markdownIt-Anchor" href="#带加权因子时"></a> 带加权因子时：</h4>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>F</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mn>1</mn></msub><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mi>c</mi><msub><mi>f</mi><mn>1</mn></msub><mo>−</mo><mi>c</mi><mi>f</mi><msub><mi mathvariant="normal">’</mi><mn>1</mn></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mn>2</mn></msub><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mi>c</mi><msub><mi>f</mi><mn>2</mn></msub><mo>−</mo><mi>c</mi><mi>f</mi><msub><mi mathvariant="normal">’</mi><mn>2</mn></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>×</mo><mo>…</mo><mo>×</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>n</mi></msub><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mi>c</mi><msub><mi>f</mi><mi>n</mi></msub><mo>−</mo><mi>c</mi><mi>f</mi><msub><mi mathvariant="normal">’</mi><mi>n</mi></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>×</mo><mi>C</mi><mi>F</mi><mo stretchy="false">(</mo><mi>H</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">CF(H)=[(ω_1×(1-max\{0,cf_1-cf’_1\}))×(ω_2×(1-max\{0,cf_2-cf’_2\}))×…×(ω_n×(1-max\{0,cf_n-cf’_n\}))]×CF(H,E)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord">’</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord">’</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord">’</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></span></p>
<h2 id="特点-2"><a class="markdownIt-Anchor" href="#特点-2"></a> 特点</h2>
<h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3>
<p>简单、直观。</p>
<h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3>
<ul>
<li>可信度因子依赖于专家主观指定，没有统一、客观的尺度，容易产生片面性。</li>
<li>随着推理延伸，可信度越来越不可靠，误差越来越大。当推理深度达到一定深度时，有可能出现推出的结论不再可信的情况。</li>
</ul>
<h1 id="模糊理论"><a class="markdownIt-Anchor" href="#模糊理论"></a> 模糊理论</h1>
<h2 id="模糊性"><a class="markdownIt-Anchor" href="#模糊性"></a> 模糊性</h2>
<ul>
<li>随机性：事物本身含义明确，但条件不明而不可预知。</li>
<li>模糊性：事物本身是模糊的。例如：青年、老年；高低；</li>
</ul>
<h2 id="集合与特征函数"><a class="markdownIt-Anchor" href="#集合与特征函数"></a> 集合与特征函数</h2>
<p>设A是论域U上的一个集合，对于任意u∈U，令</p>
<img src="/MyImages/image-20200402092804213.png" alt="image-20200402092804213" style="zoom:50%;" />
<p>则称C<sub>A</sub>(u)为集合A的<strong>特征函数</strong>。特征函数C<sub>A</sub>(u)在u=u<sub>0</sub>处的取值C<sub>A</sub>(u<sub>0</sub>)称为u<sub>0</sub>对A的隶属度。$$A={u|C_A(u)=1}$$</p>
<h2 id="模糊集与隶属函数"><a class="markdownIt-Anchor" href="#模糊集与隶属函数"></a> 模糊集与隶属函数</h2>
<h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3>
<ul>
<li>
<p>设U是论域，μA是把任意u∈U映射为[0,1]上某个值的函数，即</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>μ</mi><mi>A</mi><mo>:</mo><mi>U</mi><mo>→</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo><mi mathvariant="normal">或</mi><mi mathvariant="normal">者</mi><mi>u</mi><mo>→</mo><mi>μ</mi><mi>A</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">μA :U→[0,1]或者u→μA(u)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">μ</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">者</span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">μ</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mclose">)</span></span></span></span></span></p>
<p>则称μA为定义在U上的一个隶属函数，由μA(u)(u∈U)所构成的集合A称为U上的一个<strong>模糊集</strong>，μA(u)称为u对A的隶属度</p>
<p>模糊集刻画了每个元素隶属于A的程度</p>
</li>
</ul>
<h3 id="举例-2"><a class="markdownIt-Anchor" href="#举例-2"></a> 举例</h3>
<ul>
<li>论域U={1,2,3,4,5}，用模糊集表示“大”和“小”
<ul>
<li>设A、B分别表示“大”与“小”的模糊集，μA ，μB分别为相应的隶属函数。<br />
A={0, 0, 0.1, 0.6, 1}<br />
B={1, 0.5, 0.01, 0,0}<br />
其中：μA(1)=0,μA(2)=0 ,μA(3)=0.1 ,μA(4)=0.6 ,μA(5)=1<br />
μB(1)=1,μB(2)=0.5 ,μB(3)=0.01 ,μB(4)=0,μB(5)=0</li>
</ul>
</li>
<li>论域U={高山，刘水，秦声}，用模糊集A表示“学习好”这个概念。
<ul>
<li>解：先给出三人的平均成绩：<br />
高山：98分，刘水：90分，秦声：86分</li>
<li>上述成绩除以100后，就分别得到了各自对“学习好”的隶属度：<br />
μA(高山)=0.98,μA(刘水)=0.90 ,μA(秦声)=0.86<br />
则模糊集A为：<br />
A={0.98, 0.90, 0.86}</li>
</ul>
</li>
</ul>
<h2 id="模糊集的表示方法"><a class="markdownIt-Anchor" href="#模糊集的表示方法"></a> 模糊集的表示方法</h2>
<ul>
<li>
<p>一般表示形式为 $$A=\int_{u\in U}\mu_A(u)/u $$</p>
<p>U上的全体模糊集为$$F(U){A|\mu_A:U\to[0,1]}$$</p>
</li>
<li>
<p>用隶属度的集合表示</p>
<p>​	$$A={μA(u1),μA(u2),…,μA(un)}$$</p>
</li>
<li>
<p>分子表示隶属度，分母是元素</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mi>μ</mi><mi>A</mi><mo stretchy="false">(</mo><mi>u</mi><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>u</mi><mn>1</mn><mo>+</mo><mi>μ</mi><mi>A</mi><mo stretchy="false">(</mo><mi>u</mi><mn>2</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>u</mi><mn>2</mn><mo>+</mo><mo>…</mo><mo>+</mo><mi>μ</mi><mi>A</mi><mo stretchy="false">(</mo><mi>u</mi><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>u</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">A=μA(u1)/u1+μA(u2)/u2+…+μA(un)/un
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">μ</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">μ</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mord">2</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">μ</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span></span></span></span></span></p>
<ul>
<li>隶属度为0可以不写</li>
</ul>
</li>
<li>
<p>若论域是连续的，可以用实函数表示。例如</p>
<img src="/MyImages/image-20200406113637829.png" alt="image-20200406113637829" style="zoom: 33%;" />
</li>
</ul>
<h2 id="模糊集的运算"><a class="markdownIt-Anchor" href="#模糊集的运算"></a> 模糊集的运算</h2>
<h3 id="包含运算"><a class="markdownIt-Anchor" href="#包含运算"></a> 包含运算</h3>
<p>设A，B∈F(U)，若对任意u∈U，都有$$μ_B(u)≤μ_A(u)$$<br />
成立，则称A包含B，记为$$B\subset A$$</p>
<h3 id="交-并-补运算"><a class="markdownIt-Anchor" href="#交-并-补运算"></a> 交、并、补运算</h3>
<p>设A，B∈F(U)，以下为扎德算子</p>
<img src="/MyImages/image-20200406114749647.png" alt="image-20200406114749647" style="zoom: 50%;" />
<h3 id="其他模糊集运算"><a class="markdownIt-Anchor" href="#其他模糊集运算"></a> 其他模糊集运算</h3>
<img src="/MyImages/54.png" style="zoom:50%;" />
<h3 id="举例-3"><a class="markdownIt-Anchor" href="#举例-3"></a> 举例</h3>
<ul>
<li>设U={u1,u2,u3}，A=0.3/u1+0.8/u2+0.6/u3,B=0.6/u1+0.4/u2+0.7/u3<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">则</mi><mi>A</mi><mo>∩</mo><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><mn>0.3</mn><mo>∧</mo><mn>0.6</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>u</mi><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><mn>0.8</mn><mo>∧</mo><mn>0.4</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>u</mi><mn>2</mn><mo>+</mo><mo stretchy="false">(</mo><mn>0.6</mn><mo>∧</mo><mn>0.7</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>u</mi><mn>3</mn><mspace linebreak="newline"></mspace><mo>=</mo><mn>0.3</mn><mi mathvariant="normal">/</mi><mi>u</mi><mn>1</mn><mo>+</mo><mn>0.4</mn><mi mathvariant="normal">/</mi><mi>u</mi><mn>2</mn><mo>+</mo><mn>0.6</mn><mi mathvariant="normal">/</mi><mi>u</mi><mn>3</mn><mspace linebreak="newline"></mspace><mi>A</mi><mo>∪</mo><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><mn>0.3</mn><mo>∨</mo><mn>0.6</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>u</mi><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><mn>0.8</mn><mo>∨</mo><mn>0.4</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>u</mi><mn>2</mn><mo>+</mo><mo stretchy="false">(</mo><mn>0.6</mn><mo>∨</mo><mn>0.7</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>u</mi><mn>3</mn><mspace linebreak="newline"></mspace><mo>=</mo><mn>0.6</mn><mi mathvariant="normal">/</mi><mi>u</mi><mn>1</mn><mo>+</mo><mn>0.8</mn><mi mathvariant="normal">/</mi><mi>u</mi><mn>2</mn><mo>+</mo><mn>0.7</mn><mi mathvariant="normal">/</mi><mi>u</mi><mn>3</mn><mspace linebreak="newline"></mspace><mi mathvariant="normal">¬</mi><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>0.3</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>u</mi><mn>1</mn><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>0.8</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>u</mi><mn>2</mn><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>0.6</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>u</mi><mn>3</mn><mspace linebreak="newline"></mspace><mo>=</mo><mn>0.7</mn><mi mathvariant="normal">/</mi><mi>u</mi><mn>1</mn><mo>+</mo><mn>0.2</mn><mi mathvariant="normal">/</mi><mi>u</mi><mn>2</mn><mo>+</mo><mn>0.4</mn><mi mathvariant="normal">/</mi><mi>u</mi><mn>3</mn><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">则A∩B=(0.3∧0.6)/u1+(0.8∧0.4)/u2+(0.6∧0.7)/u3\\
	   =0.3/u1+0.4/u2+0.6/u3\\
A∪B=(0.3∨0.6)/u1+(0.8∨0.4)/u2+(0.6∨0.7)/u3\\
	   =0.6/u1+0.8/u2+0.7/u3\\
¬A=(1-0.3)/u1+(1-0.8)/u2+(1-0.6)/u3\\
	=0.7/u1+0.2/u2+0.4/u3\\
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">则</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">.</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">.</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">4</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">7</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">3</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">4</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord">3</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">.</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">.</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">4</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∨</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">7</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">8</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">7</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord">3</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">¬</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">3</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">8</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">7</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">2</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">4</span><span class="mord">/</span><span class="mord mathdefault">u</span><span class="mord">3</span></span><span class="mspace newline"></span></span></span></span></p>
</li>
</ul>
<h2 id="模糊集的水平截集"><a class="markdownIt-Anchor" href="#模糊集的水平截集"></a> 模糊集的水平截集</h2>
<h3 id="定义-2"><a class="markdownIt-Anchor" href="#定义-2"></a> 定义</h3>
<h4 id="水平截集"><a class="markdownIt-Anchor" href="#水平截集"></a> 水平截集</h4>
<p>λ水平截集是把模糊集合转化成普通集合的一个重要概念。</p>
<p>设A∈F(U),λ∈[0,1]，则称普通集合$$A_λ={u|u∈U,μ_A(u)≥λ}$$为A的一个λ水平截集， λ称为阈值或置信水平。</p>
<h4 id="核及支集"><a class="markdownIt-Anchor" href="#核及支集"></a> 核及支集</h4>
<ul>
<li>
<p>设A∈F(U) ，则称</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mi>e</mi><mi>r</mi><mi>A</mi><mo>=</mo><mo stretchy="false">{</mo><mi>u</mi><mi mathvariant="normal">∣</mi><mi>u</mi><mo>∈</mo><mi>U</mi><mo separator="true">,</mo><msub><mi>μ</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo stretchy="false">}</mo><mi mathvariant="normal">为</mi><mi mathvariant="normal">核</mi></mrow><annotation encoding="application/x-tex">Ker A=\{u|u∈U, μ_A(u)=1\}为核
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">u</span><span class="mord">∣</span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">核</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>u</mi><mi>p</mi><mi>p</mi><mi>A</mi><mo>=</mo><mo stretchy="false">{</mo><mi>u</mi><mi mathvariant="normal">∣</mi><mi>u</mi><mo>∈</mo><mi>U</mi><mo separator="true">,</mo><msub><mi>μ</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mn>0</mn><mo stretchy="false">}</mo><mi mathvariant="normal">为</mi><mi mathvariant="normal">支</mi><mi mathvariant="normal">集</mi></mrow><annotation encoding="application/x-tex">Supp A=\{u|u∈U, μ_A(u)&gt;0\}为支集
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mord mathdefault">p</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">u</span><span class="mord">∣</span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">}</span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">支</span><span class="mord cjk_fallback">集</span></span></span></span></span></p>
<p>当KerA≠Φ时，称A为<strong>正规模糊集</strong></p>
</li>
</ul>
<h3 id="性质"><a class="markdownIt-Anchor" href="#性质"></a> 性质</h3>
<ul>
<li>
<p>设A，B ∈F(U)，则：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>∪</mo><mi>B</mi><mo stretchy="false">)</mo><mi>λ</mi><mo>=</mo><msub><mi>A</mi><mi>λ</mi></msub><mo>∪</mo><msub><mi>B</mi><mi>λ</mi></msub></mrow><annotation encoding="application/x-tex">(A∪B)λ=A_λ∪B_λ
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mord mathdefault">λ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">λ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">λ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>∩</mo><mi>B</mi><mo stretchy="false">)</mo><mi>λ</mi><mo>=</mo><msub><mi>A</mi><mi>λ</mi></msub><mo>∩</mo><msub><mi>B</mi><mi>λ</mi></msub></mrow><annotation encoding="application/x-tex">(A∩B)λ=A_λ∩B_λ
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mord mathdefault">λ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">λ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">λ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p>若λ1, λ2∈[0,1]，且λ1&lt;λ2 ，则：</p>
<ul>
<li>阈值λ越大，其水平截集Aλ越小，当λ＝1时，Aλ最小，称它为<strong>模糊集的核</strong>。</li>
</ul>
</li>
</ul>
<h3 id="举例-4"><a class="markdownIt-Anchor" href="#举例-4"></a> 举例</h3>
<img src="/MyImages/image-20200406123053635.png" alt="image-20200406123053635" style="zoom:50%;" />
<h2 id="模糊度"><a class="markdownIt-Anchor" href="#模糊度"></a> 模糊度</h2>
<p>模糊度是模糊集的模糊程度的一种度量</p>
<h3 id="定义-3"><a class="markdownIt-Anchor" href="#定义-3"></a> 定义</h3>
<ul>
<li>设A∈F(U)，d是定义在F(U)上的一个实函数，如果它满足以下条件：
<ul>
<li>对任意A∈F(U)，有d(A)∈[0,1];</li>
<li>当且仅当A是一个普通集合时，d(A)=0；</li>
<li>若A的隶属函数μA(u)≡0.5，则d(A)=1;</li>
<li>若A,B∈F(U),且对任意u∈U,满足μB(u)≤μA(u)≤0.5或者μB(u)≥μA(u)≥0.5则有d(B)≤d(A)</li>
<li>对任意A∈F(U) ，有<strong>d(A)=d(¬A)则称d为定义在F(U)上的一个模糊度</strong>，d(A)称为A的模糊度。</li>
</ul>
</li>
</ul>
<h3 id="直观含义"><a class="markdownIt-Anchor" href="#直观含义"></a> 直观含义</h3>
<ul>
<li>是[0,1]上一个数；</li>
<li>普通集合的模糊度是0，表示所刻画的概念不模糊；</li>
<li>越靠近0.5就越模糊，当μA(u)＝0.5时最模糊；</li>
<li>模糊集A与其补集¬A有相同的模糊度。</li>
</ul>
<h3 id="计算方法"><a class="markdownIt-Anchor" href="#计算方法"></a> 计算方法</h3>
<ul>
<li>
<p>海明模糊度</p>
<img src="/MyImages/image-20200406123425562.png" alt="image-20200406123425562" style="zoom:33%;" />
</li>
<li>
<p>欧几里得模糊度</p>
<img src="/MyImages/image-20200406123535043.png" alt="image-20200406123535043" style="zoom:33%;" />
</li>
<li>
<p>明可夫斯基模糊度</p>
<img src="/MyImages/image-20200406123555807.png" alt="image-20200406123555807" style="zoom:50%;" />
</li>
<li>
<p>香农模糊度</p>
<img src="/MyImages/image-20200406123627009.png" alt="image-20200406123627009" style="zoom:50%;" />
<p>其中S(x)是定义在[0,1]上的香农函数，即</p>
<img src="/MyImages/image-20200406123654375.png" alt="image-20200406123654375" style="zoom: 50%;" />
</li>
</ul>
<h3 id="举例-5"><a class="markdownIt-Anchor" href="#举例-5"></a> 举例</h3>
<img src="/MyImages/55.png" style="zoom:50%;" />
<h2 id="模糊数"><a class="markdownIt-Anchor" href="#模糊数"></a> 模糊数</h2>
<h3 id="定义-4"><a class="markdownIt-Anchor" href="#定义-4"></a> 定义</h3>
<ul>
<li>
<p>如果实数域R上的模糊集A的隶属函数μA(u)在R上连续且具有如下性质：</p>
<ul>
<li>A是凸模糊集，即对任意λ∈[0,1], A<sub>λ</sub>是闭区间；</li>
<li>A是正规模糊集，即存在u∈R，使μA(u)＝1</li>
</ul>
<p>则称A为一个模糊数</p>
</li>
<li>
<p>直观上模糊数的隶属函数是单峰的，且峰顶使隶属度为1</p>
<img src="/MyImages/image-20200406124050636.png" alt="image-20200406124050636" style="zoom:50%;" />
</li>
</ul>
<h4 id="举例-6"><a class="markdownIt-Anchor" href="#举例-6"></a> 举例</h4>
<ul>
<li>
<p>6左右 可表示为</p>
<img src="/MyImages/image-20200406124132462.png" alt="image-20200406124132462" style="zoom: 50%;" />
</li>
</ul>
<h3 id="模糊数的运算"><a class="markdownIt-Anchor" href="#模糊数的运算"></a> 模糊数的运算</h3>
<ul>
<li>
<p>设θ是实数域R上的一种二元运算，A和B为任意的模糊数，则模糊数间的运算定义为</p>
<img src="/MyImages/image-20200406124314724.png" alt="image-20200406124314724" style="zoom:50%;" />
</li>
<li>
<p>两个模糊数之间的运算，实际上是对应元素的隶属度先取极小，再取极大</p>
</li>
<li>
<p><strong>模糊数乘或者除的结果可能不是一个模糊数</strong></p>
</li>
</ul>
<h4 id="举例-7"><a class="markdownIt-Anchor" href="#举例-7"></a> 举例</h4>
<ul>
<li>
<p>设有<br />
3左右=0.5/2+1/3+0.6/4<br />
2左右=0.4/1+1/2+0.7/3</p>
</li>
<li>
<img src="/MyImages/image-20200406124451302.png" alt="image-20200406124451302" style="zoom:33%;" />
</li>
<li>
<img src="/MyImages/image-20200406124522874.png" alt="image-20200406124522874" style="zoom:33%;" />
</li>
</ul>
<h2 id="模糊关系及其合成"><a class="markdownIt-Anchor" href="#模糊关系及其合成"></a> 模糊关系及其合成</h2>
<h3 id="模糊关系"><a class="markdownIt-Anchor" href="#模糊关系"></a> 模糊关系</h3>
<ul>
<li>
<p>Ai是Ui(i=1,2,…,n)上的模糊集，则称</p>
<img src="/MyImages/image-20200406125029088.png" alt="image-20200406125029088" style="zoom:50%;" />
<p>为A1,A2,…,An的<strong>笛卡儿乘积</strong>，它是U1×U2×…×Un上的一个模糊集。</p>
</li>
<li>
<p>在U1×U2×…×Un上一个n元模糊关系R是指以U1×U2×…×Un为论域的一个模糊集，记为</p>
<img src="/MyImages/image-20200406125055086.png" alt="image-20200406125055086" style="zoom:50%;" />
</li>
</ul>
<h3 id="模糊矩阵"><a class="markdownIt-Anchor" href="#模糊矩阵"></a> 模糊矩阵</h3>
<p>一般地说，当U和V都是有限论域时，其模糊关系R可用一个模糊矩阵表示。<br />
U={u1,u2,…,um}<br />
V={v1,v2,…,vn}<br />
则U×V上的模糊关系为</p>
<img src="/MyImages/image-20200406125208806.png" alt="image-20200406125208806" style="zoom:50%;" />
<h3 id="模糊关系的合成"><a class="markdownIt-Anchor" href="#模糊关系的合成"></a> 模糊关系的合成</h3>
<img src="/MyImages/image-20200408122253743.png" alt="image-20200408122253743" style="zoom:50%;" />
<h3 id="举例-8"><a class="markdownIt-Anchor" href="#举例-8"></a> 举例</h3>
<img src="/MyImages/56.png" style="zoom:67%;" />
<h2 id="模糊变换"><a class="markdownIt-Anchor" href="#模糊变换"></a> 模糊变换</h2>
<ul>
<li>定义2.24 设A={μA(u1),μA(u2),…,μA(un)}是论域U上的模糊集，R是U×V上的模糊关系，则A°R=B称为模糊变换</li>
</ul>
<h3 id="举例-9"><a class="markdownIt-Anchor" href="#举例-9"></a> 举例</h3>
<img src="/MyImages/57.png" style="zoom:67%;" />
<h2 id="常见隶属函数"><a class="markdownIt-Anchor" href="#常见隶属函数"></a> 常见隶属函数</h2>
<h3 id="正态分布"><a class="markdownIt-Anchor" href="#正态分布"></a> 正态分布</h3>
<img src="/MyImages/image-20200408122715676.png" alt="image-20200408122715676" style="zoom: 50%;" />
<h3 id="升正态分布"><a class="markdownIt-Anchor" href="#升正态分布"></a> 升正态分布</h3>
<img src="/MyImages/image-20200408122741696.png" alt="image-20200408122741696" style="zoom: 50%;" />
<h3 id="降正态分布"><a class="markdownIt-Anchor" href="#降正态分布"></a> 降正态分布</h3>
<img src="/MyImages/image-20200408122756735.png" alt="image-20200408122756735" style="zoom: 50%;" />
<img src="/MyImages/58.png" style="zoom:67%;" />
<h2 id="建立隶属函数"><a class="markdownIt-Anchor" href="#建立隶属函数"></a> 建立隶属函数</h2>
<img src="/MyImages/image-20200408122945179.png" alt="image-20200408122945179" style="zoom:67%;" />
<h1 id="模糊推理"><a class="markdownIt-Anchor" href="#模糊推理"></a> 模糊推理</h1>
<h2 id="模糊命题"><a class="markdownIt-Anchor" href="#模糊命题"></a> 模糊命题</h2>
<ul>
<li>
<p>含有模糊概念、模糊数据的语句称为<strong>模糊命题</strong></p>
</li>
<li>
<p>一般形式为</p>
<ul>
<li>
<p>x		is 	A</p>
</li>
<li>
<p>或 x	    is	    A	(CF)</p>
</li>
<li>
<p>其中<strong>A是模糊概念或者模糊数</strong>，用相应的模糊集及隶属函数刻画；</p>
<p><strong>x是论域上的变量</strong>，用以代表所论述对象的属性；</p>
<p><strong>CF是该模糊命题的可信度</strong>，它既可以是一个确定的数，也可以是一个模糊数或者模糊语言值。</p>
</li>
</ul>
</li>
</ul>
<h2 id="模糊知识的表示"><a class="markdownIt-Anchor" href="#模糊知识的表示"></a> 模糊知识的表示</h2>
<ul>
<li>
<p>模糊产生式 IF		E	THEN		H	(CF,λ)</p>
<ul>
<li>E是用模糊命题表示的模糊条件；</li>
<li>H是用模糊命题表示的模糊结论；</li>
<li>CF是知识的可信度因子，它既可以是一个确定的数，也可以是一个模糊数或模糊语言值。</li>
<li>λ是匹配度的阈值，用以指出知识被运用的条件</li>
<li>例如IF	x  is  A  THEN  y is B  (CF,λ)</li>
</ul>
</li>
<li>
<p>证据H也可以用模糊命题表示</p>
<p>例如 x 		is 			A’</p>
</li>
</ul>
<h2 id="模糊匹配与冲突消解"><a class="markdownIt-Anchor" href="#模糊匹配与冲突消解"></a> 模糊匹配与冲突消解</h2>
<ul>
<li>知识的前提条件中的A与证据中的A’不一定完全相同，因此首先必须考虑匹配问题。</li>
<li>常用的计算两个模糊集或模糊概念的相似程度（<strong>匹配度</strong>)的方法主要有贴近度、语义距离及相似度等</li>
</ul>
<h3 id="模糊匹配"><a class="markdownIt-Anchor" href="#模糊匹配"></a> 模糊匹配</h3>
<h4 id="贴近度"><a class="markdownIt-Anchor" href="#贴近度"></a> 贴近度</h4>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">[</mo><mi>A</mi><mi mathvariant="normal">∙</mi><mi>B</mi><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>A</mi><mo>⊙</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(A,B)= [A∙B+(1-A⊙B)] /2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mord">∙</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊙</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mclose">]</span><span class="mord">/</span><span class="mord">2</span></span></span></span></span></p>
<p>其中<img src="/MyImages/image-20200409092941920.png" alt="image-20200409092941920" style="zoom:50%;" /></p>
<h4 id="语义距离"><a class="markdownIt-Anchor" href="#语义距离"></a> 语义距离</h4>
<p><img src="/MyImages/59.png" alt="" /></p>
<h4 id="相似度"><a class="markdownIt-Anchor" href="#相似度"></a> 相似度</h4>
<img src="/MyImages/60.png" style="zoom:67%;" />
<img src="/MyImages/61.png" style="zoom:67%;" />
<h4 id="举例-10"><a class="markdownIt-Anchor" href="#举例-10"></a> 举例</h4>
<img src="/MyImages/image-20200409093854661.png" alt="image-20200409093854661" style="zoom:67%;" />
<h4 id="复合条件的模糊匹配"><a class="markdownIt-Anchor" href="#复合条件的模糊匹配"></a> 复合条件的模糊匹配</h4>
<ul>
<li>
<p>例如对复合条件<br />
E=x1 is A1 AND x2 is A2 AND x3 is A3<br />
及相应证据E’:<br />
x1 is A’1 , x2 is A’2 , x3 is A’3</p>
<p>分别算出Ai与A’i的匹配度δmatch(Ai,A’i),i=1,2,3</p>
</li>
</ul>
<h4 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h4>
<p>目前常用的方法有“取极小”和“相乘”等</p>
<ul>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo stretchy="false">(</mo><mi>E</mi><mo separator="true">,</mo><mi>E</mi><mi mathvariant="normal">’</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">{</mo><mi>δ</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo stretchy="false">(</mo><mi>A</mi><mn>1</mn><mo separator="true">,</mo><mi>A</mi><mi mathvariant="normal">’</mi><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>δ</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo stretchy="false">(</mo><mi>A</mi><mn>2</mn><mo separator="true">,</mo><mi>A</mi><mi mathvariant="normal">’</mi><mn>2</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>δ</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo stretchy="false">(</mo><mi>A</mi><mn>3</mn><mo separator="true">,</mo><mi>A</mi><mi mathvariant="normal">’</mi><mn>3</mn><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">δmatch(E,E’)=min\{δmatch(A1,A’1),δmatch(A2,A’2), δmatch(A3,A’3)\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">’</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mord">’</span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mord">’</span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mord">’</span><span class="mord">3</span><span class="mclose">)</span><span class="mclose">}</span></span></span></span></span></p>
</li>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo stretchy="false">(</mo><mi>E</mi><mo separator="true">,</mo><mi>E</mi><mi mathvariant="normal">’</mi><mo stretchy="false">)</mo><mo>=</mo><mi>δ</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo stretchy="false">(</mo><mi>A</mi><mn>1</mn><mo separator="true">,</mo><mi>A</mi><mi mathvariant="normal">’</mi><mn>1</mn><mo stretchy="false">)</mo><mo>×</mo><mi>δ</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo stretchy="false">(</mo><mi>A</mi><mn>2</mn><mo separator="true">,</mo><mi>A</mi><mi mathvariant="normal">’</mi><mn>2</mn><mo stretchy="false">)</mo><mo>×</mo><mi>δ</mi><mi>m</mi><mi>a</mi><mi>t</mi><mi>c</mi><mi>h</mi><mo stretchy="false">(</mo><mi>A</mi><mn>3</mn><mo separator="true">,</mo><mi>A</mi><mi mathvariant="normal">’</mi><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">δmatch(E,E’)=δmatch(A1,A’1)×δmatch(A2,A’2)×δmatch(A3,A’3)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">’</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mord">’</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mord">’</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mord">’</span><span class="mord">3</span><span class="mclose">)</span></span></span></span></span></p>
</li>
<li>
<p>检查总匹配度是否满足阈值条件，如果满足就可以匹配，否则为不可匹配</p>
</li>
</ul>
<h3 id="冲突消解"><a class="markdownIt-Anchor" href="#冲突消解"></a> 冲突消解</h3>
<p><img src="/MyImages/image-20200409094534772.png" alt="image-20200409094534772" style="zoom: 67%;" /><img src="/MyImages/image-20200409095555144.png" alt="image-20200409095555144" /><img src="/MyImages/image-20200409094548468.png" alt="image-20200409094548468" style="zoom:50%;" /></p>
<p><img src="/MyImages/image-20200409095623809.png" alt="image-20200409095623809" style="zoom:50%;" /><img src="/MyImages/image-20200409095639862.png" alt="image-20200409095639862" /></p>
<p><img src="/MyImages/image-20200409095639862.png" alt="image-20200409095639862" /></p>
<h2 id="模糊推理的基本模式"><a class="markdownIt-Anchor" href="#模糊推理的基本模式"></a> 模糊推理的基本模式</h2>
<h3 id="模糊假言推理"><a class="markdownIt-Anchor" href="#模糊假言推理"></a> 模糊假言推理</h3>
<img src="/MyImages/image-20200409095802098.png" alt="image-20200409095802098" style="zoom:50%;" />
<h3 id="模糊拒取式推理"><a class="markdownIt-Anchor" href="#模糊拒取式推理"></a> 模糊拒取式推理</h3>
<img src="/MyImages/image-20200409095908272.png" alt="image-20200409095908272" style="zoom:50%;" />
<h2 id="简单模糊推理"><a class="markdownIt-Anchor" href="#简单模糊推理"></a> 简单模糊推理</h2>
<ul>
<li>知识中只含有简单条件，且不带可信度因子的模糊推理称为<strong>简单模糊推理</strong>。</li>
</ul>
<h3 id="合成推理规则"><a class="markdownIt-Anchor" href="#合成推理规则"></a> 合成推理规则</h3>
<img src="/MyImages/image-20200409100141443.png" alt="image-20200409100141443" style="zoom:50%;" />
<h3 id="构造模糊关系r的方法"><a class="markdownIt-Anchor" href="#构造模糊关系r的方法"></a> 构造模糊关系R的方法</h3>
<h4 id="img-srcmyimages62png-stylezoom-67"><a class="markdownIt-Anchor" href="#img-srcmyimages62png-stylezoom-67"></a> <img src="/MyImages/62.png" style="zoom: 67%;" /></h4>
<img src="/MyImages/image-20200409100915608.png" alt="image-20200409100915608" style="zoom:50%;" />
<h4 id="举例-11"><a class="markdownIt-Anchor" href="#举例-11"></a> 举例</h4>
<img src="/MyImages/image-20200409101021989.png" alt="image-20200409101021989" style="zoom:50%;" />
<ul>
<li>
<img src="/MyImages/image-20200409101040426.png" alt="image-20200409101040426" style="zoom:50%;" />
<p>​	$$R_m(U_1V_3)=max(min(1,0.4),(1-1))=0.4$$</p>
<p>​	$$R_a(U_2,V_3) = min(1,(1-U_2+V_3)) = 0.9$$</p>
</li>
<li>
<img src="/MyImages/63.png" style="zoom:50%;" /></li>
</ul>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第2章知识表示方法</title>
    <url>/2020/06/13/%E7%AC%AC2%E7%AB%A0%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="知识表示"><a class="markdownIt-Anchor" href="#知识表示"></a> 知识表示</h1>
<h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2>
<ol>
<li>
<p>我们把有关信息关联在一起所形成的信息结构称为<strong>知识</strong></p>
</li>
<li>
<p><strong>知识表示</strong> 就是对知识的一种描述，一种计算机可以接受的用于描述知识的数据结构。</p>
</li>
<li>
<p><strong>知识描述</strong> 的三个维度</p>
<ol>
<li>知识的范围：是由具体到一般</li>
<li>知识的目的：由说明到指定</li>
<li>知识的有效性：由确定到不确定</li>
</ol>
</li>
</ol>
<h2 id="知识的分类"><a class="markdownIt-Anchor" href="#知识的分类"></a> 知识的分类</h2>
<h3 id="按作用范围"><a class="markdownIt-Anchor" href="#按作用范围"></a> 按作用范围</h3>
<ol>
<li><strong>常识性知识</strong>：通用性知识，适用于所有领域；如 一年有四个季节。</li>
<li><strong>领域性知识</strong>：面向某个具体领域的知识，是专业性知识，如疾病诊断的知识。</li>
</ol>
<h3 id="按知识的作用及表示划分"><a class="markdownIt-Anchor" href="#按知识的作用及表示划分"></a> 按知识的作用及表示划分</h3>
<ol>
<li><strong>事实性知识</strong>：用于描述领域内的有关概念、事实、事物的属性及状态；如：太阳从东方升起</li>
<li><strong>过程性知识</strong>：与领域相关的、用于指出如何处理与问题相关的信息以及求得问题的解；如：如果信道畅通，请发绿色信号</li>
<li><strong>控制性知识</strong>：又称为深层知识及元知识，是关于如何运用已有的知识进行问题求解的知识，也称为<strong>关于知识的知识</strong>。</li>
</ol>
<h3 id="按知识的确定性来分"><a class="markdownIt-Anchor" href="#按知识的确定性来分"></a> 按知识的确定性来分</h3>
<ol>
<li><strong>确定性知识</strong>：指其逻辑值为真或假的知识，是精确性知识；如：他是男的</li>
<li><strong>不确定性知识</strong>：是不精确、不完全、模糊性知识的总称。如：今天阴天，可能要下雨</li>
</ol>
<h3 id="按人类的思维及认识方法来分"><a class="markdownIt-Anchor" href="#按人类的思维及认识方法来分"></a> 按人类的思维及认识方法来分</h3>
<ol>
<li><strong>逻辑性知识</strong>：是反映人类逻辑思维过程的知识，一般具有因果关系或难以精确描述的特点，是人类的经验性知识和直观感觉；如：人的为人处事的经验与风格</li>
<li><strong>形象性知识</strong>：通过事物的形象建立起来的知识。</li>
</ol>
<h3 id="按获取方式分"><a class="markdownIt-Anchor" href="#按获取方式分"></a> 按获取方式分</h3>
<ol>
<li><strong>显性知识</strong>: 可通过文字、语言、图形、声音等形式编码记录和传播的知识;</li>
<li><strong>隐性知识</strong>: 指人们长期实践中积累获得的知识,不易用显性知识表达的知识。如:每个人都有不同的审美观。</li>
</ol>
<h1 id="状态空间表示"><a class="markdownIt-Anchor" href="#状态空间表示"></a> 状态空间表示</h1>
<h2 id="问题状态描述"><a class="markdownIt-Anchor" href="#问题状态描述"></a> 问题状态描述</h2>
<h3 id="相关定义"><a class="markdownIt-Anchor" href="#相关定义"></a> 相关定义</h3>
<ol>
<li><strong>状态</strong>：描述某类不同事物间的差别而引入的一组最少变量q0,q1…qn的<br />
有序集合,其矢量形式如下:<br />
Q=[q0,q1…qn]<SUP>T</SUP></li>
<li><strong>算符</strong>：使问题从一种状态变化为另一种状态的手段称为操作符或算符。操作符可为走步、过程、规则、数学算子、运算符号或逻辑符号等。</li>
<li><strong>状态空间</strong>：是一个表示该问题题全部可能状态及其关系的图,它包含三种说明的集合,即所有可能的问题初始状态集合S、操作符集合F以及目标状态集合G。可把状态空间记为三元状态(S,F,G)</li>
<li>状态描述,必须确定3件事:
<ol>
<li>状态描述方式，特别是初始状态描述;</li>
<li>操作符集合及其对状态描述的作用;</li>
<li>目标状态描述的特性</li>
</ol>
</li>
</ol>
<h2 id="状态图示法"><a class="markdownIt-Anchor" href="#状态图示法"></a> 状态图示法</h2>
<ol>
<li>
<p>当用一个图来表示某个状态空间时，图中各节点标上相应的状态描述,而有向弧线旁边标有算符。</p>
</li>
<li>
<p>三要素</p>
<ol>
<li>状态(state）:表示问题解法中每一步问题状况的数据结构;</li>
<li>算符(operator):把问题从一种状态变换为另一种状态的手段;</li>
<li>状态空间:基于解答空间的问题表示和求解方法,它是以状态和算符为基础来表示和求解问题的。</li>
</ol>
</li>
<li>
<p><strong>解</strong>就是从初始状态到目标状态所采用<strong>算符的序列</strong>。使用算符最少的解称为<strong>最优解</strong>。</p>
</li>
</ol>
<h2 id="十五数码问题"><a class="markdownIt-Anchor" href="#十五数码问题"></a> 十五数码问题</h2>
<p>参考<a href="https://cccceb.github.io/2020/01/20/%E5%85%AB%E6%95%B0%E7%A0%81/" target="_blank" rel="noopener">八数码问题</a></p>
<h1 id="问题归约法"><a class="markdownIt-Anchor" href="#问题归约法"></a> 问题归约法</h1>
<ol>
<li>
<p>**归约(problem reduction)**是另一种基于状态空间的问题描述与求解方法。已知问题的描述,通过一系列变换把此问题最终变为一个本原问题集合;这些本原问题的解可以直接得到,从而解决了初始问题</p>
</li>
<li>
<p><strong>问题归约</strong>：问题的描述,通过一系列变换把此问题变为一个子问题集合;这些子问题的解可以直接得到,从而解决了初始问题.<strong>本质是发逆向推理,建立子问题以及子问题的子问题,直到最后把初始问题</strong>归约为一个本原问题集合</p>
</li>
<li>
<p><strong>问题归约法的组成</strong></p>
<ol>
<li>一个初始问题描述</li>
<li>一套把问题变换为子问题的操作符</li>
<li>一套本原问题的描述(<strong>本原问题</strong>:不能再分解或变换且直接可解的子问题)</li>
</ol>
</li>
</ol>
<h2 id="问题归约描述"><a class="markdownIt-Anchor" href="#问题归约描述"></a> 问题归约描述</h2>
<h3 id="汉诺塔问题"><a class="markdownIt-Anchor" href="#汉诺塔问题"></a> 汉诺塔问题</h3>
<ol>
<li>
<p>上述论证允许把原始难题归约（简化)为下列3个子难题:</p>
</li>
<li>
<p>移动圆盘A和B至柱子2的双圆盘难题,如图2.4(a)所示。</p>
</li>
<li>
<p>移动圆盘C至柱子3的单圆盘难题,如图2.4(b)所示。</p>
</li>
<li>
<p>移动圆盘A和B至柱子3的双圆盘难题,如图2.4©所示。</p>
</li>
<li>
<p>子问题2可作为本原问题考虑,因为它的解只包含一步移动。应用一系列相似的推理,子问题1和子问题3也可被归约为本原问题。</p>
</li>
</ol>
<h3 id="问题归约描述-2"><a class="markdownIt-Anchor" href="#问题归约描述-2"></a> 问题归约描述</h3>
<ol>
<li>归约方法应用算符来把问题描述变换为子问题描述。问题归约方法可以应用状态、算符和目标这些表示法来描述问题(这并不意味着问题归约法和状态空间法是一样的)</li>
<li>有问题归约的目的是最终产生具有明显解答的本原问题。这些问题可能是能够由状态空间搜索中走动一步来解决的问题,或者可能是其他具有已知解答的更复杂的问题</li>
<li>汉诺塔问题可以用三元组描述</li>
</ol>
<h2 id="与或图表示"><a class="markdownIt-Anchor" href="#与或图表示"></a> 与或图表示</h2>
<h3 id="相关概念"><a class="markdownIt-Anchor" href="#相关概念"></a> 相关概念</h3>
<ol>
<li>
<p>图表示能够方便地用一个类似于图的结构来表示把问题归约为后继问题的替换集合,画出归约问题图。</p>
</li>
<li>
<p><strong>分解</strong>：把一个复杂问题分解为若干个较为简单的子问题,形成**&quot;与&quot;树**。</p>
</li>
<li>
<p><strong>等价变换</strong>：利用同构或同态的等价变换,把原问题变换为若干个较为容易求解的新问题,形成**&quot;或&quot;树**。</p>
</li>
<li>
<p><strong>与或图</strong>： 在与或图中，一个节点具有任何后继节点,那么这些后继节点既可全为或节点,也可全为与节点。(<strong>注在状态空间搜索中，不存在与节点</strong>)</p>
</li>
<li>
<p>图中的<strong>起始节点</strong>对应于<strong>原始问题描述</strong>,而对应于<strong>本原问题的节点</strong>叫做<strong>终叶节点</strong>。</p>
</li>
<li>
<p><strong>可解节点</strong>：</p>
<ol>
<li>终叶节点是可解节点</li>
<li>某个非终叶节点含有或后继节点,那么只要当其后继节点至少有一个是可解的,此非终叶节点才是可解</li>
<li>某个非终叶节点含有与后继节点,那么只有当其后继节点全部为可解的,此 非终叶节点才是可解的。</li>
</ol>
</li>
<li>
<p><strong>不可解点</strong>：</p>
<ol>
<li>
<p>没有后裔的非终叶节点为不可解节点。</p>
</li>
<li>
<p>某个非终叶节点含有<strong>或后继节点</strong>,那么只有当其全部后裔为不可解时,此非 终叶节点才是不可解的。</p>
</li>
<li>
<p>某个非终叶节点含有<strong>与后继节点</strong>,那么只要当其后裔至少有一个为不可解 时,此非终叶节点才是不可解的。</p>
</li>
</ol>
</li>
<li>
<p><strong>解图</strong>： 为那些可解节点的子图,这些节点能够证明其初始节点是可解的。</p>
</li>
</ol>
<h3 id="与或图构成规则概括"><a class="markdownIt-Anchor" href="#与或图构成规则概括"></a> 与或图构成规则概括</h3>
<ol>
<li>与或图中的每个节点代表一个要解决的单一问题或问题集合。图中所含起始节点对应于原始问题。</li>
<li>对应于本原问题的节点,叫做终叶节点,它没有后裔。</li>
<li>对于把算符应用于问题A的每种可能情况,都把问题变换为一个子问题集合; 有向弧线自A指向后继节点,表示所求得的子问题集合。</li>
<li>代表两个或两个以上子问题集合的每个节点,有向弧线从此节点指向此子 问题集合中的各个节点。由于只有当集合中所有的项都有解时,这个子问题的集合才能 获得解答,所以这些子问题节点叫做与节点。为了区别于或节点,把具有共同父辈的与节后裔的所有弧线用另外一段小弧线连接起来。</li>
<li>在特殊情况下,当只有一个算符可应用于问题,而且这个算符产生具有一个以上子问题的某个集合时,由上述规则(3）和规 则（4）所产生的图可以得到简化。因此,代表子问题集合的中间或节点可以省略</li>
</ol>
<h1 id="谓词逻辑表示"><a class="markdownIt-Anchor" href="#谓词逻辑表示"></a> 谓词逻辑表示</h1>
<h2 id="命题公式及其解释"><a class="markdownIt-Anchor" href="#命题公式及其解释"></a> 命题公式及其解释</h2>
<ol>
<li>
<p><strong>原子公式</strong>：单个命题变元、单个命题常元称为原子公式。</p>
</li>
<li>
<p><strong>命题公式</strong>：由如下规则生成的公式称为命题公式</p>
<ol>
<li>
<p>单个原子公式是命题公式。</p>
</li>
<li>
<p>若A,B是命题公式,则~A,A B,A B,A→B,A 4&gt;B是公式。</p>
</li>
<li>
<p>所有命题公式都是有限次应用1、2得到的符号串。</p>
</li>
</ol>
</li>
<li>
<p><strong>命题公式的解释</strong>：对原子公式的指派</p>
<ol>
<li>
<p>例如:公式G=(AVB)→C的一个解释是:</p>
<p>I(G)= A/T,B/F, C/T</p>
<p>在解释I1(G)下G为真</p>
</li>
<li>
<p>如果一个公式G中有n个不同的原子公式（或简 称原子),则G有2<sup>n</sup>个不同的解释</p>
</li>
</ol>
</li>
<li>
<p><strong>等价命题公式</strong>：如果两个命题公式所含原子公式相同，且在任一解释下，两个命题公式的值相同，则称这两个命题公式为等价命题公式或等价公式</p>
</li>
<li>
<p><strong>常用等价公式</strong></p>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%5CAI_img%5C7.png" alt="" /><br />
<img src="C:%5CUsers%5C86139%5CDesktop%5C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%5CAI_img%5C8.png" alt="" /></p>
</li>
<li>
<p><strong>永真蕴含式</strong>：若命题公式G-&gt;H是恒真的，称其为永真蕴涵式</p>
</li>
</ol>
<h2 id="谓词演算"><a class="markdownIt-Anchor" href="#谓词演算"></a> 谓词演算</h2>
<ol>
<li>
<p>刻画个体性质或个体之间关系的词叫<strong>谓词</strong></p>
</li>
<li>
<p><strong>函数不是谓词</strong></p>
</li>
<li>
<p><strong>原字公式</strong>(atomic formulas)是由<strong>谓词符号</strong>和若干 <strong>项</strong>组成的谓词演算</p>
<ol>
<li>
<p><strong>谓词符号</strong>:规定定义域内的一个相应关系</p>
</li>
<li>
<p><strong>项</strong></p>
<ol>
<li>
<p>变量符号: 扩大命题演算的能力,需要使公式中的命题带有变量。</p>
</li>
<li>
<p>常量符号:是最简单的项,用来表示论域内的物体 或实体。例如,要表示&quot;机器人(ROBOT)在1房间(r1)内</p>
</li>
<li>
<p>函数符号:表示论域内的函数,如&quot;李的母亲和他的父亲结婚&quot;</p>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>若某个变量是经过量化的,就把这个变量叫做<strong>约束变量</strong>,否则叫做<strong>自由变量</strong>。</p>
</li>
</ol>
<h3 id="语法和语义"><a class="markdownIt-Anchor" href="#语法和语义"></a> 语法和语义</h3>
<ol>
<li>
<p><strong>语义规定</strong>包括</p>
</li>
<li>
<p>对于每个谓词符号,必须规定定义域内的一个相应关系</p>
</li>
<li>
<p>对每个常量符号,必须规定定义域内相应的一个实体</p>
</li>
<li>
<p>对每个函数符号,则必须规定定义域内相应的一个函数。</p>
</li>
</ol>
<h3 id="连词和量词"><a class="markdownIt-Anchor" href="#连词和量词"></a> 连词和量词</h3>
<ol>
<li>连词：与，或，蕴含</li>
<li>量词：任意，存在</li>
<li>一些合式公式所构成的任一合取也是一个合式公式。由一些合式公式所构成的任一析取也是一个合式公式。</li>
</ol>
<h2 id="谓词公式"><a class="markdownIt-Anchor" href="#谓词公式"></a> 谓词公式</h2>
<h3 id="谓词公式的定义"><a class="markdownIt-Anchor" href="#谓词公式的定义"></a> 谓词公式的定义</h3>
<ol>
<li>在谓词演算中合式公式的递归定义如下
<ol>
<li>原子谓词公式是合式公式</li>
<li>若A为合式公式,则～A也是一个合式公式。</li>
<li>若A和B都是合式公式,则（AAB),（AVB）,（A→B）和（A←→B)也都是合式公式</li>
<li>若A是合式公式,x为A中的自由变元,则（Vx)A和 ∃ x)A都是合式公式。</li>
<li>只有按上述规则(1）至（4)求得的那些公式,才是合式公式。</li>
</ol>
</li>
</ol>
<h3 id="合式公式的性质"><a class="markdownIt-Anchor" href="#合式公式的性质"></a> 合式公式的性质</h3>
<ol>
<li>
<p>等价：两个合式公式的真值表相同</p>
</li>
<li>
<p>性质<br />
<img src="C:%5CUsers%5C86139%5CDesktop%5C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%5CAI_img%5C1.png" alt="" /><br />
<img src="C:%5CUsers%5C86139%5CDesktop%5C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%5CAI_img%5C2.png" alt="" /></p>
<ol>
<li>注 述最后两个等价关系说明,在一个量化的表达式中的约束变量是一类虚元,它用任何一个不在表达式中出现过的其他变量符号来代替</li>
</ol>
</li>
</ol>
<h2 id="置换与合一"><a class="markdownIt-Anchor" href="#置换与合一"></a> 置换与合一</h2>
<h3 id="置换"><a class="markdownIt-Anchor" href="#置换"></a> 置换</h3>
<ol>
<li>
<p><strong>假元推理</strong>：就是由合式公式W,和W→W。产生合式公式W:的运</p>
</li>
<li>
<p><strong>全称化推理</strong>： ,它是由合式公式(Vx)W(x)产生合式</p>
<p>公式W（A）,其中A为任意常量符号。</p>
</li>
<li>
<p><strong>置换</strong>： 同时应用假元推理和全称化推理,例如,可由合式公式(Vx)(W1(x)→W2(x))和W1(A）生成合式公式W2(A）,即寻找A对x的置换，使W1(A)与W1(x)一致。</p>
<ol>
<li>
<p>置换是<strong>可结合的</strong></p>
</li>
<li>
<p>一般来说，置换是<strong>不可交换的</strong></p>
</li>
</ol>
</li>
<li>
<p><strong>置换</strong>： 是一个形如{t1/v1,…, tn/vn}的有限集,其中每个vi是变量,ti是不同于vi的项（常量、变量或函数）(vi≠ti). 当i≠j时，vi≠vj.</p>
<ol>
<li>被置换元素必是变量，置换元素是项;</li>
<li>置换元素必不同于被置换元素;</li>
<li>在一次置换中，针对同一元素的置换只能出现一次(单次置换的同时性);</li>
<li>无元素组成的置换，成为空置换;</li>
</ol>
</li>
</ol>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%5CAI_img%5C3.png" alt="" /></p>
<ol start="5">
<li><strong>主旨</strong> <strong>是置换前后元素没有重叠(可置换多次)</strong></li>
</ol>
<h3 id="合一"><a class="markdownIt-Anchor" href="#合一"></a> 合一</h3>
<ol>
<li>
<p><strong>合一</strong>：项对变量的置换,以使两表达式一致,叫做合一</p>
</li>
<li>
<p><strong>合一</strong>：E1θ=…=Enθ, 则称置换θ为{E1,…,En}的合一子(unifier). 如果对{E1,…,En}存在这样的合一子, 则称集合{E1,…,En}可合一.</p>
</li>
<li>
<p><strong>一般合一子</strong>： 如果对E的每个合一子θ, 都存在一个置换λ, 使得θ=γ°λ, 则称合一子γ是集合{E1,…,En}的最一般合一子.</p>
<ol>
<li>例：E={P(x,y), P(x,f(b))}, θ1={a/x, f(b)/y}, θ2={b/x, f(b)/y}</li>
</ol>
<p>最一般合一子 γ={f(b)/y}<br />
θ1= γ° {a/x}, θ2= γ° {b/x}</p>
</li>
</ol>
<h1 id="语义网络表示"><a class="markdownIt-Anchor" href="#语义网络表示"></a> 语义网络表示</h1>
<h2 id="语义网络组成"><a class="markdownIt-Anchor" href="#语义网络组成"></a> 语义网络组成</h2>
<ol>
<li>语法部分：决定词汇表中允许有哪些符号,它涉及各个节点和弧线。</li>
<li>结构部分：叙述符号排列的约束条件,指定各弧线连接的节,</li>
<li>过程部分：说明访问过程,这些过程能用来建立和修正描述,以及回答相关问题</li>
<li>语义部分：确定与描述相关的（联想)意义的方法,即确定有关节点的排列j及其占有物和对应弧线。</li>
</ol>
<h2 id="语义网络特点"><a class="markdownIt-Anchor" href="#语义网络特点"></a> 语义网络特点</h2>
<ol>
<li>
<p>把实体的结构、属性与实体间的<strong>因果关系</strong>显式和简明地表达出来,与实体相关的事实、特征和关系可以通过相应的节点弧线推导出来。这样便于以联想方式实现对系统的解释,</p>
</li>
<li>
<p>由于与概念相关的属性和联系被组织在一个相应的节点中,因而使<strong>概念易于受访和学习</strong>。</p>
</li>
<li>
<p><strong>表现问题更加直观,更易于理解</strong>,适于知识工程师与领域专家沟通。语义网络中的继承方式也符合人类的思维习惯。</p>
</li>
<li>
<p>语义网络结构的语义解释依赖于该结构的推理过程而没有结构的约定,因而得到的推理不能保证像谓词逻辑法那样有效。</p>
</li>
<li>
<p>节点间的联系可能是线状、树状或网状的,甚至是递归状的结构,使相应的知识存储和检索可能需要比较复杂的过程</p>
</li>
<li>
<p><strong>谓词逻辑与语义网络等效</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>初始问题</th>
<th>算符</th>
<th>目标</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>谓词逻辑法</td>
<td>合式公式</td>
<td>置换合一消解反演</td>
<td>根结点</td>
<td>nil</td>
</tr>
<tr>
<td>语义网络法</td>
<td>结点</td>
<td>链</td>
<td>目标网络</td>
<td>语义网络</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h2 id="二元语义网络中的关系"><a class="markdownIt-Anchor" href="#二元语义网络中的关系"></a> 二元语义网络中的关系</h2>
<h3 id="类属关系-is-a"><a class="markdownIt-Anchor" href="#类属关系-is-a"></a> 类属关系 is-a</h3>
<h3 id="聚集关系-a-part-of"><a class="markdownIt-Anchor" href="#聚集关系-a-part-of"></a> 聚集关系 A-part-of</h3>
<h3 id="属性关系-have-can-owner"><a class="markdownIt-Anchor" href="#属性关系-have-can-owner"></a> 属性关系  have can  owner</h3>
<p>属性关系表示了对象和其属性之间的联系。</p>
<h3 id="推论关系-fetch"><a class="markdownIt-Anchor" href="#推论关系-fetch"></a> 推论关系 fetch</h3>
<h3 id="相近关系-similar-to-near-to"><a class="markdownIt-Anchor" href="#相近关系-similar-to-near-to"></a> 相近关系 Similar-to, Near-to</h3>
<h3 id="方位关系-located-on"><a class="markdownIt-Anchor" href="#方位关系-located-on"></a> 方位关系  located-on</h3>
<h3 id="空间关系"><a class="markdownIt-Anchor" href="#空间关系"></a> 空间关系</h3>
<h3 id="时间关系-before-after"><a class="markdownIt-Anchor" href="#时间关系-before-after"></a> 时间关系  before/ after</h3>
<h3 id="构成关系"><a class="markdownIt-Anchor" href="#构成关系"></a> 构成关系</h3>
<p>用于表示构成联系，是一种一对多的联系，它的联系的节点间不具有属性继承性</p>
<h2 id="二元语义网络的表示"><a class="markdownIt-Anchor" href="#二元语义网络的表示"></a> 二元语义网络的表示</h2>
<h3 id="西蒙斯斯洛克姆法"><a class="markdownIt-Anchor" href="#西蒙斯斯洛克姆法"></a> 西蒙斯/斯洛克姆法</h3>
<p>提出一种方法允许结点既可以寄表示一个物体或一组物体，也可以表示情况和动作。每一情况结点可以有一组向外的弧，称为<strong>事例框</strong>。</p>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%5CAI_img%5C4.png" alt="" /></p>
<ol>
<li>其中燕从春天到秋天占有一个巢&quot;这个事实的语义网络就如图2.11(b)所示。图中设立了&quot;占有权-1&quot;(OWN-1)节点,表示小燕有自己的巢。当然,小燕还可以有其他东西。所以,占有权-1只是占有权(ownership）的一个实例。而占有权又只是一种特定的&quot;情况&quot;(situation）。小燕是占有权-1的一个特定的&quot;物主&quot;(owner),而巢-1是占有权-1的一个特定的&quot;占有物&quot;(owner)。小燕占有&quot;占有权-1&quot;的时间&quot;从春天(spring)到秋天(fall)&quot;,“春天&quot;和&quot;秋天&quot;又被定为&quot;时间”(time）的实例。</li>
<li>择节点时,首先要弄清节点是用于表示基本的物体或概念的,或是用于多种目的。否则，难以扩网络。</li>
<li>通常把有关一个物体或概念,或一组有关的物体或 体或概念节点与实例节点概念的知识用一个语义网络来表示</li>
</ol>
<h2 id="多元语义网络的表示"><a class="markdownIt-Anchor" href="#多元语义网络的表示"></a> 多元语义网络的表示</h2>
<ol>
<li>方法是：将多元关系转化成一组二元关系的组合，或二元关系的合取。</li>
<li>语义网络中可以引入附加结点，把相关多元信息连在附加结点上</li>
<li>例： 北京大学和清华大学两校篮球队在北大进行的一场比赛的比分是85比 89。</li>
</ol>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%5CAI_img%5C5.png" alt="" /></p>
<h2 id="语义网络的推理过程"><a class="markdownIt-Anchor" href="#语义网络的推理过程"></a> 语义网络的推理过程</h2>
<h3 id="规定"><a class="markdownIt-Anchor" href="#规定"></a> 规定</h3>
<ol>
<li>区分在链的头部和在链的尾部的节点, 把在链的尾部的节点称为<strong>值节点</strong></li>
<li>规定节点的<strong>槽</strong>相当于链,不过取不同的名字而已</li>
<li>网络中的推理过程主要有两种,一种是<strong>继承</strong>,另一种是<strong>匹配</strong>。</li>
</ol>
<h3 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h3>
<ol>
<li>
<p><strong>继承</strong>：是把对事物的描述从概念节点或类节点传递到实例节点</p>
</li>
<li>
<p>继承包括</p>
<ol>
<li>
<p><strong>值继承</strong>：ISA链以外,另外还有一种AKO(是某种）链也可用于语义网络中的描述或特性的继承。AKO是A-KIND-OF的缩写。总之，ISA和AKO链直接地表示类的成员关系以及子类和类之间的关系，提供了一种把知识从某一层传递到另一层的途径。</p>
</li>
<li>
<p><strong>如果需要继承</strong>：道槽值时,可以利用已知信息来计算。例如,可以根据体积和物质的密度来计算积木的重量。进行上述计算的程序称为f-needed(如果需要)程序</p>
</li>
<li>
<p><strong>缺省继承</strong>：把这种具有相当程度的真实性,但又不能十分肯定的值称为&quot;缺省&quot;值。这种类型的值放人槽的DEFAULT(缺省)侧面中。</p>
</li>
</ol>
</li>
</ol>
<h3 id="匹配"><a class="markdownIt-Anchor" href="#匹配"></a> 匹配</h3>
<ol>
<li>
<p>匹配用于解决涉及由几部分组成的事物</p>
</li>
<li>
<p>举例</p>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%5CAI_img%5C6.png" alt="" /></p>
<pre><code>1. TOY-HOUSE77是TOY-HOUSE的一个实例，所以它必须有两个部件 ：砖块和楔块，且砖块必须支撑楔块。**这些知识是通过继承而间接知道的，并不是通过实际的节点和链直接知道的**。因此，我们说虚线所表示的节点和箭头表示的链是**虚节点和虚链**
2. 我们来看这样的结构：已知这个结构有两个部件，一个砖块BRICK12和一人楔块WEDGE18。在图2.33上用虚线箭头表示BRICK12和WEDGE18之间的SUPPORT虚链。因为很容易做部件匹配，所以虚线箭头的位置和方向很容易确定。WEDGE18肯定和作为TOY-HOUSE的一个部件的楔块相匹配，而BRICK12肯定和砖块相匹配
</code></pre>
</li>
</ol>
<h1 id="框架表示"><a class="markdownIt-Anchor" href="#框架表示"></a> 框架表示</h1>
<ol>
<li><strong>框架</strong>提供了一个结构,一种组织。在这个结构或组织中,新的资料可以用经验中得到的概念来分析和解释。因此,框架也是一种<strong>结构化表示法</strong>。通常，采用节点、槽、值表示结构。</li>
<li><strong>框架与语义网络的关系</strong>
<ol>
<li>框架也可以定义为是一组语义网络的节点和槽,这组节点和槽可以描述格式固定的事物、行动和事件。</li>
<li>语义网络可看作节点和弧线的集合,也可以视为框架的集合</li>
</ol>
</li>
</ol>
<h2 id="框架的构成"><a class="markdownIt-Anchor" href="#框架的构成"></a> 框架的构成</h2>
<ol>
<li>
<p>通常由描述事物的各个方面的槽(slot)组成,每个槽可以拥有若干个侧面,而每个侧面又可以拥有若干个值。(槽是属性)</p>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%5CAI_img%5C9.png" alt="" /></p>
</li>
</ol>
<h3 id="举例"><a class="markdownIt-Anchor" href="#举例"></a> 举例</h3>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%5CAI_img%5C11.png" alt="" /></p>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%5CAI_img%5C12.png" alt="" /></p>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%5CAI_img%5C13.png" alt="" /></p>
<h1 id="剧本表示"><a class="markdownIt-Anchor" href="#剧本表示"></a> 剧本表示</h1>
<p>针对时间序列发生的槽值，具有因果关系的槽值</p>
<h2 id="剧本的构成"><a class="markdownIt-Anchor" href="#剧本的构成"></a> 剧本的构成</h2>
<ol>
<li><strong>开场条件</strong>给出在剧本中描述的事件发生的前提<br />
条件</li>
<li><strong>角色</strong>用来表示在剧本所描述的事件中可能出现<br />
的有关人物的一些槽</li>
<li><strong>道具</strong>这是用来表示在剧本所描述的事件中可能现的有关物体的一些槽。</li>
<li><strong>场景</strong>描述事件发生的真实顺序,可以由多个场景组成,每个场景又可以是其它的剧本。</li>
<li><strong>结果</strong> 给出在剧本所描述的事件发生以后通常所产生的结果</li>
</ol>
<h2 id="举例-2"><a class="markdownIt-Anchor" href="#举例-2"></a> 举例</h2>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%5CAI_img%5C14.png" alt="" /></p>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%5CAI_img%5C15.png" alt="" /></p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第5章其他分类技术</title>
    <url>/2020/06/13/%E7%AC%AC5%E7%AB%A0%E5%85%B6%E4%BB%96%E5%88%86%E7%B1%BB%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="最近邻分类器"><a class="markdownIt-Anchor" href="#最近邻分类器"></a> 最近邻分类器</h1>
<ul>
<li>最近邻分类器把每个样例看作d维空间上的一个数据点，其中d是属性个数</li>
<li>对于给定的测试样例，计算邻近性度量，得到该测试样例与训练集中其他数据点的邻近度。</li>
<li><strong>分类</strong>：求出给定样例z的k个距离最近的数据点，然后将给定样例指派到这些数据点中的多数类。如果数量相同，那么随机选择一个即可</li>
</ul>
<h2 id="k的影响"><a class="markdownIt-Anchor" href="#k的影响"></a> K的影响</h2>
<ul>
<li>k太小，则最近邻分类器容易收到由于训练数据中的噪声而产生的过拟合影响</li>
<li>k太大，则最近邻分类器可能会误分类，因为最近邻列表中可能包含远离其近邻的数据点</li>
<li>降低k的影响：根据邻Xi的距离的不同对其作用加权$$w_i=\frac{1}{d(x’,x_i)^2}$$结果使得远离z的训练样例对分类的影响要比那些靠近z的训练样例弱一些</li>
</ul>
<h2 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h2>
<img src="/MyImages/image-20200411141805938.png" alt="image-20200411141805938" style="zoom:67%;" />
<ul>
<li>第5步维多数票决</li>
</ul>
<h2 id="最近邻分类器的特征"><a class="markdownIt-Anchor" href="#最近邻分类器的特征"></a> 最近邻分类器的特征</h2>
<ul>
<li>使用具体的训练实例进行预测，<strong>不必维护源自数据的模型</strong></li>
<li>分类测试样例的<strong>开销很大</strong>，因为需要逐个计算测试样例与训练样例之间的相似度</li>
<li><strong>使用局部信息做预测</strong>，而决策树试图找到一个拟合整个输入空间的全局模型。也正是因此，<strong>KNN对噪声非常敏感</strong></li>
<li><strong>KNN可以生成任意形状的决策边界，更加灵活</strong>。同时，KNN的决策边界还具有<strong>可变性</strong></li>
<li>必须要采用适当的邻近性度量和数据预处理，否则会导致分类错误</li>
</ul>
<h1 id="贝叶斯分类器"><a class="markdownIt-Anchor" href="#贝叶斯分类器"></a> 贝叶斯分类器</h1>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">联</mi><mi mathvariant="normal">合</mi><mi mathvariant="normal">分</mi><mi mathvariant="normal">布</mi><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>Y</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>Y</mi><mo stretchy="false">)</mo><mo>×</mo><mi>P</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mi mathvariant="normal">贝</mi><mi mathvariant="normal">叶</mi><mi mathvariant="normal">斯</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">理</mi><mi>P</mi><mo stretchy="false">(</mo><mi>Y</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>Y</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">联合分布P(X,Y)=P(Y|X)×P(X) = P(X|Y)×P(Y)\\
贝叶斯定理P(Y|X)=\frac{P(X|Y)P(Y)}{P(X)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">联</span><span class="mord cjk_fallback">合</span><span class="mord cjk_fallback">分</span><span class="mord cjk_fallback">布</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">贝</span><span class="mord cjk_fallback">叶</span><span class="mord cjk_fallback">斯</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">理</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<h2 id="贝叶斯定理"><a class="markdownIt-Anchor" href="#贝叶斯定理"></a> 贝叶斯定理</h2>
<ul>
<li>
<p>两队之同的足球比赛:队0和队1.假设65%比赛队0胜出,剩余的比赛队1获胜,队0荻胜的比赛中只有30%在队1的主场,而队1取胜的比赛中75%主场获胜、如果下一场比真在队1的主场进行,哪一支球队最有可能胜出呢?</p>
</li>
<li>
<p>用随机变量X代表东道主,随机变量Y代表比赛的胜利者,X和Y可在集合{0.1}中取值。那么闻题中给出的信息可总结如下</p>
<img src="/MyImages/image-20200411151554305.png" alt="image-20200411151554305" style="zoom:67%;" />
<img src="/MyImages/image-20200411151610845.png" alt="image-20200411151610845" style="zoom: 80%;" />
</li>
<li>
<p>因为P(Y=1|X=1)&gt;R(Y=0|X=1),所以,队1更有机会赢得下一场比赛。</p>
</li>
</ul>
<h2 id="贝叶斯定理在分类中的应用"><a class="markdownIt-Anchor" href="#贝叶斯定理在分类中的应用"></a> 贝叶斯定理在分类中的应用</h2>
<ul>
<li>
<p>对于属性集X=[…],如果有P(Yes|X)&gt;P(No|X)，则分类为Yes</p>
</li>
<li>
<p>但是准确估计P(Y|X)很难，但是可以利用贝叶斯公式来算</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>Y</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>Y</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">P(Y|X)=\frac{P(X|Y)P(Y)}{P(X)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<ul>
<li>其中P(X)总是常数，可以忽略</li>
<li>P(Y)为每个分类在训练记录中所占的比例</li>
<li>P(X|Y)的估计有两种方法，<strong>朴素贝叶斯和贝叶斯信念网络</strong></li>
</ul>
</li>
</ul>
<h2 id="朴素贝叶斯分类器"><a class="markdownIt-Anchor" href="#朴素贝叶斯分类器"></a> 朴素贝叶斯分类器</h2>
<h3 id="条件独立性"><a class="markdownIt-Anchor" href="#条件独立性"></a> 条件独立性</h3>
<ul>
<li>
<p>朴素指的是假设属性之间条件独立，即</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>X</mi><mi mathvariant="normal">∣</mi><mi>Y</mi><mo>=</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mi mathvariant="normal">Π</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>d</mi></msubsup><mi>P</mi><mo stretchy="false">(</mo><msub><mi>X</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi>Y</mi><mo>=</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(X|Y=y)=\Pi^d_{i=1}P(X_i|Y=y) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1491079999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999998em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></span></p>
</li>
<li>
<img src="/MyImages/image-20200411153539715.png" alt="image-20200411153539715" style="zoom:67%;" />
</li>
</ul>
<h3 id="估计分类属性的条件概率"><a class="markdownIt-Anchor" href="#估计分类属性的条件概率"></a> 估计分类属性的条件概率</h3>
<ul>
<li><strong>分类属性</strong>X,根据类y中属性值等于x<sub>i</sub>的训练实例的比例米估计条件概率P(X=x<sub>i</sub>|Y=y)</li>
</ul>
<h3 id="估计连续属性的条件概率"><a class="markdownIt-Anchor" href="#估计连续属性的条件概率"></a> 估计连续属性的条件概率</h3>
<ul>
<li>
<p><strong>离散化</strong>：离散化之后计算比例</p>
</li>
<li>
<p><strong>假设连续变量服从某种概率分布</strong></p>
<ul>
<li>
<p>通常用高斯分布来模拟，然后使用训练数据估计分布的参数</p>
</li>
<li>
<img src="/MyImages/image-20200411154023169.png" alt="image-20200411154023169" style="zoom:80%;" />
</li>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">参</mi><mi mathvariant="normal">数</mi><msub><mi>μ</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mi mathvariant="normal">可</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">用</mi><msub><mi>y</mi><mi>i</mi></msub><mi mathvariant="normal">类</mi><mi mathvariant="normal">所</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">训</mi><mi mathvariant="normal">练</mi><mi mathvariant="normal">记</mi><mi mathvariant="normal">录</mi><mi mathvariant="normal">关</mi><mi mathvariant="normal">于</mi><msub><mi>X</mi><mi>i</mi></msub><mi mathvariant="normal">的</mi><mi mathvariant="normal">均</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">估</mi><mi mathvariant="normal">计</mi></mrow><annotation encoding="application/x-tex">参数\mu_{ij}可以用y_i类所有训练记录关于X_i的均值估计
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord"><span class="mord mathdefault">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">用</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">类</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">训</span><span class="mord cjk_fallback">练</span><span class="mord cjk_fallback">记</span><span class="mord cjk_fallback">录</span><span class="mord cjk_fallback">关</span><span class="mord cjk_fallback">于</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">均</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">估</span><span class="mord cjk_fallback">计</span></span></span></span></span></p>
</li>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">参</mi><mi mathvariant="normal">数</mi><msubsup><mi>σ</mi><mrow><mi>i</mi><mi>j</mi></mrow><mn>2</mn></msubsup><mi mathvariant="normal">可</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">记</mi><mi mathvariant="normal">录</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">差</mi><mi mathvariant="normal">估</mi><mi mathvariant="normal">计</mi></mrow><annotation encoding="application/x-tex">参数\sigma_{ij}^2可以用记录的方差估计
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2472159999999999em;vertical-align:-0.383108em;"></span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">记</span><span class="mord cjk_fallback">录</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">差</span><span class="mord cjk_fallback">估</span><span class="mord cjk_fallback">计</span></span></span></span></span></p>
</li>
</ul>
</li>
</ul>
<h3 id="举例"><a class="markdownIt-Anchor" href="#举例"></a> 举例</h3>
<p><img src="/MyImages/image-20200411154809436.png" alt="image-20200411154809436" /></p>
<ul>
<li>
<p>现要预测X=(有房=否,婚姻状况=已婚,年收入=120K）的类标号</p>
</li>
<li>
<img src="/MyImages/image-20200411154913663.png" alt="image-20200411154913663" style="zoom:80%;" />
</li>
<li>
<p>No的后验概率大，所以认为是No</p>
</li>
</ul>
<h3 id="条件概率的m估计"><a class="markdownIt-Anchor" href="#条件概率的m估计"></a> 条件概率的m估计</h3>
<ul>
<li>
<p><strong>问题</strong>：如果后验概率公式中，某个条件概率为0，则直接导致后验概率为0</p>
</li>
<li>
<p><strong>解决</strong>：使用m估计</p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 30: …ac{n_c+mp}{n+m}$̲$其中

* n是类yi中实例…'>P(x_i|y_i)=\frac{n_c+mp}{n+m}$$其中

* n是类yi中实例总数
* nc是类yi的训练样例中xi的样例数
* m是等价样本大小的参数
* p是用户指定的参数

</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi mathvariant="normal">婚</mi><mi mathvariant="normal">姻</mi><mi mathvariant="normal">状</mi><mi mathvariant="normal">况</mi><mo>=</mo><mi mathvariant="normal">已</mi><mi mathvariant="normal">婚</mi><mi mathvariant="normal">∣</mi><mi>Y</mi><mi>e</mi><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>0</mn><mo>+</mo><mn>3</mn><mo>×</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>3</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mn>3</mn><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>6</mn></mrow><annotation encoding="application/x-tex">P(婚姻状况=已婚|Yes)=(0+3×1/3)/(3+3)=1/6
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord cjk_fallback">婚</span><span class="mord cjk_fallback">姻</span><span class="mord cjk_fallback">状</span><span class="mord cjk_fallback">况</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">已</span><span class="mord cjk_fallback">婚</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">3</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord">6</span></span></span></span></span></p>
</li>
</ul>
<h3 id="朴素贝叶斯分类器的特征"><a class="markdownIt-Anchor" href="#朴素贝叶斯分类器的特征"></a> 朴素贝叶斯分类器的特征</h3>
<ul>
<li><strong>面对孤立的噪声点,朴素贝叶斯分类器是健壮的</strong>。因为在从数据中估计条件概率时,这些点被平均,通过在建模和分类时忽略样例,朴素贝叶斯分类器也<strong>可以处理属性值遗漏问题</strong>。</li>
<li><strong>面对无关属性,该分类器是健壮的</strong>。如果X,是无关属性,那么P(XID）几乎变成了均匀分布。X的类条件概率不会对总的后验概率的计算产生</li>
<li><strong>相关属性可能会降低朴素贝叶斯分类器的性能,因为对这些属性,条件独立的假设已不成立</strong></li>
</ul>
<h2 id="贝叶斯误差率"><a class="markdownIt-Anchor" href="#贝叶斯误差率"></a> 贝叶斯误差率</h2>
<p><img src="/MyImages/image-20200411163743225.png" alt="image-20200411163743225" /></p>
<ul>
<li>
<p>假设美洲鳄和鳄鱼的体长分布都满足高斯分布，二者均值不同</p>
</li>
<li>
<p>x为二者概率相等时的体长</p>
</li>
<li>
<p>定义贝叶斯错误率为</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>r</mi><mo>=</mo><msubsup><mo>∫</mo><mn>0</mn><mi>x</mi></msubsup><mi>P</mi><mo stretchy="false">(</mo><mi mathvariant="normal">鳄</mi><mi mathvariant="normal">鱼</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo><mi>d</mi><mi>X</mi><mo>+</mo><msubsup><mo>∫</mo><mi>x</mi><mi mathvariant="normal">∞</mi></msubsup><mi>P</mi><mo stretchy="false">(</mo><mi mathvariant="normal">鳄</mi><mi mathvariant="normal">鱼</mi><mi mathvariant="normal">∣</mi><mi>X</mi><mo stretchy="false">)</mo><mi>d</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">Error=\int_0^xP(鳄鱼|X)dX+\int_x^\infty P(鳄鱼|X)dX
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.326242em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.414292em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.8129000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord cjk_fallback">鳄</span><span class="mord cjk_fallback">鱼</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.3262420000000006em;vertical-align:-0.9119499999999999em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4142920000000005em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span><span style="top:-3.812900000000001em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord cjk_fallback">鳄</span><span class="mord cjk_fallback">鱼</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span></span></p>
</li>
</ul>
<h1 id="贝叶斯信念网络"><a class="markdownIt-Anchor" href="#贝叶斯信念网络"></a> 贝叶斯信念网络</h1>
<p>规避朴素贝叶斯对属性间相互独立的强制要求</p>
<h1 id="ensemble-methods"><a class="markdownIt-Anchor" href="#ensemble-methods"></a> Ensemble methods</h1>
<img src="/MyImages/image-20200415111014012.png" alt="image-20200415111014012" style="zoom:67%;" />
<ul>
<li>其中Ci是用不同的分类器得到的分类结果</li>
<li>然后将不同分类器的结果进行多数票决</li>
</ul>
<h2 id="装袋-bootstrap-aggregation"><a class="markdownIt-Anchor" href="#装袋-bootstrap-aggregation"></a> 装袋 Bootstrap Aggregation</h2>
<ul>
<li>对于一个样本，使用多数票决来决定分类结果</li>
</ul>
<h2 id="boosting"><a class="markdownIt-Anchor" href="#boosting"></a> Boosting</h2>
<ul>
<li>给不同分类器以不同的权重</li>
<li>最后票据时候考虑权重</li>
</ul>
<h1 id="预测-predication"><a class="markdownIt-Anchor" href="#预测-predication"></a> 预测 Predication</h1>
<ul>
<li>与分类不同，其中属性是连续值，结果也是连续值</li>
<li>就是回归分析，模型是一个函数</li>
</ul>
<h2 id="回归分析"><a class="markdownIt-Anchor" href="#回归分析"></a> 回归分析</h2>
<ul>
<li>线性回归欸和多元回归</li>
<li>分线性回归</li>
<li>其他回归方法:广义线性模型、泊松回归、对数线性模型、回归树</li>
</ul>
<h2 id="线性回归"><a class="markdownIt-Anchor" href="#线性回归"></a> 线性回归</h2>
<ul>
<li>求解参数：最小二乘法</li>
<li>包括一元线性回归和多元线性回归</li>
</ul>
<h2 id="非线性回归"><a class="markdownIt-Anchor" href="#非线性回归"></a> 非线性回归</h2>
<ul>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>w</mi><mn>0</mn></msub><mo>+</mo><msub><mi>w</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msub><mi>w</mi><mn>3</mn></msub><msup><mi>x</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">y=w_0+w_1x+w_2x^2+w_3x^3
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0141079999999998em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0141079999999998em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>模型幂次越高，运算代价大</li>
</ul>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第3章经典逻辑推理</title>
    <url>/2020/06/13/%E7%AC%AC3%E7%AB%A0%E7%BB%8F%E5%85%B8%E9%80%BB%E8%BE%91%E6%8E%A8%E7%90%86/</url>
    <content><![CDATA[<h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1>
<h2 id="推理"><a class="markdownIt-Anchor" href="#推理"></a> 推理</h2>
<ol>
<li>所谓<strong>推理</strong>就是按某种<strong>策略</strong>由<strong>已知判断</strong>推出<strong>另一个判断</strong>的思维过程。将事实与规则借助一些符号来表示，推理过程就可以被形式化</li>
</ol>
<h2 id="推理方式及其分类"><a class="markdownIt-Anchor" href="#推理方式及其分类"></a> 推理方式及其分类</h2>
<h3 id="演绎推理-归纳推理-默认推理"><a class="markdownIt-Anchor" href="#演绎推理-归纳推理-默认推理"></a> 演绎推理、归纳推理、默认推理</h3>
<ol>
<li>
<p>演绎推理：从一般到特殊。例如三段论。</p>
</li>
<li>
<p>归纳推理：从个体到一般。</p>
</li>
<li>
<p>默认推理：缺省推理，在知识不完全的情况下假设某些条已经具备所进行的推理。</p>
</li>
</ol>
<h3 id="确定性-不确定性推理"><a class="markdownIt-Anchor" href="#确定性-不确定性推理"></a> 确定性、不确定性推理</h3>
<h3 id="单调推理-非单调推理"><a class="markdownIt-Anchor" href="#单调推理-非单调推理"></a> 单调推理、非单调推理</h3>
<p>推出的结论是否单调增加</p>
<h3 id="启发式-非启发式推理"><a class="markdownIt-Anchor" href="#启发式-非启发式推理"></a> 启发式、非启发式推理</h3>
<p>所谓启发性知识是指与问题有关且能加快推理进程、求得问题最优解的知识。</p>
<h3 id="基于知识的推理专家系统-统计推理-直觉推理常识性推理"><a class="markdownIt-Anchor" href="#基于知识的推理专家系统-统计推理-直觉推理常识性推理"></a> 基于知识的推理（专家系统） 、统计推理、直觉推理（常识性推理）</h3>
<h2 id="推理的控制策略"><a class="markdownIt-Anchor" href="#推理的控制策略"></a> 推理的控制策略</h2>
<h3 id="正向推理-数据驱动推理"><a class="markdownIt-Anchor" href="#正向推理-数据驱动推理"></a> 正向推理 (数据驱动推理)</h3>
<ol>
<li>基本思想：从用户提供的初始已知事实出发，在<strong>知识库KB</strong>中找出当前可适用的知识，构成<strong>可适用的知识集KS</strong>，然后按某种冲突消解策略从KS中选出一条知识进行推理，并将推出的新事实加入到数据库DB中，作为下一步推理的已知事实。在此之后，再在知识库中选取可适用的知识进行推理。如此重复进行这一过程，直到求得所要求的解。</li>
<li>DB中存的是所有已知的知识，反复判断是否能通过DB中的知识推出结论</li>
<li>示意图<img src="/AI_img/16.png" alt="16" style="zoom:67%;" /></li>
</ol>
<h3 id="逆向推理"><a class="markdownIt-Anchor" href="#逆向推理"></a> 逆向推理</h3>
<img src="/AI_img/17.png" style="zoom:67%;" />
<ol>
<li>不需要别的事实推出的，即为一个证据</li>
</ol>
<h3 id="混合推理"><a class="markdownIt-Anchor" href="#混合推理"></a> 混合推理</h3>
<p>先正向推理后逆向推理 或 先逆向推理后正向推理</p>
<h3 id="双向推理"><a class="markdownIt-Anchor" href="#双向推理"></a> 双向推理</h3>
<p>正向推理与逆向推理<strong>同时</strong>进行，且在推理过程中的某一步上“碰头”。</p>
<h3 id="求解策略"><a class="markdownIt-Anchor" href="#求解策略"></a> 求解策略</h3>
<p>只求一个解，还是求所有解以及最优解</p>
<h3 id="限制策略"><a class="markdownIt-Anchor" href="#限制策略"></a> 限制策略</h3>
<p>限制搜索的深度、宽度、时间、空间等等</p>
<h2 id="模式匹配"><a class="markdownIt-Anchor" href="#模式匹配"></a> 模式匹配</h2>
<h3 id="代换的复合"><a class="markdownIt-Anchor" href="#代换的复合"></a> 代换的复合</h3>
<p>两步(保证不会出现相同的分母以及分子分母相同的情况)</p>
<ol>
<li>
<p>合并</p>
<img src="/AI_img/18.png" style="zoom: 67%;" />
</li>
<li>
<p>删除</p>
<img src="/AI_img/19.png" style="zoom: 67%;" />
</li>
</ol>
<h3 id="举例"><a class="markdownIt-Anchor" href="#举例"></a> 举例</h3>
   <img src="/AI_img/20.png" style="zoom:67%;" />
<h3 id="公式集的合一"><a class="markdownIt-Anchor" href="#公式集的合一"></a> 公式集的合一</h3>
<ol>
<li>
<p>定义 设有公式集F={F1,F2,…,Fn}，若存在一个代换λ使得<strong>F<sub>1</sub>λ=F<sub>2</sub>λ=…=F<sub>n</sub>λ</strong>则称λ为公式集F的一个合一，且称F1,F2,…,Fn是可合一的。<strong>公式集的合一一般不唯一</strong></p>
</li>
<li>
<p>举例</p>
<img src="/AI_img/21.png" style="zoom:67%;" />
<p><strong>置换的时候一般令分母是变量</strong>，用分子换掉分母,用项换掉变量（项包括变量，常量和函数）</p>
</li>
</ol>
<h3 id="最一般的合一"><a class="markdownIt-Anchor" href="#最一般的合一"></a> 最一般的合一</h3>
<ol>
<li>
<p>定义 设σ是公式集F的一个合一，如果对任一个合一θ都存在一个代换λ，使得θ=σ°λ则称σ是一个最一般的合一。<strong>最一般合一是唯一的</strong></p>
</li>
<li>
<p>差异集：两个公式中相同位置处不同符号的集合</p>
<p><strong>例如</strong>：F1:P(x,y,z), F2:P(x,f(a),h(b))<br />
则D1={y,f(a)}, D2={z,h(b)}</p>
</li>
<li>
<p><strong>求解最一般合一</strong></p>
<img src="/MyImages/image-20200407115934367.png" alt="image-20200407115934367" style="zoom:50%;" />
<h4 id="举例-2"><a class="markdownIt-Anchor" href="#举例-2"></a> <strong>举例</strong></h4>
<img src="/MyImages/image-20200407120004829.png" alt="image-20200407120004829" style="zoom:50%;" />
</li>
</ol>
<h1 id="自然演绎推理"><a class="markdownIt-Anchor" href="#自然演绎推理"></a> 自然演绎推理</h1>
<p>从一组已知为真的事实出发，直接运用经典逻辑的推理规则推出结论的过程，称为自然演绎推理。其中，基本的推理规则是P规则、T规则、假言推理、拒取式推理等。</p>
<h2 id="一般形式"><a class="markdownIt-Anchor" href="#一般形式"></a> 一般形式</h2>
<p><img src="/AI_img/23.png" alt="" /></p>
<h2 id="pt规则"><a class="markdownIt-Anchor" href="#pt规则"></a> P/T规则</h2>
<ol>
<li>P规则：在推理的任何步骤都可以引入前提。</li>
<li>T规则：推理时，如果前面步骤中有一个或者多个公式永真蕴含公式S，则可把S引入推理过程中。</li>
</ol>
<h1 id="归结演绎推理-必考"><a class="markdownIt-Anchor" href="#归结演绎推理-必考"></a> 归结演绎推理  (必考)</h1>
<h2 id="子句"><a class="markdownIt-Anchor" href="#子句"></a> 子句</h2>
<ol>
<li>
<p><strong>文字</strong> 在谓词逻辑中，<strong>把原子谓词公式及其否定统称为文字</strong>。如：P(x)， ¬P(x,f(x))， Q(x,g(x))</p>
</li>
<li>
<p><strong>子句</strong> 任何文字的析取式称为子句</p>
<ol>
<li>不包含任何文字的子句称为<strong>空子句；空子句恒为假</strong></li>
</ol>
</li>
</ol>
<h3 id="子句集"><a class="markdownIt-Anchor" href="#子句集"></a> 子句集</h3>
<ol>
<li>合取范式：C1 ∧C2 ∧C3… ∧Cn</li>
<li>子句集:     S= {C1 ,C2 ,C3… ,Cn}</li>
<li><strong>任何谓词公式F都可通过等价关系及推理规则化为相应的子句集S。</strong></li>
</ol>
<h3 id="把谓词公式化成子句集的步骤"><a class="markdownIt-Anchor" href="#把谓词公式化成子句集的步骤"></a> 把谓词公式化成子句集的步骤</h3>
<p>消去蕴含关系和量词符号</p>
<img src="/AI_img/24.png" style="zoom:50%;" />
<img src="/AI_img/25.png" style="zoom: 67%;" />
<img src="/AI_img/26.png" style="zoom: 67%;" />
<h3 id="子句集的性质"><a class="markdownIt-Anchor" href="#子句集的性质"></a> 子句集的性质</h3>
<ol>
<li>
<p>句集中子句之间是合取关系。</p>
</li>
<li>
<p>子句集中的变元受全称量词的约束</p>
</li>
</ol>
<h3 id="子句集的意义"><a class="markdownIt-Anchor" href="#子句集的意义"></a> 子句集的意义</h3>
<ol>
<li><strong>子句集S的不可满足性</strong>：对于任意论域中的任意一个解释，S中的子句不能同时取得真值T。</li>
<li><strong>定理</strong> 设有谓词公式F，其子句集为S，则F不可满足的充要条件是S不可满足。<strong>要证明P→Q永真，只需证明公式F=(P∧¬Q)永假，即S不可满足。</strong></li>
</ol>
<h2 id="herbrand理论了解"><a class="markdownIt-Anchor" href="#herbrand理论了解"></a> Herbrand理论(了解)</h2>
<p>海伯伦构造了一个特殊的论域(海伯伦域)，并证明只要对这个特殊域上的一切解释进行判定，就可知子句集是否不可满足。</p>
<h3 id="海伯伦域"><a class="markdownIt-Anchor" href="#海伯伦域"></a> 海伯伦域</h3>
<p><img src="/AI_img/27.png" alt="" /></p>
<h2 id="鲁滨逊归结原理"><a class="markdownIt-Anchor" href="#鲁滨逊归结原理"></a> 鲁滨逊归结原理</h2>
<ul>
<li>鲁滨逊归结原理的基本思想：
<ul>
<li>检查子句集S中是否包含空子句。
<ul>
<li>若包含，则S不可满足；</li>
<li>若不包含，就在子句集中选择合适的子句进行归结，一旦通过归结能推出空子句，就说明子句集S是不可满足的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="命题逻辑中的归结原理"><a class="markdownIt-Anchor" href="#命题逻辑中的归结原理"></a> 命题逻辑中的归结原理</h3>
<ol>
<li>
<p>若P是原子谓词公式，则称P与¬P为互补文字。在命题逻辑中，P为命题。</p>
</li>
<li>
<p>设C1与C2是子句集中的任意两个子句。如果C1中的文字L1与C2中文字L2互补，那么从C1和C2中分别消去L1和L2，并将两个子句中余下的部分析取，构成一个新子句C12，则称这一过程为<strong>归结</strong>。称C12为C1和C2的<strong>归结式</strong>，C1和C2为C12的<strong>亲本子句。</strong></p>
</li>
<li>
<p><strong>定理</strong> C12是其亲本子句C1与C2的逻辑结论。</p>
<img src="/AI_img/28.png" style="zoom: 33%;" />
</li>
<li>
<p><strong>推论1</strong>：设C1与C2是子句集S中的两个子句，C12是它们的归结式。若用C12代替C1和C2后得到新子句集S1，则由S1的不可满足性可推出原子句集S的不可满足性，即</p>
<p>​		 <strong>S1的不可满足性＝&gt;S的不可满足性</strong></p>
</li>
<li>
<p><strong>推论2</strong> 设C1与C2是子句集S中的两个子句，C12是它们的归结式。若把C12加入S中得到新子句集S2，则S与S2在不可满足的意义上是等价的，即</p>
<p>​		<strong>S2的不可满足性&lt;＝&gt;S的不可满足性</strong></p>
</li>
</ol>
<h3 id="举例-3"><a class="markdownIt-Anchor" href="#举例-3"></a> 举例</h3>
<p><img src="/AI_img/29.png" alt="" /></p>
<h3 id="二元归结式的定义"><a class="markdownIt-Anchor" href="#二元归结式的定义"></a> 二元归结式的定义</h3>
<ol>
<li>
<p>设C1与C2是两个没有相同变元的子句，L1和L2分别是C1和C2中的文字。若σ是L1和¬L2的最一般合一，则称<br />
<strong>C12=(C1σ-{L1σ})∨(C2σ-{L2σ})<strong>为C1和C2的</strong>二元归结式</strong>，L1和L2称为<strong>归结式上的文字</strong>。</p>
</li>
<li>
<p><strong>举例</strong></p>
<p><img src="/AI_img/30.png" alt="" /></p>
<ol>
<li><strong>P 和 Q不能同时约掉，因为我们要选的是互补文字</strong></li>
</ol>
</li>
<li>
<p>子句C1和C2的归结式是下列二元归结式之一：</p>
<ol>
<li>C1与C2的二元归结式；</li>
<li>C1与C2的因子C2σ2的二元归结式；</li>
<li>C1的因子C1σ1与C2的二元归结式；</li>
<li>C1的因子C1σ1与C2的因子C2σ2的二元归结式。</li>
</ol>
</li>
<li>
<p>**结论：**对于一阶谓词逻辑归结原理也是完备的。即，若子句集S不可满足，则必然存在一个从S到空子句的归结演绎；<strong>若存在一个从S到空子句的归结演绎，则S一定是不可满足的。</strong></p>
</li>
</ol>
<h2 id="归结反演"><a class="markdownIt-Anchor" href="#归结反演"></a> 归结反演</h2>
<h3 id="过程"><a class="markdownIt-Anchor" href="#过程"></a> 过程</h3>
<ol>
<li>应用归结原理证明定理的过程称为归结反演。</li>
<li>设P为已知前提的公式集，Q为目标公式(结论)，用归结反演证明Q为真的步骤是：
<ol>
<li>否定Q，得到¬Q；</li>
<li>把¬Q并入到公式集P中，得到{P, ¬Q};</li>
<li>把公式集{P, ¬Q}化为子句集S；</li>
<li>应用归结原理对子句集S中的子句进行归结，并把每次归结得到的归结式都并入S中。如此反复进行，若出现了空子句，则停止归结，此时就证明了Q为真。</li>
</ol>
</li>
</ol>
<h3 id="举例-4"><a class="markdownIt-Anchor" href="#举例-4"></a> 举例</h3>
<p><img src="/AI_img/31.png" alt="" /></p>
<p><img src="/AI_img/32.png" alt="" /></p>
<p><img src="/AI_img/33.png" alt="" /></p>
<h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3>
<ul>
<li>归结时，并不要求把子句集中所有的子句都用到。</li>
<li>在归结过程中，一个子句可以多次被用来进行归结。</li>
</ul>
<h2 id="归结策略"><a class="markdownIt-Anchor" href="#归结策略"></a> 归结策略</h2>
<h3 id="归结的一般过程"><a class="markdownIt-Anchor" href="#归结的一般过程"></a> 归结的一般过程</h3>
<ol>
<li>
<p>S内任意子句两两逐一进行归结，得到一组归结式，称为第一级归结式，记为S1。</p>
</li>
<li>
<p>把S与S1内的任意子句两两逐一进行归结，得到一组归结式，称为第二级归结式，记为S2。</p>
</li>
<li>
<p>S和S1内的子句与S2内的任意子句两两逐一进行归结，得到一组归结式，称为第三级归结式，记为S3。</p>
</li>
<li>
<p>如此继续，直到出现了空子句或者不能再继续归结为止。</p>
</li>
<li>
<p>举例</p>
<p><img src="/AI_img/34.png" alt="" /></p>
</li>
</ol>
<h2 id="删除策略"><a class="markdownIt-Anchor" href="#删除策略"></a> 删除策略</h2>
<ol>
<li>纯文字删除法<br />
如果某文字L在子句集中不存在可与之互补的文字¬L，则称该文字为纯文字。包含纯文字的子句可以删除。</li>
<li>重言式删除法<br />
如果一个子句中同时包含互补文字对，则该字句称为重言式。重言式是永远为真的子句，可以删除。</li>
</ol>
<h2 id="支持集策略"><a class="markdownIt-Anchor" href="#支持集策略"></a> 支持集策略</h2>
<ol>
<li>
<p>对参加归结的子句提出如下限制：</p>
<ol>
<li>每一次归结时，亲本子句中至少有一个是由目标公式的否定所得到的子句，</li>
<li>或者是它的后裔。可以证明，支持集策略是完备的。</li>
</ol>
</li>
<li>
<p>举例</p>
<p><img src="/AI_img/35.png" alt="" /></p>
<ol>
<li>s1是 1-2，1-3，1-4得到，支持集策略主要减少的就是s1的数量</li>
<li>s2开始，就是1-5,1-6,2-5,2-6,</li>
</ol>
<p><img src="/AI_img/36.png" alt="" /></p>
</li>
</ol>
<h2 id="线性输入策略"><a class="markdownIt-Anchor" href="#线性输入策略"></a> 线性输入策略</h2>
<ol>
<li>参加归结的两个子句中必须至少有一个是初始子句集中的子句。线性输入策略可限制生成归结式的数量，具有简单、高效的优点。<strong>但是它是不完备的。</strong></li>
</ol>
<h2 id="单文字子句策略"><a class="markdownIt-Anchor" href="#单文字子句策略"></a> 单文字子句策略</h2>
<p>如果一个子句只包含一个文字，则称它为单文字子句。</p>
<h3 id="思想"><a class="markdownIt-Anchor" href="#思想"></a> 思想</h3>
<ol>
<li>参加归结的两个子句中必须至少有一个是单文字子句</li>
<li>用单文字子句策略归结时，归结式比亲本子句含有较少的文字，这有利于朝着空子句的方向前进，因此它有较高的归结效率。但是，<strong>这种归结策略是不完备的</strong>。当初始子句集中不包含单文字子句时，归结就无法进行</li>
</ol>
<h2 id="祖先过滤策略"><a class="markdownIt-Anchor" href="#祖先过滤策略"></a> 祖先过滤策略</h2>
<p>当对两个子句C1和C2进行归结时，只要它们满足下述任一个条件就可以归结。</p>
<ol>
<li>C1和C2中至少有一个是初始子句集中的子句。</li>
<li>C1和C2中一个是另外一个的祖先子句。<br />
祖先过滤策略是完备的。</li>
</ol>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<ol>
<li>优点：<br />
简单，便于在计算机上实现。</li>
<li>缺点：
<ul>
<li>必须把逻辑公式化成子句集。</li>
<li>不便于阅读与理解。<br />
¬P(x)∨Q(x)没有P(x)→Q(x)直观。</li>
<li>可能丢失控制信息。<br />
下列逻辑公式：<br />
(¬A∧¬B)→C	 ¬A→(B∨C)<br />
(¬A∧¬C)→B	 ¬B→(A∨C)<br />
(¬C∧¬B)→A	 ¬C→(B∨A)<br />
化成子句后都是: A∨B∨C</li>
</ul>
</li>
</ol>
<h1 id="冲突消解策略"><a class="markdownIt-Anchor" href="#冲突消解策略"></a> 冲突消解策略</h1>
<h2 id="冲突"><a class="markdownIt-Anchor" href="#冲突"></a> 冲突</h2>
<ol>
<li>冲突：多个知识都匹配成功。</li>
<li>对于正向推理：多条产生式前件都与已知事实匹配成功</li>
<li>对于逆向推理：多条规则后件都和同一个假设匹配成功<br />
<strong>冲突消解的基本思想都是对知识进行排序</strong></li>
</ol>
<h2 id="几种冲突消解策略排序策略"><a class="markdownIt-Anchor" href="#几种冲突消解策略排序策略"></a> 几种冲突消解策略(排序策略)</h2>
<ol>
<li>按针对性排序<br />
优先选用针对性强的产生式规则。</li>
<li>按已知事实的新鲜性排序<br />
优先选用与较多新事实匹配的规则。</li>
<li>按匹配度排序<br />
在不确定性匹配中，计算两个知识模式的相似度(匹配度)，并对其排序，相似度高的规则先推。</li>
<li>按领域问题特点排序</li>
<li>按上下文限制排序<br />
把规则按照下上文分组，并只能选取组中的规则。</li>
<li>按冗余限制排序<br />
冗余知识越少的规则先推。</li>
<li>按条件个数排序<br />
条件少的规则先推。</li>
</ol>
<h1 id="与或形演绎推理"><a class="markdownIt-Anchor" href="#与或形演绎推理"></a> 与或形演绎推理</h1>
<h2 id="基于规则的演绎推理"><a class="markdownIt-Anchor" href="#基于规则的演绎推理"></a> 基于规则的演绎推理</h2>
<h3 id="规则"><a class="markdownIt-Anchor" href="#规则"></a> 规则</h3>
<ol>
<li>规则是一种比较接近于人们习惯的问题描述方式，用蕴含式（“If →Then”规则）按照这种问题描述方式进行求解的系统称为基于规则的系统，或者叫做规则演绎系统。</li>
<li>规则演绎系统按照推理方式可分为：
<ul>
<li>规则正向演绎系统</li>
<li>规则逆向演绎系统</li>
<li>规则双向演绎系统</li>
</ul>
</li>
</ol>
<h3 id="规则正向演绎系统"><a class="markdownIt-Anchor" href="#规则正向演绎系统"></a> 规则正向演绎系统</h3>
<ol>
<li>
<p>规则正向演绎系统是从已知事实出发，正向使用规则（蕴含式）直接进行演绎，直至到达目标为止。</p>
<ul>
<li>在规则正向演绎系统中，对已知事实和规则都有一定的要求，如果不是所要求的形式，需要进行变换。</li>
</ul>
</li>
<li>
<p>把事实表达式化为非蕴含形式的与/或形的步骤如下：</p>
<ol>
<li>利用 “P→Q⇔﹁P∨Q”，消去蕴含符号；</li>
<li>利用狄.摩根定律及量词转换率把“﹁”移到紧靠谓词的位置，直到否定符号的辖域最多只含一个谓词为止；</li>
<li>重新命名变元，使不同量词约束的变元有不同的名字；</li>
<li>对存在量词量化的变量用skolem函数代替；</li>
<li>消去全称量词，且使各主要合取式中的变元具有不同的变量名。</li>
</ol>
<p><img src="D:%5Cblog%5CCebBlog%5Csource%5CMyImages%5C20.png" alt="" /></p>
</li>
<li>
<p>与或图</p>
<p><img src="D:%5Cblog%5CCebBlog%5Csource%5CMyImages%5C21.png" alt="" /></p>
<ol>
<li>与或图的根节点就是整个事实表达式，叶结点均为事实表达式中的一个文字</li>
<li>解树集中的每个解树都对应着子句集中的一个子句。解树集中每个解树的端节点上的文字的析取就是子句集中的一个子句。</li>
<li>上图所示的与/或图有3个解树，分别对应这以下3个子句：
<ul>
<li>Q(z, a)</li>
<li>﹁R(y)∨ ﹁ S(a, y)</li>
<li>﹁P(y)∨ ﹁ S(a, y)</li>
</ul>
</li>
<li><strong>在第二章问题归约表示中所描述的与/或图表示方法与这里与/或形的与/或图表示有着不同的目的和含义</strong>，因此应用时应加以区分。</li>
</ol>
</li>
</ol>
<h3 id="规则的表示"><a class="markdownIt-Anchor" href="#规则的表示"></a> 规则的表示</h3>
<ol>
<li>
<p>通常要求规则具有如下形式   L→W ，其中L为单文字，W为与/或形公式。不是的要进行转换</p>
</li>
<li>
<p>将规则转换为要求形式的步骤</p>
<p><img src="D:%5Cblog%5CCebBlog%5Csource%5CMyImages%5C22.png" alt="" /></p>
<p><img src="D:%5Cblog%5CCebBlog%5Csource%5CMyImages%5C23.png" alt="" /></p>
</li>
</ol>
<h3 id="谓词逻辑的规则正向演绎过程"><a class="markdownIt-Anchor" href="#谓词逻辑的规则正向演绎过程"></a> 谓词逻辑的规则正向演绎过程</h3>
<ol>
<li>
<p>已知事实的与/或形表示：P(x, y)∨(Q(z)∧R(v, y))</p>
</li>
<li>
<p>规则： P(u, v)→(S(u)∨N(v))</p>
</li>
<li>
<p>目标公式： S(a)∨N(b)∨Q©</p>
</li>
<li>
<p>证明：</p>
<ul>
<li>在谓词逻辑情况下，由于事实、规则及目标中均含有变元，因此，其规则演绎过程还需要用最一般合一对变进行置换。</li>
<li>证明过程可用下图表示。</li>
</ul>
<p><img src="/AI_img/37.png" alt="" /></p>
</li>
</ol>
<h2 id="规则逆向演绎系统"><a class="markdownIt-Anchor" href="#规则逆向演绎系统"></a> 规则逆向演绎系统</h2>
<h3 id="规则逆向演绎推理过程"><a class="markdownIt-Anchor" href="#规则逆向演绎推理过程"></a> 规则逆向演绎推理过程</h3>
<p>规则逆向演绎推理过程是从待证明的问题，即目标公式的与/或树出发，通过逆向地使用蕴含式（B规则），对目标公式的与/或树进行变换，直到得出包含已知事实的终止条件为止</p>
<h3 id="目标公式的与或形变换"><a class="markdownIt-Anchor" href="#目标公式的与或形变换"></a> 目标公式的与/或形变换</h3>
<ol>
<li>
<p>在与/或形逆向演绎推理中，要求目标公式采用与/或形表示，其化简采用与正向系统中对事实表达式处理的对偶形式。</p>
</li>
<li>
<p><strong>步骤</strong></p>
<ol>
<li>要用<strong>存在量词</strong>约束变元的Skolem函数来替换由<strong>全称量词</strong>约束的相应变元，消去全称量词。（隐含着变量受存在量词的约束 ）</li>
<li>再消去**存在量词，**并进行变元换名，使主析取元之间具有不同的变元名。</li>
</ol>
</li>
<li>
<p>举例</p>
<p><img src="/AI_img/38.png" alt="" /></p>
<p><img src="D:%5Cblog%5CCebBlog%5Csource%5CMyImages%5C59.png" alt="" /></p>
</li>
</ol>
<h3 id="b规则的表示形式"><a class="markdownIt-Anchor" href="#b规则的表示形式"></a> B规则的表示形式</h3>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi><mo>→</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">W\to L
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span></span></p>
<ol>
<li>其中前项W为任一与/或形公式，后项L为一单文字</li>
</ol>
<h3 id="已知事实的表示形式"><a class="markdownIt-Anchor" href="#已知事实的表示形式"></a> 已知事实的表示形式</h3>
<ol>
<li>
<p>反向演绎系统的事实表达式限制为<strong>文字合取</strong>形式</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>F</mi><mn>2</mn></msub><mo>∧</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>∧</mo><msub><mi>F</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">F_1\land F_2\land ...\land F_n
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>其中每个F<sub>i</sub>都为单文字，且能单独起作用</p>
</li>
</ol>
<h3 id="推理过程"><a class="markdownIt-Anchor" href="#推理过程"></a> 推理过程</h3>
<ol>
<li>首先用与/或树把目标公式表示出来；</li>
<li>用B规则的右部和与/或树的叶节点进行匹配，并将匹配成功的B规则加入到与/或树中；</li>
<li>重复进行步骤2，直到产生某个终止在事实节点上的一致解图为止。这里的“一致解图”是指在推理过程中所用到的代换应该是一致的。</li>
</ol>
<h3 id="举例-5"><a class="markdownIt-Anchor" href="#举例-5"></a> 举例</h3>
<ol>
<li>
<p>已知事实</p>
<ul>
<li>
<p>f1:  DOG(Fido)                       Fido是一只狗</p>
</li>
<li>
<p>f 2: ¬ BARKS(Fido)                 Fido是不叫的</p>
</li>
<li>
<p>f 3:  WAGS-TAIL(Fido)            Fido摇尾巴</p>
</li>
<li>
<p>f 4:  MEOWS(Myrtle)             Myrtle喵喵叫</p>
</li>
</ul>
</li>
<li>
<p>已知规则</p>
<ul>
<li>r1:  (WAGS-TAIL(x1)∧DOG(x1))→ FRIENDLY(x1)<br />
摇尾巴的狗是温顺的狗</li>
<li>r2:  (FRIENDLY(x2)∧ ¬ BARKS(x2))→ ¬ AFRAID(y2, x2)<br />
温顺又不叫的东西是不值得害怕的</li>
<li>r3:  DOG(x3)→ANIMAL(x3) ：狗为动物</li>
<li>r4:  CAT(x4)→ANIMAL(x4)：猫为动物</li>
<li>r5:  MEOWS(x5)→CAT(x5)：喵喵叫的动物是猫</li>
</ul>
</li>
<li>
<p>问题：是否存在这样的一只猫和一条狗，使得这只猫不害怕这只狗？</p>
<ul>
<li>
<p>即目标公式为**(∃x) (∃y) (CAT(x)∧DOG(y)∧¬AFRAID(x, y))**</p>
</li>
<li>
<p>变换得到</p>
<p><strong>CAT(x)∧DOG(y)∧ ¬ AFRAID(x, y)</strong></p>
</li>
</ul>
</li>
<li>
<p>逆向求解</p>
<p><img src="D:%5Cblog%5CCebBlog%5Csource%5CMyImages%5C60.png" alt="s" /></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第2章数据</title>
    <url>/2020/03/30/%E7%AC%AC2%E7%AB%A0%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h1 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h1>
<ul>
<li>数据：对象和其属性的集合</li>
</ul>
<h2 id="属性与度量"><a class="markdownIt-Anchor" href="#属性与度量"></a> 属性与度量</h2>
<h3 id="属性"><a class="markdownIt-Anchor" href="#属性"></a> 属性</h3>
<ol>
<li><strong>属性</strong>：是对象的性质或特性,它因对象而异,或随时间而变</li>
<li><strong>属性的值</strong>：分配给属性的数值或符号。相同属性可能有不同的值，不同属性可能映射到相同的值。</li>
<li><strong>测量标度</strong>：将数值或符号值与对象的属性相关联的规则（函数）。</li>
</ol>
<h3 id="属性类型"><a class="markdownIt-Anchor" href="#属性类型"></a> 属性类型</h3>
<p><strong>属性的类型</strong>告诉我们,属性的哪些性质反映在用于测量它的值中。注意,通常将属性的类型称作<strong>测量标度的类型</strong>。</p>
<h3 id="属性的不同类型"><a class="markdownIt-Anchor" href="#属性的不同类型"></a> 属性的不同类型</h3>
<ol>
<li>
<p>定性的</p>
<ol>
<li><strong>标称型</strong> 是一个标记，比如学号</li>
<li><strong>序数型</strong> 比如排名</li>
</ol>
</li>
<li>
<p>定量的</p>
<ol>
<li><strong>区间型</strong> 比如天气预报</li>
<li><strong>比率型</strong> 比如温度以长度/时间/计数方式给出</li>
</ol>
</li>
<li>
<p>每种属性类型拥有其上方属性类型上的所有性质和操作。因此,对于标称、序数和区间属性合法的任何性质或操作,对于比率属性也合法。换句话说,<strong>属性类型的定义是累积的</strong></p>
</li>
<li>
<p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%5CKDD_img%5C3.png" alt="" /></p>
<ol>
<li>定性的属性不具有数的大部分性质，即便使用整数表示，也应该像对待符号一样。</li>
<li>定量属性用数表示，离散或连续</li>
</ol>
</li>
</ol>
<h3 id="属性的变换"><a class="markdownIt-Anchor" href="#属性的变换"></a> 属性的变换</h3>
<p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%5CKDD_img%5C4.png" alt="" /></p>
<h3 id="用值的个数描述属性"><a class="markdownIt-Anchor" href="#用值的个数描述属性"></a> 用值的个数描述属性</h3>
<ol>
<li><strong>离散的</strong>：属性具有有限个值或无限可数个值。</li>
<li><strong>连续的</strong>：连续属性是取实数值的属性。</li>
<li>通常,标称和序数属性是二元的或离散的,而区间和比率属性是连续的。然而,<strong>计数属性</strong>（count attribute）是<strong>离教的,<strong>也是</strong>比率属性。</strong></li>
</ol>
<h3 id="非对称的属性"><a class="markdownIt-Anchor" href="#非对称的属性"></a> 非对称的属性</h3>
<p>只有<strong>非零值才重要</strong>的二元属性是<strong>非对称的二元属性</strong>。这类属性 对于关联分析特别重要。例如，如果记录每门误程的学分,则结果数漏集将包含非对称的离歆属性或连续属性。</p>
<h2 id="数据集的类型"><a class="markdownIt-Anchor" href="#数据集的类型"></a> 数据集的类型</h2>
<h3 id="结构化数据的重要性"><a class="markdownIt-Anchor" href="#结构化数据的重要性"></a> 结构化数据的重要性</h3>
<ol>
<li>维度：指数据集中的对象具有的属性数目</li>
<li>稀疏性</li>
<li>分辨率</li>
</ol>
<h3 id="记录型数据"><a class="markdownIt-Anchor" href="#记录型数据"></a> 记录型数据</h3>
<ul>
<li>数据由一组记录构成，每条记录包含一组属性</li>
</ul>
<h4 id="文件数据"><a class="markdownIt-Anchor" href="#文件数据"></a> 文件数据</h4>
<img src="/MyImages/image-20200426190316000.png" alt="image-20200426190316000" style="zoom:50%;" />
<ul>
<li>每一项都是向量的一个属性</li>
<li>值是每个属性出现的次数</li>
</ul>
<h4 id="事务数据"><a class="markdownIt-Anchor" href="#事务数据"></a> 事务数据</h4>
<ul>
<li>每条记录由一组项构成</li>
</ul>
<ol>
<li><strong>事务数据或购物篮数据</strong>：是一种特殊类型的记录数据
<ol>
<li>考患一个杂货店。顾客一次购物所购买的<strong>商品的集合</strong>就构成一个<strong>事务</strong>,而购买的商品是项。这种类型的数据称作购物篮数据</li>
</ol>
</li>
<li><strong>数据矩阵</strong>：如果一个数据集中的所有数据对象都具有相同的数值属性集，则数据集可以看作一个矩阵。</li>
<li><strong>稀疏数据矩阵</strong>：是数据矩阵的一种特殊情况，其中的属性的类型相同并且<strong>是非对称的</strong>。</li>
</ol>
<h3 id="基于图形的数据"><a class="markdownIt-Anchor" href="#基于图形的数据"></a> 基于图形的数据</h3>
<ol>
<li><strong>带有对象之间连续的数据</strong>：对象之间有联系</li>
<li><strong>具有图形对象的数据</strong>：对象本身具有结构，对象包含具有联系的子对象</li>
</ol>
<h3 id="有序数据"><a class="markdownIt-Anchor" href="#有序数据"></a> 有序数据</h3>
<p>对于某些数据类型，属性具有涉及时间或空间序的联系。</p>
<ol>
<li><strong>时序数据</strong></li>
<li><strong>序列数据</strong>：如核苷酸序列</li>
<li><strong>时间序列数据</strong>：如1982到1994年间的月平均气温的时间序列。重要的是考虑<strong>时间自相关</strong>，即如果两个测量的时间很接近,则这些测量的值通常非常相似。</li>
<li><strong>空间数据</strong>：空间数据的一个重要特点是<strong>空间自相关性</strong>（spatial autocorelatio）,即物理上靠近的对象趋向于在其他方面也相似</li>
</ol>
<h3 id="处理非记录型数据"><a class="markdownIt-Anchor" href="#处理非记录型数据"></a> 处理非记录型数据</h3>
<ol>
<li>尝试转换成记录型数据</li>
<li>记录型也存在弊端，应综合考量</li>
</ol>
<h1 id="数据质量"><a class="markdownIt-Anchor" href="#数据质量"></a> 数据质量</h1>
<h2 id="数据质量度量"><a class="markdownIt-Anchor" href="#数据质量度量"></a> 数据质量度量</h2>
<ol>
<li>准确性</li>
<li>完整性</li>
<li>一致性</li>
<li>可信程度</li>
<li>可解释性</li>
<li>获取难度</li>
</ol>
<h2 id="测量和数据收集问题"><a class="markdownIt-Anchor" href="#测量和数据收集问题"></a> 测量和数据收集问题</h2>
<h3 id="测量误差和数据收集错误"><a class="markdownIt-Anchor" href="#测量误差和数据收集错误"></a> 测量误差和数据收集错误</h3>
<ol>
<li><strong>测量误差</strong>：是测量过程导致的。如连续值和真实值之间的误差</li>
<li><strong>数据收集错误</strong>：遗漏数据对象或属性值导致的。</li>
</ol>
<h3 id="噪声和伪像"><a class="markdownIt-Anchor" href="#噪声和伪像"></a> 噪声和伪像</h3>
<ol>
<li><strong>噪声</strong>：是测量误差的随机部分；</li>
</ol>
<h3 id="精度-偏倚和准确率"><a class="markdownIt-Anchor" href="#精度-偏倚和准确率"></a> 精度、偏倚和准确率</h3>
<ol>
<li><strong>精度</strong>：同一个量的<strong>重复测量值</strong>之间的接近程度。常用<strong>标准差</strong>度量。</li>
<li><strong>偏倚</strong>：测量值于被测量之间的系统偏差。用<strong>值集合的均值与测出的已知值之间的差度量</strong></li>
<li><strong>准确率</strong>：被测量的测量值与实际值之间的接近度。</li>
</ol>
<h3 id="离群点"><a class="markdownIt-Anchor" href="#离群点"></a> 离群点</h3>
<ol>
<li><strong>离群点</strong>：偏离大部分数据对象的特征或者相对于该属性的典型值来说是不寻常的值。<strong>但也是真实数据</strong></li>
</ol>
<h3 id="遗漏值"><a class="markdownIt-Anchor" href="#遗漏值"></a> 遗漏值</h3>
<h4 id="原因"><a class="markdownIt-Anchor" href="#原因"></a> 原因</h4>
<ol>
<li>没有收集信息</li>
<li>该属性不适用于此类对象(比如年收入之于儿童)</li>
</ol>
<h4 id="处理"><a class="markdownIt-Anchor" href="#处理"></a> 处理</h4>
<ol>
<li><strong>删除数据对象或属性</strong></li>
<li><strong>估计遗漏值</strong>：插值</li>
<li><strong>忽略遗漏值</strong>：比如聚类的时候</li>
<li><strong>用合适的统计量代替</strong></li>
</ol>
<h3 id="不一致的值"><a class="markdownIt-Anchor" href="#不一致的值"></a> 不一致的值</h3>
<h3 id="重复数据"><a class="markdownIt-Anchor" href="#重复数据"></a> 重复数据</h3>
<p>删除即可</p>
<h2 id="关于应用的问题"><a class="markdownIt-Anchor" href="#关于应用的问题"></a> 关于应用的问题</h2>
<p>从应用的角度考虑数据的质量</p>
<ol>
<li><strong>时效性</strong></li>
<li><strong>相关性</strong></li>
<li><strong>关于数据的知识</strong></li>
</ol>
<h1 id="数据预处理"><a class="markdownIt-Anchor" href="#数据预处理"></a> 数据预处理</h1>
<p>为了让数据更适合挖掘，可以使用</p>
<ol>
<li>数据清洗</li>
<li>聚集</li>
<li>抽样</li>
<li>维归约</li>
<li>特征子集选择</li>
<li>特征创建</li>
<li>离散化和二元化</li>
<li>变量变换</li>
</ol>
<h2 id="数据清洗"><a class="markdownIt-Anchor" href="#数据清洗"></a> 数据清洗</h2>
<p>针对噪声，孤立点，缺失值，不连续数据</p>
<h3 id="对于缺失值"><a class="markdownIt-Anchor" href="#对于缺失值"></a> 对于缺失值</h3>
<h4 id="原因-2"><a class="markdownIt-Anchor" href="#原因-2"></a> 原因</h4>
<ol>
<li>设备失灵</li>
<li>与其他记录不一致而被删除</li>
<li>由于误解而为输入数据</li>
<li>收集数据时，某些数据没有被重视</li>
<li>有些数据可能涉及隐私等问题，收集不到</li>
</ol>
<h4 id="处理-2"><a class="markdownIt-Anchor" href="#处理-2"></a> 处理</h4>
<ol>
<li>忽略这个数据(通常用于标签丢失的情况)</li>
<li>手动填写缺失值</li>
<li>自动填充比如：unknown,均值，基于推理的可能值</li>
</ol>
<h3 id="对于噪声"><a class="markdownIt-Anchor" href="#对于噪声"></a> 对于噪声</h3>
<ul>
<li>指被测量量的随机误差或方差</li>
</ul>
<h4 id="起因"><a class="markdownIt-Anchor" href="#起因"></a> 起因</h4>
<ul>
<li>测量的手段，录入方法，传输过程等导致</li>
<li>也可能是由于技术的限制</li>
<li>命名不一致</li>
</ul>
<h4 id="解决"><a class="markdownIt-Anchor" href="#解决"></a> 解决</h4>
<ol>
<li>分箱：让数据平滑(可能用力过猛)</li>
<li>聚类：聚类可以分离孤立点</li>
<li>回归：建立回归模型</li>
<li>计算机和人工相结合</li>
</ol>
<h2 id="聚集"><a class="markdownIt-Anchor" href="#聚集"></a> 聚集</h2>
<p><strong>聚集</strong>：将两个或多个对象合并成的那个对象。比如，同一个地区合并，等等</p>
<h3 id="目的"><a class="markdownIt-Anchor" href="#目的"></a> 目的</h3>
<ol>
<li><strong>简化数据</strong>：减少数据的属性</li>
<li><strong>改变维度</strong>：理解为改变粒度，上钻和下钻</li>
<li><strong>稳定数据</strong></li>
<li><strong>检测和解决数据值冲突</strong></li>
<li><strong>模式集成</strong>：聚合来自多个源的数据</li>
</ol>
<h2 id="抽样"><a class="markdownIt-Anchor" href="#抽样"></a> 抽样</h2>
<ul>
<li>因为处理整个相关的数据集非常耗费时间，所以使用抽样</li>
<li><strong>抽样定理</strong>
<ul>
<li>如果样本具有代表性，则使用样本与使用整个数据集几乎一样有效</li>
<li>如果样本具有与原始数据集大致相同的(感兴趣的)属性，则该样本具有代表性</li>
</ul>
</li>
</ul>
<h3 id="抽样方法"><a class="markdownIt-Anchor" href="#抽样方法"></a> 抽样方法</h3>
<ol>
<li>简单随机抽样
<ol>
<li>无放回抽样  样本数很大的时候使用</li>
<li>有放回抽样</li>
</ol>
</li>
<li>分层抽样：当总体由不同类型的对象组成,每种类型的对象数量差别很大时,简单随机抽样不能充分地代表不太顾繁出现的对象类型。</li>
<li>渐进抽样</li>
</ol>
<h3 id="渐进抽样"><a class="markdownIt-Anchor" href="#渐进抽样"></a> 渐进抽样</h3>
<ol>
<li><strong>方法</strong>：这些方法从一个小样本开始,然后增加样本容量直至得到足够容量的样本。</li>
</ol>
<h2 id="降维"><a class="markdownIt-Anchor" href="#降维"></a> 降维</h2>
<h3 id="目的-2"><a class="markdownIt-Anchor" href="#目的-2"></a> 目的</h3>
<ol>
<li>避免维灾难</li>
<li>减少挖掘时的算法开销</li>
<li>为了可视化，也使模型更容易理解</li>
<li>去除冗余特征和消除噪声</li>
</ol>
<h3 id="维灾难"><a class="markdownIt-Anchor" href="#维灾难"></a> 维灾难</h3>
<ol>
<li>随着数据维度的增加,许多数据分析变得非常困难。特别是<strong>随着维度增加,数据在它所占据的空间中越来越稀疏</strong>。
<ol>
<li>对于分类,这可能意味没有足够的数据对象来创建模型,将所有可能的对象可靠地指派到一个类。</li>
<li>对于聚类,点之间的密度和距离的定义失去了意义。</li>
</ol>
</li>
<li>结果是分类准确率降低，聚类质量下降</li>
</ol>
<h3 id="维归约的线性代数技术"><a class="markdownIt-Anchor" href="#维归约的线性代数技术"></a> 维归约的线性代数技术</h3>
<ol>
<li><strong>主成分分析 PCA</strong>: 是一种用于连续属性的线性代数技术,它找出新的属性（主成分),这些属性是原属性的线性组合,是相互正交的,并且捕获了数据的最大变差.</li>
<li>步骤
<ol>
<li>求协方差矩阵的特征向量</li>
<li>用特征向量定义新的空间</li>
</ol>
</li>
<li>还有SVD</li>
</ol>
<h2 id="子特征选择-降维的另一种方法"><a class="markdownIt-Anchor" href="#子特征选择-降维的另一种方法"></a> 子特征选择-降维的另一种方法</h2>
<h3 id="目的-3"><a class="markdownIt-Anchor" href="#目的-3"></a> 目的</h3>
<p>去除冗余和不相关的特征</p>
<h3 id="特征选择方法"><a class="markdownIt-Anchor" href="#特征选择方法"></a> 特征选择方法</h3>
<ol>
<li><strong>Brute-force approch</strong> 尝试各种组合，选择最好结果的组合</li>
<li><strong>Embedded approaches</strong> 嵌入式的方法，下游算法可能自然具有降维功能</li>
<li><strong>Filter approaches</strong> 过滤方法</li>
<li>**Wrapper approaches **包装方法</li>
</ol>
<h3 id="特征子集选择体系结构"><a class="markdownIt-Anchor" href="#特征子集选择体系结构"></a> 特征子集选择体系结构</h3>
<ol>
<li>
<p>特征选择过程可以看作由四部分组成：</p>
<ol>
<li>子集评估度量</li>
<li>控制新的特征子集产生的搜索策略</li>
<li>停止搜索判断</li>
<li>验证过程</li>
</ol>
<p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%5CKDD_img%5C8.png" alt="" /></p>
</li>
<li>
<p><strong>子集的数量可能很大</strong>,考察所有的子集可能不现实,因比需要某种停止搜索判断。其策略**通常基于如下一个或多个条件:迭代次数,**子集评估的度量值是否最优或超过给定的阈值,一个特定大小的子集是否已经得到,大小和评估标准是否同时达到,使用搜索策略得到的选择是否可以实现改进。</p>
</li>
</ol>
<h3 id="特征加权"><a class="markdownIt-Anchor" href="#特征加权"></a> 特征加权</h3>
<ol>
<li>特征越重要，权值越大。</li>
<li>可人为设定，也可自动确定。比如<strong>支持向量机</strong>产生分类模型，其中每个特征都赋予一个权值。在<strong>计算余弦相似度时进行的对象规范化</strong>也可看作义类特征加权。</li>
</ol>
<h2 id="特征创建"><a class="markdownIt-Anchor" href="#特征创建"></a> 特征创建</h2>
<p>由原来的属性创建新的属性集，更有效的捕捉数据集中的重要信息。</p>
<h3 id="特征提取"><a class="markdownIt-Anchor" href="#特征提取"></a> 特征提取</h3>
<ol>
<li><strong>定义</strong> 由原始数据创建新的特征集称为特征提取</li>
</ol>
<h3 id="映射数据到新的空间"><a class="markdownIt-Anchor" href="#映射数据到新的空间"></a> 映射数据到新的空间</h3>
<p>从不同的时间挖掘数据</p>
<ol>
<li>如果只有单个周期模式,并且噪声不多,则容易检测到该模式:另一方面,如果有大量周期模式,并且存在大量噪声,则很难检测这些模式。</li>
<li><strong>使用傅里叶变换</strong></li>
<li><strong>小波变换</strong></li>
</ol>
<h3 id="特征构造"><a class="markdownIt-Anchor" href="#特征构造"></a> 特征构造</h3>
<p>将原始数据集的特征转换成适合挖掘的形式</p>
<ol>
<li>例如，对包含质量和体积的数据集可能需要构造密度</li>
</ol>
<h2 id="离散化和二元化"><a class="markdownIt-Anchor" href="#离散化和二元化"></a> 离散化和二元化</h2>
<h3 id="目的-4"><a class="markdownIt-Anchor" href="#目的-4"></a> 目的</h3>
<p>根据不同下游需求选择</p>
<ol>
<li>
<p>将连续属性划分成区间</p>
</li>
<li>
<p>有些算法只接收属性数据(categorical attributes),categorical attributes是标称和序数的统称。关注属性，而非值。</p>
</li>
<li>
<p>通过离散化减少数据大小</p>
</li>
<li>
<p>为后续分析做准备</p>
</li>
</ol>
<h3 id="针对三类属性"><a class="markdownIt-Anchor" href="#针对三类属性"></a> 针对三类属性</h3>
<ol>
<li>标称型</li>
<li>序数型</li>
<li>连续数据</li>
</ol>
<h3 id="二元化"><a class="markdownIt-Anchor" href="#二元化"></a> 二元化</h3>
<ol>
<li>
<p>要使用n=log2<sup>m</sup>上取整个二进制数表示m个属性值</p>
</li>
<li>
<p><strong>注意</strong> 原来有序的数据，赋值后仍要保持有序</p>
</li>
<li>
<p>可能导致复杂化，如无意中建立了转换后的属性之间的联系。</p>
</li>
</ol>
<h3 id="对无标签数据的离散化"><a class="markdownIt-Anchor" href="#对无标签数据的离散化"></a> 对无标签数据的离散化</h3>
<ol>
<li>按数据</li>
<li>频率</li>
<li>K-means</li>
<li>按区间</li>
</ol>
<h3 id="有标签数据的离散化"><a class="markdownIt-Anchor" href="#有标签数据的离散化"></a> 有标签数据的离散化</h3>
<ol>
<li>
<p><strong>基于熵的方法</strong></p>
<ol>
<li>熵的定义</li>
</ol>
<img src="C:\Users\崔恩博\Desktop\数据挖掘\KDD_img\5.png" style="zoom:50%;" />
<p>​			Py= m/m是第i个区间中类j的概率（值的比例）。</p>
<ol start="2">
<li>该划分的总熵e是每个区间的嫡的加权平均,即<img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%5CKDD_img%5C9.png" alt="" /></li>
</ol>
</li>
</ol>
<h3 id="具有过多值的分类属性"><a class="markdownIt-Anchor" href="#具有过多值的分类属性"></a> 具有过多值的分类属性</h3>
<p>对于标称的数据，比如大学的专业，可以利用领域知识合并成大的组，比如工程学，社会科学，或生物科学</p>
<h2 id="数据转换"><a class="markdownIt-Anchor" href="#数据转换"></a> 数据转换</h2>
<p>变量变换是指用于变量的所有值的变换，目的是<strong>使数据更适合挖掘</strong>。两种重要的变量变换类型：简单函数变换和规范化</p>
<h3 id="简单函数"><a class="markdownIt-Anchor" href="#简单函数"></a> 简单函数</h3>
<ol>
<li>使用如x<sup>k</sup>,log<sup>x</sup>,e<sup>x</sup>,1/x,sinx，|x|,x<sup>1/2</sup>等形式</li>
<li>平方根、对数和倒数变换，常用来将不具有高斯(正态）分布的数据变换成具有高斯(正态)分布的数据。</li>
<li>对数变换用于压缩</li>
<li><strong>注意</strong> 变换前后的序是否变化</li>
</ol>
<h3 id="正规化或标准化"><a class="markdownIt-Anchor" href="#正规化或标准化"></a> 正规化或标准化</h3>
<ul>
<li>将数据缩小到一定的范围</li>
</ul>
<ol>
<li>
<p>如果要以某种方法组合不同的变量,则<strong>为了避免具有较大值域的变量左右计算结果</strong>,这种变换常常是必要的</p>
</li>
<li>
<p>由于均值和标准差受离群点的影响很大，因此通常用<strong>中位数</strong>取代均值，用<strong>绝对标准差</strong>，取代标准差</p>
<p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%5CKDD_img%5C10.png" alt="" /></p>
</li>
</ol>
<img src="C:\Users\崔恩博\Desktop\数据挖掘\KDD_img\6.png" style="zoom:50%;" />
<h3 id="属性创建"><a class="markdownIt-Anchor" href="#属性创建"></a> 属性创建</h3>
<h1 id="共性和差异"><a class="markdownIt-Anchor" href="#共性和差异"></a> 共性和差异</h1>
<h2 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h2>
<h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3>
<ol>
<li><strong>相似度</strong>：通常,相似度是非负的,并常常在0(不相似）和1(完全相似)之间取值。</li>
<li><strong>相异度</strong>：通常,术语距离（distance)用作相异度的同义词,正如我们将介绍的,距离常常用来表示特定类型的相异度。有时,相异度在区间[0.1]中取值,但是相异度在0和∞之间取值也很常见</li>
</ol>
<h3 id="变换"><a class="markdownIt-Anchor" href="#变换"></a> 变换</h3>
<p>现在要将相似度转化到特定区间。或在相似度和相异度之间转换。</p>
<ol>
<li>
<p>对于具有有限值域的相异度也能用d=(d-mind)/(mac_d-min_d)映射到[0,1]区间。</p>
</li>
<li>
<p>如果原来的值域在[0,∞]上，那么需要使用非线性变换，井且在新的尺度上,值之间不再具有相同的联系。<strong>例如</strong>对于从0变化到∞的相异度度量,考虑变换d=d/(1+d),相异度0、0.5、2、10、100和1000分别被变换到0、0.33、067、090、0.99和0999.</p>
</li>
<li>
<p><strong>相似度与相异度间转换</strong></p>
<ol>
<li>
<p>如果相似度（相异度）落在[0,1]区间,则相异度（相似度）可以定义为<strong>d=1-s（或s=1-d)</strong>。另一种简单的方法是定义<strong>相似度为负的相异度</strong>（或相反)。</p>
</li>
<li>
<p>一般来说，<strong>任何单调减函数</strong>都可以用来将相异度转换到相似度</p>
</li>
</ol>
</li>
</ol>
<h2 id="简单属性之间的相似度和相异度"><a class="markdownIt-Anchor" href="#简单属性之间的相似度和相异度"></a> 简单属性之间的相似度和相异度</h2>
<h3 id="对于单个标称属性"><a class="markdownIt-Anchor" href="#对于单个标称属性"></a> 对于单个标称属性</h3>
<p><strong>由于标称属性只携带了对象的相异性信息</strong>,因此我们只能说两个对象有相同的值,或者没有。因面在这种情况下,如果属性值匹配,则<strong>相似度定义为1.否则为0;</strong> 相异度用相反的方法定义:如果属性值匹配,相异度为0,否则为1。</p>
<h3 id="对于单个序数属性"><a class="markdownIt-Anchor" href="#对于单个序数属性"></a> 对于单个序数属性</h3>
<ol>
<li>量化时，必须考虑序信息</li>
<li>有时需要考虑区间或比率属性。区间或比率属性的相似度通常转换成相异度。</li>
<li><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%5CKDD_img%5C7.png" alt="" /></li>
</ol>
<h2 id="数据对象之间的相异度"><a class="markdownIt-Anchor" href="#数据对象之间的相异度"></a> 数据对象之间的相异度</h2>
<h3 id="距离"><a class="markdownIt-Anchor" href="#距离"></a> 距离</h3>
<ol>
<li>
<p>欧几里得距离</p>
<p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%5CKDD_img%5C11.png" alt="" /></p>
</li>
<li>
<p>闵可夫斯基据距离</p>
<p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%5CKDD_img%5C12.png" alt="" /></p>
<p>其中r是参数</p>
<ol>
<li>
<p>r=1时，代表汉明距离。时两个具有二元属性的对象之间不同的二进制位的个数</p>
</li>
<li>
<p>r=2代表欧几里得距离</p>
</li>
<li>
<p>r=∞代表对象属性之间的最大距离</p>
<p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%5CKDD_img%5C13.png" alt="" /></p>
</li>
</ol>
</li>
<li>
<p>距离矩阵都是对称的</p>
</li>
</ol>
<h3 id="相异度性质"><a class="markdownIt-Anchor" href="#相异度性质"></a> 相异度性质</h3>
<ol>
<li>非负性</li>
<li>对称性</li>
<li>三角不等式 d(x,z)&lt;=d(x,y)+d(y,z)</li>
<li><strong>注意</strong> 不是所有相异度满足上面所有性质</li>
</ol>
<h2 id="数据对象之间的相似度"><a class="markdownIt-Anchor" href="#数据对象之间的相似度"></a> 数据对象之间的相似度</h2>
<p>对于相似度，<strong>三角不等式通常不成立</strong>。</p>
<h3 id="相似度性质"><a class="markdownIt-Anchor" href="#相似度性质"></a> 相似度性质</h3>
<ol>
<li>仅当x=y时，s(x,y)=1.（0≤s≤1）</li>
<li>对于所有x和y,s(x,y)=s(y,x)（对称性）</li>
</ol>
<h3 id="二进制向量间的相似性"><a class="markdownIt-Anchor" href="#二进制向量间的相似性"></a> 二进制向量间的相似性</h3>
<ul>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>M</mi><mi>C</mi><mo>=</mo><mfrac><mrow><msub><mi>M</mi><mn>00</mn></msub><mo>+</mo><msub><mi>M</mi><mn>11</mn></msub></mrow><mrow><msub><mi>M</mi><mn>01</mn></msub><mo>+</mo><msub><mi>M</mi><mn>10</mn></msub><mo>+</mo><msub><mi>M</mi><mn>11</mn></msub><mo>+</mo><msub><mi>M</mi><mn>00</mn></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">SMC = \frac{M_{00}+M_{11}}{M_{01}+M_{10}+M_{11}+M_{00}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</li>
<li>
<p><strong>Jaccard系数</strong> = $$\frac{M_{11}}{M_{01}+M_{10}+M_{11}}$$</p>
</li>
<li>
<p>注：M01表示p中为0，q中为1的位数</p>
</li>
<li>
<p>举例</p>
<img src="/MyImages/image-20200426234653454.png" alt="image-20200426234653454" style="zoom: 33%;" />
</li>
<li>
<p><strong>余弦相似度</strong>$$cos(d_1,d_2)=\frac{d_1gd_2}{||d_1||||d_2||}$$其中||d||表示d向量的长度</p>
</li>
<li>
<p><strong>举例</strong></p>
<img src="/MyImages/image-20200426235103418.png" alt="image-20200426235103418" style="zoom:50%;" />
</li>
<li>
<p><strong>扩展的Jaccard系数</strong>：可用于连续或计数属性</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>J</mi><mo stretchy="false">(</mo><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>d</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><msub><mi>d</mi><mn>1</mn></msub><mi>g</mi><msub><mi>d</mi><mn>2</mn></msub></mrow><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msub><mi>d</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msub><mi>d</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>−</mo><msub><mi>d</mi><mn>1</mn></msub><mi>g</mi><msub><mi>d</mi><mn>2</mn></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">EJ(d_1,d_2)=\frac{d_1gd_2}{||d_1||^2+||d_2||^2-d_1gd_2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.3074399999999997em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</li>
</ul>
<h2 id="属性对象之间的相关性度量"><a class="markdownIt-Anchor" href="#属性对象之间的相关性度量"></a> 属性对象之间的相关性度量</h2>
<ul>
<li>首先要对对象进行标准化</li>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>p</mi><mi>k</mi><mo mathvariant="normal">′</mo></msubsup><mo>=</mo><mfrac><mrow><msub><mi>p</mi><mi>k</mi></msub><mo>−</mo><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><mrow><mi>s</mi><mi>t</mi><mi>d</mi><mo stretchy="false">(</mo><mi>p</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">p&#x27;_k=\frac{p_k-mean(p)}{std(p)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</li>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>q</mi><mi>k</mi><mo mathvariant="normal">′</mo></msubsup><mo>=</mo><mfrac><mrow><msub><mi>q</mi><mi>k</mi></msub><mo>−</mo><mi>m</mi><mi>e</mi><mi>a</mi><mi>n</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><mrow><mi>s</mi><mi>t</mi><mi>d</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">q&#x27;_k=\frac{q_k-mean(q)}{std(q)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.048892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8018919999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</li>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>l</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>p</mi><mo mathvariant="normal">′</mo></msup><mo separator="true">⋅</mo><msup><mi>q</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">correlation(p,q)=p&#x27;·q&#x27;
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.996332em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
</li>
</ul>
<h2 id="整体的相似性度量"><a class="markdownIt-Anchor" href="#整体的相似性度量"></a> 整体的相似性度量</h2>
<h3 id="法一忽略全零的二值属性"><a class="markdownIt-Anchor" href="#法一忽略全零的二值属性"></a> 法一：忽略全零的二值属性</h3>
<img src="/MyImages/image-20200427165248345.png" alt="image-20200427165248345" style="zoom:50%;" />
<h3 id="法二加权求和"><a class="markdownIt-Anchor" href="#法二加权求和"></a> 法二：加权求和</h3>
<img src="/MyImages/70.png" style="zoom:50%;" />
<h1 id="相关性度量"><a class="markdownIt-Anchor" href="#相关性度量"></a> 相关性度量</h1>
<img src="/MyImages/image-20200527224849508.png" alt="image-20200527224849508" style="zoom:50%;" />
<h1 id="密度"><a class="markdownIt-Anchor" href="#密度"></a> 密度</h1>
<h2 id="欧几里得密度"><a class="markdownIt-Anchor" href="#欧几里得密度"></a> 欧几里得密度</h2>
<ul>
<li>最简单的方法是将区域划分为许多等体积的矩形单元，并将密度定义为单元包含的点的数量</li>
</ul>
<img src="/MyImages/image-20200427165716411.png" alt="image-20200427165716411" style="zoom: 50%;" />
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第4章决策树与模型评估</title>
    <url>/2020/03/30/%E7%AC%AC4%E7%AB%A0%E5%86%B3%E7%AD%96%E6%A0%91%E4%B8%8E%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/</url>
    <content><![CDATA[<h1 id="预备知识"><a class="markdownIt-Anchor" href="#预备知识"></a> 预备知识</h1>
<ol>
<li><strong>分类</strong>：分类任务就是通过学习得到一个**目标函数(分类模型)**f，把每个属性集x映射到一个预先定义的类标号y</li>
</ol>
<h2 id="分类模型用途"><a class="markdownIt-Anchor" href="#分类模型用途"></a> 分类模型用途</h2>
<ol>
<li>描述性建模：分类模型可作为解释性工具，区分vu同类中的对象</li>
<li>预测性建模：还可用于预测未知记录的类标号。<strong>分类技术非常适合预测或描述二元或标称类型的数据集</strong></li>
</ol>
<h1 id="解决分类问题的一般方法"><a class="markdownIt-Anchor" href="#解决分类问题的一般方法"></a> 解决分类问题的一般方法</h1>
<ol>
<li>分类法的例子包括决策树分类法、基于规则的分类法、神经网络、支持向量机和朴素贝叶斯分类法。</li>
<li>算法的主要目标就是建立具有很好的泛化能力模型,即建立能够准确地预测未知样本类标号的模型。</li>
</ol>
<h2 id="分割训练集和检验集"><a class="markdownIt-Anchor" href="#分割训练集和检验集"></a> 分割训练集和检验集</h2>
<ol>
<li>训练集：由类标号已知的记录组成，用于建立分类模型</li>
<li>检验集：由类标号未知的记录组成</li>
</ol>
<h2 id="混淆矩阵与性能度量"><a class="markdownIt-Anchor" href="#混淆矩阵与性能度量"></a> 混淆矩阵与性能度量</h2>
<h3 id="混淆矩阵"><a class="markdownIt-Anchor" href="#混淆矩阵"></a> 混淆矩阵</h3>
<p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%5CKDD_img%5C27.png" alt="" /></p>
<h3 id="性能度量"><a class="markdownIt-Anchor" href="#性能度量"></a> 性能度量</h3>
<p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%5CKDD_img%5C28.png" alt="" /></p>
<p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%5CKDD_img%5C29.png" alt="" /></p>
<h1 id="决策树归纳"><a class="markdownIt-Anchor" href="#决策树归纳"></a> 决策树归纳</h1>
<h2 id="决策树的工作原理"><a class="markdownIt-Anchor" href="#决策树的工作原理"></a> 决策树的工作原理</h2>
<h3 id="决策树组成"><a class="markdownIt-Anchor" href="#决策树组成"></a> 决策树组成</h3>
<ol>
<li>决策树是一种由结点和有向边组成的层次结构</li>
<li>树中包含三种结点
<ol>
<li>根结点</li>
<li>内部结点</li>
<li>叶结点：每个叶结点都赋予一个类标号</li>
</ol>
</li>
<li>非叶节点：包含属性测试条件，用以分开具有不同特性的记录</li>
</ol>
<h2 id="如何建立决策树"><a class="markdownIt-Anchor" href="#如何建立决策树"></a> 如何建立决策树</h2>
<p>找出最佳决策树在计算上是不可行的。通常使用贪心策略，在选择划分数据的属性时，采取一系列局部最优决策来构造决策树。</p>
<h3 id="hunt算法"><a class="markdownIt-Anchor" href="#hunt算法"></a> Hunt算法</h3>
<ol>
<li>通常将训练记录划分成较纯的子集，以递归方式建立决策树</li>
<li>设D<sub>i</sub>是与结点t相关联的训练记录集,而 y={y<sub>1</sub>,y<sub>2</sub>,y<sub>3</sub>,…,y<sub>c</sub>}是类标号，Humt算法的递归定义如下.
<ol>
<li>如果D<sub>t</sub>中所有记录都属于同一个类y<sub>t</sub>,则t是叶结点,用y<sub>t</sub>标记</li>
<li>否则，<strong>则选择一个属性测试条件</strong>，将记录划分成较小的子集。对于测试条件的每个输出，创建一个子女结点，并根据测试结果将记录分布到子女结点中，再递归调用算法</li>
</ol>
</li>
<li>如果属性值的每种组合都在训练数据中出现，并且每种组合都具有唯一的类标号，则Hunt算法是有效的。</li>
</ol>
<h3 id="决策树归纳的设计问题"><a class="markdownIt-Anchor" href="#决策树归纳的设计问题"></a> 决策树归纳的设计问题</h3>
<ol>
<li>如何分裂训练记录：由于在每个非叶结点，都需要选择也给属性测试条件，将记录划分成较小的子集。因此，算法必须要能为不同类型的属性提供测试条件</li>
<li>如何停止分裂过程：需要设计一个结束条件。一般策略是直到所有的记录都属于同一个类，或者所有记录都有相同的属性值。</li>
</ol>
<h2 id="表示属性测试条件的方法"><a class="markdownIt-Anchor" href="#表示属性测试条件的方法"></a> 表示属性测试条件的方法</h2>
<h3 id="二元属性"><a class="markdownIt-Anchor" href="#二元属性"></a> 二元属性</h3>
<p>二元属性的测试条件产生两个可能的输出。表示可以直接二路划分</p>
<h3 id="标称属性"><a class="markdownIt-Anchor" href="#标称属性"></a> 标称属性</h3>
<p>由于标称属性具有多个不同的属性值</p>
<ol>
<li>使用多路划分</li>
<li>创建k个属性值的二元划分的所有2<sup>k-1</sup>-1种方法</li>
</ol>
<h3 id="序数属性"><a class="markdownIt-Anchor" href="#序数属性"></a> 序数属性</h3>
<p>主要注意要维持有序性</p>
<ol>
<li>可以使用二元或多路划分，只要不违背属性值的有序性就可以对属性值进行分组。</li>
<li><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%5CKDD_img%5C30.png" alt="" />
<ol>
<li>a.b可以，而c不行</li>
</ol>
</li>
</ol>
<h3 id="连续属性"><a class="markdownIt-Anchor" href="#连续属性"></a> 连续属性</h3>
<ol>
<li>可以是以单个值分割的二元输出</li>
<li>可以是区间形式的多路输出</li>
</ol>
<h2 id="选择最佳划分的度量"><a class="markdownIt-Anchor" href="#选择最佳划分的度量"></a> 选择最佳划分的度量</h2>
<ol>
<li>用p(i|t) 表示给定结点t中属于类i的记录所占的比例，有时省略t。</li>
<li>对于二分类问题，任意结点的分布都可以记作(p<sub>0</sub>,p<sub>1</sub>)</li>
<li>选择最佳划分的度量通常是<strong>根据划分后子女结点不纯性的程度</strong>。不纯的程度越低，类分布越倾斜</li>
</ol>
<h3 id="度量不纯性"><a class="markdownIt-Anchor" href="#度量不纯性"></a> 度量不纯性</h3>
<p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%5CKDD_img%5C31.png" alt="" /></p>
<ol>
<li>
<p>举例</p>
<p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%5CKDD_img%5C32.png" alt="" /></p>
</li>
<li>
<p>比较</p>
<p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%5CKDD_img%5C33.png" alt="" /></p>
<ol>
<li>
<p>可以看出，不同的度量的结果是一样的</p>
</li>
<li>
<p><strong>但是作为测试条件的属性选择仍然因不纯性对量的选择而异</strong>衡量测试条件的划分效果：</p>
</li>
<li>
<p>比较父节点的不纯度和子女结点的不纯度。二者的差越大，测试条件效果越好。</p>
</li>
<li>
<p>增益Δ</p>
<p><img src="C:%5CUsers%5C%E5%B4%94%E6%81%A9%E5%8D%9A%5CDesktop%5C%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%5CKDD_img%5C34.png" alt="" /></p>
<ol>
<li>I(x)是给定结点的不纯性度量，N是父节点上记录总数，k是属性值的个数，N(vj)是与子女结点Vj相关联的记录个数</li>
<li>对所有测试条件来说，I(parent)是一个不变的值，所以最大化增益就是最小化子女结点的不纯性度量的加权平均值</li>
<li>如果I(parent)是用信息熵来度量，那么熵的差就称为<strong>信息增益</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="二元属性的划分"><a class="markdownIt-Anchor" href="#二元属性的划分"></a> 二元属性的划分</h3>
<h4 id="举例"><a class="markdownIt-Anchor" href="#举例"></a> 举例</h4>
<ol>
<li>
<p>若使用多路划分，需要计算每个属性的Gini指标，然后加权平均</p>
<img src="/MyImages/46.png" style="zoom: 67%;" />
</li>
</ol>
<h3 id="连续属性的划分"><a class="markdownIt-Anchor" href="#连续属性的划分"></a> 连续属性的划分</h3>
<ol>
<li>
<p>如果穷举v，并将记录划分再计算Gini值，那么时间复杂度为O(N<sup>2</sup>)</p>
</li>
<li>
<p>如果将训练数据排序，再从两个相邻的排过序的属性值中**选择中间值（平均下取整）**最为候选结点；若下图，最终选择Gini最小的97作为划分点</p>
<img src="/MyImages/47.png" style="zoom: 67%;" />
</li>
<li>
<p><strong>优化</strong> 排序之后，前三个同属一个类，所以划分肯定不会出现在60到75间(如果这样分会把已经聚类的分割开)；同理，也不会出现在100到200间</p>
</li>
</ol>
<h3 id="增益率"><a class="markdownIt-Anchor" href="#增益率"></a> 增益率</h3>
<ol>
<li>
<p>现在的<strong>问题</strong>是，我们得到的划分属性可能是一个没有预测性的属性，比顾客ID(因为这种划分方法更倾向于属性取值多的属性)。这时因为与该划分相关联的记录太少，以至于不能做出可靠的判断</p>
</li>
<li>
<p><strong>解决</strong></p>
<ol>
<li>限制测试条件只能是二元划分</li>
<li>修改评估划分的标准，把属性测试条件产生的输出数也考虑进去例如使用<strong>增益率</strong></li>
</ol>
</li>
<li>
<p><strong>增益率</strong></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi>a</mi><mi>i</mi><mi>n</mi><mi>r</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mo>=</mo><mfrac><msub><mi mathvariant="normal">Δ</mi><mrow><mi>i</mi><mi>n</mi><mi>f</mi><mi>o</mi></mrow></msub><mrow><mi>S</mi><mi>p</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>I</mi><mi>n</mi><mi>f</mi><mi>o</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">Gain ratio=\frac{Δ _{info}}{SplitInfo}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.2407700000000004em;vertical-align:-0.8804400000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804400000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>其中划分信息Split Info =$$-\sum_{i=1}<sup>kP(v_i)log_2</sup>P(v_i)$$即属性取值的熵</p>
<p>k是划分的总数</p>
<ol>
<li>考虑极端情况，划分之后，每个属性具有相同的记录数，则每个P(v<sub>i</sub>)=1/k，则划分信息等于log<sub>2</sub><sup>k</sup>；这表明，如果某个个属性产生了大量的划分，那么他的划分信息将会很大，从而降低增益率</li>
</ol>
</li>
</ol>
<h2 id="决策树的归纳算法"><a class="markdownIt-Anchor" href="#决策树的归纳算法"></a> 决策树的归纳算法</h2>
<ol>
<li>输入是训练集E和属性集F</li>
<li>步骤：递归的选择最优的属性来划分数据并扩展叶结点</li>
</ol>
<h2 id="算法流程"><a class="markdownIt-Anchor" href="#算法流程"></a> 算法流程</h2>
<img src="/MyImages/48.png" style="zoom:67%;" />
<h3 id="createnode"><a class="markdownIt-Anchor" href="#createnode"></a> createNode</h3>
<p>为决策树建立结点。结点可能是划分条件node.test_cond，也可能是一个类标号node.label</p>
<h3 id="find_best_split"><a class="markdownIt-Anchor" href="#find_best_split"></a> find_best_split</h3>
<p>通过不纯性度量来评估划分，比如使用熵，Gini</p>
<h3 id="classify"><a class="markdownIt-Anchor" href="#classify"></a> Classify</h3>
<p>为叶结点确定类标号。通常将叶结点指派到具有多数记录的类</p>
<h3 id="stopping_cond"><a class="markdownIt-Anchor" href="#stopping_cond"></a> stopping_cond</h3>
<ol>
<li>检查是否所有记录都属于同一个类，或者具有相同的属性值，以决定石头终止决策树的增长。</li>
<li>或者检查记录数是否小于某个最小的阈值</li>
</ol>
<h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3>
<p><strong>决策树过大可能导致过拟合</strong>，可以通过剪枝，增强决策树的泛化能力</p>
<h2 id="id3"><a class="markdownIt-Anchor" href="#id3"></a> ID3</h2>
<h3 id="信息增益"><a class="markdownIt-Anchor" href="#信息增益"></a> 信息增益</h3>
<ol>
<li>
<p>信息熵</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>f</mi><mi>o</mi><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><msub><mi>p</mi><mi>i</mi></msub><mi>l</mi><mi>o</mi><msubsup><mi>g</mi><mn>2</mn><mrow><mo stretchy="false">(</mo><msub><mi>p</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">Info(D)=-\sum _{i=1}^{m}p_i log_2^{(p_i)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.433692em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<ol>
<li>m是标签取值数</li>
</ol>
</li>
<li>
<p>属性的熵</p>
<p>是这个属性所有可能取值的熵的加权平均</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>f</mi><msub><mi>o</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>v</mi></munderover><mfrac><msub><mi>D</mi><mi>j</mi></msub><mrow><mi mathvariant="normal">∣</mi><mi>D</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><mo>×</mo><mi>I</mi><mi>n</mi><mi>f</mi><mi>o</mi><mo stretchy="false">(</mo><msub><mi>D</mi><mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Info_A(D)=\sum_{j=1}^v\frac{D_j}{|D|}×Info(D_j)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0651740000000007em;vertical-align:-1.4137769999999998em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000007em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
</li>
<li>
<p>信息增益</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi>a</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mi>i</mi><mi>n</mi><mi>f</mi><mi>o</mi><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo><mo>−</mo><mi>i</mi><mi>n</mi><mi>f</mi><msub><mi>o</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Gain(A) = info(D)-info_A(D)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span></span></span></span></span></p>
<ol>
<li>info(D)是识别样本中一个标签，所需要的平均信息量</li>
<li>Info<sub>A</sub>(D)用属性A对数据集D进行分割所需要的信息量</li>
</ol>
</li>
</ol>
<h3 id="举例-2"><a class="markdownIt-Anchor" href="#举例-2"></a> 举例</h3>
<p><img src="/MyImages/image-20200402120653031.png" alt="image-20200402120653031" /></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>n</mi><mi>f</mi><mi>o</mi><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mfrac><mn>9</mn><mn>14</mn></mfrac><mi>l</mi><mi>o</mi><msubsup><mi>g</mi><mn>2</mn><mfrac><mn>9</mn><mn>14</mn></mfrac></msubsup><mo>−</mo><mfrac><mn>5</mn><mn>14</mn></mfrac><mi>l</mi><mi>o</mi><msubsup><mi>g</mi><mn>2</mn><mfrac><mn>5</mn><mn>14</mn></mfrac></msubsup><mo>=</mo><mn>0.940</mn><mi>b</mi><mi>i</mi><mi>t</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">Info(D) = -\frac{9}{14}log_2^{\frac {9}{14}}-\frac{5}{14}log_2^{\frac {5}{14}}=0.940bits
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.17662em;"><span style="top:-2.733692em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.5856000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">4</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.17662em;"><span style="top:-2.733692em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.5856000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">4</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266308em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">9</span><span class="mord">4</span><span class="mord">0</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span></span></span></span></span></p>
<img src="/MyImages/image-20200402120840815.png" alt="image-20200402120840815" style="zoom:67%;" />
<h3 id="注意-2"><a class="markdownIt-Anchor" href="#注意-2"></a> 注意</h3>
<ol>
<li>对于连续值，要进行划分</li>
<li>缺点：更加偏好属性取值多的属性</li>
</ol>
<h2 id="c45"><a class="markdownIt-Anchor" href="#c45"></a> C4.5</h2>
<h3 id="将id3的gain改成gainratio"><a class="markdownIt-Anchor" href="#将id3的gain改成gainratio"></a> 将ID3的gain改成gainratio</h3>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>f</mi><msub><mi>o</mi><mi>A</mi></msub><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>v</mi></munderover><mfrac><mrow><mi mathvariant="normal">∣</mi><msub><mi>D</mi><mi>j</mi></msub><mi mathvariant="normal">∣</mi></mrow><mi>D</mi></mfrac><mo>×</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mfrac><mrow><mi mathvariant="normal">∣</mi><msub><mi>D</mi><mi>j</mi></msub><mi mathvariant="normal">∣</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>D</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mi>g</mi><mi>a</mi><mi>i</mi><mi>n</mi><mi>r</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>O</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>g</mi><mi>a</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>f</mi><mi>o</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">split info_A(D)=-\sum _{j=1}^v\frac{|D_j|}{D}×log_2({\frac {|D_j|}{|D|}})\\
gainratiO(A)=\frac {gain(A)}{splitinfo(A)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0651740000000007em;vertical-align:-1.4137769999999998em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000007em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>以gainratio最大的为划分属性</p>
<h3 id="举例-3"><a class="markdownIt-Anchor" href="#举例-3"></a> 举例</h3>
<p>如上例中</p>
<img src="/MyImages/image-20200402120910754.png" alt="image-20200402120910754" style="zoom:50%;" />
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>a</mi><mi>i</mi><mi>n</mi><mi mathvariant="normal">_</mi><mi>r</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mo stretchy="false">(</mo><mi>i</mi><mi>n</mi><mi>c</mi><mi>o</mi><mi>m</mi><mi>e</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0.029</mn><mi mathvariant="normal">/</mi><mn>0.926</mn><mo>=</mo><mn>0.031</mn></mrow><annotation encoding="application/x-tex">gain\_ratio(income) = 0.029/0.926 = 0.031
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">2</span><span class="mord">9</span><span class="mord">/</span><span class="mord">0</span><span class="mord">.</span><span class="mord">9</span><span class="mord">2</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">3</span><span class="mord">1</span></span></span></span></span></p>
<h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3>
<ol>
<li>简单易行</li>
<li>在每个结点对连续属性排序</li>
<li>需要在内存中加载全部数据</li>
<li>不适合大数据集(需要外部排序)</li>
</ol>
<h2 id="cart-分类和回归树"><a class="markdownIt-Anchor" href="#cart-分类和回归树"></a> CART 分类和回归树</h2>
<h3 id="gini系数"><a class="markdownIt-Anchor" href="#gini系数"></a> Gini系数</h3>
<ol>
<li>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 29: …m _{i=1}^mp_i^2$̲$其中P~i~是D中类i的出现…'>gini(D)=1-\sum _{i=1}^mp_i^2$$其中P~i~是D中类i的出现的频率。

</p>
<img src="/MyImages/image-20200402121019254.png" alt="image-20200402121019254" style="zoom:50%;" />
</li>
<li>
<p>gini增益：表示不确定性减少的程度。我们希望gini增益越大越好。</p>
<img src="/MyImages/image-20200402121026358.png" alt="image-20200402121026358" style="zoom:50%;" />
</li>
</ol>
<h3 id="举例-4"><a class="markdownIt-Anchor" href="#举例-4"></a> 举例</h3>
<p>D has 9 tuples in buys_computer = “yes” and 5 in “no”</p>
<ul>
<li>
<img src="/MyImages/image-20200402121114871.png" alt="image-20200402121114871" style="zoom: 50%;" />
</li>
<li>
<p>Suppose the attribute income partitions D into 10 in D1: {low, medium} and 4 in D2</p>
<img src="/MyImages/image-20200402121216503.png" alt="image-20200402121216503" style="zoom:50%;" />
<img src="/MyImages/image-20200402121225181.png" alt="image-20200402121225181" style="zoom:50%;" />
</li>
<li>
<p>but gini{medium,high} is 0.30 and thus the best since it is the lowest</p>
</li>
</ul>
<h3 id="构建树的思想"><a class="markdownIt-Anchor" href="#构建树的思想"></a> 构建树的思想</h3>
<ol>
<li>通过递归，不断的构建二分叉的树</li>
</ol>
<h2 id="三种衡量比较"><a class="markdownIt-Anchor" href="#三种衡量比较"></a> 三种衡量比较</h2>
<ol>
<li>熵增益
<ul>
<li>趋向于多值的属性</li>
</ul>
</li>
<li>增益率
<ul>
<li>趋向于不平衡的样本</li>
</ul>
</li>
<li>Gini 系数
<ul>
<li>缺陷是趋向于多值属性</li>
<li>如果类别数多的时候，时间复杂度大</li>
<li>偏好各类样本基本相等的数据集</li>
</ul>
</li>
</ol>
<h2 id="决策树归纳的特点"><a class="markdownIt-Anchor" href="#决策树归纳的特点"></a> 决策树归纳的特点</h2>
<ul>
<li>决策树归纳是一种构建分类模型的非参数方法。也就是说，它<strong>不要求任何先验假设</strong>，不假定类和其他属性服从一定的概率分布</li>
<li>找到最佳决策树是NP完全问题。许多决策树算法都采取启发式的方法知道对假设空间的搜索</li>
<li>已开发的决策树技术不需要昂贵的计算代价，即使训练集非常大，也可以<strong>快速建立模型</strong>；决策树一旦建立，<strong>未知样本分类也很快</strong>，最坏情况下的时间复杂度是O(w)，其中w是最大深度</li>
<li><strong>直观，易于解释，同时准确率也可以和其他算法媲美</strong></li>
<li>决策树是学习离散值函数的典型代表；然而，<strong>不能很好的推广到某些特定的布尔型问题</strong>。</li>
<li>对于<strong>噪声</strong>有相当好的<strong>鲁棒性</strong></li>
<li><strong>冗余属性不会</strong>对决策树的准确率<strong>造成不利影响</strong></li>
<li><strong>可能产生数据碎片问题</strong>：由于大多数的决策树采用自顶向下的方式建立，因此沿着树向下，记录会越来越少，在叶结点，记录可能太少，对于叶结点代表的类，不能做出具有统计意义的判决，即数据碎片。</li>
<li><strong>子树可能在决策树中重复多次</strong></li>
<li><strong>对连续数据之间复杂关系建模的表达能力较弱</strong></li>
</ul>
<h1 id="过拟合"><a class="markdownIt-Anchor" href="#过拟合"></a> 过拟合</h1>
<ul>
<li>
<p>误差分为<strong>训练误差</strong>和<strong>泛化误差</strong>；好的分类模型应该具有低训练误差和低泛化误差</p>
</li>
<li>
<p>过拟合：泛化误差较高的模型</p>
</li>
<li>
<p>欠拟合：训练和泛化误差都很大</p>
<p><img src="/MyImages/49.png" alt="" /></p>
</li>
</ul>
<h2 id="可能的原因"><a class="markdownIt-Anchor" href="#可能的原因"></a> 可能的原因</h2>
<ul>
<li>与数据有关：
<ul>
<li>可能是噪声和离群点导致树分支过多</li>
<li><strong>缺少样本</strong>，或样本准确性差</li>
</ul>
</li>
<li>与方法有关：构建模型的算法导致的</li>
<li>与模型复杂度有关：与模型的复杂性有关，<strong>模型越复杂，也越容易导致过拟合</strong></li>
</ul>
<h2 id="噪声导致的过分拟合"><a class="markdownIt-Anchor" href="#噪声导致的过分拟合"></a> 噪声导致的过分拟合</h2>
<ul>
<li>
<p>训练集</p>
<img src="/MyImages/50.png" style="zoom:67%;" />
</li>
<li>
<p>校验集</p>
<img src="/MyImages/52.png" style="zoom:67%;" />
</li>
</ul>
<img src="/MyImages/51.png" style="zoom: 67%;" />
<ul>
<li>左图为完全拟合，训练误差为0，但是由于人和海豚会因为不是四条腿的哺乳动物而被错分。</li>
</ul>
<h2 id="缺乏代表性样本导致的过分拟合"><a class="markdownIt-Anchor" href="#缺乏代表性样本导致的过分拟合"></a> 缺乏代表性样本导致的过分拟合</h2>
<p>根据少量训练数据做出分类决策的模型也容易收到过分拟合的影响。由于训练数据缺乏具有代表性的样本，<strong>在没有多少训练记录的情况下，学习算法仍然继续细化</strong>模型就会产生这样的模型</p>
<h2 id="过分拟合与多重比较过程"><a class="markdownIt-Anchor" href="#过分拟合与多重比较过程"></a> 过分拟合与多重比较过程</h2>
<ul>
<li>多重比较过程是一种学习算法，容易出现过拟合的情况。</li>
<li>在决策树增长的过程中，可以进行多种测试，以确定哪个属性能够最好的划分训练数据，只要观察到改进是统计显著的，就选取导致最佳划分的属性来扩展决策树</li>
<li>在这种情况下，我们是在测试$$\Delta(T_0,T_{Xmax}&gt; \alpha )$$而不是$$Delta(T_0,T_x&gt;\alpha )$$。随着k的增加找到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi><mo stretchy="false">(</mo><msub><mi>T</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mrow><mi>X</mi><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>&gt;</mo><mi>α</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Delta(T_0,T_{Xmax}&gt; \alpha )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Δ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">X</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">)</span></span></span></span>$$ 的概率也会增加，导致算法在不经意间增加了一些欺骗性的结点，导致过拟合</li>
<li>当选择属性x<sub>max</sub>的训练记录很少时，也会产生这种现象。</li>
</ul>
<h2 id="泛化误差估计"><a class="markdownIt-Anchor" href="#泛化误差估计"></a> 泛化误差估计</h2>
<img src="/MyImages/53.png" style="zoom:67%;" />
<h3 id="使用再代入估计"><a class="markdownIt-Anchor" href="#使用再代入估计"></a> 使用再代入估计</h3>
<ul>
<li>假设训练数据集可以很好的代表整体数据，因此可以使用训练误差提供对泛化误差的乐观估计</li>
<li>然而训练误差通常是泛化误差的一种很差的估计</li>
</ul>
<h3 id="结合模型复杂度"><a class="markdownIt-Anchor" href="#结合模型复杂度"></a> 结合模型复杂度</h3>
<ul>
<li>
<p>模型越复杂，出现过拟合的几率就越高</p>
</li>
<li>
<p><strong>奥卡姆剃刀定律</strong></p>
<p>给定两个具有相同泛化误差的模型，较简单的模型比复杂的模型更可取</p>
</li>
<li>
<p>上图中左决策树的训练误差为4/24-0.167</p>
</li>
<li>
<p>右边决策树的训练误差为4/24</p>
</li>
</ul>
<h4 id="悲观误差评估"><a class="markdownIt-Anchor" href="#悲观误差评估"></a> 悲观误差评估</h4>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>e</mi><mi>g</mi></msub><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mo stretchy="false">[</mo><mi>e</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>n</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">e_g(T)=\frac {\sum _{i=1}^k[e(t_i)+\Omega(t_i)]}{\sum_{i=1}^kn(t_i)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.857436em;vertical-align:-1.178718em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.678718em;"><span style="top:-2.120992em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.6897100000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9890079999999999em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">]</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.178718em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>​			$$=\frac {e(T)+\Omega(T)}{N_i}$$</p>
<p>其中n(t)是结点t分类的训练记录数，e(t)是被误分类的记录数。k是决策树的叶结点数，e(T)是决策树的总训练误差，Ni是训练记录数，$$\Omega(t_i)$$是每个结点ti对应的罚项。</p>
<ul>
<li>j若设每个结点的罚项为0.5，则
<ul>
<li>左侧的悲观误差估计为$$\frac {4+7×0.5}{24} = 0.3125$$</li>
<li>右侧的悲观误差估计为$$\frac {6+4×0.5}{24} = 0.3333$$</li>
</ul>
</li>
<li><strong>0.5的罚项</strong>：意味着只要至少能够改善一个训练记录的分类，结点就应该扩展，因为扩展一个结点等价于总误差增加0.5，代价比犯一个训练错误小</li>
<li><strong>如果罚项为1</strong>，那么右侧的决策树比左侧的有更好的悲观错误率，这样，除非能够减少一个以上的训练记录的误分类，否则结点不应当扩展</li>
</ul>
<h4 id="最小描述长度原则-mdl"><a class="markdownIt-Anchor" href="#最小描述长度原则-mdl"></a> 最小描述长度原则 MDL</h4>
<h3 id="估计统计上界"><a class="markdownIt-Anchor" href="#估计统计上界"></a> 估计统计上界</h3>
<p>利用泛化误差俩修正训练误差</p>
<h3 id="使用确认集"><a class="markdownIt-Anchor" href="#使用确认集"></a> 使用确认集</h3>
<ul>
<li>把训练数据再分成两个较小的子集，一个用于训练，另一个用作确认</li>
</ul>
<h2 id="处理决策树归纳中的过分拟合"><a class="markdownIt-Anchor" href="#处理决策树归纳中的过分拟合"></a> 处理决策树归纳中的过分拟合</h2>
<h3 id="先剪枝"><a class="markdownIt-Anchor" href="#先剪枝"></a> 先剪枝</h3>
<ul>
<li>
<p>在产生完全的决策树之前停止决策树的生长</p>
</li>
<li>
<p>需要<strong>采用更具有限制性的结束条件</strong></p>
<ul>
<li>
<p>观察到不纯性度量的增益(或估计的泛化误差的改进)低于某个阈值时就停止扩展叶结点。这样可以避免产生过于复杂的子树</p>
<p>然而很难找到合适的阈值。阈值过高导致欠拟合，太低则不能充分解决过拟合</p>
</li>
<li>
<p>所有的样本都属于一个类别时停止</p>
</li>
<li>
<p>所有样本属性值都一样时停止</p>
</li>
<li>
<p>如果划分之后不能提高样本的纯度，那么可以将其剪掉(三种经典方法)</p>
</li>
<li>
<p>当样本数少于给定阈值时停止（适用于样本数很多的时候）</p>
</li>
<li>
<p>在样本中选择具有代表性的样本：机器学习的方法</p>
</li>
<li>
<p>在特征中选择有代表性的特征：去除与目标无关的属性，以此减少内部节点的个数</p>
</li>
</ul>
</li>
</ul>
<h3 id="后剪枝"><a class="markdownIt-Anchor" href="#后剪枝"></a> 后剪枝</h3>
<ul>
<li>
<p>在产生完全的决策树之后，则自底向上的修剪</p>
</li>
<li>
<p>原则</p>
<ul>
<li>如果删除某个结点，能改进泛化误差，那么可以删除</li>
<li>如果两个分支的叶子结点的标签相同，那么可以在分支处进行修剪</li>
<li>MDL 原则</li>
</ul>
</li>
<li>
<p>主要方法</p>
<ul>
<li>用新的叶结点替换子树，该叶结点的标号用多数票决</li>
<li>用子树中最常用的分支代替子树</li>
</ul>
<p>当不能再改进时停止</p>
</li>
<li>
<p>后剪枝的问题是那些被剪掉的子树的计算量被浪费了</p>
</li>
</ul>
<h2 id="决策树构建的其他问题"><a class="markdownIt-Anchor" href="#决策树构建的其他问题"></a> 决策树构建的其他问题</h2>
<h3 id="如果属性是连续值"><a class="markdownIt-Anchor" href="#如果属性是连续值"></a> 如果属性是连续值</h3>
<ul>
<li>因为连续值是不可数的，无法作为分类标准。所以需要采用方法将连续值进行划分</li>
</ul>
<h3 id="存在缺省值"><a class="markdownIt-Anchor" href="#存在缺省值"></a> 存在缺省值</h3>
<ul>
<li>使用某种统计值弥补缺省值</li>
<li>使用概率值来填充</li>
</ul>
<h3 id="构建属性"><a class="markdownIt-Anchor" href="#构建属性"></a> 构建属性</h3>
<ul>
<li>可以基于现有的属性创建新的属性，比如将稀疏的属性重新构建</li>
<li>可以减少碎片，重复，复制
<ul>
<li>碎片：随着构建树，样本的数量越来越少，导致构建的树的分支过多</li>
<li>重复：某个属性沿着被反复测试</li>
<li>复制：子树结构在整棵树中大量重复</li>
</ul>
</li>
</ul>
<h1 id="评估分类器的性能"><a class="markdownIt-Anchor" href="#评估分类器的性能"></a> 评估分类器的性能</h1>
<h2 id="保持方法"><a class="markdownIt-Anchor" href="#保持方法"></a> 保持方法</h2>
<ul>
<li>将原始数据集划分成两个不相交的集合。</li>
<li>划分比例通常根据分析家的判断。例如50-50，或者2:1的比例。</li>
<li><strong>分类器的准确率根据模型在校验集上的准确率估计</strong></li>
</ul>
<h3 id="局限性"><a class="markdownIt-Anchor" href="#局限性"></a> 局限性</h3>
<ul>
<li>用于训练的被<strong>标记样本较少</strong>，因为要保留一部分记录用于校验，因此，<strong>建立的模型不如使用所有被标记样本建立的模型好</strong>。</li>
<li>模型可能<strong>高度依赖于训练集和校验集的构成</strong>
<ul>
<li>训练集越小，模型的方差越大</li>
<li>训练集太大，根据较小的验证集估计的准确率又不太可靠。这样的估计具有很宽的置信区间。最后,训练集和检验集不再是相互独立的。因为训练集和检验集来源于同一个数据集,在一个子集中超出比例的类在另一个子集就低干比例,反之亦然。</li>
</ul>
</li>
</ul>
<h2 id="随机二次抽样"><a class="markdownIt-Anchor" href="#随机二次抽样"></a> 随机二次抽样</h2>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">设</mi><mi>a</mi><mi>c</mi><msub><mi>c</mi><mi>i</mi></msub><mi mathvariant="normal">是</mi><mi mathvariant="normal">第</mi><mi>i</mi><mi mathvariant="normal">次</mi><mi mathvariant="normal">迭</mi><mi mathvariant="normal">代</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">模</mi><mi mathvariant="normal">型</mi><mi mathvariant="normal">准</mi><mi mathvariant="normal">确</mi><mi mathvariant="normal">率</mi><mspace linebreak="newline"></mspace><mi mathvariant="normal">总</mi><mi mathvariant="normal">准</mi><mi mathvariant="normal">确</mi><mi mathvariant="normal">率</mi><mi mathvariant="normal">位</mi><mi>a</mi><mi>c</mi><msub><mi>c</mi><mrow><mi>s</mi><mi>u</mi><mi>b</mi></mrow></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><mi>a</mi><mi>c</mi><msub><mi>c</mi><mi>i</mi></msub><mi mathvariant="normal">/</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">设acc_i是第i次迭代的模型准确率\\
总准确率位acc_{sub}=\sum _{i=1}^kacc_i/k
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">设</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">第</span><span class="mord mathdefault">i</span><span class="mord cjk_fallback">次</span><span class="mord cjk_fallback">迭</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">模</span><span class="mord cjk_fallback">型</span><span class="mord cjk_fallback">准</span><span class="mord cjk_fallback">确</span><span class="mord cjk_fallback">率</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">准</span><span class="mord cjk_fallback">确</span><span class="mord cjk_fallback">率</span><span class="mord cjk_fallback">位</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.1137820000000005em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361130000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span></span></p>
<h3 id="局限性-2"><a class="markdownIt-Anchor" href="#局限性-2"></a> 局限性</h3>
<ul>
<li>会遇到与保持方法同样的问题，因为在训练阶段没有利用尽可能多的数据</li>
<li>没有控制每个记录用于训练和检验的次数，因此，有些用于选练的记录使用的频率可能比其他记录高得多</li>
</ul>
<h2 id="交叉抽样"><a class="markdownIt-Anchor" href="#交叉抽样"></a> 交叉抽样</h2>
<p>在该方法中，每个记录用于训练的次数相同</p>
<h3 id="二折交叉验证"><a class="markdownIt-Anchor" href="#二折交叉验证"></a> 二折交叉验证</h3>
<ul>
<li>将数据分为<strong>相同大小</strong>的两个子集，一个做训练集，另一个做校验集。然后互换角色。</li>
<li>总误差位两次误差的<strong>和</strong></li>
</ul>
<h3 id="k折交叉验证"><a class="markdownIt-Anchor" href="#k折交叉验证"></a> k折交叉验证</h3>
<ul>
<li>把数据分为大小<strong>相同的 k份</strong>,在每次运行**,选择其中一份作检验集**,而其余的全作为训练集,该过程<strong>重复k 次</strong>,使得<strong>每份数据都用于检验恰好一次</strong>。</li>
<li>总误差是所有k次运行的误差之和</li>
</ul>
<h4 id="留一法"><a class="markdownIt-Anchor" href="#留一法"></a> 留一法</h4>
<ul>
<li>k折法的一种特殊情况，令k=N</li>
<li>优点是
<ul>
<li>尽可能多的利用训练数据，有效覆盖了整个数据集</li>
<li>校验集之间是互斥的</li>
</ul>
</li>
<li>缺点是
<ul>
<li>过程需要重复N次，计算开销大</li>
<li>每个校验集只有一个记录，性能估计度量的方差偏高</li>
</ul>
</li>
</ul>
<h2 id="自助法-boot-strap"><a class="markdownIt-Anchor" href="#自助法-boot-strap"></a> 自助法 boot strap</h2>
<ul>
<li>
<p>之前的方法都是不放回抽样，训练集和检验集都不包含重复记录</p>
</li>
<li>
<p><strong>自助法是有放回抽样</strong></p>
</li>
<li>
<p>如果原始数据有N个记录,可以证明,平均来说,大小为N的自助样本大约包合原始数据中**63.2%**的纪录。</p>
</li>
<li>
<p>没有被抽中的样本将称为校验集的一部分，这样每次都会得到自主样本准确率的一个估计$$\epsilon_i$$</p>
</li>
<li>
<p>重复b次，产生b个自助样本</p>
</li>
</ul>
<h3 id="632自助"><a class="markdownIt-Anchor" href="#632自助"></a> .632自助</h3>
<p>通过组合每个自助样本的准确率（$$\epsilon _i$$）和由包含所有标记样本的训练集计算的准确率(acc<sub>s</sub>)和计算总准确率(acc<sub>bout</sub>)</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>c</mi><msub><mi>c</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mi>b</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>b</mi></munderover><mo stretchy="false">(</mo><mn>0.632</mn><mo>×</mo><msub><mi>ϵ</mi><mi>i</mi></msub><mo>+</mo><mn>0.368</mn><mo>×</mo><mi>a</mi><mi>c</mi><msub><mi>c</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">acc_{out}=\frac{1}{b}\sum _{i=1}^b(0.632×\epsilon _i+0.368×acc_i)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.1137820000000005em;vertical-align:-1.277669em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361130000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mord">3</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">ϵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">3</span><span class="mord">6</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<h1 id="模型评价"><a class="markdownIt-Anchor" href="#模型评价"></a> 模型评价</h1>
<h2 id="模型评估矩阵"><a class="markdownIt-Anchor" href="#模型评估矩阵"></a> 模型评估矩阵</h2>
<h3 id="混淆矩阵-2"><a class="markdownIt-Anchor" href="#混淆矩阵-2"></a> 混淆矩阵</h3>
<table>
<thead>
<tr>
<th></th>
<th><strong>Predicted class</strong></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Actual class</strong></td>
<td>Class=Yes</td>
<td>Class=No</td>
</tr>
<tr>
<td>Class=Yes</td>
<td>TP</td>
<td>FN</td>
</tr>
<tr>
<td>Class=No</td>
<td>FP</td>
<td>TN</td>
</tr>
</tbody>
</table>
<h3 id="acc-正确率"><a class="markdownIt-Anchor" href="#acc-正确率"></a> Acc 正确率</h3>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>c</mi><mi>c</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>N</mi></mrow><mrow><mi>T</mi><mi>P</mi><mo>+</mo><mi>T</mi><mi>N</mi><mo>+</mo><mi>F</mi><mi>P</mi><mo>+</mo><mi>F</mi><mi>N</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">Acc(M) = \frac {TP+TN}{TP+TN+FP+FN}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">c</span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.1296600000000003em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<ul>
<li>
<p><strong>错分率 = 1 - Acc</strong></p>
</li>
<li>
<p><strong>灵敏度/精度 = $$\frac {TP}{TP+FP}$$</strong></p>
</li>
<li>
<p><strong>特效性 =  $$\frac {TN}{TN+FN}$$</strong></p>
</li>
</ul>
<p>通常需要多度量联合使用</p>
<h3 id="代价矩阵"><a class="markdownIt-Anchor" href="#代价矩阵"></a> 代价矩阵</h3>
<table>
<thead>
<tr>
<th></th>
<th>Predicted class</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Actualclass</td>
<td>C(i|j)</td>
<td><strong>Class=Yes</strong></td>
<td><strong>Class=No</strong></td>
</tr>
<tr>
<td></td>
<td><strong>Class=Yes</strong></td>
<td>C(Yes|Yes)</td>
<td>C(No|Yes)</td>
</tr>
<tr>
<td></td>
<td><strong>Class=No</strong></td>
<td>C(Yes|No)</td>
<td>C(No|No)</td>
</tr>
</tbody>
</table>
<p>用来衡量错分的代价</p>
<h3 id="四个常用指标"><a class="markdownIt-Anchor" href="#四个常用指标"></a> 四个常用指标</h3>
<img src="/MyImages/39.png" style="zoom: 33%;" />
<img src="/MyImages/40.png" style="zoom:50%;" />
<ul>
<li>准确率偏向C(Yes|Yes) &amp; C(Yes|No)</li>
<li>召回率偏向C(Yes|Yes) &amp; C(No|Yes)</li>
<li>F 偏向于C(No|No)</li>
</ul>
<h2 id="模型评估方法"><a class="markdownIt-Anchor" href="#模型评估方法"></a> 模型评估方法</h2>
<h3 id="roc曲线"><a class="markdownIt-Anchor" href="#roc曲线"></a> ROC曲线</h3>
<ul>
<li>用于衡量可靠性</li>
</ul>
<h3 id="保持法"><a class="markdownIt-Anchor" href="#保持法"></a> 保持法</h3>
<ul>
<li>将数据集划分成两个部分：2份做训练，1份做测试</li>
<li>可以随机抽样k次，反复使用保持法，准确率为k次的平均值</li>
</ul>
<h3 id="k折交叉验证-2"><a class="markdownIt-Anchor" href="#k折交叉验证-2"></a> k折交叉验证</h3>
<ul>
<li>将样本进行k次划分，每次以第i份为测试集，剩下k-1个训练样本</li>
<li><strong>留1交叉验证</strong>：令k等于样本个数，每次只拿出其中的一个作为测试样本；适用于小规模数据</li>
</ul>
<h3 id="bootstrap"><a class="markdownIt-Anchor" href="#bootstrap"></a> bootstrap</h3>
<ul>
<li>
<p>针对样本数较少的情况</p>
</li>
<li>
<p>进行有放回抽样来得到测试集</p>
</li>
<li>
<p>将样本进行d次有放回抽样，得到d个样本的数据集，包括训练集和测试集。重复b次，计算准确率</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>c</mi><msub><mi>c</mi><mrow><mi>o</mi><mi>u</mi><mi>t</mi></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mi>b</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>b</mi></munderover><mo stretchy="false">(</mo><mn>0.632</mn><mo>×</mo><msub><mi>ϵ</mi><mi>i</mi></msub><mo>+</mo><mn>0.368</mn><mo>×</mo><mi>a</mi><mi>c</mi><msub><mi>c</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">acc_{out}=\frac{1}{b}\sum _{i=1}^b(0.632×\epsilon _i+0.368×acc_i)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.1137820000000005em;vertical-align:-1.277669em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361130000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mord">3</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">ϵ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">3</span><span class="mord">6</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第6章问题求解与搜索策略</title>
    <url>/2020/06/13/%E7%AC%AC6%E7%AB%A0%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3%E4%B8%8E%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1>
<ul>
<li>通过搜索得到的图称为<strong>搜索图</strong>，<strong>搜索图是状态空间图的一个子集</strong>。由搜索图中的所有节点及反向指针所构成的集合是一棵树，称为<strong>搜索树</strong>。根据搜索树可给出问题的解。</li>
</ul>
<h1 id="状态空间的搜索策略"><a class="markdownIt-Anchor" href="#状态空间的搜索策略"></a> 状态空间的搜索策略</h1>
<img src="D:\MyBlog\source\MyImages\image-20200412114449945.png" alt="image-20200412114449945" style="zoom: 50%;" />
<h2 id="状态空间的一般搜索过程"><a class="markdownIt-Anchor" href="#状态空间的一般搜索过程"></a> 状态空间的一般搜索过程</h2>
<ul>
<li>OPEN表 记录没走过的结点</li>
<li>CLOSE表 记录走过的结点</li>
<li>父指针 记录从目标返回的路径</li>
</ul>
<h3 id="搜索的一般过程"><a class="markdownIt-Anchor" href="#搜索的一般过程"></a> 搜索的一般过程</h3>
<img src="D:\MyBlog\source\MyImages\image-20200412114636539.png" alt="image-20200412114636539" style="zoom: 50%;" />
<h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h3>
<ul>
<li>不能将父节点扩展为子节点</li>
<li>如果某个结点在其他路径中出现过，那么该节点的父节点应该通过从原始节点到该节点的代价来决定，由代价小的作为父节点</li>
<li>问题的解是由初始结点到目标结点上的算符构成</li>
<li>如果在搜索中一直找不到目标节点，而且OPEN表中不再有可供扩展的节点，则搜索失败。</li>
</ul>
<h2 id="盲目搜索"><a class="markdownIt-Anchor" href="#盲目搜索"></a> 盲目搜索</h2>
<ul>
<li>搜索过程中不使用与问题有关的经验信息</li>
<li>采用固定策略对OPEN表排序</li>
<li>搜索效率低</li>
<li>不适合大空间的实际问题求解</li>
</ul>
<h3 id="广度优先搜索"><a class="markdownIt-Anchor" href="#广度优先搜索"></a> 广度优先搜索</h3>
<ul>
<li>
<p>基本思想：从初始节点S0开始，逐层地对节点进行扩展并考察它是否为目标节点。在第n层的节点没有全部扩展并考察之前，不对第n＋1层的节点进行扩展</p>
</li>
<li>
<p>OPEN表中节点总是按进入的先后顺序排列，先进入的节点排在前面，后进入的排在后面。</p>
</li>
<li>
<p>过程</p>
<img src="D:\MyBlog\source\MyImages\image-20200412121743631.png" alt="image-20200412121743631" style="zoom: 50%;" />
</li>
<li>
<p>特点：</p>
<ul>
<li>优点：只要问题有解，那么广度搜索总能得到路径最短的解</li>
<li>缺点：盲目性较大，过程中可能引入很多无用结点，导致搜索效率低下</li>
</ul>
</li>
</ul>
<h3 id="深度优先搜索"><a class="markdownIt-Anchor" href="#深度优先搜索"></a> 深度优先搜索</h3>
<ul>
<li>
<p>&amp;BFS :深度优先搜索与广度优先搜索的唯一区别是：广度优先搜索是将节点n的子节点放入到OPEN表的尾部，而深度优先搜索是把节点n的子节点放入到OPEN表的首部。</p>
</li>
<li>
<p><strong>过程</strong>：</p>
<img src="D:\MyBlog\source\MyImages\image-20200412122348085.png" alt="image-20200412122348085" style="zoom:80%;" />
</li>
<li>
<p><strong>特点</strong>：</p>
<ul>
<li>不是完备的，如果问题的解不在正在搜索的分支上，而该分支又是无穷分支，则就不可能得到解。</li>
</ul>
</li>
</ul>
<h3 id="有界深度优先搜索"><a class="markdownIt-Anchor" href="#有界深度优先搜索"></a> 有界深度优先搜索</h3>
<ul>
<li>
<p>基本思想：设定一个深度上界，当达到深度上届仍未出现目标结点时，就换一个分支继续搜索</p>
</li>
<li>
<p>搜索过程</p>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200412122855031.png" alt="image-20200412122855031" /></p>
</li>
<li>
<p><strong>特点</strong>：如果问题有解，并且路径长度小于dm，那么一定可以找到。但是恰当的给出dm是困难的</p>
</li>
<li>
<p><strong>改进</strong>：</p>
<ul>
<li>先任意设定一个较小的数作为dm，然后进行上述的有界深度优先搜索，当搜索达到了指定的深度界限dm仍未发现目标节点，并且CLOSE表中仍有待扩展节点时，就将这些节点送回OPEN表，同时增大深度界限dm，继续向下搜索。如此不断地增大dm，只要问题有解，就一定可以找到它。但此时找到的解不一定是最优解</li>
<li>为了找到最优解，可增设一个表R，每找到目标节点Sg后，就把它放入到R的前面，并令dm等于该目标节点所对应的路径长度，然后继续搜索。由于后求得的解的路径长度不会超过先求得的解的路径长度，所以后求得的解一定是最优解</li>
</ul>
</li>
</ul>
<h3 id="代价树的广度优先搜索"><a class="markdownIt-Anchor" href="#代价树的广度优先搜索"></a> 代价树的广度优先搜索</h3>
<ul>
<li>
<p>基本思想：每次从OPEN表中选择代价最小的结点进行扩展。即OPEN表中的结点在任意时刻都是按代价从小到大排序</p>
</li>
<li>
<p>特点：如果有解，那么一定可以找出最优解</p>
</li>
<li>
<p>过程</p>
<img src="D:\MyBlog\source\MyImages\image-20200413103048933.png" alt="image-20200413103048933" style="zoom: 50%;" />
</li>
</ul>
<h3 id="代价树的深度优先搜索"><a class="markdownIt-Anchor" href="#代价树的深度优先搜索"></a> 代价树的深度优先搜索</h3>
<img src="D:\MyBlog\source\MyImages\image-20200416093024223.png" alt="image-20200416093024223" style="zoom: 50%;" />
<h2 id="启发式搜索"><a class="markdownIt-Anchor" href="#启发式搜索"></a> 启发式搜索</h2>
<ul>
<li>在搜索过程中引入与问题有关的经验</li>
<li>引入估价函数来估计结点位于解路径上的希望</li>
<li><strong>按照估价函数大小对OPEN表重排</strong></li>
<li><strong>每次将估计函数最小的结点进行扩展</strong></li>
</ul>
<h3 id="a算法"><a class="markdownIt-Anchor" href="#a算法"></a> A算法</h3>
<ul>
<li>**估价函数为$$f(n)=g(n)+h(n)$$**的算法称为A算法
<ul>
<li>其中<strong>g(x)</strong> 为从起始状态到当前状态x的代价；有利于搜索的完备性，但<strong>影响搜索的效率</strong></li>
<li><strong>h(x)</strong> 为从当前状态x到目标状态的估计代价（启发函数）；有利于提高搜索的效率，但<strong>影响搜索的完备性</strong></li>
</ul>
</li>
</ul>
<h4 id="举例"><a class="markdownIt-Anchor" href="#举例"></a> 举例</h4>
<img src="D:\MyBlog\source\MyImages\image-20200416094014475.png" alt="image-20200416094014475" style="zoom: 50%;" />
<h3 id="a算法-2"><a class="markdownIt-Anchor" href="#a算法-2"></a> A*算法</h3>
<ul>
<li>
<p>估价函数满足一定限制条件的算法称为A*算法</p>
</li>
<li>
<p>要求g(x)&gt;0 ； h(x)不大于x到目标的实际代价</p>
</li>
</ul>
<h4 id="举例a算法求解八数码问题"><a class="markdownIt-Anchor" href="#举例a算法求解八数码问题"></a> 举例：A*算法求解八数码问题</h4>
<ul>
<li>定义估价函数
<ul>
<li>f (x) = g (x) + h (x)</li>
<li>g (x)：从初始状态到x需要移动操作的次数</li>
<li>h (x)：x状态下错放的棋子数</li>
</ul>
</li>
<li>
<img src="D:\MyBlog\source\MyImages\image-20200416095648158.png" alt="image-20200416095648158" style="zoom: 50%;" />
</li>
</ul>
<h4 id="估价函数对算法的影响"><a class="markdownIt-Anchor" href="#估价函数对算法的影响"></a> 估价函数对算法的影响</h4>
<ul>
<li>一般来说，在满足h(n) ≤ h*(n)的前提下，h(n)的值越大越好。<strong>h(n)的值越大，说明它携带的启发性信息越多</strong>，A*算法搜索时扩展的节点就越少，搜索效率就越高。</li>
</ul>
<h4 id="以曼哈顿距离衡量h"><a class="markdownIt-Anchor" href="#以曼哈顿距离衡量h"></a> 以曼哈顿距离衡量h</h4>
<ul>
<li>
<p>曼哈顿距离：两点之间水平距离和垂直距离之和</p>
<img src="D:\MyBlog\source\MyImages\image-20200420094240937.png" alt="image-20200420094240937" style="zoom:50%;" />
</li>
</ul>
<h4 id="举例静态路网中的最短路径规划"><a class="markdownIt-Anchor" href="#举例静态路网中的最短路径规划"></a> 举例：静态路网中的最短路径规划</h4>
<ul>
<li>A* 算法：重复如下步骤
<ul>
<li>将方块加到open表中，该列表有最小的和值</li>
<li>将S从open表中移除，然后添加S到closed表中</li>
<li>对于与S相邻的每一块可通行的方块T
<ul>
<li>如果T在closed表中，不管他</li>
<li>如果T不在open表中，则添加他并计算出他的和值</li>
<li>如果T已经在open表中，则尝试更新和值</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="与或树的搜索策略"><a class="markdownIt-Anchor" href="#与或树的搜索策略"></a> 与/或树的搜索策略</h1>
<h1 id="搜索的完备性与效率"><a class="markdownIt-Anchor" href="#搜索的完备性与效率"></a> 搜索的完备性与效率</h1>
<h2 id="完备性"><a class="markdownIt-Anchor" href="#完备性"></a> 完备性</h2>
<ul>
<li>对于一类可解的问题和一个搜索过程，如果运用该<strong>搜索过程一定能求得该类问题的解，则称该搜索过程为完备的</strong>，否则为不完备的。完备的搜索过程称为“搜索算法”。不完备的搜索过程不是算法，称为“过程”。</li>
<li>广度优先搜索、代价树的广度优先搜索、改进后的有界深度优先搜索以及A*算法都是完备的搜索过程，其它搜索过程都是不完备的。</li>
</ul>
<h2 id="搜索效率"><a class="markdownIt-Anchor" href="#搜索效率"></a> 搜索效率</h2>
<ul>
<li>P=L/T
<ul>
<li>其中，L为从初始节点到目标节点的路径长度(解)；T为整个搜索过程中所生成的节点总数。</li>
<li>外显率反映了搜索过程中从初始节点向目标节点前进时搜索区域的宽度。当T=L时，P=1，表示搜索过程中每次只生成一个节点，它恰好是解路径上的节点，搜索效率最高。P越小表示搜索时产生的无用节点愈多，搜索效率愈低。</li>
</ul>
</li>
</ul>
<h3 id="有效分支因数"><a class="markdownIt-Anchor" href="#有效分支因数"></a> 有效分支因数</h3>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>+</mo><msup><mi>B</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msup><mi>B</mi><mi>L</mi></msup><mo>=</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">B+B^2+...+B^L = T
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8913309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span></span></p>
<ul>
<li>
<p>其中，B是有效分枝因数，它表示在整个搜索过程中每个节点平均生成的子节点数目；L为路径长度；T为节点总数</p>
</li>
<li>
<p>当B＝1时，L=T，此时所生成的节点数最少，搜索效率最高。</p>
</li>
<li>
<p>实验表明，b*是一个比较稳定的常数，同一问题基本不随问题规模变化</p>
</li>
<li>
<p>关系</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>=</mo><mi>L</mi><mi mathvariant="normal">/</mi><mi>T</mi><mspace linebreak="newline"></mspace><mi>T</mi><mo>=</mo><mi>B</mi><mo>×</mo><mo stretchy="false">(</mo><msup><mi>B</mi><mi>L</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>B</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mi>P</mi><mo>=</mo><mo stretchy="false">(</mo><mi>L</mi><mo>×</mo><mo stretchy="false">(</mo><mi>B</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>B</mi><mo>×</mo><mo stretchy="false">(</mo><msup><mi>B</mi><mi>L</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P=L/T\\
T=B×(B^L-1)/(B-1)\\
P=(L×(B-1))/(B×(B^L-1))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第8章遗传算法</title>
    <url>/2020/06/13/%E7%AC%AC8%E7%AB%A0%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1>
<h2 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想"></a> 基本思想</h2>
<p>遗传算法GA把问题的解表示成“染色体”，在算法中即是以一定方式编码的串。并且，在执行遗传算法之前，给出一群“染色体”，也即假设解。然后，把这些假设解置于问题的“环境”中，并按适者生存的原则，从中选择出较适应环境的“染色体”进行复制，再通过交叉，变异过程产生更适应环境的新一代“染色体”群。这样，一代一代地进化，最后就会收敛到最适应环境的一个“染色体”上，它就是问题的最优解。</p>
<h2 id="基本概念-2"><a class="markdownIt-Anchor" href="#基本概念-2"></a> 基本概念</h2>
<h3 id="串"><a class="markdownIt-Anchor" href="#串"></a> 串</h3>
<p>它是个体(Individual)的形式，在算法中为二进制串或者其它编码方式的串，并且对应于遗传学中的染色体(Chromosome)</p>
<h3 id="群体"><a class="markdownIt-Anchor" href="#群体"></a> 群体</h3>
<p>个体的集合称为群体，串是群体的元素</p>
<h3 id="群体大小"><a class="markdownIt-Anchor" href="#群体大小"></a> 群体大小</h3>
<p>个体的集合称为群体，串是群体的元素</p>
<h3 id="基因"><a class="markdownIt-Anchor" href="#基因"></a> 基因</h3>
<ul>
<li>基因是串中的元素，基因用于表示个体的特征。</li>
<li>例如有一个串S＝1011，则其中的1，0，1，1这<br />
4个元素分别称为基因。</li>
</ul>
<h3 id="基因位置"><a class="markdownIt-Anchor" href="#基因位置"></a> 基因位置</h3>
<ul>
<li>一个基因在串中的位置称为基因位置，有时也简称基因位（基因座）。</li>
<li>基因位置由串的左向右计算，例如在串S＝1101中，0的基因位置是3。</li>
<li>基因位置对应于遗传学中的地点(Locus)。</li>
</ul>
<h3 id="适应度"><a class="markdownIt-Anchor" href="#适应度"></a> 适应度</h3>
<p>表示某一个体对于环境的适应程度。</p>
<h2 id="基本机理"><a class="markdownIt-Anchor" href="#基本机理"></a> 基本机理</h2>
<h3 id="组成"><a class="markdownIt-Anchor" href="#组成"></a> 组成</h3>
<p>编码机制、控制参数、适应度函数、遗传算子</p>
<h3 id="编码机制"><a class="markdownIt-Anchor" href="#编码机制"></a> 编码机制</h3>
<p>用遗传算法解决问题时，首先要对待解决问题的模型结构和参数进行编码，一般用字符串表示。</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第7章搜索策略之与或树</title>
    <url>/2020/06/13/%E7%AC%AC7%E7%AB%A0%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5%E4%B9%8B%E4%B8%8E%E6%88%96%E6%A0%91/</url>
    <content><![CDATA[<h1 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h1>
<h2 id="可解结点与不可解结点"><a class="markdownIt-Anchor" href="#可解结点与不可解结点"></a> 可解结点与不可解结点</h2>
<h3 id="可解结点递归定义"><a class="markdownIt-Anchor" href="#可解结点递归定义"></a> 可解结点递归定义</h3>
<ul>
<li>终叶节点是可解节点，直接和本原问题相关连；</li>
<li>非终叶节点含有“或”子节点时，只要子节点中有一个是可解节点，该非终叶节点便为可解节点；</li>
<li>非终叶节点含有“与”子节点时，只有子节点全为可解节点时，该非终叶节点才是可解节点。</li>
</ul>
<h3 id="不可解结点的定义"><a class="markdownIt-Anchor" href="#不可解结点的定义"></a> 不可解结点的定义</h3>
<p>关于可解节点的三个条件全部不满足的节点，称为不可解节点；</p>
<h2 id="一般搜索过程流程"><a class="markdownIt-Anchor" href="#一般搜索过程流程"></a> 一般搜索过程流程</h2>
<ol>
<li>把原始问题作为初始节点S，并把它作为当前节点。</li>
<li>应用分解或等价变换算符对当前节点进行扩展。</li>
<li>为每个子节点设置指向父节点的指针。</li>
<li>选择合适子节点作为当前节点，反复执行第(2)、(3)步，在此期间多次调用可解标示过程和不可解标示过程，直到初始节点被标示为可解节点或不可解节点为止。
<ul>
<li>由这个搜索过程所形成的节点和指针结构称为搜索树。</li>
<li>搜索中，通过可解标示过程确定初始节点是可解的，则由此初始节点及其下属的可解节点就构成了解树。</li>
</ul>
</li>
</ol>
<h2 id="剪枝"><a class="markdownIt-Anchor" href="#剪枝"></a> 剪枝</h2>
<ul>
<li>如果已确定某个节点为可解节点，其不可解的后裔节点不再有用，可从搜索树中删去；</li>
<li>若已确定某个节点是不可解节点，其全部后裔节点都不再有用，可从搜索树中删去。但当前这个不可解节点还不能删去，在判断其先辈节点的可解性时还要用到</li>
</ul>
<h1 id="盲目搜索"><a class="markdownIt-Anchor" href="#盲目搜索"></a> 盲目搜索</h1>
<h2 id="广度优先搜索"><a class="markdownIt-Anchor" href="#广度优先搜索"></a> 广度优先搜索</h2>
<h3 id="流程"><a class="markdownIt-Anchor" href="#流程"></a> 流程</h3>
<img src="/MyImages/image-20200422095129126.png" alt="image-20200422095129126" style="zoom: 50%;" />
<img src="/MyImages/image-20200422095147781.png" alt="image-20200422095147781" style="zoom: 50%;" />
<ul>
<li>注： 放入OPEN表中时，子节点要放到OPEN表尾部，配指向父节点的指针</li>
</ul>
<h3 id="举例"><a class="markdownIt-Anchor" href="#举例"></a> 举例</h3>
<h2 id="深度优先搜索"><a class="markdownIt-Anchor" href="#深度优先搜索"></a> 深度优先搜索</h2>
<ul>
<li>区别在于是向OPEN表的首部加如结点</li>
</ul>
<h2 id="与或树的深度-宽度优先搜索特点"><a class="markdownIt-Anchor" href="#与或树的深度-宽度优先搜索特点"></a> 与/或树的深度、宽度优先搜索特点</h2>
<ul>
<li>都是盲目搜索。</li>
<li>搜索从初始节点开始，先自上而下进行搜索，寻找终叶节点及端点节，然后再自下而上进行标示。一旦初始节点被标示为可解或不可解节点，搜索就不再继续进行。</li>
<li>搜索都按确定路线进行，当选择某个节点进行扩展时，只考虑节点在与/或树中的位置，没有考虑要付出的代价，因而求得的解树不一定是代价最小的解树，即不一定是最优解树。</li>
</ul>
<h1 id="有序搜索启发式搜索策略"><a class="markdownIt-Anchor" href="#有序搜索启发式搜索策略"></a> 有序搜索（启发式搜索策略）</h1>
<ul>
<li>用于与/或树的有序搜索是求代价最小的解树的搜索方法</li>
<li><strong>基本思想</strong>：为求得代价最小的解树，每次确定待扩展节点时，需要往前多看几步（向叶子），<strong>计算扩展这个节点可能要付出的代价</strong>，并选择代价最小的节点进行扩展。</li>
</ul>
<h2 id="解树的代价计算"><a class="markdownIt-Anchor" href="#解树的代价计算"></a> 解树的代价计算</h2>
<p>通过计算解树中节点的代价得到。若问题可解，由子节点代价推算父节点代价，<strong>逐层上推</strong>，最终求出S的代价，即<strong>解树的代价</strong></p>
<ul>
<li>如果x是终叶节点，则定义x的代价： h(x)=0</li>
<li>如果x不可扩展，且不是终叶节点，则定义h(x)=∞</li>
<li>如果x是“或”节点，y1， y2， …， yn是它的子节点，则x的代价为$$h(x)=min_{1\leq i\leq n}{c(x,y_i)+h(y_i)}$$</li>
<li>如果x是“与”结点，可以使用
<ul>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><msub><mi>x</mi><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow></msub><mo stretchy="false">{</mo><mi>c</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi>h</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">h(x)=max_{1\leq i\leq n}\{c(x,y_i)+h(y_i)\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">≤</span><span class="mord mathdefault mtight">i</span><span class="mrel mtight">≤</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24517899999999998em;"><span></span></span></span></span></span></span><span class="mopen">{</span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">}</span></span></span></span></span></p>
</li>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow><mi>n</mi></munderover><mo stretchy="false">{</mo><mi>c</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi>h</mi><mo stretchy="false">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">h(x)=\sum ^n_{1\leq i\leq n}\{c(x,y_i)+h(y_i)\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0242450000000005em;vertical-align:-1.372848em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.8723309999999997em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mrel mtight">≤</span><span class="mord mathdefault mtight">i</span><span class="mrel mtight">≤</span><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.372848em;"><span></span></span></span></span></span><span class="mopen">{</span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">}</span></span></span></span></span></p>
</li>
</ul>
</li>
</ul>
<h3 id="举例-2"><a class="markdownIt-Anchor" href="#举例-2"></a> 举例</h3>
<img src="/MyImages/72.png" style="zoom: 67%;" />
<h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h3>
<ul>
<li>计算h(x)的条件：已知x所有子节点的代价</li>
<li><strong>问题</strong>：搜索是自上而下进行的，只有不可扩展节点的代价是已知的（∞或0），因此除非x的所有子节点都不可扩展，否则x的代价无法计算得到</li>
<li><strong>解决方案</strong>：根据问题本身提供的启发性信息定义一个启发函数，由启发函数估算子节点的代价，然后反推计算父节点和先辈节点的代价。每当有新一代的节点生成时，都要自下而上地重新计算先辈节点的代价</li>
</ul>
<h2 id="希望树"><a class="markdownIt-Anchor" href="#希望树"></a> 希望树</h2>
<ul>
<li>选择待扩展节点时，挑选有希望成为最优解树一部分的节点进行扩展，保证任一时刻求出的部分解树的代价都是最小的。<br />
这些节点及先辈节点（包括初始节点S）构成的与/或树有可能成为最优解树一部分，被称为<strong>希望树</strong></li>
<li>随着新节点的生成，结点的代价不断变化，希望树也不断变化</li>
<li>有序搜索是不断选择，不断调整希望树的过程</li>
</ul>
<h3 id="希望树的构成"><a class="markdownIt-Anchor" href="#希望树的构成"></a> 希望树的构成</h3>
<ul>
<li>初始节点S在希望树中</li>
<li>如果节点x在希望树中，则一定有
<ul>
<li>如果x是“或”节点，y1， y2， …， yn是它的子节点，则具有$$h(x)=min_{1\leq i\leq n}{c(x,y_i)+h(y_i)}$$，值的那个子节点也在希望树中</li>
<li>如果x是与结点，则它的全部子节点都应该在希望树中</li>
</ul>
</li>
</ul>
<h3 id="有序搜索算法流程"><a class="markdownIt-Anchor" href="#有序搜索算法流程"></a> 有序搜索算法流程</h3>
<p>(1)把初始节点S放入OPEN表中。<br />
(2)根据当前搜索树中节点的代价求出以S为根的希望树T 。<br />
(3)依次把OPEN表中T的端节点N选出放入CLOSED表中。<br />
(4)如果N是终叶节点，则做下列工作：<br />
①标示N为可解节点。<br />
②对T应用可解标示过程，标记N的先辈节点。<br />
③若S被标记为可解，则T就是最优解树，成功退出。<br />
④否则，从OPEN表中删去具有可解先辈的节点。</p>
<p>(5)如果N不是终叶节点，且不可扩展，则做下列工作：<br />
①标示N为不可解节点。<br />
②对T应用不可解标示过程，标记N的先辈节点。<br />
③若初始节点S被标示为不可解节点，则失败退出。<br />
④否则，从OPEN表中删去有不可解先辈的节点。<br />
(6)如果N不是终叶节点，但可扩展，则做下列工作：<br />
①扩展N，产生N的所有子节点。<br />
②把子节点放入OPEN表，并为每个子节点配置父指针。<br />
③计算子节点的h值及其先辈节点的h值。<br />
(7)转第(2)步。</p>
<h3 id="举例-3"><a class="markdownIt-Anchor" href="#举例-3"></a> 举例</h3>
<p>此例中路径长度为1，每次扩展两层</p>
<img src="/MyImages/73.png" style="zoom:67%;" />
<img src="/MyImages/74.png" style="zoom:67%;" />
<img src="/MyImages/75.png" style="zoom:67%;" />
<img src="/MyImages/76.png" style="zoom:67%;" />
<h1 id="博弈"><a class="markdownIt-Anchor" href="#博弈"></a> 博弈</h1>
<h2 id="博弈树的形成"><a class="markdownIt-Anchor" href="#博弈树的形成"></a> 博弈树的形成</h2>
<ul>
<li>博弈过程中，设我方为A方，则可供A方选择的若干行动方案之间是“或”关系；</li>
<li>在A方行动方案基础上，B方也有若干个可供选择的行动方案，则这些方案对A方来说就是“与”关系。</li>
<li>如此，逐层扩展，并用图表示博弈过程，得到的就是一棵与/或树，描述博弈过程的与/或树被称为博弈树。</li>
</ul>
<h2 id="博弈树搜索的特点"><a class="markdownIt-Anchor" href="#博弈树搜索的特点"></a> 博弈树搜索的特点</h2>
<ul>
<li>博弈的<strong>初始格局是初始节点。</strong></li>
<li>博弈树中，<strong>“或”节点和“与”节点是逐层交替出现的</strong>。自己一方扩展的节点之间是“或”关系，对方扩展的节点之间是“与”关系。双方轮流扩展节点。</li>
<li>所有能使<strong>自己一方获胜的终局都是本原问题</strong>，相应节点是可解节点；所有<strong>使对方获胜的终局都是不可解节点</strong>。</li>
</ul>
<h2 id="极大极小分析法"><a class="markdownIt-Anchor" href="#极大极小分析法"></a> 极大极小分析法</h2>
<h3 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想"></a> 基本思想</h3>
<ul>
<li>根据问题特性定义一个估价函数。考虑每一方案实施后，对方可能采取的所有行动，利用估价函数估算当前博弈树端节点得分（<strong>静态估值</strong>）。</li>
<li>利用端节点的估值推算其父节点得分（<strong>倒推值</strong>）
<ul>
<li><strong>对“或”节点</strong>，为了选一个对自己最有利的方案，选<strong>其子节点中的最大得分</strong>作为父节点得分；</li>
<li><strong>对“与”节点</strong>，立足于最坏情况，<strong>选其子节点中的最小得分</strong>作为父节点得分。</li>
</ul>
</li>
<li>具有较大倒推值的行动方案就是当前最好的行动方案。</li>
</ul>
<h3 id="倒退值的计算"><a class="markdownIt-Anchor" href="#倒退值的计算"></a> 倒退值的计算</h3>
<img src="/MyImages/image-20200510233317658.png" alt="image-20200510233317658" style="zoom: 50%;" />
<h3 id="举例-4"><a class="markdownIt-Anchor" href="#举例-4"></a> 举例</h3>
<p>设有如图所示九个空格，A、B二人对奕，轮到谁走谁就往空格上放一只自己的棋子，最先使自己棋子构成三子一线的就获得胜利。<br />
设A的棋子用“a”表示，B的棋子用“b”表示，A先走棋。<br />
为了不生成太大的博弈树，假设每次仅扩展两层。</p>
<ul>
<li>设计估价函数e§
<ul>
<li>若P是A必胜的棋局，则e§=+∞</li>
<li>若P是B必胜的棋局，则e§=-∞</li>
<li>若P是胜负未定的棋局，则e§=e(+P)-e(-P)
<ul>
<li>e(+P)：棋局P上有可能使a成为三子成一线的数目；</li>
<li>e(-P)：棋局P上有可能使b成为三子成一线的数目。</li>
</ul>
</li>
<li>
<img src="/MyImages/77.png" style="zoom: 67%;" />
</li>
</ul>
</li>
<li>
<img src="/MyImages/78.png" style="zoom:67%;" />
</li>
<li>
<img src="/MyImages/79.png" style="zoom:67%;" />
</li>
</ul>
<h3 id="极大极小法的缺点"><a class="markdownIt-Anchor" href="#极大极小法的缺点"></a> 极大极小法的缺点</h3>
<ul>
<li>首先，生成一定深度的博弈树。然后，对端节点进行估值，再计算上层节点的倒推值，效率较低</li>
<li>分析可知：博弈树具有“与”、“或”节点逐层交替出现的特点，如能边生成节点边计算估值及倒推值，就有可能删去一些不必要的节点，从而减少搜索及计算的工作量。</li>
</ul>
<h3 id="α-β剪枝"><a class="markdownIt-Anchor" href="#α-β剪枝"></a> α-β剪枝</h3>
<ul>
<li>对“与”节点，取当前子节点中最小倒推值作为它的倒推值上界，该值被称为值。</li>
<li>对“或”节点，取当前子节点中最大倒推值作为它的倒推值下界，该值被称为值。</li>
</ul>
<img src="/MyImages/80.png" style="zoom: 67%;" />
<ul>
<li>
<p><strong>α剪枝</strong><br />
对“或”节点x，如果x的α值不能降低其父节点的值，则对x以下的分枝可停止搜索，并使x的倒推值为α。这种剪枝称为α剪枝。</p>
</li>
<li>
<p><strong>β剪枝</strong><br />
对“与”节点x，如果x的β值不能升高其父节点的值，则对x以下的分枝可停止搜索，并使x的倒推值为β。这种剪枝称为剪枝。</p>
</li>
<li>
<p>举例</p>
<img src="/MyImages/81.png" style="zoom:67%;" /></li>
</ul>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>素数环</title>
    <url>/2020/03/30/%E7%B4%A0%E6%95%B0%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="uva-524-素数环"><a class="markdownIt-Anchor" href="#uva-524-素数环"></a> UVA 524 素数环</h1>
<p>输入正整数n，把1，2，3，···，n组成一个环，使得相邻两个整数之和均为素数。输出时从整数1开始逆时针排列。同一个环应恰好输出一次。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>直观的考虑，答案应该是1-n的某种排列，但是16！太大了，如果生成排列再测试会导致超时。</li>
<li>因为前面能构成素数也未必能构成素数环，有点局部最优未必是整体最优的感觉。所以考虑回溯法，在当前位置处枚举没用过的数，判断能否与上一位构成素数。</li>
<li>加速：实现打印出素数表，后面直接判断。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="dfs-每一层都在寻找cur位置处能放的数别忘了回溯"><a class="markdownIt-Anchor" href="#dfs-每一层都在寻找cur位置处能放的数别忘了回溯"></a> dfs 每一层都在寻找cur位置处能放的数，别忘了回溯</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void dfs(int cur) &#123;</span><br><span class="line">if (cur &#x3D;&#x3D; n &amp;&amp; isp[A[0] + A[n - 1]]) &#123;</span><br><span class="line">	cout &lt;&lt; A[0];</span><br><span class="line">	for (int i &#x3D; 1; i &lt; n; i++) cout &lt;&lt; &quot; &quot; &lt;&lt; A[i];</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">	for (int j &#x3D; 2; j &lt;&#x3D; n; j++) &#123;</span><br><span class="line">		if (!vis[j] &amp;&amp; isp[j + A[cur - 1]]) &#123;</span><br><span class="line">			A[cur] &#x3D; j;</span><br><span class="line">			&#x2F;&#x2F;回溯法</span><br><span class="line">			vis[j] &#x3D; 1;</span><br><span class="line">			dfs(cur + 1);</span><br><span class="line">			vis[j] &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="is_prime-判断i是否是素数固定的"><a class="markdownIt-Anchor" href="#is_prime-判断i是否是素数固定的"></a> is_prime 判断i是否是素数，固定的</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int is_prime(int a) &#123;</span><br><span class="line">for (int i &#x3D; 2; i &lt; a; i++)</span><br><span class="line">	if (a%i &#x3D;&#x3D; 0) return 0;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int n, vis[1000000];</span><br><span class="line">int A[1000000];</span><br><span class="line">int isp[100000];</span><br><span class="line">int main() &#123;</span><br><span class="line">int kase &#x3D; 0;</span><br><span class="line">while (cin &gt;&gt; n) &#123;</span><br><span class="line">	if (kase) cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++kase &lt;&lt; &quot;:&quot; &lt;&lt; endl;</span><br><span class="line">	memset(isp, 0, 2 * n * sizeof(int));</span><br><span class="line">	memset(vis, 0, 2 * n * sizeof(int));</span><br><span class="line">	for (int i &#x3D; 2; i &lt;&#x3D; 2 * n; i++)</span><br><span class="line">		isp[i] &#x3D; is_prime(i);</span><br><span class="line">	isp[1] &#x3D; 1;&#x2F;&#x2F;先构造出素数表，以后方便</span><br><span class="line">	A[0] &#x3D; 1;&#x2F;&#x2F;题干要求从1开始逆序输出</span><br><span class="line">	dfs(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2020/06/20/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="成本模型"><a class="markdownIt-Anchor" href="#成本模型"></a> 成本模型</h1>
<ul>
<li>使用成本模型来评估算法，例如数组的访问次数就是一种成本模型</li>
<li>由于计算机系统存在缓存，所以访问相邻的元素会比访问不相邻元素快得多</li>
</ul>
<h1 id="均摊分析"><a class="markdownIt-Anchor" href="#均摊分析"></a> 均摊分析</h1>
<ul>
<li>将所有操作的总成本除于操作总数来将成本均摊
<ul>
<li>例如对一个空栈进行 N 次连续的 push() 调用需要访问数组的次数为 N+4+8+16+…+2N=5N-4（N 是向数组写入元素的次数，其余都是调整数组大小时进行复制需要的访问数组次数），均摊后访问数组的平均次数为常数。</li>
</ul>
</li>
</ul>
<h1 id="倍率实验"><a class="markdownIt-Anchor" href="#倍率实验"></a> 倍率实验</h1>
<ul>
<li>结论：如果$$ T(N)= aN^blogN$$，那么 $$T(2N)/T(N) = 2b$$</li>
<li>可以统计不同N下，算法的时间，求倍率的均值，从而求得b，得到T(N)</li>
</ul>
<h1 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h1>
<ul>
<li>成本模型是比较和交换的次数</li>
</ul>
<table>
<thead>
<tr>
<th>算法</th>
<th>稳定性</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>选择排序</td>
<td>×</td>
<td>N2</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>冒泡排序</td>
<td>√</td>
<td>N2</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>插入排序</td>
<td>√</td>
<td>N ~ N2</td>
<td>1</td>
<td>时间复杂度和初始顺序有关</td>
</tr>
<tr>
<td>希尔排序</td>
<td>×</td>
<td>N 的若干倍乘于递增序列的长度</td>
<td>1</td>
<td>改进版插入排序</td>
</tr>
<tr>
<td>快速排序</td>
<td>×</td>
<td>NlogN</td>
<td>logN</td>
<td></td>
</tr>
<tr>
<td>三向切分快速排序</td>
<td>×</td>
<td>N ~ NlogN</td>
<td>logN</td>
<td>适用于有大量重复主键</td>
</tr>
<tr>
<td>归并排序</td>
<td>√</td>
<td>NlogN</td>
<td>N</td>
<td></td>
</tr>
<tr>
<td>堆排序</td>
<td>×</td>
<td>NlogN</td>
<td>1</td>
<td>无法利用局部性原理</td>
</tr>
</tbody>
</table>
<h2 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(nums[j], nums[min])) &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>N2/2次比较和N次交换</li>
</ul>
<h2 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length;</span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt; <span class="number">0</span> &amp;&amp; !isSorted; i--) &#123;</span><br><span class="line">            isSorted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (less(nums[j + <span class="number">1</span>], nums[j])) &#123;</span><br><span class="line">                    isSorted = <span class="keyword">false</span>;</span><br><span class="line">                    swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>从左到右交换相邻逆序元素，一轮循环后，可以让未排序的最大元素上浮到右侧</li>
</ul>
<h2 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(nums[j], nums[j - <span class="number">1</span>]); j--) &#123;</span><br><span class="line">                swap(nums, j, j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序</li>
<li>对于数组 {3, 5, 2, 4, 1}，它具有以下逆序：(3, 2), (3, 1), (5, 2), (5, 4), (5, 1), (2, 1), (4, 1)，插入排序每次只能交换相邻元素，令逆序数量减少 1，因此插入排序需要交换的次数为逆序数量</li>
</ul>
<h2 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h2>
<ul>
<li>改进的插入排序，通过交换不相邻的元素，使每次可以将逆序数量减少大于1</li>
<li>希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> N = nums.length;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; N / <span class="number">3</span>) &#123;</span><br><span class="line">            h = <span class="number">3</span> * h + <span class="number">1</span>; <span class="comment">// 1, 4, 13, 40, ...</span></span><br><span class="line">            <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(nums[j], nums[j - h]); j -= h) &#123;</span><br><span class="line">                        swap(nums, j, j - h);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                h = h / <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> T[] aux;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(T[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = l, j = m + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= h; k++) &#123;</span><br><span class="line">            aux[k] = nums[k]; <span class="comment">// 将数据复制到辅助数组</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= h; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; m) &#123;</span><br><span class="line">                nums[k] = aux[j++];</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; h) &#123;</span><br><span class="line">                nums[k] = aux[i++];</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i].compareTo(aux[j]) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                nums[k] = aux[i++]; <span class="comment">// 先进行这一步，保证稳定性</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k] = aux[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自顶向下归并排序"><a class="markdownIt-Anchor" href="#自顶向下归并排序"></a> 自顶向下归并排序</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Up2DownMergeSort</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">MergeSort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">        aux = (T[]) <span class="keyword">new</span> Comparable[nums.length];</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (h &lt;= l) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        sort(nums, l, mid);</span><br><span class="line">        sort(nums, mid + <span class="number">1</span>, h);</span><br><span class="line">        merge(nums, l, mid, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自底向上归并排序"><a class="markdownIt-Anchor" href="#自底向上归并排序"></a> 自底向上归并排序</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Down2UpMergeSort</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">MergeSort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> N = nums.length;</span><br><span class="line">        aux = (T[]) <span class="keyword">new</span> Comparable[N];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N; sz += sz) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; N - sz; lo += sz + sz) &#123;</span><br><span class="line">                merge(nums, lo, lo + sz - <span class="number">1</span>, Math.min(lo + sz + sz - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h2>
<ul>
<li>快速排序 &amp; 归并排序
<ul>
<li>归并排序将数组分为两个子数组分别排序，并将有序的子数组归并使得整个数组排序；</li>
<li>快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">        shuffle(nums);</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (h &lt;= l)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, l, h);</span><br><span class="line">        sort(nums, l, j - <span class="number">1</span>);</span><br><span class="line">        sort(nums, j + <span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Comparable&gt; list = Arrays.asList(nums);</span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        list.toArray(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(T[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = h + <span class="number">1</span>;</span><br><span class="line">    T v = nums[l];</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (less(nums[++i], v) &amp;&amp; i != h) ;</span><br><span class="line">        <span class="keyword">while</span> (less(v, nums[--j]) &amp;&amp; j != l) ;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, l, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N2/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。</p>
</li>
<li>
<p>改进</p>
<ul>
<li>
<p>以为对于小数组，插入排序的性能更好，所以在小数组中可以切换到插入排序</p>
</li>
<li>
<p><strong>三数取中</strong>：最好的情况下是每次都能取数组的中位数作为切分元素，但是计算中位数的代价很高。一种折中方法是取 3 个元素，并将大小居中的元素作为切分元素</p>
</li>
<li>
<p><strong>三向切分</strong>：对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeWayQuickSort</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">QuickSort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (h &lt;= l) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lt = l, i = l + <span class="number">1</span>, gt = h;</span><br><span class="line">        T v = nums[l];</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = nums[i].compareTo(v);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, lt++, i++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, i, gt--);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums, l, lt - <span class="number">1</span>);</span><br><span class="line">        sort(nums, gt + <span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>切分可以用于快速选择</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">select</span><span class="params">(T[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt; l) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, l, h);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[k];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; k) &#123;</span><br><span class="line">            h = j - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h2>
<h3 id="上浮"><a class="markdownIt-Anchor" href="#上浮"></a> 上浮</h3>
<ul>
<li>
<p>在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为<strong>上浮</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k / <span class="number">2</span>, k)) &#123;</span><br><span class="line">        swap(k / <span class="number">2</span>, k);</span><br><span class="line">        k = k / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="下沉"><a class="markdownIt-Anchor" href="#下沉"></a> 下沉</h3>
<ul>
<li>
<p>类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为<strong>下沉</strong>。一个节点如果有两个子节点，应当与两个子节点中最大那个节点进行交换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; N &amp;&amp; less(j, j + <span class="number">1</span>))</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (!less(k, j))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="插入元素"><a class="markdownIt-Anchor" href="#插入元素"></a> 插入元素</h3>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Comparable v)</span> </span>&#123;</span><br><span class="line">    heap[++N] = v;</span><br><span class="line">    swim(N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除最大元素"><a class="markdownIt-Anchor" href="#删除最大元素"></a> 删除最大元素</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T max = heap[<span class="number">1</span>];</span><br><span class="line">    swap(<span class="number">1</span>, N--);</span><br><span class="line">    heap[N + <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">    sink(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建堆"><a class="markdownIt-Anchor" href="#构建堆"></a> <strong>构建堆</strong>：</h3>
<p>从右至左，依次进行下沉操作，叶子节点不需要下沉</p>
<h3 id="堆排序-2"><a class="markdownIt-Anchor" href="#堆排序-2"></a> 堆排序</h3>
<p>交换堆顶元素与最后一个元素，之后进行下沉操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">Sort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组第 0 个位置不能有元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)</span><br><span class="line">            sink(nums, k, N);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            swap(nums, <span class="number">1</span>, N--);</span><br><span class="line">            sink(nums, <span class="number">1</span>, N);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(T[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; N &amp;&amp; less(nums, j, j + <span class="number">1</span>))</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span> (!less(nums, k, j))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(nums, k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(T[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i].compareTo(nums[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h1>
<table>
<thead>
<tr>
<th>算法</th>
<th>union</th>
<th>find</th>
</tr>
</thead>
<tbody>
<tr>
<td>Quick Find</td>
<td>N</td>
<td>1</td>
</tr>
<tr>
<td>Quick Union</td>
<td>树高</td>
<td>树高</td>
</tr>
<tr>
<td>加权 Quick Union</td>
<td>logN</td>
<td>logN</td>
</tr>
<tr>
<td>路径压缩的加权 Quick Union</td>
<td>非常接近 1</td>
<td>非常接近 1</td>
</tr>
</tbody>
</table>
<h2 id="quick-find"><a class="markdownIt-Anchor" href="#quick-find"></a> Quick Find</h2>
<ul>
<li>需要保证<strong>同一连通分量的所有节点的 id 值相等</strong>，就可以通过判断两个节点的 id 值是否相等从而判断其连通性。</li>
<li>但是 <strong>union 操作代价却很高</strong>，需要将其中一个连通分量中的所有节点 id 值都修改为另一个节点的 id 值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickFindUF</span> <span class="keyword">extends</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QuickFindUF</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pID = find(p);</span><br><span class="line">        <span class="keyword">int</span> qID = find(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pID == qID) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; id.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id[i] == pID) &#123;</span><br><span class="line">                id[i] = qID;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="quick-union"><a class="markdownIt-Anchor" href="#quick-union"></a> Quick Union</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickUnionUF</span> <span class="keyword">extends</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QuickUnionUF</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(N);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (p != id[p]) &#123;</span><br><span class="line">            p = id[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pRoot = find(p);</span><br><span class="line">        <span class="keyword">int</span> qRoot = find(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pRoot != qRoot) &#123;</span><br><span class="line">            id[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>同一个连通分量的节点 id 值不同，id 值只是用来指向另一个节点。因此需要一直向上查找操作，直到找到最上层的节点。</li>
<li>这种方法可以快速进行 union 操作，但是 find 操作和树高成正比，最坏的情况下树的高度为节点的数目。</li>
</ul>
<h2 id="加权quick-union"><a class="markdownIt-Anchor" href="#加权quick-union"></a> 加权Quick Union</h2>
<ul>
<li>union时总是将小树连在大树上</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightedQuickUnionUF</span> <span class="keyword">extends</span> <span class="title">UF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存节点的数量信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sz;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeightedQuickUnionUF</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(N);</span><br><span class="line">        <span class="keyword">this</span>.sz = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (p != id[p]) &#123;</span><br><span class="line">            p = id[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = find(p);</span><br><span class="line">        <span class="keyword">int</span> j = find(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == j) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sz[i] &lt; sz[j]) &#123;</span><br><span class="line">            id[i] = j;</span><br><span class="line">            sz[j] += sz[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            id[j] = i;</span><br><span class="line">            sz[i] += sz[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h1>
<h2 id="数组实现"><a class="markdownIt-Anchor" href="#数组实现"></a> 数组实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">MyStack</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈元素数组，只能通过转型来创建泛型数组</span></span><br><span class="line">    <span class="keyword">private</span> Item[] a = (Item[]) <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyStack&lt;Item&gt; <span class="title">push</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        check();</span><br><span class="line">        a[N++] = item;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"stack is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Item item = a[--N];</span><br><span class="line"></span><br><span class="line">        check();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 避免对象游离</span></span><br><span class="line">        a[N] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (N &gt;= a.length) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * a.length);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (N &gt; <span class="number">0</span> &amp;&amp; N &lt;= a.length / <span class="number">4</span>) &#123;</span><br><span class="line">            resize(a.length / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整数组大小，使得栈具有伸缩性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Item[] tmp = (Item[]) <span class="keyword">new</span> Object[size];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            tmp[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回逆序遍历的迭代器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Item&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> i = N;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i &gt; <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a[--i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表实现"><a class="markdownIt-Anchor" href="#链表实现"></a> 链表实现</h2>
<ul>
<li>使用头插法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListStack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">MyStack</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node top = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Item item;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyStack&lt;Item&gt; <span class="title">push</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node newTop = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">        newTop.item = item;</span><br><span class="line">        newTop.next = top;</span><br><span class="line"></span><br><span class="line">        top = newTop;</span><br><span class="line"></span><br><span class="line">        N++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"stack is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Item item = top.item;</span><br><span class="line">        top = top.next;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Item&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> Node cur = top;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cur != <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Item item = cur.item;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="队列"><a class="markdownIt-Anchor" href="#队列"></a> 队列</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyQueue</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">MyQueue&lt;Item&gt; <span class="title">add</span><span class="params">(Item item)</span></span>;</span><br><span class="line">    <span class="function">Item <span class="title">remove</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListQueue</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">MyQueue</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node first;</span><br><span class="line">    <span class="keyword">private</span> Node last;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Item item;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyQueue&lt;Item&gt; <span class="title">add</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node();</span><br><span class="line">        newNode.item = item;</span><br><span class="line">        newNode.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            last = newNode;</span><br><span class="line">            first = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last.next = newNode;</span><br><span class="line">            last = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        N++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">remove</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"queue is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node node = first;</span><br><span class="line">        first = first.next;</span><br><span class="line">        N--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node.item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Item&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            Node cur = first;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cur != <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Item item = cur.item;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="符号表键值对"><a class="markdownIt-Anchor" href="#符号表键值对"></a> 符号表(键值对)</h1>
<h2 id="初级实现"><a class="markdownIt-Anchor" href="#初级实现"></a> 初级实现</h2>
<h3 id="链表实现无序符号表"><a class="markdownIt-Anchor" href="#链表实现无序符号表"></a> 链表实现无序符号表</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListUnorderedST</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        K key;</span><br><span class="line">        V val;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V val, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key,V val)</span></span>&#123;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.key.equals(key))&#123;</span><br><span class="line">                cur.val = val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = <span class="keyword">new</span> Node(key,val,head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.key.equals(key))&#123;</span><br><span class="line">                <span class="keyword">return</span> cur.val;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉查找树-bst"><a class="markdownIt-Anchor" href="#二叉查找树-bst"></a> 二叉查找树 BST</h1>
<ul>
<li>性能取决于键被插入的先后顺序</li>
<li>最好的情况下树是完全平衡的，每条空连接和根节点的距离都是logN</li>
<li>最坏的情况下，树的高度为N</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V val;</span><br><span class="line">    Node left,right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node root;</span><br></pre></td></tr></table></figure>
<h2 id="get"><a class="markdownIt-Anchor" href="#get"></a> get</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">get</span><span class="params">(Node root,K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = key.compareTo(root.key);</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(result &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> get(root.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> get(root.right,key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="put"><a class="markdownIt-Anchor" href="#put"></a> put</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key,V val)</span></span>&#123;</span><br><span class="line">    root = put(root,key,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node root,K key,V val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(key,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = key.compareTo(root.key);</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;</span><br><span class="line">        root.val = val;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(result &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        root.left = put(root.left,key,val);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        root.right = put(root.right,key,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="floor"><a class="markdownIt-Anchor" href="#floor"></a> floor</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">floor</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Node x = floor(root, key);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x.key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">floor</span><span class="params">(Node root,K key)</span></span>&#123;<span class="comment">//返回小于等于key的最大键</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = key.compareTo(root.key);</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(result &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> floor(root.left,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先看看这个key在不在右子树中，如果在则返回，否则当前节点就是所求节点</span></span><br><span class="line">    Node x = floor(root.right,key);</span><br><span class="line">    <span class="keyword">return</span> x !=<span class="keyword">null</span> ? x : root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="rank"><a class="markdownIt-Anchor" href="#rank"></a> rank</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rank(root,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size(root.right) + size(root.left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Node root,K key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = key.compareTo(root.key);</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+size(root.left);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(result &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> rank(root.left,key);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+size(root.left)+rank(root.right,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="min"><a class="markdownIt-Anchor" href="#min"></a> min</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">min</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> min(root).key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">min</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(root.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="deletemin"><a class="markdownIt-Anchor" href="#deletemin"></a> deleteMin</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    root = deleteMin(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">deleteMin</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    root.left = deleteMin(root.left);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="delete"><a class="markdownIt-Anchor" href="#delete"></a> delete</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        root= delete(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">delete</span><span class="params">(Node root,K key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = key.compareTo(root.key);</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left !=<span class="keyword">null</span> &amp;&amp; root.right !=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> min(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(result &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            root.left = delete(root.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            root.right = delete(root.right,key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="散列表"><a class="markdownIt-Anchor" href="#散列表"></a> 散列表</h1>
<h2 id="散列函数"><a class="markdownIt-Anchor" href="#散列函数"></a> 散列函数</h2>
<p>应当满足以下三个性质</p>
<ul>
<li>一致性：相等的键应当有相等的 hash 值，两个键相等表示调用 equals() 返回的值相等。</li>
<li>高效性：计算应当简便，有必要的话可以把 hash 值缓存起来，在调用 hash 函数时直接返回。</li>
<li>均匀性：所有键的 hash 值应当均匀地分布到 [0, M-1] 之间，如果不能满足这个条件，有可能产生很多冲突，从而导致散列表的性能下降。</li>
</ul>
<h2 id="hashcode"><a class="markdownIt-Anchor" href="#hashcode"></a> hashcode</h2>
<ul>
<li>
<p>默认使用内存地址值，是32位整数。一般我们只需要31位非负 整数，因此需要屏蔽符号位之后再除留余数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = (x.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>多属性的hashcode</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String who;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date when;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Transaction</span><span class="params">(String who, Date when, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.who = who;</span><br><span class="line">        <span class="keyword">this</span>.when = when;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = <span class="number">17</span>;</span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">31</span>;</span><br><span class="line">        hash = R * hash + who.hashCode();</span><br><span class="line">        hash = R * hash + when.hashCode();</span><br><span class="line">        hash = R * hash + ((Double) amount).hashCode();</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="哈希冲突"><a class="markdownIt-Anchor" href="#哈希冲突"></a> 哈希冲突</h2>
<h3 id="拉链法"><a class="markdownIt-Anchor" href="#拉链法"></a> 拉链法</h3>
<h3 id="线性探测法"><a class="markdownIt-Anchor" href="#线性探测法"></a> 线性探测法</h3>
<ul>
<li>
<p>查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = hash(key); keys[i] != <span class="keyword">null</span>; i = (i + <span class="number">1</span>) % M)</span><br><span class="line">        <span class="keyword">if</span> (keys[i].equals(key))</span><br><span class="line">            <span class="keyword">return</span> values[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>插入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">    resize();</span><br><span class="line">    putInternal(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putInternal</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = hash(key); keys[i] != <span class="keyword">null</span>; i = (i + <span class="number">1</span>) % M)</span><br><span class="line">        <span class="keyword">if</span> (keys[i].equals(key)) &#123;</span><br><span class="line">            values[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    keys[i] = key;</span><br><span class="line">    values[i] = value;</span><br><span class="line">    N++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = hash(key);</span><br><span class="line">    <span class="keyword">while</span> (keys[i] != <span class="keyword">null</span> &amp;&amp; !key.equals(keys[i]))</span><br><span class="line">        i = (i + <span class="number">1</span>) % M;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不存在，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (keys[i] == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    keys[i] = <span class="keyword">null</span>;</span><br><span class="line">    values[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将之后相连的键值对重新插入</span></span><br><span class="line">    i = (i + <span class="number">1</span>) % M;</span><br><span class="line">    <span class="keyword">while</span> (keys[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Key keyToRedo = keys[i];</span><br><span class="line">        Value valToRedo = values[i];</span><br><span class="line">        keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        values[i] = <span class="keyword">null</span>;</span><br><span class="line">        N--;</span><br><span class="line">        putInternal(keyToRedo, valToRedo);</span><br><span class="line">        i = (i + <span class="number">1</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    N--;</span><br><span class="line">    resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>调整数组大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &gt;= M / <span class="number">2</span>)</span><br><span class="line">        resize(<span class="number">2</span> * M);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (N &lt;= M / <span class="number">8</span>)</span><br><span class="line">        resize(M / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    LinearProbingHashST&lt;Key, Value&gt; t = <span class="keyword">new</span> LinearProbingHashST&lt;Key, Value&gt;(cap);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">        <span class="keyword">if</span> (keys[i] != <span class="keyword">null</span>)</span><br><span class="line">            t.putInternal(keys[i], values[i]);</span><br><span class="line"></span><br><span class="line">    keys = t.keys;</span><br><span class="line">    values = t.values;</span><br><span class="line">    M = t.M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1>
<h2 id="哈夫曼编码"><a class="markdownIt-Anchor" href="#哈夫曼编码"></a> 哈夫曼编码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Huffman</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> freq;</span><br><span class="line">        Node left,right;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">char</span> ch,<span class="keyword">int</span> freq)&#123;</span><br><span class="line">            <span class="keyword">this</span>.ch = ch;</span><br><span class="line">            <span class="keyword">this</span>.freq = freq;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node(Node left,Node right,<span class="keyword">int</span> freq)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">            <span class="keyword">this</span>.freq = freq;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.freq - o.freq;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> Map&lt;Character,String&gt; <span class="title">encode</span><span class="params">(Map&lt;Character, Integer&gt; frequencyForChar)</span></span>&#123;</span><br><span class="line">            PriorityQueue&lt;Node&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(Character character:frequencyForChar.keySet())&#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Node(character,frequencyForChar.get(character)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (queue.size()!=<span class="number">1</span>)&#123;</span><br><span class="line">                Node node1 = queue.poll();</span><br><span class="line">                Node node2 = queue.poll();</span><br><span class="line">                queue.add(<span class="keyword">new</span> Node(node1,node2,node1.freq + node2.freq));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> encode(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> Map&lt;Character,String&gt; <span class="title">encode</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">            Map&lt;Character,String&gt; encoding = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            encode(root,<span class="string">""</span>,encoding);</span><br><span class="line">            <span class="keyword">return</span> encoding;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(Node root,String encoding,Map&lt;Character,String&gt;map)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right== <span class="keyword">null</span>)&#123;</span><br><span class="line">                map.put(root.ch,encoding);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            encode(root.left,encoding+<span class="string">"0"</span>,map);</span><br><span class="line">            encode(root.right,encoding+<span class="string">"1"</span>,map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Character,String&gt; <span class="title">encode</span><span class="params">(Map&lt;Character, Integer&gt; frequencyForChar)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node().encode(frequencyForChar);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Huffman huffman = <span class="keyword">new</span> Huffman();</span><br><span class="line">        Map&lt;Character, Integer&gt; frequencyForChar = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        frequencyForChar.put(<span class="string">'A'</span>,<span class="number">60</span>);</span><br><span class="line">        frequencyForChar.put(<span class="string">'B'</span>,<span class="number">45</span>);</span><br><span class="line">        frequencyForChar.put(<span class="string">'C'</span>,<span class="number">13</span>);</span><br><span class="line">        frequencyForChar.put(<span class="string">'D'</span>,<span class="number">69</span>);</span><br><span class="line">        frequencyForChar.put(<span class="string">'E'</span>,<span class="number">14</span>);</span><br><span class="line">        frequencyForChar.put(<span class="string">'F'</span>,<span class="number">5</span>);</span><br><span class="line">        frequencyForChar.put(<span class="string">'G'</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(huffman.encode(frequencyForChar));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第6章关联规则挖掘</title>
    <url>/2020/06/13/%E7%AC%AC6%E7%AB%A0%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E6%8C%96%E6%8E%98/</url>
    <content><![CDATA[<h1 id="问题定义"><a class="markdownIt-Anchor" href="#问题定义"></a> 问题定义</h1>
<h2 id="二元表示"><a class="markdownIt-Anchor" href="#二元表示"></a> 二元表示</h2>
<img src="/MyImages/image-20200418182019162.png" alt="image-20200418182019162" style="zoom:67%;" />
<ul>
<li><strong>每一行称为一个事务</strong></li>
<li>每一列称为一个项，项可以用<strong>二元变量</strong>表示，如果在事物中出现，则它的值为1，否则为0.因通常关系出现的事物，所以是<strong>非对称的二元变量</strong></li>
</ul>
<h2 id="项集和支持度计数"><a class="markdownIt-Anchor" href="#项集和支持度计数"></a> 项集和支持度计数</h2>
<ul>
<li><strong>项集</strong>是包含0个或多个项的集合</li>
<li>设<strong>I是所有项的集合</strong></li>
<li><strong>设T是所有事务的集合</strong>，每个事务ti包含的项集都是I的子集</li>
<li><strong>事务的宽度</strong>：定义为事务中出现的项的个数</li>
</ul>
<h3 id="项集的支持度计数"><a class="markdownIt-Anchor" href="#项集的支持度计数"></a> 项集的支持度计数</h3>
<ul>
<li>
<p><strong>包含特定项集的事务个数</strong></p>
</li>
<li>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 42: …t_i,t_i\in T\}|$̲$,其中||表示取元素个数

'>\sigma(X)=|\{t_i|X\subset t_i,t_i\in T\}|$$,其中||表示取元素个数

</p>
</li>
<li>
<p><strong>关联规则是型如X-&gt;Y的蕴含表达式</strong>，其中X和Y是不相交的项集，即$$X\and Y=\empty$$.</p>
</li>
<li>
<p>关联规则的强度可以用它的<strong>支持度</strong>和<strong>置信度</strong>衡量。</p>
</li>
<li>
<p><strong>支持度确定规则可以用于给定数据集的频繁程度</strong>*</p>
<ul>
<li>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \or at position 25: …=\frac{\sigma(X\̲o̲r̲ ̲Y)}{N}
'>s(X\to Y)=\frac{\sigma(X\or Y)}{N}
</p>
</li>
<li>支持度很低的规则可能只是偶然出现，因此支持度常用来删去无用的规则</li>
</ul>
</li>
<li>
<p><strong>置信度确定Y在包含X的事务中出现的频繁程度</strong></p>
<ul>
<li>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \or at position 25: …=\frac{\sigma(X\̲o̲r̲ ̲Y)}{\sigma(X)}
'>c(X\to Y)=\frac{\sigma(X\or Y)}{\sigma(X)}
</p>
</li>
<li>置信度衡量通过规则进行推理的可靠性</li>
<li>对于给定规则X→Y，置信度越高，Y在包含X的事务中出现的可能性就越大</li>
</ul>
</li>
</ul>
<h3 id="举例"><a class="markdownIt-Anchor" href="#举例"></a> 举例</h3>
<img src="/MyImages/image-20200418191330794.png" alt="image-20200418191330794" style="zoom:80%;" />
<h2 id="关联规则挖掘问题的形式描述"><a class="markdownIt-Anchor" href="#关联规则挖掘问题的形式描述"></a> 关联规则挖掘问题的形式描述</h2>
<h3 id="关联规则的发现"><a class="markdownIt-Anchor" href="#关联规则的发现"></a> 关联规则的发现</h3>
<ul>
<li>指定事务的集合T,关联规则发现是指找出支持度大于等于minsup并且置信度大于等于minconf的所有规则,其中 minrup和 mincorf是对应的支持度和置信度阈值。</li>
</ul>
<h3 id="关联规则的挖掘算法"><a class="markdownIt-Anchor" href="#关联规则的挖掘算法"></a> 关联规则的挖掘算法</h3>
<ul>
<li>
<p>如果枚举所有规则，计算其支持度和置信度，代价太高</p>
<ul>
<li><strong>包含d个项的数据集提取的可能规则的总数为$$R=3<sup>d-2</sup>{d+1}+1$$</strong></li>
</ul>
</li>
<li>
<p>考虑进行剪枝，首先减去包含不频繁项集的规则</p>
<ul>
<li>
<p>例如对于项集{啤酒,尿布,牛奶}，存在规则</p>
<p>{啤酒,尿布}→{午奶}，{啤源,牛奶}一{尿布},</p>
<p>{尿布,牛奶}→{啤酒}，{啤酒→{尿布,牛奶},</p>
<p>{牛奶}→{啤酒.尿布}，{尿布}→{酒,牛奶}</p>
</li>
<li>
<p>如果{啤酒,尿布,牛奶}非频繁，则立即剪掉6个候选规则</p>
</li>
</ul>
</li>
<li>
<p>因此，将关联规则挖掘分解成两个子任务</p>
<ul>
<li><strong>频繁项集产生</strong>：目标是发现满足最小支持度阈值的所有项集,这些项集称作频繁项集</li>
<li><strong>规则的产生</strong>：目标是从上一步发现的频繁项集中提取所有高置信度的规则,这些规则称作强规则</li>
</ul>
</li>
</ul>
<h1 id="频繁项集的产生"><a class="markdownIt-Anchor" href="#频繁项集的产生"></a> 频繁项集的产生</h1>
<h2 id="先验原理"><a class="markdownIt-Anchor" href="#先验原理"></a> 先验原理</h2>
<h3 id="定理如果一个项集是频繁的那么他的所有子集一定也是频繁的"><a class="markdownIt-Anchor" href="#定理如果一个项集是频繁的那么他的所有子集一定也是频繁的"></a> 定理：如果一个项集是频繁的，那么他的所有子集一定也是频繁的</h3>
<ul>
<li>剪枝：一旦发现一个项集是非频繁的，那么它的所有超集也一定是非频繁的。</li>
<li>这个剪枝依赖于：<strong>一个项集的支持度绝不会超过它的子集的支持度</strong> (支持度的反单调性)</li>
</ul>
<h3 id="单调性"><a class="markdownIt-Anchor" href="#单调性"></a> 单调性</h3>
<ul>
<li>令I是项的集合，$$J=2^I$$是I的幂集。度量f是单调的
<ul>
<li>若$$\forall X,Y\in J:(X\subset Y)\to f(X)\leq f(Y)$$，则称f是单调的</li>
<li>若$$\forall X,Y\in J:(X\subset Y)\to f(Y)\leq f(X)$$，则称f是反单调的</li>
</ul>
</li>
<li><strong>任何具有反单调性的度量都能够直接结合到挖掘算法中</strong></li>
</ul>
<img src="/MyImages/image-20200425141506188.png" alt="image-20200425141506188" style="zoom: 33%;" />
<h2 id="apriori-算法的频繁项集的产生"><a class="markdownIt-Anchor" href="#apriori-算法的频繁项集的产生"></a> Apriori 算法的频繁项集的产生</h2>
<ul>
<li>使用基于支持度的剪枝技术，控制候选项集的指数增长</li>
</ul>
<img src="/MyImages/image-20200425125637999.png" alt="image-20200425125637999" style="zoom: 50%;" />
<h3 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h3>
<ul>
<li>初始通过单遍扫描数据集，确定每个项的支持度。一旦完成这一步，就得到所有频繁1-项集的集合F<sub>1</sub></li>
<li>接下来，该算法使用上一次迭代发现的频繁(k-1)项集，产生新的候选k-项集。候选的产生使用apriori-gen函数实现</li>
<li>为了对候选项的支持度计数，算法需要再次扫描一遍数据集。使用子集函数确定包含在每一个事务t中的C<sub>k</sub>中的所有候选k-项集。</li>
<li>计算候选项的支持度计数后，算法将删去支持度计数小于minsup的所有候选项集</li>
<li>当没有新的频繁项集产生，即$$F_k=\empty$$，算法结束</li>
</ul>
<h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3>
<ul>
<li>逐层进行，从频繁1-项集到最长的频繁项集，每次遍历项集格中的一层</li>
<li>使用产生-测试策略来发现频繁项集</li>
<li>该算法总迭代次数是k<sub>max</sub>+1，其中k<sub>max</sub>是频繁项集的最大长度</li>
</ul>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<ul>
<li>
<p>如何产生候选集</p>
<ol>
<li>自合并(仿照自连接，必须有相同的部分)</li>
<li>修剪pruning：如果一个候选集是频繁的，那么他的所有非空子集也要求是频繁的，否则删除</li>
</ol>
</li>
<li>
<p>举例</p>
<p>L3={abc, abd, acd, ace, bcd}<br />
Self-joining: L3*L3<br />
abcd from abc and abd<br />
acde from acd and ace<br />
Pruning:  <strong>acde is removed because ade is not in L3</strong><br />
C4={abcd}</p>
</li>
<li>
<p>存在O(NMw)次比较，其中N是事务数，M=2<sup>k</sup>-1是候选项集数，而w是事务的最大宽度</p>
</li>
<li>
<p><strong>关于修剪</strong></p>
<ul>
<li>满足规则$$\forall X,Y:(X\sub Y)\to s(X)\geq (Y)$$项集的支持度一定小于任意子集的支持度</li>
</ul>
</li>
<li>
<p>降低产生频繁项集的计算复杂度</p>
<ul>
<li>减少候选项集的数目</li>
<li>减少比较次数
<ul>
<li>可以使用高级的数据结构</li>
<li>压缩数据集</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="候选的产生与剪枝"><a class="markdownIt-Anchor" href="#候选的产生与剪枝"></a> 候选的产生与剪枝</h2>
<ul>
<li>对于候选k-项集，我们并不需要检查给定候选项集的所有k格子集。如果k个子集中的m个用来产生候选项集，则再候选项集剪枝时只需要检查剩下的k-m个子集</li>
</ul>
<h3 id="蛮力法"><a class="markdownIt-Anchor" href="#蛮力法"></a> 蛮力法</h3>
<ul>
<li>如果要产生k项集，那么先拿出$$C_d^k$$个，其中d是项的总数。之后再剪枝</li>
</ul>
<h3 id="fk-1f1法"><a class="markdownIt-Anchor" href="#fk-1f1法"></a> F<sub>k-1</sub>×F<sub>1</sub>法</h3>
<ul>
<li><strong>问题</strong>是不可避免产生重复的候选项</li>
<li><strong>解决</strong>：确保每个频繁项集中的项以字典序存储，每个频繁(k-1)-项集X只用字典序比X中所有的项都大的频繁项进行扩展。例如,项集(面包,尿布)可以用项集(牛奶)扩展,因为&quot;牛奶&quot;（Mik）在字典序下比&quot;面包&quot;（Bread)和&quot;尿布&quot;(Dapers)都大．然而,不应当用(面包]扩展(尿布,牛奶|或用(尿布)扩展(面包,牛奶),因为它们违反了字典序条件。</li>
</ul>
<h3 id="fk-1fk-1法"><a class="markdownIt-Anchor" href="#fk-1fk-1法"></a> F<sub>k-1</sub>×F<sub>k-1</sub>法</h3>
<ul>
<li>候选产生过程是合并一对频繁(k-1)-项集，仅当他们的前k-2项都相同</li>
</ul>
<h2 id="支持度计数"><a class="markdownIt-Anchor" href="#支持度计数"></a> 支持度计数</h2>
<h3 id="枚举事务t的所有3个项的子集"><a class="markdownIt-Anchor" href="#枚举事务t的所有3个项的子集"></a> 枚举事务t的所有3个项的子集</h3>
<img src="/MyImages/image-20200425175458505.png" alt="image-20200425175458505" style="zoom:50%;" />
<ul>
<li>所有3-项集一定以项1、2和3开始，不必构造以5和6开始的3-项集。因为事务t中只有两个项的标号大于等于5</li>
</ul>
<h3 id="使用hash树进行支持度计数"><a class="markdownIt-Anchor" href="#使用hash树进行支持度计数"></a> 使用Hash树进行支持度计数</h3>
<ul>
<li>
<p>在Apriori算法中，候选项集划分为不同的捅，并存放在Hash树种。在支持度计数期间，包含在事务种的项集也散列到相应的桶中。这种方法不是将事务中的每个项集与所有的候选项集进行比较，而是将它与同一个桶内的候选项集纪念性比较</p>
<img src="/MyImages/image-20200425180039465.png" alt="image-20200425180039465" style="zoom: 50%;" />
</li>
<li>
<p><img src="/MyImages/image-20200425181055739.png" alt="image-20200425181055739" style="zoom:67%;" />以$$h§=pMod3$$来确定应该沿着哪个分支向下</p>
</li>
<li>
<p><strong>更新候选项集的支持度计数，遍历Hash树</strong>：例如对事务t={1,2,3,5,6}进行更新，所有包含属于t的候选3-项集的叶结点都至少访问一次（<strong>包含在t中的候选3-项集必然以1，2，或3开始</strong>）</p>
<img src="/MyImages/image-20200425183055736.png" alt="image-20200425183055736" style="zoom: 67%;" />
<ul>
<li>本小节中第一图的第一层前缀结构所示。这样,在Hash 树的根结点,事务中的项1.2和3将分别散列,项 1被散列到根结点的左千女,项2被散列到中间子女,而项3被散列到右子女。在树的下一层,事务根据图6-9中的第二层结构列出的第二项进行散列。例如,在根结点散列项1之后,散列事务的项2、3和5.项2和5散列到中间子女,而3散列到右子女,|如上图所示。维续该过程,直至到达 Hash 树的叶结点。存放在被访闻的叶结点中的候选项集与事务进行比较,如果候选项集是该事务的子集,则增加它的支持度计数</li>
</ul>
</li>
<li>
<p><strong>复杂度分析</strong></p>
<ul>
<li>查找一个候选的花费是O(k)</li>
<li>将候选项集散列到Hash树的开销为$$O(\sum_{k=2}^wk|C_k|)$$</li>
<li>剪枝过程中需要检验每个候选k-项集的k-2个子集是否频繁，所以复杂度为$$O(\sum_{k=2}^wk(k-2)|C_k|)$$</li>
<li>支持度计数的开销为$$O(N\sum_kC_w^k\alpha_k)$$其中w是事务的最大宽度，$$\alpha_k$$是更新Hash树中一个候选k-项集的支持度计数的开销</li>
</ul>
</li>
</ul>
<h1 id="规则产生"><a class="markdownIt-Anchor" href="#规则产生"></a> 规则产生</h1>
<h2 id="基于置信度的剪枝"><a class="markdownIt-Anchor" href="#基于置信度的剪枝"></a> 基于置信度的剪枝</h2>
<h3 id="定理"><a class="markdownIt-Anchor" href="#定理"></a> 定理</h3>
<p><strong>如果规则X→ Y-X不满足置信度阖值,则形如X’→Y-X’的规则一定也不满足置信度阈值,其中X’是X的子集。</strong></p>
<h2 id="apriori算法中规则的产生"><a class="markdownIt-Anchor" href="#apriori算法中规则的产生"></a> Apriori算法中规则的产生</h2>
<ul>
<li>使用逐层方法产生关联规则，其中每层对应于规则后件中的项数。</li>
</ul>
<img src="/MyImages/image-20200425190441649.png" alt="image-20200425190441649" style="zoom: 67%;" />
<ul>
<li>初始，提取规则后件只含一个项的所有高置信度规则。例如$${acd}\to{b}和{abd}\to{c}$$</li>
<li>合并后后件得到{ad}-&gt;{bc}</li>
<li>对于低置信度规则，比如{bcd}-&gt;{a}，则可以丢弃后件包含a的所有规则，包括{ed}→{ab},{bd}→{ac},{bc}→{ad}和{d}→{abc}</li>
</ul>
<h2 id="举例-2"><a class="markdownIt-Anchor" href="#举例-2"></a> 举例</h2>
<img src="/MyImages/image-20200425134410506.png" alt="image-20200425134410506" style="zoom: 50%;" />
<h2 id="挑战"><a class="markdownIt-Anchor" href="#挑战"></a> 挑战</h2>
<ul>
<li>需要多次扫描数据库</li>
<li>对候选集的每个非空子集都要扫描数据库计算置信度</li>
</ul>
<h2 id="改进方法"><a class="markdownIt-Anchor" href="#改进方法"></a> 改进方法</h2>
<ul>
<li>减少扫描次数
<ul>
<li>动态调整数据库的大小</li>
</ul>
</li>
<li>减少候选集
<ul>
<li>使用剪枝pruning</li>
</ul>
</li>
<li>加速置信度的计算
<ul>
<li>减少比较次数
<ul>
<li>使用特殊的数据结构存储候选集和数据库（比如哈希存储）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="频繁项集的紧凑表示"><a class="markdownIt-Anchor" href="#频繁项集的紧凑表示"></a> 频繁项集的紧凑表示</h1>
<h2 id="极大频繁项集"><a class="markdownIt-Anchor" href="#极大频繁项集"></a> 极大频繁项集</h2>
<ul>
<li><strong>极大频繁项集</strong>：本身是频繁项集，但是他的直接超集都不是频繁的</li>
<li>其他的频繁项集都是他们的子集，但是要确定子集的支持度仍然需要扫描数据库</li>
</ul>
<h2 id="闭频繁项集"><a class="markdownIt-Anchor" href="#闭频繁项集"></a> 闭频繁项集</h2>
<ul>
<li>提供频繁项集的一种最小表示，不丢失支持度信息</li>
<li><strong>闭项集</strong> 项集X是闭的，如果他的直接超集都不具有和它相同的支持度计数</li>
<li><strong>闭频繁项集</strong> 一个项集是频繁项集，如果它是闭的，并且它的支持度大于或等于最小支持度阈值</li>
<li><strong>结论</strong>非闭频繁项集的支持度一定等于它的超集的最大支持度</li>
<li><strong>结论</strong>。关联规则X→Y是冗余的,如果存在另一个关联规则X→Y使得两个规则的支持度和置信度都相同,其中,X’是 X的子集,并且Y‘是Y的子集。</li>
<li><strong>结论</strong>极大频繁项集都是闭的，因为任何极大频繁项集都不可能与它的直接超集具有相同的支持度计数</li>
</ul>
<h1 id="产生频繁项集的其他方法"><a class="markdownIt-Anchor" href="#产生频繁项集的其他方法"></a> 产生频繁项集的其他方法</h1>
<h2 id="apriori算法"><a class="markdownIt-Anchor" href="#apriori算法"></a> Apriori算法</h2>
<ul>
<li>使用先验原理对指数搜索空间进行剪枝，解决组合爆炸问题</li>
<li>仍有不可低估的I/O开销，因为需要多次扫描数据库。如果事务数据宽度很大，那么Apriori算法的性能会显著下降</li>
</ul>
<h2 id="项集格的遍历"><a class="markdownIt-Anchor" href="#项集格的遍历"></a> 项集格的遍历</h2>
<h3 id="一般到特殊与特殊到一般"><a class="markdownIt-Anchor" href="#一般到特殊与特殊到一般"></a> 一般到特殊与特殊到一般</h3>
<ul>
<li>Apriori算法使用一般到特殊的搜索策略，合并两个频繁(k-1)项集得到k-项集</li>
<li><strong>特殊到一般</strong>：是寻找更特殊的频繁项集，这样利于发现稠密事务种的极大频繁项集
<ul>
<li>可以利用先验原理剪掉极大频繁项集的任意k-1项子集</li>
<li>如果k-项集是非频繁的，那么要考察所有k-1项集</li>
</ul>
</li>
</ul>
<h3 id="等价类"><a class="markdownIt-Anchor" href="#等价类"></a> 等价类</h3>
<ul>
<li>
<p>方法是先将格划分为两个不相交的结点组（或等价类）。频繁项集产生算法依次在每个等价类内搜索频繁项集。</p>
</li>
<li>
<p>可以组成前缀树或后缀树</p>
<img src="/MyImages/image-20200505162758331.png" alt="image-20200505162758331" style="zoom:50%;" />
</li>
</ul>
<h3 id="宽度优先和深度优先"><a class="markdownIt-Anchor" href="#宽度优先和深度优先"></a> 宽度优先和深度优先</h3>
<ul>
<li>Apriori算法采用<strong>宽度优先</strong>的方法遍历格</li>
<li><strong>深度优先</strong>的话，可以逐渐向下扩展直到到达一个非频繁结点
<ul>
<li>深度优先搜索用于寻找极大频繁项集，如果bcde是极大频繁项集，那么算法不必访问bd,be,c,d和e为根的子树了</li>
</ul>
</li>
</ul>
<h2 id="事务数据集的表示"><a class="markdownIt-Anchor" href="#事务数据集的表示"></a> 事务数据集的表示</h2>
<img src="/MyImages/image-20200505164822195.png" alt="image-20200505164822195" style="zoom:50%;" />
<h1 id="fp增长算法"><a class="markdownIt-Anchor" href="#fp增长算法"></a> FP增长算法</h1>
<ul>
<li>是一种输入数据的压缩表示，通过逐个读入事务，并把每个事务映射到FP树中的一条路径来构造，他们的枯井可能部分重叠，所以有压缩的效果。</li>
<li>如果FP树足够小，能放在内存中，就可以加速扫描过程</li>
</ul>
<h2 id="fp树表示法"><a class="markdownIt-Anchor" href="#fp树表示法"></a> FP树表示法</h2>
<img src="/MyImages/image-20200505170421773.png" alt="image-20200505170421773" style="zoom: 67%;" />
<h3 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h3>
<img src="/MyImages/image-20200505165945063.png" alt="image-20200505165945063" style="zoom: 67%;" />
<ul>
<li>
<p>最好情况下：所有的事务都具有相同的项集,FP树只包含一条结点路径</p>
</li>
<li>
<p>最坏情况下：当每个事务都具有唯一项集时,导致最坏情况发生,由于事务不包含任何共同项,FP树的大小实际上与原数据的大小一样。由于附加的存储空间导致FP树的存储需求更大</p>
</li>
<li>
<p>树的大小与支持度排序方向也有关</p>
</li>
</ul>
<h2 id="fp增长算法的频繁项集产生"><a class="markdownIt-Anchor" href="#fp增长算法的频繁项集产生"></a> FP增长算法的频繁项集产生</h2>
<img src="/MyImages/image-20200505171055366.png" alt="image-20200505171055366" style="zoom:67%;" />
<ul>
<li>
<img src="/MyImages/image-20200505171251980.png" alt="image-20200505171251980" style="zoom:67%;" />
</li>
<li>假设对发现所有以e结尾的频繁项集感兴趣。为了实现这个目的,必须首先检查项集[e)本身是否频繁。如果它是频繁的,则考虑发现以de结尾的频繁项集子问题,接下来是ce和ae.依次,每一个子问题可以迷一步划分为更小的子问题。通过合并这些子闻题得到的结果,就可以找到所有以e结尾的频繁项集。这种分治策略是FP增长算法采用的关键策略。</li>
</ul>
<h3 id="算法过程"><a class="markdownIt-Anchor" href="#算法过程"></a> 算法过程</h3>
<ol>
<li>
<p>第一步收集包含e结点的所有路径。这些初始的路径称为前缀路径</p>
</li>
<li>
<p>根据前缀路径，通过把与结点e相关联的支持度计数相加得到e的支持度计数。假定最小支持度为2，因为e的支持度为3所以他是频繁项集</p>
</li>
<li>
<p>由于e是频繁的，因此需要发现以de,ce,be和ae结尾的频繁项集的子问题。为了解决这些子问题，必须将前缀路径转化为条件FP树，获取 condition FP-tree</p>
<ol>
<li>
<p>首先，更新前缀路径上的支持度计数，因为某些计数包括那些不含项e的事务。例如，上图a中最右边路径$$null\to b:2\to c:2\to e:1$$，包含并不含项e的事务{b,c}。因此，必须将该前缀路径上的计数调整为1，以反应包含{b,c,e}的事务的实际个数</p>
</li>
<li>
<p>删除e的结点，修剪前缀路径。删除这些结点是因为，沿这些前缀路径的支持度计数已经更新，以反应包含e的那些事务，并发现以de,ce,be和ae结尾的频繁项集的子问题不再需要结点e的信息。</p>
</li>
<li>
<p>更新沿前缀路径上的支持度计数后，某些项可能不再是频繁的。例如，结点b只出现了1次，它的支持度计数等于1，这就意味着只有一个事务同时包含b和e。因为所有以be结尾的项集一定都是非频繁的，所以在其后的分析中可以安全的忽略b。</p>
<img src="/MyImages/image-20200512111855130.png" alt="image-20200512111855130" style="zoom:67%;" />
</li>
</ol>
</li>
<li>
<p>使用e的条件FP树来发现以de,ce,be和ae解为的频繁项集的子问题。为了发现以de结尾的频繁项集，从e的条件FP树收集d的所有前缀路径。通过将与结点d相关联的频度计数求和，得到项集{d,e}的支持度计数，为2。接下来，再构建de的条件FP树，更新支持度计数并删除非频繁项集c之后，de的条件FP树为d图。因为该条件FP树只包含一个支持度等于最小支持度的项a，算法提取出频繁项集{a,d,e}并转到下一个子问题，产生以ce结尾的频繁项集。处理c的前缀路径后，只发现项集{c,e}是频繁的。接下来，算法继续解决下一个子问题并发现项集{a,e}是剩下唯一的频繁项集。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑书稿</title>
    <url>/2020/03/30/%E7%BC%96%E8%BE%91%E4%B9%A6%E7%A8%BF/</url>
    <content><![CDATA[<h1 id="uva-11212-编辑书稿"><a class="markdownIt-Anchor" href="#uva-11212-编辑书稿"></a> UVA 11212 编辑书稿</h1>
<p>你有一篇n(2≤n≤9)个自然段组成的文章，希望将它们排列成1，2，…，n。可以用Ctrl+X（剪切）和Ctrl+V（粘贴）快捷键来完成任务。每次可以剪切一段连续的自然段，粘贴时按照顺序粘贴。注意，剪贴板只有一个，所以不能连续剪切两次，只能剪切和粘贴交替。例如，为了将{2，4，1，5，3，6}变为升序，可以剪切1将其放到2前，然后剪切3将其放到4前。再如，排列{3，4，5，1，2}，只需一次剪切和一次粘贴即可——将{3，4，5}放在{1，2}后，或者将{1，2}放在{3，4，5}前。</p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<ol>
<li>
<p>典型的状态空间搜索问题，其中的状态是1-n的排列。排列最多有9！个。但是由于剪切和粘贴的位置不定，所以搜索空间很大。</p>
</li>
<li>
<p>关于剪枝</p>
<ol>
<li>每次只剪切一段连续的数字，不破坏已经有序的串。</li>
<li>每次剪切至多使后继数字不正确的个数减少3个。考虑abc变成acb时，a b c 三段的末尾的数字。</li>
</ol>
</li>
<li>
<p>迭代加深搜。迭代以获得下一次递归调用的初始状态，深度搜索来找解。迭代的时候需要枚举剪切的长度，剪切和粘贴的起始位置。注意循环的边界问题。</p>
</li>
<li>
<p>进行剪切和粘贴的时候，要分情况，因为涉及到其他元素往前移动还是往后移动的问题。</p>
<ol>
<li>如果start位置在pos后面，那么粘贴之后，需要将pos之后到start的元素向后移动len位。</li>
<li>同理如果start在pos前面，则需要从pos开始到start之前的元素向前移动len位。</li>
</ol>
</li>
</ol>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<h3 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> dfs()</h3>
<pre><code>bool dfs(int d) {
if (d == maxd) 
	return not_inorder(d) == 0;
if (d * 3 + not_inorder(d) &gt; 3 * maxd) return false; //每次剪切时后继不正确的数字个数至多减少三个
													//考虑abc变成acb，那么受影响的至多是a b c的最后一个数

//枚举剪切的起始位置和长度
int next = d + 1;
for (rint len = 0; len &lt; T; len++) {
	for (rint start = 0; start &lt;= T - len; start++) {


		//如果试图剪切有序串，那么剪枝
		if (start &gt; 0 &amp;&amp; in[d][start - 1] == in[d][start] - 1) continue;
		if (start + len &lt; T &amp;&amp; in[d][start + d - 1] == in[d][start + d] - 1) continue;

		//枚举粘贴的起始位置
		for (rint pos = 0; pos &lt;= T - len; pos++)
		{
			//也不能粘到自己里面
			if (pos &gt;= start &amp;&amp; pos &lt; start + len) continue;
			for (rint i = 0; i &lt; T; i++) in[next][i] = in[d][i];
			//粘贴
			for (rint i = 0; i &lt; len; i++)
				in[next][pos + i] = in[d][start + i];

			if (pos &lt; start)
				for (rint i(pos); i &lt; start; ++i)
					in[next][i + len] = in[d][i];
			else
				for (rint i(pos); i &gt; start; --i)
					in[next][i - len] = in[d][i];
			if (dfs(next)) return true;
		}

	}
}
return false;
}
</code></pre>
<h3 id="not_inorder-返回后继不正确的数字的个数"><a class="markdownIt-Anchor" href="#not_inorder-返回后继不正确的数字的个数"></a> not_inorder() 返回后继不正确的数字的个数</h3>
<pre><code>inline int not_inorder(int d) {
int ret(0);
for (int i(0); i &lt; T - 1; ++i)
	ret += in[d][i + 1] != in[d][i] + 1;
return ret + (in[d][T - 1] != (T - 1));

}</code></pre>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>缩点</title>
    <url>/2020/03/30/%E7%BC%A9%E7%82%B9/</url>
    <content><![CDATA[<h1 id="缩点"><a class="markdownIt-Anchor" href="#缩点"></a> 缩点</h1>
<h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2>
<p>给定一个 n个点 m 条边有向图，每个点有一个权值，求一条路径，使路径经过的点权值之和最大。你只需要求出这个权值和。</p>
<p>允许多次经过一条边或者一个点，但是，重复经过的点，权值只计算一次。</p>
<h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2>
<p>第一行两个正整数 n,m</p>
<p>第二行 n 个整数，依次代表点权</p>
<p>第三至 m+2 行，每行两个整数 u,v*，表示一条 u-&gt;v 的有向边。</p>
<h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2>
<p>共一行，最大的点权之和。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>由于经过相同的点的权值只计算一次。一方面，在一个环中反复走没有意义。另一方面，一旦选定环中一个点，就应该选择所有的点。</li>
<li>使用Tarjan算法对原图进行缩点，将强连通分量中的点合并成一个。</li>
<li>之后使用dp求得最优解即可。实现时，还加入了拓扑排序，其实没屁用。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="tarjan"><a class="markdownIt-Anchor" href="#tarjan"></a> tarjan</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 10000 + 5;</span><br><span class="line">int dfn[maxn], instack[maxn], low[maxn],st[maxn];</span><br><span class="line">int Tree[maxn], indegree[maxn],dp[maxn];</span><br><span class="line">int w[maxn];</span><br><span class="line">int sum;</span><br><span class="line">int head[maxn],h[maxn];</span><br><span class="line">struct EDGE</span><br><span class="line">&#123;</span><br><span class="line">	int to; int next; int from;</span><br><span class="line">&#125;edge[maxn * 10], ed[maxn * 10];</span><br><span class="line">int n, m;</span><br><span class="line">int clk &#x3D; 0;</span><br><span class="line">int top;</span><br><span class="line">void tarjan(int u) &#123;</span><br><span class="line">	dfn[u] &#x3D; low[u] &#x3D; ++clk;</span><br><span class="line">	st[++top] &#x3D; u;</span><br><span class="line">	instack[u] &#x3D; 1;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; head[u]; i; i &#x3D; edge[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		int v &#x3D; edge[i].to;</span><br><span class="line">		if (!dfn[v]) &#123;</span><br><span class="line">			tarjan(v);</span><br><span class="line">			low[u] &#x3D; min(low[u], low[v]);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (instack[v])</span><br><span class="line">			low[u] &#x3D; min(low[u], dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	if (low[u] &#x3D;&#x3D; dfn[u]) &#123;</span><br><span class="line">		int tp;</span><br><span class="line">		while (tp &#x3D; st[top--])&#123;</span><br><span class="line">			Tree[tp] &#x3D; u;</span><br><span class="line">			instack[tp] &#x3D; 0;</span><br><span class="line">			if (tp &#x3D;&#x3D; u) break;</span><br><span class="line">			w[u] +&#x3D; w[tp];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dp过程"><a class="markdownIt-Anchor" href="#dp过程"></a> dp过程</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int topo()</span><br><span class="line">&#123;</span><br><span class="line">	queue &lt;int&gt; q;</span><br><span class="line">	int tot &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">		if (Tree[i] &#x3D;&#x3D; i &amp;&amp; !indegree[i])</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">			q.push(i);</span><br><span class="line">			dp[i] &#x3D; w[i];</span><br><span class="line">		&#125;</span><br><span class="line">	while (!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		int k &#x3D; q.front(); q.pop();</span><br><span class="line">		for (int i &#x3D; h[k]; i; i &#x3D; ed[i].next)</span><br><span class="line">		&#123;</span><br><span class="line">			int v &#x3D; ed[i].to;</span><br><span class="line">			dp[v] &#x3D; max(dp[v], dp[k] + w[v]);</span><br><span class="line">			indegree[v]--;</span><br><span class="line">			if (indegree[v] &#x3D;&#x3D; 0) q.push(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	int ans &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">		ans &#x3D; max(ans, dp[i]);</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void add(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">	edge[++sum].next &#x3D; head[x];</span><br><span class="line">	edge[sum].from &#x3D; x;</span><br><span class="line">	edge[sum].to &#x3D; y;</span><br><span class="line">	head[x] &#x3D; sum;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">	int a, b;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;w[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">		scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">		add(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">		if (!dfn[i]) &#123;</span><br><span class="line">			tarjan(i);</span><br><span class="line">		&#125;</span><br><span class="line">	int s &#x3D; 0;</span><br><span class="line">	for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int x &#x3D; Tree[edge[i].from], y &#x3D; Tree[edge[i].to];</span><br><span class="line">		if (x !&#x3D; y)</span><br><span class="line">		&#123;</span><br><span class="line">			ed[++s].next &#x3D; h[x];</span><br><span class="line">			ed[s].to &#x3D; y;</span><br><span class="line">			ed[s].from &#x3D; x;</span><br><span class="line">			h[x] &#x3D; s;</span><br><span class="line">			indegree[y]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d&quot;, topo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重写的前向列表法"><a class="markdownIt-Anchor" href="#重写的前向列表法"></a> 重写的前向列表法</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000</span> + <span class="number">15</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line">Edge edge[maxn * <span class="number">10</span>], ed[maxn * <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], st[maxn], low[maxn], dfn[maxn], Tree[maxn], w[maxn], indegree[maxn];</span><br><span class="line"><span class="keyword">int</span> instack[maxn];</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>, clk = <span class="number">0</span>, top = <span class="number">0</span>, n, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	edge[++sum].next = head[a];</span><br><span class="line">	edge[sum].a = a;</span><br><span class="line">	edge[sum].b = b;</span><br><span class="line">	head[a] = sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	low[u] = dfn[u] = ++clk;</span><br><span class="line">	st[++top] = u;</span><br><span class="line">	instack[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = edge[i].next) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = edge[i].b;</span><br><span class="line">		<span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">			tarjan(v);</span><br><span class="line">			low[u] = <span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (instack[v])</span><br><span class="line">			low[u] = <span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">		<span class="keyword">int</span> tp;</span><br><span class="line">		<span class="keyword">while</span> (tp = st[top--]) &#123;</span><br><span class="line">			Tree[tp] = u;</span><br><span class="line">			instack[tp] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (tp == u) <span class="keyword">break</span>;</span><br><span class="line">			w[u] += w[tp];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[maxn]&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (Tree[i] == i &amp;&amp; indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">			dp[i] = w[i];</span><br><span class="line">			q.push(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = edge[i].next) &#123;</span><br><span class="line">			<span class="keyword">int</span> v = edge[i].b;</span><br><span class="line">			dp[v] = <span class="built_in">max</span>(dp[v], dp[u] + w[v]);</span><br><span class="line">			indegree[v]--;</span><br><span class="line">			<span class="keyword">if</span> (indegree[v] == <span class="number">0</span>)</span><br><span class="line">				q.push(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (dp[i] &gt; ans)</span><br><span class="line">			ans = dp[i];</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a, b;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">		add_edge(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (!dfn[i])</span><br><span class="line">			tarjan(i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		ed[i] = edge[i];</span><br><span class="line">	<span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">	<span class="comment">//memset(edge, 0, sizeof(edge));</span></span><br><span class="line">	sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> ta = Tree[ed[i].a];</span><br><span class="line">		<span class="keyword">int</span> tb = Tree[ed[i].b];</span><br><span class="line">		<span class="keyword">if</span> (ta != tb) &#123;</span><br><span class="line">			add_edge(ta, tb);</span><br><span class="line">			indegree[tb]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, topo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>网格动物</title>
    <url>/2020/03/30/%E7%BD%91%E6%A0%BC%E5%8A%A8%E7%89%A9/</url>
    <content><![CDATA[<h1 id="uva-1602-网格动物"><a class="markdownIt-Anchor" href="#uva-1602-网格动物"></a> UVA 1602 网格动物</h1>
<p>输入n,w,h(1&lt;=n&lt;=10,1&lt;=w,h&lt;=n).求能放在w*h网格里的不同的n连块的个数(平移,旋转,翻转算一种)</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>
<p>如果对于每次的输入计算结果，会超时，所以先打表。</p>
</li>
<li>
<p>题目问有多少种连通块，所以直观的想到不断的在格子周围扩展各自，然后判断是否重复，不重复则加入到集合中。</p>
</li>
<li>
<p>主要的数据结构为set(set(node))[maxn]，点的集合构成一种连通格，相同连通数的图构成i连通块的动物集合。i格连通的动物存在数组下标为i的集合中。使用点集来存图，一方面可以节省空间，另一方面便于实现平移旋转翻转</p>
</li>
<li>
<p>还需要实现平移，旋转，翻转</p>
<ol>
<li>平移：统一平移到原点</li>
<li>旋转：顺时针旋转90度，画个图就明白了</li>
<li>翻转：实现是关于x轴翻转</li>
</ol>
</li>
<li>
<p>打表：打表是一个迭代枚举的过程，后代是对前一代节点周围区域的扩展。由于normal的过程，所以不需要判断越界问题，即使出现负坐标，normal也会将他平移到原点。之后，在循环n,w,h将对应结果存在一个三维数组中即可。</p>
</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="打表"><a class="markdownIt-Anchor" href="#打表"></a> 打表</h2>
<pre><code>void get_ans() {
g start;
start.insert(node(0, 0));
animals[1].insert(start);
for (int i = 2; i &lt;= maxn; i++)
	for (set&lt;g&gt;::iterator j = animals[i - 1].begin(); j != animals[i - 1].end(); j++)
		for (g::iterator k = (*j).begin(); k != (*j).end(); k++) {
			int r = k-&gt;r, c = k-&gt;c;
			for (int w = 0; w &lt; 4; w++) {
				node nd(r + dx[w], c + dy[w]);
				if (!(*j).count(nd))
					insert(*j, nd);
			}
		}


for (int n = 1; n &lt;= maxn; n++)
	for (int w = 1; w &lt;= maxn; w++)
		for (int h = 1; h &lt;= maxn; h++) {
			int sum = 0;
			for (set&lt;g&gt;::iterator p = animals[n].begin(); p != animals[n].end(); p++) {
				int maxx = 0, maxy = 0;
				for (g::iterator q = (*p).begin(); q != (*p).end(); q++) {
					maxx = max(maxx, q-&gt;r);
					maxy = max(maxy, q-&gt;c);
				}
				if (max(maxx, maxy) &lt; max(w, h) &amp;&amp; min(maxx, maxy) &lt; min(w, h)) sum++;
			}
			ans[n][w][h] = sum;
		}
}
</code></pre>
<h2 id="判重及旋转平移翻转"><a class="markdownIt-Anchor" href="#判重及旋转平移翻转"></a> 判重及旋转,平移，翻转</h2>
<pre><code>g normal(const g&amp; p) {
int minx = p.begin()-&gt;r, miny = p.begin()-&gt;c;
for (g::iterator i = p.begin(); i != p.end(); i++) {
	minx = min(minx, i-&gt;r);
	miny = min(miny, i-&gt;c);
}
g p2;
for (g::iterator i = p.begin(); i != p.end(); i++)
	p2.insert(node(i-&gt;r - minx, i-&gt;c - miny));
return p2;
}
g turn(const g&amp;p) {
g p2;
for (g::iterator i = p.begin(); i != p.end(); i++)
	p2.insert(node(i-&gt;c, -i-&gt;r));
return normal(p2);
}
g filp(const g&amp;p) {
g p2;
for (g::iterator i = p.begin(); i != p.end(); i++)
	p2.insert(node(i-&gt;r, -i-&gt;c));
return normal(p2);
}
void insert(const g&amp; p, node nd) {
g p2 = p;
p2.insert(nd);
p2 = normal(p2);
int n = p2.size();

for (int i = 0; i &lt; 4; i++) {
	if (animals[n].count(p2)) return;
	p2 = turn(p2);
}
p2 = filp(p2);
for (int i = 0; i &lt; 4; i++) {
	if (animals[n].count(p2)) return;
	p2 = turn(p2);
}
animals[n].insert(p2);	
}
</code></pre>
<h2 id="主函数"><a class="markdownIt-Anchor" href="#主函数"></a> 主函数</h2>
<pre><code>struct node {
int r, c;
node(int r = 0, int c = 0) :r(r), c(c) {}
bool operator &lt; (const node &amp;a) const { return r &lt; a.r || r == a.r &amp;&amp; c &lt; a.c; }
};
typedef set&lt;node&gt; g;
const int maxn = 10;
int dx[] = { 1,-1,0,0 };
int dy[] = { 0,0,1,-1 };
g normal(const g&amp; p);
g turn(const g&amp; p);
g filp(const g&amp; p);
void insert(const g&amp; p, node nd);
int main()
{
int n, h, w;
get_ans();
while (cin &gt;&gt; n &gt;&gt; w &gt;&gt; h)
	cout &lt;&lt; ans[n][w][h] &lt;&lt; endl;
return 0;
}	</code></pre>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>考研机试目录</title>
    <url>/2020/03/30/%E8%80%83%E7%A0%94%E6%9C%BA%E8%AF%95%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="基础相关"><a class="markdownIt-Anchor" href="#基础相关"></a> <a href="/2020/03/30/%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/">基础相关</a></h2>
<h2 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> <a href="/2020/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></h2>
<h2 id="数学理论"><a class="markdownIt-Anchor" href="#数学理论"></a> <a href="/2020/03/30/%E6%95%B0%E5%AD%A6%E7%90%86%E8%AE%BA/">数学理论</a></h2>
<h2 id="搜索"><a class="markdownIt-Anchor" href="#搜索"></a> <a href="/2020/03/30/%E6%90%9C%E7%B4%A2/">搜索</a></h2>
<h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> <a href="/2020/03/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></h2>
<h2 id="图论"><a class="markdownIt-Anchor" href="#图论"></a> <a href="/2020/03/30/%E5%9B%BE%E8%AE%BA/">图论</a></h2>
<h2 id="其他技巧"><a class="markdownIt-Anchor" href="#其他技巧"></a> <a href="/2020/03/30/%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7/">其他技巧</a></h2>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第8章聚类分析</title>
    <url>/2020/06/13/%E7%AC%AC8%E7%AB%A0%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1>
<h2 id="什么是聚类分析"><a class="markdownIt-Anchor" href="#什么是聚类分析"></a> 什么是聚类分析</h2>
<ul>
<li>
<p><strong>目标</strong>：组内的对象相互之间是相似的，而不同组中的对象是不同的。组内的相似性越大，组间差距越大，聚类就越好</p>
</li>
<li>
<p>聚类 &amp; 分类：聚类是非监督的分类</p>
</li>
</ul>
<h2 id="不同的聚类类型"><a class="markdownIt-Anchor" href="#不同的聚类类型"></a> 不同的聚类类型</h2>
<h3 id="层次的-划分的"><a class="markdownIt-Anchor" href="#层次的-划分的"></a> 层次的 &amp; 划分的</h3>
<ul>
<li><strong>划分聚类</strong>简单的讲数据对象集划分成不重叠的子集，使得每个数据对象恰在一个子集中</li>
<li><strong>层次聚类</strong>是嵌套簇的集族，组织成一颗树。除叶结点外，树种每个结点都是其子女的并，而树根是包含所有对象的簇。</li>
</ul>
<h3 id="互斥的-重叠的与模糊的"><a class="markdownIt-Anchor" href="#互斥的-重叠的与模糊的"></a> 互斥的、重叠的与模糊的</h3>
<ul>
<li><strong>互斥的</strong>：每个对象都指派到单个簇</li>
<li><strong>重叠的</strong>：聚类用来反应对象同时属于多个组的事实</li>
<li><strong>模糊的</strong>：每个对象<strong>以一个0和1之间的隶属权值属于每个簇</strong>。在模糊聚类种，通常施加一个约束条件，每个对象的权值之和等于1。在实践中，通常通过将对象指派到具有最高隶属度权值或概率的簇，将模糊或概率聚类转换成互斥聚类。</li>
</ul>
<h3 id="完全的-部分的"><a class="markdownIt-Anchor" href="#完全的-部分的"></a> 完全的 &amp; 部分的</h3>
<ul>
<li><strong>完全聚类</strong>：将每个对象指派到一个簇</li>
<li><strong>部分聚类</strong>：由于数据集中可能<strong>某些对象可能不属于明确定义的组</strong>，<strong>比如一些噪声，离群点</strong>。因此不需要完全聚类</li>
</ul>
<h2 id="不同的簇类型"><a class="markdownIt-Anchor" href="#不同的簇类型"></a> 不同的簇类型</h2>
<img src="/MyImages/image-20200513113907175.png" alt="image-20200513113907175" style="zoom: 50%;" />
<h1 id="k均值"><a class="markdownIt-Anchor" href="#k均值"></a> K均值</h1>
<h2 id="基本k均值算法"><a class="markdownIt-Anchor" href="#基本k均值算法"></a> 基本K均值算法</h2>
<img src="/MyImages/image-20200517185635918.png" alt="image-20200517185635918" style="zoom: 50%;" />
<ul>
<li>
<p>首先算则K个初始质心，其中K是用户指定的参数，即所期望的簇的个数</p>
</li>
<li>
<p>每个点指派到最近的质心，而指派到一个质心的点集即为一个簇</p>
</li>
<li>
<p>根据指派到簇的点，更新每个簇的质心</p>
</li>
<li>
<p>重复指派和更新步骤，直到簇不发生变化，或等价的，直到质心不发生变化</p>
</li>
</ul>
<p><strong>注</strong>：</p>
<ul>
<li>上图中使用均值作为质心</li>
<li><strong>对于邻近性函数和质心类型的某些组合，K均值总是收敛到一个解，即K均值到达一种状态，其中所有点都不会从一个簇转移到另一个，因此质心不会改变</strong></li>
</ul>
<h3 id="指派点到最近的质心"><a class="markdownIt-Anchor" href="#指派点到最近的质心"></a> 指派点到最近的质心</h3>
<ul>
<li><strong>最近性度量</strong>：通常，对欧氏空间中的点使用欧几里得距离(L2)或曼哈顿距离(L1)；对文档用余弦相似度或Jaccard度量。</li>
<li>可以使用<strong>二分K均值减少相似度计算量来加快K均值的速度</strong></li>
</ul>
<h3 id="质心和目标函数"><a class="markdownIt-Anchor" href="#质心和目标函数"></a> 质心和目标函数</h3>
<ul>
<li>
<p>目标函数：比如最小化每个点到最近质心的距离的平方</p>
</li>
<li>
<p><strong>欧几里得空间中的数据</strong></p>
<ul>
<li>
<p>使用误差的平方和作为度量聚类质量的目标函数，簇的质心是均值</p>
</li>
<li>
<p>即对于每个数据点计算其到质心的欧几里得距离(误差)，然后计算误差的平方和。给定由两次运行K均值产生的两个不同的簇集，选择误差的平方和最小的那个</p>
</li>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>S</mi><mi>E</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></munderover><munder><mo>∑</mo><mrow><mi>x</mi><mo>∈</mo><msub><mi>C</mi><mi>i</mi></msub></mrow></munder><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><msub><mi>c</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>x</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">SSE=\sum ^K_{i=1}\sum _{x\in C_i}dist(c_i,x)^2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.222772em;vertical-align:-1.394436em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.855664em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.07153em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.394436em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p><strong>K均值的步骤3和步骤4只能确保找到关于SSE的局部最优，因为是对选定的质心和簇，而不是对所有可能的选择来优化SSE</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>文档数据</strong></p>
<ul>
<li>
<p>使用余弦相似性度量，目标是最大化簇中文档与簇的质心相似度：该量称为簇的<strong>凝聚度</strong>；簇的质心是均值</p>
</li>
<li>
<p>总凝聚度</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi><mtext>  </mtext><mi>C</mi><mi>o</mi><mi>h</mi><mi>e</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></munderover><munder><mo>∑</mo><mrow><mi>x</mi><mo>∈</mo><msub><mi>C</mi><mi>i</mi></msub></mrow></munder><mi>c</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><msub><mi>c</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Total\;Cohesion=\sum ^K_{i=1}\sum _{x\in C_i}cosine(x,c_i)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.222772em;vertical-align:-1.394436em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.855664em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.07153em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.394436em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
</li>
</ul>
</li>
<li>
<p><strong>一般情况</strong></p>
<img src="/MyImages/image-20200517201948267.png" alt="image-20200517201948267" style="zoom:80%;" />
</li>
</ul>
<h3 id="选择初始质心"><a class="markdownIt-Anchor" href="#选择初始质心"></a> 选择初始质心</h3>
<ul>
<li>
<p>随机初始化的质心往往很差。一种解决方法是使用一组不同的随机初始质心，然后选取具有最小SSE的簇集</p>
</li>
<li>
<p><strong>只要两个初始质心落在簇对的任何位置，就能得到最优聚类</strong>，因为质心将自己重新分布，每个簇一个。但是**随着簇的个数增加，**至少一个簇对只有一个初始质心的可能性也逐步增大。在这种情况下，<strong>由于簇对相距较远，K均值算法不能再簇对之间重新分布质心，只能得到局部最优。</strong></p>
</li>
<li>
<p>一种解决方法是，使用层次聚类计数。</p>
</li>
<li>
<p>另一种方法：</p>
<ul>
<li>先随机初始化一个点或者选取所有点的质心作为第一个点</li>
<li>然后，对于每个后继初始质心，选择离已经选取过的初始质心最远的点。使用这种方法，得到初始质心的集合，确保不仅是随机的，还是散开的。</li>
</ul>
</li>
</ul>
<h2 id="k均值附加的问题"><a class="markdownIt-Anchor" href="#k均值附加的问题"></a> K均值：附加的问题</h2>
<h3 id="处理空簇"><a class="markdownIt-Anchor" href="#处理空簇"></a> 处理空簇</h3>
<ul>
<li>如果所有的点在指派步骤都未分配到某个簇，就会得到空簇</li>
<li><strong>解决</strong>：使用替补质心，否则，平方误差会增大
<ul>
<li>一种方法是选择距离当前任何质心最远的点，这样可以清除当前对总平方误差影响最大的点</li>
<li>从具有最大SSE的簇中选择一个替补质心。这样将分裂簇并降低聚类的总SSE</li>
</ul>
</li>
</ul>
<h3 id="离群点"><a class="markdownIt-Anchor" href="#离群点"></a> 离群点</h3>
<ul>
<li>存在离群点的时候，质心可能不那么具有代表性，并且SSE也比较高。</li>
<li><strong>注意</strong>：如果聚类用来压缩数据时，必须对每个点聚类。再比如财经分析中，明显的离群点可能是最有利可图的点</li>
</ul>
<h3 id="用后处理降低sse"><a class="markdownIt-Anchor" href="#用后处理降低sse"></a> 用后处理降低SSE</h3>
<ul>
<li>使用较大的K，从而找出更多的簇</li>
<li><strong>SSE较大是因为K均值往往收敛于局部极小值</strong>，可以通过<strong>在簇上进行分裂和合并</strong>等，改变总的SSE。下面是一些分裂和合并的技术
<ul>
<li><strong>分裂一个簇</strong>：通常选择具有最大SSE的簇，也可以选择分裂在特定属性上具有最大标准差的簇</li>
<li><strong>引进一个新的质心</strong>：通常选择离所有簇质心最远的点。可以通过记录每个点对SSE的贡献来判断最远，也可以从具有最高SSE的点中随机选择</li>
<li><strong>拆散一个簇</strong>：删除某个簇的质心，将簇中的点指派给其他簇。目标是使得拆散之后，SSE增加最小</li>
<li><strong>合并两个簇</strong>：通常选择最接近的两个簇合并</li>
</ul>
</li>
</ul>
<h3 id="增量的更新质心"><a class="markdownIt-Anchor" href="#增量的更新质心"></a> 增量的更新质心</h3>
<ul>
<li>在每次点到簇指派之后，增量的更新质心，而不是在所有点都被指派之后才更新。</li>
<li>优点
<ul>
<li><strong>这样不会产生空簇</strong>，因为所有的簇都从单个点开始，并且如果一个簇如果只有单个点，则总是被指派到相同的簇 ；</li>
<li><strong>可以调整点的相对权重</strong></li>
</ul>
</li>
<li>缺点
<ul>
<li>所产生的簇可能依赖点的处理次序(可以通过随机选择的处理次序解决)</li>
<li>开销大一点</li>
</ul>
</li>
</ul>
<h2 id="二分k均值"><a class="markdownIt-Anchor" href="#二分k均值"></a> 二分K均值</h2>
<img src="/MyImages/1589963806738-1592024931344.png" alt="1589963806738" style="zoom: 67%;" />
<ul>
<li>待分的簇：可以选择最大的簇；具有最大SSE的簇；或者使用一个基于大小和SSE的标准进行选择</li>
<li><strong>通常使用结果簇做为基本K均值的初始质心</strong></li>
<li>二分K均值不太受初始质心的影响，因为他执行了多次二分实验并选取具有最小SSE的实验结果</li>
</ul>
<h2 id="k均值和不同的簇类型"><a class="markdownIt-Anchor" href="#k均值和不同的簇类型"></a> K均值和不同的簇类型</h2>
<ul>
<li><strong>当簇具有非球形状或具有不同尺寸或密度时，K均值很难检测到自然的簇</strong></li>
<li>这是因为K均值目标函数是最小化等尺寸和等密度的球形簇，或者明显分离的簇</li>
</ul>
<h2 id="优点与缺点"><a class="markdownIt-Anchor" href="#优点与缺点"></a> 优点与缺点</h2>
<h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3>
<ul>
<li>简单并且可以<strong>用于各种数据类型</strong></li>
<li>K均值的<strong>变种</strong>(包括二分K均值)<strong>可以不受初始化问题的影响</strong></li>
</ul>
<h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3>
<ul>
<li><strong>不能处理非球形簇</strong>，不同尺寸，不同密度的簇</li>
<li>对包含离群点的数据进行聚类时也有问题</li>
<li>K均值仅限于具有中心概念的数据</li>
</ul>
<h1 id="凝聚层次聚类"><a class="markdownIt-Anchor" href="#凝聚层次聚类"></a> 凝聚层次聚类</h1>
<ul>
<li>两种层次聚类基本方法
<ul>
<li><strong>凝聚的</strong>：从点作为个体簇开始,每一步合并两个最接近的簇。这需要定义族的邻近性概念。</li>
<li><strong>分裂的</strong>：从包含所有点的某个簇开始,每一步分裂一个簇,直到仅剩下单点簇。在这种情况下,我们需要确定每一步分裂哪个簇,以及如何分裂。</li>
</ul>
</li>
</ul>
<h2 id="基本凝聚层次聚类算法"><a class="markdownIt-Anchor" href="#基本凝聚层次聚类算法"></a> 基本凝聚层次聚类算法</h2>
<img src="/MyImages/image-20200520181307668-1592024934915.png" alt="image-20200520181307668" style="zoom: 67%;" />
<h3 id="定义簇之间的邻近性"><a class="markdownIt-Anchor" href="#定义簇之间的邻近性"></a> 定义簇之间的邻近性</h3>
<img src="/MyImages/image-20200520183236757-1592024936343.png" alt="image-20200520183236757" style="zoom:50%;" />
<ul>
<li><strong>MIN</strong>定义簇的邻近度为不同簇的两个最近的点之间的邻近度(两个簇之间的最短边)</li>
<li><strong>MAX</strong>取两个不同簇之间的最长边</li>
<li><strong>组平均</strong>：定义簇邻近度为取自不同簇的所有点对邻近度的平均值</li>
</ul>
<h2 id="特殊技术"><a class="markdownIt-Anchor" href="#特殊技术"></a> 特殊技术</h2>
<img src="/MyImages/image-20200520183210974-1592024937923.png" alt="image-20200520183210974" style="zoom: 67%;" />
<h3 id="单链技术"><a class="markdownIt-Anchor" href="#单链技术"></a> 单链技术</h3>
<ul>
<li>
<p>起初，将所有点作为单点簇</p>
</li>
<li>
<p>每次在点之间加上一条链，最短的链先加，则这些链将点合并成簇</p>
</li>
<li>
<p><strong>单链技术擅长于处理非椭圆形状的簇，但对噪声和离群点敏感</strong></p>
</li>
<li>
<p>举例</p>
<img src="/MyImages/image-20200520183954421-1592024944787.png" alt="image-20200520183954421" style="zoom: 67%;" />
</li>
</ul>
<h3 id="全链技术"><a class="markdownIt-Anchor" href="#全链技术"></a> 全链技术</h3>
<ul>
<li>
<p>从单点簇开始</p>
</li>
<li>
<p>每次在点之间加上一条链，最短的链先加，则一组点直到其中所有的点都完全链接才形成一个簇</p>
</li>
<li>
<p><strong>对噪声和离群点不敏感，但是可能使大的簇破裂，形成偏好球形</strong></p>
</li>
<li>
<p>举例：是{3，6}和{4}合并，而不是与{2，5}或{1}合并</p>
<img src="/MyImages/image-20200520184416410-1592024947254.png" alt="image-20200520184416410" style="zoom:67%;" />
</li>
</ul>
<h3 id="组平均"><a class="markdownIt-Anchor" href="#组平均"></a> 组平均</h3>
<ul>
<li>
<p>定义簇i和簇j的邻近度</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>C</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><munder><mo>∑</mo><mrow><mi>x</mi><mo>∈</mo><msub><mi>C</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><msub><mi>C</mi><mi>j</mi></msub></mrow></munder><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mi>m</mi><mi>i</mi></msub><mo>∗</mo><msub><mi>m</mi><mi>j</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">proximity(C_i,C_j)=\frac{\sum _{x\in C_i,y\in C_j}proximity(x,y)}{m_i*m_j}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.6091379999999997em;vertical-align:-0.972108em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.63703em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.8870299999999998em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.17862099999999997em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.07153em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mrel mtight">∈</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.07153em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.49703em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">x</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.972108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>其中mi和mj表示簇的大小</p>
</li>
<li>
<p>举例</p>
<img src="/MyImages/image-20200520184819575-1592024970470.png" alt="image-20200520184819575" style="zoom: 67%;" />
</li>
</ul>
<h3 id="ward方法和质心方法"><a class="markdownIt-Anchor" href="#ward方法和质心方法"></a> Ward方法和质心方法</h3>
<ul>
<li>
<p>Ward将两个簇的邻近度定义为两个簇合并时导致的平方误差的增量</p>
</li>
<li>
<img src="C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20200520185253738.png" alt="image-20200520185253738" style="zoom:67%;" />
<p>与前面的结果不同</p>
</li>
<li>
<p>质心法是通过计算<strong>簇质心之间的距离</strong>来计算邻近度</p>
</li>
</ul>
<h2 id="层次聚类的主要问题"><a class="markdownIt-Anchor" href="#层次聚类的主要问题"></a> 层次聚类的主要问题</h2>
<h3 id="缺乏全局目标函数"><a class="markdownIt-Anchor" href="#缺乏全局目标函数"></a> 缺乏全局目标函数</h3>
<ul>
<li>层次聚类在每一步局部的确定哪些簇应当合并或分裂。</li>
<li>没有局部极小问题或选择初始点问题</li>
<li>但是时间复杂度和空间复杂度高</li>
</ul>
<h3 id="处理不同大小簇的能力"><a class="markdownIt-Anchor" href="#处理不同大小簇的能力"></a> 处理不同大小簇的能力</h3>
<ul>
<li><strong>加权法</strong>平等对待所有簇，不同簇中的点不同的权值</li>
<li><strong>非加权</strong>考虑每个簇的点数，赋予不同簇中的点相同的权值</li>
</ul>
<h3 id="合并决策是最终的"><a class="markdownIt-Anchor" href="#合并决策是最终的"></a> 合并决策是最终的</h3>
<ul>
<li>由于每次都是取局部最优，并且一旦合并，以后不能撤销，<strong>这就阻碍了局部最优变成全局最优</strong></li>
</ul>
<h2 id="优点和缺点"><a class="markdownIt-Anchor" href="#优点和缺点"></a> 优点和缺点</h2>
<h3 id="优点-2"><a class="markdownIt-Anchor" href="#优点-2"></a> 优点</h3>
<ul>
<li>能够产生高质量的聚类</li>
</ul>
<h3 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2"></a> 缺点</h3>
<ul>
<li>存储和计算复杂度大</li>
<li>噪声和高维数据可能造成影响</li>
</ul>
<h1 id="dbscan"><a class="markdownIt-Anchor" href="#dbscan"></a> DBSCAN</h1>
<ul>
<li><strong>基于密度的聚类算法</strong></li>
</ul>
<h2 id="传统的密度基于中心的方法"><a class="markdownIt-Anchor" href="#传统的密度基于中心的方法"></a> 传统的密度：基于中心的方法</h2>
<ul>
<li>基于中心的方法中，数据集中特定点的密度通过对该点Eps半径内的点计数来估计</li>
</ul>
<h3 id="根据基于中心的密度进行点分类"><a class="markdownIt-Anchor" href="#根据基于中心的密度进行点分类"></a> 根据基于中心的密度进行点分类</h3>
<ul>
<li>点分成了
<ul>
<li>稠密区域内部的点（核心点）：核心点的定义是,如果该点的给定邻域内的点的个数超过给定的阈值MinPts,其中MinPts也是一个用户指定的参数</li>
<li>稠密区域边缘的点（边界点）:不是核心点，但是落在某个核心点的邻域内</li>
<li>稀疏区域中的点（噪声或背景）</li>
</ul>
</li>
</ul>
<h2 id="dbscan算法"><a class="markdownIt-Anchor" href="#dbscan算法"></a> DBSCAN算法</h2>
<img src="/MyImages/image-20200520202653610-1592024974613.png" alt="image-20200520202653610" style="zoom:50%;" />
<h3 id="参数的选择"><a class="markdownIt-Anchor" href="#参数的选择"></a> 参数的选择</h3>
<ul>
<li>
<p>通过观察点到他的k个最邻近的距离确定。对于属于某个簇的点，如果k不大于簇的大小，则k-距离将很小。</p>
</li>
<li>
<p>可以计算所有点的k-距离，按递增次序排序，则会看到k-距离的急剧变化。选取合适的距离作为Eps，取k的值为MinPts。则k-距离小于Eps的点将被标记为核心点，而其他点标记为噪声点</p>
</li>
<li>
<p>如果k太小，则少量临近点的噪声或离群点将可能不正确的标记为簇</p>
</li>
<li>
<p>如果k太大，则尺度小于k的簇可能会标记为噪声</p>
</li>
</ul>
<h3 id="变密度的簇"><a class="markdownIt-Anchor" href="#变密度的簇"></a> 变密度的簇</h3>
<ul>
<li><strong>如果簇的密度变化很大，DBSCAN可能会有问题</strong></li>
</ul>
<h2 id="优点与缺点-2"><a class="markdownIt-Anchor" href="#优点与缺点-2"></a> 优点与缺点</h2>
<h3 id="优点-3"><a class="markdownIt-Anchor" href="#优点-3"></a> 优点</h3>
<ul>
<li>因为DBSCAN是基于密度定义的，所以是相对抗噪声的，并且能够处理任意形状和大小的簇</li>
</ul>
<h3 id="缺点-3"><a class="markdownIt-Anchor" href="#缺点-3"></a> 缺点</h3>
<ul>
<li>当簇的密度变化太大时，会有问题</li>
<li>对于高维数据，密度的定义更加困难</li>
<li>计算k-距离时的时间复杂度大</li>
</ul>
<h1 id="簇评估"><a class="markdownIt-Anchor" href="#簇评估"></a> 簇评估</h1>
<ul>
<li>根据聚类算法的不同，评估度量也不同。例如，K均值簇使用SSE来评估，但是<strong>有些基于密度的簇不是球形，SSE不起作用</strong></li>
<li>评估的目的
<ul>
<li>避免在噪声中寻找模式</li>
<li>比较聚类算法</li>
<li>比较两个聚类结果</li>
</ul>
</li>
</ul>
<h2 id="概述-2"><a class="markdownIt-Anchor" href="#概述-2"></a> 概述</h2>
<h3 id="三类度量评估簇"><a class="markdownIt-Anchor" href="#三类度量评估簇"></a> 三类度量评估簇</h3>
<ul>
<li><strong>非监督的</strong>：<strong>内部指标</strong>，聚类结构的优良性度量，不考虑外部信息，如SSE。还可进一步分类
<ul>
<li><strong>簇的凝聚性</strong>：度量确定簇中对象如何密切相关</li>
<li><strong>簇的分离性</strong>：度量确定某个簇不同于其他簇的方法</li>
</ul>
</li>
<li><strong>监督的</strong>：度量聚类算法发现的聚类结构<strong>与某种外部结构</strong>的匹配程度。<strong>是外部指标</strong></li>
<li><strong>相对的</strong>：比较不同的聚类或簇。例如，两个K均值聚类可以使用SSE或熵进行比较</li>
</ul>
<h2 id="非监督簇评估使用凝聚度和分离度"><a class="markdownIt-Anchor" href="#非监督簇评估使用凝聚度和分离度"></a> 非监督簇评估：使用凝聚度和分离度</h2>
<ul>
<li>
<p><strong>总体簇的有效性表示为个体簇有效性的加权和</strong></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>v</mi><mi>e</mi><mi>a</mi><mi>l</mi><mi>l</mi><mtext>  </mtext><mi>v</mi><mi>a</mi><mi>l</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></munderover><msub><mi>w</mi><mi>i</mi></msub><mtext>  </mtext><mi>v</mi><mi>a</mi><mi>l</mi><mi>i</mi><mi>d</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false">(</mo><msub><mi>C</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">oveall\;val=\sum_{i=1}^Kw_i\;validity(C_i)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.106005em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
</li>
<li>
<p>其中有效性度量可以是凝聚度或分离度</p>
</li>
</ul>
<h3 id="凝聚度和分离度的基于图的观点"><a class="markdownIt-Anchor" href="#凝聚度和分离度的基于图的观点"></a> 凝聚度和分离度的基于图的观点</h3>
<img src="/MyImages/image-20200524203244047.png" alt="image-20200524203244047" style="zoom:67%;" />
<ul>
<li><strong>凝聚度</strong>可以定义为连接簇内点的邻近度图中边的加权和</li>
<li><strong>两个簇之间的分离度</strong>可以用从一个簇的点到另一个簇的点的边的加权和来度量</li>
</ul>
<h3 id="凝聚度和分离度的基于原型的观点"><a class="markdownIt-Anchor" href="#凝聚度和分离度的基于原型的观点"></a> 凝聚度和分离度的基于原型的观点</h3>
<img src="/MyImages/image-20200524203446558.png" alt="image-20200524203446558" style="zoom:67%;" />
<ul>
<li>簇的凝聚度可以定义为关于簇原型（中心）的邻近度的和</li>
<li>两个簇之间的分离度可以定义为两个簇原型的邻近性度量</li>
<li>如果取邻近度为平方欧式距离，则为簇的SSE</li>
</ul>
<h3 id="凝聚度和分离度的总度量"><a class="markdownIt-Anchor" href="#凝聚度和分离度的总度量"></a> 凝聚度和分离度的总度量</h3>
<img src="/MyImages/image-20200524204243927.png" alt="image-20200524204243927" style="zoom:67%;" />
<h3 id="两种基于原型的分离性度量方法"><a class="markdownIt-Anchor" href="#两种基于原型的分离性度量方法"></a> 两种基于原型的分离性度量方法</h3>
<ul>
<li>
<p>当邻近度使用欧几里得距离度量时，簇之间分离性的度量是组平方和(SSB)</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>S</mi><mi>B</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></munderover><mi mathvariant="normal">∣</mi><msub><mi>C</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><msub><mi>m</mi><mi>i</mi></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">SSB=\sum_{i=1}^K|C_i|(m-m_i)^2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.106005em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li>其中Ci时第i个簇的大小，m是所有点的质心，mi是第i个簇的质心</li>
<li>总SSB越高，簇之间的分离性越好</li>
</ul>
</li>
<li>
<p>P335 没看懂</p>
</li>
</ul>
<h3 id="凝聚度和分离度之间的联系"><a class="markdownIt-Anchor" href="#凝聚度和分离度之间的联系"></a> 凝聚度和分离度之间的联系</h3>
<ul>
<li><strong>总SSE和总SSB之和是一个常数</strong>，等于总平方和（每个点到数据的总均值的距离的平方和）。这说明，<strong>最小化SSE等价于最大化SSB</strong></li>
</ul>
<h3 id="举例sse"><a class="markdownIt-Anchor" href="#举例sse"></a> 举例:SSE</h3>
<img src="/MyImages/image-20200524214202833.png" alt="image-20200524214202833" style="zoom: 33%;" />
<h3 id="评估个体簇和对象"><a class="markdownIt-Anchor" href="#评估个体簇和对象"></a> 评估个体簇和对象</h3>
<ul>
<li>凝聚度和分离度也可以用来评价个体簇</li>
<li>如果簇凝聚性不好,则我们可能希望将它分裂成若干个子簇,另一方面,如果两个簇相对凝聚,但分离性不好,则我们可能需要将它们合并成一个族</li>
<li>也可以用来评估簇中对象，根据对象对凝聚度和分离度贡献的大小，判断是接近中心还是边缘</li>
</ul>
<h3 id="轮廓系数"><a class="markdownIt-Anchor" href="#轮廓系数"></a> 轮廓系数</h3>
<img src="/MyImages/image-20200524214956225.png" alt="image-20200524214956225" style="zoom: 50%;" />
<img src="/MyImages/image-20200524210352952.png" alt="image-20200524210352952" style="zoom:67%;" />
<ul>
<li>值域[-1,1]</li>
<li>不希望负值，因为负值表示两个簇有包含关系</li>
<li>希望ai接近0，当ai=0时取极大值1</li>
</ul>
<h2 id="非监督簇评估使用邻近度矩阵"><a class="markdownIt-Anchor" href="#非监督簇评估使用邻近度矩阵"></a> 非监督簇评估：使用邻近度矩阵</h2>
<ul>
<li>邻近度矩阵：Aij = 1代表第i个点和第j个点在同一个簇中，Aij=0表示不在一个簇中</li>
</ul>
<h3 id="通过相关性度量簇的有效性"><a class="markdownIt-Anchor" href="#通过相关性度量簇的有效性"></a> 通过相关性度量簇的有效性</h3>
<img src="/MyImages/image-20200524221227751.png" alt="image-20200524221227751" style="zoom:67%;" />
<ul>
<li>
<p>可以通过考察相似度矩阵和基于簇标号的相似度矩阵的理想版本之间的相关性来评估聚类的优良性。<strong>计算两个矩阵之间的相关性</strong>。高相关性表示属于同一簇的点彼此接近</p>
</li>
<li>
<p>如果将相似度矩阵的行和列排序，使得属于相同簇的对象在一起，则<strong>理想的相似度矩阵具有块对角结构</strong>。即在相似度矩阵中代表簇内相似度的项的块内部相似度非零，而其他地方为0.</p>
</li>
<li>
<p>对于基于密度和基于紧邻的簇来说，不是好的度量，因为他们不是球形的。</p>
</li>
</ul>
<h2 id="簇有效性的监督度量外部"><a class="markdownIt-Anchor" href="#簇有效性的监督度量外部"></a> 簇有效性的监督度量（外部）</h2>
<h3 id="簇有效性的面向分类的度量"><a class="markdownIt-Anchor" href="#簇有效性的面向分类的度量"></a> 簇有效性的面向分类的度量</h3>
<ul>
<li>对于有标签数据，可以使用<strong>精度、纯度、召回率、F度量</strong>等分类度量来评价</li>
</ul>
<h3 id="簇有效性的面向相似性的度量"><a class="markdownIt-Anchor" href="#簇有效性的面向相似性的度量"></a> 簇有效性的面向相似性的度量</h3>
<ul>
<li>使用前文的相似性矩阵和理想矩阵求相关度作为有效性的度量</li>
<li>
<img src="/MyImages/image-20200524234039260.png" alt="image-20200524234039260" style="zoom: 67%;" /></li>
</ul>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第10讲</title>
    <url>/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC10%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="相机成像原理"><a class="markdownIt-Anchor" href="#相机成像原理"></a> 相机成像原理</h1>
<ol>
<li>为什么不使光圈尽可能小?<br />
（1）使光线减少 （2）衍射影响</li>
<li>人的眼睛：瞳孔相当于光圈；视网膜上的感光细胞相当于胶片。</li>
</ol>
<h2 id="相机模型"><a class="markdownIt-Anchor" href="#相机模型"></a> 相机模型</h2>
<ol>
<li>
<p>投影建模</p>
 <img src="/视觉_img/10_1.png" style="zoom:80%">
 1. 将相机近似为针孔模型
 2. 把小孔的位置设在原点
 3. 将图像平面放在投影中心COP的前面(为了得到正立的相)
 4. 相机向负z轴看去(右手坐标系下)
</li>
<li>
<p>投影方程</p>
 <img src="/视觉_img/10_2.png" style="zoom:80%">
<ol>
<li>
<p>不是线性变换----&gt;采用3D齐次坐标。</p>
 <img src="/视觉_img/10_3.png" style="zoom:80%">
</li>
</ol>
</li>
<li>
<p>透视投影</p>
<ol>
<li>
<p>投影是使用齐次坐标的矩阵乘法：</p>
 <img src="/视觉_img/10_4.png" style="zoom:80%">
</li>
<li>
<p>改变投影变换的吃尺度对变换没有影响</p>
 <img src="/视觉_img/10_5.png" style="zoom:80%">
</li>
</ol>
</li>
<li>
<p>正交投影（平行投影）</p>
<ol>
<li>
<p>是透视投影的特殊情况：当光学中心COP到投影平面PP的距离是无限的时候。（1/d = 0）</p>
 <img src="/视觉_img/10_6.png" style="zoom:80%">
</li>
</ol>
</li>
</ol>
<h2 id="正交投影的变体"><a class="markdownIt-Anchor" href="#正交投影的变体"></a> 正交投影的变体</h2>
<ol start="5">
<li>
<p>缩放正交（弱透视）</p>
<p>相当于在物体聚焦到角点前就将图像截获。</p>
 <img src="/视觉_img/10_7.png" style="zoom:80%">
<p>分两步:</p>
<ol>
<li>第一步：整个物体按平行于光轴的方向正交投影到经过物体质心并与图像平面平行的平面上。</li>
<li>第二步：再按透视模型投影到图像平面上，这一步实际是全局的缩放。</li>
</ol>
</li>
<li>
<p>仿射投影</p>
 <img src="/视觉_img/10_8.png" style="zoom:80%">
<p>分两步：</p>
<ol>
<li>仍把物体平行投影到过质心且与图象平面平行的平面上，不过这次的投影线不是平行于光轴，而是平行于光心C和物体质心G的连线CG；</li>
<li>再按透视模型投影到图象平面上。</li>
</ol>
</li>
<li>
<p>总结</p>
</li>
</ol>
<img src="/视觉_img/10_9.png" style="zoom:80%">
<h2 id="降维"><a class="markdownIt-Anchor" href="#降维"></a> 降维</h2>
<ol>
<li>
<p>投影属性</p>
<ol>
<li>多对一：同一光线上的所有点映射到图像中的同一点。</li>
<li>点-&gt;点，线-&gt;线（通过角点的线变成一个点）</li>
<li>平面-&gt;平面（通过角点的平面变成一条线）</li>
<li>平行线在消失点汇合
<ol>
<li>每个方向在空间中都有他自己的消失点，但平行于图像平面的平行线保持平行。</li>
</ol>
</li>
</ol>
 <img src="/视觉_img/10_10.png" style="zoom:80%">
</li>
</ol>
<h2 id="相机参数"><a class="markdownIt-Anchor" href="#相机参数"></a> 相机参数</h2>
<p>现在我们要将世界坐标系中的一个点投影到相机坐标系中。我们需要知道相机在世界坐标系中的位置和方向。然后透视投影到图像平面上以获得像素坐标。</p>
<ol>
<li>
<p>相机内参数</p>
<ol>
<li>从世界坐标系原点到光心COP的平移变换T</li>
<li>描述相机方向的旋转变换R</li>
<li>焦距f、主点(x,y)、像素大小（sx,sy）</li>
</ol>
</li>
<li>
 <img src="/视觉_img/10_11.png" style="zoom:80%">
<p>·</p>
<p>·</p>
 <img src="/视觉_img/10_12.png" style="zoom:80%">
<p>这个公式要从右向左看</p>
<ol>
<li>平移矩阵即是将相机原点与世界原点重合。</li>
<li>第二步旋转，是将相机坐标系的三个轴旋转到与世界坐标系坐标轴平行。</li>
<li>第三步是将世界坐标系中的三维点透过光心进行投影。</li>
<li>第四步是使用相机内参数将图像变成离散的坐标。</li>
<li><strong>注意</strong> 该公式中对投影变换进行了拆分，，一部分与内参数乘在了一起。</li>
</ol>
</li>
</ol>
<h2 id="外参数让相机规范化"><a class="markdownIt-Anchor" href="#外参数让相机规范化"></a> 外参数—让相机规范化</h2>
<ol>
<li>
<p>第一步 平移-c，将相机坐标系原点与世界坐标系原点重合。<br />
<img src="/视觉_img/10_15.png" style="zoom:80%"></p>
<p>其中c为相机坐标原点在世界坐标系中的坐标[[tx,ty,tz]].T</p>
</li>
<li>
<p>第二步 旋转R， 将相机坐标系的轴旋转到与世界坐标系轴平行。</p>
 <img src="/视觉_img/10_16.png" style="zoom:80%">
</li>
</ol>
<h2 id="透视投影"><a class="markdownIt-Anchor" href="#透视投影"></a> 透视投影</h2>
<img src="/视觉_img/10_17.png" style="zoom:80%">
<h2 id="投影矩阵"><a class="markdownIt-Anchor" href="#投影矩阵"></a> 投影矩阵</h2>
<img src="/视觉_img/10_18.png" style="zoom:80%">
<p><strong>注：</strong></p>
<ol>
<li>
<p>平移的三个参数是相机原点在世界坐标系中的坐标。</p>
</li>
<li>
<p>旋转的三个参数是相机坐标系的坐标轴在用世界坐标系的方向向量来表达的向量坐标的转置。</p>
</li>
<li>
<p><strong>将投影矩阵乘开</strong></p>
</li>
</ol>
<img src="/视觉_img/10_19.png" style="zoom:80%">
<img src="/视觉_img/10_13.png" style="zoom:80%">
<h2 id="透视失真"><a class="markdownIt-Anchor" href="#透视失真"></a> 透视失真</h2>
<ol>
<li>梯形失真</li>
<li>仰拍导致。解决：移轴镜头</li>
<li>外侧列更大</li>
<li>镜头失真：枕型，桶型–&gt;由不完美镜头引起</li>
<li><strong>修正径向畸变</strong><br />
<img src="/视觉_img/10_14.png" style="zoom:80%"></li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉实验目录</title>
    <url>/2020/03/30/%E8%A7%86%E8%A7%89%E5%AE%9E%E9%AA%8C%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="高斯混合图像"><a class="markdownIt-Anchor" href="#高斯混合图像"></a> <a href="https://github.com/Cccceb/BTF/tree/master/CV_Exp1">高斯混合图像</a></h2>
<p>将两张图片通过高斯核进行滤波得到一幅图片的高通(left)和另一幅图片的低通部分(right)，然后按照混合比例将两张图片混合得到混合图像</p>
<p><img src="/MyImages/image-20200407103221556.png" alt="image-20200407103221556" /></p>
<h2 id="基于harris的角点检测及特征匹配"><a class="markdownIt-Anchor" href="#基于harris的角点检测及特征匹配"></a> <a href="https://github.com/Cccceb/BTF/tree/master/CV_Exp2">基于Harris的角点检测及特征匹配</a></h2>
<p>本次实验包括三大部分：特征检测，特征描述，特征匹配</p>
<ul>
<li>
<p>特征检测：本次实验中实现了 Harris 算子，Harris 算子的实现分为三小部分</p>
<ul>
<li>计算每个像素处的角点响应强度大小及方向。首先通过Sobel 算子求得 x 方向和 y 方向上的导数。根据 MOPS 论文中所述，为了防止混叠，在较高的高斯金字塔上进行采样，本实验中使用σ=0.5 的高斯核处理，求得 H 矩阵的四个参数，带入公式得到每一点的角点响应强度。方向由该点处的梯度近似给出，注意要转为角度才能通过 <a href="http://test.py" target="_blank" rel="noopener">test.py</a>。</li>
<li>检测每个点是否是局部最大值，针对 TODO2 采用了简化处理，只判断每个点是否是 7*7 窗口的极大值即可。后续我实现了非 极大值抑制，性能提高 27</li>
<li>将 特 征 点 的 角 点 响 应 强 度 ， 方 向 ， 坐 标 等 信 息 放 进 cv2.KeyPoint 对象列表中，返回特征点列表。</li>
</ul>
</li>
<li>
<p>特征描述：本次实验中分别实现了 SimpleFeatureDescriptor 和 MOPS 特征描述。</p>
<ul>
<li>
<p>SimpleFeatureDescriptor：先给矩阵加一圈 2*2 的白边，以防越界，然后取每个点周围 5*5 的区域，并以行序为主序构成描述向量。</p>
</li>
<li>
<p>MOPS 实现需要用到 cv2 的仿射变换函数，仿射变换用到的 矩 阵 由 四 部 分 矩 阵 乘 法 得 到 ： 分 别 是</p>
<p>平 移 到 原 点 的 矩$$ T1 =np.array([[1,0,-x],[0,1,-y],[0,0,1]]) $$</p>
</li>
<li>
<p>旋 转 到 水 平 的 矩 阵</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mo>=</mo><mi>n</mi><mi>p</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mo stretchy="false">[</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi mathvariant="normal">.</mi><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo>−</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mo stretchy="false">[</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>h</mi><mi mathvariant="normal">.</mi><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R = np.array([[math.cos(angle),-math.sin(angle),0],[math.sin(angle),math.co s(angle),0],[0,0,1]])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">p</span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mopen">[</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord">.</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord">.</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord">.</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord">.</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<p>缩放的矩阵 $$S = np.array([[1/5,0,0],[0,1/5,0],[0,0,1]]) $$</p>
<p>平移到中心的矩阵 $$T2 = np.array([[1,0,4],[0,1,4],[0,0,1]])$$</p>
<p>这四部分进行矩阵乘法的结果作为仿射变换的矩阵，将变换的结果按行序为主序展成列表，得到特征描述符。</p>
</li>
</ul>
</li>
<li>
<p>特征匹配：本次实验中实现了两种特征匹配 SSD 和 RatioTest，二者的区别是 SSD 是求到其他特征点距离的平方和，二 RatioTest 是选择其中最大的两个距离的平均值。</p>
</li>
</ul>
<p><img src="/MyImages/image-20200407104149788.png" alt="image-20200407104149788" /></p>
<p><img src="/MyImages/image-20200407104106565.png" alt="image-20200407104106565" style="zoom: 33%;" /><img src="/MyImages/image-20200407104121516.png" alt="image-20200407104121516" style="zoom: 67%;" /></p>
<ul>
<li>
<p>优化：非极大值抑制</p>
<p>实现了自适应非极大值抑制，在选择区域内最大点的时候，从半径等于图像大小开始，枚举半径，将半径最大的 1250(论文中是 500，实测出来 1500 左右的 AUC 比较好)点选出来，作为基础的特征点。通过在yosemite 数据集上的测试，性能提升 27%。</p>
</li>
</ul>
<h2 id="全景图拼接orbransac拉普拉斯融合"><a class="markdownIt-Anchor" href="#全景图拼接orbransac拉普拉斯融合"></a> <a href="https://github.com/Cccceb/BTF/tree/master/CV_Exp3">全景图拼接(ORB+RANSAC+拉普拉斯融合)</a></h2>
<ul>
<li>实现了将一系列水平重叠的照片合成成一张全景图。</li>
<li>通过ORB进行特征检测，得到特征匹配集</li>
<li>通过特征匹配集来估计单应映射，其中使用了 SVD 来计算最佳拟合单应映射</li>
<li>利用 RANSAC 求一个最佳匹配</li>
<li>对图像进行融合，使用了羽化和拉普拉斯融合</li>
<li>实现 360 度全景图</li>
</ul>
<p><img src="/MyImages/campus_pano_blendwidth200_360degree.png" alt="" /></p>
<h2 id="立体视觉"><a class="markdownIt-Anchor" href="#立体视觉"></a> <a href="https://github.com/Cccceb/BTF/tree/master/CV_Exp4">立体视觉</a></h2>
<p>本实验将运用平面扫描立体视觉与光度测量立体视觉的方法，来恢复图像深度，并建立立体图。实验包含三个部分：</p>
<ul>
<li>光度测量立体视觉：给定在不同的已知光照方向下从相同视角拍摄的一组图像，从中恢复物体表面的反照率(albedo)和法线方向(normals)。</li>
<li>平面扫描立体视觉：给定同一场景从不同的视角拍摄的两幅校准图像，从中恢复出粗略的深度图。</li>
<li>基于泊松方程重建深度图：根据法线图及粗略深 度图，恢复出物体每个点的深度，并重建 3D 网格。</li>
</ul>
<p><img src="/MyImages/image-20200407104421416.png" alt="image-20200407104421416" /></p>
<p><img src="/MyImages/image-20200407104435407.png" alt="image-20200407104435407" /></p>
<p><img src="/MyImages/image-20200407104457098.png" alt="image-20200407104457098" /></p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第11讲</title>
    <url>/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC11%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="创建全景图"><a class="markdownIt-Anchor" href="#创建全景图"></a> 创建全景图</h1>
<h2 id="基本流程"><a class="markdownIt-Anchor" href="#基本流程"></a> 基本流程</h2>
<ol>
<li>从同一位置拍摄一系列图像。<strong>光心不动</strong></li>
<li>计算第二个图像与第一个映像之间的变换。</li>
<li>变换第二个图像与第一个图像部分重合</li>
<li>将二者融合在一起创建拼图。</li>
<li>多个图像重复上述过程</li>
</ol>
<img src="/视觉_img/11_1.png" style="zoom:80%">
## 变换矩阵
<img src="/视觉_img/11_2.png" style="zoom:80%">
<img src="/视觉_img/11_3.png" style="zoom:80%">
<p>注：</p>
<ol>
<li>图像平面一般以主点为圆心。</li>
<li>相机1的坐标系为世界坐标系。</li>
</ol>
<h2 id="360全景图"><a class="markdownIt-Anchor" href="#360全景图"></a> 360°全景图</h2>
<p>使用拼图投影球</p>
<img src="/视觉_img/11_4.png" style="zoom:80%">
<p>注：</p>
<ol>
<li>球面坐标：弧长</li>
<li>s为投影球半径</li>
</ol>
<h2 id="装配全景图"><a class="markdownIt-Anchor" href="#装配全景图"></a> 装配全景图</h2>
<ol>
<li>过程：拼接，融合，裁剪</li>
<li>问题：出现漂移</li>
<li>解决</li>
</ol>
<img src="/视觉_img/11_5.png" style="zoom:80%">
<h2 id="图像融合"><a class="markdownIt-Anchor" href="#图像融合"></a> 图像融合</h2>
<ol>
<li>
<p>使用羽化</p>
<ol>
<li>窗口大小影响羽化效果。
<ol>
<li>窗口大小为0和直接拼接一样</li>
<li>良好的窗口应该是平滑且没有虚影的。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>金字塔混合<br />
使用拉普拉斯金子塔在各层次上融合，最终叠加。</p>
<p>拉普拉斯金字塔</p>
 <img src="/视觉_img/11_6.png" style="zoom:80%">
</li>
<li>
<p>Alpha混合<br />
<img src="/视觉_img/11_7.png" style="zoom:80%"></p>
</li>
<li>
<p>泊松图像编辑</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第12讲</title>
    <url>/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC12%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="点和线"><a class="markdownIt-Anchor" href="#点和线"></a> 点和线</h1>
<h2 id="点和线的对偶性"><a class="markdownIt-Anchor" href="#点和线的对偶性"></a> 点和线的对偶性</h2>
<img src="/视觉_img/12_1.png" style="zoom:70%">
<ol>
<li>对于线上的每一点P,有I·P=0	（面上一点同理）</li>
<li>由射线P1和P2决定的线I,有I=P1×P2</li>
<li>两条线I1和I2的交点P，有P=I1×I2</li>
</ol>
<h2 id="理想的点和线"><a class="markdownIt-Anchor" href="#理想的点和线"></a> 理想的点和线</h2>
<img src="/视觉_img/12_2.png" style="zoom:70%">
<ol>
<li>
<p>理想点（无穷远点）</p>
<ol>
<li>P(x,y,0)平行于图像平面</li>
<li>有无限的图像坐标</li>
</ol>
</li>
<li>
<p>理想线</p>
<ol>
<li>I(a,b,0)平行于图像平面</li>
<li>对应于图像平面过主点的一条线</li>
<li>由ax+by=0组成的线</li>
</ol>
</li>
</ol>
<h2 id="面和点的对偶性"><a class="markdownIt-Anchor" href="#面和点的对偶性"></a> 面和点的对偶性</h2>
<ol>
<li>一个平面可以用四维向量表示</li>
<li>点和平面是对偶的：N·P=0</li>
<li>三点定义一个平面，三个平面定义一个点</li>
</ol>
<h1 id="透视投影"><a class="markdownIt-Anchor" href="#透视投影"></a> 透视投影</h1>
<img src="/视觉_img/12_3.png" style="zoom:40%">
<h2 id="消失点-1d"><a class="markdownIt-Anchor" href="#消失点-1d"></a> 消失点 1D</h2>
<img src="/视觉_img/12_4.png" style="zoom:40%">
<ol>
<li>消失点：
<ol>
<li>是无穷处一个点的投影</li>
<li>通常投影到图像中的一个有限点</li>
</ol>
</li>
</ol>
<h2 id="消失点-2d"><a class="markdownIt-Anchor" href="#消失点-2d"></a> 消失点 2D</h2>
<img src="/视觉_img/12_5.png" style="zoom:40%">
## 消失点 3D
<img src="/视觉_img/12_6.png" style="zoom:40%">
<ol>
<li>特性
<ol>
<li>任意两条平行线都有相同的消失点V</li>
<li>从光心C通过消失点V的射线与那些平行线平行</li>
<li>图像可能有多个消失点</li>
</ol>
</li>
</ol>
<h2 id="消失线"><a class="markdownIt-Anchor" href="#消失线"></a> 消失线</h2>
<img src="/视觉_img/12_7.png" style="zoom:40%">
<ol>
<li>平面上任意一组平行线都定义一个消失点</li>
<li>消失点的联合就是消失线(地平线)</li>
<li>不同平面可以定义不同的消失线</li>
</ol>
<h2 id="计算消失点"><a class="markdownIt-Anchor" href="#计算消失点"></a> 计算消失点</h2>
<img src="/视觉_img/12_8.png" style="zoom:40%">
<p>v = ΠP<sub>∞</sub></p>
<ol>
<li>
<p>解释：</p>
<ol>
<li>先得到一条射线Px，其中t是一个自由变化的系数，D是方向向量</li>
<li>将t-&gt;∞代入，得到P<sub>∞</sub></li>
<li>将P<sub>∞</sub>投影到成像平面</li>
</ol>
</li>
<li>
<p>特性：</p>
<ol>
<li>P<sub>∞</sub> 是无穷远处的一个点，v是其投影</li>
<li>仅取决于线的方向</li>
<li>平行线P<sub>0</sub>+tD和P<sub>1</sub>+tD相交于P<sub>∞</sub></li>
</ol>
</li>
<li>
<img src="/视觉_img/12_10.png" style="zoom:40%">
</li>
</ol>
<h2 id="计算消失线"><a class="markdownIt-Anchor" href="#计算消失线"></a> 计算消失线</h2>
<img src="/视觉_img/12_9.png" style="zoom:40%">
<p>作平行于地面平面且过C的平面与投影平面的交线。</p>
<ol>
<li>特性
<ol>
<li>I是通过C的水平平面与图像平面的交集</li>
<li>可以通过地面平面上的两组平行线计算I</li>
<li>所有与光心C同样高度的点投影到I上</li>
<li>提供了比较场景中对象高度的方法</li>
</ol>
</li>
</ol>
<h1 id="通过参照物测量高度"><a class="markdownIt-Anchor" href="#通过参照物测量高度"></a> 通过参照物测量高度</h1>
<ol>
<li>
<p>交叉比—射影不变量</p>
 <img src="/视觉_img/12_11.png" style="zoom:40%">
</li>
<li>
<p>测量高度</p>
 <img src="/视觉_img/12_12.png" style="zoom:40%">
</li>
<li>
<p>实际</p>
 <img src="/视觉_img/12_13.png" style="zoom:40%"></li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>联合国大楼</title>
    <url>/2020/03/30/%E8%81%94%E5%90%88%E5%9B%BD%E5%A4%A7%E6%A5%BC/</url>
    <content><![CDATA[<h1 id="uva-1605-联合国大楼"><a class="markdownIt-Anchor" href="#uva-1605-联合国大楼"></a> UVA 1605 联合国大楼</h1>
<p>给出有多少个国家 nnn （ n&lt;= 50），需要给每个国家安排办公室。大楼的每一层有着相同的行列数，请你构造一种安排（输出层数，行数和列数），使得每两个国家之间都有一间挨着的办公室，且办公室总数不超过 1000000 ，用不同字母表示不同国家，输出每层楼的安排方法。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>最简单的，一共键两层，每层都是n*n,令第一层全是国家i，第二层第j列全是国家j。这样任何一个国家(行)必能与另一层的所有列相交，所以设计方案一定正确。</li>
<li>使用中途相遇法，从两个不同的方向来解决问题</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 50 + 5;</span><br><span class="line">int f1[maxn][maxn];</span><br><span class="line">int f2[maxn][maxn];</span><br><span class="line">inline char to_alp(int x) &#123; return x &lt; 26 ? x + &#39;A&#39; : &#39;a&#39; + x - 26; &#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">int n;</span><br><span class="line">while (scanf(&quot;%d&quot;, &amp;n) &#x3D;&#x3D; 1) &#123;</span><br><span class="line"></span><br><span class="line">	printf(&quot;2 %d %d\n&quot;, n, n);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">			f1[i][j] &#x3D; i;</span><br><span class="line">			f2[i][j] &#x3D; j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">			printf(&quot;%c&quot;, to_alp(f1[i][j]));</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; n; j++)</span><br><span class="line">			printf(&quot;%c&quot;, to_alp(f2[i][j]));</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第13讲</title>
    <url>/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC13%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="极几何"><a class="markdownIt-Anchor" href="#极几何"></a> 极几何</h1>
<h2 id="基本的立体图算法"><a class="markdownIt-Anchor" href="#基本的立体图算法"></a> 基本的立体图算法</h2>
<img src="/视觉_img/13_1.png" style="zoom:1%">
<p>对于左图中每个像素，在右图同一个极线上选择最小匹配成本的像素。</p>
<ol>
<li>用SSD衡量成本</li>
<li>匹配窗口：大窗口粒度粗，小窗口更加精细，但是噪声多。</li>
</ol>
<h2 id="能量最小化求解立体视觉"><a class="markdownIt-Anchor" href="#能量最小化求解立体视觉"></a> 能量最小化求解立体视觉</h2>
<ol>
<li>目标
<ol>
<li>匹配质量：希望每个像素在其他图像中找到一个好的匹配项</li>
<li>平滑：如果两个像素相邻，他们的应该平移大约相同的量</li>
</ol>
</li>
</ol>
<h3 id="贪心匹配"><a class="markdownIt-Anchor" href="#贪心匹配"></a> 贪心匹配</h3>
<ol start="2">
<li>
<p>定义能量函数E(d)</p>
 <img src="/视觉_img/13_2.png" style="zoom:1%">
<ol>
<li>现在要找一个平移量映射D，最大限度的减少一个能量函数E(d)</li>
<li>独立的选择每一列的最小值d(x,y)=argmin C(x,y,d’)</li>
</ol>
</li>
</ol>
<h3 id="改进目标函数"><a class="markdownIt-Anchor" href="#改进目标函数"></a> 改进目标函数</h3>
<img src="/视觉_img/13_3.png" style="zoom:1%">
<p>其中</p>
<img src="/视觉_img/13_4.png" style="zoom:1%">
<p>对于平滑成本，v的选择很多</p>
<img src="/视觉_img/13_5.png" style="zoom:1%">
<ol>
<li>
<p>一维动态规划</p>
<ol>
<li>
<p>对每条扫描线使用动态规划方法独立求解</p>
</li>
<li>
<p>以增量方式构建成本函数D</p>
 <img src="/视觉_img/13_6.png" style="zoom:1%">
</li>
</ol>
</li>
<li>
<p>二维动态规划</p>
 <img src="/视觉_img/13_7.png" style="zoom:1%">
<ol>
<li>不能用二维动态规划求解，因为dx,y-1和 dx-1,y可能取决于 dx-1,y-1 的不同值</li>
<li>2D有许多局部极小值</li>
<li>以及一个大的搜索群空间</li>
<li>好的方法是马尔可夫随机场</li>
</ol>
</li>
</ol>
<h1 id="通过视差求深度"><a class="markdownIt-Anchor" href="#通过视差求深度"></a> 通过视差求深度</h1>
<img src="/视觉_img/13_8.png" style="zoom:1%">
<ol>
<li>baseline 极线，平行于成像平面</li>
<li>X是物体</li>
<li>x和x’是向量</li>
<li>(baseline-(x-x’))/baseline=z-f/z</li>
<li>z为深度</li>
</ol>
<h1 id="立体重建"><a class="markdownIt-Anchor" href="#立体重建"></a> 立体重建</h1>
<h2 id="过程"><a class="markdownIt-Anchor" href="#过程"></a> 过程</h2>
<ol>
<li>标定摄像机：标定内外参数</li>
<li>校正图像：将两个图像放到同一个平面上，且平行于baseline</li>
<li>计算平移量</li>
<li>估计深度</li>
</ol>
<h2 id="由结构光主动获得立体图"><a class="markdownIt-Anchor" href="#由结构光主动获得立体图"></a> 由结构光主动获得立体图</h2>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第15讲</title>
    <url>/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC15%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="运动恢复结构-sfm"><a class="markdownIt-Anchor" href="#运动恢复结构-sfm"></a> 运动恢复结构 SFM</h1>
<ol>
<li>目的：输入一对匹配点的图像坐标，输出这个点的三维坐标及相机内外参数(可能的话)。同时使得目标函数具有最小化重投影误差。</li>
<li>过程：
<ol>
<li>特征检测与匹配</li>
<li>匹配每对图像之间的特征</li>
<li>用 RANSAC 优化匹配以估计各对之间的基本矩阵</li>
</ol>
</li>
</ol>
<h2 id="目标函数"><a class="markdownIt-Anchor" href="#目标函数"></a> 目标函数</h2>
<img src="/视觉_img/15-1.png" style="zoom:80%">
<ol>
<li>目标是使重投影误差平方和最小</li>
<li>P(xi,Rj,tj)表示把Xi这个点投影到第j个相机。</li>
<li>Wij：=1代表三维点在图像中出现了；=0代表没出现。</li>
<li>解不唯一。</li>
</ol>
<h2 id="重复结构问题的解决"><a class="markdownIt-Anchor" href="#重复结构问题的解决"></a> 重复结构问题的解决</h2>
<ol>
<li>预处理：删除不一致的场景图边缘</li>
<li>后处理：识别和更正重复的结构</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第14讲</title>
    <url>/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC14%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="极线"><a class="markdownIt-Anchor" href="#极线"></a> 极线</h1>
<img src="/视觉_img/14_2.png" style="zoom:1%">
<ol>
<li>极线：极面与成像平面的交线</li>
</ol>
<h1 id="基本矩阵"><a class="markdownIt-Anchor" href="#基本矩阵"></a> 基本矩阵</h1>
<h2 id="基本矩阵性质"><a class="markdownIt-Anchor" href="#基本矩阵性质"></a> 基本矩阵性质</h2>
<ol>
<li>F将图像1中的点映射到图像2中的极线</li>
<li>Fp是与p对应的极线</li>
<li>F<sup>T</sup>q是与q对应的极线</li>
<li>Fe1=0，F<sup>T</sup>e2=0
<ol>
<li><strong>证明</strong> 比如极线恒过e1，则对于任意的q，e1<sup>T</sup>F1<sup>T</sup>q=0，则e1<sup>T</sup>F1<sup>T</sup>=0</li>
</ol>
</li>
<li>F的秩是2，行列式为0</li>
<li>点p在图2中的极线是:Fp</li>
<li>对应点间<strong>极线约束</strong>为q<sup>T</sup>Fp=0,即匹配点必须在极线上</li>
<li>特殊点e1和e2(极点)：是相机在另一个相机成像平面上的投影。(两个相机互相拍照)</li>
<li>所有极线都通过极点</li>
</ol>
<h2 id="求解基本矩阵-已标定时"><a class="markdownIt-Anchor" href="#求解基本矩阵-已标定时"></a> 求解基本矩阵-已标定时</h2>
<img src="/视觉_img/14_3.png" style="zoom:1%">	
<p>其中</p>
<ol>
<li>ot为baseline</li>
<li>相机1坐标系即世界坐标系</li>
<li>p,q为齐次坐标</li>
<li>旋转矩阵R<sup>-1</sup>=R<sup>T</sup><br />
<img src="/视觉_img/14_4.png" style="zoom:1%"></li>
</ol>
<img src="/视觉_img/14_5.png" style="zoom:1%">
<ol start="3">
<li>与t的叉积可表示为</li>
</ol>
<img src="/视觉_img/14_6.png" style="zoom:1%">
<img src="/视觉_img/14_7.png" style="zoom:1%">
<ol start="4">
<li>求得本质矩阵E</li>
</ol>
<img src="/视觉_img/14_8.png" style="zoom:1%">
<ol start="5">
<li>求得基本矩阵F</li>
</ol>
<img src="/视觉_img/14_9.png" style="zoom:1%">	
<h2 id="估计基本矩阵"><a class="markdownIt-Anchor" href="#估计基本矩阵"></a> 估计基本矩阵</h2>
<p>在不知道K1,K2,R或t的情况下估计F</p>
<h3 id="8点算法"><a class="markdownIt-Anchor" href="#8点算法"></a> 8点算法</h3>
<ol>
<li>
<p>求解思路<br />
对于每对匹配点，由x’<sup>T</sup>Fx=0</p>
 <img src="/视觉_img/14_10.png" style="zoom:1%">	
<p>将问题转换成求解让det(Af)最小化的f,其解为A<sup>T</sup>A的最小特征向量。</p>
</li>
<li>
<p>问题</p>
<ol>
<li>不能保证F的秩是2</li>
</ol>
</li>
<li>
<p>解决</p>
<ol>
<li>因此应将F换成F’，F’的秩为2，且是|F-F’|最小化</li>
</ol>
 <img src="/视觉_img/14_11.png" style="zoom:1%">
</li>
<li>
<p>8点算法：</p>
<ol>
<li><strong>优点</strong> 是线性的，易于实现且速度快</li>
<li><strong>缺点</strong> 易受噪声影响，当各列间数量级差别较大的时候，最小二乘法得到不良解。</li>
</ol>
</li>
</ol>
<h2 id="归一化的8点算法"><a class="markdownIt-Anchor" href="#归一化的8点算法"></a> 归一化的8点算法</h2>
<p>将图像变换到[-1,1]×[-1,1]</p>
<img src="/视觉_img/14_12.png" style="zoom:1%">
<img src="/视觉_img/14_13.png" style="zoom:1%">
<p>其中T为归一化矩阵</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第16讲</title>
    <url>/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC16%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="立体视觉"><a class="markdownIt-Anchor" href="#立体视觉"></a> 立体视觉</h1>
<p>通过多个角度拍摄的标定过 的图像，进行3D对象建模。###</p>
<h1 id="多视图立体视觉"><a class="markdownIt-Anchor" href="#多视图立体视觉"></a> 多视图立体视觉</h1>
<ol>
<li>需要多视图原因
<ol>
<li>可能有某些区域的特写</li>
<li>某些表面在某些视图中缩小了</li>
<li>某些点可能在某些视图中完全消失。</li>
<li>多次测量同一个点可以减小误差。</li>
</ol>
</li>
</ol>
<h1 id="多基线立体视觉"><a class="markdownIt-Anchor" href="#多基线立体视觉"></a> 多基线立体视觉</h1>
<p>将几台相机矫正到同一共同平面上。可能有宽基线和扭曲问题。</p>
<h2 id="选择立体视图基线"><a class="markdownIt-Anchor" href="#选择立体视图基线"></a> 选择立体视图基线</h2>
<img src="/视觉_img/16-1.png" height="5%" width="%5">
<img src="/视觉_img/16-2.png" height="5%" width="%5">
<ol>
<li>基线太小导致深度误差大</li>
<li>基线太大大致搜索范围大，计算复杂度提高。</li>
</ol>
<h2 id="基本方法"><a class="markdownIt-Anchor" href="#基本方法"></a> 基本方法</h2>
<ol>
<li>选择参考视图</li>
<li>使用立体视图算法，但将其中双视图SSD换成SSSD(SUM SSD)</li>
</ol>
<h3 id="限制"><a class="markdownIt-Anchor" href="#限制"></a> 限制</h3>
<ol>
<li>只能给出深度图，不能给出对象模型</li>
<li>不适用于广泛分布的视图</li>
</ol>
<h1 id="照片一致性评分"><a class="markdownIt-Anchor" href="#照片一致性评分"></a> 照片一致性评分</h1>
<h2 id="衡量函数"><a class="markdownIt-Anchor" href="#衡量函数"></a> 衡量函数</h2>
<ol>
<li>
<p>SSD</p>
 <img src="/视觉_img/16-3.png" height="5%" width="%5">
</li>
<li>
<p>SAD</p>
 <img src="/视觉_img/16-4.png" height="5%" width="%5">
</li>
<li>
<p>ZNCC</p>
 <img src="/视觉_img/16-5.png" height="5%" width="%5">
</li>
</ol>
<h1 id="平面扫描立体视觉"><a class="markdownIt-Anchor" href="#平面扫描立体视觉"></a> 平面扫描立体视觉</h1>
<h2 id="基础"><a class="markdownIt-Anchor" href="#基础"></a> 基础</h2>
<img src="/视觉_img/16-6.png" height="5%" width="%5">
<ol>
<li>
<p>相机1系即世界坐标系，相机1为参考相机</p>
</li>
<li>
<p>深度平面</p>
 <img src="/视觉_img/16-7.png" height="5%" width="%5">
<ol>
<li>其中n<sub>m</sub>为深度平面的法向量</li>
<li>平面表示为ax+by+cz+d=0</li>
<li>点到平面距离dm=√a<sup>2</sup>+b<sup>2</sup>+c<sup>2</sup>?</li>
</ol>
</li>
<li>
<p>从参考相机Pref映射到深度平<br />
面Πm，再映射到相机Pk的单应<br />
映射为</p>
 <img src="/视觉_img/16-8.png" height="5%" width="%5">
</li>
</ol>
<h2 id="过程"><a class="markdownIt-Anchor" href="#过程"></a> 过程</h2>
<img src="/视觉_img/16-9.png" height="5%" width="%5">
<h3 id="参考平面"><a class="markdownIt-Anchor" href="#参考平面"></a> 参考平面</h3>
<ol>
<li>
<p>与成像平面平行<br />
<img src="/视觉_img/16-10.png" height="5%" width="%5"></p>
</li>
<li>
<p>其他方向</p>
 <img src="/视觉_img/16-11.png" height="5%" width="%5">
</li>
</ol>
<h1 id="深度图融合"><a class="markdownIt-Anchor" href="#深度图融合"></a> 深度图融合</h1>
<p>方法</p>
<ol>
<li>使用多基线方法计算一个深度图</li>
<li>体积融合</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第1讲</title>
    <url>/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC1%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="滤波器"><a class="markdownIt-Anchor" href="#滤波器"></a> 滤波器</h1>
<ol>
<li><strong>滤波</strong>：形成一个新的图像，其像素是原始像素的组合。</li>
<li>用途：
<ol>
<li>提取边缘或轮廓</li>
<li>消除噪音</li>
<li>锐化和增强形象</li>
</ol>
</li>
</ol>
<h1 id="线性滤波"><a class="markdownIt-Anchor" href="#线性滤波"></a> 线性滤波</h1>
<ol>
<li>线性滤波：用相邻的线性组合(加权和)替换每个像素</li>
</ol>
<p>–&gt;互相关，卷积</p>
<h2 id="相关"><a class="markdownIt-Anchor" href="#相关"></a> 相关</h2>
<img src="/视觉_img/1-1.png" style="zoom:1%">
<ol>
<li>将图像记为,以H表示权重核（大小为(2K+1)x(2K+1)),并记G为输出图像</li>
<li>G=H×F</li>
</ol>
<h2 id="卷积"><a class="markdownIt-Anchor" href="#卷积"></a> 卷积</h2>
<img src="/视觉_img/1-2.png" style="zoom:1%">
<ol>
<li>与相关相同，只是将权重核在水平和竖直方向翻转。</li>
<li>妈祖交换律、分配律和结合律</li>
</ol>
<h2 id="平均滤波"><a class="markdownIt-Anchor" href="#平均滤波"></a> 平均滤波</h2>
<ol>
<li>H 全为1/k，其中k为权重核边长。</li>
</ol>
<h2 id="锐化-增强图像-平均滤波"><a class="markdownIt-Anchor" href="#锐化-增强图像-平均滤波"></a> 锐化 = 增强图像-平均滤波</h2>
<img src="/视觉_img/1-3.png" style="zoom:1%">
<img src="/视觉_img/1-5.png" style="zoom:1%">
<h2 id="高斯滤波"><a class="markdownIt-Anchor" href="#高斯滤波"></a> 高斯滤波</h2>
<ol>
<li>
<p>高斯核</p>
 <img src="/视觉_img/1-4.png" style="zoom:1%">
<ol>
<li>σ作用：σ越大，带通越大，高斯核函数的局部影响的范围就越大。中心亮点也越大，卷积后的图像越模糊。</li>
</ol>
</li>
<li>
<p>高斯滤波器（低通滤波器）</p>
<ol>
<li>用宽度为σ的核卷积两次=以宽度为√2σ的核卷积一次。</li>
</ol>
</li>
</ol>
<h2 id="阈值滤波器"><a class="markdownIt-Anchor" href="#阈值滤波器"></a> 阈值滤波器</h2>
<p><strong>不是线性滤波器</strong></p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第17讲</title>
    <url>/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC17%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="光"><a class="markdownIt-Anchor" href="#光"></a> 光</h1>
<h2 id="辐射"><a class="markdownIt-Anchor" href="#辐射"></a> 辐射</h2>
<ol>
<li>像素亮度决定因素
<ol>
<li>光源属性</li>
<li>表面特性</li>
</ol>
</li>
</ol>
<h2 id="光谱"><a class="markdownIt-Anchor" href="#光谱"></a> 光谱</h2>
<p>可见光为400nm-700nm的电磁辐射</p>
<h2 id="颜色知觉"><a class="markdownIt-Anchor" href="#颜色知觉"></a> 颜色知觉</h2>
<img src="/视觉_img/17-1.png">
<img src="/视觉_img/17-2.png">
<ol>
<li>视锥细胞和视杆细胞在光谱上充当滤波器。</li>
</ol>
<h2 id="亮度对比度和恒常"><a class="markdownIt-Anchor" href="#亮度对比度和恒常"></a> 亮度对比度和恒常</h2>
<ol>
<li>亮度对比度：恒定的有色区域根据周围的强度看起来更亮或更暗。</li>
<li>明度恒常性：当照明条件改变时，人知觉到的物体的相对明度保持不变。</li>
</ol>
<h2 id="光照"><a class="markdownIt-Anchor" href="#光照"></a> 光照</h2>
<h3 id="定向照明"><a class="markdownIt-Anchor" href="#定向照明"></a> 定向照明：</h3>
<ol>
<li>所有射线都是平行的</li>
<li>等价于无穷远的点光源</li>
</ol>
<h3 id="漫反射"><a class="markdownIt-Anchor" href="#漫反射"></a> 漫反射</h3>
<img src="/视觉_img/17-3.png">
<p>I = N·L</p>
<ol>
<li>漫反射反射到各个角度得到的光强一样，与视角无关</li>
<li>正比于夹角余弦</li>
</ol>
<h3 id="三种材料"><a class="markdownIt-Anchor" href="#三种材料"></a> 三种材料</h3>
<ol>
<li>理想漫反射：哑光表面</li>
<li></li>
</ol>
<h1 id="图像形成模型"><a class="markdownIt-Anchor" href="#图像形成模型"></a> 图像形成模型</h1>
<img src="/视觉_img/17-4.png">
<h2 id="模型"><a class="markdownIt-Anchor" href="#模型"></a> 模型</h2>
<ol>
<li>Kd：表示入射光反射的比例</li>
<li>I：光强度，表示有多少光射进来</li>
<li>相机相应函数：假设像素值与传入光的能量成线性比例关系。</li>
</ol>
<h2 id="用途"><a class="markdownIt-Anchor" href="#用途"></a> 用途</h2>
<p>测量光的方向以辨别真假照片。</p>
<p>需要增加假设</p>
<ol>
<li>反照率恒定</li>
<li>已知一些法线</li>
<li>已知法线的平滑度</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第19讲</title>
    <url>/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC19%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="图像识别"><a class="markdownIt-Anchor" href="#图像识别"></a> 图像识别</h1>
<ol>
<li>简单匹配存在的问题：
<ol>
<li>遮挡，视角的变化</li>
<li>类内的变化</li>
<li>照明变化</li>
<li>变形</li>
<li>背景杂乱</li>
</ol>
</li>
<li>没有明确的解</li>
</ol>
<h1 id="数据驱动的方法"><a class="markdownIt-Anchor" href="#数据驱动的方法"></a> 数据驱动的方法</h1>
<img src="/视觉_img/19-1.png">
<ol>
<li>收集带有标签的图像数据库</li>
<li>使用机器学习算法训练图像分类器</li>
<li>用测试图像评估分类器的效果</li>
</ol>
<h2 id="线性分类器"><a class="markdownIt-Anchor" href="#线性分类器"></a> 线性分类器</h2>
<p>要做</p>
<ol>
<li>定义一个损失函数：在训练集上评估我们对分类分数的不满意程度</li>
<li>优化方法：求解参数的方法，以最小化损失函数</li>
</ol>
<h3 id="评分函数-原始数据到类分数"><a class="markdownIt-Anchor" href="#评分函数-原始数据到类分数"></a> 评分函数 原始数据到类分数</h3>
<img src="/视觉_img/19-2.png">
<ol>
<li>要将图像拉成列向量</li>
<li>偏执向量可归到权重向量中</li>
</ol>
<h3 id="损失函数-预测分数与实际标签的一致性"><a class="markdownIt-Anchor" href="#损失函数-预测分数与实际标签的一致性"></a> 损失函数 预测分数与实际标签的一致性</h3>
<img src="/视觉_img/19-3.png">
<ol>
<li>其中yi为真实标签</li>
<li>目标是通过训练找到最小化损失函数的参数W(评分函数中的权)</li>
</ol>
<h2 id="softmax分类"><a class="markdownIt-Anchor" href="#softmax分类"></a> Softmax分类</h2>
<p>由于分数不直观，所以将分数归一化得到概率分布。推广逻辑斯蒂回归将分数转到(0,1)。</p>
<img src="/视觉_img/19-4.png">
<img src="/视觉_img/19-5.png">
<ol>
<li>分数转到(0,1)</li>
<li>Li只对真实标签计算，取值[0,∞]。S=0时，Li=logN</li>
<li>注意Li的负号</li>
</ol>
<h3 id="交叉熵损失"><a class="markdownIt-Anchor" href="#交叉熵损失"></a> 交叉熵损失</h3>
<ol>
<li>
<img src="/视觉_img/19-6.png">
</li>
<li>Softmax分类器目标是最小化交叉熵</li>
</ol>
<h3 id="kl-散度-相对熵"><a class="markdownIt-Anchor" href="#kl-散度-相对熵"></a> KL 散度 相对熵</h3>
<img src="/视觉_img/19-7.png">
<ol>
<li>描述p与q之间的差异</li>
<li>非负</li>
</ol>
<h3 id="正则化"><a class="markdownIt-Anchor" href="#正则化"></a> 正则化</h3>
<img src="/视觉_img/19-8.png">
<img src="/视觉_img/19-13.png">
<ol>
<li>使模型更加简单，增强其泛化能力</li>
<li>使权重均匀</li>
<li>避免过拟合，避免拟合噪声，增强泛化能力</li>
</ol>
<h2 id="设置权重的方法"><a class="markdownIt-Anchor" href="#设置权重的方法"></a> 设置权重的方法</h2>
<h3 id="随机搜索"><a class="markdownIt-Anchor" href="#随机搜索"></a> 随机搜索</h3>
<h3 id="随机梯度下降"><a class="markdownIt-Anchor" href="#随机梯度下降"></a> 随机梯度下降</h3>
<p>跟随斜坡(沿梯度反方向进发)</p>
<img src="/视觉_img/19-9.png">
<p>𝛻<sub>w</sub>L = W-α𝛻<sub>w</sub>L</p>
<ol>
<li>
<p>对于一维函数，梯度即导数。对于多维函数，梯度是沿各维的偏导数。</p>
</li>
<li>
<p>某个方向上的斜率是该方向与梯度的点积。</p>
</li>
<li>
<p>两向量方向相同时，点积模长最大。所以下降最快速的方向是负梯度方向。</p>
</li>
<li>
<p>α为学习率：太大会错过最低点，太小收敛速度慢。</p>
</li>
<li>
<p>数值解求法 速度慢</p>
 <img src="/视觉_img/19-10.png">
 <img src="/视觉_img/19-11.png">
 <img src="/视觉_img/19-12.png">
<p>近似、速度慢、容易编程</p>
</li>
<li>
<p><strong>解析解求法</strong>(梯度检查) 用微积分来求</p>
 <img src="/视觉_img/19-14.png">
<p>精确、快速、容易出错</p>
</li>
</ol>
<h3 id="批量梯度下降"><a class="markdownIt-Anchor" href="#批量梯度下降"></a> 批量梯度下降</h3>
<img src="/视觉_img/19-15.png">
<h3 id="动量项"><a class="markdownIt-Anchor" href="#动量项"></a> 动量项</h3>
<img src="/视觉_img/19-16.png">
<p>使得梯度变换平缓一些</p>
<h1 id="图像特征分类"><a class="markdownIt-Anchor" href="#图像特征分类"></a> 图像特征分类</h1>
<p>方法</p>
<ol>
<li>建立颜色直方图</li>
<li>建立梯度直方图</li>
<li>建立词袋</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第18讲</title>
    <url>/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC18%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="光度测量立体视觉"><a class="markdownIt-Anchor" href="#光度测量立体视觉"></a> 光度测量立体视觉</h1>
<p>基于<strong>朗伯漫反射</strong></p>
<h2 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h2>
<h3 id="求光照方向"><a class="markdownIt-Anchor" href="#求光照方向"></a> 求光照方向</h3>
<p>利用铬球的镜面反射</p>
<img src="/视觉_img/18-2.png">
### 求法线方向
<p>假设已知三个点</p>
<ol>
<li>
<img src="/视觉_img/18-3.png">
</li>
<li>
<p>写成矩阵形式</p>
</li>
<li>
 <img src="/视觉_img/18-4.png">
</li>
<li>
<p>求解N</p>
 <img src="/视觉_img/18-5.png">
</li>
<li>
<p>对每个像素求解可以获得该像素的表面法线方向</p>
</li>
<li>
<p>超过三个光源<br />
<img src="/视觉_img/18-1.png"></p>
</li>
</ol>
<h3 id="从法线计算深度泊松方程"><a class="markdownIt-Anchor" href="#从法线计算深度泊松方程"></a> 从法线计算深度(泊松方程)</h3>
<p>将相邻的连个点的连线看成是曲面的切面向量，那么这条线与法线垂直。</p>
<img src="/视觉_img/18-6.png">
<h3 id="局限性"><a class="markdownIt-Anchor" href="#局限性"></a> 局限性</h3>
<p>对于有反射，折射，阴影等情况不起效</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第3讲</title>
    <url>/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC3%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="子采样"><a class="markdownIt-Anchor" href="#子采样"></a> 子采样</h1>
<ol>
<li>每隔一行一列丢弃一行一列</li>
<li>问题：导致噪声变多</li>
<li>解决：先滤波，再子采样</li>
</ol>
<h2 id="混叠"><a class="markdownIt-Anchor" href="#混叠"></a> 混叠</h2>
<ol>
<li>定义：当采样频率不够高时，无法捕捉图像中的细节。</li>
<li>解决：采样率≥2 * 图像中的最大频率&lt;=&gt;每周期至少两个样本</li>
<li>若原始图像频率太高，则先做高斯预处理，然后子采样。（高斯金字塔）</li>
</ol>
<h1 id="上采样"><a class="markdownIt-Anchor" href="#上采样"></a> 上采样</h1>
<h2 id="最简单方法"><a class="markdownIt-Anchor" href="#最简单方法"></a> 最简单方法</h2>
<p>重复每行每列n次</p>
<h2 id="图像插值"><a class="markdownIt-Anchor" href="#图像插值"></a> 图像插值</h2>
<img src="/视觉_img/3-1.png" style="zoom:80%">
### 重建滤波器
1. 目的是重建连续图像f
2. 步骤
	1. 将F转换成连续函数：
		f<sub>F</sub>(x)=F(x/d) 当x/d是整数，否则为0
	2. 用重建滤波器H来卷积
		f = h*f<sub>F</sub>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第2讲</title>
    <url>/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC2%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="边缘"><a class="markdownIt-Anchor" href="#边缘"></a> 边缘</h1>
<ol>
<li>
<p>来源：</p>
<ol>
<li>表面法线不连续</li>
<li>深度不连续</li>
<li>颜色不连续</li>
<li>光照不连续</li>
</ol>
</li>
<li>
<p>特征是图像强度函数中快速变化的地方：</p>
<ol>
<li>一阶导数的极值点</li>
<li>二阶导数为0的点</li>
</ol>
</li>
</ol>
<h2 id="图像导数求解"><a class="markdownIt-Anchor" href="#图像导数求解"></a> 图像导数求解</h2>
<img src="/视觉_img/1-6.png" style="zoom:1%">
<h2 id="图像梯度求解"><a class="markdownIt-Anchor" href="#图像梯度求解"></a> 图像梯度求解</h2>
<img src="/视觉_img/1-7.png" style="zoom:1%">
<ol>
<li>梯度点在强度增大最快的方向上</li>
<li>边缘方向与梯度方向垂直</li>
</ol>
<h2 id="去噪"><a class="markdownIt-Anchor" href="#去噪"></a> 去噪</h2>
<ol>
<li>
<p>问题</p>
 <img src="/视觉_img/1-8.png" style="zoom:1%">
</li>
<li>
<p>解决:先做平滑</p>
 <img src="/视觉_img/1-9.png" style="zoom:1%">
<ol>
<li>核一般不变，可以先求h的导数，以简化计算。</li>
</ol>
</li>
</ol>
<h1 id="边缘检测"><a class="markdownIt-Anchor" href="#边缘检测"></a> 边缘检测</h1>
<h2 id="高斯一阶导"><a class="markdownIt-Anchor" href="#高斯一阶导"></a> 高斯一阶导</h2>
<img src="/视觉_img/1-10.png" style="zoom:1%">
<h2 id="sobel算子"><a class="markdownIt-Anchor" href="#sobel算子"></a> Sobel算子</h2>
<img src="/视觉_img/1-11.png" style="zoom:1%">
<ol>
<li>是高斯导数的一般近似</li>
<li>标准定义中没有1/8，不会影响边缘检测</li>
<li>如果要得到正确的梯度值，1/8是必须的。</li>
</ol>
<h2 id="非最大抑制"><a class="markdownIt-Anchor" href="#非最大抑制"></a> 非最大抑制</h2>
<p>检测像素是否是梯度方向上的局部最大值，一般需要插值。</p>
<img src="/视觉_img/1-12.png" style="zoom:1%">
<h2 id="canny-边缘检测器"><a class="markdownIt-Anchor" href="#canny-边缘检测器"></a> Canny 边缘检测器</h2>
<p><strong>步骤</strong></p>
<ol>
<li>用高斯导数做滤波
<ol>
<li>大σ检测大尺度边缘</li>
<li>小σ检测细微边缘</li>
</ol>
</li>
<li>获得梯度的赋值和方向</li>
<li>非最大抑制</li>
<li>连接与滞后 阈值化（两个阈值）
<ol>
<li>高阈值寻找边缘曲线的起点</li>
<li>低阈值确定后继点</li>
</ol>
</li>
</ol>
<h1 id="尺度空间"><a class="markdownIt-Anchor" href="#尺度空间"></a> 尺度空间</h1>
<p><strong>性质</strong></p>
<ol>
<li>边缘位置随尺度(σ) 的增大而变化</li>
<li>随尺度增加，两条边缘有可能合并</li>
<li>随尺度增加，边缘不可能分成两个</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第4讲</title>
    <url>/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC4%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="harris角点检测"><a class="markdownIt-Anchor" href="#harris角点检测"></a> Harris角点检测</h1>
<ol>
<li>不变的局部特征
<ol>
<li>几何不变性：平移、旋转、缩放</li>
<li>光度不变性：亮度、曝光率</li>
<li>局部特征的优点
<ol>
<li>局部性：由于特征是局部的，所以对遮挡和噪声鲁棒。</li>
<li>数量：一张图片中成百上千。</li>
<li>独特性：可以区分大量对象</li>
<li>效率：可实现实时性能。</li>
</ol>
</li>
</ol>
</li>
<li>好的特征
<ol>
<li>需要具有唯一性</li>
<li>在任何方向上移动窗口都导致大的变化–&gt;角点。</li>
</ol>
</li>
<li>Harris角点检测
<ol>
<li>
<p>通过比较平移前后窗口w内每个像素的差异平方和(SSD)</p>
</li>
<li>
<p>SSD:<br />
<img src="/视觉_img/4_1.png" style="zoom:80%"></p>
<ol>
<li>SSD越大越好</li>
<li>问题：计算每个点的SSD很慢。</li>
<li>对平移量进行泰勒级数展开。</li>
</ol>
</li>
<li>
<p>近似SSD</p>
 <img src="/视觉_img/4_2.png" style="zoom:80%">
 <img src="/视觉_img/4_3.png" style="zoom:80%">
 1. 对于水平边缘Ix=0;垂直边缘Iy=0;
 2. 对于矩阵H可以看作一个椭圆
<pre><code> &lt;img src=&quot;/视觉_img/4_4.png&quot; style=&quot;zoom:80%&quot;&gt;
 
 可以通过查看H的特征向量来找到导致最大和最小的E的方向。
 1. &lt;img src=&quot;/视觉_img/4_4.png&quot; style=&quot;zoom:80%&quot;&gt;
 2. 特征值与特征检测的关系：我们希望E(u,v)的最小值对于小的平移量(u,v)都大，此最小值由H的较小的特征值λ&lt;sub&gt;min&lt;/sub&gt;给出
</code></pre>
</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第5讲</title>
    <url>/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC5%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="特征不变性"><a class="markdownIt-Anchor" href="#特征不变性"></a> 特征不变性</h1>
<ol>
<li>
<p>不变性与协变性</p>
<ol>
<li>
<p>不变性：图像变换后，角点位置不变。</p>
<p>我们希望角点的位置对光照变换有不</p>
</li>
<li>
<p>协变性：如果有两张同一图像的变换版本，则应在相应的位置检测到同一特征。</p>
<p>我们希望角点对几何变换具有协变性。</p>
</li>
</ol>
</li>
<li>
<p>Harris检测器</p>
<ol>
<li>平移：
<ol>
<li>导数和窗口函数是平移不变的。</li>
<li>角点位置是平移协变的。</li>
</ol>
</li>
<li>图像旋转
<ol>
<li>形状是旋转不变的</li>
<li>角点位置是旋转协变的。</li>
</ol>
</li>
<li>仿射强度变化
<ol>
<li>
<p>对仿射强度变化部分具有不变性。</p>
 <img src="/视觉_img/5_1.png" style="zoom:80%">
</li>
</ol>
</li>
<li>缩放
<ol>
<li>对缩放不具有不变性。</li>
<li>实现尺度不变性：寻找使f具有局部最大值的尺度。
<ol>
<li>同时在位置和尺度上查找。</li>
</ol>
</li>
<li>自动尺度选择：规格化到固定尺度。
<ol>
<li>是在高斯金字塔中使用固定大小的窗口。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>高斯-拉布普拉斯算子(LoG)</p>
<p><a href="%22https://blog.csdn.net/touch_dream/article/details/62237018%22/a">高斯-拉普拉斯算子</a></p>
<ol>
<li>
<p>LoG是高斯函数的二阶导数</p>
</li>
<li>
<p>为了减少计算量，可以用高斯差分算子(DoG)来近似</p>
 <img src="/视觉_img/5_2.png" style="zoom:80%">
<p>该函数逼近是因为发现高斯二阶导和原高斯函数对sigma参数求导之后函数模型的关系如上述的公式，然后约等于右边的导数表达式（严格的话需要加上极限的）！模型逼近如下：好处是可以提高算法的效率减少计算量</p>
</li>
<li>
<p>LoG和DoG都是旋转不变的。</p>
</li>
</ol>
</li>
<li>
<p>Blob斑点检测器</p>
<ol>
<li>在空间和尺度上查找LoG算子的极大值和极小值。
<ol>
<li>
<p>将一个点与周围26个点比较，以求得极大值。</p>
 <img src="/视觉_img/5_3.png" style="zoom:80%">
</li>
</ol>
</li>
<li>特征尺度：产生拉普拉斯响应峰值的尺度。</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第6讲</title>
    <url>/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC6%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="特征描述符"><a class="markdownIt-Anchor" href="#特征描述符"></a> 特征描述符</h1>
<ol>
<li>性质：
<ol>
<li>不变性：图像被变换，描述符应该不变</li>
<li>区分力：每个点的描述符是高度唯一的</li>
</ol>
</li>
</ol>
<h2 id="实现不变性"><a class="markdownIt-Anchor" href="#实现不变性"></a> 实现不变性</h2>
<ol>
<li>确保检测器是不变的</li>
<li>设计不变的特征描述符</li>
</ol>
<h2 id="旋转不变性"><a class="markdownIt-Anchor" href="#旋转不变性"></a> 旋转不变性</h2>
<p>通过寻找图像块的主导方向实现，主导方向为<br />
1. H的特征向量Xmax对应的λmax<br />
2. 梯度方向</p>
<h2 id="mops"><a class="markdownIt-Anchor" href="#mops"></a> MOPS</h2>
<ol>
<li><strong>步骤</strong>：
<ol>
<li>选出特征点周围40×40的窗口</li>
<li>缩放到1/5大小</li>
<li>旋转至水平</li>
<li>在以特征为中心的8×8窗口内采样</li>
<li>规格化：强度减去平均值除以标准差，使之均值为0，方差为1。</li>
</ol>
</li>
</ol>
<h2 id="sift"><a class="markdownIt-Anchor" href="#sift"></a> SIFT</h2>
<ol>
<li>
<p><strong>步骤</strong></p>
<ol>
<li>取特征周围16×16的窗口，划分为4×4单元格</li>
<li>为每个像素计算边缘方向(梯度方向-90°)</li>
<li>通过梯度幅值阈值去除弱的边缘</li>
<li>为剩余边缘<strong>方向</strong>建立直方图，得到16个单元格×8方向=128维描述符</li>
<li>将该128维描述符归一化到单位长度</li>
</ol>
</li>
<li>
<p>性质：</p>
<ol>
<li>可以处理视角变化</li>
<li>适应光照变化</li>
<li>快速高效</li>
</ol>
</li>
</ol>
<h1 id="特征匹配"><a class="markdownIt-Anchor" href="#特征匹配"></a> 特征匹配</h1>
<p>想找到最佳匹配</p>
<ol>
<li>定义距离函数来比较两个描述符</li>
<li>测试I2中所有的特征，找出距离最小的一个。</li>
</ol>
<h2 id="特征距离"><a class="markdownIt-Anchor" href="#特征距离"></a> 特征距离</h2>
<ol>
<li>定义为||f1-f2||
<ol>
<li><strong>问题</strong> 可能对不正确匹配给出小的距离。</li>
<li><strong>解决</strong> 定义距离比= ||f1-f2||/||f1-f2’||
<ol>
<li>f2是f1在I2中最好的SSD匹配</li>
<li>f2’是f1在I2中次好的SSD匹配</li>
<li>距离比可以对不正确的匹配给出较大的值，用阈值过滤即可。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="结果评估"><a class="markdownIt-Anchor" href="#结果评估"></a> 结果评估</h1>
<ol>
<li>最大化真阳性，最小化假阳性</li>
</ol>
<h2 id="roc-曲线"><a class="markdownIt-Anchor" href="#roc-曲线"></a> Roc 曲线</h2>
<img src="/视觉_img/6-1.png" style="zoom:1%">
<img src="/视觉_img/6-2.png" style="zoom:1%">
1. AUC:一个正例，一个负例，预测为正的概率值比负的概率值还要大的可能性。
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第7讲</title>
    <url>/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC7%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="图像卷绕"><a class="markdownIt-Anchor" href="#图像卷绕"></a> 图像卷绕</h1>
<p>卷绕&amp;滤波：</p>
<p>滤波改变图像的值域</p>
<p>&lt;img src=&quot;/视觉_img/7-1.png&quot;style=“zoom:1%”&gt;</p>
<p>卷绕改变图像的定义域</p>
<p>&lt;img src=&quot;/视觉_img/7-2.png&quot;style=“zoom:1%”&gt;</p>
<h2 id="线性变换"><a class="markdownIt-Anchor" href="#线性变换"></a> 线性变换</h2>
<ol>
<li>
<p>缩放</p>
<p>&lt;img src=&quot;/视觉_img/7-3.png&quot;style=“zoom:1%”&gt;</p>
</li>
<li>
<p>旋转</p>
<p>&lt;img src=&quot;/视觉_img/7-4.png&quot;style=“zoom:1%”&gt;</p>
<ol>
<li>R<sup>-1</sup>=R<sup>T</sup></li>
</ol>
</li>
<li>
<p>镜像</p>
<ol>
<li>
<p>关于Y轴镜像</p>
<p>&lt;img src=&quot;/视觉_img/7-5.png&quot;style=“zoom:1%”&gt;</p>
</li>
<li>
<p>关于y=x镜像</p>
<p>&lt;img src=&quot;/视觉_img/7-6.png&quot;style=“zoom:1%”&gt;</p>
</li>
</ol>
</li>
<li>
<p>剪切</p>
</li>
<li>
<p>性质：</p>
<ol>
<li>原点映射到原点</li>
<li>直线映射到直线</li>
<li>平行线保持平行</li>
<li>保持比率</li>
<li>线性变换的组合仍然是线性变换。</li>
</ol>
</li>
</ol>
<h2 id="非线性变换仿射变换"><a class="markdownIt-Anchor" href="#非线性变换仿射变换"></a> 非线性变换–仿射变换</h2>
<p>&lt;img src=&quot;/视觉_img/7-8.png&quot;style=“zoom:1%”&gt;</p>
<p>方式变换是线性变换和平移变换的组合</p>
<ol>
<li>
<p>基本仿射变换</p>
<p>&lt;img src=&quot;/视觉_img/7-7.png&quot;style=“zoom:1%”&gt;</p>
</li>
<li>
<p>仿射变换的性质</p>
<ol>
<li>原点不一定映射到原点</li>
<li>直线映射到直线</li>
<li>平行线保持平行</li>
<li>保持比率</li>
<li>仿射变换的组合仍然是仿射变换</li>
</ol>
</li>
</ol>
<h2 id="投影变换透视变换单应映射"><a class="markdownIt-Anchor" href="#投影变换透视变换单应映射"></a> 投影变换(透视变换/单应映射)</h2>
<p>&lt;img src=&quot;/视觉_img/7-9.png&quot;style=“zoom:1%”&gt;</p>
<ol>
<li>8个自由度</li>
<li>投影变换的属性
<ol start="2">
<li>
<p>保直线</p>
</li>
<li>
<p>原点不一定映射到原点</p>
</li>
<li>
<p>不保平行</p>
</li>
<li>
<p>不保比率</p>
</li>
<li>
<p>投影的组合仍然是投影变换</p>
</li>
</ol>
</li>
</ol>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>&lt;img src=&quot;/视觉_img/7-10.png&quot;style=“zoom:1%”&gt;</p>
<h1 id="实现图像卷绕"><a class="markdownIt-Anchor" href="#实现图像卷绕"></a> 实现图像卷绕</h1>
<h2 id="前向卷绕"><a class="markdownIt-Anchor" href="#前向卷绕"></a> 前向卷绕</h2>
<p>将每个像素f (x,y)复制到g图中对应位置(x’,y’) = T(x,y)</p>
<ol>
<li>如果(x’,y’)不是整数，则将像素值分配给四个最近邻，记录每个点的权重并在最后归一化。</li>
<li><strong>问题</strong> 可能有空洞，效果是混叠与模糊</li>
</ol>
<h2 id="反向卷绕"><a class="markdownIt-Anchor" href="#反向卷绕"></a> 反向卷绕</h2>
<p>获取每个像素g(x’, y’) 在原图像中对应的位 置 (x, y) = T<sup>-1</sup>(x’<br />
, y’) 处的像素值f(x, y)</p>
<ol>
<li>如果(x,y)不是整数，则f(x,y)的颜色值通过原图像中邻域的插值获得，且可以使用滤波器来控制混叠。</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第8讲</title>
    <url>/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC8%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="图像配准"><a class="markdownIt-Anchor" href="#图像配准"></a> 图像配准</h1>
<p>问题：给定图像A和B之间的一组匹配项，如何计算从A到B的变换T？</p>
<ol>
<li>
<p>对于平移</p>
<ol>
<li>最简单的取n对匹配的移动平均值值<br />
<img src="/视觉_img/8_1.png" style = "zoom:80%" /></li>
<li>通过线性方程组求解
<ol>
<li>问题：对于n对匹配点，有2两个未知数和2n个方程–&gt;最小二乘法。</li>
<li>最小二乘法
<ol>
<li>
<p>最小二乘法公式</p>
 <img src="/视觉_img/8_2.png" style = "zoom:80%"/>
</li>
<li>
<p>矩阵形式</p>
 <img src="/视觉_img/8_3.png" style = "zoom:80%"/>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p>对于仿射变化</p>
<ol>
<li>
<p>有6个未知数</p>
 <img src="/视觉_img/8_4.png" style = "zoom:80%"/>
</li>
</ol>
</li>
<li>
<p>对于同态映射（单应映射）</p>
<ol>
<li>有8个未知数，至少需要4个匹配对。</li>
</ol>
 <img src="/视觉_img/8_5.png" style = "zoom:80%"/>
 <img src="/视觉_img/8_6.png" style = "zoom:80%"/>
 <img src="/视觉_img/8_7.png" style = "zoom:80%"/>
</li>
<li>
<p>图像配准过程</p>
<ol>
<li>计算A和B的特征</li>
<li>匹配A和B之间的特征</li>
<li>使用匹配集计算A到B单应映射矩阵的最小二乘解。</li>
</ol>
</li>
<li>
<p>离群点（外点）</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计安导目录</title>
    <url>/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="物理安全"><a class="markdownIt-Anchor" href="#物理安全"></a> <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC2%E7%AB%A0/">物理安全</a></h2>
<h2 id="计算机系统安全"><a class="markdownIt-Anchor" href="#计算机系统安全"></a> <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC3%E7%AB%A0/">计算机系统安全</a></h2>
<h2 id="恶意软件"><a class="markdownIt-Anchor" href="#恶意软件"></a> <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC4%E7%AB%A0/">恶意软件</a></h2>
<h2 id="网络安全一"><a class="markdownIt-Anchor" href="#网络安全一"></a> <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC5%E7%AB%A0/">网络安全(一)</a></h2>
<h2 id="网络安全二"><a class="markdownIt-Anchor" href="#网络安全二"></a> <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC6%E7%AB%A0/">网络安全(二)</a></h2>
<h2 id="网络安全三"><a class="markdownIt-Anchor" href="#网络安全三"></a> <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC7%E7%AB%A0/">网络安全(三)</a></h2>
<h2 id="密码学基础"><a class="markdownIt-Anchor" href="#密码学基础"></a> <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC8%E7%AB%A0/">密码学基础</a></h2>
<h2 id="安全模型"><a class="markdownIt-Anchor" href="#安全模型"></a> <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC9%E7%AB%A0/">安全模型</a></h2>
<h2 id="数据库安全"><a class="markdownIt-Anchor" href="#数据库安全"></a> <a href="/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC10%E7%AB%A0/">数据库安全</a></h2>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉第9讲</title>
    <url>/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC9%E8%AE%B2/</url>
    <content><![CDATA[<h1 id="随机抽样一致"><a class="markdownIt-Anchor" href="#随机抽样一致"></a> 随机抽样一致</h1>
<p>针对最小二乘法出现的离群点问题</p>
<ol>
<li>思路
<ol>
<li>先求得一条候选直线</li>
<li>计算与该直线的内群点</li>
<li>对于所有候选直线，选择内群点最多的那一条。</li>
</ol>
</li>
<li>RANSAC算法
<ol>
<li>
<p>思想：所有的内点将在平移向量上达成一致；少部分离群点彼此矛盾。</p>
</li>
<li>
<p>RANSAC只能在离群点少于50%时才能保证正确解。</p>
</li>
<li>
<p>衡量内点：通过阈值过滤</p>
<p>阈值与噪声量有关，通常噪声建模为高斯噪声，标准差为3个像素。</p>
<p>通过设置阈值，使高斯分布中95%的比例位于半径内。</p>
</li>
<li>
<p>算法完整过程</p>
<ol>
<li>
<p>随机选择s个样本点</p>
<p>通常s=可求解模型的最少样本点数</p>
</li>
<li>
<p>根据样本得到一个解</p>
</li>
<li>
<p>计算内点数</p>
</li>
<li>
<p>重复N次</p>
</li>
<li>
<p>选择具有最多内点的模型。</p>
</li>
<li>
<p>计算所有内点的平均平移向量。</p>
</li>
</ol>
</li>
<li>
<p>实验轮数</p>
 <img src="/视觉_img/9_1.png " style="zoom:80%">
<p>其中p为内点概率；s是每次实验使用的样本点数目；P为能最终找到正确解的概率；R为实验轮次</p>
</li>
<li>
<p>s的取值<br />
为自由度/2下取整</p>
 <img src="/视觉_img/9_2.png " style="zoom:80%">
</li>
<li>
<p>优点</p>
<ol>
<li>简单，通用</li>
<li>适用于许多不同的问题</li>
<li>实践中表现良好，通常比蛮力取样要好</li>
</ol>
</li>
<li>
<p>缺点：</p>
<ol>
<li>需要调整参数</li>
<li>有时需要大量迭代，耗费时间</li>
<li>内点概率极低时可能失败</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计安导第10章</title>
    <url>/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC10%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="数据库安全"><a class="markdownIt-Anchor" href="#数据库安全"></a> 数据库安全</h1>
<h2 id="两阶段协议实现完整性和可用性"><a class="markdownIt-Anchor" href="#两阶段协议实现完整性和可用性"></a> 两阶段协议–实现完整性和可用性</h2>
<ol>
<li>第一阶段是请求阶段：
<ol>
<li>该阶段，确定所要修改的部分，并标记。</li>
<li>结果是成功或终止。在成功时，每个修改请求都是可 用的，标记被修改；在中止时，由于别人早已对其进行了标记，或者 由于网络或系统出现了故障，所以不能标记所有需要修改的部分。</li>
<li>如果第一阶段被中止，则重置所有修改的请求，这样做是完全可行 的，因为并未进行任何永久性的修改。如果第一阶段成功完成，则协议继续第二个阶段。</li>
</ol>
</li>
<li>第二阶段是提交阶段
<ol>
<li>在这个阶段，对于其他 修改而言，数据库是锁定的，只执行在请求阶段确定的修改序列。</li>
<li>如果更新成功完成，则清除所有确定请求修改的标志，并释放对数据库的锁定。</li>
<li>如果更新操作失败，则回滚，使数据库回到完成第一 阶段后的状态。</li>
</ol>
</li>
</ol>
<h2 id="数据库访问控制"><a class="markdownIt-Anchor" href="#数据库访问控制"></a> 数据库访问控制</h2>
<ol>
<li>
<p><strong>最小特权原则</strong>：实现适当的访问控制应遵 循最小特权原则，使每个用户都拥有完成自己任务所必需的权限，但 除此之外，不再拥有其他的权限</p>
</li>
<li>
<p><strong>特权分离原则</strong>：实现适当的访问控 制还应遵循特权分离原则，以便不同的用户具有不同的权限，这取决 于他们需要执行的不同任务</p>
</li>
<li>
<p>数据库允许SQL实现权限委托</p>
</li>
<li>
<p>权限委托：除了能向其他用户授予具体的权限外，表的所有者还允许其他用户来授予 这些表的权限，这称为策略授权委托</p>
</li>
<li>
<p>权限撤销：级联撤销</p>
</li>
</ol>
<h2 id="敏感信息"><a class="markdownIt-Anchor" href="#敏感信息"></a> 敏感信息</h2>
<p>1.要保护用户因素，满足机密性要求<br />
2. 方法：使用加密，存储密文。授权用户直到解密密钥，但不能将解密密钥存储在数据库中。<br />
3. 隐私保护：如果数据库是公开的，比如说是出于研究的目的，则应删除姓名、地址、 社会安全码、员工人数和学生人数等身份信息，或改用掩码值 ，从而不提供任何身份信息。</p>
<h2 id="推理攻击"><a class="markdownIt-Anchor" href="#推理攻击"></a> 推理攻击</h2>
<ol>
<li>
<p>推理攻击：即使删除或屏蔽掉身份信息，攻击者仍能将其他的信息与数据库结合，得到底层的数据。</p>
</li>
<li>
<p>推理攻击的防御：</p>
<ol>
<li>单元抑制：在使用这种技术时，会删除数据库 中的一些单元，在公开版本中只留下空白。</li>
<li>推广：在使用这种技术时，公开数据库中的一些 值被更常用的值所替代。</li>
<li>加噪：在使用这种技术时，在公开数据库中添加 了随机值，使具有相同属性的所有记录的平均噪声为零。</li>
</ol>
 <img src="/计安导_img/27.png">
</li>
</ol>
<h1 id="垃圾邮件和网络犯罪"><a class="markdownIt-Anchor" href="#垃圾邮件和网络犯罪"></a> 垃圾邮件和网络犯罪</h1>
<h2 id="smtp"><a class="markdownIt-Anchor" href="#smtp"></a> SMTP</h2>
<ol>
<li>使用25端口建立TCP连接</li>
<li>客户端向服务器发送命令，服务器确认或通知错误</li>
<li><strong>问题</strong>
<ol>
<li>发件人未经过身份验证</li>
<li>消息和消息头使用明文传输</li>
<li>消息和消息头完整性没有得到保护</li>
</ol>
</li>
</ol>
<h2 id="垃圾邮件"><a class="markdownIt-Anchor" href="#垃圾邮件"></a> 垃圾邮件</h2>
<ol>
<li>垃圾邮件：不清自来的批量电子邮件</li>
</ol>
<h2 id="黑名单"><a class="markdownIt-Anchor" href="#黑名单"></a> 黑名单</h2>
<img src="/计安导_img/28.png">
<h2 id="灰名单"><a class="markdownIt-Anchor" href="#灰名单"></a> 灰名单</h2>
<ol>
<li>灰名单：是一种垃圾邮件过滤技术，接收邮件服务器拒绝来自未知发 件人的邮件。当接收来自未知发件人的邮件时，接收服务器会发送一 个“临时拒绝”消息给发送方，并记录相应的信息。</li>
<li>维护一个可信发件服务器的数据库</li>
<li>简单易行高效</li>
</ol>
<h2 id="发件人id和发件人策略框架"><a class="markdownIt-Anchor" href="#发件人id和发件人策略框架"></a> 发件人ID和发件人策略框架</h2>
<ol>
<li>发件人策略框架(SPF)可对发件人的发送邮 件代理进行身份验证，其中不使用加密 技术。接收方MTA会检查发送方MTA的IP是否在发件人域的授权IP 地址列表中。</li>
</ol>
<h2 id="发件人的mta身份验证dkim"><a class="markdownIt-Anchor" href="#发件人的mta身份验证dkim"></a> 发件人的MTA身份验证：DKIM</h2>
<ol>
<li>域密钥标识邮件DKIM：是一种用于验证发送邮件传输代理的方法</li>
<li>签名实体(通常是发件人的MTA) 向消息中增加签名， 表明消息的签名实体所在的域</li>
<li>公钥存储在DNS的文本记录中</li>
</ol>
<h2 id="spf-vs-dkim"><a class="markdownIt-Anchor" href="#spf-vs-dkim"></a> SPF vs DKIM</h2>
<img src="/计安导_img/29.png">
<h2 id="网络犯罪"><a class="markdownIt-Anchor" href="#网络犯罪"></a> 网络犯罪</h2>
<ol>
<li>网络犯罪：是使用计算机、网络或硬件设备犯下的任何罪行。 计算机或 设备可以是犯罪的代理人，犯罪的促进者或犯罪的目标。 犯罪可以 单独在计算机上进行，也可以在其他地方进行</li>
</ol>
<h2 id="信用卡"><a class="markdownIt-Anchor" href="#信用卡"></a> 信用卡</h2>
<ol>
<li>
<p>特点</p>
<ol>
<li>支持保密</li>
<li>可与多个商家共享</li>
<li>经常被不安全的传送</li>
<li>熵值较低</li>
</ol>
</li>
<li>
<p>优点：简单易行</p>
</li>
<li>
<p>缺点：易发生欺诈</p>
</li>
<li>
<p>防范：</p>
<ol>
<li>一次性信用卡号码</li>
<li>监控交易</li>
<li>交易时启动密码输入</li>
</ol>
</li>
</ol>
<h2 id="常见银行欺诈"><a class="markdownIt-Anchor" href="#常见银行欺诈"></a> 常见银行欺诈</h2>
<ol>
<li>伪造支票</li>
<li>电子汇款</li>
<li>创建恶意账户</li>
<li>多重身份认证</li>
<li>账户所有权验证</li>
<li>账户限制</li>
<li>监控银行交易</li>
<li>取消网银</li>
</ol>
<h1 id="支付系统"><a class="markdownIt-Anchor" href="#支付系统"></a> 支付系统</h1>
<h2 id="电子支付方案"><a class="markdownIt-Anchor" href="#电子支付方案"></a> 电子支付方案</h2>
<ol>
<li>是一种多方协议</li>
<li>目标：
<ol>
<li>完整性：电子货币不能伪造或复制；合法交易能够兑现</li>
<li>问责制：交易后不可否认</li>
<li>隐私</li>
</ol>
</li>
</ol>
<h2 id="私密支付方案"><a class="markdownIt-Anchor" href="#私密支付方案"></a> 私密支付方案</h2>
<h3 id="盲签名"><a class="markdownIt-Anchor" href="#盲签名"></a> 盲签名</h3>
<ol>
<li>
<p>允许签名者在不知道消息本身的情况下对消息进行签名</p>
</li>
<li>
<p>基本过程</p>
<ol>
<li>银行对客户提取的货币进行盲签名</li>
<li>商家验证签名并存入货币</li>
<li>银行无法将货币与客户关联起来</li>
</ol>
</li>
<li>
<p>RSA 盲签名</p>
 <img src="/计安导_img/30.png">
 <img src="/计安导_img/31.png">
</li>
<li>
<p>对钱币进行盲签名</p>
 <img src="/计安导_img/32.png">
</li>
</ol>
<h2 id="防止双重支付"><a class="markdownIt-Anchor" href="#防止双重支付"></a> 防止双重支付</h2>
<ol>
<li>联机系统：在支付过程中，银行保持在线，实时撤销已使用的钱币</li>
<li>离线系统：
<ol>
<li>每个提款的钱币都包含客户身份的加密信息</li>
<li>每个存款的钱币都包含商家身份的加密信息</li>
<li>双重支付将导致欺骗者的身份被披露出来</li>
</ol>
</li>
</ol>
<h2 id="秘密分享"><a class="markdownIt-Anchor" href="#秘密分享"></a> 秘密分享</h2>
<p>步骤</p>
<ol>
<li>一个秘密字符串 x 可以被划分为以下的随机值 y 和 z。选择一个随机数 y ；z = y⊕x</li>
<li>通过x = y⊕z重构字符串x</li>
<li>其中y和z都是随机值，成为x的秘密份额，任一秘密份额都不会揭示关于秘密值 x 的任何信息</li>
</ol>
<h2 id="钱币保护匿名性"><a class="markdownIt-Anchor" href="#钱币保护匿名性"></a> 钱币–保护匿名性</h2>
<ol>
<li>给定一个秘密值x和关于x的承诺(a,b)</li>
<li>a=h(y) b=h(z) y,z是x的秘密份额</li>
</ol>
<h2 id="取款"><a class="markdownIt-Anchor" href="#取款"></a> 取款</h2>
<ol>
<li>客户生成并向银行提交 k 个钱币</li>
<li>银行随机选择 k-1 枚钱币</li>
<li>银行要求客户向其披露所选定的 k-1 个钱币的承诺的秘密份额</li>
<li>银行在剩余的硬币上创建一个盲签名</li>
<li>银行签名的钱币是有效的概率是 1 - 1/k</li>
</ol>
<h2 id="支付"><a class="markdownIt-Anchor" href="#支付"></a> 支付</h2>
<ol>
<li>
<p>客户向商家提交钱币 {x, [(a1, b2) , … , (an, bn)]}</p>
</li>
<li>
<p>商家验证钱币上的签名</p>
</li>
<li>
<p>商家发送给客户一个随机的二进制向量 s1, … , sn, 称为选择器。</p>
</li>
<li>
<p>客户向商家揭示由选择器所选定的秘密份额，即客户向商家发送 一组字符串 P1, … , Pn</p>
<p>h(Pi) = ai if si = 0</p>
<p>h(Pi) = bi if si= 1</p>
</li>
</ol>
<h2 id="存款及其安全性分析"><a class="markdownIt-Anchor" href="#存款及其安全性分析"></a> 存款及其安全性分析</h2>
<ol>
<li>
<p>存款</p>
<ol>
<li>商人将钱币和字符串 P1, … , Pn提交给银行进行存款</li>
<li>银行验证签名并且记录钱币和相应字符串的对应关系</li>
</ol>
</li>
<li>
<p>安全性分析</p>
<ol>
<li>两个商家提供的选择器相同的概率是 1/2<sup>n</sup></li>
<li>因此，如果客户将1个钱币进行双重支付，那么银行发现该客户 身份的概率为 1/2<sup>n</sup></li>
<li>客户想要在不被银行发现的情况进行双重支付的唯一办法是找到 一个Hash函数的碰撞。</li>
</ol>
</li>
</ol>
<h1 id="数字版权管理"><a class="markdownIt-Anchor" href="#数字版权管理"></a> 数字版权管理</h1>
<ol>
<li>数字版权管理：是指能限制用户 使用数字内容的做法，常用于数字媒体，如DVD、下载的音乐和 许可的软件</li>
</ol>
<h2 id="复制保护方法"><a class="markdownIt-Anchor" href="#复制保护方法"></a> 复制保护方法</h2>
<ol>
<li>加密狗</li>
<li>产品密钥</li>
<li>手机激活</li>
</ol>
<h2 id="用于媒体文件的drm方案"><a class="markdownIt-Anchor" href="#用于媒体文件的drm方案"></a> 用于媒体文件的DRM方案</h2>
<p>步骤</p>
<ol>
<li>媒体服务器向播放器发送用文件密钥加密的媒体文件和用播放器密钥加密的文件密钥</li>
<li>播放器先用播放器密 钥解密文件密钥，然 后使用文件密钥解密 媒体文件</li>
</ol>
<h2 id="叛徒识别"><a class="markdownIt-Anchor" href="#叛徒识别"></a> 叛徒识别</h2>
<p><img src="/%E8%AE%A1%E5%AE%89%E5%AF%BC_img/33.png" alt="" /></p>
<h2 id="逻辑密钥对"><a class="markdownIt-Anchor" href="#逻辑密钥对"></a> 逻辑密钥对</h2>
<p><img src="/%E8%AE%A1%E5%AE%89%E5%AF%BC_img/34.png" alt="" /></p>
<ol>
<li>是平衡二叉树，树的每个节点都与一个对称加密密钥相关联</li>
<li>将设备与叶子节点关联，每个设备上存储着从叶子到根路径上的所有密钥</li>
<li>用节点 v 的密钥加密的内容可以被 v 的子树中的所有设备解密</li>
<li>撤销设备：如果设备需要被撤销，则必须更改此设备已知的密钥，并分发新的密钥。新密钥的分发可以通过广播对数级数量的加密消息来完成</li>
</ol>
<h2 id="加密广播"><a class="markdownIt-Anchor" href="#加密广播"></a> 加密广播</h2>
<ol>
<li>广播之前，每个内容都用单一的对称密钥进行加密。被授权产看内容项的订阅者应该拥有解密该项的密钥</li>
<li>每个节点的密钥可以被用来计算子孙节点的密钥</li>
<li>存在密钥分配问题</li>
</ol>
<h2 id="可信设备"><a class="markdownIt-Anchor" href="#可信设备"></a> 可信设备</h2>
<ol>
<li>由可信制造商加工，被分配一个保密的播放器密钥</li>
</ol>
<h2 id="内容扰乱系统css"><a class="markdownIt-Anchor" href="#内容扰乱系统css"></a> 内容扰乱系统CSS</h2>
<p><img src="/%E8%AE%A1%E5%AE%89%E5%AF%BC_img/35.png" alt="" /></p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计安导第2章</title>
    <url>/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC2%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="物理保护与攻击"><a class="markdownIt-Anchor" href="#物理保护与攻击"></a> 物理保护与攻击</h1>
<h2 id="物理安全"><a class="markdownIt-Anchor" href="#物理安全"></a> 物理安全</h2>
<ol>
<li>物理安全：泛指保护贵重物品、信息或访问受限资源 所使用的物理措施，物理安全直接影响完整性、计算 机硬件和数字信息保护。包括
<ol>
<li>位置保护</li>
<li>物理入侵检测</li>
<li>硬件攻击</li>
<li>窃听</li>
<li>物理接口攻击</li>
</ol>
</li>
</ol>
<h2 id="钥匙与锁"><a class="markdownIt-Anchor" href="#钥匙与锁"></a> 钥匙与锁</h2>
<ol>
<li>包括TSA锁，凸块锁，万能钥匙，弹子锁</li>
<li>非破坏性开锁：选取，旁路</li>
<li>40种不同的钥匙坯，7个顶部锁鞘，8个不同高度的底部锁鞘，则可能的钥匙数量是40*8<sup>7</sup></li>
</ol>
<h2 id="特权升级"><a class="markdownIt-Anchor" href="#特权升级"></a> 特权升级</h2>
<p>攻击者将地权限的密钥提升为高权限的密钥</p>
<h2 id="指纹锁相关问题"><a class="markdownIt-Anchor" href="#指纹锁相关问题"></a> 指纹锁相关问题</h2>
<ol>
<li>识别率不够高</li>
<li>电池寿命问题</li>
<li>指纹锁的稳定性不高</li>
</ol>
<h2 id="测信道攻击"><a class="markdownIt-Anchor" href="#测信道攻击"></a> 测信道攻击</h2>
<p>攻击者不是试图直接绕过 安全措施，而是通过利用 其他不受安全机制保护的 漏洞绕过安全措施</p>
<h1 id="身份认证技术"><a class="markdownIt-Anchor" href="#身份认证技术"></a> 身份认证技术</h1>
<ol>
<li>包括条形码，二维码，磁条卡，智能卡，SIM卡,RFID</li>
</ol>
<h2 id="磁条卡安全"><a class="markdownIt-Anchor" href="#磁条卡安全"></a> 磁条卡安全</h2>
<ol>
<li>问题：易于读取和复制。词条阅读器成本相对较低</li>
<li>解决：要求输入PIN</li>
</ol>
<h2 id="智能卡安全"><a class="markdownIt-Anchor" href="#智能卡安全"></a> 智能卡安全</h2>
<ol>
<li>可以提供保护所有者信息的安全认证机制，并且极难复制</li>
<li>使用加密技术加强认证的手段</li>
</ol>
<h2 id="sim卡安全"><a class="markdownIt-Anchor" href="#sim卡安全"></a> SIM卡安全</h2>
<ol>
<li>SIM卡：用于识别所有者并对相应的蜂窝网络进行身份验证</li>
<li>18位，用于硬件识别</li>
<li>128位密钥</li>
</ol>
<h2 id="gsm挑战-相应协议"><a class="markdownIt-Anchor" href="#gsm挑战-相应协议"></a> GSM挑战-相应协议</h2>
<p><img src="/%E8%AE%A1%E5%AE%89%E5%AF%BC_img/36.png" alt="" /></p>
<ol>
<li>当手机希望加入蜂窝网络时，它连接并发送其IMSI到网络提供商拥有的 本地基站。</li>
<li>如果IMSI匹配网络提供商的数据库中的用户记录正确，则基站将128位 随机数发送到蜂窝电话。</li>
<li>然后，该随机数由蜂窝电话编码存储在SIM卡中，用户的密钥使用A3的 专有加密算法，从而产生发送回基站的密文</li>
<li>然后，基站使用其存储的用于用户密钥的值来执行相同的计算。 如果两 个密文匹配，则手机被认证到网络并被允许拨打和接听电话。</li>
</ol>
<h2 id="rfid"><a class="markdownIt-Anchor" href="#rfid"></a> RFID</h2>
<ol>
<li>必须与单独的读取器或写入器一起使用</li>
<li>所有RFID都使用密钥加密</li>
</ol>
<h2 id="生物识别技术"><a class="markdownIt-Anchor" href="#生物识别技术"></a> 生物识别技术</h2>
<ol>
<li>
<p>生物特征：指用于基于生物或生理特 征唯一识别信息进行的任何身份度 量。</p>
</li>
<li>
<p>生物识别的要求</p>
<ol>
<li>普遍性</li>
<li>独特性</li>
<li>持久性</li>
<li>可回收性：该特征应具有有效确定和量化的能力</li>
</ol>
</li>
<li>
<p>如指纹，虹膜，步态</p>
</li>
</ol>
<h1 id="针对计算设备的攻击"><a class="markdownIt-Anchor" href="#针对计算设备的攻击"></a> 针对计算设备的攻击</h1>
<h2 id="环境攻击"><a class="markdownIt-Anchor" href="#环境攻击"></a> 环境攻击</h2>
<ol>
<li>电力，温度，有限的传导</li>
</ol>
<h2 id="窃听"><a class="markdownIt-Anchor" href="#窃听"></a> 窃听</h2>
<p>搭线窃听同轴电缆的电脉冲</p>
<h2 id="信号发射"><a class="markdownIt-Anchor" href="#信号发射"></a> 信号发射</h2>
<p>通过计算机屏幕发出的射频信号来检测正在显示的内容</p>
<h2 id="键盘记录"><a class="markdownIt-Anchor" href="#键盘记录"></a> 键盘记录</h2>
<h2 id="防御"><a class="markdownIt-Anchor" href="#防御"></a> 防御</h2>
<ol>
<li>三级：1米；20米，100米</li>
<li>放射阻隔(阻隔光,音)</li>
<li>法拉第笼：阻挡电磁辐射</li>
</ol>
<h1 id="计算机取证"><a class="markdownIt-Anchor" href="#计算机取证"></a> 计算机取证</h1>
<p>计算机取证是一种获取包含在电子媒介上的信息的方 法，如计算机系统、硬盘和光盘，通常用于收集用于 法律诉讼的证据</p>
<h2 id="过程"><a class="markdownIt-Anchor" href="#过程"></a> 过程</h2>
<ol>
<li>鉴定</li>
<li>收集：注意不要修改数据</li>
<li>分析和评估</li>
<li>报告</li>
</ol>
<h2 id="取证约束"><a class="markdownIt-Anchor" href="#取证约束"></a> 取证约束</h2>
<ol>
<li>监管链</li>
<li>优先级RAM &gt; swap &gt; disk &gt; CDs/DVDs。第一时间捕获更易失的</li>
<li>犯罪现场的计算机应该被视为完全敌对的</li>
</ol>
<h2 id="隐藏数据的方法"><a class="markdownIt-Anchor" href="#隐藏数据的方法"></a> 隐藏数据的方法</h2>
<ol>
<li>密码学</li>
<li>隐写术</li>
<li>更改文件名或者扩展名</li>
<li>隐藏分区</li>
<li>删除文件</li>
</ol>
<h2 id="反取证技术"><a class="markdownIt-Anchor" href="#反取证技术"></a> 反取证技术</h2>
<ol>
<li>反取证技术试图阻止调查员及其取证技术</li>
<li>安全删除数据，以便无法使用取证方法进行恢复</li>
<li>首先防止创建某些数据</li>
<li>从未出现的数据显然无法通过取证方法恢复。</li>
</ol>
<h2 id="磁盘擦出"><a class="markdownIt-Anchor" href="#磁盘擦出"></a> 磁盘擦出</h2>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计安导第3章</title>
    <url>/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC3%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="计算机系统"><a class="markdownIt-Anchor" href="#计算机系统"></a> 计算机系统</h1>
<ol>
<li>包括计算机硬件系统和计算机软件系统。
<ol>
<li>硬件系统包括：运算器，控制器，存储器，输入设备，输出设备。</li>
<li>软件系统：操作系统</li>
</ol>
</li>
<li>操作系统：提供计算机用户和该计算机硬件之间的接口，管理应用程序访问计算机资源的方式。
<ol>
<li>内核：操作系统的核心组件，处理对底层硬件资源的管理。</li>
</ol>
</li>
<li>系统调用：是一种机制，通过这种机制，应用程序可以委托内核来执行与硬件相关的操作。</li>
</ol>
<h1 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程：</h1>
<ol>
<li>进程进程是正在执行的程序的一个实例。</li>
<li>进程树：新的进程由其父进程产生，构成一颗进程树。树的根是init进程，在加载和运行内核后开始执行，并创建登陆会话和系统任务等其他子进程。</li>
<li>进程ID：每个进程都通过唯一的非负整数进行标识。</li>
<li>进程间通信
<ol>
<li>读写文件进行方式
<ol>
<li>通过硬盘，速度较慢。</li>
<li>不便于进行私密通信。</li>
</ol>
</li>
<li>共享内存方式
<ol>
<li>只有内核能管理共享内存区。</li>
</ol>
</li>
<li>管道和套接字：提供进程与进程间通信的通道，通信双方共享管道和套接字。</li>
<li>信号量机制</li>
</ol>
</li>
<li>远程过程调用RPC：允许一个进程调用另一个进程中的子例程。</li>
<li>守护进程和服务
<ol>
<li>守护进程（后台进程）（Windows下称为服务）：运行权限高于任何用户，并在登陆会话结束前就一直存在。如Web服务器，远程登陆等</li>
</ol>
</li>
</ol>
<h1 id="文件系统"><a class="markdownIt-Anchor" href="#文件系统"></a> 文件系统</h1>
<ol>
<li>
<p>文件系统是如何组织计算机的外部、非易失性存储的一种抽象。</p>
</li>
<li>
<p>文件权限</p>
<p>关键在于界定哪些用户可以访问哪些资源。</p>
</li>
<li>
<p>Unix文件权限</p>
<ol>
<li>包括三类用户：
<ol>
<li>owner类</li>
<li>group类：决定了相同组中的用户的文件权限。</li>
<li>others类</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="内存管理"><a class="markdownIt-Anchor" href="#内存管理"></a> 内存管理</h1>
<ol>
<li>内存管理是指如何组织和分配计算机的内存。</li>
<li>进程的地址空间
<ol>
<li>代码段</li>
<li>数据段</li>
<li>BSS：符号起始区块，包含未初始化的静态变量。</li>
<li>堆：动态段，存储运行时产生的数据。</li>
<li>栈：记录函数调用和他们的参数。</li>
</ol>
</li>
<li>内存访问权限
<ol>
<li>五段都有各自的访问权限。通常代码段只读，其他段可以写入</li>
<li><strong>不允许进程访问其他进程的地址空间</strong></li>
</ol>
</li>
<li>虚拟内存
<ol>
<li>每个进程都有一个虚拟地址空间，虚拟内存系统将每个虚拟地址映射为实际内存地址。</li>
<li>由MMU来进行地址转换。</li>
<li>在进程看来，它的虚拟地址空间是连续的，但是实际内存却未必。</li>
<li>优点：允许进程的地址空间大于内存。</li>
<li>缺点：访问硬盘速度慢。</li>
<li><strong>问题</strong>：不正常关机的时候，虚拟页面可能未被删除。攻击者可以通过外部介质引导另一个操作系统，查看并重建部分内存，导致信息泄漏。</li>
<li><strong>解决</strong>：对硬盘内容进行加密。</li>
</ol>
</li>
<li>缺页</li>
<li>虚拟机
<ol>
<li>不直接接触底层硬件就允许操作系统的运行。</li>
<li>在虚拟机中运行的操作系统称为客户机，本地的操作系统称为主机。</li>
<li>虚拟机的实现：
<ol>
<li>模拟：主机系统翻译接口的通信，传给硬件。其优点是增加了硬件的灵活性，缺点是使性能下降。</li>
<li>虚拟化：失去硬件灵活性，但是性能提升了。</li>
</ol>
</li>
<li>虚拟机的优点
<ol>
<li>提高了硬件效率：在一台机器上托管多个操作系统。</li>
<li>可移植性</li>
<li>安全：沙箱</li>
<li>便于管理</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="进程安全"><a class="markdownIt-Anchor" href="#进程安全"></a> 进程安全</h1>
<h2 id="引导顺序及安全"><a class="markdownIt-Anchor" href="#引导顺序及安全"></a> 引导顺序及安全</h2>
<ol>
<li>引导：从关机状态到将操作系统加载到内存。</li>
<li>加载分两阶段：首先加载BIOS固件中的代码，然后这程序会假爱国操作系统其余部分加载到内存，然后将控制权交给操作系统。</li>
<li><strong>问题</strong>：恶意用户可以利用引导过程的一些脆弱点来控制计算机的执行。</li>
<li><strong>解决</strong>：设置BIOS密码。</li>
</ol>
<h2 id="引导设备的层次"><a class="markdownIt-Anchor" href="#引导设备的层次"></a> 引导设备的层次</h2>
<ol>
<li>第二阶段引导程序允许用户指定使用哪个设备来加载操作系统。</li>
<li><strong>问题</strong>：攻击者可以绕过运行的计算机上的安全机制，从外部介质引导其他操作系统。</li>
<li><strong>解决</strong>：对第二阶段引导程序启动密码保护。</li>
</ol>
<h2 id="休眠"><a class="markdownIt-Anchor" href="#休眠"></a> 休眠</h2>
<ol>
<li>休眠：电源关闭的状态。当进入休眠时，操作系统将计算机内存的全部内容存储到硬盘中的休眠文件中；系统通电后，再迅速恢复计算机状态。</li>
<li><strong>问题</strong>：
<ol>
<li>攻击者可以从休眠文件中获取一些敏感信息。Windows的休眠文件目录C:/hiberfil.sys</li>
<li>攻击者可以修改休眠文件，改变计算机上执行的程序。</li>
<li>即使计算机重启后，也不会删除休眠文件。</li>
</ol>
</li>
<li><strong>解决</strong>：使用硬盘加密来保护休眠文件。</li>
</ol>
<h2 id="监控-管理和日志"><a class="markdownIt-Anchor" href="#监控-管理和日志"></a> 监控、管理和日志</h2>
<p>操作系统可以根据留下的线索解决常见的问题，还能确定出现安全漏洞的原因。</p>
<ol>
<li>事件日志：
<ol>
<li>由操作系统进行管理</li>
<li>Windows中定义了三种日记 源：系统、应用程序和安全。其中系统日志只有操作系统才能写入；应用程序日志只由应用程序写入；安全日志由操作系统提供的本地安全授予子系统服务才能写入。</li>
</ol>
</li>
<li>进程监控：查看正在运行的进程</li>
<li>进程查看器：提供进程监控和管理的大量信息。
<ol>
<li>提高进程的映像，即运行进程的代码所在的磁盘位置。</li>
<li><strong>问题</strong>：攻击者可以通过替换合法程序的映像来掩饰自身。</li>
<li><strong>解决</strong>：可以对映像使用数字签名来保证磁盘上存储的应用程序不被替换。</li>
</ol>
</li>
</ol>
<h1 id="基于密码的身份认证"><a class="markdownIt-Anchor" href="#基于密码的身份认证"></a> 基于密码的身份认证</h1>
<ol>
<li>密码盐—反字典攻击：是一种加密技术，使用随机位作为散列函数的输入或加密算法的部分输入，从而增加随机性。<br />
(U,S,h(S||P))其中S为U的盐，h是散列函数。</li>
<li>加盐的原理：增大字典攻击的搜索空间。2<sup>B×D，其中B是随机数位数，D是字典攻击单词列表。</li>
</ol>
<h1 id="访问控制"><a class="markdownIt-Anchor" href="#访问控制"></a> 访问控制</h1>
<h2 id="linux的权限"><a class="markdownIt-Anchor" href="#linux的权限"></a> Linux的权限</h2>
<ol>
<li>使用文件权限矩阵</li>
<li>对于未明确授权的都默认拒绝</li>
<li>为了访问文件，在文件系统树中的每个祖先文件夹都必须有执行权限。</li>
<li>文件所有者具有自主访问控制权，可以修改文件权限。</li>
<li>可以使用chattr设置权限，lsattr查看。</li>
<li>目前开始支持ACL方案</li>
<li>对owner, group和other主体，每个文件都有基本的ACE(<strong>访问控制项</strong>)；对于命名用户和命名组可创建额外的ACE；还有掩码ACE,即规定主体允许的最大权限</li>
</ol>
<h2 id="linux的acl权限方案"><a class="markdownIt-Anchor" href="#linux的acl权限方案"></a> Linux的ACL权限方案</h2>
<ol>
<li>设U是进程的euid，具有一定的请求权限，视图访问文件或文件夹</li>
<li>为确定是否授权，操作系统将进行匹配：
<ol>
<li>U是文件所有者的ID</li>
<li>U是命名组之一</li>
<li>U的一个组是所有组，该组的ACE包含请求权限。</li>
<li>U的一个组是命名组，该组的ACE包含请求权限。</li>
<li>对于U所在的每个组，该组的ACE都不包含请求权限。</li>
<li>检查other的ACE</li>
</ol>
</li>
</ol>
<h2 id="windows权限基础"><a class="markdownIt-Anchor" href="#windows权限基础"></a> Windows权限基础</h2>
<ol>
<li>Windows使用访问控制列表，允许用户创建访问控制规则。</li>
<li>默认是拒绝</li>
<li>标准权限包裹：读、写、修改、读和执行、完全控制。</li>
<li>读相关的高级属性：读取数据、读取属性、读取扩展属性和读取权限。</li>
<li>文件夹权限包括
<ol>
<li>读权限：可以列出文件夹内容。</li>
<li>写权限：允许用户创建新文件夹。</li>
<li>Windows下可以禁止用户访问文件夹，但允许用户访问该文件夹下的特定文件。</li>
</ol>
</li>
<li>ACE
<ol>
<li>继承ACE：文件夹的任何ACE可用于该文件夹内的子文件夹和文件。</li>
<li>显式ACE：针对文件或者文件夹专门设置的ACE。</li>
<li>ACE优先级：拒绝ACE&gt;允许ACE、显示ACE&gt;继承ACE、继承ACE优先级 由祖先与对象之间的距离决定，越近优先级越高。</li>
</ol>
</li>
</ol>
<h2 id="windows文件权限"><a class="markdownIt-Anchor" href="#windows文件权限"></a> Windows文件权限</h2>
<ol>
<li>
<p>SetUID操作：程序由普通用户运行，但期望允许程序改变普通用户无法改变的文件。</p>
<p>例如：在早期UNIX系统中，用户登录信息存储在/etc/passwd中。普通用户 不能编辑这个文件，但允许该用户更改自己的密码是合理的要求</p>
<ol>
<li>设置了setuid位，使得程序以其所有者的有效ID来运行，而不是以正在执行程序的进程ID。</li>
<li><strong>问题</strong>
<ol>
<li>攻击者可以强制setuid程序执行任意代码，如缓冲区溢出攻击。</li>
<li>权限升级：攻击者可以通过setuid机制来运用程序的所有者权限。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>文件描述符：存储在文件描述符表中的索引值，用来索引特定文件</p>
<ol>
<li>当程序需要访问文件时，访问open系统调用，该调用使内核创建一个文件 描述符表中的新项并将其返回给程序，该项映射到文件的磁盘位置。程序可以使用文件描述符发送读或者写命令。内核在接到读、写系统调用时， 在文件描述符表中查找相关的表项，并在磁盘适当位置执行读、写操作。完成操作后，要用close系统调用删除打开的文件描述符。</li>
<li><strong>漏洞</strong> 当进程创建子进程时，子进程会集成父进程打开的所有文 件描述符副本。当程序以高权限打开文件描述符，但未关闭，然后又创建了 低权限的进程，那么新进程就能够读写相关文件，但子进程本身不具有打开 该文件的权限。</li>
<li><strong>原因</strong> 在创建文件描述符项的时刻，操作 系统只检查进程是否具有读写权限；在实际读写文件操作时，只根据文件描 述符被打开时的权限来确认是否允许请求的操作。</li>
</ol>
</li>
<li>
<p>符号链接与快捷方式</p>
<ol>
<li><strong>问题</strong> 攻击者可以利用符号链接来诱使应用程序执行不良操作。</li>
<li><strong>解决</strong> 程序检查文件名是否指向符号链接，以确定打开的实际文件名。</li>
<li>Windows的快捷方式&amp;Linux的符号链接：符号链接由操作系统处 理，使用透明；而快捷方式是普通文件。</li>
</ol>
</li>
</ol>
<h1 id="应用程序安全"><a class="markdownIt-Anchor" href="#应用程序安全"></a> 应用程序安全</h1>
<h2 id="编译和链接"><a class="markdownIt-Anchor" href="#编译和链接"></a> 编译和链接</h2>
<ol>
<li>编译：将源代码转换为处理器能够执行的机器代码的过程</li>
<li>静态链接：程序执行时所需的共享库需要复制到编译程序中。一般比较安全， 但重复代码会占用额外的空间。</li>
<li>动态链接：程序真正运行时，才会加载共享库。加载程序确定待运行程序需 要哪些共享库，然后在磁盘上找到这些库，并将它们导入进程的地址空间。
<ol>
<li><strong>DDL注入</strong>：通过共享库向程序注入任意代码的过程。<strong>优点</strong> 是便于调试，<strong>缺点</strong> 是潜在的安全风险，恶意用户能向合法程序注入自己的代码。</li>
</ol>
</li>
</ol>
<h2 id="简单的缓冲区溢出攻击"><a class="markdownIt-Anchor" href="#简单的缓冲区溢出攻击"></a> 简单的缓冲区溢出攻击</h2>
<ol>
<li>缓冲区：进程为程序在内存中分配固定大小的存储空间。</li>
<li>缓冲区溢出：如果不进行边界检查，攻击者提供的输入数据可能会超出缓冲 区的大小。此时，内存缓冲区之外的数据可能会被覆盖。</li>
<li><strong>问题</strong> 攻击者利用缓冲区溢出获得进程的控制权，执行任意恶意代码。</li>
</ol>
<h2 id="基于栈的缓冲区溢出"><a class="markdownIt-Anchor" href="#基于栈的缓冲区溢出"></a> 基于栈的缓冲区溢出</h2>
<ol>
<li>进程地址空间中栈由帧组成，每一帧存储局部变量、调用参数和返回地址。</li>
<li><strong>问题</strong> 如果攻击者提供的输入大于调用函数中缓冲区的大小，会导致溢出，从而导致栈缓冲区之外 的内存空间被覆盖。</li>
<li>缓冲区溢出攻击：当缓冲区是局部变量 或帧的参数时，用户的输入 可能覆盖返回地址，改变程 序的执行。
<ol>
<li><strong>问题</strong> 攻击者利用栈缓冲区的脆弱 性，在栈中注入恶意代码， 覆盖当前调用的返回地址， 从而将执行权限传递给攻击 者的恶意代码。</li>
<li>实际攻击中，攻击者需要猜测缓冲区返回地址的位置，并确定用什么地址覆盖返回地址。难点在于：
<ol>
<li>进程不能访问其他进程的地址空间，因此恶意代码必须驻留在被攻击进 程的地址空间内。一般驻留在缓冲区中或者在用户的Shell环境中。</li>
<li>给定进程的地址空间是不可预测的，程序在不同计算机上执行时，地址 空间可能发生改变。</li>
<li>为了克服以上困难，攻击者可以采取的相关技术有：NOP指令滑动(NOP sledding)、返回到libc(return-to-libc)、跳转到寄存器(jump-to-register)或蹦 床(Trampolining)技术</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="缓冲区溢出攻击相关技术"><a class="markdownIt-Anchor" href="#缓冲区溢出攻击相关技术"></a> 缓冲区溢出攻击相关技术</h2>
<ol>
<li>
<p>NOP指令滑动:通过命中一串连续的NOP指令，从而使CPU指令执行流一直滑动到特定位 置来执行恶意代码。</p>
<ol>
<li>由于进程地址空间难以预测，所以通过一连串的NOP指令，只要有一个命中就能执行恶意代码。</li>
</ol>
</li>
<li>
<p>跳转到寄存器：在初始化时，大多数进程需要将外部库的内容加载到自己的地址空间。操作 系统一般将这些外部库加载到内存预留段的进程地址空间中。因此，外部库 在内存中的位置是可预测的。攻击者利用这些外部库的知识进行跳转攻击：</p>
<ol>
<li>攻击者找到特定代码集中 的跳转指令，如jump ESP；</li>
<li>攻击者设法把恶意代码放在ESP寄存器指定 的内存地址上；</li>
<li>攻击者将当前函数的返回地址重写为jump指令的地址；</li>
<li>函数返回时将执行jump指令，并跳转执行恶意代码；</li>
</ol>
</li>
<li>
<p>返回到libc攻击：攻击者确定脆弱进程的地址空间内C库函数的地址，如system()或execv的 地址，并使用这些信息强制进程调用该函数。</p>
<ol>
<li>攻击者首先让缓冲区溢出，并用所需库函数的地址覆盖返回地址，并传递重 新设定好的参数使其能够按攻击者的期望运行。</li>
<li>这种攻击方式在实现攻击的同时，也避开了数据执行保护策略中对攻击代码 的注入和执行所采取的的防护措施。Return-to-libc 攻击不需要注入新的恶意代码，而是重用漏洞程序中已有的 函数完成攻击，让漏洞程序跳转到已有的代码序列。</li>
</ol>
</li>
</ol>
<h2 id="防止基于栈的缓冲区溢出攻击"><a class="markdownIt-Anchor" href="#防止基于栈的缓冲区溢出攻击"></a> 防止基于栈的缓冲区溢出攻击</h2>
<ol>
<li>规范C语言编程</li>
<li>使用更安全的函数</li>
<li>操作系统也提供保护措施，如防止攻击者覆盖返回地址；使用金丝雀技术。</li>
</ol>
<h3 id="防止攻击者覆盖返回值地址"><a class="markdownIt-Anchor" href="#防止攻击者覆盖返回值地址"></a> 防止攻击者覆盖返回值地址</h3>
<ol>
<li>在所有指针使用前后都进行异或编码</li>
<li>将内存的栈空间设置为非执行权限</li>
<li>地址空间布局随机化，随机地重新安排地址空间的数据，使得攻击者难以预测。</li>
</ol>
<h3 id="金丝雀预警技术"><a class="markdownIt-Anchor" href="#金丝雀预警技术"></a> 金丝雀预警技术</h3>
<p>重新组织分配程序的堆栈数据，使用一个canary值，并将此值放在缓冲区和 控制数据之间。系统定期检查canary值的完整性。如果此值被更改，表明缓 冲区溢出，就要防止恶意代码的执行。</p>
<h2 id="基于堆的缓冲区溢出"><a class="markdownIt-Anchor" href="#基于堆的缓冲区溢出"></a> 基于堆的缓冲区溢出</h2>
<p><strong>问题</strong> 如果在堆上显示分配了内存，但没有释放，会导致内存泄漏问题。</p>
<p><strong>攻击</strong> 攻击者一般通过修改堆中的数据 或者滥用管理堆内存的函数和宏 来执行恶意代码。</p>
<ol>
<li>如果攻击者向程序提供输入，而程序以不安全的方式将其复制到堆中的内存 块中。那么攻击者可以使数据溢出块的边界，并覆盖下一个内存块。通过精心设计，攻击者会覆盖下一个内存块的链表指针，并将该内存块标记 为空闲。此时，unlink例程可以向内存地址空间中的任意地址写入数据。如 果写入的数据是恶意代码的存储位置，会导致程序跳转并执行恶意代码。</li>
</ol>
<h2 id="防御基于堆的缓冲区溢出"><a class="markdownIt-Anchor" href="#防御基于堆的缓冲区溢出"></a> 防御基于堆的缓冲区溢出</h2>
<p>如安全编程、地址空间随机化、设置堆数据不可执 行、将存储堆内存的指针数据和存储堆中的实际数据相分离。</p>
<h1 id="格式化字符串攻击"><a class="markdownIt-Anchor" href="#格式化字符串攻击"></a> 格式化字符串攻击</h1>
<p><strong>攻击</strong> 攻击者可以精心指定所使用的格式化字符串作为输入，并可以将输入写入内 存的任意位置。如果写入的位置正好覆盖了返回地址、函数指针等，则攻击 者能够取得控制权，并在程序的上下文中执行任意代码。</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计安导第4章</title>
    <url>/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC4%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="内部攻击"><a class="markdownIt-Anchor" href="#内部攻击"></a> 内部攻击</h1>
<ol start="2">
<li>内部攻击：指控制和保护资产的内部人员利用安全漏洞进行的攻击</li>
</ol>
<h2 id="后门"><a class="markdownIt-Anchor" href="#后门"></a> 后门</h2>
<ol start="3">
<li>后门：是程序中隐藏的功能或命令，有时也称为活门，它允许用户执行一些正常情况下不允许用户执行的操作。通常这些操作会违反安全策略，如执行特权升级。
<ol>
<li>为调试有时也会插入后门</li>
<li>为了紧急情况也可能留后门</li>
<li>恶意的后门：直接留后门；在程序中引入脆弱性，如缓冲区溢出。</li>
<li>彩蛋</li>
</ol>
</li>
</ol>
<h2 id="逻辑炸弹"><a class="markdownIt-Anchor" href="#逻辑炸弹"></a> 逻辑炸弹</h2>
<ol start="4">
<li>逻辑炸弹：是一种程序，它根据一定的逻辑条件执行恶意操作。</li>
<li>千年虫问题：具有和逻辑炸弹类似的效果，但是不视为逻辑炸弹</li>
</ol>
<h2 id="内部攻击的防御"><a class="markdownIt-Anchor" href="#内部攻击的防御"></a> 内部攻击的防御</h2>
<ol>
<li>避免单点故障：不能只让一个人创建备份或管理重要系统。</li>
<li>使用代码走查</li>
<li>使用归档和报告工具</li>
<li>限制授权和权限：使用最小权限原则；在保证每个员工能正常工作的情况下，授予他们最小权限。</li>
<li>重要系统的物理安全</li>
<li>监控员工行为</li>
<li>控制软件的安装</li>
</ol>
<h1 id="计算机病毒"><a class="markdownIt-Anchor" href="#计算机病毒"></a> 计算机病毒</h1>
<ol>
<li>计算机病毒：是一种能自我复制的计算机指令或程序代码，它通过修改其他文件与程序来插入代码，且能进一步自我复制；
<ol>
<li>这种自我复制的特性是计算机病毒与其他类型恶意软件（如逻辑炸弹）的不同之处；</li>
<li>病毒的另一个特性是其复制需要某种类型的用户协助，如打开电子邮件附件或共享USB驱动器；</li>
</ol>
</li>
<li>恶意软件分类：
<ol>
<li>按传播特性分：
<ol>
<li>病毒：人工辅助传播</li>
<li>蠕虫：自动传播</li>
</ol>
</li>
<li>按隐藏特性分：
<ol>
<li>Rootkit：修改操作系统以隐藏其存在</li>
<li>特洛伊木马：提供理想的功能但是隐藏恶意操作。</li>
</ol>
</li>
</ol>
</li>
<li>隐藏方式
<ol>
<li>加密病毒：
<ol>
<li>病毒包括解密引擎+病毒代码主体，随机生成加密密钥</li>
<li>检测：通过查找解密引擎</li>
</ol>
</li>
<li>多态病毒
<ol>
<li>具有随机变体的解密引擎的加密病毒</li>
<li>检测：使用CPU仿真器</li>
</ol>
</li>
<li>变形病毒
<ol>
<li>不同的病毒体；方法包括代码排列和指令替换</li>
<li>具有挑战性的检测</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="病毒的分类"><a class="markdownIt-Anchor" href="#病毒的分类"></a> 病毒的分类</h2>
<ol start="3">
<li>病毒执行的四个阶段
<ol>
<li>潜伏阶段</li>
<li>繁殖阶段：病毒进行自我复制，归纳然新系统中的新文件。</li>
<li>触发阶段</li>
<li>行动阶段：此阶段，病毒会执行恶意操作。</li>
</ol>
</li>
<li>病毒的类型
<ol>
<li>程序病毒（文件病毒）：通过修改文件包含的对象代码感染文件。</li>
<li>宏病毒（文档病毒）：打开文档时，启动病毒，此时，病毒搜索其他要感染的文件。此外，宏病毒还可以将自己插入到模板中，使得每次新建的文档都含有此病毒。另外，还可以通过电子邮件传播。</li>
<li>引导区病毒：感染驱动器引导区的代码，每次启动计算机或重启时，都会运行引导区的代码。</li>
</ol>
</li>
<li>病毒的特征
<ol>
<li>传染性</li>
<li>隐蔽性</li>
<li>潜伏性：只有当触发条件满足时才破坏，否则只传染</li>
<li>多态性：不断变种</li>
<li>破坏性</li>
</ol>
</li>
<li>病毒注入：（1）在程序开始处简单注入（2）将病毒代码分成两部分，并将这两部分分别注入到程序的不同位置，使用跳转指令来执行。</li>
</ol>
<h2 id="病毒的防御"><a class="markdownIt-Anchor" href="#病毒的防御"></a> 病毒的防御</h2>
<ol>
<li>病毒的特征码：
<ol>
<li>通过病毒样本找到病毒的特征指令集，产检唯一标识这类病毒的特征字符串。<strong>一般将特征字符串称为病毒的特征码</strong>。它是病毒的一种数字指纹</li>
</ol>
</li>
<li>病毒的检测与隔离
<ol>
<li>可以定期扫描整个文件系统</li>
<li>可以实时的分析每个新创建的文件，每个修改的文件和收到的电子邮件。一旦文件中有一部分包含与病毒特征码匹配的代码，就会被放入隔离区。</li>
</ol>
</li>
</ol>
<h2 id="加密病毒"><a class="markdownIt-Anchor" href="#加密病毒"></a> 加密病毒</h2>
<ol>
<li>加密病毒：通过加密病毒代码的主体，以隐藏其自身的特征码。
<ol>
<li>包括解密代码、密钥和加密病毒代码（解密代码一般用暴力破解代替）。</li>
<li>对病毒主体的解密代码本身时未加密的代码，此结构本身就构成了一种病毒的特征码。</li>
</ol>
</li>
</ol>
<h2 id="多变体病毒和变形病毒"><a class="markdownIt-Anchor" href="#多变体病毒和变形病毒"></a> 多变体病毒和变形病毒</h2>
<ol>
<li>
<p>多变体：变异的病毒。</p>
<ol>
<li>一方面，多变体病毒通过加密使自身呈现出多种形式。</li>
<li>另一方面，多变体病毒采用非加密的混淆技术，如指令重排和包含无用指令技术。</li>
</ol>
</li>
<li>
<p>检测多变体病毒：单个字符串不可能检测变形病毒的特征码，可以采用</p>
<ol>
<li>联合特征码：由在被感染文件中必须出现的字符串集组成。</li>
<li>序列特征码：由在被感染文件中必须出现的有序字符串列表组成</li>
<li>概率特征码：由阈值和字符串-评分对组成。如果文件中存在的字符串的评分总和大于阈值，则认为被感染。</li>
</ol>
</li>
</ol>
<h1 id="恶意软件攻击"><a class="markdownIt-Anchor" href="#恶意软件攻击"></a> 恶意软件攻击</h1>
<h2 id="特洛伊木马"><a class="markdownIt-Anchor" href="#特洛伊木马"></a> 特洛伊木马</h2>
<ol start="2">
<li>
<p>特洛伊木马：是一种恶意程序，表面上，它会执行一些有用的任务，但同时会隐形的执行具有负面后果的任务。</p>
<ol>
<li>
<p>组成：</p>
<ol>
<li>硬件部分：包括控制端、服务端、因特网；</li>
<li>软件部分：控制端程序、木马程序、木马配置程序；</li>
<li>具体连接部分：控制端IP、服务端IP、控制端端口、木马端口；</li>
</ol>
</li>
<li>
<p>木马入侵步骤：</p>
<p>1.配置木马  2.传播木马  3.运行木马</p>
<p>4.信息反馈  5.建立连接  6.远程控制</p>
</li>
</ol>
</li>
<li>
<p>计算机蠕虫：是一种恶意程序，不需要将自己注入其他程序就能传播自己的副本，并且不需要与人交互。</p>
<ol>
<li>
<p>蠕虫可以自我复制传播，但它不属于计算机病毒，因为他们不会感染其他程序。</p>
</li>
<li>
<p>大多数情况下，蠕虫用来删除文件或者安装后门</p>
</li>
<li>
<p>蠕虫的结构<br />
<img src="/计安导_img/第四章1.png" style="zoom:30%"/></p>
</li>
<li>
<p>设计蠕虫<br />
<img src="/计安导_img/第四章2.png" style="zoom:70%"/></p>
</li>
<li>
<p>蠕虫传播</p>
<ol>
<li>传播理论</li>
</ol>
<p>经典的传播病模型<br />
<img src="/计安导_img/第四章3.png" style="zoom:70%"/></p>
</li>
</ol>
<p>N: 易受感染的主机总数; I(t)：在t时刻被感染的主机数<br />
S(t)：在t时刻，易被感染的主机数;I(t)+S(t)=N;β：感染率;I(t)的微分方程 ：dI/dt=βI(t)S(t);	<br />
2. 蠕虫可以利用正在运行应用程序的脆弱性（如缓冲区溢出）来进行自我传播。<br />
3. 一般通过修改注册表来隐藏自身。(同时杀毒软件也会观察一些注册表项)</p>
</li>
<li>
<p>Rootkits</p>
<ol>
<li>Rootkits最早是一组用于UNIX操作系统的工具集，黑客使用它们隐藏入侵活 动的痕迹，它能在操作系统中隐藏恶意程序。这些程序在植入系统后，rootkits 会将它们 隐藏起来，它能隐藏任何恶意程序过程、文件夹、注册码。</li>
<li>一般通过修改系统是实用程序或操作系统本身来防止检测。</li>
<li>通常使用Rootkits来隐藏其他恶意软件的恶意行为（在进程控制器中删除进程的显示，删除文件浏览器中文件的显示）</li>
</ol>
</li>
<li>
<p>恶意软件僵尸</p>
<ol>
<li>僵尸是一种外部控制以执行恶意攻击的计算机，通常作为僵尸网络的一部分。</li>
</ol>
</li>
</ol>
<h2 id="入侵隐私软件"><a class="markdownIt-Anchor" href="#入侵隐私软件"></a> 入侵隐私软件</h2>
<ol>
<li>包括广告软件、间谍软件</li>
</ol>
<h2 id="对策"><a class="markdownIt-Anchor" href="#对策"></a> 对策</h2>
<ol>
<li>
<p>病毒签名：一个签名是一个病毒指纹</p>
<ol>
<li>扫描将分析的对象与签名数据库进行比较。如果文件中包含签名，则文件被感染。</li>
</ol>
</li>
<li>
<p>黑/白名单</p>
<ol>
<li>维护加密哈希数据库<br />
（1）操作系统文件 （2）热门应用程序<br />
（3）已知被感染的文件</li>
<li>需要保护数据库的完整性</li>
</ol>
</li>
<li>
<p>启发式分析</p>
<ol>
<li>用于识别新的和“零日”恶意软件</li>
<li>步骤
<ol>
<li>代码分析：根据说明防病毒软件可以确定该程序是否是恶意的。</li>
<li>执行仿真：在隔离的仿真环境中执行代码，并监控目标文件所采取的操作，如果操作有害，则认为其为病毒。</li>
<li>启发式方法可以触发错误警报</li>
</ol>
</li>
</ol>
</li>
<li>
<p>隔离：将可疑文件隔离在隔离文件夹中。</p>
<ol>
<li>可疑文件未被删除，最终可以由用户决定何使删除</li>
<li>只能通过防病毒程序与隔离区中的文件交互。</li>
<li>隔离区的文件是无害的，因为它是加密的</li>
<li>隔离技术的细节是保密的</li>
</ol>
</li>
<li>
<p>静态分析与动态分析</p>
 <img src="/计安导_img/第四章4.png" style="zoom:70%"/>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计安导第5章</title>
    <url>/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC5%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="网络基本概念"><a class="markdownIt-Anchor" href="#网络基本概念"></a> 网络基本概念</h1>
<h2 id="网络协议"><a class="markdownIt-Anchor" href="#网络协议"></a> 网络协议</h2>
<ol>
<li>OSI七层模型：应用层；表示层；会话层；传输层；网络层；链路层；物理层</li>
<li>TCP/IP五层模型：应用层；传输层；网络层；数据链路层；物理层</li>
</ol>
<h2 id="tcpip"><a class="markdownIt-Anchor" href="#tcpip"></a> TCP/IP</h2>
<ol>
<li>
<p>物理层</p>
<ol>
<li>其任务是以尽力服务为基础，在网络节点之间传输实际的比特位。</li>
<li>规定通信设备的机械的、电气的、功能的和过程的特性，用以建 立、维护和拆除物理链路连接。</li>
</ol>
</li>
<li>
<p>链路层</p>
<ol>
<li>其任务是在网络节点对间或局域网节点间传输数据并检测物理层出现的差错。</li>
<li>该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据 的检错、重发等。</li>
</ol>
</li>
<li>
<p>网络层</p>
<ol>
<li>其任务是以尽力服务为基础，在任意两台主机之间传送数据包。就是选择合适的网间路由和交换结点， 确保数据及 时传送。</li>
<li>网络层将数据链路层提供的帧组成数据包，包中封装有网络层包 头，其中含有逻辑地址信息：源站点和目的站点地址的网络地址。</li>
</ol>
</li>
<li>
<p>传输层</p>
<ol>
<li>其任务是基于IP地址和端口，支持应用程序之间的通信与连接。</li>
<li>传输层为上层提供端到端（最终用户到最终用户）的透明的、可 靠的数据传输服务。所谓透明的传输是指在通信过程中传输层对 上层屏蔽了通信传输系统的具体细节。</li>
</ol>
</li>
<li>
<p>应用层</p>
<ol>
<li>其任务是以传输层提供的服务为基础，提供协议来支持互联网上的有用的功能。</li>
<li>常用协议有FTP、TELNET、DNS、SMTP、POP3。</li>
</ol>
</li>
</ol>
<h2 id="网络与安全"><a class="markdownIt-Anchor" href="#网络与安全"></a> 网络与安全</h2>
<h3 id="与计算机安全目标-cia"><a class="markdownIt-Anchor" href="#与计算机安全目标-cia"></a> 与计算机安全目标 CIA</h3>
<ol>
<li>机密性：网络协议的任何分层中，都没有要求传输数据的机密性。 需要修订相关协议来完成机密性。可以在应用层进行加密协议的 设计，也可以在网络层。</li>
<li>完整性：封装的数据包中的头和尾部都有简单的校验和，以检查 传输数据是否有改变。但这些校验和不是密码学意义下安全的， 因此不能提供计算机安全层面的完整性。</li>
<li>可用性：网络协议设计之初主要考虑的是节点发生故障时如何保 证可用性，并未考虑攻击者存在时的情形。如拒绝服务攻击会影 响系统可用性。</li>
</ol>
<h3 id="与计算机安全目标-3a"><a class="markdownIt-Anchor" href="#与计算机安全目标-3a"></a> 与计算机安全目标 3A</h3>
<ol>
<li>保证：默认情况下网络中数据包可以在任何两个节点间阐述。如 果需要引入权限和策略来控制网络中的数据流，必须通过显式得 的措施来实现。</li>
<li>真实性：网络协议的数据格式中没有存储数字签名的字段，也没 有用户身份的概念。如果需要引入身份证明和数字签名，必须在 应用层完成。</li>
<li>匿名：网络协议没有用户身份的概念，因此具有内在的匿名性。 对于匿名攻击，可以通过确定用户正在使用网络中的哪台计算机 来确定。</li>
</ol>
<h1 id="链路层"><a class="markdownIt-Anchor" href="#链路层"></a> 链路层</h1>
<h2 id="以太网"><a class="markdownIt-Anchor" href="#以太网"></a> 以太网</h2>
<ol>
<li>定义：以太网包括通信所使用的物理介质以及链路层的协议 标准IEEE 802.3。</li>
<li>不同帧 在以太网电缆上同时传输时会产生冲突，需要丢弃并重传冲突帧。</li>
<li>冲突处理：以太网协议使用CSMA/CD（载波监听多路访问及冲突 检测）技术来避免冲突。</li>
</ol>
<h2 id="集线器"><a class="markdownIt-Anchor" href="#集线器"></a> 集线器：</h2>
<ol>
<li>工作与物理层，将所有帧广播给与之相连的所有设备。</li>
<li>缺点是与集线器相连的所有设备共享带宽，传输效率低下。由于 是广播，所以数据容易被窃听。</li>
</ol>
<h2 id="交换机"><a class="markdownIt-Anchor" href="#交换机"></a> 交换机</h2>
<ol>
<li>交换机会记录连接到自己各个接口的计算机地址。之后交换机会 将接收到的帧发送到特定的接收端，而不是广播出去。</li>
</ol>
<h2 id="mac地址"><a class="markdownIt-Anchor" href="#mac地址"></a> MAC地址</h2>
<ol>
<li>MAC（Medium/Media Access Control）地址，用来表示互联网 上每一个站点的标识符，采用十六进制数表示，共六个字节。</li>
<li>MAC地址是网卡决定的，一般是固定的。但可以通过网卡的驱动 程序软件来修改MAC地址。因此，<strong>从安全角度考虑，不能使用MAC地址作为识别网络流源头的依据。</strong></li>
</ol>
<h2 id="arp欺骗"><a class="markdownIt-Anchor" href="#arp欺骗"></a> ARP欺骗</h2>
<ol>
<li>ARP:是一种链路层协议，其主要功能是将给定主机的网络层地址解析为主机 的硬件地址。</li>
<li>过程：主机通过发送包含目标IP地址的AARP请求到网络上所有主机，并接受返回消息，以此确定目标的物理地址。同时将映射存入ARP缓存。</li>
<li><strong>ARP欺骗</strong>：攻击者可以向某 一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主 机或到达错误的主机，这就构成了一个<strong>ARP欺骗</strong>。
<ol>
<li>问题在于ARP缺乏身份认证</li>
<li><strong>解决</strong> ：
<ol>
<li>检查相同的MAC是否在局域网中多次出现，以作为ARP欺骗的标志。</li>
<li>静态ARP表：通过手动指定路由器的ARP缓存来将具体的MAC地址与特定的IP地址进行绑定。问题是不够灵活。</li>
<li>更加复杂和灵活的措施：anti-arpsroof、XArp、Arpwatch，这些 程序会仔细检查所有的ARP数据包，并将数据包的内容与所存储 的ARP表项纪录做比较，以检测并防止ARP欺骗。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="网络层"><a class="markdownIt-Anchor" href="#网络层"></a> 网络层</h1>
<h2 id="网际协议基本概念"><a class="markdownIt-Anchor" href="#网际协议基本概念"></a> 网际协议基本概念</h2>
<ol>
<li>IP：网络层协议，尽最大努力将一个数据包从源节点路由到目的 节点。节点由IP地址标识，IPv4地址为32位，IPv6地址为128位。</li>
<li>IP包路由：如果数据包的源和目的在同一个局域网内，则通过ARP进行。否则，将包传送至网关，由网关根据路由表来确定如何转发。</li>
<li>IP地址与子网掩码：例如IP地址为192.168.1.100,子网掩码为 255.255.255.0。则该地址的网络部分为192.168.1.0,主机部分为 0.0.0.100.</li>
<li>IPv4地址耗尽解决：IPv6；网络地址转换</li>
</ol>
<h2 id="路由"><a class="markdownIt-Anchor" href="#路由"></a> 路由</h2>
<ol start="3">
<li>路由器：为数据包寻找一条最佳的传输路径。路由器中维护一张路由表，以提高效率。</li>
<li>路由操作：包括发送、丢弃、转发</li>
<li><strong>TTL</strong>:数据包的<strong>生存周期</strong>，由跳数决定，一般最大条数为255。</li>
<li>路由协议
<ol>
<li>OSPF决定了如何在自治系统内路由数据包。</li>
<li>BGP决定了如何在自治系统之间路由数据包。</li>
</ol>
</li>
</ol>
<h2 id="icmp-网际控制消息协议"><a class="markdownIt-Anchor" href="#icmp-网际控制消息协议"></a> ICMP 网际控制消息协议</h2>
<ol>
<li>ICMP:用于在主机、路由器之间传递控制消息。
<ol>
<li>包括：回显请求；回显响应；超时；目的地不可达</li>
</ol>
</li>
<li>Ping 命令：Ping发送一个ICMP<strong>回声请求</strong> 消息给目的地并报告是否收到ICMP<strong>回声应答</strong>消息。</li>
<li>traceroute命令：利用ICMP 协议定位您的计算机和目标计算机之间的所有路由器。<strong>利用ICMP超时报文，依次等增TTL，以确定路径上有哪些路由</strong></li>
</ol>
<h2 id="ip地址欺骗"><a class="markdownIt-Anchor" href="#ip地址欺骗"></a> IP地址欺骗</h2>
<ol>
<li><strong>方法</strong> 恶意用户产生的IP数据包中的源IP地址是伪造的， 以便冒充其他系统或发件人的身份。源IP地址修改后， IP数据包 头部校验和也需重新计算。</li>
<li>攻击者不会收到服务器响应，因为服务器会将数据包返回给具有假冒IP地址的主机。因此，攻击者不在乎响应，故可以用来Dos攻击。</li>
<li><strong>应对</strong>
<ol>
<li>通过边缘路由器禁止那些源地址在域内，但实际地址在域外的数据包或源地址在域外，但是从域内向域外发的送的数据包。</li>
<li>可以通过IP追踪计数追踪数据包返回到实际源地址的路径。</li>
</ol>
</li>
</ol>
<h2 id="数据包嗅探"><a class="markdownIt-Anchor" href="#数据包嗅探"></a> 数据包嗅探</h2>
<ol>
<li>Wireshark：网络数据包分析软件。使用WinpCAP作为接口，直接与网卡进行数据报文交换。此时网卡需要设置为混杂模式。
<ol>
<li><strong>问题</strong> 可能泄露敏感信息。</li>
</ol>
</li>
<li><strong>解决</strong>
<ol>
<li>对于有线网，使用以太网交换机而不是集线器，降低数据包包嗅探的可能性。</li>
<li>检查网卡是否被设置为混杂模式。</li>
<li>利用高层协议进行加密，比如HTTPS</li>
</ol>
</li>
</ol>
<h1 id="传输层"><a class="markdownIt-Anchor" href="#传输层"></a> 传输层</h1>
<h2 id="基础概念"><a class="markdownIt-Anchor" href="#基础概念"></a> 基础概念</h2>
<ol>
<li>
<p>端口号：16位，用来标识应用层不同服务。</p>
<ol>
<li>FTP:21</li>
<li>Telnet:23</li>
<li>SSMTP:25</li>
<li>HTTP:80</li>
</ol>
</li>
<li>
<p><strong>TCP</strong>:面向连接的、可靠的。面向 连接意味着实现会比较复杂，可靠的是指信息会完整、有序地到 达。如果数据包丢失，TCP会保证重传。 TCP是传输文件、网页 和电子邮件的首选协议。</p>
</li>
<li>
<p><strong>UDP</strong>：无连接的、不可靠但速度快。基于IP的语音会话(VoIP)适合于使用UDP协议。</p>
</li>
</ol>
<h2 id="tcp-协议"><a class="markdownIt-Anchor" href="#tcp-协议"></a> TCP 协议</h2>
<ol>
<li>
<p>三次握手建立连接，每个数据包都有编号。</p>
</li>
<li>
<p>采用<strong>累计确认</strong></p>
</li>
<li>
<p>流量控制使用滑动窗口协议</p>
</li>
<li>
<p>校验和：使用循环冗余校验(CRC)，可以检测由网络错误引发的数据不一致，但不能检测恶意篡改。</p>
</li>
<li>
<p>拥塞控制：拥塞会导致传输速率急剧下降和数据包的丢弃。拥塞 控制是防止流量淹没网络的一种技术，通过收集确认数据包等信 息来调整数据的传输速率，防止拥塞。</p>
<ol>
<li>慢开始与拥塞避免</li>
<li>快重传与快恢复</li>
</ol>
</li>
<li>
<p>TCP三次握手</p>
 <img src="/计安导_img/1.png" style="zoom:80%">
<ol>
<li>初始序列号是随机的，以<strong>防止针对预测初始序列号的攻击</strong>。</li>
</ol>
</li>
</ol>
<h2 id="udp-协议"><a class="markdownIt-Anchor" href="#udp-协议"></a> UDP 协议</h2>
<ol>
<li>无需三次握手，允许直接发送数据包。</li>
<li>UPD提供无连接、不可靠的服务。将数据报序列中丢失数据报的工作交给应用层。</li>
<li>使用16位校验和验证数据包完整性。</li>
<li>速度远远快于TCP,用于DNS和VoIP。</li>
</ol>
<h2 id="nat-网络地址转换"><a class="markdownIt-Anchor" href="#nat-网络地址转换"></a> NAT 网络地址转换</h2>
<ol>
<li>NAT允许局域网内的主机共享一个公共IP，以接入因特网。
<ol>
<li>解决了IP地址不足的问题。</li>
<li>有效的避免了来自网络外部的攻击，隐藏并保护网络内部的计算机。</li>
<li>NAT路由器：公网和私网之间的网关，负责管理流入和流出的数据包。</li>
<li>NAT路由器通过维护一个查找表来实现私有IP和公有IP的地址转换。</li>
<li>使用NAT设备时，互联网的流入流量不能到达内部网络，能够阻 止来自外部网络的威胁。</li>
</ol>
</li>
</ol>
<h2 id="tcp会话劫持"><a class="markdownIt-Anchor" href="#tcp会话劫持"></a> TCP会话劫持</h2>
<ol>
<li>
<p><strong>TCP序列号预测攻击</strong> 通过预测TCP会话的初始序列号，以建立伪造的TCP会话。之后</p>
<ol>
<li>发动拒绝服务攻击</li>
<li>向服务器发送SYN，将源IP地址伪造成受害者客户端IP。</li>
<li>在等待服务器向客户端发送响应之后，攻击者通过发送一个 ACK数据包来结束TCP握手，该数据包的序列号是预测的下一个序列号；</li>
<li>攻击者以受害客户端名义向服务器发送请求。</li>
</ol>
</li>
<li>
<p><strong>盲注入</strong>：在TCP序列预测攻击中使用了IP欺骗，所以攻击者无法从服务器收到任何响应。盲注入允许攻击者使用请求者的源IP地址来执行某些命令，从而破坏系统。</p>
</li>
<li>
<p><strong>ACK风暴</strong>：盲注入后客户端不会向服务器发送同步消息，导致不同步。此时，客户端和服务端都会向对方发送ACK消息，来告知对方需要开始使用正确的序列号。这种反复的通信称为ACK风暴。</p>
</li>
<li>
<p><strong>完全会话劫持</strong>：当攻击者与目标服务器或客户端在同一网段时，攻击者可以通过数据包嗅探攻击，直到建立会话时的数据包序列号，从而完全劫持会话。</p>
</li>
<li>
<p><strong>防范会话劫持</strong>：</p>
<ol>
<li>在IP层或者应用层使用认证和加密，如IPSec或者应用层安全协议。</li>
<li>网站应避免创建以安全身份验证措施开始，但后来切换到未加密交 换的会话，这样会产生TCP会话劫持攻击的风险。</li>
</ol>
</li>
</ol>
<h1 id="dos攻击"><a class="markdownIt-Anchor" href="#dos攻击"></a> Dos攻击</h1>
<ol>
<li><strong>拒绝服务攻击</strong>亦称洪水攻击，其目的在于使目标电脑的网络或系统 资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</li>
<li><strong>分布式拒绝服务攻击</strong>：使用多台僵尸机发起攻击。</li>
<li>症状：网络异常缓慢(打开文件或访问网站)、特定网站无法访 问、无法访问任何网站、垃圾邮件的数量急剧增加、无线或有线网 络连接异常断开、长时间尝试访问网站或任何互联网服务时被拒绝、 服务器容易断线、卡顿等。</li>
</ol>
<h2 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h2>
<ol>
<li>
<p>带宽消耗：</p>
<ol>
<li>ICMP洪水攻击：通过向未良好设置的路由器发送广播信息以占用系统资源 。</li>
<li>UDP洪水攻击：大量UDP数据包发送给受害系统，可能会导致带宽。</li>
<li>死亡之ping：产生超过IP协议能容忍的数据包数，可能会导致死机。</li>
<li>泪滴攻击：数据在发送前都会经过切割，每个小切割都会记录位移的信息，以 便重组。此攻击模式就是捏造位移信息，导致重组时发生问题，造成错误。</li>
</ol>
</li>
<li>
<p>资源消耗型</p>
<ol>
<li>SYN 洪水攻击：大量TCP SYN请求反复发送，导致系统资源耗尽。</li>
<li>LAND攻击：与SYN floods类似，会导致被攻击的机器死循环。</li>
<li>分布式HTTP洪水攻击：使用代理服务器向受害服务器发送大量貌似合法的请 求，通常使用HTTP GET。</li>
<li>僵尸网络攻击：大量被命令与控制服务器所控制的互联网主机群协同攻击。</li>
</ol>
</li>
</ol>
<h2 id="icmp-攻击"><a class="markdownIt-Anchor" href="#icmp-攻击"></a> ICMP 攻击</h2>
<ol>
<li><strong>ping洪水攻击</strong>：通过功能强大的计算机向单个受害服务器发送大量 回显请求命令。这样受害服务器会被这些网络流量 淹没，无法响应合法的请求。</li>
<li><strong>Smurf攻击</strong>：攻击者向网络广播地址发送ICMP包，并将回复地址 设置成受害网络的广播地址，通过使用ICMP应答请求数据包来淹 没受害主机的方式进行。</li>
<li><strong>阻止Smurf攻击</strong>：
<ol>
<li>管理员应该将网络中的主机和路由器配置 为忽略广播请求；</li>
<li>避免直接向广播地址转发数据包；</li>
<li>忽略 ping请求。</li>
</ol>
</li>
</ol>
<h2 id="syn洪水攻击"><a class="markdownIt-Anchor" href="#syn洪水攻击"></a> SYN洪水攻击</h2>
<ol>
<li>
<p>攻击者故意延迟或不发送握手确认。</p>
</li>
<li>
<p><strong>过程</strong>：</p>
<ol>
<li>假设连接发起方是A，接受方是B。A发送SYN消息给B，B反馈 SYN-ACK消息给A，使连接进入半开状态。此时B会给每个半开连 接都设一个Timer，如果超过时间还没有收到A的ACK消息，则重 新发送一次SYN-ACK消息给A，直到重试超过一定次数时才会放弃。</li>
<li>攻击方A可以控制肉鸡向B发送大量SYN消息但不响应ACK消息， 或者干脆伪造SYN消息中的Source IP，使B反馈的SYN-ACK消息 石沉大海，导致B被大量注定不能完成的半开连接占据，直到资源 耗尽，停止响应正常的连接请求。</li>
</ol>
</li>
<li>
<p><strong>防范</strong></p>
<ol>
<li><strong>SYN Cookie机制</strong>：在TCP服务器接收到TCP SYN包并返回TCP SYN+ACK包时，不分配专门的数据区，而是根据SYN包计算一个 cookie值。 这个cookie作为将要返回的SYN-ACK包的初始序列号。</li>
</ol>
</li>
<li>
<p>SYN + ACK包的32比特结构如下：</p>
<ol>
<li>前5比特是时间戳，由每分 钟按模32递增的计数器实现</li>
<li>中间3比特是编码值，表示传输段 的最大值</li>
<li>最后24比特是基于密钥k，由服务器和客户端IP地址，端口号和前面使用的时间戳计算出来的MAC值。</li>
</ol>
</li>
<li>
<p>当客户端返回一个ACK包时</p>
<ol>
<li>服务器首先根据其前5比特判断是否 过期；</li>
<li>服务器根据包头信息重新计算24比特的MAC值，与返回的确认序列号(初始序列号 + 1)进行对比；</li>
<li>服务器对中间3 比特进行解码，完成对SYN队列项的重构。如果验证通过，则服务 器发起TCP会话。</li>
</ol>
</li>
<li>
<p>Optimistic TCP ACK攻击</p>
<ol>
<li>利用TCP的拥塞控制机制。在TCP的华东窗口协议中，虽则接收ACK的增多，窗口大小增大。</li>
<li><strong>攻击</strong> 恶意客户端在没有收到SYN-ACK时，就提前发送ACK，使得服务 器增加其传输速度。如果同时针对多台服务器进行TCP ACK攻击，它会通过淹 没网络带宽资源，导致互联网范围内的拥塞。</li>
<li><strong>防御</strong> 设置对每个客户端最大流量的限制。</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计安导第6章</title>
    <url>/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC6%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="dns-域名系统"><a class="markdownIt-Anchor" href="#dns-域名系统"></a> DNS 域名系统</h1>
<ol>
<li>DNS是应用层协议，负责将域名映射到IP地址。</li>
<li>DNS数据库包括
<ol>
<li>地址记录：与主机名相关链的IP地址。</li>
<li>邮件交换记录：域的邮件服务器。</li>
<li>名称服务器记录：域的权威服务器。</li>
</ol>
</li>
</ol>
<h2 id="应用层协议"><a class="markdownIt-Anchor" href="#应用层协议"></a> 应用层协议</h2>
<ol>
<li>DNS：建立IP和域名间的映射</li>
<li>HTTP:用来浏览网页</li>
<li>SSL/TLS: 以安全的、加密的方式浏览网页的协议(<strong>HTTPS</strong>)</li>
<li>IMAP/POP/SMAP:用于互联网电子邮件</li>
<li>SOAP：用于交换作为网络服务模式部分的结构化数据</li>
<li>talent：远程访问协议(与FTP一样，不提供加密)</li>
<li>SSH:较新的安全远程访问和管理协议</li>
</ol>
<h2 id="域名服务器"><a class="markdownIt-Anchor" href="#域名服务器"></a> 域名服务器</h2>
<ol>
<li>域名：最右为顶级域名(TLD)</li>
<li>域名服务器从上至下依次为
<ol>
<li>根域名服务器：管理顶级域名.</li>
<li>顶级域名服务器:如.com。其中保存的每条记录都对应一个权威域名服务器</li>
<li>权威域名服务器</li>
</ol>
</li>
</ol>
<h2 id="域名解析"><a class="markdownIt-Anchor" href="#域名解析"></a> 域名解析</h2>
<ol>
<li>
<p>区域：具有相同权威DNS服务器的已连接节点的集合。</p>
</li>
<li>
<p>域名解析：</p>
<ol>
<li>迭代解析</li>
</ol>
 <img src="/计安导_img/2.png"  />
<ol start="2">
<li>递归解析</li>
</ol>
 <img src="/计安导_img/3.png"  />	
</li>
</ol>
<h2 id="权威域名服务器"><a class="markdownIt-Anchor" href="#权威域名服务器"></a> 权威域名服务器</h2>
<ol>
<li>权威域名服务器层次结构：权威域名服务器也是分层的，每个域名服务器都存储着记录的集合，每个记录提供域名地址或者对该域权威域名服务器的引用。</li>
<li>作用：控制在权威域名服务器(ANS)之间分配
<ol>
<li>负责特定域</li>
<li>可以为子域指定其他ANS</li>
</ol>
</li>
</ol>
<h2 id="dns数据包"><a class="markdownIt-Anchor" href="#dns数据包"></a> DNS数据包</h2>
<ol>
<li>DNS查询和应答是通过UDP实现的，但当请求超过512时，会采用TCP。</li>
<li>DNS查询通常通过端口53上的UDP发出。</li>
</ol>
<h3 id="组成"><a class="markdownIt-Anchor" href="#组成"></a> 组成：</h3>
<ol>
<li>头：包含16为查询标识符，用于标识查询和响应</li>
<li>查询部分：由问题序列组成，每个问题由所查询域名和查询记录的类型组成。</li>
<li>应答部分包括
<ol>
<li>NAME 包含一个全域名</li>
<li>2B的TYPE 标识DNS记录的类型</li>
<li>2B的CLASS域 标识更广泛的类型</li>
<li>4B的TTL 标识有效时间</li>
<li>2B的RDLENGTH 标识数据段的长度</li>
<li>可变长RDATA段 包括实际的记录数据</li>
</ol>
</li>
</ol>
<h2 id="dns缓存"><a class="markdownIt-Anchor" href="#dns缓存"></a> DNS缓存</h2>
<ol>
<li>目的：如果每个查询都遍历DNS树会导致根区域过载</li>
<li>缓存有效期：由ANS回复的TTL指定。</li>
<li>由操作系统和浏览器维护缓存</li>
</ol>
<h2 id="dns-攻击-网络嫁接与网络钓鱼"><a class="markdownIt-Anchor" href="#dns-攻击-网络嫁接与网络钓鱼"></a> DNS 攻击： 网络嫁接与网络钓鱼</h2>
<ol>
<li><strong>过程</strong> 攻击者把网站发送请求解析成子集恶意服务器的伪装IP地址，导致受害人浏览或下载伪造的内容。</li>
<li><strong>用途</strong> 伪造王章</li>
</ol>
<h2 id="dns-缓存中毒"><a class="markdownIt-Anchor" href="#dns-缓存中毒"></a> DNS 缓存中毒</h2>
<ol>
<li>
<p><strong>思想</strong> 攻击者欺骗DNS服务器缓存保存虚假的DNS记录。</p>
 <img src="/计安导_img/4.png"  />
 <img src="/计安导_img/5.png"  />
 <img src="/计安导_img/6.png"  />
</li>
<li>
<p><strong>检测</strong> DNS使用16位请求标识符将查询ID与响应ID配对。当服务器</p>
<ol>
<li>忽略标识符</li>
<li>具有可预测的ID</li>
<li>接受未经请求的DNS记录</li>
</ol>
<p>说明可能中毒了</p>
</li>
<li>
<p>防御DNS缓存中毒</p>
<ol>
<li>对查询使用随机标识符</li>
<li>始终检查标识符</li>
<li>DNS请求的端口随机化</li>
<li>部署DNSSEC（DNS协议的安全扩展集）</li>
</ol>
</li>
</ol>
<h2 id="dns缓存中毒和生日悖论"><a class="markdownIt-Anchor" href="#dns缓存中毒和生日悖论"></a> DNS缓存中毒和生日悖论</h2>
<blockquote>
<p>DNS 协议交换不验证对递归迭代查询的响应。验证查询只会检查 16 位事务 ID 以及响应数据包的源 IP 地址和目标端口。在 2008 年之前，所有 DNS 使用固定端口53 解析.因此，除了事务 ID 之外，欺骗 DNS 回复所需的所有信息都是可预测的。用这种弱点攻击 DNS 被称为“生日悖论”，平均需要 256 次来猜测事务 ID。为了使攻击成功，伪造的 DNS 回复必须在合法权威响应之前到达目标解析器。如果合法响应首先到达，它将由解析器缓存，并且直到其生存时间（TTL）到期，解析器将不会要求权威服务器解析相同的域名，从而防止攻击者中毒映射该域，直到 TTL 到期。</p>
</blockquote>
<h2 id="dnssec"><a class="markdownIt-Anchor" href="#dnssec"></a> DNSSEC</h2>
<blockquote>
<p>DNSSEC 采用基于公共密钥加密的数字签名，从而增强 DNS 验证强度。DNSSEC 并非对 DNS 查询和响应本身进行加密签名，而是由数据所有者对 DNS 数据自身进行签名。</p>
</blockquote>
<blockquote>
<p>每一个 DNS 区均包含一个公私秘钥对。DNS 区所有者使用该区域的私钥对区域内的 DNS 数据进行签名，为这些数据生成数字签名。顾名思义，&quot;私钥&quot;是指 DNS 区所有者会对这些密钥材料保密。但是，该区域的公钥则在区域内公开发布，供全体用户检索。凡在区域内查找数据的递归解析器，还必需检索区域公钥，从而使用公钥验证 DNS 数据的真实性。解析器确认检索到的 DNS 数据的数字签名是否有效。如果有效，证明 DNS 数据合法，则将 DNS 数据返回给用户。如果签名未通过验证，解析器会假设发生攻击，丢弃数据并向用户返回错误。</p>
</blockquote>
<ol>
<li>
<p>目的：验证</p>
<ol>
<li>DNS回答来源的真实性</li>
<li>回复的完整性</li>
<li>拒绝存在的真实性</li>
</ol>
</li>
<li>
<p>通过在每一步中对DNS回复签名来实现这一点</p>
</li>
<li>
<p>使用公钥加密对所有DNS应答进行数字签名</p>
</li>
<li>
<p>通常使用信任锚，操作系统中的条目来引导进程</p>
</li>
<li>
<p>现状：加入安全机制后，数据包会远大于512B的UDP数据包。</p>
</li>
</ol>
<h1 id="防火墙"><a class="markdownIt-Anchor" href="#防火墙"></a> 防火墙</h1>
<ol>
<li>
<p>定义：防火墙是一种集成的安全措施集合，旨在防止对网络计算机 系统未经授权的访问。</p>
</li>
<li>
<p>防火墙策略：</p>
<ol>
<li>接收</li>
<li>拒绝</li>
<li>丢弃</li>
</ol>
</li>
<li>
<p>数据包匹配：基于数据包的一些特性。</p>
</li>
</ol>
<h2 id="黑名单与白名单"><a class="markdownIt-Anchor" href="#黑名单与白名单"></a> 黑名单与白名单</h2>
<h3 id="黑名单"><a class="markdownIt-Anchor" href="#黑名单"></a> 黑名单</h3>
<ol>
<li>默认规则为接收，只拒绝/丢弃黑名单定义的规则匹配到的数据包。</li>
</ol>
<h3 id="白名单"><a class="markdownIt-Anchor" href="#白名单"></a> 白名单</h3>
<ol>
<li>默认规则拒绝，只接收白名单规则匹配到的数据包。</li>
</ol>
<h2 id="防火墙分类"><a class="markdownIt-Anchor" href="#防火墙分类"></a> 防火墙分类</h2>
<ol>
<li>数据包过滤器(无状态防火墙)：如果数据包与数据包过滤器的规则集匹配，则数据包过滤器将丢弃或者接受他。</li>
<li>状态过滤器(状态防火墙)：一种能够提供状态数据包检查或状态查看功能的防火墙，能够持续追踪穿过这个防火墙的各种网络连接（例如TCP与UDP连接）的状态。这种防火墙被设计来区分不同连接种类下的合法数据包。只有匹配主动连接的数据包才能够被允许穿过防火墙，其他的数据包都会被拒绝。</li>
<li>应用层防火墙：当内部计算机与外部主机连结时，将由代理服务器（Proxy Server）担任内部计算机与外部主机的连结中继者。使用ALG的好处是隐藏内部主机的地址和防止外部不正常的连接，如果代理服务器上未安装针对该应用程序设计的代理程序时，任何属于这个网络服务的封包将完全无法通过防火墙。</li>
</ol>
<h3 id="无状态防火墙"><a class="markdownIt-Anchor" href="#无状态防火墙"></a> 无状态防火墙</h3>
<ol>
<li>将每个尝试通过它的数据包视为独立的，而不考虑前后数据包间的关系。</li>
<li>因此必须具有严格的限制性</li>
</ol>
<h3 id="状态防火墙"><a class="markdownIt-Anchor" href="#状态防火墙"></a> 状态防火墙</h3>
<ol>
<li>可以区分数据包是否是<strong>受信任网络</strong>内发起的<strong>合法会话</strong>的一部分。</li>
<li>状态防火墙维护一些表，表中包含每个活动<strong>连接的信息</strong>， 包括<strong>IP地址、端口和数据包的序列号</strong>。通过这些表，可以只允许响应内部网发起连接的TCP数据包流入。</li>
<li><strong>对于TCP</strong> 一旦完成初始的握手，且也允许数据包通过防火墙，则该连接的所有后续通信都允许通过防火墙，直到连接终止。</li>
<li><strong>对于UDP</strong> 由于UDP没有握手过程，所以一般情况下，当防火墙允许合法UDP通过</li>
</ol>
<h3 id="应用层防火墙"><a class="markdownIt-Anchor" href="#应用层防火墙"></a> 应用层防火墙</h3>
<ol>
<li>基于进入或流出网络数据包的实际内容来管理流量，而不是仅仅分析源和目的。</li>
</ol>
<h3 id="现状基于深度数据包检测技术"><a class="markdownIt-Anchor" href="#现状基于深度数据包检测技术"></a> 现状：基于深度数据包检测技术</h3>
<h1 id="隧道-tcp"><a class="markdownIt-Anchor" href="#隧道-tcp"></a> 隧道----&gt;TCP</h1>
<ol>
<li><strong>问题</strong> 由于TCP本身是不加密的，如果有人窃听TCP连接，就可以知道有效载荷中的全部内容。</li>
<li><strong>解决</strong> 使用隧道协议，无需改变软件的执行就能防止窃听，并且加密是自动的。</li>
<li><strong>缺点</strong> 需要在传输层或网络层协议中使用应用层概念，增加了协议栈的开销。</li>
</ol>
<h2 id="安全的shell-ssh-telnetftprlogin等早期远程管理协议"><a class="markdownIt-Anchor" href="#安全的shell-ssh-telnetftprlogin等早期远程管理协议"></a> 安全的Shell (SSH) -&gt;Telnet,FTP,rlogin等早期远程管理协议</h2>
<ol>
<li>使用对称和公钥密码技术加密通信。</li>
<li>常用于<strong>安全隧道</strong>，目的是使窃听者无法推断出SSH流量的内容，使用SSH建立的隧道能防止许多基于数据包嗅探的攻击。</li>
<li><strong>安全的交互式命令会话</strong>过程：
<ol>
<li>客户端通过一个TCP会话连接到服务器</li>
<li>客户端与服务器交换管理细节的信息，如支持的加密方法、各 自协议的版本，每一方都要选择另一方支持的一组协议</li>
<li>客户端和服务器进行密钥交换，创建共享的秘密会话密钥，用 会话密钥加密双方的通信（但不用于身份验证）。这个会话密 钥配合选择的块加密（通常是AES、3DES、Blowfish或IDEA） 来加密所有后续的通信</li>
<li>服务器向客户端发送可以接受身份验证列表，客户端将按顺序尝 试。最常见的机制是使用密码或以下的公共密钥身份验证方法：
<ol>
<li>如果选定的机制是<strong>公共密钥身份验证</strong>，则客户端向服务器发送<strong>自己的</strong>公钥；</li>
<li>然后服务器检查是否这密钥已存储在其授权的密钥列表之中。如果在， 服务器使用客户的<strong>公钥加密挑战</strong>，并将其发送给客户端；</li>
<li>客户用自己的私钥解密挑战，并向服务器发回响应，证明自己的身份；</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="ipsecip"><a class="markdownIt-Anchor" href="#ipsecip"></a> IPSec–&gt;IP</h2>
<p>IPSec协议族在网络层保证应用程序的安全，为数据包提供机密性和真实性。且协议族中每个协议都能运行在<strong>传输模式</strong>或<strong>隧道模式</strong>下</p>
<ol>
<li><strong>传输模式</strong>：在原数据包的数据之前，插入额外的IPSec的头信息，只对数据包的有效载荷继续加密或身份验证。</li>
<li><strong>隧道模式</strong>：构造一个新的数据包，将IPSec头信息和整个原数据包一起封装进新数据包的有效载荷中。</li>
</ol>
<h2 id="vpn-虚拟专用网"><a class="markdownIt-Anchor" href="#vpn-虚拟专用网"></a> VPN 虚拟专用网</h2>
<p>分为 <strong>远程访问VPN</strong>和<strong>站点到站点的VPN</strong></p>
<h3 id="远程访问vpn"><a class="markdownIt-Anchor" href="#远程访问vpn"></a> 远程访问VPN</h3>
<p>允许授权的用户通过安装在自己电脑上的客户端通过NAS访问私有网络，即内网。</p>
<ol>
<li><strong>网路接入服务器(NAS)</strong>：VPN服务端</li>
</ol>
<h3 id="站点到站点的vpn"><a class="markdownIt-Anchor" href="#站点到站点的vpn"></a> 站点到站点的VPN</h3>
<p>旨在为<strong>两个或更多</strong>远程网络提供安全的桥梁。两个网络各有一个独立的VPN端点，两端点之间相互通信。</p>
<h3 id="安全问题"><a class="markdownIt-Anchor" href="#安全问题"></a> 安全问题</h3>
<ol>
<li>
<p>使用点对点的隧道协议 PPTP</p>
<p>首先使用PPP建立连接，然后封装PPP帧，然后用MPPE对其加密，最后通过互联网发送数据包。</p>
</li>
</ol>
<h2 id="隧道存在的安全风险"><a class="markdownIt-Anchor" href="#隧道存在的安全风险"></a> 隧道存在的安全风险</h2>
<ol>
<li>会规避防火墙的策略。当使用隧道技术时，会不同的传输协议对一系列网络数据包的有效载荷进行封装。同时，在隧道协议中也对有效载荷进行了加密，所以深度数据包检测也毫无用处。</li>
<li>如果内部用户通过隧道直接和外部服务器连接，并代表该用户向禁止访问的网站路由HTTP流量，同样通过隧道，将响应返回给该用户。相应的，攻击者也可以通过隧道规避防火墙。</li>
</ol>
<h1 id="入侵检测"><a class="markdownIt-Anchor" href="#入侵检测"></a> 入侵检测</h1>
<h2 id="入侵检测系统-ids"><a class="markdownIt-Anchor" href="#入侵检测系统-ids"></a> 入侵检测系统 IDS</h2>
<p>IDS 是一个软件或硬件系统，用于检测网络或个人计算机上恶意活动的迹象。</p>
<ol>
<li>
<p>分类： 按功能分</p>
<ol>
<li>
<p>IDS传感器，用于收集网络组件或计算机的实时数据</p>
</li>
<li>
<p>IDS管理器，用于接收来自传感器的报告</p>
</li>
<li>
<p><strong>关系</strong>：IDS管理器编译来自IDS传感器的数据，以确定是否发生了入侵。以此确定基于一组站点策略，这些策略是定义可能入侵的规则和条件。如果 IDS管理员检测到入侵，则会发出警报。</p>
</li>
</ol>
</li>
<li>
<p>IDS所检测的威胁包括</p>
<ol>
<li>伪装者：冒用合法用户的身份或凭据来获得对计算机系统或网络的访问的攻击者</li>
<li>违反者：执行了未经授权的操作的合法的用户</li>
<li>秘密用户：通过删除审计文件或系统日志，试图组织或掩盖自己行为的用户</li>
</ol>
</li>
<li>
<p>IDS所检测的攻击包括</p>
<ol>
<li><strong>端口扫描</strong>：是指某些别有用心的人发送一组端口扫描消息，试图以此侵入某台计算机，并了解其提供的计算机网络服务类型。攻击者可以通过它了解到从哪里可探寻到攻击弱点。</li>
<li><strong>拒绝服务攻击</strong>：网络攻击淹没主机，并将合法访问拒之门外</li>
<li><strong>恶意软件攻击</strong>：复制恶意软件的攻击，特洛伊木马、计算机蠕虫和病毒等</li>
<li>ARP欺骗：试图重定向局域网中的IP流量</li>
<li><strong>DNS缓存中毒</strong>：网络嫁接攻击旨在改变主机的DNS缓存，以创建伪造的域名/IP 地址的关联</li>
</ol>
</li>
</ol>
<h2 id="入侵检测技术"><a class="markdownIt-Anchor" href="#入侵检测技术"></a> 入侵检测技术</h2>
<ol>
<li>
<p>传统的网络入侵检测系统（NIDS）</p>
<p>– 位于网络边界，基于<strong>流量模式和内容</strong>检测恶意的行为；</p>
</li>
<li>
<p>基于入侵检测系统的协议（PIDS）</p>
<p>– <strong>专门检测特定协议中的恶意行为</strong>，通常部署在特定的网络主机中。如 Web服务器可以运行PIDS来分析流入的HTTP流量，丢弃恶意的或包含错误的请求</p>
</li>
<li>
<p>基于主机的IDS（HIDS）</p>
<p>– 驻留在单个系统之中，<strong>监控这台计算机上的活动</strong>。如系统调用，进程间 的通信和资源使用模式</p>
</li>
</ol>
<h2 id="ids攻击"><a class="markdownIt-Anchor" href="#ids攻击"></a> IDS攻击</h2>
<p>通过对IDS本身发动Dos攻击，故意触发大量入侵警报。直到淹没IDS，使他无法记录每个事件，或让管理员很难确定哪些日志代表攻击。</p>
<h2 id="入侵检测错误"><a class="markdownIt-Anchor" href="#入侵检测错误"></a> 入侵检测错误</h2>
<p>包括：</p>
<ol>
<li>误报：当事件是良性活动而不是入侵时就发出警报，导致时间和资源的浪费。</li>
<li>漏报：当事件是入侵的恶意事件，却未发出警报。</li>
</ol>
<h3 id="基率谬误"><a class="markdownIt-Anchor" href="#基率谬误"></a> 基率谬误</h3>
<p>由于基率谬误的存在，可能使某些IDS的有效性被误解。所以，当评估某些条件事件的概率而不考虑该事件的“基本概率”时，会发生此类错误。例如：</p>
<ol>
<li>
<p>假设IDS准确度为99％，假阳性或假阴性的概率为1％。</p>
</li>
<li>
<p>假设入侵检测系统生成1,000,100个日志条目。 1,000,100个条目中只有100个对应于实际的恶意事件。</p>
</li>
<li>
<p>由于IDS的成功率，在100个恶意事件中，99个将被检测为恶意，这意 味着我们有1个假阴性。</p>
</li>
<li>
<p>然而，在1,000,000个良性事件中，10,000个将被错误地识别为恶意事件。</p>
</li>
<li>
<p>因此，将共有10,099个警报响起，其中10,000个是误报警。也就是说，大约99％的警报都是误报警。</p>
</li>
</ol>
<h2 id="ids数据收集和审计记录"><a class="markdownIt-Anchor" href="#ids数据收集和审计记录"></a> IDS数据收集和审计记录</h2>
<ol>
<li>
<p>入侵检测的输入是确定网络或主机操作基本的记录流</p>
</li>
<li>
<p>记录流中操作的类型包括：</p>
<ol>
<li>基于网的IDS，包括每次HTTP会话尝试、每次登录尝试、每 次TCP绘画的初始化等；</li>
<li>基于主机的IDS，包括对文件的读、写或执行</li>
</ol>
</li>
<li>
<p>IDS传感器检测这些操作，创建这些操作的特征。将这 些记录报告给IDS管理器或者将它们写入审计日志</p>
</li>
<li>
<p>IDS事件记录包括：主体，对象，操作，异常条件，占用的资源，时间戳。</p>
</li>
</ol>
<h2 id="入侵检测系统的类型"><a class="markdownIt-Anchor" href="#入侵检测系统的类型"></a> 入侵检测系统的类型</h2>
<h3 id="基于规则的入侵检测"><a class="markdownIt-Anchor" href="#基于规则的入侵检测"></a> 基于规则的入侵检测</h3>
<ol>
<li>
<p><strong>规则</strong>标识与入侵攻击的某些已知<strong>配置文件匹配的操作类型</strong>，在这种情况下， 规则将编码此类攻击的<strong>签名</strong>。因此，如果IDS管理器看到与该规则的签名匹配的事件，它将立即发出警报，甚至可能指示怀疑的类型。</p>
</li>
<li>
<p><strong>优点</strong>：减少了误报，因为决策者已经明确了规则列表。</p>
</li>
<li>
<p><strong>缺点</strong>：存在局限性，因为它需要IDS具有每一个攻击类型的特征。</p>
</li>
</ol>
<h3 id="基于统计的入侵检测"><a class="markdownIt-Anchor" href="#基于统计的入侵检测"></a> 基于统计的入侵检测</h3>
<ol>
<li>构建了一个配置文件，它是用户行为或主机使用的<strong>典型方式</strong>的统计表示； 因此，它可用于确定用户或主机何时以非常不寻常的<strong>异常方式</strong>运行。</li>
</ol>
<h3 id="端口扫描"><a class="markdownIt-Anchor" href="#端口扫描"></a> 端口扫描</h3>
<ol>
<li>允许用户列举计算机的哪个端口正在接受连接的技术。端口的状态包括：开放的，关闭的，阻塞的。</li>
<li>端口扫描的方法：
<ol>
<li>
<p>TCP扫描/连接扫描：向目标主机的每个端口发起TCP连接。完成连接的端口是开放的，否则要么是关闭的，要么是阻塞的。</p>
</li>
<li>
<p>SYN扫描：向目标主机端口发起SYN标志的数据包，看是否有SYN-ACK返回。(如果收到，则发出一个RST数据包终止连接而非完成握手)</p>
</li>
<li>
<p>空闲扫描：它允许进行端口完全欺骗扫描。使得攻击者能够不使用自己的IP向目标主机发送数据包。它的巧妙之处在于，利用不活跃的“僵尸主机”反弹给攻击者一个旁通信道，从而使得攻击者可以进行端口扫描。入侵检测系统也就会把无辜的僵尸主机当成攻击者。利用僵尸可预测的TCP序列号实现。其过程如下：</p>
<ol>
<li>探测僵尸主机的IP ID 并记录。</li>
<li>向需要扫描的目标主机端口发送一个伪造成来自僵尸主机的SYN包。根据目标主机端口状态的不同，目标主机返回的数据包会使得僵尸主机的IP ID递增或否。</li>
<li>再次探测僵尸主机的IP ID。并对比第一步记录的IP ID就可以确定目标主机端口的状态。如果序列号递增了，则表示目标端口是开放的。否则，目标端口是关闭或阻塞的。</li>
</ol>
</li>
<li>
<p>UDP扫描：向目标主机端口发送UDP数据包。</p>
</li>
</ol>
</li>
</ol>
<h2 id="蜜罐"><a class="markdownIt-Anchor" href="#蜜罐"></a> 蜜罐</h2>
<p>使用一台计算机作为诱饵的入侵检测技术。其优点包括</p>
<ol>
<li>
<p>入侵检测：因为连接到蜜罐的尝试不会来自合法用户，所以 对蜜罐的任何连接都被安全地确定为入侵。</p>
</li>
<li>
<p>证据：蜜罐计算机中有吸引力的文件使入侵者逗留并留下证据，从而识别出入侵者或者确定他的位置。</p>
</li>
<li>
<p>导流：与合法计算机相比，蜜罐对入侵者更有吸引力，从而分散入侵者对敏感信息和服务的注意力。</p>
</li>
</ol>
<h1 id="无线网"><a class="markdownIt-Anchor" href="#无线网"></a> 无线网</h1>
<p>无线网引入安全问题包括：</p>
<ol>
<li>使得<strong>数据包嗅探</strong>更加容易。因为同一个网段的所有计算机都共享一个无线接入点。</li>
<li>使得<strong>会话劫持</strong>更加容易。因为配有无线适配器的计算机都可以嗅探出数据包并模拟无线接入点。</li>
<li>存在<strong>入侵</strong>问题。入侵指未授权用户通过其他人的无限接入点连接到互联网。</li>
<li>验证<strong>合法用户</strong>的难度增加。通过在局域网中主机的位置来验证合法主机再不可能，需要其他的身份验证或授权方法。</li>
</ol>
<h2 id="无线网结构"><a class="markdownIt-Anchor" href="#无线网结构"></a> 无线网结构</h2>
<img src="/计安导_img/7.png"  />	
<ol>
<li>基于802.11标准。大多数的TCP/IP实现会根据不同的接收者重新定义数据包，即802.11帧和以太网帧的相互转换。</li>
<li>结构
<ol>
<li>客户端计算机与接入点建立无线连接。</li>
<li>无线接入点连接到有线网络的接入点提供到互联网的网关。</li>
</ol>
</li>
</ol>
<h2 id="ssid-服务集id"><a class="markdownIt-Anchor" href="#ssid-服务集id"></a> SSID (服务集ID)</h2>
<ol>
<li>SSID 32个字符组成的网络标识，使得多个无线网络可以共存。
<ol>
<li>制造商的名称是接入点的典型默认SSID。</li>
<li>经常广播SSID可以使潜在用户能够发现网络</li>
</ol>
</li>
<li><strong>问题</strong> ：由于SSID未被签名，所以可以进行欺骗攻击
<ol>
<li>将恶意接入点放置在公共场所（例如，咖啡馆，机场）；</li>
<li>使用ISP的SSID</li>
<li>设置类似于ISP的登录页面；</li>
<li>等待客户端连接到恶意接入点并进行身份验证；</li>
<li>可能会转发到ISP网络的会话；</li>
<li>由自动连接默认值促成</li>
</ol>
</li>
</ol>
<h2 id="强制网络门户"><a class="markdownIt-Anchor" href="#强制网络门户"></a> 强制网络门户</h2>
<ol>
<li>
<p><strong>定义</strong>：是公共接入网络的用户在授予访问权限之前必须查看和交互的网页。通常 用于商业中心、机场、酒店大堂、咖啡店等为用户提供免费Wi-Fi的场所</p>
</li>
<li>
<p><strong>协议</strong></p>
<ol>
<li>
<p>通过MAC地址定位客户端。</p>
</li>
<li>
<p>认证完成之前，任何URL都会被重定向到身份验证界面。</p>
<ol>
<li>防火墙会阻止其他流量。</li>
<li>名称服务器会将一切映射到认证服务器。</li>
</ol>
</li>
<li>
<p>身份验证之后，恢复常规网络服务。由DHCP提供IP地址。</p>
</li>
</ol>
</li>
<li>
<p><strong>问题</strong></p>
<ol>
<li>如果客户端没有主动断开连接，则可以执行MAC欺骗和会话窃取。</li>
<li>如果身份验证之前未阻止防火墙之外的DNS流量，则隧道攻击可以绕过强制网络门户。</li>
</ol>
</li>
</ol>
<h2 id="wardriving-and-warchalking"><a class="markdownIt-Anchor" href="#wardriving-and-warchalking"></a> Wardriving and Warchalking</h2>
<ol>
<li>Wardriving在移动的汽车中，使用移动设备四处寻找无线网。</li>
<li>Warchalking（开战标记）：在公共场所绘制引导公共Wi-Fi网 络的一种绘画符号（源自流浪汉符号）</li>
</ol>
<h2 id="wep-有线等效保密协议"><a class="markdownIt-Anchor" href="#wep-有线等效保密协议"></a> WEP 有线等效保密协议</h2>
<p>###<strong>目标</strong> ：</p>
<ol>
<li>机密性:防止窃听。</li>
<li>数据完整性：保证数据包不被篡改。</li>
<li>访问控制：仅路由正确加密的数据包。<br />
###<strong>限制</strong></li>
<li>在数据链路层加密每个帧的主体。</li>
<li>避免传统的802.11标准。</li>
</ol>
<h3 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h3>
<p>接入点和客户端共享40b的密钥。密钥在WEP会话期间不被更改。</p>
<h3 id="流密码"><a class="markdownIt-Anchor" href="#流密码"></a> 流密码</h3>
<ol>
<li>流密码是一种对称加密系统，密文C由明文消息M异或密钥流生成，而密钥流是密钥产生的伪随机数二进制向量S。</li>
<li><strong>流密码是安全的</strong> 因为相同的密钥流永远不会被重用，否则攻击者会得到两个明文消息的异或值，统计攻击就能同时恢复明文和密钥流。</li>
</ol>
<h3 id="加密"><a class="markdownIt-Anchor" href="#加密"></a> 加密</h3>
<ol>
<li>计算消息M(有效载荷部分)的CRC校验和。</li>
<li>选择24b的初始化向量V</li>
<li>使用RC4流密码生成密钥流S(K,V)</li>
<li>计算密文 C=(M||CRC(m))⊕S(K,V)</li>
</ol>
<h3 id="wep-认证方法"><a class="markdownIt-Anchor" href="#wep-认证方法"></a> WEP 认证方法</h3>
<p>包括开放系统和共享密钥两种。</p>
<ol>
<li>
<p><strong>开放系统</strong>身份验证</p>
<p>客户端无需任何凭证就可以连接接入点。且只能使用正确的密钥发送和接收信息，否则接入点会忽略请求。</p>
</li>
<li>
<p><strong>共享密钥</strong>身份验证</p>
<p>在连入接入点之前要先证明自己拥有接入点的WEP密钥。</p>
<ol start="2">
<li>接入点向客户端发起明文挑战，客户端用拥有的密钥加密该明文，并将生成的密文发给接入点。</li>
<li>如果接入点能正确解密，则可连接接入点。</li>
</ol>
</li>
</ol>
<h2 id="消息篡改攻击"><a class="markdownIt-Anchor" href="#消息篡改攻击"></a> 消息篡改攻击</h2>
<h3 id="消息篡改"><a class="markdownIt-Anchor" href="#消息篡改"></a> 消息篡改</h3>
<p>对于给定一个任意字符串 ，我们想用M’=M⊕▲替换消息M</p>
<p>可以在中途用C’=C⊕(▲||CRC(▲))来替换C。</p>
<ol>
<li>需要直到消息中文本的位置即可</li>
<li><strong>脆弱性原因</strong> CRC检验和是通过XOR</li>
<li><strong>解决</strong> 改用哈希函数</li>
</ol>
<h2 id="ip重定向攻击"><a class="markdownIt-Anchor" href="#ip重定向攻击"></a> IP重定向攻击</h2>
<p>指攻击者利用物理接入点解密数据包，将目的地址修改为恶意主机地址。</p>
<ol>
<li>
<p>过程为：</p>
<ol>
<li>窃听入站的IP数据包。</li>
<li>将数据包重新发送到由攻击者控制的外部计算机。</li>
<li>接收由接入点解密的数据包。</li>
<li>重复出站数据包。</li>
</ol>
</li>
<li>
<p>需要修改数据包校验和。校验和的差为：x’-x=(D’H+D’L)-(DH-DL)</p>
</li>
</ol>
<h2 id="重用初始化向量iv"><a class="markdownIt-Anchor" href="#重用初始化向量iv"></a> 重用初始化向量IV</h2>
<h3 id="初始化向量iv"><a class="markdownIt-Anchor" href="#初始化向量iv"></a> 初始化向量IV</h3>
<ol>
<li>每个数据包一个，24位。</li>
<li>以邮件的明文部分发送。</li>
<li>初始化向量空间过小会导致重用相同的密钥流。</li>
</ol>
<h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h3>
<ol>
<li><strong>问题</strong> 重用初始化向量意味着重用密钥流，攻击者获得两条消息的XOR，可以恢复出消息和密钥流。</li>
<li><strong>默认IV存在上述问题</strong></li>
<li><strong>解决</strong> 使用随机IV，且长度要足够长。</li>
</ol>
<h3 id="注入方法"><a class="markdownIt-Anchor" href="#注入方法"></a> 注入方法</h3>
<ol>
<li>假设攻击者知道一个加密消息的一个明文。</li>
<li>利用RC4(X )⊕X⊕Y=RC4(Y),来构造计算CRC32的新消息。</li>
</ol>
<h2 id="身份验证欺骗"><a class="markdownIt-Anchor" href="#身份验证欺骗"></a> 身份验证欺骗</h2>
<ol>
<li>不知道密钥的非法用户可以通过窃听身份验证消息。</li>
<li><strong>攻击</strong>
<ol>
<li>生成挑战R和加密挑战C =(R||CRC®)⊕S(K,V)</li>
<li>计算密钥流S(K,V)=(R||CRC®)⊕C</li>
<li>从接入点挑战时重用密钥流S(K,V)</li>
</ol>
</li>
</ol>
<h2 id="慢攻击wep嗅探"><a class="markdownIt-Anchor" href="#慢攻击wep嗅探"></a> 慢攻击：WEP嗅探</h2>
<p>通过大量数据包去计算初始化向量IV</p>
<h2 id="快攻击数据包注入"><a class="markdownIt-Anchor" href="#快攻击数据包注入"></a> 快攻击：数据包注入</h2>
<h2 id="wpa-wi-fi访问保护"><a class="markdownIt-Anchor" href="#wpa-wi-fi访问保护"></a> WPA Wi-fi访问保护</h2>
<p>目的是为了改进WEP</p>
<h3 id="区别wep"><a class="markdownIt-Anchor" href="#区别wep"></a> 区别WEP</h3>
<ol>
<li>采用128位密钥和48位IV</li>
<li>支持除共享密钥外各种类型的身份验证。</li>
<li>会话期间动态修改密钥。</li>
<li>支持检查完整性的加密。</li>
<li>增加帧计数器防止重放攻击</li>
</ol>
<h3 id="wpa2"><a class="markdownIt-Anchor" href="#wpa2"></a> WPA2</h3>
<ol>
<li>使用AES而不是RC4</li>
<li>处理加密，密钥管理和完整性</li>
<li>由反模式提供的MAC与密码块链接（CCMP）一起使用</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计安导第7章</title>
    <url>/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC7%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="万维网"><a class="markdownIt-Anchor" href="#万维网"></a> 万维网</h1>
<h2 id="html-超文本标记语言"><a class="markdownIt-Anchor" href="#html-超文本标记语言"></a> HTML 超文本标记语言</h2>
<h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3>
<ol>
<li>静态文档描述语言</li>
<li>支持链接到其他页面或者嵌入图像</li>
<li>通过表单（Forms）将用户输入发送到服务器</li>
</ol>
<h2 id="超文本传输协议http"><a class="markdownIt-Anchor" href="#超文本传输协议http"></a> 超文本传输协议HTTP</h2>
<ol>
<li>先检索本地DNS，如果没有找到则查询DNS服务器</li>
<li>解析IP地址之后，建立TCP连接</li>
<li>HTTP请求和响应<strong>通过TCP的端口80</strong>传输</li>
<li>不提供数据加密，以明文发送</li>
</ol>
<h2 id="安全套接字层超文本传输协议https"><a class="markdownIt-Anchor" href="#安全套接字层超文本传输协议https"></a> 安全套接字层超文本传输协议HTTPS</h2>
<ol>
<li>
<p>与HTTP语法相同，但使用了安全套接字层SSL或传输层安全TLS</p>
</li>
<li>
<p>SSL和TLS都依靠证书来验 证服务器的身份，并建立加 密的通信信道</p>
 <img src="/计安导_img/8.png">
</li>
</ol>
<h1 id="网络钓鱼"><a class="markdownIt-Anchor" href="#网络钓鱼"></a> 网络钓鱼</h1>
<p>通过伪造网页以欺诈的方式获取敏感资料</p>
<h2 id="url混淆同源攻击"><a class="markdownIt-Anchor" href="#url混淆同源攻击"></a> URL混淆	同源攻击</h2>
<p>注册带有unicode字符的域名，针对相似的字母进行注册。称为<strong>同源攻击</strong></p>
<h2 id="移除或伪造地址栏"><a class="markdownIt-Anchor" href="#移除或伪造地址栏"></a> 移除或伪造地址栏</h2>
<h1 id="图像崩溃"><a class="markdownIt-Anchor" href="#图像崩溃"></a> 图像崩溃</h1>
<p>由于浏览器的缺陷导致。通过HTML代码创建一个非常大比例的简单图像，可以使IE 崩溃，有时还会使电脑宕机。</p>
<h1 id="可移动代码"><a class="markdownIt-Anchor" href="#可移动代码"></a> 可移动代码</h1>
<p><strong>可移动代码</strong> 指可执行、通过网络发送、在目标 电脑上执行的代码程序。包括</p>
<h2 id="javascript"><a class="markdownIt-Anchor" href="#javascript"></a> JavaScript</h2>
<h2 id="activex控件"><a class="markdownIt-Anchor" href="#activex控件"></a> ActiveX控件</h2>
<h3 id="支持签名"><a class="markdownIt-Anchor" href="#支持签名"></a> 支持签名</h3>
<p>此签名的ActiveX控件要求 用户运行权限。如果获得批准，控件将以与用户相同的权限运行</p>
<h3 id="受信任不受信任的activex控件"><a class="markdownIt-Anchor" href="#受信任不受信任的activex控件"></a> 受信任/不受信任的ActiveX控件</h3>
<ol>
<li>
<p>可行的发布者：</p>
<ol>
<li>存储在Windows注册表中的列表</li>
<li>恶意ActiveX控件可以修改注册表，使其发行者可信</li>
<li>运行该发布者今后所有的插件不需要提示用户</li>
</ol>
</li>
<li>
<p>未签名的控件</p>
<ol>
<li>浏览器对于未签名的控件会给出一个接受/拒绝的选项</li>
<li>但即使你拒绝该控件，它也已被下载到一个临时文件夹中</li>
<li>如果拒绝，它不会被执行，但也不会被删除</li>
</ol>
</li>
</ol>
<p>###<strong>可以访问用户文件</strong></p>
<h2 id="java插件"><a class="markdownIt-Anchor" href="#java插件"></a> Java插件</h2>
<h3 id="支持签名-2"><a class="markdownIt-Anchor" href="#支持签名-2"></a> 支持签名</h3>
<p>###<strong>沙箱执行</strong></p>
<ol>
<li>沙箱：应用程序或脚本在另一个应用程序中首先的运行权限。沙箱只能访问某些文件和设备。</li>
</ol>
<h1 id="cookies"><a class="markdownIt-Anchor" href="#cookies"></a> Cookies</h1>
<p>cookie是指存储在计算机上、与特定服务器关联的 一小部分信息。用于在会话中保存状态信息。</p>
<h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2>
<p>可能包含敏感信息</p>
<h2 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h2>
<ol>
<li><strong>会话型cookie</strong>：是浏览器的处理过程中保留的，是暂时性的，当 浏览器关闭时则消除。</li>
<li><strong>持久性cookie</strong>：而持久性的是保存在客户端的硬盘上的，浏览器 关闭也不会消除。</li>
</ol>
<h1 id="跨站脚本-xss"><a class="markdownIt-Anchor" href="#跨站脚本-xss"></a> 跨站脚本 XSS</h1>
<p>用于攻击者将脚本代码注入Web应用程序生成的页面。攻击者通常在有漏洞的程序中插入Javascript， VBScript，ActiveX或Flash以欺骗用户。</p>
<h2 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例</h2>
<p>2005 年 Samy 在社交网站Myspace的个人资料中加入 Javascript ，打开该页面 的浏览器将执行该脚本 ― 首先把攻击者加为好友，其次把这段 XSS 复制到被 攻击者的个人资料中。</p>
<p>这算是一种<strong>蠕虫</strong></p>
<h2 id="xss的发起条件"><a class="markdownIt-Anchor" href="#xss的发起条件"></a> XSS的发起条件</h2>
<ol>
<li>Web服务器没有对用户输入进行有效性验证或者验证强度不够 ，而又轻易地将它们返回到客户端</li>
<li>允许用户在表格或编辑框中输入不相关字符</li>
<li>存储并允许把用户输入显示在返回给终端的页面上，而没有去 除非法字符或者重新进行编码</li>
</ol>
<h2 id="xss盗取cookie"><a class="markdownIt-Anchor" href="#xss盗取cookie"></a> XSS盗取cookie</h2>
<ol>
<li>首先编写获取cokie的php脚本</li>
<li>向被攻击者服务器页面上注入一段JS代码，用于将被攻击者的cookie传送到我们的服务器。</li>
</ol>
<h2 id="xss的防御"><a class="markdownIt-Anchor" href="#xss的防御"></a> XSS的防御</h2>
<h3 id="基于代理"><a class="markdownIt-Anchor" href="#基于代理"></a> 基于代理</h3>
<ol>
<li>分析浏览器和Web服务器之间的HTTP通信量</li>
<li>寻找HTML中的特殊字符</li>
<li>执行Web页面之前对它们进行编码</li>
</ol>
<h3 id="使用应用层防火墙"><a class="markdownIt-Anchor" href="#使用应用层防火墙"></a> 使用应用层防火墙</h3>
<ol>
<li>分析HTML页面中可能导致敏感信息泄漏的超链接</li>
<li>对于使用不良请求的一系列链接进行停止操作</li>
</ol>
<h3 id="审计制度"><a class="markdownIt-Anchor" href="#审计制度"></a> 审计制度</h3>
<p>监视JavaScript代码的执行，并将操作与高级策略进行比较，以 检测恶意行为</p>
<h1 id="sql注入攻击"><a class="markdownIt-Anchor" href="#sql注入攻击"></a> SQL注入攻击</h1>
<p>SQL注入：就是通过把SQL命令插入到Web表单提交或输入 域名或页面请求的查询字符串，最终达到欺骗服务器执行恶 意的SQL命令</p>
<h2 id="条件"><a class="markdownIt-Anchor" href="#条件"></a> 条件</h2>
<ol>
<li>web应用程序从表单中获取用户输入</li>
<li>用户提交的信息用于构建查询</li>
<li>SQL注入攻击涉及在用户输入中放置SQL语句。</li>
</ol>
<h2 id="万能语句-1-or-1"><a class="markdownIt-Anchor" href="#万能语句-1-or-1"></a> 万能语句 1 or 1</h2>
<h2 id="防范"><a class="markdownIt-Anchor" href="#防范"></a> 防范</h2>
<ol>
<li>使用预编译语句，绑定变量。</li>
<li>对用户提交的数据和输入参数进行严格过滤。</li>
<li>使用安全函数</li>
<li>摒弃动态SQL语句，改用存储过程来访问和操作数据。</li>
<li>最小权限原则：避免Web直接使用root</li>
</ol>
<h1 id="dos-拒绝服务攻击"><a class="markdownIt-Anchor" href="#dos-拒绝服务攻击"></a> DoS 拒绝服务攻击</h1>
<p>任何旨在 使计算机或系统不可用或无法执行基本功能的攻击。如TCP 泛滥攻击，DNS放大攻击。</p>
<h2 id="分布式拒绝服务攻击-ddos"><a class="markdownIt-Anchor" href="#分布式拒绝服务攻击-ddos"></a> 分布式拒绝服务攻击 DDoS</h2>
<ol>
<li>利用控制的大量僵尸计算机同时攻击目标。使得传统DoS攻击不了的高性能服务器也变得不安全。</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计安导第8章</title>
    <url>/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC8%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="密码学基础"><a class="markdownIt-Anchor" href="#密码学基础"></a> 密码学基础</h1>
<h2 id="基本符号"><a class="markdownIt-Anchor" href="#基本符号"></a> 基本符号</h2>
<ol>
<li>密钥 K</li>
<li>加密算法 E<sub>K</sub>§ = C</li>
<li>解密算法 D<sub>K</sub>©	= M</li>
</ol>
<h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2>
<ol>
<li>密文长度通常和明文长度相同</li>
<li>加密/解密是所有n位二进制序列构成的集合上的 (双射)置换函数。加密算法EK§和解密算法DK©必须是高效的。</li>
<li>对密文解密后可恢复出明文，即D<sub>K</sub>(E<sub>K</sub>§)=P</li>
</ol>
<h1 id="对称加密"><a class="markdownIt-Anchor" href="#对称加密"></a> 对称加密</h1>
<p>加密和解密使用同一个密钥</p>
<h2 id="攻击者主要类型"><a class="markdownIt-Anchor" href="#攻击者主要类型"></a> 攻击者主要类型</h2>
<ol>
<li>唯密文攻击：攻击者收集一个或多个消息的密文。且这些消息都使用相同的密钥K加密。攻击者的目标是根据一个或多个密文来确定明文，或者找到密钥K。</li>
<li>已知明文攻击：攻击者收集一个或多个明文-密文对。且每个这样的对都使用相同的密钥K加密。攻击者目标是确定密钥K。</li>
<li>选择明文攻击: 攻击者可收集指定的明文对应的密文信息。且这些明文都使用相同的密钥K。 目的在于破解密钥K。</li>
<li>选择密文攻击：攻击者可收集指定的密文 对应的明文信息。且这些明文都使用相同的密钥K。 目的在于破解密钥K。</li>
<li>穷举攻击：穷举可能的密钥，直到能把密文转换称有意义的明文。需要了解明文结构且密钥不长。</li>
</ol>
<h2 id="英文文本的唯一解距离计算"><a class="markdownIt-Anchor" href="#英文文本的唯一解距离计算"></a> 英文文本的唯一解距离计算</h2>
<p>已知英文文本的信息熵为1.25bits，共t个字符，每个字符由8位二进制数的ASCII码表示。</p>
<img src="/计安导_img/9.png">
<img src="/计安导_img/10.png">
<h2 id="替换密码"><a class="markdownIt-Anchor" href="#替换密码"></a> 替换密码</h2>
<p>每个字母用不同的独一无二的其他字符替代。存在26!个可能的替换密码。存在4.03×1026个可能的密文。</p>
<h3 id="主要弱点"><a class="markdownIt-Anchor" href="#主要弱点"></a> 主要弱点</h3>
<p>他们不隐藏明文中不同字母的基本频率。</p>
<h3 id="多字母替换密码和替换盒"><a class="markdownIt-Anchor" href="#多字母替换密码和替换盒"></a> 多字母替换密码和替换盒</h3>
<ol>
<li>
<p>多字母替换密码：对字母组进行替换。由26<sup>2</sup> = 676种可能的组合。会产生676!个可能的密钥</p>
</li>
<li>
<p>问题 导致密钥太长，需要保存所有替换组合密码。</p>
</li>
<li>
<p>替换盒(S-盒)：一张二维表，交叉处为相应的替换。</p>
 <img src="/计安导_img/11.png">
</li>
</ol>
<h3 id="频率分析"><a class="markdownIt-Anchor" href="#频率分析"></a> 频率分析</h3>
<p>对字母频率的分析是针对替换密码的有效攻击手段</p>
<h3 id="一次一密"><a class="markdownIt-Anchor" href="#一次一密"></a> 一次一密</h3>
<p>绝对牢不可破的替换密码</p>
<ol>
<li>使用密钥块(k1, k2, . . . , kn)来加密长度为n的明文M，每个密钥ki都是均匀随机生成的。由于每次都是完全随机地选择移动量，在密文中字母表的每 个字母出现的概率几乎相同</li>
<li>弱点：
<ol>
<li>密钥块的长度m必须和明文的 长度n相同</li>
<li>密钥不可以被重用。而事实是密钥很可能被用完，当重用密钥时，安全性会大大降低。</li>
</ol>
</li>
</ol>
<h2 id="分组密码"><a class="markdownIt-Anchor" href="#分组密码"></a> 分组密码</h2>
<p>每条消息被划分成一系列的块，基于这些数据块来进行加密或解密。</p>
<h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3>
<ol>
<li>明文和密文具有固定的长度b</li>
<li>长度为 n 的明文被划分为 m 个序列块 P[0], …, P[m-1]（n ≤ bm＜ n + b）</li>
</ol>
<h3 id="填充要求"><a class="markdownIt-Anchor" href="#填充要求"></a> 填充要求</h3>
<p>分组密码要求明文长度n应该为块长度b的倍数，所以最后一个块特殊。对最后一个数据块的填充必须是明确的（不能只是填充0）。要求</p>
<ol>
<li>当块大小和明文长度是8的倍数时，一种常用的填充方法（PKCS5） 是一组相同的字节，每个字节都表示填充的长度（以字节为单位）</li>
</ol>
<img src="/计安导_img/12.png"> 
<p>意思貌似是要填充9个字节，所以用9来填充。</p>
<h2 id="实际使用的分组密码"><a class="markdownIt-Anchor" href="#实际使用的分组密码"></a> 实际使用的分组密码</h2>
<h3 id="aes-高级加密标准"><a class="markdownIt-Anchor" href="#aes-高级加密标准"></a> AES 高级加密标准</h3>
<ol>
<li>每组128位，所采用的密钥长度为128、192或者256 位，所得到的密码称为AES-128、AES-192和AES-256。</li>
<li>AES轮结构</li>
</ol>
<img src="/计安导_img/13.png"> 
<p>10轮异或之后得到密文。</p>
<ol>
<li>SubBytes步骤：S-盒替换步骤</li>
<li>ShiftRows步骤：置换步骤</li>
<li>MixColumns步骤：矩阵乘法（希尔密码）步骤</li>
<li>AddRoundKey步骤：使用从128位密钥派生的轮密钥的XOR步骤</li>
</ol>
<h3 id="数据加密标准des"><a class="markdownIt-Anchor" href="#数据加密标准des"></a> 数据加密标准（DES）</h3>
<h3 id="三重des-3des"><a class="markdownIt-Anchor" href="#三重des-3des"></a> 三重DES （3DES）</h3>
<h2 id="分组密码的操作模式"><a class="markdownIt-Anchor" href="#分组密码的操作模式"></a> 分组密码的操作模式</h2>
<h3 id="电子密码本模式-ecb"><a class="markdownIt-Anchor" href="#电子密码本模式-ecb"></a> 电子密码本模式 	ECB</h3>
<ol>
<li>明文块 P[i] 加密成密文块 C[i] = EK( P[i] )；密文块 C[i] 解密成明文块 M[i] = DK( C[i] )</li>
<li>优点 可以容忍分组丢失。因为解密i分组与i-1分组无关。</li>
<li>缺点
<ol>
<li>如果加密算法是完全确定的，比如使用AES，那么每个明文都与唯一的密文相关联。对于很长的消息，ECB模式可能会解释分组流中出现的模式。</li>
<li>适用于短报文，如<strong>密钥和初始向量的加密</strong></li>
</ol>
</li>
</ol>
<h3 id="密码分组链接模式cbc"><a class="markdownIt-Anchor" href="#密码分组链接模式cbc"></a> 密码分组链接模式	CBC</h3>
<p>是最常用的模式之一</p>
<img src="/计安导_img/14.png"> 
<ol>
<li>
<p>加密 C[i] = EK(C[i-1] ⊕ P[i])</p>
<p>C[-1] = V， 一个单独传输的随机加密数据块将作为初始化向量</p>
</li>
<li>
<p>解密 P[i] = C[i-1] ⊕DK(C[i])</p>
</li>
<li>
<p>优点</p>
<ol>
<li>没有在明文中泄露明文的模式</li>
<li>快速而简单</li>
</ol>
</li>
<li>
<p>缺点</p>
<ol>
<li>需要所有数据进行有序可靠的传输</li>
<li>不适用于允许丢包的应用，如音频流、视频流</li>
</ol>
</li>
</ol>
<h3 id="密码反馈模式-cfb"><a class="markdownIt-Anchor" href="#密码反馈模式-cfb"></a> 密码反馈模式 CFB</h3>
<h3 id="输出反馈模式-ofb"><a class="markdownIt-Anchor" href="#输出反馈模式-ofb"></a> 输出反馈模式 OFB</h3>
<h2 id="流密码"><a class="markdownIt-Anchor" href="#流密码"></a> 流密码</h2>
<h3 id="密钥流"><a class="markdownIt-Anchor" href="#密钥流"></a> 密钥流</h3>
<p>是一组伪随机序列S = S[0], S[1], S[2], …… ；每次生成1位或者1个字节。</p>
<h3 id="流密码-2"><a class="markdownIt-Anchor" href="#流密码-2"></a> 流密码</h3>
<p>密钥流和明文流进行对位异或操作 C[i] = S[i]⊕P[i]</p>
<h3 id="同步流密码"><a class="markdownIt-Anchor" href="#同步流密码"></a> 同步流密码</h3>
<ol>
<li>密钥流的生成只依靠密钥K</li>
<li>如果明文是带有序列号的包，同步流密码可在不可靠信道下工作。</li>
</ol>
<h3 id="自同步流密码"><a class="markdownIt-Anchor" href="#自同步流密码"></a> 自同步流密码</h3>
<ol>
<li>使用密钥K和前q个密文来生成密钥流</li>
<li>在接收到q个密文后自动与密钥流生成器同步，如果数字被丢弃或添加到明文流中，更容易恢复。</li>
<li>自同步：因解码当前文字只依赖于固定个数的之前的密文字。所以仅有确定数量的明文字符不可被恢复。</li>
</ol>
<h3 id="rc4-流密码与密钥流生成器"><a class="markdownIt-Anchor" href="#rc4-流密码与密钥流生成器"></a> RC4 流密码与密钥流生成器</h3>
<ol>
<li>最多可以使用2048位的密钥</li>
<li>使用块大小为b的数据块</li>
<li>使用一个密钥对(K, t), K为密钥，计数器t是一个b位的值</li>
<li>密钥流由下列密文块连接而成: E<sub>K</sub>(t), E<sub>K</sub>(t+1), E<sub>K</sub>(t+2), ……</li>
</ol>
<h2 id="针对流密码的攻击"><a class="markdownIt-Anchor" href="#针对流密码的攻击"></a> 针对流密码的攻击</h2>
<h3 id="重试攻击"><a class="markdownIt-Anchor" href="#重试攻击"></a> 重试攻击</h3>
<p>如果密钥流被重用，那么攻击者可获得两个明文的异或值</p>
<h3 id="插入攻击"><a class="markdownIt-Anchor" href="#插入攻击"></a> 插入攻击</h3>
<p>将由攻击者选定的字节插入到消息流中，并使用相同的密钥流进行加密</p>
<h1 id="公钥加密"><a class="markdownIt-Anchor" href="#公钥加密"></a> 公钥加密</h1>
<h2 id="数论基础"><a class="markdownIt-Anchor" href="#数论基础"></a> 数论基础</h2>
<h3 id="素数-只能被1和他自身整除"><a class="markdownIt-Anchor" href="#素数-只能被1和他自身整除"></a> 素数 只能被1和他自身整除。</h3>
<ol>
<li>正整数n可以写成若干个素数的某次幂的乘积。如200=2<sup>3</sup>×5<sup>2</sup></li>
<li>算术基本定理：一个正整数的素数分解是唯一的</li>
</ol>
<h3 id="互质-两个数的最大公约数为1"><a class="markdownIt-Anchor" href="#互质-两个数的最大公约数为1"></a> 互质 两个数的最大公约数为1</h3>
<h3 id="辗转相除法-用于计算两个正整数的最大公约数"><a class="markdownIt-Anchor" href="#辗转相除法-用于计算两个正整数的最大公约数"></a> 辗转相除法 用于计算两个正整数的最大公约数</h3>
<ol>
<li>
<p>gcd(a, b) = gcd(b, a mod b)</p>
</li>
<li>
<p>算法最大迭代次数为1+2log max(a,b)</p>
<p>复杂度 O(log min(a,b))</p>
<p>gcd(412,260)=4</p>
 <img src="/计安导_img/15.png">
</li>
</ol>
<h3 id="乘法逆元"><a class="markdownIt-Anchor" href="#乘法逆元"></a> 乘法逆元</h3>
<ol>
<li>
<p>xy mod n = 1, 则称 y 是 x 在 Zn的乘法逆元，记作 y = x - 1</p>
 <img src="/计安导_img/16.png">
</li>
<li>
<p>定理：Zn中的元素 x 有乘法逆元当且仅当 x 和 n 互素。</p>
</li>
<li>
<p>定理：a存在模b的乘法逆元的充要条件是gcd（a,b）= 1</p>
</li>
<li>
<p>定理：如果p是素数，那么Zp上的非0剩余类都有乘法逆元</p>
</li>
<li>
<p>定理：欧几里得算法可以用来计算 Zn 中元素 x 的乘法逆元或者确定该元素是否存在乘法逆元</p>
</li>
</ol>
<h3 id="费马小定理"><a class="markdownIt-Anchor" href="#费马小定理"></a> 费马小定理</h3>
<ol>
<li>
<p>若 p 是素数，x 是正整数且不能被 p 整除，则 x<sup>p-1</sup> mod p = 1</p>
 <img src="/计安导_img/17.png">
</li>
<li>
<p>若 p 是素数，x 是正整数且不能被 p 整除，x的乘法逆元是 xp<sup>p-2</sup> mod p</p>
</li>
</ol>
<h3 id="欧拉定理"><a class="markdownIt-Anchor" href="#欧拉定理"></a> 欧拉定理</h3>
<ol>
<li>欧拉函数  Φ(n)指的是小于n且与n互素的正整数个数。Φ(1) = 1。 当p为素数时，Φ(p - 1) = p</li>
<li>欧拉定理：对任意互素的x和n，有 x<sup>Φ(n)</sup> mod n = 1</li>
</ol>
<img src="/计安导_img/18.png">
<h2 id="rsa-密码系统"><a class="markdownIt-Anchor" href="#rsa-密码系统"></a> RSA 密码系统</h2>
<img src="/计安导_img/19.png">
<img src="/计安导_img/20.png">
<h3 id="rsa-安全性"><a class="markdownIt-Anchor" href="#rsa-安全性"></a> RSA 安全性</h3>
<p>基于给定e和n，找到d是困难的</p>
<h1 id="密码学哈希函数"><a class="markdownIt-Anchor" href="#密码学哈希函数"></a> 密码学哈希函数</h1>
<h2 id="哈希函数"><a class="markdownIt-Anchor" href="#哈希函数"></a> 哈希函数</h2>
<ol>
<li>哈希函数 指将可变长度的消息P 作为输入，产生固定 长度的Hash值 x = h§，称函数值h§为P的哈希值或消息摘要。</li>
<li>哈希表 是根据关键码值(Key value)而直接进行访问的数据结构。也就是说， 它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。</li>
<li>性质：
<ol>
<li>单向性</li>
<li>抗弱碰撞性 想穷举出明文是困难的</li>
<li>抗强碰撞性 想伪造哈希签名是困难的</li>
<li>一个函数如果是抗强碰撞的，那么也同时是抗弱碰撞的，但反之则不 一定成立</li>
</ol>
</li>
</ol>
<h2 id="随机预言机"><a class="markdownIt-Anchor" href="#随机预言机"></a> 随机预言机</h2>
<p>把随机预言机理解为<strong>完美</strong>的散列函数，具有</p>
<ol>
<li>一致性：对于相同的输入，其输出必然相同</li>
<li>可计算性：输出的计算可以在多项式时间内完成</li>
<li>均匀分布性：预言机的输出在取值空间内均匀分布，<strong>无碰撞</strong></li>
</ol>
<h2 id="生日攻击"><a class="markdownIt-Anchor" href="#生日攻击"></a> 生日攻击</h2>
<p>暴力破解哈希，危害其抗碰撞性</p>
<h3 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h3>
<ol>
<li>随机产生消息序列X1，X2，X3，…</li>
<li>对于每个Xi计算Hash值 yi = h(Xi) 并且检测yi是否等于yj ( j &lt; i )</li>
<li>直至找到碰撞即停止</li>
</ol>
<h3 id="概率分析"><a class="markdownIt-Anchor" href="#概率分析"></a> 概率分析</h3>
<ol>
<li>对于b位的Hash函数，则有2<sup>b</sup>个Hash值数目</li>
<li>攻击者 生成的第 i 个消息与前面 i-1 个消息中任意一个产生冲突的概率为 1 - (i - 1)/m</li>
<li>在k轮的失败概率(即攻击者在生成 k个消息后没有找到冲突的概率)为Fk = (1 - 1/m) (1 - 2/m) (1 - 3/m) … (1 - (k - 1)/m)</li>
<li>用1- x ≈ e<sup>-x</sup>逼近,Fk ≈ e <sup>-(1/m + 2/m + 3/m + … + (k - 1)/m) </sup>= e <sup>-k ( k-1) / 2m</sup></li>
<li>当Fk = 1/2时，攻击成功/失败的概率为50%，即e <sup>-k ( k-1) / 2m</sup> = 1/2</li>
<li>进一步得到k=1.17√m , 其中√m 的位数是b/2，m位数的一半</li>
<li>所以通常根据输出大小的一半来考虑加密散列函数的安全, 比如256位抗冲突Hash函数的安全是128位。</li>
</ol>
<h2 id="md5消息签名算法"><a class="markdownIt-Anchor" href="#md5消息签名算法"></a> MD5消息签名算法</h2>
<p>对于任意两个密文Ｐ和Ｑ，通过250次MD5哈希运算可以找出两个前 缀S1和S2使得 P||S1 和 Q||S2 发生碰撞.</p>
<h1 id="数据完整性"><a class="markdownIt-Anchor" href="#数据完整性"></a> 数据完整性</h1>
<h2 id="消息认证码-mac"><a class="markdownIt-Anchor" href="#消息认证码-mac"></a> 消息认证码 MAC</h2>
<ol>
<li>发送方计算MAC值 c = h(K, M) 并且将c连同消息M一起传输。接收方从收到的消息中重新计算MAC值并将其与接收到的MAC进行比较。</li>
<li>密钥可以以单独加密并签名的方式发送</li>
</ol>
<h2 id="基于hash函数的mac-hmac"><a class="markdownIt-Anchor" href="#基于hash函数的mac-hmac"></a> 基于Hash函数的MAC HMAC</h2>
<ol>
<li>密码学Hash函数不能直接用作消息认证函数。因为Hash函数内部迭代结构，所以标准Hash并不安全。</li>
<li>HMAC构造方法
<ol>
<li>h(K⊕A||h(K⊕B||M)) A和B为常数</li>
</ol>
</li>
</ol>
<h2 id="安全信道"><a class="markdownIt-Anchor" href="#安全信道"></a> 安全信道</h2>
<p>确保不安全信道所传输的消息的完整性和机密性。包括</p>
<ol>
<li>签名配合加密：对(message, signature)加密后再进行传输</li>
<li>MAC配合加密：对(message, MAC)加密后再进行传输。
<ol>
<li>比签名配合加密的方法更加高效：计算消息的MAC比对消息进行签名 和验证更快，且开销更低。</li>
</ol>
</li>
</ol>
<h2 id="hash链"><a class="markdownIt-Anchor" href="#hash链"></a> Hash链</h2>
<img src="/计安导_img/21.png">
<ol>
<li>
<p>计算Hash链</p>
<p>xn = r</p>
<p>xi = h(x<sub>i+1</sub>) for i = n-1, …, 1</p>
</li>
<li>
<p>验证Hash链</p>
<p>xn+1 = 0</p>
<p>xi = h(Pi || x<sub>i+1</sub>) ) for i = n, …, 1</p>
</li>
</ol>
<h2 id="hash-树"><a class="markdownIt-Anchor" href="#hash-树"></a> Hash 树</h2>
<p>是一种树 形数据结构，每个叶节点均以 数据块的Hash作为标签，而 除了叶节点以外的节点则以其 子节点标签的Hash作为标签</p>
<h2 id="哈希认证树"><a class="markdownIt-Anchor" href="#哈希认证树"></a> 哈希认证树</h2>
<img src="/计安导_img/22.png">
<ol>
<li>g = h(h(a, h(x3, x4)), d)</li>
<li>proof(x4) = [(x3, L), (a, L), (d, R)]</li>
<li>具有对数级的存储和计算复杂度</li>
</ol>
<h2 id="允许丢包的数据流检验"><a class="markdownIt-Anchor" href="#允许丢包的数据流检验"></a> 允许丢包的数据流检验</h2>
<img src="/计安导_img/23.png">]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机视觉目录</title>
    <url>/2020/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="视觉第1讲"><a class="markdownIt-Anchor" href="#视觉第1讲"></a> <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC1%E8%AE%B2/">视觉第1讲</a></h2>
<h2 id="视觉第2讲"><a class="markdownIt-Anchor" href="#视觉第2讲"></a> <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC2%E8%AE%B2/">视觉第2讲</a></h2>
<h2 id="视觉第3讲"><a class="markdownIt-Anchor" href="#视觉第3讲"></a> <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC3%E8%AE%B2/">视觉第3讲</a></h2>
<h2 id="视觉第4讲"><a class="markdownIt-Anchor" href="#视觉第4讲"></a> <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC4%E8%AE%B2/">视觉第4讲</a></h2>
<h2 id="视觉第5讲"><a class="markdownIt-Anchor" href="#视觉第5讲"></a> <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC5%E8%AE%B2/">视觉第5讲</a></h2>
<h2 id="视觉第6讲"><a class="markdownIt-Anchor" href="#视觉第6讲"></a> <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC6%E8%AE%B2/">视觉第6讲</a></h2>
<h2 id="视觉第7讲"><a class="markdownIt-Anchor" href="#视觉第7讲"></a> <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC7%E8%AE%B2/">视觉第7讲</a></h2>
<h2 id="视觉第8讲"><a class="markdownIt-Anchor" href="#视觉第8讲"></a> <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC8%E8%AE%B2/">视觉第8讲</a></h2>
<h2 id="视觉第9讲"><a class="markdownIt-Anchor" href="#视觉第9讲"></a> <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC9%E8%AE%B2/">视觉第9讲</a></h2>
<h2 id="视觉第10讲"><a class="markdownIt-Anchor" href="#视觉第10讲"></a> <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC10%E8%AE%B2/">视觉第10讲</a></h2>
<h2 id="视觉第11讲"><a class="markdownIt-Anchor" href="#视觉第11讲"></a> <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC11%E8%AE%B2/">视觉第11讲</a></h2>
<h2 id="视觉第12讲"><a class="markdownIt-Anchor" href="#视觉第12讲"></a> <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC12%E8%AE%B2/">视觉第12讲</a></h2>
<h2 id="视觉第13讲"><a class="markdownIt-Anchor" href="#视觉第13讲"></a> <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC13%E8%AE%B2/">视觉第13讲</a></h2>
<h2 id="视觉第14讲"><a class="markdownIt-Anchor" href="#视觉第14讲"></a> <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC14%E8%AE%B2/">视觉第14讲</a></h2>
<h2 id="视觉第15讲"><a class="markdownIt-Anchor" href="#视觉第15讲"></a> <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC15%E8%AE%B2/">视觉第15讲</a></h2>
<h2 id="视觉第16讲"><a class="markdownIt-Anchor" href="#视觉第16讲"></a> <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC16%E8%AE%B2/">视觉第16讲</a></h2>
<h2 id="视觉第17讲"><a class="markdownIt-Anchor" href="#视觉第17讲"></a> <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC17%E8%AE%B2/">视觉第17讲</a></h2>
<h2 id="视觉第18讲"><a class="markdownIt-Anchor" href="#视觉第18讲"></a> <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC18%E8%AE%B2/">视觉第18讲</a></h2>
<h2 id="视觉第19讲"><a class="markdownIt-Anchor" href="#视觉第19讲"></a> <a href="/2020/03/30/%E8%A7%86%E8%A7%89%E7%AC%AC19%E8%AE%B2/">视觉第19讲</a></h2>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计安导第9章</title>
    <url>/2020/03/30/%E8%AE%A1%E5%AE%89%E5%AF%BC%E7%AC%AC9%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="策略-模型与信任"><a class="markdownIt-Anchor" href="#策略-模型与信任"></a> 策略、模型与信任</h1>
<h2 id="安全策略"><a class="markdownIt-Anchor" href="#安全策略"></a> 安全策略</h2>
<h3 id="主体"><a class="markdownIt-Anchor" href="#主体"></a> 主体</h3>
<p>是与系统交互的代理</p>
<h3 id="客体"><a class="markdownIt-Anchor" href="#客体"></a> 客体</h3>
<p>是安全策略要保护和管理的信息与计算资源</p>
<h3 id="动作"><a class="markdownIt-Anchor" href="#动作"></a> 动作</h3>
<p>主体对客体可能(或不可能)执行的操作</p>
<h3 id="权限"><a class="markdownIt-Anchor" href="#权限"></a> 权限</h3>
<p>主体、操作与客体之间的映射，权限明确规定允许或禁止哪些操作</p>
<h3 id="保护"><a class="markdownIt-Anchor" href="#保护"></a> 保护</h3>
<p>策略中包含的特定安全特性或规则，以 帮助实现特定的安全目标，如保密性、完整性、可用性或匿 名性。</p>
<h2 id="安全模型"><a class="markdownIt-Anchor" href="#安全模型"></a> 安全模型</h2>
<p>是一种抽象的、为管理员指定安全策略提供 概念语言。</p>
<p>通常定义了</p>
<ol>
<li>组织成员所拥有的访问或修改权限的层次结构</li>
</ol>
<h2 id="自主访问控制-dac"><a class="markdownIt-Anchor" href="#自主访问控制-dac"></a> 自主访问控制 DAC</h2>
<p>指的是赋予用户能力确定文件访 问权限的一种方案。</p>
<ol>
<li>允许用户根据用户和组设置访问控制措施。</li>
<li>允许用户将资源特权授予同一系统上的其他用户。</li>
</ol>
<h2 id="强制访问控制-mac"><a class="markdownIt-Anchor" href="#强制访问控制-mac"></a> 强制访问控制 MAC</h2>
<ol>
<li>不允许用户定义文件的权限.</li>
<li>而是由中央策略管理员制定安全策略。</li>
<li>每个安全规则都由主体、客体和一系列的权限组成。其中主体是获得权限的的一方，客体是被访问的资源。</li>
</ol>
<h2 id="信任管理系统"><a class="markdownIt-Anchor" href="#信任管理系统"></a> 信任管理系统</h2>
<h2 id="组成包括"><a class="markdownIt-Anchor" href="#组成包括"></a> 组成包括</h2>
<ol>
<li><strong>策略语言</strong></li>
<li><strong>一致性检查器</strong></li>
<li>策略规则由策略语言指定，并由一致性检查器执行</li>
</ol>
<h2 id="规则包括"><a class="markdownIt-Anchor" href="#规则包括"></a> 规则包括</h2>
<ol>
<li>操作 与系统安全相关的结果</li>
<li>主题 可以在系统 上执行操作的用户、进程或其他实体</li>
<li>策略 就是制定的规 则，制定赋予主体哪些权限，能执行那些操作</li>
<li>凭证 数字签名 的文件，将主体身份与允许的行 为绑定，包括允许主体将权限委 托给其他主体的权限</li>
</ol>
<h1 id="访问控制模型"><a class="markdownIt-Anchor" href="#访问控制模型"></a> 访问控制模型</h1>
<h2 id="bell-la-padula模型"><a class="markdownIt-Anchor" href="#bell-la-padula模型"></a> Bell-La Padula模型</h2>
<p>强制访问控制模型，保护机密性</p>
<h3 id="全序和偏序"><a class="markdownIt-Anchor" href="#全序和偏序"></a> 全序和偏序</h3>
<ol>
<li>全序：自反，反对称，传递，完全性(如果x和y在U中，则x ≤ y 或 y ≤ x)</li>
<li>偏序：去掉完全性</li>
</ol>
<h3 id="blp-工作原理"><a class="markdownIt-Anchor" href="#blp-工作原理"></a> BLP 工作原理</h3>
<ol>
<li>原则：信息只能从低安全级别流向高安全级别。</li>
<li>安全级别是偏序的</li>
<li>每个对象x被分配到一个安全级别L(X)。同样，每个用户u被分配到 安全级别L(U)。用户对象的访问受以下两条规则控制：
<ol>
<li>简单安全性质：只有满足L(x) ≼ L(u)，用户u才能读取对象x：即<strong>不可向上读</strong></li>
<li>性质只有满足L(u) ≼ L(x)，用户u才能写入（创建、编 辑或追加）对象x：即<strong>不可向下写</strong></li>
</ol>
</li>
</ol>
<h2 id="biba模型"><a class="markdownIt-Anchor" href="#biba模型"></a> Biba模型</h2>
<ol>
<li>Biba模型的完整性级别表明对象和用户的可信度或准确度。</li>
<li>Biba 不允许从下一级阅读，也不允许写到上层。</li>
</ol>
<h3 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h3>
<p>如果让I(u)表示用户u的完整性级别，I(x)表示对象x的完整性级别， 则Biba模型中有以下规则：</p>
<ol>
<li>原则：信息只能从较高的完整性级别下降 到较低的完整性级别</li>
<li>用户u只能在I(u) ≼ I(x)情况下读取对象x：</li>
<li>用户u只能在I(x) ≼ I(u)情况下才能写入(创建、编辑或追加)一个对象x</li>
</ol>
<h2 id="低水印模型"><a class="markdownIt-Anchor" href="#低水印模型"></a> 低水印模型</h2>
<p>扩展的Biba模型，放宽了不可想下读的限制。</p>
<ol>
<li>原则 具有较高完整性级别的用户可以读取完整性级别较低 的对象。</li>
<li>在这样的读取之后，对执行读取的用户进行降级，使其完整性级别 与所读取对象的完整性级别相匹配。</li>
</ol>
<h2 id="克拉克-威尔逊模型"><a class="markdownIt-Anchor" href="#克拉克-威尔逊模型"></a> 克拉克-威尔逊模型</h2>
<p>用于处理执行事务的系统。关键组件包括</p>
<ol>
<li>完整性约束：表明为了保证系统的状态有效，各对象之间必须满足的关系。</li>
<li>认证方法：验证事务给定的完整性约束。一旦认证了事务的程序，每 次执行事务时，则不必再次进行完整性约束验证。</li>
<li>职责分离原则：防止执行事务的用户验证事务。通常，每个事务都被 分配给可以分别验证和执行事务的不相交的用户集。</li>
</ol>
<h2 id="中国墙模型"><a class="markdownIt-Anchor" href="#中国墙模型"></a> 中国墙模型</h2>
<p>被设计用于商业领域， 以消除利益冲突的可能性。</p>
<ol>
<li>讲资源分组为利益冲突类</li>
<li>每个用户只能从每个利益冲突类访问一个资源。</li>
</ol>
<h2 id="基于角色的访问控制-rbac"><a class="markdownIt-Anchor" href="#基于角色的访问控制-rbac"></a> 基于角色的访问控制 RBAC</h2>
<h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3>
<ol>
<li>便于组织授权管理</li>
<li>支持继承</li>
<li>便于实现最小特权原则</li>
<li>可实现指责隔离原则</li>
<li>支持客体抽象</li>
<li>策略中立，通过不同配置能够实现特殊策略</li>
</ol>
<h3 id="核心概念"><a class="markdownIt-Anchor" href="#核心概念"></a> 核心概念</h3>
<ol>
<li>用户：需要访问组织的资源以执行任务的实体</li>
<li>角色：组织中具有类似功能和职责的用户的集合</li>
<li>权限：权限描述了允许访问资源的方法。</li>
<li>会话：由为执行特定任务而激活用户角色的子集组成。</li>
</ol>
<h3 id="分级rbac"><a class="markdownIt-Anchor" href="#分级rbac"></a> 分级RBAC</h3>
<ol>
<li>定义：色R1继承（inherits）R2，如果R1包含R2的所有权限，R2包括 R1的所有用户，可以表示为R1 ≽ R2。称R1为R2的上一层。</li>
</ol>
<h1 id="渗透测试"><a class="markdownIt-Anchor" href="#渗透测试"></a> 渗透测试</h1>
<h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2>
<ol>
<li>
<p>渗透测试：从攻击者(黑客)的角度测试系统和体系结构的安全性，在 固定时间内必须获得的具有预定目标的“模拟攻击”</p>
<ol>
<li>组我欸其他安全措施的补充</li>
<li>花销大</li>
</ol>
</li>
<li>
<p>流程：</p>
<ol>
<li>收集信息
<ol>
<li>IP地址信息</li>
<li>个人信息</li>
</ol>
</li>
<li>扫描IP：给定一组IP地址，确定每个服务和操作系统都在运行</li>
<li>识别系统：通过扫描开放电脑的网络连接端，确定哪些服务运行在哪些连接端，并且推断计算机运行哪个操作系统</li>
<li>识别易受攻击的服务：给定特定的IP地址和端口，尝试获得对机器 的访问权限。报告此目标的所有已知漏洞</li>
<li>利用漏洞</li>
</ol>
</li>
</ol>
<h1 id="kerberos"><a class="markdownIt-Anchor" href="#kerberos"></a> Kerberos</h1>
<ol>
<li>Kerberos：基于可信第三方（Trusted Third Party， TTP）的身份认证协议；</li>
<li>旨在对整个网络进行集中身份验证，而不是在每个用户计算机上存储敏感的身份验证信息。</li>
</ol>
<h2 id="身份验证"><a class="markdownIt-Anchor" href="#身份验证"></a> 身份验证</h2>
<ol>
<li>
<p>在身份验证过程中，客户端收到两个票据</p>
<ol>
<li>票据授予票据（TGT）：用户和会话密钥的全局标识符。</li>
<li>服务票据（service ticket）：对用户进行身份验证，确定用户能否 使用特殊服务。</li>
<li>票据都有时间戳，用于标明数据的有效期限</li>
</ol>
</li>
<li>
<p>密钥分发中心 KDC 组成</p>
<p>为了实现安全的身份验证</p>
<ol>
<li>身份验证服务器(AS):用于执行用户身份验证。维护存储用户和服务密钥的数据库。对用户提供的密码执行单向散列来生成用户的密钥。</li>
<li>票据授予服务器(TGS):用于向用户授予票据</li>
</ol>
</li>
</ol>
<h3 id="身份认证过程"><a class="markdownIt-Anchor" href="#身份认证过程"></a> 身份认证过程</h3>
<p>概括的说</p>
<ol>
<li>客户端与AS互相进行身份验证</li>
<li>客户端与TGS互相进行身份验证</li>
<li>客户端与服务S互相进行身份验证，为客户端提供服务</li>
</ol>
<p>具体</p>
<ol>
<li>用户输入的密码经过哈希散列形成客户端密钥Kc</li>
<li>客户端与AS联系，AS执行
<ol>
<li>
<p>使用客户端密钥Kc加密客户端-TGS的会话密钥K<sub>CT</sub></p>
</li>
<li>
<p>使用TGS的密钥K<sub>T</sub>加密票据授予票据TGT。TGT中包含K<sub>CT</sub>和有效期。</p>
</li>
<li>
<p>客户端使用Kc解密TGS会话密钥K<sub>CT</sub>。之后，客户端向TGS发送如下两个消息：</p>
<ol>
<li>TGT 和 所请求服务名称S</li>
<li>验证令牌 有用户ID和时间戳组成，使用客户端TGS会话密钥K<sub>CT</sub>进行加密</li>
</ol>
</li>
<li>
<p>.TGS使KT解密TGS，从而得到客户端TGS的会话密钥K<sub>CT</sub>和TGT的 有效期。在有效期之内，TGS使用密钥K<sub>CT</sub>解密身份验证令牌，向客 户端发送如下两个消息：</p>
<ol>
<li>使用K<sub>CT</sub>加密的新的客户端-服务器会话密K<sub>CS</sub>。</li>
<li>使用具体服务的密钥KS加密客户端-服务器票据（client-server ticket），其中 TGS已知密钥KS 。票据包含客户端ID、网络地址、有效期、密钥K<sub>CS</sub>。</li>
</ol>
</li>
<li>
<p>在对客户端-服务器会话密钥K<sub>CS</sub>解密后，为了使服务对客户端进行身份验证，客户端发送以下两个消息：</p>
<ol>
<li>在上个步骤中，TGS发送的客户端-服务器的票据。</li>
<li>使用K<sub>CS</sub>加密的客户端ID和时间戳。</li>
</ol>
</li>
<li>
<p>服务使用自己的密钥KS解密客户端-服务器的票据，得到客户端-服 务器的会话密钥K<sub>CS</sub> 。使用K<sub>CS</sub>解密客户端ID和时间戳。最后，为了向客户端证码自己的身份，它使用时间戳加1，并用K<sub>CS</sub>重新加密送回客户端。</p>
</li>
<li>
<p>客户端使用KCS解密并验证这个响应，如果验证成功，就可以开始 客户端-服务器的会话了。</p>
</li>
<li>
<p>票据有效期内，客户端为了访问多个服务，可以一直重复3-7步。</p>
</li>
</ol>
</li>
</ol>
<h3 id="优点-2"><a class="markdownIt-Anchor" href="#优点-2"></a> 优点</h3>
<ol>
<li>分布式体系结构，可以在不安全的网络中使用。</li>
<li>由于每次传输都使用适当的密钥进行加密，攻击者在不能破解密 钥或底层的加密算法的情况下，无法伪造有效的票据来获得对未 授权服务的访问。</li>
<li>可防止重放攻击，因为不接受未授权方重传的消息。</li>
<li>使用对称加密，所以比较高效</li>
</ol>
<h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3>
<ol>
<li>存在单点故障问题：密钥分发中心不可用</li>
<li>如果KDC被破坏，在每个客户端和服务器的身法验证信息都被泄漏</li>
<li>需要所有参与方都有同步的时钟</li>
</ol>
<h1 id="安全存储"><a class="markdownIt-Anchor" href="#安全存储"></a> 安全存储</h1>
<h2 id="安全保护措施"><a class="markdownIt-Anchor" href="#安全保护措施"></a> 安全保护措施</h2>
<ol>
<li>保存好U盘手机</li>
<li>防范窃取数据的恶意软件</li>
<li>合理处置废旧设备</li>
<li>备份</li>
<li>云存储</li>
</ol>
<h2 id="文件密码保护"><a class="markdownIt-Anchor" href="#文件密码保护"></a> 文件密码保护</h2>
<p>保护信息的一种方法就是对文件进行加密，在密码算法没有在理论破解或密钥泄露的情况下，即使文件被盗，也不用担心信息会泄露。</p>
<ol>
<li>
<p>常见密码算法</p>
 <img src="/计安导_img/25.png">
</li>
</ol>
<h3 id="加密文件系统-efs"><a class="markdownIt-Anchor" href="#加密文件系统-efs"></a> 加密文件系统 EFS</h3>
<ol>
<li>
<p>特点</p>
<ol>
<li>自动加密解密</li>
<li>保护文件内容，而不保护文件名和其他元数据</li>
<li>支持共享加密文件</li>
</ol>
</li>
<li>
<p>缺点</p>
<ol>
<li>只保护本地文件系统，所以传送到其他文件系统会被破解</li>
<li>临时文件不受保护</li>
<li>密钥管理很麻烦</li>
</ol>
</li>
<li>
<p>加密技术：同时使用对称和非对称加密</p>
 <img src="/计安导_img/26.png">
<ol>
<li>加密时首先使用AES(对称)单独的加密密钥FEK加密每个文件</li>
<li>然后使用FEK加密数据</li>
<li>再用用户的RSA(非对称)的公钥加密FEK，并保存文件的元数据。</li>
<li>解密时首先用用户的私钥解密FEK</li>
<li>然后再用FEK解密数据</li>
<li>注：每个用户对应一个经过公钥加密的FEK</li>
</ol>
</li>
</ol>
<h2 id="磁盘加密"><a class="markdownIt-Anchor" href="#磁盘加密"></a> 磁盘加密</h2>
<h3 id="truecrypt"><a class="markdownIt-Anchor" href="#truecrypt"></a> TrueCrypt</h3>
<ol>
<li>以分区为基础</li>
<li>所有加密数据都是经过AES等加密算法，难以破解</li>
<li>加密过程自动透明</li>
<li>提供两级方案</li>
</ol>
<h3 id="bitlocker"><a class="markdownIt-Anchor" href="#bitlocker"></a> BitLocker</h3>
<ol>
<li>使用AES对扇区进行加密</li>
<li>使用NTFS格式的卷</li>
<li>可以通过冷启动攻击：属于一种边信道攻击方法，可 以物理接触到计算机的攻击者能够运用这种攻击手段 在冷启动或硬盘重启之后，比如计算机没经历正常的 关机过程就突然重启时，从计算机的内存(RAM)中获 取加密密钥、口令和其他数据。断电后内存中的数据 能维持几十秒或数分钟，但通过液氮或压缩空气冷冻 ，这一数据衰减过程可被攻击者拉长至数小时之久。</li>
</ol>
<h2 id="可信平台模块-tpm"><a class="markdownIt-Anchor" href="#可信平台模块-tpm"></a> 可信平台模块 TPM</h2>
<p>是设计安装在主板上的芯片 ，作为安全密码处理器，它能安全地生成和存储密 钥。在生产时，将一个唯一地RSA私钥铸入到每一 个TPM芯片中。TPM的设计是防篡改的，所以，能 进行物理访问的攻击者也很难恢复这个密钥。</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>邮件传输代理的交互</title>
    <url>/2020/03/30/%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93%E4%BB%A3%E7%90%86%E7%9A%84%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<h1 id="uva-814-邮件传输代理的交互"><a class="markdownIt-Anchor" href="#uva-814-邮件传输代理的交互"></a> uva 814 邮件传输代理的交互</h1>
<p> 本题的任务为模拟发送邮件时MTA（邮件传输代理）之间的交互。所谓MTA，就是email地址格式user@mtaname的“后面部分”。当某人从user1@mta1发送给另一个人user2@mta2时，这两个MTA将会通信。如果两个收件人属于同一个MTA，发送者的MTA只需与这个 MTA通信一次就可以把邮件发送给这两个人。</p>
<p> 输入每个MTA里的用户列表，对于每个发送请求（输入发送者和接收者列表），按顺序 输出所有MTA之间的SMTP（简单邮件协议）交互。协议细节参见原题。</p>
<p> 发送人MTA连接收件人MTA的顺序应该与在输入中第一次出现的顺序一致。例如，若 发件人是Hamdy@Cairo，收件人列表为Conrado@MexicoCity、Shariff@SanFrancisco、 Lisa@MexicoCity，则Cairo应当依次连接MexicoCity和SanFrancisco。 如果连接某个MTA之后发现所有收件人都不存在，则不应该发送DATA。所有用户名均由不超过15个字母和数字组成。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>首先考虑输入过程，可以选择用map&lt;string,vector<string>&gt;来存用户列表；也可以选择用set<string>来存，值就是邮件地址。</li>
<li>对于每个请求，首先读入发件人，分离出MTA和用户名，然后读取收件人，根据MTA出现的先后顺序进行保存，并且去掉重复。</li>
<li>接下来读入邮件正文，最后按顺序依次连接每个MTA，检查并输出每个收件人是否存在，如果至少有一个存在，则输出邮件正文。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   #include&lt;iostream&gt;</span><br><span class="line">   #include&lt;string&gt;</span><br><span class="line">   #include&lt;map&gt;</span><br><span class="line">   #include&lt;set&gt;</span><br><span class="line">   #include&lt;vector&gt;</span><br><span class="line">   using namespace std;</span><br><span class="line"></span><br><span class="line">   void pare_address(const string s, string &amp;user, string &amp;mta) &#123;</span><br><span class="line">   	int k &#x3D; s.find(&#39;@&#39;);</span><br><span class="line">   	user &#x3D; s.substr(0, k);</span><br><span class="line">   	mta &#x3D; s.substr(k + 1);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">string s;</span><br><span class="line">set&lt;string&gt; addr;&#x2F;&#x2F;存每个mta对应用户的列表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string user1, mta1;</span><br><span class="line">while (cin &gt;&gt; s &amp;&amp; s !&#x3D; &quot;*&quot;) &#123;</span><br><span class="line">	int k;</span><br><span class="line">	string loc;</span><br><span class="line">	cin &gt;&gt; s &gt;&gt; k;</span><br><span class="line">	while (k--) &#123;</span><br><span class="line">		cin &gt;&gt; loc;</span><br><span class="line">		addr.insert(loc + &quot;@&quot; + s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;&#x2F;&#x2F;输入完成</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;处理发送地址和接收地址</span><br><span class="line">string sender;</span><br><span class="line">while (cin &gt;&gt; sender &amp;&amp; sender !&#x3D; &quot;*&quot;) &#123;</span><br><span class="line"></span><br><span class="line">	pare_address(sender, user1, mta1);</span><br><span class="line">	vector&lt;string&gt; mta;&#x2F;&#x2F;按序存需要连接的mta</span><br><span class="line">	map&lt;string, vector&lt;string&gt;&gt; dest;&#x2F;&#x2F;存每个mta要发送的用户</span><br><span class="line">	set&lt;string&gt; vis;&#x2F;&#x2F;用来去除重复收件人</span><br><span class="line"></span><br><span class="line">	while (cin &gt;&gt; s &amp;&amp; s !&#x3D; &quot;*&quot;) &#123;</span><br><span class="line">		string user2, mta2;</span><br><span class="line">		pare_address(s, user2, mta2);</span><br><span class="line"></span><br><span class="line">		if (vis.count(s)) continue;&#x2F;&#x2F;重复收件人</span><br><span class="line">		vis.insert(s);</span><br><span class="line">		if (!dest.count(mta2)) &#123;&#x2F;&#x2F;如果不是重复的要连接的mta</span><br><span class="line">			mta.push_back(mta2);</span><br><span class="line">			dest[mta2] &#x3D; vector&lt;string&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">		dest[mta2].push_back(s);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	getline(cin, s);&#x2F;&#x2F;把“*”这一行的回车吃掉</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;输入正文</span><br><span class="line">	string data;</span><br><span class="line">	while (getline(cin, s) &amp;&amp; s[0] !&#x3D; &#39;*&#39;)	data +&#x3D; &quot;     &quot; + s + &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">	for (int i &#x3D; 0; i &lt; mta.size(); i++) &#123;</span><br><span class="line">		string mta2 &#x3D; mta[i];&#x2F;&#x2F;mta2遍历要连接的mta</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; &quot;Connection between &quot; &lt;&lt; mta1 &lt;&lt; &quot; and &quot; 	&lt;&lt; mta2 &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;     HELO &quot; &lt;&lt; mta1 &lt;&lt; endl &lt;&lt; &quot;     250\n&quot;;</span><br><span class="line">		cout &lt;&lt; &quot;     MAIL FROM:&lt;&quot; &lt;&lt; sender &lt;&lt; &quot;&gt;&quot; &lt;&lt; endl &lt;&lt; &quot;     250&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		vector&lt;string&gt; users &#x3D; dest[mta2];</span><br><span class="line">		</span><br><span class="line">		bool ok &#x3D; false;</span><br><span class="line">		for (int j &#x3D; 0; j &lt; users.size(); j++) &#123;</span><br><span class="line">		&#x2F;&#x2F;遍历当前连接的mta2下要发送的用户列表</span><br><span class="line">			cout &lt;&lt; &quot;     RCPT TO:&lt;&quot; &lt;&lt; users[j] &lt;&lt; &quot;&gt;&quot; &lt;&lt; endl;</span><br><span class="line">			if (addr.count(users[j])) &#123;</span><br><span class="line">				ok &#x3D; true;</span><br><span class="line">				cout &lt;&lt; &quot;     250&quot; &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				cout &lt;&lt; &quot;     550&quot; &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (ok) &#123;</span><br><span class="line">			cout &lt;&lt; &quot;     DATA&quot; &lt;&lt; endl &lt;&lt; &quot;     354&quot; &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; data &lt;&lt; &quot;     .&quot; &lt;&lt; endl &lt;&lt; &quot;     250&quot; &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; &quot;     QUIT&quot; &lt;&lt; endl &lt;&lt; &quot;     221&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<ol>
<li>学习拆分用户和地址时的引用传递</li>
<li>存一对多关系的时候可以用map+vector</li>
<li>去重时可以考虑多加一个容器，不要仅仅因为不能重复，就断定用set存一些数据</li>
<li>向量能保持原序，set能避免重复，map能得到对应关系</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>防线</title>
    <url>/2020/03/30/%E9%98%B2%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="uva-1471-防线"><a class="markdownIt-Anchor" href="#uva-1471-防线"></a> UVA 1471 防线</h1>
<p>给一个长度为 n(n≤200000)的序列，你的任务是删除一个连续子序列，使得剩下的序列中有一个长度最大的连续递增子序列。例如，将序列{5,3,4,9,2,8,6,7,1}中的{9,2,8}删除，得到的序列{5,3,4,6,7,1}中包含一个长度为4的连续递增子序列{3,4,6,7}。序列中每个数均为不超过 10^9的正整数。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>最直观的，枚举i和j，对于所有满足A[j]&lt;A[i]的分别向左右扩展，统计有序序列能扩展多长，复杂度O(n<sup>3</sup>)</li>
<li>可以预先计算出以第i个元素为起点的最长序列长f(i)以及以第i个元素为终点的最长序列长g(i)。然后枚举i,j，对于满足A[j]&lt;A[i]的ij，答案为g[j]+f[i]。复杂度O(n<sup>2</sup>)，可惜仍然超时了…</li>
<li>枚举i是必须的。但是随着i的向后移动，不是所有的j都是有用的了。所以可以首先排除一些肯定不是最优值的j。例如，若有j’满足A[j’]&lt;=A[j]且g(j’)&gt;g(j)，则j不是最优的，因为j’不仅是一个更长的序列的末尾，而且它还更容易插入。因此，操作涉及动态维护一个有序表，涉及大量插入删除，所以不能用排序加二分查找，而选择使用set。</li>
<li>具体实现时，应该首先找到这个元素的插入位置，根据插入位置前一个元素判断是否需要保留。如果需要保留，还要将插入位置后面的不可能成为最优解的元素删除掉。插入删除查询都是set的操作，复杂度都为O(logn)，总的时间复杂度为O(nlogn)。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="get_fg-填充f-g数组"><a class="markdownIt-Anchor" href="#get_fg-填充f-g数组"></a> get_fg 填充f g数组</h2>
<h3 id="迭代写法更快-440ms"><a class="markdownIt-Anchor" href="#迭代写法更快-440ms"></a> 迭代写法(更快) 440ms</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void get_fg() &#123;</span><br><span class="line">	g[0] &#x3D; 1;</span><br><span class="line">	for (int i &#x3D; 1; i &lt; n; i++)</span><br><span class="line">		if (in[i - 1] &lt; in[i]) g[i] &#x3D; g[i - 1] + 1;</span><br><span class="line">		else g[i] &#x3D; 1;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; f[i] is the length of longest increasing continuous subsequence starting from i</span><br><span class="line">	f[n - 1] &#x3D; 1;</span><br><span class="line">	for (int i &#x3D; n - 2; i &gt;&#x3D; 0; i--)</span><br><span class="line">		if (in[i] &lt; in[i + 1]) f[i] &#x3D; f[i + 1] + 1;</span><br><span class="line">		else f[i] &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="直接写的-460ms"><a class="markdownIt-Anchor" href="#直接写的-460ms"></a> 直接写的 460ms</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">void get_fg() &#123;</span><br><span class="line">memset(f, 0, sizeof(f));</span><br><span class="line">memset(g, 0, sizeof(g));</span><br><span class="line">int beg &#x3D; 0;</span><br><span class="line">for (int last &#x3D; 1; last &lt; n; last++) &#123;</span><br><span class="line">	g[last - 1] &#x3D; last - beg;</span><br><span class="line">	if (in[last] &lt;&#x3D; in[last - 1]) &#123;</span><br><span class="line">		for (; beg &lt; last; beg++)</span><br><span class="line">			f[beg] &#x3D; last - beg;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!g[n - 1]) g[n - 1] &#x3D; n - beg;</span><br><span class="line">for (; beg &lt; n; beg++)</span><br><span class="line">	f[beg] &#x3D; n - beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="solve-枚举i动态修改有序表计算j"><a class="markdownIt-Anchor" href="#solve-枚举i动态修改有序表计算j"></a> solve 枚举i动态修改有序表计算j</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int solve() &#123;</span><br><span class="line">	get_fg();</span><br><span class="line">	int ans &#x3D; 1;</span><br><span class="line">	s.clear();</span><br><span class="line">	s.insert(node(in[0], g[0]));</span><br><span class="line">	for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">		node c (in[i], g[i]);</span><br><span class="line">		set&lt;node&gt; ::iterator it &#x3D; s.lower_bound(c);</span><br><span class="line">		bool keep &#x3D; true;</span><br><span class="line">		if (it !&#x3D; s.begin()) &#123;</span><br><span class="line">			node last &#x3D; *(--it);</span><br><span class="line">			int len &#x3D; f[i] + last.v;</span><br><span class="line">			ans &#x3D; max(ans, len);</span><br><span class="line">			if (c.v &lt;&#x3D; last.v) keep &#x3D; false;</span><br><span class="line">		&#125;</span><br><span class="line">		if (keep) &#123;</span><br><span class="line">			s.erase(c);</span><br><span class="line">			s.insert(c);</span><br><span class="line">			it &#x3D; s.find(c);</span><br><span class="line">			it++;</span><br><span class="line">			while (it !&#x3D; s.end() &amp;&amp; it-&gt;num &gt; c.num&amp;&amp;it-&gt;v &lt;&#x3D; c.v)</span><br><span class="line">				s.erase(it++);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a class="markdownIt-Anchor" href="#main"></a> main</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const int maxn &#x3D; 200005;</span><br><span class="line">int in[maxn];</span><br><span class="line">int g[maxn], f[maxn];&#x2F;&#x2F;g(i)表示以第i个元素结尾的最长序列长度，f(i)表示以第i个元素开始最长序列长度</span><br><span class="line">struct node &#123;</span><br><span class="line">	int v, num;</span><br><span class="line">	node(int num, int v) :num(num), v(v) &#123;&#125;</span><br><span class="line">	bool operator &lt; (const node&amp;a) const &#123; return num &lt; a.num; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int n;</span><br><span class="line">set&lt;node&gt; s;</span><br><span class="line"></span><br><span class="line">inline void get_fg();</span><br><span class="line">inline int solve();</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">			scanf(&quot;%d&quot;, &amp;in[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		if (n &#x3D;&#x3D; 1) &#123; printf(&quot;1\n&quot;); continue; &#125;</span><br><span class="line">		printf(&quot;%d\n&quot;, solve());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2020/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1>
<h2 id="基本术语"><a class="markdownIt-Anchor" href="#基本术语"></a> 基本术语</h2>
<ol>
<li><strong>链路</strong>：从一个结点到另一个结点的一段<strong>物理线路</strong>。中间没有任何其他交点。</li>
<li><strong>ISP</strong>：因特网服务提供者（提供商）</li>
<li><strong>IXP</strong>：互联网交换点<strong>IXP的主要作用就是允许两个网络直接相连并交换分组</strong>，而不需要再通过第三个网络来转发分组。</li>
<li><strong>RFC</strong>：意思是“请求评议”，包含了关于Internet几乎所有的重要的文字资料。</li>
<li><strong>城域网</strong>：将多个局域网连接起来</li>
<li><strong>广域网</strong>：通过长距离运送主机的数据</li>
<li><strong>分组</strong>：因特网中传送的数据单元。由首部header和数据段组成。分组又称为包，首部可称为包头。</li>
<li><strong>存储转发</strong>：路由器收到一个分组，先存储下来，再检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去。</li>
<li><strong>带宽</strong>：在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为b/s。</li>
<li><strong>吞吐量</strong>：表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。</li>
</ol>
<h2 id="主机之间的通信方式"><a class="markdownIt-Anchor" href="#主机之间的通信方式"></a> 主机之间的通信方式</h2>
<ul>
<li>客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。</li>
<li>对等（P2P）：不区分客户和服务器。</li>
</ul>
<h2 id="电路交换与分组交换"><a class="markdownIt-Anchor" href="#电路交换与分组交换"></a> 电路交换与分组交换</h2>
<h3 id="电路交换"><a class="markdownIt-Anchor" href="#电路交换"></a> 电路交换</h3>
<p>电路交换用于电话通信系统，两个用户要通信之前需要建立一条<strong>专用的物理链路</strong>，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%</p>
<h3 id="分组交换"><a class="markdownIt-Anchor" href="#分组交换"></a> 分组交换</h3>
<ul>
<li>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是<strong>说分组交换不需要独占传输线路。</strong></li>
<li>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，<strong>分组交换也使用了存储转发过程</strong></li>
</ul>
<h2 id="时延"><a class="markdownIt-Anchor" href="#时延"></a> 时延</h2>
<p><strong>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</strong></p>
<h3 id="排队时延"><a class="markdownIt-Anchor" href="#排队时延"></a> 排队时延</h3>
<p>分组<strong>在路由器的输入队列和输出队列中</strong>排队等待的时间，<strong>取决于网络当前的通信量。</strong></p>
<h3 id="处理时延"><a class="markdownIt-Anchor" href="#处理时延"></a> 处理时延</h3>
<p>主机或路由器收到分组时<strong>进行处理所需要的时间</strong>，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</p>
<h3 id="传输时延"><a class="markdownIt-Anchor" href="#传输时延"></a> 传输时延</h3>
<p><strong>主机或路由器传输数据帧所需要的时间</strong></p>
<h3 id="传播时延"><a class="markdownIt-Anchor" href="#传播时延"></a> 传播时延</h3>
<p><strong>电磁波在信道中传播所需要花费的时间</strong>，电磁波传播的速度接近光速</p>
<h2 id="计算机网络体系结构"><a class="markdownIt-Anchor" href="#计算机网络体系结构"></a> 计算机网络体系结构</h2>
<h3 id="五层协议"><a class="markdownIt-Anchor" href="#五层协议"></a> 五层协议</h3>
<ul>
<li><strong>应用层</strong> ：<strong>为特定应用程序提供数据传输服务</strong>，例如 HTTP、DNS 等协议。数据单位为报文。</li>
<li><strong>传输层</strong> ：<strong>为进程提供通用数据传输服务</strong>。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：
<ul>
<li>传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为<strong>报文段</strong>；</li>
<li>用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为<strong>用户数据报</strong>。</li>
<li>TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li>
</ul>
</li>
<li><strong>网络层</strong> ：<strong>为主机提供数据传输服务</strong>。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成<strong>分组</strong>。</li>
<li><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而<strong>主机之间可以有很多链路</strong>，<strong>链路层协议就是为同一链路的主机提供数据传输服务</strong>。数据链路层把网络层传下来的分组封装成<strong>帧</strong>。</li>
<li><strong>物理层</strong> ：考虑的是怎样<strong>在传输媒体上传输数据比特流</strong>，而不是指具体的传输媒体。物理层的作用是<strong>尽可能屏蔽传输媒体和通信手段的差异</strong>，使数据链路层感觉不到这些差异。</li>
</ul>
<h3 id="osi"><a class="markdownIt-Anchor" href="#osi"></a> OSI</h3>
<p>其中表示层和会话层用途如下：</p>
<ul>
<li><strong>表示层</strong> ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li>
<li><strong>会话层</strong> ：建立及管理会话。</li>
</ul>
<p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p>
<h3 id="tcpip"><a class="markdownIt-Anchor" href="#tcpip"></a> TCP/IP</h3>
<p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p>
<p>TCP/IP 体系结构不严格遵循 OSI 分层概念，<strong>应用层可能会直接使用 IP 层或者网络接口层。</strong></p>
<h3 id="数据在各层之间的传递过程"><a class="markdownIt-Anchor" href="#数据在各层之间的传递过程"></a> 数据在各层之间的传递过程</h3>
<p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p>
<p><strong>路由器只有下面三层协议</strong>，因为<strong>路由器位于网络核心中</strong>，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p>
<h1 id="物理层"><a class="markdownIt-Anchor" href="#物理层"></a> 物理层</h1>
<h2 id="基本术语-2"><a class="markdownIt-Anchor" href="#基本术语-2"></a> 基本术语</h2>
<ol>
<li>
<p><strong>信号</strong>：数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。</p>
<ul>
<li>通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。<strong>信号则是数据的电器或电磁的表现</strong>。</li>
</ul>
</li>
<li>
<p><strong>码元</strong>：在使用时间域（或简称为时域）的波形来表示数字信号时，<strong>代表不同离散数值的基本波形。</strong></p>
</li>
<li>
<p><strong>奈氏准则</strong>：在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。</p>
</li>
<li>
<p><strong>基带信号</strong>：来自信源的信号。指<strong>没有经过调制的</strong>数字信号或模拟信号。</p>
</li>
<li>
<p><strong>带通（频带）信号</strong>：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），这里调制过后的信号就是带通信号。</p>
<ul>
<li>带通调制方法有调幅，调频和调相。还有更复杂的调制方法，如正交振幅调制。</li>
</ul>
</li>
<li>
<p><strong>信噪比</strong>：指信号的平均功率和噪声的平均功率之比，记为S/N。</p>
<p>​				$$信噪比(dB)=10*log10（S/N）$$</p>
</li>
<li>
<p><strong>比特率 &amp; 波特率</strong></p>
<ul>
<li><strong>比特率</strong>：单位时间（每秒）内传送的比特数。</li>
<li><strong>波特率</strong>：单位时间载波调制状态改变的次数。针对数据信号对载波的调制速率。</li>
</ul>
</li>
</ol>
<h2 id="物理层的任务"><a class="markdownIt-Anchor" href="#物理层的任务"></a> 物理层的任务</h2>
<ol>
<li>物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。</li>
<li><strong>透明地传送比特流</strong>。现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而且通信手段也有许多不同的方式。物理层的作用正是尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么</li>
</ol>
<h2 id="通信方式"><a class="markdownIt-Anchor" href="#通信方式"></a> 通信方式</h2>
<ul>
<li>单工通信：单向传输</li>
<li>半双工通信：双向交替传输</li>
<li>全双工通信：双向同时传输</li>
</ul>
<h2 id="传输媒体"><a class="markdownIt-Anchor" href="#传输媒体"></a> 传输媒体</h2>
<h3 id="导引型传输媒体"><a class="markdownIt-Anchor" href="#导引型传输媒体"></a> 导引型传输媒体</h3>
<p>双绞线、同轴电缆、光纤</p>
<h3 id="非导引型传输媒体"><a class="markdownIt-Anchor" href="#非导引型传输媒体"></a> 非导引型传输媒体</h3>
<p>天线、红外、大气激光</p>
<h2 id="带通调制"><a class="markdownIt-Anchor" href="#带通调制"></a> 带通调制</h2>
<p>模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。</p>
<h2 id="常用的宽带接入方式"><a class="markdownIt-Anchor" href="#常用的宽带接入方式"></a> 常用的宽带接入方式</h2>
<ol>
<li><strong>非对称数字用户线ADSL</strong>：用数字技术对现有的模拟电话线进行改造，而不需要重新布线。ASDL的快速版本是甚高速数字用户线VDSL。</li>
<li><strong>光纤同轴混合网HFC</strong>：是在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网。</li>
<li><strong>FTTx</strong></li>
</ol>
<h1 id="链路层"><a class="markdownIt-Anchor" href="#链路层"></a> 链路层</h1>
<h2 id="相关术语"><a class="markdownIt-Anchor" href="#相关术语"></a> 相关术语</h2>
<ol>
<li><strong>数据链路</strong>：把实现控制数据运输的协议的硬件和软件加到链路上就构成了数据链路</li>
<li><strong>帧</strong>：一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。</li>
<li><strong>MTU</strong>：最大传送单元。帧的数据部分的长度上限。</li>
<li><strong>误码率BER</strong>：在一段时间内，传输错误的比特占所传输比特总数的比率。</li>
<li><strong>PPP点对点协议</strong>：即<strong>用户计算机和ISP</strong>进行通信时所使用的数据链路层协议。</li>
<li><strong>网桥</strong>： 一种<strong>用于数据链路层实现中继，连接两个或多个局域网的网络互连设备。</strong></li>
<li><strong>交换机</strong>：广义的来说，交换机指的是一种通信系统中完成信息交换的设备。这里<strong>工作在数据链路层的交换机指的是交换式集线器，其实质是一个多接口的网桥</strong></li>
</ol>
<h2 id="基本任务"><a class="markdownIt-Anchor" href="#基本任务"></a> 基本任务</h2>
<h3 id="封装成帧"><a class="markdownIt-Anchor" href="#封装成帧"></a> 封装成帧</h3>
<p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p>
<img src="/MyImages/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32396131343733352d653135342d346636302d396130342d6339363238653564303966342e706e67.png" style="zoom: 50%;" />
<h3 id="透明传输"><a class="markdownIt-Anchor" href="#透明传输"></a> 透明传输</h3>
<p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要<strong>在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符</strong>。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，<strong>用户察觉不到转义字符的存在</strong>。</p>
<img src="/MyImages/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65373338613364322d663432652d343735352d616531332d6361323334393765376139372e706e67.png" alt="68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65373338613364322d663432652d343735352d616531332d6361323334393765376139372e706e67" style="zoom:67%;" />
<h3 id="差错检测"><a class="markdownIt-Anchor" href="#差错检测"></a> 差错检测</h3>
<p>目前数据链路层广泛<strong>使用了循环冗余检验（CRC）来检查比特差错</strong>。</p>
<h2 id="信道分类"><a class="markdownIt-Anchor" href="#信道分类"></a> 信道分类</h2>
<h3 id="广播信道"><a class="markdownIt-Anchor" href="#广播信道"></a> 广播信道</h3>
<p>一对多通信，<strong>一个节点发送的数据能够被广播信道上所有的节点接收到</strong>。</p>
<p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，<strong>避免发生冲突</strong>（冲突也叫碰撞）。</p>
<p>主要有两种控制方法进行协调，<strong>一个是使用信道复用技术，一是使用 CSMA/CD 协议。</strong></p>
<h3 id="点对点信道"><a class="markdownIt-Anchor" href="#点对点信道"></a> 点对点信道</h3>
<p>一对一通信。</p>
<p>因为<strong>不会发生碰撞</strong>，因此也比较简单，<strong>使用 PPP 协议进行控制</strong>。</p>
<h2 id="信道复用技术"><a class="markdownIt-Anchor" href="#信道复用技术"></a> 信道复用技术</h2>
<h3 id="频分复用"><a class="markdownIt-Anchor" href="#频分复用"></a> 频分复用</h3>
<p>频分复用的所有主机在相同的时间占用不同的频率带宽资源。</p>
<p><a href="https://camo.githubusercontent.com/59cd8a8923c17c639df4b470814ef443f6a32fb7/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34616135653035372d626335372d343731392d616235372d6336666263383631633530352e706e67" target="_blank" rel="noopener"><img src="/MyImages/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34616135653035372d626335372d343731392d616235372d6336666263383631633530352e706e67" alt="img" style="zoom:50%;" /></a></p>
<h3 id="时分复用"><a class="markdownIt-Anchor" href="#时分复用"></a> 时分复用</h3>
<p>时分复用的所有主机在不同的时间占用相同的频率带宽资源。</p>
<p><a href="https://camo.githubusercontent.com/e48291d4c77069499ab153e8867ffe025499ba23/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36373538326164652d643434612d343661362d383735372d3363313239366363316566392e706e67" target="_blank" rel="noopener"><img src="/MyImages/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36373538326164652d643434612d343661362d383735372d3363313239366363316566392e706e67" alt="img" style="zoom:50%;" /></a></p>
<h3 id="以上两种的效率都不高"><a class="markdownIt-Anchor" href="#以上两种的效率都不高"></a> 以上两种的效率都不高</h3>
<p>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。</p>
<h3 id="统计时分复用"><a class="markdownIt-Anchor" href="#统计时分复用"></a> 统计时分复用</h3>
<p>是对时分复用的一种改进，<strong>不固定每个用户在时分复用帧中的位置</strong>，只要有数据就集中起来组成统计时分复用帧然后发送。</p>
<p><a href="https://camo.githubusercontent.com/328957a040b63d34cb5d34bbaeca59f6d93fdeb5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36323833626532612d383134612d346131302d383462662d3935393235333366653662632e706e67" target="_blank" rel="noopener"><img src="/MyImages/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36323833626532612d383134612d346131302d383462662d3935393235333366653662632e706e67" alt="img" style="zoom:50%;" /></a></p>
<h3 id="波分复用"><a class="markdownIt-Anchor" href="#波分复用"></a> 波分复用</h3>
<p>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p>
<h3 id="码分复用"><a class="markdownIt-Anchor" href="#码分复用"></a> 码分复用</h3>
<p>为每个用户分配 m bit 的码片，并且<strong>所有的码片正交</strong>，对于任意两个码片S和 T有$$\frac{1}{m}S·T=0$$</p>
<ul>
<li>
<p>取 m=8，设码片S为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。</p>
</li>
<li>
<p>在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mi>m</mi></mfrac><mi>S</mi><mo separator="true">⋅</mo><mi>S</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{1}{m}S·S=1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mi>m</mi></mfrac><mi>S</mi><mo separator="true">⋅</mo><msup><mi>S</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\frac{1}{m}S·S&#x27;=-1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span></span></p>
</li>
<li>
<p>所以接受放可以使用码片和接受到的数据进行内积运算，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。</p>
</li>
</ul>
<p><strong>码分复用需要发送的数据量为原先的 m 倍。</strong></p>
<h2 id="csmacd-协议"><a class="markdownIt-Anchor" href="#csmacd-协议"></a> CSMA/CD 协议</h2>
<p>CSMA/CD 表示载波监听多点接入 / 碰撞检测</p>
<ul>
<li><strong>多点接入</strong> ：说明这是<strong>总线型网络</strong>，许多主机以多点的方式连接到总线上。</li>
<li><strong>载波监听</strong> ：<strong>每个主机都必须不停地监听信道</strong>。在发送前，如果监听到信道正在使用，就必须等待。</li>
<li><strong>碰撞检测</strong> ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是<strong>由于电磁波的传播时延的存在，还是有可能会发生碰撞</strong>。</li>
</ul>
<h3 id="截断二进制指数规避算法"><a class="markdownIt-Anchor" href="#截断二进制指数规避算法"></a> 截断二进制指数规避算法</h3>
<p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 <strong>争用期</strong> 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p>
<p><strong>当发生碰撞时，站点要停止发送</strong>，等待一段时间再发送。这个时间采用 <strong>截断二进制指数退避算法</strong> 来确定。从离散的整数集合 {0, 1, …, (2-1)} 中随机取出一个数，记作 r，然后<strong>取 r 倍的争用期作为重传等待时间。</strong></p>
<img src="/MyImages/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31396434323365392d373466372d346332622d396239372d3535383930653064353139332e706e67" alt="img" style="zoom:50%;" />
<h2 id="ppp协议"><a class="markdownIt-Anchor" href="#ppp协议"></a> PPP协议</h2>
<p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，<strong>PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议</strong>。</p>
<h3 id="isp"><a class="markdownIt-Anchor" href="#isp"></a> ISP</h3>
<p><strong>互联网服务提供商 ISP</strong> 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</p>
<p><a href="https://camo.githubusercontent.com/4f2c402b47a5348bd8af0f794066068135cb6079/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37326265303163642d343161652d343566372d393962392d6138643238346534346464342e706e67" target="_blank" rel="noopener"><img src="/MyImages/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37326265303163642d343161652d343566372d393962392d6138643238346534346464342e706e67" alt="img" style="zoom:50%;" /></a></p>
<p>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。</p>
<p><a href="https://camo.githubusercontent.com/fe0d7539a888cded848170ae83346030234cfd86/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33626534323630312d396433332d346432392d383335382d6139643136343533616639332e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/fe0d7539a888cded848170ae83346030234cfd86/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33626534323630312d396433332d346432392d383335382d6139643136343533616639332e706e67" alt="img" /></a></p>
<h3 id="ppp的帧格式"><a class="markdownIt-Anchor" href="#ppp的帧格式"></a> PPP的帧格式</h3>
<img src="/MyImages/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37353930313364372d363164382d343530392d383937612d6437356166353938613233362e706e67" alt="img" style="zoom:50%;" />
<ul>
<li>F 字段为帧的定界符</li>
<li>A 和 C 字段暂时没有意义</li>
<li>FCS 字段是使用 CRC 的检验序列</li>
<li>信息部分的长度不超过 1500</li>
</ul>
<h2 id="mac地址"><a class="markdownIt-Anchor" href="#mac地址"></a> MAC地址</h2>
<p>MAC 地址是链路层地址，<strong>长度为 6 字节（48 位）</strong>，用于<strong>唯一标识网络适配器</strong>（网卡）。</p>
<p>一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p>
<h2 id="局域网"><a class="markdownIt-Anchor" href="#局域网"></a> 局域网</h2>
<p>局域网是一种典型的广播信道，<strong>主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</strong></p>
<p><strong>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术</strong>，目前以太网占领着有线局域网市场。</p>
<p>可以按照网络拓扑结构对局域网进行分类：</p>
<p><a href="https://camo.githubusercontent.com/d46c2651545c3d0b1a8462f2378d0f621678f444/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38303766343235382d646261382d346335342d396333632d6137303763376363666661322e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/d46c2651545c3d0b1a8462f2378d0f621678f444/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38303766343235382d646261382d346335342d396333632d6137303763376363666661322e6a7067" alt="img" style="zoom:50%;" /></a></p>
<h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3>
<ul>
<li>具有广播功能，从一个站点可方便地访问全网；</li>
<li>便于系统的扩展和逐渐演变；</li>
<li>提高了系统的可靠性，可用性和生存性。</li>
</ul>
<h2 id="以太网"><a class="markdownIt-Anchor" href="#以太网"></a> 以太网</h2>
<ul>
<li>以太网是一种<strong>星型拓扑结构局域网</strong>。</li>
<li>采用无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做</li>
<li>采用的协议是具有冲突检测的<strong>载波监听多点接入CSMA/CD</strong>。以太网上的各站点平等的争用以太网信道。</li>
<li>以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。</li>
</ul>
<h3 id="集线器"><a class="markdownIt-Anchor" href="#集线器"></a> 集线器</h3>
<p>早期使用集线器进行连接，<strong>集线器是一种物理层设备， 作用于比特而不是帧</strong>，当一个比特到达接口时，集线器<strong>重新生成</strong>这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。<strong>如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。</strong></p>
<h3 id="交换机"><a class="markdownIt-Anchor" href="#交换机"></a> 交换机</h3>
<p>目前以太网使用交换机替代了集线器，<strong>交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。</strong></p>
<p>以太网帧格式：</p>
<ul>
<li><strong>类型</strong> ：标记上层使用的协议；</li>
<li><strong>数据</strong> ：长度在 46-1500 之间，如果太小则需要填充；</li>
<li><strong>FCS</strong> ：帧检验序列，使用的是 CRC 检验方法；</li>
</ul>
<p><a href="https://camo.githubusercontent.com/5c04656a8a3c2b422abd15eeb7e34f1aa658fcec/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31363439343464332d626264322d346262322d393234622d6536323139396335316239302e706e67" target="_blank" rel="noopener"><img src="/MyImages/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31363439343464332d626264322d346262322d393234622d6536323139396335316239302e706e67" alt="img" /></a></p>
<h2 id="交换机-2"><a class="markdownIt-Anchor" href="#交换机-2"></a> 交换机</h2>
<p>交换机具有<strong>自学习能力</strong>，学习的是交换表的内容，<strong>交换表中存储着 MAC 地址到接口的映射</strong>。</p>
<p>正是由于这种自学习能力，因此<strong>交换机是一种即插即用设备</strong>，不需要网络管理员手动配置交换表内容。</p>
<h3 id="举例"><a class="markdownIt-Anchor" href="#举例"></a> 举例</h3>
<p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。</p>
<p><a href="https://camo.githubusercontent.com/3115f74e61ba45a231e0d1c80218fe918ee1b737/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61343434343534352d306436382d343031352d396133642d3139323039646334333662332e706e67" target="_blank" rel="noopener"><img src="/MyImages/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61343434343534352d306436382d343031352d396133642d3139323039646334333662332e706e67" alt="img" /></a></p>
<h2 id="虚拟局域网"><a class="markdownIt-Anchor" href="#虚拟局域网"></a> 虚拟局域网</h2>
<p>虚拟局域网<strong>可以建立与物理位置无关的逻辑组</strong>，<strong>只有在同一个虚拟局域网中的成员才会收到链路层广播信息</strong>。</p>
<p>例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。</p>
<p>使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。<strong>IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。</strong></p>
<p><a href="https://camo.githubusercontent.com/1a3fb5086fd1160a82b645b4af8c3457949e5149/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65393865396432302d323036622d343533332d626163662d3334343864303039366633382e706e67" target="_blank" rel="noopener"><img src="/MyImages/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65393865396432302d323036622d343533332d626163662d3334343864303039366633382e706e67" alt="img" style="zoom:50%;" /></a></p>
<h1 id="网络层"><a class="markdownIt-Anchor" href="#网络层"></a> 网络层</h1>
<h2 id="基本问题"><a class="markdownIt-Anchor" href="#基本问题"></a> 基本问题</h2>
<ol>
<li><strong>任务</strong>：因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。<strong>网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。<strong>使用 IP 协议，可以</strong>把异构的物理网络连接起来</strong>，使得在网络层看起来好像是一个统一的网络。</li>
<li><strong>虚电路</strong>：在两个终端设备的逻辑或物理端口之间，通过建立的双向的透明传输通道。<strong>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送</strong>，而并不是真正建立了一条物理连接。</li>
</ol>
<h3 id="相关协议"><a class="markdownIt-Anchor" href="#相关协议"></a> 相关协议</h3>
<ul>
<li>地址解析协议 ARP（Address Resolution Protocol）</li>
<li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li>
<li>网际组管理协议 IGMP（Internet Group Management Protocol）</li>
</ul>
<h2 id="ip数据报格式"><a class="markdownIt-Anchor" href="#ip数据报格式"></a> IP数据报格式</h2>
<p><a href="https://camo.githubusercontent.com/d9b7f233d56f9d2af3d9b404c80af95b211ad539/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38356330356662312d353534362d346335302d393232312d3231663233316364633863352e6a7067" target="_blank" rel="noopener"><img src="/MyImages/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38356330356662312d353534362d346335302d393232312d3231663233316364633863352e6a7067" alt="img" /></a></p>
<ul>
<li>
<p><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</p>
</li>
<li>
<p><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</p>
</li>
<li>
<p><strong>区分服务</strong> : 用来获得更好的服务，一般情况下不使用。</p>
</li>
<li>
<p><strong>总长度</strong> : 包括首部长度和数据部分长度。</p>
</li>
<li>
<p><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p>
</li>
<li>
<p><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</p>
</li>
<li>
<p><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</p>
</li>
<li>
<p><strong>标识</strong> : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</p>
</li>
<li>
<p><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。<strong>片偏移的单位为 8 字节。</strong></p>
<p><a href="https://camo.githubusercontent.com/ce4a4c68bd1cb7dd450976e5630015272ebc33a4/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32336261383930652d653131632d343565322d613230632d3634643231376638333433302e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/ce4a4c68bd1cb7dd450976e5630015272ebc33a4/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32336261383930652d653131632d343565322d613230632d3634643231376638333433302e706e67" alt="img" /></a></p>
</li>
</ul>
<h2 id="ip地址编址方式"><a class="markdownIt-Anchor" href="#ip地址编址方式"></a> IP地址编址方式</h2>
<p>IP 地址的编址方式经历了三个历史阶段：分类，子网划分，无分类</p>
<h3 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h3>
<p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p>
<p><a href="https://camo.githubusercontent.com/5562e1440908cc6254c6e6a4b74733366fdfb424/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63626635306562382d323262342d343532382d613265372d6431383731343364353766372e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/5562e1440908cc6254c6e6a4b74733366fdfb424/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63626635306562382d323262342d343532382d613265372d6431383731343364353766372e706e67" alt="img" style="zoom:50%;" /></a></p>
<p>A,B,C类各保留了一个区域作为私有地址范围：</p>
<ul>
<li>10.0.0.0 - 10.255.255.255</li>
<li>172.16.0.0 - 172.31.255.255</li>
<li>192.168.0.0 - 192.168.255.255</li>
</ul>
<h3 id="子网划分"><a class="markdownIt-Anchor" href="#子网划分"></a> 子网划分</h3>
<p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p>
<p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p>
<p>注意，外部网络看不到子网的存在。</p>
<h3 id="无分类"><a class="markdownIt-Anchor" href="#无分类"></a> 无分类</h3>
<ul>
<li>
<p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，<strong>使用网络前缀和主机号来对 IP 地址进行编码</strong>，<strong>网络前缀的长度可以根据需要变化。</strong></p>
<p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p>
</li>
<li>
<p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p>
</li>
</ul>
<p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p>
<p><strong>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络</strong>，<strong>并且在路由表中只需要一个路由就可以代替原来的多个路由</strong>，减少了路由表项的数量。把这种通过<strong>使用网络前缀来减少路由表项的方式称为路由聚合</strong>，也称为 <strong>构成超网</strong> 。</p>
<p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，<strong>应当采用最长前缀匹配来确定应该匹配哪一个</strong>。</p>
<h2 id="地址解析协议-arp"><a class="markdownIt-Anchor" href="#地址解析协议-arp"></a> 地址解析协议 ARP</h2>
<p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，<strong>IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</strong></p>
<p><a href="https://camo.githubusercontent.com/5d2c96a69535cff2d24e1a8fcfcf474f9d61b4fc/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62396437396135612d653761662d343939622d623938392d6631303438336537316238622e6a7067" target="_blank" rel="noopener"><img src="/MyImages/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62396437396135612d653761662d343939622d623938392d6631303438336537316238622e6a7067" alt="img" style="zoom: 67%;" /></a></p>
<ul>
<li><strong>ARP协议负责实现IP地址到MAC地址的转换</strong></li>
</ul>
<h3 id="过程"><a class="markdownIt-Anchor" href="#过程"></a> 过程</h3>
<ul>
<li>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</li>
<li>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时<strong>主机 A 通过广播的方式发送 ARP 请求分组</strong>，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</li>
</ul>
<p><a href="https://camo.githubusercontent.com/12ebabeea9c90bcaeaaf41c7daf23515a8d6e8d2/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38303036613435302d366332662d343938632d613932382d6339323766373538623164302e706e67" target="_blank" rel="noopener"><img src="/MyImages/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38303036613435302d366332662d343938632d613932382d6339323766373538623164302e706e67" alt="img" /></a></p>
<h2 id="网际控制报文协议-icmp"><a class="markdownIt-Anchor" href="#网际控制报文协议-icmp"></a> 网际控制报文协议 ICMP</h2>
<p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。<strong>它封装在 IP 数据报中，但是不属于高层协议。</strong></p>
<h3 id="分类-2"><a class="markdownIt-Anchor" href="#分类-2"></a> 分类</h3>
<p>ICMP 报文分为差错报告报文和询问报文。</p>
<p><a href="https://camo.githubusercontent.com/7bd6bdd8c479ce3976e34d12b577ca53bc0fd81b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61613239636338382d373235362d343339392d386337662d3363663461363438393535392e706e67" target="_blank" rel="noopener"><img src="/MyImages/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61613239636338382d373235362d343339392d386337662d3363663461363438393535392e706e67" alt="img" /></a></p>
<h3 id="ping"><a class="markdownIt-Anchor" href="#ping"></a> Ping</h3>
<p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p>
<p><strong>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文</strong>，<strong>目的主机收到之后会发送 Echo 回答报文</strong>。Ping 会根据时间和成功响应的次数<strong>估算出数据包往返时间以及丢包率。</strong></p>
<h3 id="traceroute"><a class="markdownIt-Anchor" href="#traceroute"></a> Traceroute</h3>
<p>Traceroute 是 ICMP 的另一个应用，<strong>用来跟踪一个分组从源点到终点的路径</strong>。</p>
<p>Traceroute 发送的 IP 数据报封装的<strong>是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</strong></p>
<ul>
<li>
<p>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并<strong>向源主机发送一个 ICMP 时间超过差错报告报文；</strong></p>
</li>
<li>
<p>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</p>
</li>
<li>
<p>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，<strong>主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</strong></p>
</li>
<li>
<p>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</p>
<p><strong>中间的路由向源发送超时报告报文，目标主机向源发送终点不可达差错报告报文</strong></p>
</li>
</ul>
<h2 id="虚拟专用网-vpn"><a class="markdownIt-Anchor" href="#虚拟专用网-vpn"></a> 虚拟专用网 VPN</h2>
<ul>
<li>
<p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，<strong>机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</strong></p>
<p>有三个专用地址块：</p>
<ul>
<li><strong>10.0.0.0 ~ 10.255.255.255</strong></li>
<li><strong>172.16.0.0 ~ 172.31.255.255</strong></li>
<li><strong>192.168.0.0 ~ 192.168.255.255</strong></li>
</ul>
</li>
<li>
<p>VPN 使<strong>用公用的互联网作为本机构各专用网之间的通信载体</strong>。</p>
<ul>
<li>专用指机构内的主机只与本机构内的其它主机通信；</li>
<li>虚拟指好像是，而实际上并不是，它有经过公用的互联网。</li>
</ul>
</li>
</ul>
<h3 id="举例-2"><a class="markdownIt-Anchor" href="#举例-2"></a> 举例</h3>
<p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，<strong>R1 对内部数据进行加密，然后重新加上数据报的首部</strong>，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。<strong>路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y</strong>。</p>
<p><img src="/MyImages/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31353536373730622d386330312d343638312d616631302d3436663164663639323032632e6a7067" alt="img" /></p>
<h2 id="网络地址转换-nat"><a class="markdownIt-Anchor" href="#网络地址转换-nat"></a> 网络地址转换 NAT</h2>
<p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p>
<p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p>
<h2 id="路由器分组转发流程"><a class="markdownIt-Anchor" href="#路由器分组转发流程"></a> 路由器分组转发流程</h2>
<ul>
<li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li>
<li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li>
<li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li>
<li>报告转发分组出错。</li>
</ul>
<h2 id="路由选择协议"><a class="markdownIt-Anchor" href="#路由选择协议"></a> 路由选择协议</h2>
<p>可以把路由选择协议划分为两大类：</p>
<ul>
<li>自治系统内部的路由选择：RIP 和 OSPF</li>
<li>自治系统间的路由选择：BGP</li>
</ul>
<p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p>
<p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p>
<h3 id="内部网关协议rip"><a class="markdownIt-Anchor" href="#内部网关协议rip"></a> 内部网关协议RIP</h3>
<p>RIP 是一种<strong>基于距离向量的路由选择协议</strong>。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p>
<p><strong>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表</strong>，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p>
<p><strong>距离向量算法：</strong></p>
<ul>
<li>Y路由器收到邻居X路由器的RIP报文（目的网路N，距离d,下一跳Z）进行如下过程构造路由表项</li>
<li>修改RIP报文，距离d+1,下一跳改为X：(目的网路N，距离d+1,下一跳X),Y到目的网络N，经过X路由器花费为d+1</li>
<li>如果Y原路由表中没有目的网络N的项，则直接加入该项(目的网路N，距离d+1,下一跳X)，否则进入3</li>
<li>Y中有目的网络N的表项，如果该表项的下一跳也是X，则用(目的网路N，距离d+1,下一跳X)替换原来的表项。否则4</li>
<li>Y中有目的网络N的表项，且下一跳不是X,则，比较距离d,选择小的作为路由表项。否则，什么也不做。</li>
</ul>
<p>RIP 协议实现简单，<strong>开销小</strong>。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。（<strong>坏消息传的慢</strong>）</p>
<h3 id="内部网关协议-ospf"><a class="markdownIt-Anchor" href="#内部网关协议-ospf"></a> 内部网关协议 OSPF</h3>
<p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p>
<p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；<strong>最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</strong></p>
<p>OSPF 具有以下特点：</p>
<ul>
<li>向本自治系统中的所有路由器发送信息，这种方法是<strong>洪泛法。</strong></li>
<li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，<strong>度量用费用、距离、时延、带宽等来表示。</strong></li>
<li>只有<strong>当链路状态发生变化时，路由器才会发送信息</strong>。</li>
</ul>
<p>**所有路由器都具有全网的拓扑结构图，**并且是一致的。相比于 RIP，<strong>OSPF 的更新过程收敛的很快。</strong></p>
<h3 id="外部网关协议-bgp"><a class="markdownIt-Anchor" href="#外部网关协议-bgp"></a> 外部网关协议 BGP</h3>
<p>BGP（Border Gateway Protocol，边界网关协议）</p>
<p>AS 之间的路由选择很困难，主要是由于：</p>
<ul>
<li>互联网规模很大；</li>
<li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li>
<li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li>
</ul>
<p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p>
<p><strong>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</strong></p>
<p><a href="https://camo.githubusercontent.com/5d90614fddb838584221d50bee59cc886b3ca631/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39636430616532302d346662352d343031372d613030302d6637643361306562333532392e706e67" target="_blank" rel="noopener"><img src="/MyImages/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39636430616532302d346662352d343031372d613030302d6637643361306562333532392e706e67" alt="img" /></a></p>
<h1 id="传输层"><a class="markdownIt-Anchor" href="#传输层"></a> 传输层</h1>
<h2 id="基本问题-2"><a class="markdownIt-Anchor" href="#基本问题-2"></a> 基本问题</h2>
<ol>
<li>
<p><strong>任务</strong>：网络层只把分组发送到目的主机，但是真<strong>正通信的并不是主机而是主机中的进程</strong>。<strong>传输层提供了进程间的逻辑通信</strong>，传输层向高层用户屏蔽了下面网络层的核心细节，<strong>使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</strong></p>
</li>
<li>
<p><strong>传输层的复用和分用</strong>：复用指发送方不同的进程都可以通过统一个运输层协议传送数据。分用指接收方的运输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。</p>
</li>
<li>
<p><strong>套接字</strong>：用（IP地址：端口号）来表示。</p>
</li>
</ol>
<h2 id="udp-和-tcp-特点"><a class="markdownIt-Anchor" href="#udp-和-tcp-特点"></a> UDP 和 TCP 特点</h2>
<ul>
<li>用户数据报协议 UDP（User Datagram Protocol）是<strong>无连接</strong>的，<strong>尽最大可能交付</strong>，<strong>没有拥塞控制</strong>，<strong>面向报文</strong>（对于应用程序传下来的报文不合并也<strong>不拆分</strong>，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>传输控制协议 TCP（Transmission Control Protocol）是<strong>面向连接的</strong>，提供<strong>可靠交付</strong>，有<strong>流量控制</strong>，<strong>拥塞控制</strong>，<strong>提供全双工通信</strong>，<strong>面向字节流</strong>（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接<strong>只能是点对点的</strong>（一对一）。</li>
</ul>
<h2 id="udp-首部格式"><a class="markdownIt-Anchor" href="#udp-首部格式"></a> UDP 首部格式</h2>
<p><a href="https://camo.githubusercontent.com/7ca1b1c28cbd15d58b78d883d62f55b12b540c92/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64346333613461312d303834362d343665632d396363332d6561646466636137313235342e6a7067" target="_blank" rel="noopener"><img src="/MyImages/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64346333613461312d303834362d343665632d396363332d6561646466636137313235342e6a7067" alt="img" style="zoom: 33%;" /></a></p>
<h2 id="tcp-首部格式"><a class="markdownIt-Anchor" href="#tcp-首部格式"></a> TCP 首部格式</h2>
<p><a href="https://camo.githubusercontent.com/2e30711bdf748be3b6355a1903df0b59bd7a093f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35356463346538342d353733642d346331332d613736352d3532656431646432353166392e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/2e30711bdf748be3b6355a1903df0b59bd7a093f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35356463346538342d353733642d346331332d613736352d3532656431646432353166392e706e67" alt="img" style="zoom: 33%;" /></a></p>
<ul>
<li><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li>
<li><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li>
<li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li>
<li><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li>
<li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</li>
<li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li>
<li><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li>
<li><strong>端口号</strong>：用16位端口号标志一个端口。端口号只有本地意义，只是标志计算机应用层中的各个进程和运输层交互时的层间接口。</li>
</ul>
<h2 id="tcp-三次握手"><a class="markdownIt-Anchor" href="#tcp-三次握手"></a> TCP 三次握手</h2>
<p><a href="https://camo.githubusercontent.com/a01cdf6f16898459a64d0e4f30099a648e41f234/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65393264306562632d376434362d343133622d616563312d3334613339363032663738372e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/a01cdf6f16898459a64d0e4f30099a648e41f234/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65393264306562632d376434362d343133622d616563312d3334613339363032663738372e706e67" alt="img" style="zoom:50%;" /></a></p>
<p>假设 A 为客户端，B 为服务器端。</p>
<ul>
<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li>
<li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li>
<li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li>
<li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li>
<li>B 收到 A 的确认后，连接建立。</li>
</ul>
<h3 id="三次握手的原因"><a class="markdownIt-Anchor" href="#三次握手的原因"></a> <strong>三次握手的原因</strong></h3>
<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。<strong>如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</strong>(第三次握手后，服务器期待收到的序列号+1，那么旧的序列号就被抛弃了)</p>
<h2 id="tcp-的四次挥手"><a class="markdownIt-Anchor" href="#tcp-的四次挥手"></a> TCP 的四次挥手</h2>
<p><a href="https://camo.githubusercontent.com/e34c2dba285adb550060da92c5f3c98d57a4e3e1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66383761666537322d633264662d346331322d616330332d3962386435383161386166382e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/e34c2dba285adb550060da92c5f3c98d57a4e3e1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66383761666537322d633264662d346331322d616330332d3962386435383161386166382e6a7067" alt="img" style="zoom:50%;" /></a></p>
<p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p>
<ul>
<li>A 发送连接释放报文，FIN=1。</li>
<li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li>
<li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li>
<li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li>
<li>B 收到 A 的确认后释放连接。</li>
</ul>
<h3 id="四次挥手的原因"><a class="markdownIt-Anchor" href="#四次挥手的原因"></a> <strong>四次挥手的原因</strong></h3>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<p><strong>TIME_WAIT</strong></p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ul>
<li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li>
<li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li>
</ul>
<h2 id="tcp为什么可靠"><a class="markdownIt-Anchor" href="#tcp为什么可靠"></a> TCP为什么可靠</h2>
<h3 id="1-序列号与确认号"><a class="markdownIt-Anchor" href="#1-序列号与确认号"></a> 1、序列号与确认号</h3>
<p>当发送错误的时候，会发生：</p>
<p><strong>a、超时重传机制</strong></p>
<p>发送方发送的报文中含有序列号，每当发送一个报文后，就启动一个计时器（RTO），该计时器的时间一般是有当前网络来决定的，一个RTT指的是当一个报文从发送到接收到对应的ACK标志的时间，RTO的决定一般是发送方尝试发送几个报文，然后取平均RTT时间来决定计时器的值。 当发送一个报文以后，发送方在计时范围以内，如果没有接收到相应的ACK确认报文，那么发送方就会重传该报文。</p>
<p><strong>b、快速重传机制</strong></p>
<p>该机制指的是，发送方一直发送报文，不会每发一次报文就都要等待到这个报文的ACK标志才发送下个报文。 当接收方发送接受的序列号不对的时候，发送连续的3个ACK标志，告诉发送方，这个报文在传输过程中出现了丢包。发送方如果接收到某个相同序列号的三个ACK报文，那么此时立马重发该报文，不用等待计时器的时间结束。</p>
<h3 id="2-流量控制滑动窗口"><a class="markdownIt-Anchor" href="#2-流量控制滑动窗口"></a> 2、流量控制（滑动窗口）</h3>
<p>发送方通过维持一个发送滑动窗口来确保不会发生由于发送方报文发送太快接收方无法及时处理的问题。此时发送方的报文分为四类， 第一类是已经发送并且得到接收方确认的报文，第二类是已经发送但是没有接收到确认的报文，第三类是发送方还没发送，但是滑动窗口还足够巨大，允许被发送的报文， 第四类是还没发送并且窗口已经被占满，不允许发送的报文。 一般来说，滑动窗口的最左端都是介于第一类跟第二类报文的分界线，最右端是第三类跟第四类报文的分界线。</p>
<p>滑动窗口的流量控制可以包括那么几个协议：</p>
<p><strong>a、停等协议。</strong> 滑动窗口的大小为1， 每个发送报文都要等到被确认以后，发送方才继续发送下一个报文。</p>
<p><strong>b、后退n步协议。</strong> 该协议下，滑动窗口大于1，发送方可以一直发送报文，但是当接收到接收方发送的三个连续的同一序列号的ACK报文时，说明该序列号的报文是已经丢失的，那么此时重发该丢失报文以及该报文以后的报文（包括那些已经发送的）。</p>
<p>**c、选择重传。**在后退n步协议当中，如果某个报文丢失。那么将要重新发送这个丢失报文及以后的所有报文（包括已经发送的），选择重传协议不用做此要求，只要重新发送丢失的报文即可。</p>
<h3 id="3-拥塞控制"><a class="markdownIt-Anchor" href="#3-拥塞控制"></a> 3、拥塞控制</h3>
<p>首先要明白拥塞控制与流量控制有什么不同，流量控制考虑的是单纯的发送方与接收方，这两个在全部网络过程中的两个端点。而<strong>拥塞控制考虑的是整个网络</strong>。可以想象一下，在流量控制当中，接收方跟发送方考虑的只是自己的报文有没有发送并且被接收的问题，假设现在网络阻塞，在超时重传机制当中，发送方没有发送后在计时器时间内没有接收到确认报文，就<strong>立马重新发送报文，这时候对已经拥塞的网络来说</strong>，无异于雪上加霜。同样实在拥塞的网络情况下，考虑下快速重传机制，同样是这个道理。所以，针对以上问题，TCP应该要有一个拥塞控制机制，不然，后果不堪设想。</p>
<p>在拥塞控制机制当中，发送方会维护一个滑动发送窗口，该窗口与拥塞控制窗口一般是一样大的，除非受到物理限制，假设网络的承载量是无线的，那么拥塞窗口理论上就可以无线增大，但受现在电脑技术限制，我们可能无法将发送窗口与拥塞窗口变得一样大。</p>
<p>下面说明下几个符号说明：</p>
<p>cwnd：拥塞窗口大小</p>
<p>ssthreshold: 拥塞阈值 （该阈值是对网络状况的一个预估，决定在拥塞窗口多大的时候采取怎样的策略，它的初始化一般是一个估计，一般都会给出）</p>
<p>现在可以看下这个拥塞控制机制包括哪几个策略</p>
<p><strong>1. 慢开始与拥塞避免</strong></p>
<p>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p>
<p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>
<p>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</p>
<p><strong>2. 快重传与快恢复</strong></p>
<p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对M2 的确认。</p>
<p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
<h3 id="4-举例"><a class="markdownIt-Anchor" href="#4-举例"></a> 4、举例</h3>
<p>下面我们模拟一下发送方发送报文：假设ssthreshold=8</p>
<p>首先肯定是慢启动阶段，cwnd增长，1、2、4、8，到8的时候，cwnd达到了ssthreshold的值，于是进入拥塞避免阶段，cwnd继续增长8、9、10，假设到10的时候，发生了网络拥塞，这时候拥塞分为两种情况：</p>
<p>第一种，发送方接收到同一序列号的报文的连续三个ACK确认报文，说明出现了丢包，但是接收到接收方发送的丢包信号，说明网络情况还是相对较好的，于是此时发送方做出反应，将ssthreshold=cwnd/2=5，cwnd=ssthreshold=5，然后进入拥塞避免阶段，cwnd继续以5、6、7…这种情况增长。</p>
<p>第二种，发送方接收到同一序列号的报文连续两个ACK确认报文，这时候，就说明网络拥塞情况就比较严重了，连接收方发送的丢包信号都不完整了，这个时候得采取更加严厉的措施了，于是ssthreshold=cwnd/2，cwnd=1，然后重新进入慢启动过程。</p>
<h2 id="tcp-滑动窗口"><a class="markdownIt-Anchor" href="#tcp-滑动窗口"></a> TCP 滑动窗口</h2>
<ul>
<li>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，<strong>接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小</strong>，发送方根据这个值和其它信息设置自己的窗口大小。</li>
<li><strong>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收</strong>。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</li>
<li><strong>接收窗口只会对窗口内最后一个按序到达的字节进行确认</strong>，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</li>
</ul>
<h1 id="应用层"><a class="markdownIt-Anchor" href="#应用层"></a> 应用层</h1>
<h2 id="域名系统"><a class="markdownIt-Anchor" href="#域名系统"></a> 域名系统</h2>
<p><strong>DNS 是一个分布式数据库</strong>，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，<strong>每个站点只保留它自己的那部分数据。</strong></p>
<p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p>
<p><strong>DNS 可以使用 UDP 或者 TCP 进行传输</strong>，使用的<strong>端口号都为 53</strong>。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：</p>
<ul>
<li>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。</li>
<li>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）</li>
</ul>
<h2 id="文件传输协议-ftp"><a class="markdownIt-Anchor" href="#文件传输协议-ftp"></a> 文件传输协议 FTP</h2>
<p><strong>FTP 使用 TCP 进行连接</strong>，它需要两个连接来传送一个文件：</p>
<ul>
<li><strong>控制连接</strong>：服务器打开<strong>端口号 21</strong> 等待客户端的连接，<strong>客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器</strong>，并传回服务器的应答。</li>
<li><strong>数据连接</strong>：用来传送一个文件数据。</li>
</ul>
<h3 id="模式"><a class="markdownIt-Anchor" href="#模式"></a> 模式</h3>
<p>根据数据连接是否是服务器端主动建立，<strong>FTP 有主动和被动两种模式：</strong></p>
<ul>
<li><strong>主动模式</strong>：<strong>服务器端主动建立数据连接</strong>，其中<strong>服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024</strong>，因为 0~1023 是熟知端口号。</li>
</ul>
<ul>
<li>
<p><strong>被动模式</strong>：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</p>
</li>
<li>
<p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是<strong>被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号</strong>。</p>
</li>
</ul>
<h2 id="动态主机配置协议-dhcp"><a class="markdownIt-Anchor" href="#动态主机配置协议-dhcp"></a> 动态主机配置协议 DHCP</h2>
<p>DHCP (Dynamic Host Configuration Protocol) <strong>提供了即插即用的连网方式</strong>，用户不再需要手动配置 IP 地址等信息。DHCP 配置的内容不仅是 IP 地址，<strong>还包括子网掩码、网关 IP 地址。</strong></p>
<h3 id="工作过程"><a class="markdownIt-Anchor" href="#工作过程"></a> 工作过程</h3>
<ol>
<li><strong>客户端发送 Discover 报文</strong>，<strong>该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68</strong>，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li>
<li><strong>DHCP 服务器收到 Discover 报文之后</strong>，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，<strong>因此客户端需要进行选择</strong>。</li>
<li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就<strong>发送 Request 报文给该 DHCP 服务器</strong>。</li>
<li><strong>DHCP 服务器发送 Ack 报文</strong>，表示客户端此时可以使用提供给它的信息。</li>
</ol>
<h2 id="电子邮件协议-smtp-pop3-imap"><a class="markdownIt-Anchor" href="#电子邮件协议-smtp-pop3-imap"></a> 电子邮件协议 SMTP &amp; POP3 &amp; IMAP</h2>
<p><strong>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议</strong>。发送常用SMTP，读取常用POP3,IMAP</p>
<h3 id="smtp-mime"><a class="markdownIt-Anchor" href="#smtp-mime"></a> SMTP &amp; MIME</h3>
<p><strong>SMTP 只能发送 ASCII 码</strong>，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p>
<h3 id="pop3"><a class="markdownIt-Anchor" href="#pop3"></a> POP3</h3>
<p>POP3 的特点是<strong>只要用户从服务器上读取了邮件，就把该邮件删除</strong>。但最新版本的 POP3 可以不删除邮件。</p>
<h3 id="imap"><a class="markdownIt-Anchor" href="#imap"></a> IMAP</h3>
<p>IMAP 协议中客户端和服务器上的邮件保持同步，<strong>如果不手动删除邮件，那么服务器上的邮件也不会被删除</strong>。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p>
<h2 id="常用端口"><a class="markdownIt-Anchor" href="#常用端口"></a> 常用端口</h2>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>应用</td>
<td>应用层协议</td>
<td>端口号</td>
<td>传输层协议</td>
<td>备注</td>
</tr>
<tr>
<td>域名解析</td>
<td>DNS</td>
<td>53</td>
<td>UDP/TCP</td>
<td>长度超过 512 字节时使用 TCP</td>
</tr>
<tr>
<td>动态主机配置协议</td>
<td>DHCP</td>
<td>67/68</td>
<td>UDP</td>
<td></td>
</tr>
<tr>
<td>简单网络管理协议</td>
<td>SNMP</td>
<td>161/162</td>
<td>UDP</td>
<td></td>
</tr>
<tr>
<td>文件传送协议</td>
<td>FTP</td>
<td>20/21</td>
<td>TCP</td>
<td>控制连接 21，数据连接 20</td>
</tr>
<tr>
<td>远程终端协议</td>
<td>TELNET</td>
<td>23</td>
<td>TCP</td>
<td></td>
</tr>
<tr>
<td>超文本传送协议</td>
<td>HTTP</td>
<td>80</td>
<td>TCP</td>
<td></td>
</tr>
<tr>
<td>简单邮件传送协议</td>
<td>SMTP</td>
<td>25</td>
<td>TCP</td>
<td></td>
</tr>
<tr>
<td>邮件读取协议</td>
<td>POP3</td>
<td>110</td>
<td>TCP</td>
<td></td>
</tr>
<tr>
<td>网际报文存取协议</td>
<td>IMAP</td>
<td>143</td>
<td>TCP</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="web-页面请求过程"><a class="markdownIt-Anchor" href="#web-页面请求过程"></a> Web 页面请求过程</h2>
<h3 id="1-dhcp-配置主机信息"><a class="markdownIt-Anchor" href="#1-dhcp-配置主机信息"></a> 1. DHCP 配置主机信息</h3>
<ul>
<li>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</li>
<li>主机生成一个 DHCP 请求报文，并将这个报文放入具有<strong>目的端口 67 和源端口 68 的 UDP</strong> 报文段中。</li>
<li>该报文段则被放入在一个具有广播 IP **目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）**的 IP 数据报中。</li>
<li>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。</li>
<li>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</li>
<li>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</li>
<li>主机收到该帧后，不断分解得到 DHCP 报文。之后就<strong>配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址</strong>，并在其 IP 转发表中安装默认网关。</li>
</ul>
<h3 id="2-arp-解析-mac-地址"><a class="markdownIt-Anchor" href="#2-arp-解析-mac-地址"></a> 2. ARP 解析 MAC 地址</h3>
<ul>
<li>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</li>
<li>主机<strong>生成一个 DNS 查询报文，该报文具有 53 号端口</strong>，因为 DNS 服务器的端口号是 53。</li>
<li>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</li>
<li>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</li>
<li>DHCP 过程只知道网关路由器的 IP 地址，<strong>为了获取网关路由器的 MAC 地址，需要使用 ARP 协议</strong>。</li>
<li>主机<strong>生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文</strong>，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</li>
<li>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就<strong>发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机</strong>。</li>
</ul>
<h3 id="3-dns-解析域名"><a class="markdownIt-Anchor" href="#3-dns-解析域名"></a> 3. DNS 解析域名</h3>
<ul>
<li>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</li>
<li><strong>网关路由器</strong>接收到包含 DNS 查询报文的以太网帧后，<strong>抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</strong></li>
<li>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</li>
<li>到达 <strong>DNS 服务器</strong>之后，DNS 服务器抽取出 DNS 查询报文，并<strong>在 DNS 数据库中查找待解析的域名</strong>。</li>
<li>找到 DNS 记录之后，<strong>发送 DNS 回答报文</strong>，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</li>
</ul>
<h3 id="4-http-请求页面"><a class="markdownIt-Anchor" href="#4-http-请求页面"></a> 4. HTTP 请求页面</h3>
<ul>
<li>有了 HTTP 服务器的 IP 地址之后，<strong>主机就能够生成 TCP 套接字</strong>，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</li>
<li>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</li>
<li>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</li>
<li><strong>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</strong></li>
<li>HTTP 服务器从 <strong>TCP 套接字读取 HTTP GET 报文</strong>，生成一个 HTTP 响应报文，将 <strong>Web 页面内容放入报文主体中，发回给主机。</strong></li>
<li>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</li>
</ul>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>集合栈计算机</title>
    <url>/2020/03/30/%E9%9B%86%E5%90%88%E6%A0%88%E8%AE%A1%E7%AE%97%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="uva12096-集合栈计算机"><a class="markdownIt-Anchor" href="#uva12096-集合栈计算机"></a> uva12096 ※集合栈计算机※</h1>
<pre><code>Sample Input
2
9
PUSH
DUP
ADD
PUSH
ADD
DUP
ADD
DUP
UNION
5
PUSH
PUSH
ADD
PUSH
INTERSECT

Sample Output
0
0
1
0
1
1
2
***
0
0
1
0
0
</code></pre>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<ol>
<li>首先考虑集合的存储问题：由于有集合作为元素插入到另一个集合的情况，所以不能直接定义集合类型的栈。考虑将集合映射到值(map)，另用一个向量存集合本身。</li>
<li>按照题干输入输出判断操作即可。注意后三种操作可以合并简化代码</li>
</ol>
<h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2>
<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;iterator&gt;
#include&lt;algorithm&gt;
# define ALL(x) x.begin(),x.end()
# define INS(x) inserter(x,x.begin())
</code></pre>
<blockquote>
<p>INS(x)插入迭代器，插入而非覆盖<br />
<a href="https://blog.csdn.net/m0_37456764/article/details/83019250" target="_blank" rel="noopener">inserter</a>.</p>
</blockquote>
<pre><code>using namespace std;
typedef set&lt;int&gt; Set;
map&lt;Set, int&gt; id;//将每个集合对应一个编号，编号是在向量中的下标
vector&lt;Set&gt; Setcache;
int ID(Set x) {//既是插入又是查询！！
	if (id.count(x)) return id[x];//存在则返回id

	//不存在则添加
	Setcache.push_back(x);
	return id[x] = Setcache.size() - 1;
}
</code></pre>
<p>插入和查询合并简化代码</p>
<pre><code>int main() {
int n;

cin &gt;&gt; n;
while (n--) {
	int m;
	cin &gt;&gt; m;
	stack&lt;int&gt; s;
	while (m--) {
		string op;
		cin &gt;&gt; op;
		if (op[0] == 'P') s.push(ID(Set()));
		//空集入栈，注意此处空集的写法
		else if (op[0] == 'D') s.push(s.top());
		else {
			Set x1 = Setcache[s.top()]; s.pop();
			//不同直接用pop赋值，因为pop的返回值为void
			Set x2 = Setcache[s.top()]; s.pop();
			Set x;
			if (op[0] == 'U') set_union(ALL(x1), ALL(x2), INS(x));
			if (op[0] == 'I') set_intersection(ALL(x1), ALL(x2), INS(x));
			if (op[0] == 'A') { x = x2; x.insert(ID(x1)); }
			s.push(ID(x));
		}
		cout &lt;&lt; Setcache[s.top()].size() &lt;&lt; endl;
	}
	cout &lt;&lt; &quot;***&quot; &lt;&lt; endl;
}
}
</code></pre>
<h1 id="心得"><a class="markdownIt-Anchor" href="#心得"></a> 心得</h1>
<ol>
<li>本题主要注重多种STL的结合使用，尤其是集合映射为整型的处理方式</li>
<li>记住题中交并集的函数，set_union(参数为5个迭代器),set_intersection(参数为5个迭代器);要配合两处define使用</li>
<li>注意模拟多种操作时提取相同部分简化代码，也降低出错的可能性和调试难度。</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>黄金图形</title>
    <url>/2020/03/30/%E9%BB%84%E9%87%91%E5%9B%BE%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="uva-225-黄金图形"><a class="markdownIt-Anchor" href="#uva-225-黄金图形"></a> UVA 225 黄金图形</h1>
<p>平面上有k个障碍点。 从(0,0)点出发，第一次走1个单位，第二次走2个单位，……， 第n次走n个单位，恰好回到(0,0)。 要求只能沿着东南西北方向走，且每次必须转弯90°（不能沿着同一个方向继续走，也不能后退）。 走出的图形可以自交，但不能经过障碍点，如图 7-25所示。每个转折点只能走一次。 输入n、k（1≤n≤20，0≤k≤50）和所有障碍点的坐标，输出所有满足要求的移动序列（用 news表示北、东、西、南），按照字典序从小到大排列，最后输出移动序列的总数。</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>又要输出所有的路径，所以直观的想到用dfs。dfs中处理好可以移动的方向即可。</li>
<li>本题的特殊之处在于，障碍格可能出现负坐标。由于本题中最长边长n小于等于20，所以采用给(0,0)点以及障碍物点加一个比较大的值来消负号。我是假设n=20，那么一共也就能走1+2+…20/2=105，所以我加了一个120.</li>
<li>注意：卡了很久的原因主要是题干中要求最长边等于n，这条件不仅是限定搜索深度的。他还要求必须包含长度为n的边。</li>
<li>注意每个转折点只能走一次的条件。这个转折点是指每一步走完之后的终点。</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<pre><code>#include&lt;bits/stdc++.h&gt;
# pragma warning(disable:4996)
FILE *fin = freopen(&quot;习题7-2in.txt&quot;, &quot;r&quot;, stdin);
FILE *fout = freopen(&quot;习题7-2out.txt&quot;, &quot;w&quot;, stdout);
using namespace std;
const int maxn = 20;
void dfs(int r, int c, int dir, int step);
int dx[] = { 1,0,0,-1 };//东北南西
int dy[] = { 0,1,-1,0 };
int cnt, n;
bool g[maxn * maxn + 1][maxn * maxn + 1];
char direction[] = { 'e','n','s','w' };
int path[maxn*maxn];
bool vis[maxn*maxn + 1][maxn*maxn+ 1];
int stax, stay;
int main() {
int T;
scanf(&quot;%d&quot;, &amp;T);
int k;
while (T--)
{
	int x, y;
	memset(g, 1, sizeof(g));
	memset(path, 0, sizeof(path));
	
	scanf(&quot;%d\n%d&quot;, &amp;n, &amp;k);
	vector&lt;int&gt; tmpx;
	vector&lt;int&gt; tmpy;
	stax = stay = 120;
	cnt = 0;
	while (k--)
	{
		scanf(&quot;%d %d&quot;, &amp;x, &amp;y);
		g[x + stax][y + stay] = 0;
	}

	for (int i = 0; i &lt; 4; i++) {
		memset(vis, 0, sizeof(vis));
		dfs(stax, stay, i, 1);


	}
	printf(&quot;Found %d golygon(s).\n\n&quot;, cnt);
}
}
void dfs(int r, int c, int dir, int step) {
path[step] = dir;
for (int i = 0; i &lt; step; i++) {
	r += dx[dir];
	c += dy[dir];
	if (!g[r][c] || r &lt; 0 || c &lt; 0 ) {
		return;
	}
}
if (vis[r][c]) return;
if (step &gt;= n) {
	if (r == (stax) &amp;&amp; c == (stay)) {
		for (int i = 1; i &lt;= step; i++)
			printf(&quot;%c&quot;, direction[path[i]]);
		printf(&quot;\n&quot;);
		cnt++;
	}
	return;
}

vis[r][c] = 1;
if (dir == 0 || dir == 3) {
	dfs(r, c, 1, step + 1);
	dfs(r, c, 2, step + 1);
}
else {
	dfs(r, c, 0, step + 1);
	dfs(r, c, 3, step + 1);
}
vis[r][c] = 0;
}</code></pre>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>颜色的长度</title>
    <url>/2020/03/30/%E9%A2%9C%E8%89%B2%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="uva-1625-颜色的长度"><a class="markdownIt-Anchor" href="#uva-1625-颜色的长度"></a> UVA 1625 颜色的长度</h1>
<p>输入两个长度分别是n和m(n,m&lt;=5000)的颜色序列，要求按顺序合并成同一个序列，即每次可以把一个序列开头的颜色放到新序列的尾部。</p>
<p>例如，两个颜色序列GBBY和YRRGB，至少有两种合并结果：GBYBRYRGB和YRRGGBBYB。对于每种颜色来说其跨度L©等于最大位置和最小位置之差。例如，对于上面两种合并结果，每种颜色的L©和所有L©的总和如图</p>
<p><img src="/UVA_img/9.png" alt="" /></p>
<p>你的任务是找一种合并方式，使得所有L©的总和最小</p>
<h1 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h1>
<ol>
<li>收到lcs的启发，考虑使用d[i][j]来表示第一个序列使用了前i个字符，第j个序列使用了前j个字符时的最小花费。问题在于，如果每次更新的时候屈计算l©会导致时间复杂度过高。</li>
<li>关于L©的计算：需要知道的刚刚移入最终序列的字符是否已经全部用完，并且要知道他最早在最终序列中出现的位置。如果记录每个颜色第一次出现的位置，状态会变得很复杂。所以尝试转换思路，不是等一个颜色全部移完再计算。而是每次累加。即，当把一个颜色移动到最终序列前，需要把所有已经出现但是还没结束的颜色的L©+1。也就是说，并不关心每种颜色的L©，只需要知道有多少种颜色已经开始但尚未结束</li>
<li>欲实现上述操作，则需要记录每种元素(26个大写字母)第一次和最后一次出现的位置</li>
</ol>
<h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1>
<h2 id="初始化过程"><a class="markdownIt-Anchor" href="#初始化过程"></a> 初始化过程</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 1000;</span><br><span class="line">#define inf 1000000</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line">int much[maxn][maxn];&#x2F;&#x2F;记录[i][j]状态下总的L(c)</span><br><span class="line">char ts[2][maxn];	&#x2F;&#x2F;输入字符串</span><br><span class="line">int s[2][maxn];		&#x2F;&#x2F;输入字符串-&#39;A&#39;</span><br><span class="line">int first[2][26];	&#x2F;&#x2F;每个颜色第一次出现的位置</span><br><span class="line">int last[2][26];	&#x2F;&#x2F;每个颜色最后一次出现的位置</span><br><span class="line">int main() &#123;</span><br><span class="line">	int T;</span><br><span class="line">	scanf(&quot;%d\n&quot;, &amp;T);</span><br><span class="line">	while (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf(&quot;%s\n%s\n&quot;, ts[0] + 1, ts[1] + 1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		int len1 &#x3D; strlen(ts[0] + 1);</span><br><span class="line">		int len2 &#x3D; strlen(ts[1] + 1);</span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; len1; i++) s[0][i] &#x3D; ts[0][i] - &#39;A&#39;;</span><br><span class="line">		for (int i &#x3D; 1; i &lt;&#x3D; len2; i++) s[1][i] &#x3D; ts[1][i] - &#39;A&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; 2; i++)</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 26; j++) &#123;</span><br><span class="line">				first[i][j] &#x3D; inf;</span><br><span class="line">				last[i][j] &#x3D; -1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		for (int i &#x3D; 0; i &lt; 2; i++) &#123;</span><br><span class="line">			int len &#x3D; strlen(ts[i] + 1);</span><br><span class="line">			for (int j &#x3D; 0; j &lt; 26; j++) &#123;</span><br><span class="line"></span><br><span class="line">				for (int k &#x3D; 1; k &lt;&#x3D; len; k++)</span><br><span class="line">					if (s[i][k] &#x3D;&#x3D; j) &#123;</span><br><span class="line">						first[i][j] &#x3D; k;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				for (int k &#x3D; len; k &gt;&#x3D; 1; k--)</span><br><span class="line">					if (s[i][k] &#x3D;&#x3D; j) &#123;</span><br><span class="line">						last[i][j] &#x3D; k;</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dp过程"><a class="markdownIt-Anchor" href="#dp过程"></a> dp过程</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">much[0][0] &#x3D; 0;</span><br><span class="line">		dp[0][0] &#x3D; 0;</span><br><span class="line">		for (int i &#x3D; 0; i &lt;&#x3D; len1; i++) &#123;</span><br><span class="line">			for (int j &#x3D; 0; j &lt;&#x3D; len2; j++) &#123;</span><br><span class="line">				if (!i &amp;&amp; !j) continue;</span><br><span class="line">				dp[i][j] &#x3D; inf;</span><br><span class="line">				if (i) &#123;&#x2F;&#x2F;d[i][j]可能是由d[i-1][j]从第一个串中取一个元素而来</span><br><span class="line">					dp[i][j] &#x3D; min(dp[i][j], dp[i - 1][j] + much[i - 1][j]);</span><br><span class="line"></span><br><span class="line">					&#x2F;&#x2F;判断s1[i]是否是已经出现但尚未用完的元素</span><br><span class="line">					much[i][j] &#x3D; much[i - 1][j];</span><br><span class="line">					int c &#x3D; s[0][i];</span><br><span class="line">					if (i &#x3D;&#x3D; first[0][c] &amp;&amp; j &lt; first[1][c])&#x2F;&#x2F;是第一次出现，则+1</span><br><span class="line">						much[i][j]++;</span><br><span class="line">					if (i &#x3D;&#x3D; last[0][c] &amp;&amp; j &gt;&#x3D; last[1][c])&#x2F;&#x2F;是最后一次出现，则-1</span><br><span class="line">						much[i][j]--;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">				if (j) &#123;&#x2F;&#x2F;与上述对称</span><br><span class="line">					dp[i][j] &#x3D; min(dp[i][j], dp[i][j - 1] + much[i][j - 1]);</span><br><span class="line">					much[i][j] &#x3D; much[i][j - 1];</span><br><span class="line">					int c &#x3D; s[1][j];</span><br><span class="line"></span><br><span class="line">					if (i &lt; first[0][c] &amp;&amp; j &#x3D;&#x3D; first[1][c])</span><br><span class="line">						much[i][j]++;</span><br><span class="line">					if (i &gt;&#x3D; last[0][c] &amp;&amp; j &#x3D;&#x3D; last[1][c])</span><br><span class="line">						much[i][j]--;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		printf(&quot;%d\n&quot;, dp[len1][len2]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理</title>
    <url>/2020/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="数据表示"><a class="markdownIt-Anchor" href="#数据表示"></a> 数据表示</h1>
<h2 id="检错与纠错码"><a class="markdownIt-Anchor" href="#检错与纠错码"></a> 检错与纠错码</h2>
<h3 id="crc"><a class="markdownIt-Anchor" href="#crc"></a> CRC</h3>
<img src="/MyImages/image-20200617204450964.png" alt="image-20200617204450964" style="zoom:33%;" />
<img src="/MyImages/image-20200617204655088.png" alt="image-20200617204655088" style="zoom: 67%;" />
<ul>
<li>纠正所有一位错误；<br />
检测所有一位或两位错误；<br />
检测所有奇数位错误；<br />
检测所有低于16位的突发性错误；<br />
大于16位的突发性错误，可以检测出的概率为99.9％。</li>
</ul>
<h3 id="海明码"><a class="markdownIt-Anchor" href="#海明码"></a> 海明码</h3>
<img src="/MyImages/image-20200617205057638.png" alt="image-20200617205057638" style="zoom:33%;" />
<ul>
<li>最小海明距离Dmin决定了该编码校验和纠正错误的能力。</li>
<li>海明编码可以校正 $$floor((D_{min}-1)/2)$$个码位错误</li>
<li>要能校正k个错误，编码方案的最小海明距离必须大于2k＋1</li>
</ul>
<h1 id="运算方法与运算器"><a class="markdownIt-Anchor" href="#运算方法与运算器"></a> 运算方法与运算器</h1>
<h2 id="定点数运算"><a class="markdownIt-Anchor" href="#定点数运算"></a> 定点数运算</h2>
<h3 id="加减运算"><a class="markdownIt-Anchor" href="#加减运算"></a> 加减运算</h3>
<img src="/MyImages/image-20200617210853506.png" alt="image-20200617210853506" style="zoom: 33%;" />
<h4 id="同号加异号减可能溢出"><a class="markdownIt-Anchor" href="#同号加异号减可能溢出"></a> 同号加异号减可能溢出</h4>
<img src="/MyImages/image-20200617211005101.png" alt="image-20200617211005101" style="zoom: 33%;" />
<img src="/MyImages/image-20200617211108225.png" alt="image-20200617211108225" style="zoom:33%;" />
<img src="/MyImages/image-20200617211133153.png" alt="image-20200617211133153" style="zoom: 33%;" />
<h3 id="乘法运算"><a class="markdownIt-Anchor" href="#乘法运算"></a> 乘法运算</h3>
<ul>
<li>
<p>原码乘法运算</p>
<ul>
<li>原码一位乘法</li>
<li>原码二位乘法</li>
</ul>
</li>
<li>
<p>补码乘法运算</p>
<ul>
<li>补码一位乘法：校正法，布斯(Booth)法</li>
<li>补码二位乘法</li>
</ul>
</li>
</ul>
<h4 id="原码一位乘法"><a class="markdownIt-Anchor" href="#原码一位乘法"></a> 原码一位乘法</h4>
<ul>
<li>乘积的符号为被乘数的符号位与乘数的符号位相异或；</li>
<li>乘积的绝对值为被乘数的绝对值与乘数的绝对值之积。即<br />
[X]原×[Y]原＝(X0⊕Y0 )(|X|×|Y|)<img src="/MyImages/image-20200617211630578.png" alt="image-20200617211630578" style="zoom:33%;" /></li>
</ul>
<h4 id="原码二位乘法"><a class="markdownIt-Anchor" href="#原码二位乘法"></a> 原码二位乘法</h4>
<img src="/MyImages/image-20200617211904414.png" alt="image-20200617211904414" style="zoom: 67%;" />
<img src="/MyImages/image-20200617212136663.png" alt="image-20200617212136663" style="zoom: 33%;" />
<h4 id="补码一位乘法校正法"><a class="markdownIt-Anchor" href="#补码一位乘法校正法"></a> 补码一位乘法：校正法</h4>
<img src="/MyImages/image-20200617212312907.png" alt="image-20200617212312907" style="zoom: 33%;" />
<img src="/MyImages/image-20200617212419883.png" alt="image-20200617212419883" style="zoom:33%;" />
<h4 id="补码一位乘法布斯法"><a class="markdownIt-Anchor" href="#补码一位乘法布斯法"></a> 补码一位乘法：布斯法</h4>
<img src="/MyImages/image-20200617212849208.png" alt="image-20200617212849208" style="zoom:50%;" />
<img src="/MyImages/image-20200617212908303.png" alt="image-20200617212908303" style="zoom: 33%;" />
<h3 id="除法运算"><a class="markdownIt-Anchor" href="#除法运算"></a> 除法运算</h3>
<h4 id="原码除法"><a class="markdownIt-Anchor" href="#原码除法"></a> 原码除法</h4>
<img src="/MyImages/image-20200617213228025.png" alt="image-20200617213228025" style="zoom:33%;" />
<h4 id="恢复余数法"><a class="markdownIt-Anchor" href="#恢复余数法"></a> 恢复余数法</h4>
<img src="/MyImages/image-20200617213329467.png" alt="image-20200617213329467" style="zoom:33%;" />
<h4 id="加减交替法"><a class="markdownIt-Anchor" href="#加减交替法"></a> 加减交替法</h4>
<img src="/MyImages/image-20200617213425754.png" alt="image-20200617213425754" style="zoom:33%;" />
<h1 id="存储系统"><a class="markdownIt-Anchor" href="#存储系统"></a> 存储系统</h1>
<h2 id="存储系统的层次结构"><a class="markdownIt-Anchor" href="#存储系统的层次结构"></a> 存储系统的层次结构</h2>
<img src="/MyImages/image-20200617213727149.png" alt="image-20200617213727149" style="zoom: 33%;" />
<h3 id="内存字扩展"><a class="markdownIt-Anchor" href="#内存字扩展"></a> 内存字扩展</h3>
<img src="/MyImages/image-20200617214004213.png" alt="image-20200617214004213" style="zoom:33%;" />
<h3 id="内存位扩展"><a class="markdownIt-Anchor" href="#内存位扩展"></a> 内存位扩展</h3>
<img src="/MyImages/image-20200617214048248.png" alt="image-20200617214048248" style="zoom:33%;" />
<h2 id="高速缓冲存储器"><a class="markdownIt-Anchor" href="#高速缓冲存储器"></a> 高速缓冲存储器</h2>
<img src="/MyImages/image-20200617214311548.png" alt="image-20200617214311548" style="zoom:33%;" />
<h3 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h3>
<ul>
<li>
<p>基于时间局部性和空间局部性原理</p>
</li>
<li>
<p>工作过程：</p>
<ul>
<li>
<p>流水处理：地址变换、访问Cache</p>
</li>
<li>
<p>Cache-处理机通路</p>
<p>主存-处理机直接通路</p>
</li>
<li>
<p>有Cache存储器的主存系统都采用多体交叉存储器。</p>
</li>
</ul>
</li>
</ul>
<h3 id="地址映射"><a class="markdownIt-Anchor" href="#地址映射"></a> 地址映射</h3>
<h4 id="全相联"><a class="markdownIt-Anchor" href="#全相联"></a> 全相联</h4>
<ul>
<li>映射规则：主存的任意一块可以映象到Cache中的任意一块。</li>
<li>特点：
<ul>
<li>块冲突概率低，Cache空间利用率高。</li>
<li>相联目录表容量大→成本高、查表速度慢。</li>
</ul>
</li>
</ul>
<p><img src="/MyImages/image-20200620110538206.png" alt="image-20200620110538206" /></p>
<h4 id="直接映射"><a class="markdownIt-Anchor" href="#直接映射"></a> 直接映射</h4>
<ul>
<li>映射规则：主存的每一块只能映象到Cache的一个特定的块中。</li>
<li>优点：
<ul>
<li>硬件简单，<strong>不需要相联存储器</strong>，只要
<ul>
<li>容量较小的按地址访问的区号标志表存储器；</li>
<li>少量外比较电路。</li>
</ul>
</li>
<li>访问速度快（无需地址变换）</li>
</ul>
</li>
<li>缺点：
<ul>
<li>Cache块冲突概率高；</li>
<li>Cache空间利用率很低</li>
</ul>
</li>
</ul>
<img src="/MyImages/image-20200620110928330.png" alt="image-20200620110928330" style="zoom: 50%;" />
<h4 id="组相联"><a class="markdownIt-Anchor" href="#组相联"></a> 组相联</h4>
<ul>
<li>
<p>映射规则：将主存和Cache都机械等分成相同大小的块，并将主存空间按照Cache大小等分成区，再将Cache和主存空间中的每一区都等分成大小相同的组，让主存各区中的某组中的任何一块均可直接映象装入到Cache中对应组的任何一块上。<strong>从主存的组到Cache的组之间采用直接映象方式，在两个对应的组内部采用全相联映象方式 ——组间直接，组内全相联。</strong></p>
</li>
<li>
<p>优点：</p>
<ul>
<li>块的冲突概率比较低；</li>
<li>块的利用率大幅度提高；</li>
<li>块的失效率明显降低。</li>
</ul>
</li>
<li>
<p>缺点：实现难度和造价比直接映射方式高。</p>
<img src="/MyImages/image-20200620111453084.png" alt="image-20200620111453084" style="zoom:50%;" />
</li>
</ul>
<h3 id="替换算法"><a class="markdownIt-Anchor" href="#替换算法"></a> 替换算法</h3>
<img src="/MyImages/image-20200620111852270.png" alt="image-20200620111852270" style="zoom:50%;" />
<h3 id="主存与cache内容一致性问题"><a class="markdownIt-Anchor" href="#主存与cache内容一致性问题"></a> 主存与Cache内容一致性问题</h3>
<img src="/MyImages/image-20200620112341384.png" alt="image-20200620112341384" style="zoom: 33%;" />
<img src="/MyImages/image-20200620112528938.png" alt="image-20200620112528938" style="zoom:33%;" />
<img src="/MyImages/image-20200620112537661.png" alt="image-20200620112537661" style="zoom:33%;" />
<h2 id="虚拟存储器"><a class="markdownIt-Anchor" href="#虚拟存储器"></a> 虚拟存储器</h2>
<h3 id="段式虚拟存储器"><a class="markdownIt-Anchor" href="#段式虚拟存储器"></a> 段式虚拟存储器</h3>
<img src="/MyImages/image-20200620112810784.png" alt="image-20200620112810784" style="zoom:33%;" />
<img src="/MyImages/image-20200620113155265.png" alt="image-20200620113155265" style="zoom:33%;" />
<img src="/MyImages/image-20200620113333378.png" alt="image-20200620113333378" style="zoom:33%;" />
<img src="/MyImages/image-20200620113939668.png" alt="image-20200620113939668" style="zoom:33%;" />
<h3 id="页式虚拟存储器"><a class="markdownIt-Anchor" href="#页式虚拟存储器"></a> 页式虚拟存储器</h3>
<img src="/MyImages/image-20200620114110491.png" alt="image-20200620114110491" style="zoom:33%;" />
<img src="/MyImages/image-20200620114122809.png" alt="image-20200620114122809" style="zoom:33%;" />
<h3 id="段页式虚拟存储器"><a class="markdownIt-Anchor" href="#段页式虚拟存储器"></a> 段页式虚拟存储器</h3>
<img src="/MyImages/image-20200620114615930.png" alt="image-20200620114615930" style="zoom:33%;" />
<img src="/MyImages/image-20200620114703447.png" alt="image-20200620114703447" style="zoom:33%;" />
<h3 id="替换算法-2"><a class="markdownIt-Anchor" href="#替换算法-2"></a> 替换算法</h3>
<p><img src="/MyImages/image-20200620115038029.png" alt="image-20200620115038029" /></p>
<h1 id="中央处理器-cpu"><a class="markdownIt-Anchor" href="#中央处理器-cpu"></a> 中央处理器 CPU</h1>
<h2 id="cpu结构与微操作"><a class="markdownIt-Anchor" href="#cpu结构与微操作"></a> CPU结构与微操作</h2>
<ul>
<li>
<p><strong>指令周期</strong>：由CPU完成的操作序列构成一个指令周期（instruction cycle）</p>
<ul>
<li>取指令子周期（fetch cycle）</li>
<li>执行指令子周期（execute cycle）
<ul>
<li>取数子周期</li>
<li>执行子周期</li>
<li>存数子周期</li>
</ul>
</li>
<li>中断子周期（interrupt cycle）</li>
</ul>
</li>
<li>
<p><strong>微操作</strong>：处理器（CPU）的基本或原子操作。每一个微操作是通过控制器将控制信号发送到相关部件上引起部件动作而完成的。</p>
</li>
</ul>
<h1 id="流水线技术与指令级并行"><a class="markdownIt-Anchor" href="#流水线技术与指令级并行"></a> 流水线技术与指令级并行</h1>
<h2 id="流水线处理"><a class="markdownIt-Anchor" href="#流水线处理"></a> 流水线处理</h2>
<h3 id="并行性"><a class="markdownIt-Anchor" href="#并行性"></a> 并行性</h3>
<ol>
<li><strong>空间并行性</strong>：即在一个处理机内设置多个独立的操作部件，并让这些操作部件并行工作，这种处理机称为<strong>多操作部件处理机或超标量处理机</strong>；</li>
<li><strong>时间并行性</strong>：就是采用流水线技术。流水线技术是一种非常经济、对提高处理机的运算速度非常有效的技术。采用流水线技术可以不增加硬件或只需要增加少量硬件就能够把处理机的运算速度提高几倍，它是目前使用非常普遍的一种并行处理方式。</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot笔记</title>
    <url>/2020/03/30/SpringBoot%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一-spring-boot-入门"><a class="markdownIt-Anchor" href="#一-spring-boot-入门"></a> **一、**Spring Boot 入门</h1>
<h2 id="1-spring-boot-简介"><a class="markdownIt-Anchor" href="#1-spring-boot-简介"></a> 1、Spring Boot 简介</h2>
<p>简化Spring应用开发的一个框架；</p>
<p>整个Spring技术栈的一个大整合；</p>
<p>J2EE开发的一站式解决方案；</p>
<h2 id="2-微服务"><a class="markdownIt-Anchor" href="#2-微服务"></a> 2、微服务</h2>
<p>在2014，martin fowler</p>
<p>微服务：架构风格（服务微化）</p>
<p>一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；</p>
<p>单体应用：ALL IN ONE</p>
<p>微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；</p>
<p><a href="https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa" target="_blank" rel="noopener">详细参照微服务文档</a></p>
<h2 id="3-环境准备"><a class="markdownIt-Anchor" href="#3-环境准备"></a> 3、环境准备</h2>
<p><a href="http://www.gulixueyuan.com/" target="_blank" rel="noopener">http://www.gulixueyuan.com/</a> 谷粒学院</p>
<p>环境约束</p>
<p>–jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_112”</p>
<p>–maven3.x：maven 3.3以上版本；Apache Maven 3.3.9</p>
<p>–IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS</p>
<p>–SpringBoot 1.5.9.RELEASE：1.5.9；</p>
<p>统一环境；</p>
<h3 id="1-maven设置"><a class="markdownIt-Anchor" href="#1-maven设置"></a> 1、MAVEN设置；</h3>
<p>给maven 的settings.xml配置文件的profiles标签添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-idea设置"><a class="markdownIt-Anchor" href="#2-idea设置"></a> 2、IDEA设置</h3>
<p>整合maven进来；</p>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180129151045.png" alt="idea设置" /></p>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180129151112.png" alt="images/" /></p>
<h2 id="4-spring-boot-helloworld"><a class="markdownIt-Anchor" href="#4-spring-boot-helloworld"></a> 4、Spring Boot HelloWorld</h2>
<p>一个功能：</p>
<p>浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；</p>
<h3 id="1-创建一个maven工程jar"><a class="markdownIt-Anchor" href="#1-创建一个maven工程jar"></a> 1、创建一个maven工程；（jar）</h3>
<h3 id="2-导入spring-boot相关的依赖"><a class="markdownIt-Anchor" href="#2-导入spring-boot相关的依赖"></a> 2、导入spring boot相关的依赖</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-编写一个主程序启动spring-boot应用"><a class="markdownIt-Anchor" href="#3-编写一个主程序启动spring-boot应用"></a> 3、编写一个主程序；启动Spring Boot应用</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring应用启动起来</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-编写相关的controller-service"><a class="markdownIt-Anchor" href="#4-编写相关的controller-service"></a> 4、编写相关的Controller、Service</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-运行主程序测试"><a class="markdownIt-Anchor" href="#5-运行主程序测试"></a> 5、运行主程序测试</h3>
<h3 id="6-简化部署"><a class="markdownIt-Anchor" href="#6-简化部署"></a> 6、简化部署</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>将这个应用打成jar包，直接使用java -jar的命令进行执行；</p>
<h2 id="5-hello-world探究"><a class="markdownIt-Anchor" href="#5-hello-world探究"></a> 5、Hello World探究</h2>
<h3 id="1-pom文件"><a class="markdownIt-Anchor" href="#1-pom文件"></a> 1、POM文件</h3>
<h4 id="1-父项目"><a class="markdownIt-Anchor" href="#1-父项目"></a> 1、父项目</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">他的父项目是</span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">他来真正管理Spring Boot应用里面的所有依赖版本；</span><br></pre></td></tr></table></figure>
<p>Spring Boot的版本仲裁中心；</p>
<p>以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号）</p>
<h4 id="2-启动器"><a class="markdownIt-Anchor" href="#2-启动器"></a> 2、启动器</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>spring-boot-starter</strong>-<mark>web</mark>：</p>
<p>​	spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；</p>
<p>Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器</p>
<h3 id="2-主程序类主入口类"><a class="markdownIt-Anchor" href="#2-主程序类主入口类"></a> 2、主程序类，主入口类</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring应用启动起来</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@<strong>SpringBootApplication</strong>:    Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">      <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">      @<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>@<strong>SpringBootConfiguration</strong>:Spring Boot的配置类；</p>
<p>​		标注在某个类上，表示这是一个Spring Boot的配置类；</p>
<p>​		@<strong>Configuration</strong>:配置类上来标注这个注解；</p>
<p>​			配置类 -----  配置文件；配置类也是容器中的一个组件；@Component</p>
<p>@<strong>EnableAutoConfiguration</strong>：开启自动配置功能；</p>
<p>​		以前我们需要配置的东西，Spring Boot帮我们自动配置；@<strong>EnableAutoConfiguration</strong>告诉SpringBoot开启自动配置功能；这样自动配置才能生效；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>​      	@<strong>AutoConfigurationPackage</strong>：自动配置包</p>
<p>​		@<strong>Import</strong>(AutoConfigurationPackages.Registrar.class)：</p>
<p>​		Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class；</p>
<p><mark>将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；</mark></p>
<p>​	@<strong>Import</strong>(EnableAutoConfigurationImportSelector.class)；</p>
<p>​		给容器中导入组件？</p>
<p>​		<strong>EnableAutoConfigurationImportSelector</strong>：导入哪些组件的选择器；</p>
<p>​		将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；</p>
<p>​		会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；		<img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180129224104.png" alt="自动配置类" /></p>
<p>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；</p>
<p>​		SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；</p>
<p>==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们；</p>
<p>J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar；</p>
<p>​</p>
<p><mark>Spring注解版（谷粒学院）</mark></p>
<h2 id="6-使用spring-initializer快速创建spring-boot项目"><a class="markdownIt-Anchor" href="#6-使用spring-initializer快速创建spring-boot项目"></a> 6、使用Spring Initializer快速创建Spring Boot项目</h2>
<h3 id="1-idea使用-spring-initializer快速创建项目"><a class="markdownIt-Anchor" href="#1-idea使用-spring-initializer快速创建项目"></a> 1、IDEA：使用 Spring Initializer快速创建项目</h3>
<p>IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；</p>
<p>选择我们需要的模块；向导会联网创建Spring Boot项目；</p>
<p>默认生成的Spring Boot项目；</p>
<ul>
<li>主程序已经生成好了，我们只需要我们自己的逻辑</li>
<li>resources文件夹中目录结构
<ul>
<li>static：保存所有的静态资源； js css  images；</li>
<li>templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；</li>
<li>application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；</li>
</ul>
</li>
</ul>
<h3 id="2-sts使用-spring-starter-project快速创建项目"><a class="markdownIt-Anchor" href="#2-sts使用-spring-starter-project快速创建项目"></a> 2、STS使用 Spring Starter Project快速创建项目</h3>
<hr />
<h1 id="二-配置文件"><a class="markdownIt-Anchor" href="#二-配置文件"></a> 二、配置文件</h1>
<h2 id="1-配置文件"><a class="markdownIt-Anchor" href="#1-配置文件"></a> 1、配置文件</h2>
<p>SpringBoot使用一个全局的配置文件，配置文件名是固定的；</p>
<p>•application.properties</p>
<p>•application.yml</p>
<p>配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；</p>
<p>YAML（YAML Ain’t Markup Language）</p>
<p>​	YAML  A Markup Language：是一个标记语言</p>
<p>​	YAML   isn’t Markup Language：不是一个标记语言；</p>
<p>标记语言：</p>
<p>​	以前的配置文件；大多都使用的是  <strong>xxxx.xml</strong>文件；</p>
<p>​	YAML：<strong>以数据为中心</strong>，比json、xml等更适合做配置文件；</p>
<p>​	YAML：配置例子</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>
<p>​	XML：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">port</span>&gt;</span>8081<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-yaml语法"><a class="markdownIt-Anchor" href="#2-yaml语法"></a> 2、YAML语法：</h2>
<h3 id="1-基本语法"><a class="markdownIt-Anchor" href="#1-基本语法"></a> 1、基本语法</h3>
<p>k:(空格)v：表示一对键值对（空格必须有）；</p>
<p>以<strong>空格</strong>的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/hello</span></span><br></pre></td></tr></table></figure>
<p>属性和值也是大小写敏感；</p>
<h3 id="2-值的写法"><a class="markdownIt-Anchor" href="#2-值的写法"></a> 2、值的写法</h3>
<h4 id="字面量普通的值数字字符串布尔"><a class="markdownIt-Anchor" href="#字面量普通的值数字字符串布尔"></a> 字面量：普通的值（数字，字符串，布尔）</h4>
<p>​	k: v：字面直接来写；</p>
<p>​		字符串默认不用加上单引号或者双引号；</p>
<p>​		“”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思</p>
<p>​				name:   “zhangsan \n lisi”：输出；zhangsan 换行  lisi</p>
<p>​		‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p>
<p>​				name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi</p>
<h4 id="对象-map属性和值键值对"><a class="markdownIt-Anchor" href="#对象-map属性和值键值对"></a> 对象、Map（属性和值）（键值对）：</h4>
<p>​	k: v：在下一行来写对象的属性和值的关系；注意缩进</p>
<p>​		对象还是k: v的方式</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line">		<span class="attr">lastName:</span> <span class="string">zhangsan</span></span><br><span class="line">		<span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>行内写法：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">friends:</span> <span class="string">&#123;lastName:</span> <span class="string">zhangsan,age:</span> <span class="number">18</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="数组list-set"><a class="markdownIt-Anchor" href="#数组list-set"></a> 数组（List、Set）：</h4>
<p>用- 值表示数组中的一个元素</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">dog</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure>
<p>行内写法</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pets:</span> <span class="string">[cat,dog,pig]</span></span><br></pre></td></tr></table></figure>
<h2 id="3-配置文件值注入"><a class="markdownIt-Anchor" href="#3-配置文件值注入"></a> 3、配置文件值注入</h2>
<p>配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">    <span class="attr">lastName:</span> <span class="string">hello</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">    <span class="attr">boss:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">birth:</span> <span class="number">2017</span><span class="string">/12/12</span></span><br><span class="line">    <span class="attr">maps:</span> <span class="string">&#123;k1:</span> <span class="string">v1,k2:</span> <span class="number">12</span><span class="string">&#125;</span></span><br><span class="line">    <span class="attr">lists:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">lisi</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zhaoliu</span></span><br><span class="line">    <span class="attr">dog:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">小狗</span></span><br><span class="line">      <span class="attr">age:</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>javaBean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将配置文件中配置的每一个属性的值，映射到这个组件中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span></span><br><span class="line"><span class="comment"> *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有这个组件是容器中的组件，才能容器提供的<span class="doctag">@ConfigurationProperties</span>功能；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure>
<p>我们可以导入配置文件处理器，以后编写配置就有提示了</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="1-properties配置文件在idea中默认utf-8可能会乱码"><a class="markdownIt-Anchor" href="#1-properties配置文件在idea中默认utf-8可能会乱码"></a> 1、properties配置文件在idea中默认utf-8可能会乱码</h4>
<p>调整</p>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180130161620.png" alt="idea配置乱码" /></p>
<h4 id="2-value获取值和configurationproperties获取值比较"><a class="markdownIt-Anchor" href="#2-value获取值和configurationproperties获取值比较"></a> 2、@Value获取值和@ConfigurationProperties获取值比较</h4>
<table>
<thead>
<tr>
<th></th>
<th>@ConfigurationProperties</th>
<th>@Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>功能</td>
<td>批量注入配置文件中的属性</td>
<td>一个个指定</td>
</tr>
<tr>
<td>松散绑定（松散语法）</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>SpEL</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>JSR303数据校验</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>复杂类型封装</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>
<p>配置文件yml还是properties他们都能获取到值；</p>
<p>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；</p>
<p>如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；</p>
<h4 id="3-配置文件注入值数据校验"><a class="markdownIt-Anchor" href="#3-配置文件注入值数据校验"></a> 3、配置文件注入值数据校验</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">     *      &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;bean/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//lastName必须是邮箱格式</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="comment">//@Value("$&#123;person.last-name&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">//@Value("#&#123;11*2&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//@Value("true")</span></span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure>
<h4 id="4-propertysourceimportresourcebean"><a class="markdownIt-Anchor" href="#4-propertysourceimportresourcebean"></a> 4、@PropertySource&amp;@ImportResource&amp;@Bean</h4>
<p>@<strong>PropertySource</strong>：加载指定的配置文件；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将配置文件中配置的每一个属性的值，映射到这个组件中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span></span><br><span class="line"><span class="comment"> *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有这个组件是容器中的组件，才能容器提供的<span class="doctag">@ConfigurationProperties</span>功能；</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@ConfigurationProperties</span>(prefix = "person")默认从全局配置文件中获取值；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:person.properties"</span>&#125;)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="comment">//@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">     *      &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;bean/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//lastName必须是邮箱格式</span></span><br><span class="line">   <span class="comment">// @Email</span></span><br><span class="line">    <span class="comment">//@Value("$&#123;person.last-name&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">//@Value("#&#123;11*2&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//@Value("true")</span></span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br></pre></td></tr></table></figure>
<p>@<strong>ImportResource</strong>：导入Spring的配置文件，让配置文件里面的内容生效；</p>
<p>Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；</p>
<p>想让Spring的配置文件生效，加载进来；@<strong>ImportResource</strong>标注在一个配置类上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(locations = &#123;<span class="string">"classpath:beans.xml"</span>&#125;)</span><br><span class="line">导入Spring的配置文件让其生效</span><br></pre></td></tr></table></figure>
<p>不来编写Spring的配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloService"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.springboot.service.HelloService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式</p>
<p>1、配置类**@Configuration**------&gt;Spring配置文件</p>
<p>2、使用**@Bean**给容器中添加组件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span>：指明当前类是一个配置类；就是来替代之前的Spring配置文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"配置类@Bean给容器中添加组件了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##4、配置文件占位符</p>
<h3 id="1-随机数"><a class="markdownIt-Anchor" href="#1-随机数"></a> 1、随机数</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$&#123;random.value&#125;、$&#123;random.<span class="keyword">int</span>&#125;、$&#123;random.<span class="keyword">long</span>&#125;</span><br><span class="line">$&#123;random.<span class="keyword">int</span>(<span class="number">10</span>)&#125;、$&#123;random.<span class="keyword">int</span>[<span class="number">1024</span>,<span class="number">65536</span>]&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-占位符获取之前配置的值如果没有可以是用指定默认值"><a class="markdownIt-Anchor" href="#2-占位符获取之前配置的值如果没有可以是用指定默认值"></a> 2、占位符获取之前配置的值，如果没有可以是用:指定默认值</h3>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">person.last-name</span>=<span class="string">张三$&#123;random.uuid&#125;</span></span><br><span class="line"><span class="meta">person.age</span>=<span class="string">$&#123;random.int&#125;</span></span><br><span class="line"><span class="meta">person.birth</span>=<span class="string">2017/12/15</span></span><br><span class="line"><span class="meta">person.boss</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">person.maps.k1</span>=<span class="string">v1</span></span><br><span class="line"><span class="meta">person.maps.k2</span>=<span class="string">14</span></span><br><span class="line"><span class="meta">person.lists</span>=<span class="string">a,b,c</span></span><br><span class="line"><span class="meta">person.dog.name</span>=<span class="string">$&#123;person.hello:hello&#125;_dog</span></span><br><span class="line"><span class="meta">person.dog.age</span>=<span class="string">15</span></span><br></pre></td></tr></table></figure>
<h2 id="5-profile"><a class="markdownIt-Anchor" href="#5-profile"></a> 5、Profile</h2>
<h3 id="1-多profile文件"><a class="markdownIt-Anchor" href="#1-多profile文件"></a> 1、多Profile文件</h3>
<p>我们在主配置文件编写的时候，文件名可以是   application-{profile}.properties/yml</p>
<p>默认使用application.properties的配置；</p>
<h3 id="2-yml支持多文档块方式"><a class="markdownIt-Anchor" href="#2-yml支持多文档块方式"></a> 2、yml支持多文档块方式</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">prod</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8083</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8084</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">prod</span>  <span class="comment">#指定属于哪个环境</span></span><br></pre></td></tr></table></figure>
<h3 id="3-激活指定profile"><a class="markdownIt-Anchor" href="#3-激活指定profile"></a> 3、激活指定profile</h3>
<p>​	1、在配置文件中指定  spring.profiles.active=dev</p>
<p>​	2、命令行：</p>
<p>​		java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev；</p>
<p>​		可以直接在测试的时候，配置传入命令行参数</p>
<p>​	3、虚拟机参数；</p>
<p>​		-Dspring.profiles.active=dev</p>
<h2 id="6-配置文件加载位置"><a class="markdownIt-Anchor" href="#6-配置文件加载位置"></a> 6、配置文件加载位置</h2>
<p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p>
<p>–file:./config/</p>
<p>–file:./</p>
<p>–classpath:/config/</p>
<p>–classpath:/</p>
<p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p>
<p>SpringBoot会从这四个位置全部加载主配置文件；<strong>互补配置</strong>；</p>
<p><mark>我们还可以通过spring.config.location来改变默认的配置文件位置</mark></p>
<p><strong>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；</strong></p>
<p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --spring.config.location=G:/application.properties</p>
<h2 id="7-外部配置加载顺序"><a class="markdownIt-Anchor" href="#7-外部配置加载顺序"></a> 7、外部配置加载顺序</h2>
<p><strong><mark>SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置</mark></strong></p>
<p><strong>1.命令行参数</strong></p>
<p>所有的配置都可以在命令行上进行指定</p>
<p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --server.port=8087  --server.context-path=/abc</p>
<p>多个配置用空格分开； --配置项=值</p>
<p>2.来自java:comp/env的JNDI属性</p>
<p>3.Java系统属性（System.getProperties()）</p>
<p>4.操作系统环境变量</p>
<p>5.RandomValuePropertySource配置的random.*属性值</p>
<p><mark><strong>由jar包外向jar包内进行寻找；</strong></mark></p>
<p><mark><strong>优先加载带profile</strong></mark></p>
<p><strong>6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p>
<p><strong>7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p>
<p><mark><strong>再来加载不带profile</strong></mark></p>
<p><strong>8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件</strong></p>
<p><strong>9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></p>
<p>10.@Configuration注解类上的@PropertySource</p>
<p>11.通过SpringApplication.setDefaultProperties指定的默认属性</p>
<p>所有支持的配置加载来源；</p>
<p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">参考官方文档</a></p>
<h2 id="8-自动配置原理"><a class="markdownIt-Anchor" href="#8-自动配置原理"></a> 8、自动配置原理</h2>
<p>配置文件到底能写什么？怎么写？自动配置原理；</p>
<p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">配置文件能配置的属性参照</a></p>
<h3 id="1-自动配置原理"><a class="markdownIt-Anchor" href="#1-自动配置原理"></a> 1、<strong>自动配置原理：</strong></h3>
<p>1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 <mark>@EnableAutoConfiguration</mark></p>
<p><strong>2）、@EnableAutoConfiguration 作用：</strong></p>
<ul>
<li>
<p>利用EnableAutoConfigurationImportSelector给容器中导入一些组件？</p>
</li>
<li>
<p>可以查看selectImports()方法的内容；</p>
</li>
<li>
<p>List<String> configurations = getCandidateConfigurations(annotationMetadata,      attributes);获取候选的配置</p>
<ul>
<li>
<pre class="highlight"><code class="java">SpringFactoriesLoader.loadFactoryNames()
扫描所有jar包类路径下  META-INF/spring.factories
把扫描到的这些文件的内容包装成properties对象
从properties中获取到EnableAutoConfiguration<span class="class">.<span class="keyword">class</span>类（类名）对应的值，然后把他们添加在容器中

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">**&#x3D;&#x3D;将 类路径下  META-INF&#x2F;spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；&#x3D;&#x3D;**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;properties</span><br><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</span><br></pre></td></tr></table></figure>

</span></code></pre>
</li>
</ul>
</li>
</ul>
<p>每一个这样的  xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；</p>
<p>3）、每一个自动配置类进行自动配置功能；</p>
<p>4）、以**HttpEncodingAutoConfiguration（Http编码自动配置）**为例解释自动配置原理；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>   <span class="comment">//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HttpEncodingProperties<span class="class">.<span class="keyword">class</span>)  //启动指定类的<span class="title">ConfigurationProperties</span>功能；将配置文件中对应的值和<span class="title">HttpEncodingProperties</span>绑定起来；并把<span class="title">HttpEncodingProperties</span>加入到<span class="title">ioc</span>容器中</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnWebApplication</span> //<span class="title">Spring</span>底层@<span class="title">Conditional</span>注解（<span class="title">Spring</span>注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是<span class="title">web</span>应用，如果是，当前配置类生效</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnClass</span>(<span class="title">CharacterEncodingFilter</span>.<span class="title">class</span>)  //判断当前项目有没有这个类<span class="title">CharacterEncodingFilter</span>；<span class="title">SpringMVC</span>中进行乱码解决的过滤器；</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">prefix</span> </span>= <span class="string">"spring.http.encoding"</span>, value = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)  <span class="comment">//判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的</span></span><br><span class="line"><span class="comment">//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//他已经和SpringBoot的配置文件映射了</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> HttpEncodingProperties properties;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//只有一个有参构造器的情况下，参数的值就会从容器中拿</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpEncodingProperties properties)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.properties = properties;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span>(CharacterEncodingFilter<span class="class">.<span class="keyword">class</span>) //判断容器没有这个组件？</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">CharacterEncodingFilter</span> <span class="title">characterEncodingFilter</span>() </span>&#123;</span><br><span class="line">		CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">		filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">		filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.REQUEST));</span><br><span class="line">		filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.RESPONSE));</span><br><span class="line">		<span class="keyword">return</span> filter;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>根据当前不同的条件判断，决定这个配置类是否生效？</p>
<p>一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p>
<p>5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.http.encoding"</span>)  <span class="comment">//从配置文件中获取指定的值和bean的属性进行绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_CHARSET = Charset.forName(<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>精髓：</strong></p>
<p>​	<strong>1）、SpringBoot启动会加载大量的自动配置类</strong></p>
<p>​	<strong>2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；</strong></p>
<p>​	<strong>3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）</strong></p>
<p>​	<strong>4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；</strong></p>
<p>xxxxAutoConfigurartion：自动配置类；</p>
<p>给容器中添加组件</p>
<p>xxxxProperties:封装配置文件中相关属性；</p>
<h3 id="2-细节"><a class="markdownIt-Anchor" href="#2-细节"></a> 2、细节</h3>
<h4 id="1-conditional派生注解spring注解版原生的conditional作用"><a class="markdownIt-Anchor" href="#1-conditional派生注解spring注解版原生的conditional作用"></a> 1、@Conditional派生注解（Spring注解版原生的@Conditional作用）</h4>
<p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p>
<table>
<thead>
<tr>
<th>@Conditional扩展注解</th>
<th>作用（判断是否满足当前指定条件）</th>
</tr>
</thead>
<tbody>
<tr>
<td>@ConditionalOnJava</td>
<td>系统的java版本是否符合要求</td>
</tr>
<tr>
<td>@ConditionalOnBean</td>
<td>容器中存在指定Bean；</td>
</tr>
<tr>
<td>@ConditionalOnMissingBean</td>
<td>容器中不存在指定Bean；</td>
</tr>
<tr>
<td>@ConditionalOnExpression</td>
<td>满足SpEL表达式指定</td>
</tr>
<tr>
<td>@ConditionalOnClass</td>
<td>系统中有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnMissingClass</td>
<td>系统中没有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnSingleCandidate</td>
<td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td>
</tr>
<tr>
<td>@ConditionalOnProperty</td>
<td>系统中指定的属性是否有指定的值</td>
</tr>
<tr>
<td>@ConditionalOnResource</td>
<td>类路径下是否存在指定资源文件</td>
</tr>
<tr>
<td>@ConditionalOnWebApplication</td>
<td>当前是web环境</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>当前不是web环境</td>
</tr>
<tr>
<td>@ConditionalOnJndi</td>
<td>JNDI存在指定项</td>
</tr>
</tbody>
</table>
<p><strong>自动配置类必须在一定的条件下才能生效；</strong></p>
<p>我们怎么知道哪些自动配置类生效；</p>
<p><strong><mark>我们可以通过启用  debug=true属性；来让控制台打印自动配置报告</mark></strong>，这样我们就可以很方便的知道哪些自动配置类生效；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">=========================</span><br><span class="line">AUTO-CONFIGURATION REPORT</span><br><span class="line">=========================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Positive matches:（自动配置类启用的）</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   DispatcherServletAutoConfiguration matched:</span><br><span class="line">      - <span class="meta">@ConditionalOnClass</span> found required <span class="class"><span class="keyword">class</span> '<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">servlet</span>.<span class="title">DispatcherServlet</span>'</span>; <span class="meta">@ConditionalOnMissingClass</span> <span class="function">did not find unwanted <span class="title">class</span> <span class="params">(OnClassCondition)</span></span></span><br><span class="line"><span class="function">      - @<span class="title">ConditionalOnWebApplication</span> <span class="params">(required)</span> found <span class="title">StandardServletEnvironment</span> <span class="params">(OnWebApplicationCondition)</span></span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">Negative matches:（没有启动，没有匹配成功的自动配置类）</span></span><br><span class="line"><span class="function">-----------------</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   ActiveMQAutoConfiguration:</span></span><br><span class="line"><span class="function">      Did not match:</span></span><br><span class="line"><span class="function">         - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' <span class="params">(OnClassCondition)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   AopAutoConfiguration:</span></span><br><span class="line"><span class="function">      Did not match:</span></span><br><span class="line"><span class="function">         - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' <span class="params">(OnClassCondition)</span></span></span><br></pre></td></tr></table></figure>
<h1 id="三-日志"><a class="markdownIt-Anchor" href="#三-日志"></a> 三、日志</h1>
<h2 id="1-日志框架"><a class="markdownIt-Anchor" href="#1-日志框架"></a> 1、日志框架</h2>
<p>小张；开发一个大型系统；</p>
<p>​		1、System.out.println(&quot;&quot;)；将关键数据打印在控制台；去掉？写在一个文件？</p>
<p>​		2、框架来记录系统的一些运行时信息；日志框架 ；  zhanglogging.jar；</p>
<p>​		3、高大上的几个功能？异步模式？自动归档？xxxx？  zhanglogging-good.jar？</p>
<p>​		4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar；</p>
<p>​		5、JDBC—数据库驱动；</p>
<p>​			写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar；</p>
<p>​			给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层；</p>
<p><strong>市面上的日志框架；</strong></p>
<p>JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…</p>
<table>
<thead>
<tr>
<th>日志门面  （日志的抽象层）</th>
<th>日志实现</th>
</tr>
</thead>
<tbody>
<tr>
<td><s>JCL（Jakarta  Commons Logging）</s>    SLF4j（Simple  Logging Facade for Java）    <strong><s>jboss-logging</s></strong></td>
<td>Log4j  JUL（java.util.logging）  Log4j2  <strong>Logback</strong></td>
</tr>
</tbody>
</table>
<p>左边选一个门面（抽象层）、右边来选一个实现；</p>
<p>日志门面：  SLF4J；</p>
<p>日志实现：Logback；</p>
<p>SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘</p>
<p>​	<strong><mark>SpringBoot选用 SLF4j和logback；</mark></strong></p>
<h2 id="2-slf4j使用"><a class="markdownIt-Anchor" href="#2-slf4j使用"></a> 2、SLF4j使用</h2>
<h3 id="1-如何在系统中使用slf4j-httpswwwslf4jorg"><a class="markdownIt-Anchor" href="#1-如何在系统中使用slf4j-httpswwwslf4jorg"></a> 1、如何在系统中使用SLF4j   <a href="https://www.slf4j.org" target="_blank" rel="noopener">https://www.slf4j.org</a></h3>
<p>以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；</p>
<p>给系统里面导入slf4j的jar和  logback的实现jar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(HelloWorld<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    logger.info(<span class="string">"Hello World"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图示；</p>
<p><img src="images/concrete-bindings.png" alt="images/concrete-bindings.png" /></p>
<p>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，<strong>配置文件还是做成日志实现框架自己本身的配置文件；</strong></p>
<h3 id="2-遗留问题"><a class="markdownIt-Anchor" href="#2-遗留问题"></a> 2、遗留问题</h3>
<p>a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx</p>
<p>统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？</p>
<p><img src="images/legacy.png" alt="" /></p>
<p><strong>如何让系统中所有的日志都统一到slf4j；</strong></p>
<p><mark>1、将系统中其他日志框架先排除出去；</mark></p>
<p><mark>2、用中间包来替换原有的日志框架；</mark></p>
<p><mark>3、我们导入slf4j其他的实现</mark></p>
<h2 id="3-springboot日志关系"><a class="markdownIt-Anchor" href="#3-springboot日志关系"></a> 3、SpringBoot日志关系</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>SpringBoot使用它来做日志功能；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>底层依赖关系</p>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180131220946.png" alt="" /></p>
<p>总结：</p>
<p>​	1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录</p>
<p>​	2）、SpringBoot也把其他的日志都替换成了slf4j；</p>
<p>​	3）、中间替换包？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = <span class="string">"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> LogFactory logFactory = <span class="keyword">new</span> SLF4JLogFactory();</span><br></pre></td></tr></table></figure>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180131221411.png" alt="" /></p>
<p>​	4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？</p>
<p>​			Spring框架用的是commons-logging；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong><mark>SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；</mark></strong></p>
<h2 id="4-日志使用"><a class="markdownIt-Anchor" href="#4-日志使用"></a> 4、日志使用；</h2>
<h3 id="1-默认配置"><a class="markdownIt-Anchor" href="#1-默认配置"></a> 1、默认配置</h3>
<p>SpringBoot默认帮我们配置好了日志；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记录器</span></span><br><span class="line">Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//System.out.println();</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//日志的级别；</span></span><br><span class="line">	<span class="comment">//由低到高   trace&lt;debug&lt;info&lt;warn&lt;error</span></span><br><span class="line">	<span class="comment">//可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效</span></span><br><span class="line">	logger.trace(<span class="string">"这是trace日志..."</span>);</span><br><span class="line">	logger.debug(<span class="string">"这是debug日志..."</span>);</span><br><span class="line">	<span class="comment">//SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别</span></span><br><span class="line">	logger.info(<span class="string">"这是info日志..."</span>);</span><br><span class="line">	logger.warn(<span class="string">"这是warn日志..."</span>);</span><br><span class="line">	logger.error(<span class="string">"这是error日志..."</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>    日志输出格式：
		%d表示日期时间，
		%thread表示线程名，
		%-5level：级别从左显示5个字符宽度
		%logger{50} 表示logger名字最长50个字符，否则按照句点分割。 
		%msg：日志消息，
		%n是换行符
    --&gt;
    %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n
</code></pre>
<p>SpringBoot修改日志的默认配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">logging.level.com.atguigu</span>=<span class="string">trace</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#logging.path=</span></span><br><span class="line"><span class="comment"># 不指定路径在当前项目下生成springboot.log日志</span></span><br><span class="line"><span class="comment"># 可以指定完整的路径；</span></span><br><span class="line"><span class="comment">#logging.file=G:/springboot.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件</span></span><br><span class="line"><span class="meta">logging.path</span>=<span class="string">/spring/log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  在控制台输出的日志的格式</span></span><br><span class="line"><span class="meta">logging.pattern.console</span>=<span class="string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span></span><br><span class="line"><span class="comment"># 指定文件中日志输出的格式</span></span><br><span class="line"><span class="meta">logging.pattern.file</span>=<span class="string">%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>logging.file</th>
<th>logging.path</th>
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>(none)</td>
<td>(none)</td>
<td></td>
<td>只在控制台输出</td>
</tr>
<tr>
<td>指定文件名</td>
<td>(none)</td>
<td>my.log</td>
<td>输出日志到my.log文件</td>
</tr>
<tr>
<td>(none)</td>
<td>指定目录</td>
<td>/var/log</td>
<td>输出到指定目录的 spring.log 文件中</td>
</tr>
</tbody>
</table>
<h3 id="2-指定配置"><a class="markdownIt-Anchor" href="#2-指定配置"></a> 2、指定配置</h3>
<p>给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了</p>
<table>
<thead>
<tr>
<th>Logging System</th>
<th>Customization</th>
</tr>
</thead>
<tbody>
<tr>
<td>Logback</td>
<td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code> or <code>logback.groovy</code></td>
</tr>
<tr>
<td>Log4j2</td>
<td><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td>
</tr>
<tr>
<td>JDK (Java Util Logging)</td>
<td><code>logging.properties</code></td>
</tr>
</tbody>
</table>
<p>logback.xml：直接就被日志框架识别了；</p>
<p><strong>logback-spring.xml</strong>：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"staging"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the "staging" profile is active --&gt;</span></span><br><span class="line">  	可以指定某段配置只在某个环境下生效</span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"stdout"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        日志输出格式：</span></span><br><span class="line"><span class="comment">			%d表示日期时间，</span></span><br><span class="line"><span class="comment">			%thread表示线程名，</span></span><br><span class="line"><span class="comment">			%-5level：级别从左显示5个字符宽度</span></span><br><span class="line"><span class="comment">			%logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 </span></span><br><span class="line"><span class="comment">			%msg：日志消息，</span></span><br><span class="line"><span class="comment">			%n是换行符</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"!dev"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误</p>
<p><code>no applicable action for [springProfile]</code></p>
<h2 id="5-切换日志框架"><a class="markdownIt-Anchor" href="#5-切换日志框架"></a> 5、切换日志框架</h2>
<p>可以按照slf4j的日志适配图，进行相关的切换；</p>
<p>slf4j+log4j的方式；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>切换为log4j2</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<hr />
<h1 id="四-web开发"><a class="markdownIt-Anchor" href="#四-web开发"></a> 四、Web开发</h1>
<h2 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1、简介</h2>
<p>使用SpringBoot；</p>
<p><strong>1）、创建SpringBoot应用，选中我们需要的模块；</strong></p>
<p><strong>2）、SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来</strong></p>
<p><strong>3）、自己编写业务代码；</strong></p>
<p><strong>自动配置原理？</strong></p>
<p>这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxxxAutoConfiguration：帮我们给容器中自动配置组件；</span><br><span class="line">xxxxProperties:配置类来封装配置文件的内容；</span><br></pre></td></tr></table></figure>
<h2 id="2-springboot对静态资源的映射规则"><a class="markdownIt-Anchor" href="#2-springboot对静态资源的映射规则"></a> 2、SpringBoot对静态资源的映射规则；</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.resources"</span>, ignoreUnknownFields = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceProperties</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">  <span class="comment">//可以设置和静态资源有关的参数，缓存时间等</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebMvcAuotConfiguration：</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Default resource handling disabled"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Integer cachePeriod = <span class="keyword">this</span>.resourceProperties.getCachePeriod();</span><br><span class="line">		<span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">"/webjars/**"</span>)) &#123;</span><br><span class="line">			customizeResourceHandlerRegistration(</span><br><span class="line">					registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">							.addResourceLocations(</span><br><span class="line">									<span class="string">"classpath:/META-INF/resources/webjars/"</span>)</span><br><span class="line">					.setCachePeriod(cachePeriod));</span><br><span class="line">		&#125;</span><br><span class="line">		String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">         	<span class="comment">//静态资源文件夹映射</span></span><br><span class="line">		<span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">			customizeResourceHandlerRegistration(</span><br><span class="line">					registry.addResourceHandler(staticPathPattern)</span><br><span class="line">							.addResourceLocations(</span><br><span class="line">									<span class="keyword">this</span>.resourceProperties.getStaticLocations())</span><br><span class="line">					.setCachePeriod(cachePeriod));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//配置欢迎页映射</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title">welcomePageHandlerMapping</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ResourceProperties resourceProperties)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> WelcomePageHandlerMapping(resourceProperties.getWelcomePage(),</span><br><span class="line">				<span class="keyword">this</span>.mvcProperties.getStaticPathPattern());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//配置喜欢的图标</span></span><br><span class="line">	<span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"spring.mvc.favicon.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FaviconConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> ResourceProperties resourceProperties;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">FaviconConfiguration</span><span class="params">(ResourceProperties resourceProperties)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.resourceProperties = resourceProperties;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> SimpleUrlHandlerMapping <span class="title">faviconHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			SimpleUrlHandlerMapping mapping = <span class="keyword">new</span> SimpleUrlHandlerMapping();</span><br><span class="line">			mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + <span class="number">1</span>);</span><br><span class="line">             	<span class="comment">//所有  **/favicon.ico </span></span><br><span class="line">			mapping.setUrlMap(Collections.singletonMap(<span class="string">"**/favicon.ico"</span>,</span><br><span class="line">					faviconRequestHandler()));</span><br><span class="line">			<span class="keyword">return</span> mapping;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> ResourceHttpRequestHandler <span class="title">faviconRequestHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			ResourceHttpRequestHandler requestHandler = <span class="keyword">new</span> ResourceHttpRequestHandler();</span><br><span class="line">			requestHandler</span><br><span class="line">					.setLocations(<span class="keyword">this</span>.resourceProperties.getFaviconLocations());</span><br><span class="line">			<span class="keyword">return</span> requestHandler;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><mark>1）、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；</mark></p>
<p>​	webjars：以jar包的方式引入静态资源；</p>
<p><a href="http://www.webjars.org/" target="_blank" rel="noopener">http://www.webjars.org/</a></p>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180203181751.png" alt="" /></p>
<p>localhost:8080/webjars/jquery/3.3.1/jquery.js</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入jquery-webjar--&gt;</span>在访问的时候只需要写webjars下面资源的名称即可</span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><mark>2）、&quot;/**&quot; 访问当前项目的任何资源，都去（静态资源的文件夹）找映射</mark></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;, </span><br><span class="line">&quot;classpath:&#x2F;resources&#x2F;&quot;,</span><br><span class="line">&quot;classpath:&#x2F;static&#x2F;&quot;, </span><br><span class="line">&quot;classpath:&#x2F;public&#x2F;&quot; </span><br><span class="line">&quot;&#x2F;&quot;：当前项目的根路径</span><br></pre></td></tr></table></figure>
<p>localhost:8080/abc ===  去静态资源文件夹里面找abc</p>
<p><mark>3）、欢迎页； 静态资源文件夹下的所有index.html页面；被&quot;/**&quot;映射；</mark></p>
<p>​	localhost:8080/   找index页面</p>
<p><mark>4）、所有的 **/favicon.ico  都是在静态资源文件下找；</mark></p>
<h2 id="3-模板引擎"><a class="markdownIt-Anchor" href="#3-模板引擎"></a> 3、模板引擎</h2>
<p>JSP、Velocity、Freemarker、Thymeleaf</p>
<p><img src="images/template-engine.png" alt="" /></p>
<p>SpringBoot推荐的Thymeleaf；</p>
<p>语法更简单，功能更强大；</p>
<h3 id="1-引入thymeleaf"><a class="markdownIt-Anchor" href="#1-引入thymeleaf"></a> 1、引入thymeleaf；</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          	2.1.6</span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">切换thymeleaf版本</span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">thymeleaf.version</span>&gt;</span>3.0.9.RELEASE<span class="tag">&lt;/<span class="name">thymeleaf.version</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 布局功能的支持程序  thymeleaf3主程序  layout2以上版本 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- thymeleaf2   layout1--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">thymeleaf-layout-dialect.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-thymeleaf使用"><a class="markdownIt-Anchor" href="#2-thymeleaf使用"></a> 2、Thymeleaf使用</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.thymeleaf"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_ENCODING = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(<span class="string">"text/html"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PREFIX = <span class="string">"classpath:/templates/"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SUFFIX = <span class="string">".html"</span>;</span><br><span class="line">  	<span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染；</p>
<p>使用：</p>
<p>1、导入thymeleaf的名称空间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2、使用thymeleaf语法；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>成功！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--th:text 将div里面的文本内容设置为 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">th:text</span>=<span class="string">"$&#123;hello&#125;"</span>&gt;</span>这是显示欢迎信息<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-语法规则"><a class="markdownIt-Anchor" href="#3-语法规则"></a> 3、语法规则</h3>
<p>1）、th:text；改变当前元素里面的文本内容；</p>
<p>​	th：任意html属性；来替换原生属性的值</p>
<p><img src="images/2018-02-04_123955.png" alt="" /></p>
<p>2）、表达式？</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">Simple</span> <span class="string">expressions:（表达式语法）</span></span><br><span class="line">    <span class="attr">Variable</span> <span class="string">Expressions: $&#123;...&#125;：获取变量值；OGNL；</span></span><br><span class="line">    		<span class="attr">1）、获取对象的属性、调用方法</span></span><br><span class="line">    		<span class="attr">2）、使用内置的基本对象：</span></span><br><span class="line"><span class="comment">    			#ctx : the context object.</span></span><br><span class="line"><span class="comment">    			#vars: the context variables.</span></span><br><span class="line"><span class="comment">                #locale : the context locale.</span></span><br><span class="line"><span class="comment">                #request : (only in Web Contexts) the HttpServletRequest object.</span></span><br><span class="line"><span class="comment">                #response : (only in Web Contexts) the HttpServletResponse object.</span></span><br><span class="line"><span class="comment">                #session : (only in Web Contexts) the HttpSession object.</span></span><br><span class="line"><span class="comment">                #servletContext : (only in Web Contexts) the ServletContext object.</span></span><br><span class="line">                </span><br><span class="line">                <span class="attr">$&#123;session.foo&#125;</span></span><br><span class="line">            <span class="attr">3）、内置的一些工具对象：</span></span><br><span class="line"><span class="comment">#execInfo : information about the template being processed.</span></span><br><span class="line"><span class="comment">#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.</span></span><br><span class="line"><span class="comment">#uris : methods for escaping parts of URLs/URIs</span></span><br><span class="line"><span class="comment">#conversions : methods for executing the configured conversion service (if any).</span></span><br><span class="line"><span class="comment">#dates : methods for java.util.Date objects: formatting, component extraction, etc.</span></span><br><span class="line"><span class="comment">#calendars : analogous to #dates , but for java.util.Calendar objects.</span></span><br><span class="line"><span class="comment">#numbers : methods for formatting numeric objects.</span></span><br><span class="line"><span class="comment">#strings : methods for String objects: contains, startsWith, prepending/appending, etc.</span></span><br><span class="line"><span class="comment">#objects : methods for objects in general.</span></span><br><span class="line"><span class="comment">#bools : methods for boolean evaluation.</span></span><br><span class="line"><span class="comment">#arrays : methods for arrays.</span></span><br><span class="line"><span class="comment">#lists : methods for lists.</span></span><br><span class="line"><span class="comment">#sets : methods for sets.</span></span><br><span class="line"><span class="comment">#maps : methods for maps.</span></span><br><span class="line"><span class="comment">#aggregates : methods for creating aggregates on arrays or collections.</span></span><br><span class="line"><span class="comment">#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">Selection</span> <span class="string">Variable Expressions: *&#123;...&#125;：选择表达式：和$&#123;&#125;在功能上是一样；</span></span><br><span class="line">    	<span class="meta">补充：配合</span> <span class="string">th:object="$&#123;session.user&#125;：</span></span><br><span class="line">   <span class="meta">&lt;div</span> <span class="string">th:object="$&#123;session.user&#125;"&gt;</span></span><br><span class="line">    <span class="meta">&lt;p&gt;Name</span>: <span class="string">&lt;span th:text="*&#123;firstName&#125;"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;</span></span><br><span class="line">    <span class="meta">&lt;p&gt;Surname</span>: <span class="string">&lt;span th:text="*&#123;lastName&#125;"&gt;Pepper&lt;/span&gt;.&lt;/p&gt;</span></span><br><span class="line">    <span class="meta">&lt;p&gt;Nationality</span>: <span class="string">&lt;span th:text="*&#123;nationality&#125;"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;</span></span><br><span class="line">    <span class="attr">&lt;/div&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">Message</span> <span class="string">Expressions: #&#123;...&#125;：获取国际化内容</span></span><br><span class="line">    <span class="attr">Link</span> <span class="string">URL Expressions: @&#123;...&#125;：定义URL；</span></span><br><span class="line">    		<span class="meta">@&#123;/order/process(execId</span>=<span class="string">$&#123;execId&#125;,execType='FAST')&#125;</span></span><br><span class="line">    <span class="attr">Fragment</span> <span class="string">Expressions: ~&#123;...&#125;：片段引用表达式</span></span><br><span class="line">    		<span class="meta">&lt;div</span> <span class="string">th:insert="~&#123;commons :: main&#125;"&gt;...&lt;/div&gt;</span></span><br><span class="line">    		</span><br><span class="line"><span class="attr">Literals（字面量）</span></span><br><span class="line">      <span class="attr">Text</span> <span class="string">literals: 'one text' , 'Another one!' ,…</span></span><br><span class="line">      <span class="attr">Number</span> <span class="string">literals: 0 , 34 , 3.0 , 12.3 ,…</span></span><br><span class="line">      <span class="attr">Boolean</span> <span class="string">literals: true , false</span></span><br><span class="line">      <span class="attr">Null</span> <span class="string">literal: null</span></span><br><span class="line">      <span class="attr">Literal</span> <span class="string">tokens: one , sometext , main ,…</span></span><br><span class="line"><span class="attr">Text</span> <span class="string">operations:（文本操作）</span></span><br><span class="line">    <span class="attr">String</span> <span class="string">concatenation: +</span></span><br><span class="line">    <span class="attr">Literal</span> <span class="string">substitutions: |The name is $&#123;name&#125;|</span></span><br><span class="line"><span class="attr">Arithmetic</span> <span class="string">operations:（数学运算）</span></span><br><span class="line">    <span class="attr">Binary</span> <span class="string">operators: + , - , * , / , %</span></span><br><span class="line">    <span class="attr">Minus</span> <span class="string">sign (unary operator): -</span></span><br><span class="line"><span class="attr">Boolean</span> <span class="string">operations:（布尔运算）</span></span><br><span class="line">    <span class="attr">Binary</span> <span class="string">operators: and , or</span></span><br><span class="line">    <span class="attr">Boolean</span> <span class="string">negation (unary operator): ! , not</span></span><br><span class="line"><span class="attr">Comparisons</span> <span class="string">and equality:（比较运算）</span></span><br><span class="line">    <span class="attr">Comparators</span>: <span class="string">&gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le )</span></span><br><span class="line">    <span class="attr">Equality</span> <span class="string">operators: == , != ( eq , ne )</span></span><br><span class="line"><span class="attr">Conditional</span> <span class="string">operators:条件运算（三元运算符）</span></span><br><span class="line">    <span class="meta">If-then</span>: <span class="string">(if) ? (then)</span></span><br><span class="line">    <span class="meta">If-then-else</span>: <span class="string">(if) ? (then) : (else)</span></span><br><span class="line">    <span class="attr">Default</span>: <span class="string">(value) ?: (defaultvalue)</span></span><br><span class="line"><span class="attr">Special</span> <span class="string">tokens:</span></span><br><span class="line">    <span class="meta">No-Operation</span>: <span class="string">_</span></span><br></pre></td></tr></table></figure>
<h2 id="4-springmvc自动配置"><a class="markdownIt-Anchor" href="#4-springmvc自动配置"></a> 4、SpringMVC自动配置</h2>
<p><a href="https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-developing-web-applications</a></p>
<h3 id="1-spring-mvc-auto-configuration"><a class="markdownIt-Anchor" href="#1-spring-mvc-auto-configuration"></a> 1. Spring MVC auto-configuration</h3>
<p>Spring Boot 自动配置好了SpringMVC</p>
<p>以下是SpringBoot对SpringMVC的默认配置:<strong><mark>（WebMvcAutoConfiguration）</mark></strong></p>
<ul>
<li>
<p>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</p>
<ul>
<li>自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？））</li>
<li>ContentNegotiatingViewResolver：组合所有的视图解析器的；</li>
<li><mark>如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；</mark></li>
</ul>
</li>
<li>
<p>Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars</p>
</li>
<li>
<p>Static <code>index.html</code> support. 静态首页访问</p>
</li>
<li>
<p>Custom <code>Favicon</code> support (see below).  favicon.ico</p>
</li>
<li>
<p>自动注册了 of <code>Converter</code>, <code>GenericConverter</code>, <code>Formatter</code> beans.</p>
<ul>
<li>Converter：转换器；  public String hello(User user)：类型转换使用Converter</li>
<li><code>Formatter</code>  格式化器；  2017.12.17===Date；</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.mvc"</span>, name = <span class="string">"date-format"</span>)<span class="comment">//在文件中配置日期格式化的规则</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Formatter&lt;Date&gt; <span class="title">dateFormatter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> DateFormatter(<span class="keyword">this</span>.mvcProperties.getDateFormat());<span class="comment">//日期格式化组件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	<mark>自己添加的格式化器转换器，我们只需要放在容器中即可</mark></p>
<ul>
<li>
<p>Support for <code>HttpMessageConverters</code> (see below).</p>
<ul>
<li>
<p>HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json；</p>
</li>
<li>
<p><code>HttpMessageConverters</code> 是从容器中确定；获取所有的HttpMessageConverter；</p>
<p><mark>自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）</mark></p>
</li>
</ul>
</li>
<li>
<p>Automatic registration of <code>MessageCodesResolver</code> (see below).定义错误代码生成规则</p>
</li>
<li>
<p>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (see below).</p>
<p><mark>我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）</mark></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始化WebDataBinder；</span><br><span class="line">请求数据&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;JavaBean；</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><a href="http://org.springframework.boot.autoconfigure.web" target="_blank" rel="noopener">org.springframework.boot.autoconfigure.web</a>：web的所有自动场景；</strong></p>
<p>If you want to keep Spring Boot MVC features, and you just want to add additional <a href="https://docs.spring.io/spring/docs/4.3.14.RELEASE/spring-framework-reference/htmlsingle#mvc" target="_blank" rel="noopener">MVC configuration</a> (interceptors, formatters, view controllers etc.) you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurerAdapter</code>, but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code> or <code>ExceptionHandlerExceptionResolver</code> you can declare a <code>WebMvcRegistrationsAdapter</code> instance providing such components.</p>
<p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</p>
<h3 id="2-扩展springmvc"><a class="markdownIt-Anchor" href="#2-扩展springmvc"></a> 2、扩展SpringMVC</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">"/hello"</span> <span class="attr">view-name</span>=<span class="string">"success"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/hello"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong><mark>编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc</mark></strong>;</p>
<p>既保留了所有的自动配置，也能用我们扩展的配置；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// super.addViewControllers(registry);</span></span><br><span class="line">        <span class="comment">//浏览器发送 /atguigu 请求来到 success</span></span><br><span class="line">        registry.addViewController(<span class="string">"/atguigu"</span>).setViewName(<span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理：</p>
<p>​	1）、WebMvcAutoConfiguration是SpringMVC的自动配置类</p>
<p>​	2）、在做其他自动配置时会导入；@Import(<strong>EnableWebMvcConfiguration</strong>.class)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EnableWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">DelegatingWebMvcConfiguration</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> WebMvcConfigurerComposite configurers = <span class="keyword">new</span> WebMvcConfigurerComposite();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//从容器中获取所有的WebMvcConfigurer</span></span><br><span class="line">     <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigurers</span><span class="params">(List&lt;WebMvcConfigurer&gt; configurers)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">             <span class="keyword">this</span>.configurers.addWebMvcConfigurers(configurers);</span><br><span class="line">           	<span class="comment">//一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；  </span></span><br><span class="line">           	<span class="meta">@Override</span></span><br><span class="line">            <span class="comment">// public void addViewControllers(ViewControllerRegistry registry) &#123;</span></span><br><span class="line">             <span class="comment">//    for (WebMvcConfigurer delegate : this.delegates) &#123;</span></span><br><span class="line">              <span class="comment">//       delegate.addViewControllers(registry);</span></span><br><span class="line">              <span class="comment">//   &#125;</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	3）、容器中所有的WebMvcConfigurer都会一起起作用；</p>
<p>​	4）、我们的配置类也会被调用；</p>
<p>​	效果：SpringMVC的自动配置和我们的扩展配置都会起作用；</p>
<h3 id="3-全面接管springmvc"><a class="markdownIt-Anchor" href="#3-全面接管springmvc"></a> 3、全面接管SpringMVC；</h3>
<p>SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了</p>
<p><strong>我们需要在配置类中添加@EnableWebMvc即可；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// super.addViewControllers(registry);</span></span><br><span class="line">        <span class="comment">//浏览器发送 /atguigu 请求来到 success</span></span><br><span class="line">        registry.addViewController(<span class="string">"/atguigu"</span>).setViewName(<span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理：</p>
<p>为什么@EnableWebMvc自动配置就失效了；</p>
<p>1）@EnableWebMvc的核心</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import</span>(DelegatingWebMvcConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableWebMvc</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>2）、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>3）、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet<span class="class">.<span class="keyword">class</span>, <span class="title">DispatcherServlet</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">		<span class="title">WebMvcConfigurerAdapter</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">//容器中没有这个组件的时候，这个自动配置类才生效</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">WebMvcConfigurationSupport</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureOrder</span>(<span class="title">Ordered</span>.<span class="title">HIGHEST_PRECEDENCE</span> + 10)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(</span>&#123; DispatcherServletAutoConfiguration<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">		<span class="title">ValidationAutoConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；</p>
<p>5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；</p>
<h2 id="5-如何修改springboot的默认配置"><a class="markdownIt-Anchor" href="#5-如何修改springboot的默认配置"></a> 5、如何修改SpringBoot的默认配置</h2>
<p>模式：</p>
<p>​	1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；</p>
<p>​	2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置</p>
<p>​	3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置</p>
<h2 id="6-restfulcrud"><a class="markdownIt-Anchor" href="#6-restfulcrud"></a> 6、RestfulCRUD</h2>
<h3 id="1-默认访问首页"><a class="markdownIt-Anchor" href="#1-默认访问首页"></a> 1）、默认访问首页</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span></span><br><span class="line"><span class="comment">//@EnableWebMvc   不要接管SpringMVC</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// super.addViewControllers(registry);</span></span><br><span class="line">        <span class="comment">//浏览器发送 /atguigu 请求来到 success</span></span><br><span class="line">        registry.addViewController(<span class="string">"/atguigu"</span>).setViewName(<span class="string">"success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有的WebMvcConfigurerAdapter组件都会一起起作用</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//将组件注册在容器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcConfigurerAdapter <span class="title">webMvcConfigurerAdapter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        WebMvcConfigurerAdapter adapter = <span class="keyword">new</span> WebMvcConfigurerAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">                registry.addViewController(<span class="string">"/"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">                registry.addViewController(<span class="string">"/index.html"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> adapter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-国际化"><a class="markdownIt-Anchor" href="#2-国际化"></a> 2）、国际化</h3>
<p><strong>1）、编写国际化配置文件；</strong></p>
<p>2）、使用ResourceBundleMessageSource管理国际化资源文件</p>
<p>3）、在页面使用fmt:message取出国际化内容</p>
<p>步骤：</p>
<p>1）、编写国际化配置文件，抽取页面需要显示的国际化消息</p>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180211130721.png" alt="" /></p>
<p>2）、SpringBoot自动配置好了管理国际化资源文件的组件；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.messages"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSourceAutoConfiguration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Comma-separated list of basenames (essentially a fully-qualified classpath</span></span><br><span class="line"><span class="comment">	 * location), each following the ResourceBundle convention with relaxed support for</span></span><br><span class="line"><span class="comment">	 * slash based locations. If it doesn't contain a package qualifier (such as</span></span><br><span class="line"><span class="comment">	 * "org.mypackage"), it will be resolved from the classpath root.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> String basename = <span class="string">"messages"</span>;  </span><br><span class="line">    <span class="comment">//我们的配置文件可以直接放在类路径下叫messages.properties；</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MessageSource <span class="title">messageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ResourceBundleMessageSource messageSource = <span class="keyword">new</span> ResourceBundleMessageSource();</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.basename)) &#123;</span><br><span class="line">            <span class="comment">//设置国际化资源文件的基础名（去掉语言国家代码的）</span></span><br><span class="line">			messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(</span><br><span class="line">					StringUtils.trimAllWhitespace(<span class="keyword">this</span>.basename)));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.encoding != <span class="keyword">null</span>) &#123;</span><br><span class="line">			messageSource.setDefaultEncoding(<span class="keyword">this</span>.encoding.name());</span><br><span class="line">		&#125;</span><br><span class="line">		messageSource.setFallbackToSystemLocale(<span class="keyword">this</span>.fallbackToSystemLocale);</span><br><span class="line">		messageSource.setCacheSeconds(<span class="keyword">this</span>.cacheSeconds);</span><br><span class="line">		messageSource.setAlwaysUseMessageFormat(<span class="keyword">this</span>.alwaysUseMessageFormat);</span><br><span class="line">		<span class="keyword">return</span> messageSource;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>3）、去页面获取国际化的值；</p>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180211134506.png" alt="" /></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>  <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, shrink-to-fit=no"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>Signin Template for Bootstrap<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- Bootstrap core CSS --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"asserts/css/bootstrap.min.css"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- Custom styles for this template --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"asserts/css/signin.css"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/asserts/css/signin.css&#125;"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">"text-center"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"form-signin"</span> <span class="attr">action</span>=<span class="string">"dashboard.html"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"mb-4"</span> <span class="attr">th:src</span>=<span class="string">"@&#123;/asserts/img/bootstrap-solid.svg&#125;"</span> <span class="attr">src</span>=<span class="string">"asserts/img/bootstrap-solid.svg"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">width</span>=<span class="string">"72"</span> <span class="attr">height</span>=<span class="string">"72"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"h3 mb-3 font-weight-normal"</span> <span class="attr">th:text</span>=<span class="string">"#&#123;login.tip&#125;"</span>&gt;</span>Please sign in<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"sr-only"</span> <span class="attr">th:text</span>=<span class="string">"#&#123;login.username&#125;"</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"Username"</span> <span class="attr">th:placeholder</span>=<span class="string">"#&#123;login.username&#125;"</span> <span class="attr">required</span>=<span class="string">""</span> <span class="attr">autofocus</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"sr-only"</span> <span class="attr">th:text</span>=<span class="string">"#&#123;login.password&#125;"</span>&gt;</span>Password<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"Password"</span> <span class="attr">th:placeholder</span>=<span class="string">"#&#123;login.password&#125;"</span> <span class="attr">required</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"checkbox mb-3"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">          		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"remember-me"</span>/&gt;</span> [[#&#123;login.remember&#125;]]</span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-lg btn-primary btn-block"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">th:text</span>=<span class="string">"#&#123;login.btn&#125;"</span>&gt;</span>Sign in<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"mt-5 mb-3 text-muted"</span>&gt;</span>© 2017-2018<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-sm"</span>&gt;</span>中文<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-sm"</span>&gt;</span>English<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果：根据浏览器语言设置的信息切换了国际化；</p>
<p>原理：</p>
<p>​	国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">		<span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.mvc"</span>, name = <span class="string">"locale"</span>)</span><br><span class="line">		<span class="function"><span class="keyword">public</span> LocaleResolver <span class="title">localeResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.mvcProperties</span><br><span class="line">					.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> FixedLocaleResolver(<span class="keyword">this</span>.mvcProperties.getLocale());</span><br><span class="line">			&#125;</span><br><span class="line">			AcceptHeaderLocaleResolver localeResolver = <span class="keyword">new</span> AcceptHeaderLocaleResolver();</span><br><span class="line">			localeResolver.setDefaultLocale(<span class="keyword">this</span>.mvcProperties.getLocale());</span><br><span class="line">			<span class="keyword">return</span> localeResolver;</span><br><span class="line">		&#125;</span><br><span class="line">默认的就是根据请求头带来的区域信息获取Locale进行国际化</span><br></pre></td></tr></table></figure>
<p>4）、点击链接切换国际化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以在连接上携带区域信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLocaleResolver</span> <span class="keyword">implements</span> <span class="title">LocaleResolver</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Locale <span class="title">resolveLocale</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String l = request.getParameter(<span class="string">"l"</span>);</span><br><span class="line">        Locale locale = Locale.getDefault();</span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(l))&#123;</span><br><span class="line">            String[] split = l.split(<span class="string">"_"</span>);</span><br><span class="line">            locale = <span class="keyword">new</span> Locale(split[<span class="number">0</span>],split[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> locale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocale</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Locale locale)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocaleResolver <span class="title">localeResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyLocaleResolver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-登陆"><a class="markdownIt-Anchor" href="#3-登陆"></a> 3）、登陆</h3>
<p>开发期间模板引擎页面修改以后，要实时生效</p>
<p>1）、禁用模板引擎的缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 禁用缓存</span><br><span class="line">spring.thymeleaf.cache&#x3D;false</span><br></pre></td></tr></table></figure>
<p>2）、页面修改完成以后ctrl+f9：重新编译；</p>
<p>登陆错误消息的显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color: red"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;msg&#125;"</span> <span class="attr">th:if</span>=<span class="string">"$&#123;not #strings.isEmpty(msg)&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-拦截器进行登陆检查"><a class="markdownIt-Anchor" href="#4-拦截器进行登陆检查"></a> 4）、拦截器进行登陆检查</h3>
<p>拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登陆检查，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//目标方法执行之前</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object user = request.getSession().getAttribute(<span class="string">"loginUser"</span>);</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//未登陆，返回登陆页面</span></span><br><span class="line">            request.setAttribute(<span class="string">"msg"</span>,<span class="string">"没有权限请先登陆"</span>);</span><br><span class="line">            request.getRequestDispatcher(<span class="string">"/index.html"</span>).forward(request,response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//已登陆，放行请求</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//所有的WebMvcConfigurerAdapter组件都会一起起作用</span></span><br><span class="line">  <span class="meta">@Bean</span> <span class="comment">//将组件注册在容器</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> WebMvcConfigurerAdapter <span class="title">webMvcConfigurerAdapter</span><span class="params">()</span></span>&#123;</span><br><span class="line">      WebMvcConfigurerAdapter adapter = <span class="keyword">new</span> WebMvcConfigurerAdapter() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">              registry.addViewController(<span class="string">"/"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">              registry.addViewController(<span class="string">"/index.html"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">              registry.addViewController(<span class="string">"/main.html"</span>).setViewName(<span class="string">"dashboard"</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//注册拦截器</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">              <span class="comment">//super.addInterceptors(registry);</span></span><br><span class="line">              <span class="comment">//静态资源；  *.css , *.js</span></span><br><span class="line">              <span class="comment">//SpringBoot已经做好了静态资源映射</span></span><br><span class="line">              registry.addInterceptor(<span class="keyword">new</span> LoginHandlerInterceptor()).addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">                      .excludePathPatterns(<span class="string">"/index.html"</span>,<span class="string">"/"</span>,<span class="string">"/user/login"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">return</span> adapter;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-crud-员工列表"><a class="markdownIt-Anchor" href="#5-crud-员工列表"></a> 5）、CRUD-员工列表</h3>
<p>实验要求：</p>
<p>1）、RestfulCRUD：CRUD满足Rest风格；</p>
<p>URI：  /资源名称/资源标识       HTTP请求方式区分对资源CRUD操作</p>
<table>
<thead>
<tr>
<th></th>
<th>普通CRUD（uri来区分操作）</th>
<th>RestfulCRUD</th>
</tr>
</thead>
<tbody>
<tr>
<td>查询</td>
<td>getEmp</td>
<td>emp—GET</td>
</tr>
<tr>
<td>添加</td>
<td>addEmp?xxx</td>
<td>emp—POST</td>
</tr>
<tr>
<td>修改</td>
<td>updateEmp?id=xxx&amp;xxx=xx</td>
<td>emp/{id}—PUT</td>
</tr>
<tr>
<td>删除</td>
<td>deleteEmp?id=1</td>
<td>emp/{id}—DELETE</td>
</tr>
</tbody>
</table>
<p>2）、实验的请求架构;</p>
<table>
<thead>
<tr>
<th>实验功能</th>
<th>请求URI</th>
<th>请求方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>查询所有员工</td>
<td>emps</td>
<td>GET</td>
</tr>
<tr>
<td>查询某个员工(来到修改页面)</td>
<td>emp/1</td>
<td>GET</td>
</tr>
<tr>
<td>来到添加页面</td>
<td>emp</td>
<td>GET</td>
</tr>
<tr>
<td>添加员工</td>
<td>emp</td>
<td>POST</td>
</tr>
<tr>
<td>来到修改页面（查出员工进行信息回显）</td>
<td>emp/1</td>
<td>GET</td>
</tr>
<tr>
<td>修改员工</td>
<td>emp</td>
<td>PUT</td>
</tr>
<tr>
<td>删除员工</td>
<td>emp/1</td>
<td>DELETE</td>
</tr>
</tbody>
</table>
<p>3）、员工列表：</p>
<h4 id="thymeleaf公共页面元素抽取"><a class="markdownIt-Anchor" href="#thymeleaf公共页面元素抽取"></a> thymeleaf公共页面元素抽取</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1、抽取公共片段</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:fragment</span>=<span class="string">"copy"</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">2、引入公共片段</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">"~&#123;footer :: copy&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">~&#123;templatename::selector&#125;：模板名::选择器</span><br><span class="line">~&#123;templatename::fragmentname&#125;:模板名::片段名</span><br><span class="line"></span><br><span class="line">3、默认效果：</span><br><span class="line">insert的公共片段在div标签中</span><br><span class="line">如果使用th:insert等属性进行引入，可以不用写~&#123;&#125;：</span><br><span class="line">行内写法可以加上：[[~&#123;&#125;]];[(~&#123;&#125;)]；</span><br></pre></td></tr></table></figure>
<p>三种引入公共片段的th属性：</p>
<p><strong>th:insert</strong>：将公共片段整个插入到声明引入的元素中</p>
<p><strong>th:replace</strong>：将声明引入的元素替换为公共片段</p>
<p><strong>th:include</strong>：将被引入的片段的内容包含进这个标签中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">th:fragment</span>=<span class="string">"copy"</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line">引入方式</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">"footer :: copy"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">"footer :: copy"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:include</span>=<span class="string">"footer :: copy"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">效果</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery</span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="symbol">&amp;copy;</span> 2011 The Good Thymes Virtual Grocery</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>引入片段的时候传入参数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"col-md-2 d-none d-md-block bg-light sidebar"</span> <span class="attr">id</span>=<span class="string">"sidebar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"sidebar-sticky"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav flex-column"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"nav-item"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"nav-link active"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">th:class</span>=<span class="string">"$&#123;activeUri=='main.html'?'nav-link active':'nav-link'&#125;"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/main.html&#125;"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">width</span>=<span class="string">"24"</span> <span class="attr">height</span>=<span class="string">"24"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 24 24"</span> <span class="attr">fill</span>=<span class="string">"none"</span> <span class="attr">stroke</span>=<span class="string">"currentColor"</span> <span class="attr">stroke-width</span>=<span class="string">"2"</span> <span class="attr">stroke-linecap</span>=<span class="string">"round"</span> <span class="attr">stroke-linejoin</span>=<span class="string">"round"</span> <span class="attr">class</span>=<span class="string">"feather feather-home"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">"9 22 9 12 15 12 15 22"</span>&gt;</span><span class="tag">&lt;/<span class="name">polyline</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">                    Dashboard <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"sr-only"</span>&gt;</span>(current)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入侧边栏;传入参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:replace</span>=<span class="string">"commons/bar::#sidebar(activeUri='emps')"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-crud-员工添加"><a class="markdownIt-Anchor" href="#6-crud-员工添加"></a> 6）、CRUD-员工添加</h3>
<p>添加页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>LastName<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan@atguigu.com"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Gender<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-check form-check-inline"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-check-input"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span>  <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"form-check-label"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-check form-check-inline"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-check-input"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span>  <span class="attr">value</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"form-check-label"</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>department<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">"form-control"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>4<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>5<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Birth<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>提交的数据格式不对：生日：日期；</p>
<p>2017-12-12；2017/12/12；2017.12.12；</p>
<p>日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型;</p>
<p>2017-12-12—Date； 类型转换，格式化;</p>
<p>默认日期是按照/的方式；</p>
<h3 id="7-crud-员工修改"><a class="markdownIt-Anchor" href="#7-crud-员工修改"></a> 7）、CRUD-员工修改</h3>
<p>修改添加二合一表单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--需要区分是员工修改还是添加；--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">"@&#123;/emp&#125;"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--发送put请求修改员工数据--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">1、SpringMVC中配置HiddenHttpMethodFilter;（SpringBoot自动配置好的）</span></span><br><span class="line"><span class="comment">2、页面创建一个post表单</span></span><br><span class="line"><span class="comment">3、创建一个input项，name="_method";值就是我们指定的请求方式</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"_method"</span> <span class="attr">value</span>=<span class="string">"put"</span> <span class="attr">th:if</span>=<span class="string">"$&#123;emp!=null&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">th:if</span>=<span class="string">"$&#123;emp!=null&#125;"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;emp.id&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>LastName<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"lastName"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan@atguigu.com"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;emp.email&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Gender<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-check form-check-inline"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-check-input"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">th:checked</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"form-check-label"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-check form-check-inline"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"form-check-input"</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"0"</span> <span class="attr">th:checked</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"form-check-label"</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>department<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--提交的是部门的id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">name</span>=<span class="string">"department.id"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">th:selected</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;dept.id&#125;"</span> <span class="attr">th:each</span>=<span class="string">"dept:$&#123;depts&#125;"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;dept.departmentName&#125;"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span>Birth<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"birth"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"zhangsan"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">class</span>=<span class="string">"btn btn-primary"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp!=null&#125;?'修改':'添加'"</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="8-crud-员工删除"><a class="markdownIt-Anchor" href="#8-crud-员工删除"></a> 8）、CRUD-员工删除</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"emp:$&#123;emps&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp.id&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>[[$&#123;emp.lastName&#125;]]<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp.email&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp.gender&#125;==0?'女':'男'"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;emp.department.departmentName&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-sm btn-primary"</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/emp/&#125;+$&#123;emp.id&#125;"</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">th:attr</span>=<span class="string">"del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;"</span> <span class="attr">class</span>=<span class="string">"btn btn-sm btn-danger deleteBtn"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">".deleteBtn"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//删除当前员工的</span></span></span><br><span class="line"><span class="javascript">        $(<span class="string">"#deleteEmpForm"</span>).attr(<span class="string">"action"</span>,$(<span class="keyword">this</span>).attr(<span class="string">"del_uri"</span>)).submit();</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="7-错误处理机制"><a class="markdownIt-Anchor" href="#7-错误处理机制"></a> 7、错误处理机制</h2>
<h3 id="1-springboot默认的错误处理机制"><a class="markdownIt-Anchor" href="#1-springboot默认的错误处理机制"></a> 1）、SpringBoot默认的错误处理机制</h3>
<p>默认效果：</p>
<p>​		1）、浏览器，返回一个默认的错误页面</p>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180226173408.png" alt="" /></p>
<p>浏览器发送请求的请求头：</p>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180226180347.png" alt="" /></p>
<p>​		2）、如果是其他客户端，默认响应一个json数据</p>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180226173527.png" alt="" /></p>
<p>​		<img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180226180504.png" alt="" /></p>
<p>原理：</p>
<p>​	可以参照ErrorMvcAutoConfiguration；错误处理的自动配置；</p>
<pre><code>给容器中添加了以下组件
</code></pre>
<p>​	1、DefaultErrorAttributes：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">帮我们在页面共享信息；</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(RequestAttributes requestAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">boolean</span> includeStackTrace)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; errorAttributes = <span class="keyword">new</span> LinkedHashMap&lt;String, Object&gt;();</span><br><span class="line">		errorAttributes.put(<span class="string">"timestamp"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">		addStatus(errorAttributes, requestAttributes);</span><br><span class="line">		addErrorDetails(errorAttributes, requestAttributes, includeStackTrace);</span><br><span class="line">		addPath(errorAttributes, requestAttributes);</span><br><span class="line">		<span class="keyword">return</span> errorAttributes;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​	2、BasicErrorController：处理默认/error请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicErrorController</span> <span class="keyword">extends</span> <span class="title">AbstractErrorController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(produces = <span class="string">"text/html"</span>)<span class="comment">//产生html类型的数据；浏览器发送的请求来到这个方法处理</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">errorHtml</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">			HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">		HttpStatus status = getStatus(request);</span><br><span class="line">		Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes(</span><br><span class="line">				request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));</span><br><span class="line">		response.setStatus(status.value());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//去哪个页面作为错误页面；包含页面地址和页面内容</span></span><br><span class="line">		ModelAndView modelAndView = resolveErrorView(request, response, status, model);</span><br><span class="line">		<span class="keyword">return</span> (modelAndView == <span class="keyword">null</span> ? <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>, model) : modelAndView);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span></span><br><span class="line">	<span class="meta">@ResponseBody</span>    <span class="comment">//产生json数据，其他客户端来到这个方法处理；</span></span><br><span class="line">	<span class="keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;</span><br><span class="line">		Map&lt;String, Object&gt; body = getErrorAttributes(request,</span><br><span class="line">				isIncludeStackTrace(request, MediaType.ALL));</span><br><span class="line">		HttpStatus status = getStatus(request);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​	3、ErrorPageCustomizer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;error.path:/error&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String path = <span class="string">"/error"</span>;  系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则）</span><br></pre></td></tr></table></figure>
<p>​	4、DefaultErrorViewResolver：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveErrorView</span><span class="params">(HttpServletRequest request, HttpStatus status,</span></span></span><br><span class="line"><span class="function"><span class="params">			Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">		ModelAndView modelAndView = resolve(String.valueOf(status), model);</span><br><span class="line">		<span class="keyword">if</span> (modelAndView == <span class="keyword">null</span> &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123;</span><br><span class="line">			modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> modelAndView;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> ModelAndView <span class="title">resolve</span><span class="params">(String viewName, Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//默认SpringBoot可以去找到一个页面？  error/404</span></span><br><span class="line">		String errorViewName = <span class="string">"error/"</span> + viewName;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//模板引擎可以解析这个页面地址就用模板引擎解析</span></span><br><span class="line">		TemplateAvailabilityProvider provider = <span class="keyword">this</span>.templateAvailabilityProviders</span><br><span class="line">				.getProvider(errorViewName, <span class="keyword">this</span>.applicationContext);</span><br><span class="line">		<span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//模板引擎可用的情况下返回到errorViewName指定的视图地址</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(errorViewName, model);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面   error/404.html</span></span><br><span class="line">		<span class="keyword">return</span> resolveResource(errorViewName, model);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>​	步骤：</p>
<p>​		一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被<strong>BasicErrorController</strong>处理；</p>
<p>​		1）响应页面；去哪个页面是由<strong>DefaultErrorViewResolver</strong>解析得到的；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">resolveErrorView</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">      HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有的ErrorViewResolver得到ModelAndView</span></span><br><span class="line">   <span class="keyword">for</span> (ErrorViewResolver resolver : <span class="keyword">this</span>.errorViewResolvers) &#123;</span><br><span class="line">      ModelAndView modelAndView = resolver.resolveErrorView(request, status, model);</span><br><span class="line">      <span class="keyword">if</span> (modelAndView != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> modelAndView;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-如果定制错误响应"><a class="markdownIt-Anchor" href="#2-如果定制错误响应"></a> 2）、如果定制错误响应：</h3>
<h4 id="1-如何定制错误的页面"><a class="markdownIt-Anchor" href="#1-如何定制错误的页面"></a> <strong>1）、如何定制错误的页面；</strong></h4>
<p>​			<strong>1）、有模板引擎的情况下；error/状态码;</strong> 【将错误页面命名为  错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到  对应的页面；</p>
<p>​			我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）；</p>
<p>​			页面能获取的信息；</p>
<p>​				timestamp：时间戳</p>
<p>​				status：状态码</p>
<p>​				error：错误提示</p>
<p>​				exception：异常对象</p>
<p>​				message：异常消息</p>
<p>​				errors：JSR303数据校验的错误都在这里</p>
<p>​			2）、没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找；</p>
<p>​			3）、以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面；</p>
<h4 id="2-如何定制错误的json数据"><a class="markdownIt-Anchor" href="#2-如何定制错误的json数据"></a> 2）、如何定制错误的json数据；</h4>
<p>​		1）、自定义异常处理&amp;返回定制json数据；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(UserNotExistException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Map</span>&lt;<span class="title">String</span>,<span class="title">Object</span>&gt; <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"code"</span>,<span class="string">"user.notexist"</span>);</span><br><span class="line">        map.put(<span class="string">"message"</span>,e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有自适应效果...</span></span><br></pre></td></tr></table></figure>
<p>​		2）、转发到/error进行自适应响应效果处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(UserNotExistException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">   <span class="title">public</span> <span class="title">String</span> <span class="title">handleException</span>(<span class="title">Exception</span> <span class="title">e</span>, <span class="title">HttpServletRequest</span> <span class="title">request</span>)</span>&#123;</span><br><span class="line">       Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="comment">//传入我们自己的错误状态码  4xx 5xx，否则就不会进入定制错误页面的解析流程</span></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Integer statusCode = (Integer) request</span></span><br><span class="line"><span class="comment">        .getAttribute("javax.servlet.error.status_code");</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       request.setAttribute(<span class="string">"javax.servlet.error.status_code"</span>,<span class="number">500</span>);</span><br><span class="line">       map.put(<span class="string">"code"</span>,<span class="string">"user.notexist"</span>);</span><br><span class="line">       map.put(<span class="string">"message"</span>,e.getMessage());</span><br><span class="line">       <span class="comment">//转发到/error</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">"forward:/error"</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-将我们的定制数据携带出去"><a class="markdownIt-Anchor" href="#3-将我们的定制数据携带出去"></a> 3）、将我们的定制数据携带出去；</h4>
<p>出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）；</p>
<p>​	1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中；</p>
<p>​	2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到；</p>
<p>​			容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的；</p>
<p>自定义ErrorAttributes</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给容器中加入我们自己定义的ErrorAttributes</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorAttributes</span> <span class="keyword">extends</span> <span class="title">DefaultErrorAttributes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(RequestAttributes requestAttributes, <span class="keyword">boolean</span> includeStackTrace)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">super</span>.getErrorAttributes(requestAttributes, includeStackTrace);</span><br><span class="line">        map.put(<span class="string">"company"</span>,<span class="string">"atguigu"</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容，</p>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180228135513.png" alt="" /></p>
<h2 id="8-配置嵌入式servlet容器"><a class="markdownIt-Anchor" href="#8-配置嵌入式servlet容器"></a> 8、配置嵌入式Servlet容器</h2>
<p>SpringBoot默认使用Tomcat作为嵌入式的Servlet容器；</p>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180301142915.png" alt="" /></p>
<p>问题？</p>
<h3 id="1-如何定制和修改servlet容器的相关配置"><a class="markdownIt-Anchor" href="#1-如何定制和修改servlet容器的相关配置"></a> 1）、如何定制和修改Servlet容器的相关配置；</h3>
<p>1、修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）；</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="meta">server.context-path</span>=<span class="string">/crud</span></span><br><span class="line"></span><br><span class="line"><span class="meta">server.tomcat.uri-encoding</span>=<span class="string">UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">//通用的Servlet容器设置</span></span><br><span class="line"><span class="attr">server.xxx</span></span><br><span class="line"><span class="attr">//Tomcat的设置</span></span><br><span class="line"><span class="attr">server.tomcat.xxx</span></span><br></pre></td></tr></table></figure>
<p>2、编写一个<strong>EmbeddedServletContainerCustomizer</strong>：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> TomcatServletWebServerFactory <span class="title">tomcatServletWebServerFactory</span> <span class="params">()</span></span>&#123;</span><br><span class="line">     TomcatServletWebServerFactory tomcatServletWebServerFactory = <span class="keyword">new</span> 			TomcatServletWebServerFactory();</span><br><span class="line">     <span class="comment">//设置规则</span></span><br><span class="line">     tomcatServletWebServerFactory.setPort(<span class="number">8083</span>);</span><br><span class="line">     <span class="keyword">return</span> tomcatServletWebServerFactory;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-注册servlet三大组件servlet-filter-listener"><a class="markdownIt-Anchor" href="#2-注册servlet三大组件servlet-filter-listener"></a> 2）、注册Servlet三大组件【Servlet、Filter、Listener】</h3>
<p>由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。</p>
<p>注册三大组件用以下方式</p>
<p>ServletRegistrationBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册三大组件</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">myServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> MyServlet(),<span class="string">"/myServlet"</span>);</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FilterRegistrationBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">myFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">    registrationBean.setFilter(<span class="keyword">new</span> MyFilter());</span><br><span class="line">    registrationBean.setUrlPatterns(Arrays.asList(<span class="string">"/hello"</span>,<span class="string">"/myServlet"</span>));</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServletListenerRegistrationBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletListenerRegistrationBean <span class="title">myListener</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = <span class="keyword">new</span> ServletListenerRegistrationBean&lt;&gt;(<span class="keyword">new</span> MyListener());</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet；</p>
<p>DispatcherServletAutoConfiguration中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)</span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(value = DispatcherServlet<span class="class">.<span class="keyword">class</span>, <span class="title">name</span> </span>= DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">dispatcherServletRegistration</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      DispatcherServlet dispatcherServlet)</span> </span>&#123;</span><br><span class="line">   ServletRegistrationBean registration = <span class="keyword">new</span> ServletRegistrationBean(</span><br><span class="line">         dispatcherServlet, <span class="keyword">this</span>.serverProperties.getServletMapping());</span><br><span class="line">    <span class="comment">//默认拦截： /  所有请求；包静态资源，但是不拦截jsp请求；   /*会拦截jsp</span></span><br><span class="line">    <span class="comment">//可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径</span></span><br><span class="line">    </span><br><span class="line">   registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);</span><br><span class="line">   registration.setLoadOnStartup(</span><br><span class="line">         <span class="keyword">this</span>.webMvcProperties.getServlet().getLoadOnStartup());</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.multipartConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">      registration.setMultipartConfig(<span class="keyword">this</span>.multipartConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）、SpringBoot能不能支持其他的Servlet容器；</p>
<h3 id="3-替换为其他嵌入式servlet容器"><a class="markdownIt-Anchor" href="#3-替换为其他嵌入式servlet容器"></a> 3）、替换为其他嵌入式Servlet容器</h3>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180302114401.png" alt="" /></p>
<p>默认支持：</p>
<p>Tomcat（默认使用）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；</span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Jetty</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入web模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入其他的Servlet容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Undertow</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入web模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入其他的Servlet容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-嵌入式servlet容器自动配置原理"><a class="markdownIt-Anchor" href="#4-嵌入式servlet容器自动配置原理"></a> 4）、嵌入式Servlet容器自动配置原理；</h3>
<p>EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfigureOrder</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@Import</span>(BeanPostProcessorsRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">//导入<span class="title">BeanPostProcessorsRegistrar</span>：<span class="title">Spring</span>注解版；给容器中导入一些组件</span></span><br><span class="line"><span class="class">//导入了<span class="title">EmbeddedServletContainerCustomizerBeanPostProcessor</span>：</span></span><br><span class="line"><span class="class">//后置处理器：<span class="title">bean</span>初始化前后（创建完对象，还没赋值赋值）执行初始化工作</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">EmbeddedServletContainerAutoConfiguration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass</span>(&#123; Servlet<span class="class">.<span class="keyword">class</span>, <span class="title">Tomcat</span>.<span class="title">class</span> &#125;)//判断当前是否引入了<span class="title">Tomcat</span>依赖；</span></span><br><span class="line"><span class="class">	@<span class="title">ConditionalOnMissingBean</span>(<span class="title">value</span> </span>= EmbeddedServletContainerFactory<span class="class">.<span class="keyword">class</span>, <span class="title">search</span> </span>= SearchStrategy.CURRENT)<span class="comment">//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedTomcat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> TomcatEmbeddedServletContainerFactory <span class="title">tomcatEmbeddedServletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> TomcatEmbeddedServletContainerFactory();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Nested configuration if Jetty is being used.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass</span>(&#123; Servlet<span class="class">.<span class="keyword">class</span>, <span class="title">Server</span>.<span class="title">class</span>, <span class="title">Loader</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">			<span class="title">WebAppContext</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">	@<span class="title">ConditionalOnMissingBean</span>(<span class="title">value</span> </span>= EmbeddedServletContainerFactory<span class="class">.<span class="keyword">class</span>, <span class="title">search</span> </span>= SearchStrategy.CURRENT)</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedJetty</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> JettyEmbeddedServletContainerFactory <span class="title">jettyEmbeddedServletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JettyEmbeddedServletContainerFactory();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Nested configuration if Undertow is being used.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Configuration</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass</span>(&#123; Servlet<span class="class">.<span class="keyword">class</span>, <span class="title">Undertow</span>.<span class="title">class</span>, <span class="title">SslClientAuthMode</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">	@<span class="title">ConditionalOnMissingBean</span>(<span class="title">value</span> </span>= EmbeddedServletContainerFactory<span class="class">.<span class="keyword">class</span>, <span class="title">search</span> </span>= SearchStrategy.CURRENT)</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedUndertow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> UndertowEmbeddedServletContainerFactory <span class="title">undertowEmbeddedServletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> UndertowEmbeddedServletContainerFactory();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmbeddedServletContainerFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取嵌入式的Servlet容器</span></span><br><span class="line">   <span class="function">EmbeddedServletContainer <span class="title">getEmbeddedServletContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         ServletContextInitializer... initializers)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180302144835.png" alt="" /></p>
<p>2）、EmbeddedServletContainer：（嵌入式的Servlet容器）</p>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180302144910.png" alt="" /></p>
<p>3）、以<strong>TomcatEmbeddedServletContainerFactory</strong>为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainer <span class="title">getEmbeddedServletContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ServletContextInitializer... initializers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个Tomcat</span></span><br><span class="line">   Tomcat tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置Tomcat的基本环节</span></span><br><span class="line">   File baseDir = (<span class="keyword">this</span>.baseDirectory != <span class="keyword">null</span> ? <span class="keyword">this</span>.baseDirectory</span><br><span class="line">         : createTempDir(<span class="string">"tomcat"</span>));</span><br><span class="line">   tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">   Connector connector = <span class="keyword">new</span> Connector(<span class="keyword">this</span>.protocol);</span><br><span class="line">   tomcat.getService().addConnector(connector);</span><br><span class="line">   customizeConnector(connector);</span><br><span class="line">   tomcat.setConnector(connector);</span><br><span class="line">   tomcat.getHost().setAutoDeploy(<span class="keyword">false</span>);</span><br><span class="line">   configureEngine(tomcat.getEngine());</span><br><span class="line">   <span class="keyword">for</span> (Connector additionalConnector : <span class="keyword">this</span>.additionalTomcatConnectors) &#123;</span><br><span class="line">      tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">   &#125;</span><br><span class="line">   prepareContext(tomcat.getHost(), initializers);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器</span></span><br><span class="line">   <span class="keyword">return</span> getTomcatEmbeddedServletContainer(tomcat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）、我们对嵌入式容器的配置修改是怎么生效？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServerProperties、EmbeddedServletContainerCustomizer</span><br></pre></td></tr></table></figure>
<p><strong>EmbeddedServletContainerCustomizer</strong>：定制器帮我们修改了Servlet容器的配置？</p>
<p>怎么修改的原理？</p>
<p>5）、容器中导入了<strong>EmbeddedServletContainerCustomizerBeanPostProcessor</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化之前</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件</span></span><br><span class="line">   <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ConfigurableEmbeddedServletContainer) &#123;</span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">      postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postProcessBeforeInitialization</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ConfigurableEmbeddedServletContainer bean)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值；</span></span><br><span class="line">    <span class="keyword">for</span> (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123;</span><br><span class="line">        customizer.customize(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;EmbeddedServletContainerCustomizer&gt; <span class="title">getCustomizers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.customizers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Look up does not include the parent context</span></span><br><span class="line">        <span class="keyword">this</span>.customizers = <span class="keyword">new</span> ArrayList&lt;EmbeddedServletContainerCustomizer&gt;(</span><br><span class="line">            <span class="keyword">this</span>.beanFactory</span><br><span class="line">            <span class="comment">//从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer</span></span><br><span class="line">            <span class="comment">//定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件</span></span><br><span class="line">            .getBeansOfType(EmbeddedServletContainerCustomizer<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">false</span>, <span class="title">false</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">values</span>())</span>;</span><br><span class="line">        Collections.sort(<span class="keyword">this</span>.customizers, AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        <span class="keyword">this</span>.customizers = Collections.unmodifiableList(<span class="keyword">this</span>.customizers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.customizers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServerProperties也是定制器</span><br></pre></td></tr></table></figure>
<p>步骤：</p>
<p>1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】</p>
<p>2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor；</p>
<p>只要是嵌入式的Servlet容器工厂，后置处理器就工作；</p>
<p>3）、后置处理器，从容器中获取所有的<strong>EmbeddedServletContainerCustomizer</strong>，调用定制器的定制方法</p>
<p>###5）、嵌入式Servlet容器启动原理；</p>
<p>什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat；</p>
<p>获取嵌入式的Servlet容器工厂：</p>
<p>1）、SpringBoot应用启动运行run方法</p>
<p>2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建<strong>AnnotationConfigEmbeddedWebApplicationContext</strong>，否则：<strong>AnnotationConfigApplicationContext</strong></p>
<p>3）、refresh(context);<strong>刷新刚才创建好的ioc容器；</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）、  onRefresh(); web的ioc容器重写了onRefresh方法</p>
<p>5）、webioc容器会创建嵌入式的Servlet容器；<strong>createEmbeddedServletContainer</strong>();</p>
<p><strong>6）、获取嵌入式的Servlet容器工厂：</strong></p>
<p>EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();</p>
<p>​	从ioc容器中获取EmbeddedServletContainerFactory 组件；<strong>TomcatEmbeddedServletContainerFactory</strong>创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置；</p>
<p>7）、<strong>使用容器工厂获取嵌入式的Servlet容器</strong>：this.embeddedServletContainer = containerFactory      .getEmbeddedServletContainer(getSelfInitializer());</p>
<p>8）、嵌入式的Servlet容器创建对象并启动Servlet容器；</p>
<p><strong>先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来；</strong></p>
<p><strong><mark>IOC容器启动创建嵌入式的Servlet容器</mark></strong></p>
<h2 id="9-使用外置的servlet容器"><a class="markdownIt-Anchor" href="#9-使用外置的servlet容器"></a> 9、使用外置的Servlet容器</h2>
<p>嵌入式Servlet容器：应用打成可执行的jar</p>
<p>​		优点：简单、便携；</p>
<p>​		缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）；</p>
<p>外置的Servlet容器：外面安装Tomcat—应用war包的方式打包；</p>
<h3 id="步骤"><a class="markdownIt-Anchor" href="#步骤"></a> 步骤</h3>
<p>1）、必须创建一个war项目；（利用idea创建好目录结构）</p>
<p>2）、将嵌入式的Tomcat指定为provided；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3）、必须编写一个<strong>SpringBootServletInitializer</strong>的子类，并调用configure方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletInitializer</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//传入SpringBoot应用的主程序</span></span><br><span class="line">      <span class="keyword">return</span> application.sources(SpringBoot04WebJspApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）、启动服务器就可以使用；</p>
<h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3>
<p>jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器；</p>
<p>war包：启动服务器，<strong>服务器启动SpringBoot应用</strong>【SpringBootServletInitializer】，启动ioc容器；</p>
<p>servlet3.0（Spring注解版）：</p>
<p>8.2.4 Shared libraries / runtimes pluggability：</p>
<p>规则：</p>
<p>​	1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例：</p>
<p>​	2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名</p>
<p>​	3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类；</p>
<p>流程：</p>
<p>1）、启动Tomcat</p>
<p>2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer：</p>
<p>Spring的web模块里面有这个文件：<strong>org.springframework.web.SpringServletContainerInitializer</strong></p>
<p>3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例；</p>
<p>4）、每一个WebApplicationInitializer都调用自己的onStartup；</p>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180302221835.png" alt="" /></p>
<p>5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法</p>
<p>6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createRootApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、创建SpringApplicationBuilder</span></span><br><span class="line">   SpringApplicationBuilder builder = createSpringApplicationBuilder();</span><br><span class="line">   StandardServletEnvironment environment = <span class="keyword">new</span> StandardServletEnvironment();</span><br><span class="line">   environment.initPropertySources(servletContext, <span class="keyword">null</span>);</span><br><span class="line">   builder.environment(environment);</span><br><span class="line">   builder.main(getClass());</span><br><span class="line">   ApplicationContext parent = getExistingRootWebApplicationContext(servletContext);</span><br><span class="line">   <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.info(<span class="string">"Root context already created (using as parent)."</span>);</span><br><span class="line">      servletContext.setAttribute(</span><br><span class="line">            WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">null</span>);</span><br><span class="line">      builder.initializers(<span class="keyword">new</span> ParentContextApplicationContextInitializer(parent));</span><br><span class="line">   &#125;</span><br><span class="line">   builder.initializers(</span><br><span class="line">         <span class="keyword">new</span> ServletContextApplicationContextInitializer(servletContext));</span><br><span class="line">   builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来</span></span><br><span class="line">   builder = configure(builder);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用builder创建一个Spring应用</span></span><br><span class="line">   SpringApplication application = builder.build();</span><br><span class="line">   <span class="keyword">if</span> (application.getSources().isEmpty() &amp;&amp; AnnotationUtils</span><br><span class="line">         .findAnnotation(getClass(), Configuration<span class="class">.<span class="keyword">class</span>) !</span>= <span class="keyword">null</span>) &#123;</span><br><span class="line">      application.getSources().add(getClass());</span><br><span class="line">   &#125;</span><br><span class="line">   Assert.state(!application.getSources().isEmpty(),</span><br><span class="line">         <span class="string">"No SpringApplication sources have been defined. Either override the "</span></span><br><span class="line">               + <span class="string">"configure method or add an @Configuration annotation"</span>);</span><br><span class="line">   <span class="comment">// Ensure error pages are registered</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.registerErrorPageFilter) &#123;</span><br><span class="line">      application.getSources().add(ErrorPageFilterConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//启动Spring应用</span></span><br><span class="line">   <span class="keyword">return</span> run(application);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7）、Spring的应用就启动并且创建IOC容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">   StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">   stopWatch.start();</span><br><span class="line">   ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">   FailureAnalyzers analyzers = <span class="keyword">null</span>;</span><br><span class="line">   configureHeadlessProperty();</span><br><span class="line">   SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">   listeners.starting();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">            args);</span><br><span class="line">      ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">            applicationArguments);</span><br><span class="line">      Banner printedBanner = printBanner(environment);</span><br><span class="line">      context = createApplicationContext();</span><br><span class="line">      analyzers = <span class="keyword">new</span> FailureAnalyzers(context);</span><br><span class="line">      prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">            printedBanner);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//刷新IOC容器</span></span><br><span class="line">      refreshContext(context);</span><br><span class="line">      afterRefresh(context, applicationArguments);</span><br><span class="line">      listeners.finished(context, <span class="keyword">null</span>);</span><br><span class="line">      stopWatch.stop();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">         <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">               .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> context;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><mark>启动Servlet容器，再启动SpringBoot应用</mark></strong></p>
<h1 id="五-docker"><a class="markdownIt-Anchor" href="#五-docker"></a> 五、Docker</h1>
<h2 id="1-简介-2"><a class="markdownIt-Anchor" href="#1-简介-2"></a> 1、简介</h2>
<p><strong>Docker</strong>是一个开源的应用容器引擎；是一个轻量级容器技术；</p>
<p>Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；</p>
<p>运行中的这个镜像称为容器，容器启动是非常快速的。</p>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180303145450.png" alt="" /></p>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180303145531.png" alt="" /></p>
<h2 id="2-核心概念"><a class="markdownIt-Anchor" href="#2-核心概念"></a> 2、核心概念</h2>
<p>docker主机(Host)：安装了Docker程序的机器（Docker直接安装在操作系统之上）；</p>
<p>docker客户端(Client)：连接docker主机进行操作；</p>
<p>docker仓库(Registry)：用来保存各种打包好的软件镜像；</p>
<p>docker镜像(Images)：软件打包好的镜像；放在docker仓库中；</p>
<p>docker容器(Container)：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用</p>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180303165113.png" alt="" /></p>
<p>使用Docker的步骤：</p>
<p>1）、安装Docker</p>
<p>2）、去Docker仓库找到这个软件对应的镜像；</p>
<p>3）、使用Docker运行这个镜像，这个镜像就会生成一个Docker容器；</p>
<p>4）、对容器的启动停止就是对软件的启动停止；</p>
<h2 id="3-安装docker"><a class="markdownIt-Anchor" href="#3-安装docker"></a> 3、安装Docker</h2>
<h4 id="1-安装linux虚拟机"><a class="markdownIt-Anchor" href="#1-安装linux虚拟机"></a> 1）、安装linux虚拟机</h4>
<p>​	1）、VMWare、VirtualBox（安装）；</p>
<p>​	2）、导入虚拟机文件centos7-atguigu.ova；</p>
<p>​	3）、双击启动linux虚拟机;使用  root/ 123456登陆</p>
<p>​	4）、使用客户端连接linux服务器进行命令操作；</p>
<p>​	5）、设置虚拟机网络；</p>
<p>​		桥接网络=<mark>选好网卡</mark>==接入网线；</p>
<p>​	6）、设置好网络以后使用命令重启虚拟机的网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure>
<p>​	7）、查看linux的ip地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure>
<p>​	8）、使用客户端连接linux；</p>
<h4 id="2-在linux虚拟机上安装docker"><a class="markdownIt-Anchor" href="#2-在linux虚拟机上安装docker"></a> 2）、在linux虚拟机上安装docker</h4>
<p>步骤：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1、检查内核版本，必须是3.10及以上</span><br><span class="line">uname -r</span><br><span class="line">2、安装docker</span><br><span class="line">yum install docker</span><br><span class="line">3、输入y确认安装</span><br><span class="line">4、启动docker</span><br><span class="line">[root@localhost ~]# systemctl start docker</span><br><span class="line">[root@localhost ~]# docker -v</span><br><span class="line">Docker version 1.12.6, build 3e8e77d/1.12.6</span><br><span class="line">5、开机启动docker</span><br><span class="line">[root@localhost ~]# systemctl enable docker</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.</span><br><span class="line">6、停止docker</span><br><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>
<h2 id="4-docker常用命令操作"><a class="markdownIt-Anchor" href="#4-docker常用命令操作"></a> 4、Docker常用命令&amp;操作</h2>
<h3 id="1-镜像操作"><a class="markdownIt-Anchor" href="#1-镜像操作"></a> 1）、镜像操作</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>检索</td>
<td>docker  search 关键字  eg：docker  search redis</td>
<td>我们经常去docker  hub上检索镜像的详细信息，如镜像的TAG。</td>
</tr>
<tr>
<td>拉取</td>
<td>docker pull 镜像名:tag</td>
<td>:tag是可选的，tag表示标签，多为软件的版本，默认是latest</td>
</tr>
<tr>
<td>列表</td>
<td>docker images</td>
<td>查看所有本地镜像</td>
</tr>
<tr>
<td>删除</td>
<td>docker rmi image-id</td>
<td>删除指定的本地镜像</td>
</tr>
</tbody>
</table>
<p><a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p>
<h3 id="2-容器操作"><a class="markdownIt-Anchor" href="#2-容器操作"></a> 2）、容器操作</h3>
<p>软件镜像（QQ安装程序）----运行镜像----产生一个容器（正在运行的软件，运行的QQ）；</p>
<p>步骤：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1、搜索镜像</span><br><span class="line">[root@localhost ~]# docker search tomcat</span><br><span class="line">2、拉取镜像</span><br><span class="line">[root@localhost ~]# docker pull tomcat</span><br><span class="line">3、根据镜像启动容器</span><br><span class="line">docker run --name mytomcat -d tomcat:latest</span><br><span class="line">4、docker ps  </span><br><span class="line">查看运行中的容器</span><br><span class="line">5、 停止运行中的容器</span><br><span class="line">docker stop  容器的id</span><br><span class="line">6、查看所有的容器</span><br><span class="line">docker ps -a</span><br><span class="line">7、启动容器</span><br><span class="line">docker start 容器id</span><br><span class="line">8、删除一个容器</span><br><span class="line"> docker rm 容器id</span><br><span class="line">9、启动一个做了端口映射的tomcat</span><br><span class="line">[root@localhost ~]# docker run -d -p 8888:8080 tomcat</span><br><span class="line">-d：后台运行</span><br><span class="line">-p: 将主机的端口映射到容器的一个端口    主机端口:容器内部的端口</span><br><span class="line"></span><br><span class="line">10、为了演示简单关闭了linux的防火墙</span><br><span class="line">service firewalld status ；查看防火墙状态</span><br><span class="line">service firewalld stop：关闭防火墙</span><br><span class="line">11、查看容器的日志</span><br><span class="line">docker logs container-name/container-id</span><br><span class="line"></span><br><span class="line">更多命令参看</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/docker/</span><br><span class="line">可以参考每一个镜像的文档</span><br></pre></td></tr></table></figure>
<h3 id="3-安装mysql示例"><a class="markdownIt-Anchor" href="#3-安装mysql示例"></a> 3）、安装MySQL示例</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br></pre></td></tr></table></figure>
<p>错误的启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run --name mysql01 -d mysql</span><br><span class="line">42f09819908bb72dd99ae19e792e0a5d03c48638421fa64cce5f8ba0f40f5846</span><br><span class="line"></span><br><span class="line">mysql退出了</span><br><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                           PORTS               NAMES</span><br><span class="line">42f09819908b        mysql               "docker-entrypoint.sh"   34 seconds ago      Exited (1) 33 seconds ago                            mysql01</span><br><span class="line">538bde63e500        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       compassionate_</span><br><span class="line">goldstine</span><br><span class="line">c4f1ac60b3fc        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       lonely_fermi</span><br><span class="line">81ec743a5271        tomcat              "catalina.sh run"        About an hour ago   Exited (143) About an hour ago                       sick_ramanujan</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//错误日志</span><br><span class="line">[root@localhost ~]# docker logs 42f09819908b</span><br><span class="line">error: database is uninitialized and password option is not specified </span><br><span class="line">  You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD；这个三个参数必须指定一个</span><br></pre></td></tr></table></figure>
<p>正确的启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br><span class="line">b874c56bec49fb43024b3805ab51e9097da779f2f572c22c695305dedd684c5f</span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">b874c56bec49        mysql               "docker-entrypoint.sh"   4 seconds ago       Up 3 seconds        3306/tcp            mysql01</span><br></pre></td></tr></table></figure>
<p>做了端口映射</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run -p 3306:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br><span class="line">ad10e4bc5c6a0f61cbad43898de71d366117d120e39db651844c0e73863b9434</span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">ad10e4bc5c6a        mysql               "docker-entrypoint.sh"   4 seconds ago       Up 2 seconds        0.0.0.0:3306-&gt;3306/tcp   mysql02</span><br></pre></td></tr></table></figure>
<p>几个其他的高级操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name mysql03 -v &#x2F;conf&#x2F;mysql:&#x2F;etc&#x2F;mysql&#x2F;conf.d -e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw -d mysql:tag</span><br><span class="line">把主机的&#x2F;conf&#x2F;mysql文件夹挂载到 mysqldocker容器的&#x2F;etc&#x2F;mysql&#x2F;conf.d文件夹里面</span><br><span class="line">改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（&#x2F;conf&#x2F;mysql）</span><br><span class="line"></span><br><span class="line">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD&#x3D;my-secret-pw -d mysql:tag --character-set-server&#x3D;utf8mb4 --collation-server&#x3D;utf8mb4_unicode_ci</span><br><span class="line">指定mysql的一些配置参数</span><br></pre></td></tr></table></figure>
<h1 id="六-springboot与数据访问"><a class="markdownIt-Anchor" href="#六-springboot与数据访问"></a> 六、SpringBoot与数据访问</h1>
<h2 id="1-jdbc"><a class="markdownIt-Anchor" href="#1-jdbc"></a> 1、JDBC</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.15.22:3306/jdbc</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p>​	默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源；</p>
<p>​	数据源的相关配置都在DataSourceProperties里面；</p>
<p>自动配置原理：</p>
<p>org.springframework.boot.autoconfigure.jdbc：</p>
<p>1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型；</p>
<p>2、SpringBoot默认可以支持；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、</span><br></pre></td></tr></table></figure>
<p>3、自定义数据源类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Generic DataSource configuration.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(DataSource<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">name</span> </span>= <span class="string">"spring.datasource.type"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(DataSourceProperties properties)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性</span></span><br><span class="line">      <span class="keyword">return</span> properties.initializeDataSourceBuilder().build();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、<strong>DataSourceInitializer：ApplicationListener</strong>；</p>
<p>​	作用：</p>
<p>​		1）、runSchemaScripts();运行建表语句；</p>
<p>​		2）、runDataScripts();运行插入数据的sql语句；</p>
<p>默认只需要将文件命名为：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">schema-*.sql、data-*.sql</span></span><br><span class="line"><span class="attr">默认规则：schema.sql，schema-all.sql；</span></span><br><span class="line"><span class="meta">可以使用</span>   <span class="string"></span></span><br><span class="line">	<span class="attr">schema</span>:<span class="string"></span></span><br><span class="line">      <span class="meta">-</span> <span class="string">classpath:department.sql</span></span><br><span class="line">      <span class="attr">指定位置</span></span><br></pre></td></tr></table></figure>
<p>5、操作数据库：自动配置了JdbcTemplate操作数据库</p>
<h2 id="2-整合druid数据源"><a class="markdownIt-Anchor" href="#2-整合druid数据源"></a> 2、整合Druid数据源</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">导入druid数据源</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource"</span>)</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">druid</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置Druid的监控</span></span><br><span class="line">    <span class="comment">//1、配置一个管理后台的Servlet</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">statViewServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServletRegistrationBean bean = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> StatViewServlet(), <span class="string">"/druid/*"</span>);</span><br><span class="line">        Map&lt;String,String&gt; initParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        initParams.put(<span class="string">"loginUsername"</span>,<span class="string">"admin"</span>);</span><br><span class="line">        initParams.put(<span class="string">"loginPassword"</span>,<span class="string">"123456"</span>);</span><br><span class="line">        initParams.put(<span class="string">"allow"</span>,<span class="string">""</span>);<span class="comment">//默认就是允许所有访问</span></span><br><span class="line">        initParams.put(<span class="string">"deny"</span>,<span class="string">"192.168.15.21"</span>);</span><br><span class="line"></span><br><span class="line">        bean.setInitParameters(initParams);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、配置一个web监控的filter</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">webStatFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FilterRegistrationBean bean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        bean.setFilter(<span class="keyword">new</span> WebStatFilter());</span><br><span class="line"></span><br><span class="line">        Map&lt;String,String&gt; initParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        initParams.put(<span class="string">"exclusions"</span>,<span class="string">"*.js,*.css,/druid/*"</span>);</span><br><span class="line"></span><br><span class="line">        bean.setInitParameters(initParams);</span><br><span class="line"></span><br><span class="line">        bean.setUrlPatterns(Arrays.asList(<span class="string">"/*"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-整合mybatis"><a class="markdownIt-Anchor" href="#3-整合mybatis"></a> 3、整合MyBatis</h2>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180305194443.png" alt="" /></p>
<p>步骤：</p>
<p>​	1）、配置数据源相关属性（见上一节Druid）</p>
<p>​	2）、给数据库建表</p>
<p>​	3）、创建JavaBean</p>
<h3 id="4-注解版"><a class="markdownIt-Anchor" href="#4-注解版"></a> 4）、注解版</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定这是一个操作数据库的mapper</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DepartmentMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from department where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Department <span class="title">getDeptById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete</span>(<span class="string">"delete from department where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteDeptById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Options</span>(useGeneratedKeys = <span class="keyword">true</span>,keyProperty = <span class="string">"id"</span>)</span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into department(departmentName) values(#&#123;departmentName&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertDept</span><span class="params">(Department department)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update</span>(<span class="string">"update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateDept</span><span class="params">(Department department)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题：</p>
<p>自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.springframework.context.annotation.Configuration</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConfigurationCustomizer <span class="title">configurationCustomizer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConfigurationCustomizer()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Configuration configuration)</span> </span>&#123;</span><br><span class="line">                configuration.setMapUnderscoreToCamelCase(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用MapperScan批量扫描所有的Mapper接口；</span><br><span class="line"><span class="meta">@MapperScan</span>(value = <span class="string">"com.atguigu.springboot.mapper"</span>)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBoot06DataMybatisApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(SpringBoot06DataMybatisApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-配置文件版"><a class="markdownIt-Anchor" href="#5-配置文件版"></a> 5）、配置文件版</h3>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">config-location:</span> <span class="string">classpath:mybatis/mybatis-config.xml</span> <span class="string">指定全局配置文件的位置</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mybatis/mapper/*.xml</span>  <span class="string">指定sql映射文件的位置</span></span><br></pre></td></tr></table></figure>
<p>更多使用参照</p>
<p><a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/" target="_blank" rel="noopener">http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</a></p>
<h2 id="4-整合springdata-jpa"><a class="markdownIt-Anchor" href="#4-整合springdata-jpa"></a> 4、整合SpringData JPA</h2>
<h3 id="1-springdata简介"><a class="markdownIt-Anchor" href="#1-springdata简介"></a> 1）、SpringData简介</h3>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180306105412.png" alt="" /></p>
<h3 id="2-整合springdata-jpa"><a class="markdownIt-Anchor" href="#2-整合springdata-jpa"></a> 2）、整合SpringData JPA</h3>
<p>JPA:ORM（Object Relational Mapping）；</p>
<p>1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用JPA注解配置映射关系</span></span><br><span class="line"><span class="meta">@Entity</span> <span class="comment">//告诉JPA这是一个实体类（和数据表映射的类）</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"tbl_user"</span>) <span class="comment">//@Table来指定和哪个数据表对应;如果省略默认表名就是user；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span> <span class="comment">//这是一个主键</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)<span class="comment">//自增主键</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"last_name"</span>,length = <span class="number">50</span>) <span class="comment">//这是和数据表对应的一个列</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="meta">@Column</span> <span class="comment">//省略默认列名就是属性名</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br></pre></td></tr></table></figure>
<p>2）、编写一个Dao接口来操作实体类对应的数据表（Repository）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承JpaRepository来完成对数据库的操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）、基本的配置JpaProperties</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line"> <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line"><span class="comment">#     更新或者创建数据表结构</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br><span class="line"><span class="comment">#    控制台显示SQL</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="七-启动配置原理"><a class="markdownIt-Anchor" href="#七-启动配置原理"></a> 七、启动配置原理</h1>
<p>几个重要的事件回调机制</p>
<p>配置在META-INF/spring.factories</p>
<p><strong>ApplicationContextInitializer</strong></p>
<p><strong>SpringApplicationRunListener</strong></p>
<p>只需要放在ioc容器中</p>
<p><strong>ApplicationRunner</strong></p>
<p><strong>CommandLineRunner</strong></p>
<p>启动流程：</p>
<h2 id="1-创建springapplication对象"><a class="markdownIt-Anchor" href="#1-创建springapplication对象"></a> <strong>1、创建SpringApplication对象</strong></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">initialize(sources);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(Object[] sources)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存主配置类</span></span><br><span class="line">    <span class="keyword">if</span> (sources != <span class="keyword">null</span> &amp;&amp; sources.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sources.addAll(Arrays.asList(sources));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前是否一个web应用</span></span><br><span class="line">    <span class="keyword">this</span>.webEnvironment = deduceWebEnvironment();</span><br><span class="line">    <span class="comment">//从类路径下找到META-INF/spring.factories配置的所有ApplicationContextInitializer；然后保存起来</span></span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(</span><br><span class="line">        ApplicationContextInitializer<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    <span class="comment">//从类路径下找到ETA-INF/spring.factories配置的所有ApplicationListener</span></span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    <span class="comment">//从多个配置类中找到有main方法的主配置类</span></span><br><span class="line">    <span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180306145727.png" alt="" /></p>
<p><img src="images/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180306145855.png" alt="" /></p>
<h2 id="2-运行run方法"><a class="markdownIt-Anchor" href="#2-运行run方法"></a> 2、运行run方法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">   StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">   stopWatch.start();</span><br><span class="line">   ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">   FailureAnalyzers analyzers = <span class="keyword">null</span>;</span><br><span class="line">   configureHeadlessProperty();</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//获取SpringApplicationRunListeners；从类路径下META-INF/spring.factories</span></span><br><span class="line">   SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">    <span class="comment">//回调所有的获取SpringApplicationRunListener.starting()方法</span></span><br><span class="line">   listeners.starting();</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//封装命令行参数</span></span><br><span class="line">      ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">            args);</span><br><span class="line">      <span class="comment">//准备环境</span></span><br><span class="line">      ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">            applicationArguments);</span><br><span class="line">       		<span class="comment">//创建环境完成后回调SpringApplicationRunListener.environmentPrepared()；表示环境准备完成</span></span><br><span class="line">       </span><br><span class="line">      Banner printedBanner = printBanner(environment);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//创建ApplicationContext；决定创建web的ioc还是普通的ioc</span></span><br><span class="line">      context = createApplicationContext();</span><br><span class="line">       </span><br><span class="line">      analyzers = <span class="keyword">new</span> FailureAnalyzers(context);</span><br><span class="line">       <span class="comment">//准备上下文环境;将environment保存到ioc中；而且applyInitializers()；</span></span><br><span class="line">       <span class="comment">//applyInitializers()：回调之前保存的所有的ApplicationContextInitializer的initialize方法</span></span><br><span class="line">       <span class="comment">//回调所有的SpringApplicationRunListener的contextPrepared()；</span></span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">      prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">            printedBanner);</span><br><span class="line">       <span class="comment">//prepareContext运行完成以后回调所有的SpringApplicationRunListener的contextLoaded（）；</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//s刷新容器；ioc容器初始化（如果是web应用还会创建嵌入式的Tomcat）；Spring注解版</span></span><br><span class="line">       <span class="comment">//扫描，创建，加载所有组件的地方；（配置类，组件，自动配置）</span></span><br><span class="line">      refreshContext(context);</span><br><span class="line">       <span class="comment">//从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调</span></span><br><span class="line">       <span class="comment">//ApplicationRunner先回调，CommandLineRunner再回调</span></span><br><span class="line">      afterRefresh(context, applicationArguments);</span><br><span class="line">       <span class="comment">//所有的SpringApplicationRunListener回调finished方法</span></span><br><span class="line">      listeners.finished(context, <span class="keyword">null</span>);</span><br><span class="line">      stopWatch.stop();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">         <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">               .logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">//整个SpringBoot应用启动完成以后返回启动的ioc容器；</span></span><br><span class="line">      <span class="keyword">return</span> context;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-事件监听机制"><a class="markdownIt-Anchor" href="#3-事件监听机制"></a> 3、事件监听机制</h2>
<p>配置在META-INF/spring.factories</p>
<p><strong>ApplicationContextInitializer</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationContextInitializer</span> <span class="keyword">implements</span> <span class="title">ApplicationContextInitializer</span>&lt;<span class="title">ConfigurableApplicationContext</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ApplicationContextInitializer...initialize..."</span>+applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SpringApplicationRunListener</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSpringApplicationRunListener</span> <span class="keyword">implements</span> <span class="title">SpringApplicationRunListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//必须有的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloSpringApplicationRunListener</span><span class="params">(SpringApplication application, String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SpringApplicationRunListener...starting..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">        Object o = environment.getSystemProperties().get(<span class="string">"os.name"</span>);</span><br><span class="line">        System.out.println(<span class="string">"SpringApplicationRunListener...environmentPrepared.."</span>+o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SpringApplicationRunListener...contextPrepared..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SpringApplicationRunListener...contextLoaded..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finished</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SpringApplicationRunListener...finished..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置（META-INF/spring.factories）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">org.springframework.context.ApplicationContextInitializer</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">com.atguigu.springboot.listener.HelloApplicationContextInitializer</span></span><br><span class="line"></span><br><span class="line"><span class="meta">org.springframework.boot.SpringApplicationRunListener</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">com.atguigu.springboot.listener.HelloSpringApplicationRunListener</span></span><br></pre></td></tr></table></figure>
<p>只需要放在ioc容器中</p>
<p><strong>ApplicationRunner</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApplicationRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ApplicationRunner...run...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CommandLineRunner</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloCommandLineRunner</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CommandLineRunner...run..."</span>+ Arrays.asList(args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="八-自定义starter"><a class="markdownIt-Anchor" href="#八-自定义starter"></a> 八、自定义starter</h1>
<p>starter：</p>
<p>​	1、这个场景需要使用到的依赖是什么？</p>
<p>​	2、如何编写自动配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//指定这个类是一个配置类</span></span><br><span class="line"><span class="meta">@ConditionalOnXXX</span>  <span class="comment">//在指定条件成立的情况下自动配置类生效</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>  <span class="comment">//指定自动配置类的顺序</span></span><br><span class="line"><span class="meta">@Bean</span>  <span class="comment">//给容器中添加组件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationPropertie</span>结合相关xxxProperties类来绑定相关的配置</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span> <span class="comment">//让xxxProperties生效加入到容器中</span></span><br><span class="line"></span><br><span class="line">自动配置类要能加载</span><br><span class="line">将需要启动就加载的自动配置类，配置在META-INF/spring.factories</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br></pre></td></tr></table></figure>
<p>​	3、模式：</p>
<p>启动器只用来做依赖导入；</p>
<p>专门来写一个自动配置模块；</p>
<p>启动器依赖自动配置；别人只需要引入启动器（starter）</p>
<p>mybatis-spring-boot-starter；自定义启动器名-spring-boot-starter</p>
<p>步骤：</p>
<p>1）、启动器模块</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.starter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>atguigu-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--启动器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--引入自动配置模块--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.starter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>atguigu-spring-boot-starter-autoconfigurer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2）、自动配置模块</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.starter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>atguigu-spring-boot-starter-autoconfigurer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>atguigu-spring-boot-starter-autoconfigurer<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!--引入spring-boot-starter；所有starter的基本配置--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.starter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"atguigu.hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String prefix;</span><br><span class="line">    <span class="keyword">private</span> String suffix;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.prefix = prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSuffix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuffix</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.suffix = suffix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.starter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloProperties <span class="title">getHelloProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHelloProperties</span><span class="params">(HelloProperties helloProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.helloProperties = helloProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHellAtguigu</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloProperties.getPrefix()+<span class="string">"-"</span> +name + helloProperties.getSuffix();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.starter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span> <span class="comment">//web应用才生效</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HelloProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">HelloServiceAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HelloProperties helloProperties;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HelloService service = <span class="keyword">new</span> HelloService();</span><br><span class="line">        service.setHelloProperties(helloProperties);</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="更多springboot整合示例"><a class="markdownIt-Anchor" href="#更多springboot整合示例"></a> 更多SpringBoot整合示例</h1>
<p><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples">https://github.com/spring-projects/spring-boot/tree/master/spring-boot-samples</a></p>
<p>jing</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>10模型评估与选择</title>
    <url>/2020/06/30/10%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<h1 id="经验误差与过拟合"><a class="markdownIt-Anchor" href="#经验误差与过拟合"></a> 经验误差与过拟合</h1>
<h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2>
<ol>
<li><strong>错误率</strong> 错误样本占样本总数的比例</li>
<li><strong>精度</strong> = 1- 错误率</li>
<li><strong>误差</strong> 机器学习的实际预测输出与样本的真实输出之间的差异称为误差</li>
<li><strong>训练误差</strong> 指学习器在训练集上的误差</li>
<li><strong>泛化误差</strong> 指在新样本上的误差</li>
<li>过拟合因素：学习能力过于强大</li>
<li>欠拟合因素：学习能力太弱，训练轮次不够</li>
</ol>
<h1 id="模型评估方法"><a class="markdownIt-Anchor" href="#模型评估方法"></a> 模型评估方法</h1>
<h2 id="留出法"><a class="markdownIt-Anchor" href="#留出法"></a> 留出法</h2>
<ol>
<li>
<p>直接讲数据集划分成两个互斥的集合，其中一个作为训练集S，另一个作为测试集T</p>
</li>
<li>
<p><strong>注意</strong> 训练集和测试集要尽可能保持数据分布的一致性。<strong>保留类别比例的采样方式称为分层采样</strong></p>
</li>
<li>
<p>在使用留出法时，<strong>一般要采用若干次随机划分</strong>，重复进行试验评估后取平均值作为留出法的评估结果。例如进行100次随即划分，每次产生一个训练/测试集用于试验评估，100次后得到100个结果，而留出法返回的则是这100个结果的平均。</p>
</li>
<li>
<p><strong>通常</strong> 将大约2/3~4/5的样本用于训练，剩余样本用于测试</p>
</li>
</ol>
<h2 id="交叉验证法"><a class="markdownIt-Anchor" href="#交叉验证法"></a> 交叉验证法</h2>
<ol>
<li>先将数据集D划分成k个大小相似的互斥子集，即D = D1∪D2∪…∪Dk。每个子集Di都尽可能保持数据分布的一致性(分层采样);然后每次用K-1个子集的并集作为训练集，1个用作测试集。得到k组结果，最终返回k组结果的均值</li>
<li>通常k折交叉验证要随机使用不同的划分重复p次，最终的评估结果是这p次k折交叉结果的均值。常见的是10次10折交叉验证</li>
<li>k通常取3，5，10，15</li>
</ol>
<h3 id="留一法"><a class="markdownIt-Anchor" href="#留一法"></a> <strong>留一法</strong></h3>
<p>若D中包含m个样本，令k=m得到的交叉验证法称为留一法。<strong>留一法不受随机样本划分方式的影响</strong></p>
<h2 id="自助法"><a class="markdownIt-Anchor" href="#自助法"></a> 自助法</h2>
<ol>
<li>
<p>以自助采样法为基础，给定包含m个样本的数据集D，然后对它进行采样产生数据集D’：<strong>每次随机从D中挑选一个样本，将其拷贝放入D’中，使得该样本在线下次采样时仍然有可能被采到</strong>，重复执行m次，得到包含m个样本的数据集D’即为自主采样的结果。</p>
</li>
<li>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%5Cmd%5C%E5%9B%BE%E7%89%87%5C2.png" alt="" /></p>
<p>因此，初始数据集中约有36.8%的样本未出现在采样数据集中。</p>
</li>
<li>
<p><strong>优点</strong> 实际评估的模型与期望评估的模型都是用m个训练样本，而我们热能有约1/3的样本可以用于测试。<strong>适用于小的数据集</strong></p>
</li>
<li>
<p><strong>缺点</strong> 改变了原始数据集的分布，<strong>引入估计偏差</strong>。因此大数据集上还是留出法和交叉验证法更为常用</p>
</li>
</ol>
<h2 id="调参与最终模型"><a class="markdownIt-Anchor" href="#调参与最终模型"></a> 调参与最终模型</h2>
<h3 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h3>
<ol>
<li>方法时对每种参数设定取值范围和步长，</li>
</ol>
<h1 id="性能度量"><a class="markdownIt-Anchor" href="#性能度量"></a> 性能度量</h1>
<p>性能度量反应了任务需求</p>
<h2 id="回归问题"><a class="markdownIt-Anchor" href="#回归问题"></a> 回归问题</h2>
<img src="C:\Users\86139\Desktop\机器学习\md\图片\3.png" style="zoom:50%;" />
<h2 id="错误率与精度"><a class="markdownIt-Anchor" href="#错误率与精度"></a> 错误率与精度</h2>
<ol>
<li>
<p><strong>常用于分类问题</strong></p>
</li>
<li>
<p>对于数据分布D和概率密度函数p，则错误率和精度可分别定义为</p>
<img src="C:\Users\86139\Desktop\机器学习\md\图片\4.png" style="zoom:50%;" />
<img src="C:\Users\86139\Desktop\机器学习\md\图片\5.png" style="zoom:50%;" />
</li>
</ol>
<h2 id="查准率-查全率与f1"><a class="markdownIt-Anchor" href="#查准率-查全率与f1"></a> 查准率、查全率与F1</h2>
<h3 id="非类结果混淆矩阵"><a class="markdownIt-Anchor" href="#非类结果混淆矩阵"></a> 非类结果混淆矩阵</h3>
<img src="C:\Users\86139\Desktop\机器学习\md\图片\6.png" style="zoom:50%;" />
<h3 id="查准率-p-与查全率-r"><a class="markdownIt-Anchor" href="#查准率-p-与查全率-r"></a> 查准率 P 与查全率 R</h3>
<img src="C:\Users\86139\Desktop\机器学习\md\图片\7.png" style="zoom:50%;" />
<ol>
<li>查准率：正确率</li>
<li>查全率：真正例率</li>
<li><strong>是一对矛盾的度量</strong>。一般来说，查准率高时，查全率往往偏低；反之亦然。只有在一些简单任务中，才可能使查全率和查准率都很高</li>
</ol>
<h3 id="p-r曲线"><a class="markdownIt-Anchor" href="#p-r曲线"></a> P-R曲线</h3>
<img src="C:\Users\86139\Desktop\机器学习\md\图片\8.png" style="zoom: 67%;" />
<ol>
<li>根据学习器的预测结果对样例进行排序，排在前面的是学习器认为最可能是正例的样本，排在后面的则是学习器认为最不可能是正例的样本，按此顺序逐个把样本作为正例进行预测，则每次可以计算出当前的查全率，和查准率，即可绘制出P-R图</li>
<li>若一个学习器的P-R曲线被另一个完全包住，<strong>那么可断言后者优于前者</strong>。如A优于C</li>
<li>也可通过曲线下面积进行比较，但是不易判断。故提出平衡点</li>
</ol>
<h3 id="平衡点"><a class="markdownIt-Anchor" href="#平衡点"></a> 平衡点</h3>
<ol>
<li>平衡点是查准率=查全率时的取值，越大越好</li>
</ol>
<h3 id="f1度量调和平均"><a class="markdownIt-Anchor" href="#f1度量调和平均"></a> F1度量：调和平均</h3>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%5Cmd%5C%E5%9B%BE%E7%89%87%5C9.png" alt="" /></p>
<h3 id="fβ度量"><a class="markdownIt-Anchor" href="#fβ度量"></a> Fβ度量</h3>
<p>体现了对查全率和查准率的不同偏好</p>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%5Cmd%5C%E5%9B%BE%E7%89%87%5C10.png" alt="" /></p>
<h3 id="多分类问题的度量"><a class="markdownIt-Anchor" href="#多分类问题的度量"></a> 多分类问题的度量</h3>
<p>有时，我们有多个混淆矩阵，想要估计算法的全局性能。</p>
<ol>
<li>
<p>宏查准率/查全率</p>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%5Cmd%5C%E5%9B%BE%E7%89%87%5C11.png" alt="" /></p>
</li>
<li>
<p>微查准率、微查全率、微F1</p>
<p>先计算混淆矩阵的对应元素的平均，则计算P和R，F1</p>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%5Cmd%5C%E5%9B%BE%E7%89%87%5C12.png" alt="" /></p>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%5Cmd%5C%E5%9B%BE%E7%89%87%5C13.png" alt="" /></p>
</li>
</ol>
<h2 id="roc-与-auc"><a class="markdownIt-Anchor" href="#roc-与-auc"></a> ROC 与 AUC</h2>
<h3 id="roc"><a class="markdownIt-Anchor" href="#roc"></a> ROC</h3>
<p>纵轴是真正例率TPR，横轴是假正例率FPR</p>
<img src="C:\Users\86139\Desktop\机器学习\md\图片\14.png" style="zoom:50%;" />
<ol>
<li>
<p>绘制过程</p>
<img src="C:\Users\86139\Desktop\机器学习\md\图片\15.png" style="zoom:50%;" />
</li>
</ol>
<h3 id="auc"><a class="markdownIt-Anchor" href="#auc"></a> AUC</h3>
<ol>
<li>
<p>是ROC曲线下的面积</p>
</li>
<li>
<p>估算</p>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%5Cmd%5C%E5%9B%BE%E7%89%87%5C16.png" alt="" /></p>
</li>
<li>
<p>AUC考虑的是样本预测的排序质量，它与排序误差有紧密联系。</p>
</li>
<li>
<p><strong>损失</strong></p>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%5Cmd%5C%E5%9B%BE%E7%89%87%5C17.png" alt="" /></p>
<ol>
<li>给定m+的正例和m-个反例，令D+,D-分别表示正反例集合</li>
<li><strong>解释</strong> 考虑每一对正反例，若正例的预测值小于反例，则记一个罚分，若相等，则记0.5个罚分</li>
<li>loss对应ROC曲线之上的面积</li>
</ol>
</li>
</ol>
<h3 id="多分类roc"><a class="markdownIt-Anchor" href="#多分类roc"></a> 多分类ROC</h3>
<p>一般转换成多个二分类，画多个ROC</p>
<h2 id="代价敏感错误率和代价曲线"><a class="markdownIt-Anchor" href="#代价敏感错误率和代价曲线"></a> 代价敏感错误率和代价曲线</h2>
<h3 id="代价矩阵cost"><a class="markdownIt-Anchor" href="#代价矩阵cost"></a> 代价矩阵cost</h3>
<p>以二分类为例，其中cost<sub>ij</sub>代表将第i类样本预测为第j类样本的代价。</p>
<h3 id="代价敏感的错误率非均等代价"><a class="markdownIt-Anchor" href="#代价敏感的错误率非均等代价"></a> 代价敏感的错误率(非均等代价)</h3>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%5Cmd%5C%E5%9B%BE%E7%89%87%5C18.png" alt="" /></p>
<p><strong>带权的错误率</strong></p>
<h3 id="代价曲线"><a class="markdownIt-Anchor" href="#代价曲线"></a> 代价曲线</h3>
<p>在非均等代价下，ROC曲线不能直接反应出学习器的期望总体代价，而代价曲线可以。</p>
<ol>
<li>
<p>其横轴是取值为[0,1]的正例概率代价。其中p是样例为正例的概率</p>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%5Cmd%5C%E5%9B%BE%E7%89%87%5C19.png" alt="" /></p>
</li>
<li>
<p>其纵轴是取值为[0,1]的归一化代价</p>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%5Cmd%5C%E5%9B%BE%E7%89%87%5C20.png" alt="" /></p>
<p>FNR = 1- TPR 假负例率</p>
</li>
<li>
<p>绘制</p>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%5Cmd%5C%E5%9B%BE%E7%89%87%5C21.png" alt="" /></p>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%5Cmd%5C%E5%9B%BE%E7%89%87%5C22.png" alt="" /></p>
</li>
</ol>
<h1 id="比较检验"><a class="markdownIt-Anchor" href="#比较检验"></a> 比较检验</h1>
<ol>
<li>要综合考虑泛化能力和在测试集上的性能。</li>
<li>测试集上的性能与测试集本身的选择有很大关系</li>
<li>很多机器学习算法本身具有一定随机性，即便用相同的参数设置在同一个测试集上多次运行，其结果也会不同</li>
<li>由于以上问题，使用一些方法来为机器学习性能的比较提供依据。比如假设检验法</li>
</ol>
<h2 id="假设检验"><a class="markdownIt-Anchor" href="#假设检验"></a> 假设检验</h2>
<h3 id="假设"><a class="markdownIt-Anchor" href="#假设"></a> 假设</h3>
<ol>
<li>是对学习器泛化错误率分布的某种判断或猜想。现实中，往往根据测试错误率估推出泛化错误率的分布。</li>
</ol>
<h3 id="泛化错误率为ε的学习器被测得测试错误率为ε的概率"><a class="markdownIt-Anchor" href="#泛化错误率为ε的学习器被测得测试错误率为ε的概率"></a> 泛化错误率为ε的学习器被测得测试错误率为ε^^^的概率<img src="C:%5CUsers%5C86139%5CDesktop%5C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%5Cmd%5C%E5%9B%BE%E7%89%87%5C23.png" alt="" /></h3>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%5Cmd%5C%E5%9B%BE%E7%89%87%5C24.png" alt="" /></p>
<ol>
<li>
<p><strong>二项检验</strong></p>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%5Cmd%5C%E5%9B%BE%E7%89%87%5C25.png" alt="" /></p>
<p>结论：</p>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%5Cmd%5C%E5%9B%BE%E7%89%87%5C26.png" alt="" /></p>
</li>
<li>
<p><strong>t检验</strong> ：用于手里多个测试错误率的情况</p>
<ol>
<li>平均错误率和方差</li>
</ol>
</li>
</ol>
<h1 id="过拟合"><a class="markdownIt-Anchor" href="#过拟合"></a> 过拟合</h1>
<h2 id="将训练数据分为训练集和验证集"><a class="markdownIt-Anchor" href="#将训练数据分为训练集和验证集"></a> 将训练数据分为训练集和验证集</h2>
<img src="/MyImages/90.png" style="zoom:50%;" />
<ul>
<li>目标是在验证集上误差最小</li>
</ul>
<h1 id="评估一个假设"><a class="markdownIt-Anchor" href="#评估一个假设"></a> 评估一个假设</h1>
<ul>
<li>目的是防止过拟合</li>
<li>需要将数据分成训练集和测试集，重点是要保证数据分布一致</li>
<li>在测试集上测试模型
<ul>
<li>对于线性回归模型，利用测试集数据计算代价函数 J</li>
<li>
<img src="/MyImages/image-20200516091605630.png" alt="image-20200516091605630" style="zoom:67%;" />
</li>
</ul>
</li>
</ul>
<h1 id="模型选择和交叉验证集"><a class="markdownIt-Anchor" href="#模型选择和交叉验证集"></a> 模型选择和交叉验证集</h1>
<h2 id="模型选择的方法"><a class="markdownIt-Anchor" href="#模型选择的方法"></a> 模型选择的方法</h2>
<ul>
<li>使用训练集训练出 10 个模型</li>
<li>用 10 个模型分别对交叉验证集计算得出交叉验证误差（代价函数的值）</li>
<li>选取代价函数值最小的模型</li>
<li>用步骤 3 中选出的模型对测试集计算得出推广误差（代价函数的值）</li>
</ul>
<img src="/MyImages/image-20200516092528849.png" alt="image-20200516092528849" style="zoom:50%;" />
<h1 id="诊断偏差和方差"><a class="markdownIt-Anchor" href="#诊断偏差和方差"></a> 诊断偏差和方差</h1>
<ul>
<li>判断过拟合和欠拟合与偏差、方差的关系。</li>
</ul>
<img src="/MyImages/image-20200516093118866.png" alt="image-20200516093118866" style="zoom: 67%;" />
<ul>
<li>通常将训练集和交叉验证集的代价函数误差与多项式的次数绘制在同一张图上</li>
</ul>
<img src="/MyImages/image-20200516093354773.png" alt="image-20200516093354773" style="zoom:50%;" />
<ul>
<li>
<p>对于训练集，当 𝑑 较小时，模型拟合程度更低，误差较大；随着 𝑑 的增长，拟合程</p>
<p>度提高，误差减小。</p>
</li>
<li>
<p>对于交叉验证集，当 𝑑 较小时，模型拟合程度低，误差较大；但是随着 𝑑 的增长，</p>
<p>误差呈现先减小后增大的趋势，转折点是我们的模型开始过拟合训练数据集的时候。</p>
</li>
</ul>
<img src="/MyImages/image-20200516093446803.png" alt="image-20200516093446803" style="zoom: 50%;" />
<h2 id="判断方法"><a class="markdownIt-Anchor" href="#判断方法"></a> 判断方法</h2>
<img src="/MyImages/162bbe3ae6c8f46da4f4e05edea2d9fc_1440w.jpg" alt="img" style="zoom:50%;" />
<ul>
<li>同时结合前面方差和偏差随次数变换的情况可得结论
<ul>
<li>当训练集误差和交叉验证集误差近似时（都高）是欠拟合，有高偏差问题</li>
<li>当交叉验证集误差大于训练集误差时：是过拟合，有高方差问题。</li>
</ul>
</li>
</ul>
<h1 id="正则化和偏差方差"><a class="markdownIt-Anchor" href="#正则化和偏差方差"></a> 正则化和偏差/方差</h1>
<img src="/MyImages/image-20200516095811229.png" alt="image-20200516095811229"  />
<ul>
<li>
<p>选择λ的方法</p>
<p>1.使用训练集训练出 12 个不同程度正则化的模型</p>
<p>2.用 12 个模型分别对交叉验证集计算的出交叉验证误差</p>
<p>3.选择得出交叉验证误差<strong>最小</strong>的模型</p>
<p>4.运用步骤 3 中选出模型对测试集计算得出推广误差，我们也可以同时将训练集和交叉验证集模型的代价函数误差与 λ 的值绘制在一张图表上：</p>
</li>
</ul>
<h2 id="偏差方差-与-正则化的关系"><a class="markdownIt-Anchor" href="#偏差方差-与-正则化的关系"></a> 偏差/方差 与 正则化的关系</h2>
<p><img src="/MyImages/image-20200516102004045.png" alt="image-20200516102004045" /></p>
<ul>
<li>当 𝜆 较小时，训练集误差较小（过拟合）而交叉验证集误差较大</li>
<li>随着 𝜆 的增加，训练集误差不断增加（欠拟合），而交叉验证集误差则是先减小后增加</li>
</ul>
<h1 id="学习曲线"><a class="markdownIt-Anchor" href="#学习曲线"></a> 学习曲线</h1>
<ul>
<li>学习曲线是将训练集误差和交叉验证集误差作为训练集实例数量的函数绘制的图表</li>
</ul>
<img src="/MyImages/image-20200516102352692.png" alt="image-20200516102352692" style="zoom:80%;" />
<ul>
<li>
<img src="/MyImages/image-20200516102503027.png" alt="image-20200516102503027" style="zoom:80%;" />
* 如果用一条直线来模拟这些点，那么无论训练集有多么大误差都不会有太大改观
* **即高偏差/欠拟合的情况下，增加数据到训练集不一定有帮助**
</li>
<li>
<img src="/MyImages/image-20200516102720570.png" alt="image-20200516102720570" style="zoom: 80%;" />
* 使用非常高次的多项式来模拟，可以看出，当交叉验证集误差远大于训练集误差时，往训练集增加更多数据可以提高模型的效果。
* **即在高方差/过拟合的情况下，增加更多数据到训练集可能提高算法效果**
</li>
</ul>
<h1 id="不同情况的做法"><a class="markdownIt-Anchor" href="#不同情况的做法"></a> 不同情况的做法</h1>
<ol>
<li>
<p>获得更多的训练实例——解决高方差</p>
</li>
<li>
<p>尝试减少特征的数量——解决高方差</p>
</li>
<li>
<p>尝试获得更多的特征——解决高偏差</p>
</li>
<li>
<p>尝试增加多项式特征——解决高偏差</p>
</li>
<li>
<p>尝试减少正则化程度 λ——解决高偏差</p>
</li>
<li>
<p>尝试增加正则化程度 λ——解决高方差</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>13非监督学习</title>
    <url>/2020/06/30/13%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="pca"><a class="markdownIt-Anchor" href="#pca"></a> PCA</h1>
<h2 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h2>
<ol>
<li>数据表示，去线性相关</li>
<li>特征提取</li>
<li>降维去噪</li>
<li>进行可视化</li>
</ol>
<h2 id="协方差矩阵"><a class="markdownIt-Anchor" href="#协方差矩阵"></a> 协方差矩阵</h2>
<h2 id="推导"><a class="markdownIt-Anchor" href="#推导"></a> 推导</h2>
<h2 id="物理含义"><a class="markdownIt-Anchor" href="#物理含义"></a> 物理含义</h2>
<ol>
<li>大特征值对应长轴</li>
<li>小特征值对应短轴</li>
</ol>
<h1 id="lda-有监督"><a class="markdownIt-Anchor" href="#lda-有监督"></a> LDA-有监督</h1>
<ol>
<li>
<p>目标：找子空间，使数据在其中最好分</p>
</li>
<li>
<p>类内越聚集，类间距离越大，越好分</p>
</li>
<li>
<p>使用Fisher来评价</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>i</mi><mi>s</mi><mi>h</mi><mi>e</mi><mi>r</mi><mo>=</mo><mi>t</mi><mi>r</mi><mo stretchy="false">(</mo><msubsup><mi>S</mi><mi>w</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mi>S</mi><mi>b</mi></msub><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><msub><mi>S</mi><mi>w</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>k</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><msub><mi>C</mi><mi>i</mi></msub><mspace linebreak="newline"></mspace><msub><mi>S</mi><mi>b</mi></msub><mo>=</mo><msub><mi>C</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">Fisher=tr(S_w^{-1}S_b)\\
S_w = \frac{1}{k}\sum_{i=1}^kC_i\\
S_b = C_b
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.1137820000000005em;vertical-align:-1.277669em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8361130000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>所以目的变成了</p>
<p>原空间的点x,使用x=Ay变换后到新空间，他的Fisher最大，说明这个空间内最好分</p>
</li>
</ol>
<h1 id="nmf-非负矩阵分解"><a class="markdownIt-Anchor" href="#nmf-非负矩阵分解"></a> NMF 非负矩阵分解</h1>
<h2 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h2>
<ol>
<li>降维</li>
<li>特征提取</li>
<li>盲信号分离</li>
</ol>
<p>在空间中找两个基，使得基的射线能包含所有点</p>
<h1 id="ica-无监督"><a class="markdownIt-Anchor" href="#ica-无监督"></a> ICA-无监督</h1>
<h2 id="目的"><a class="markdownIt-Anchor" href="#目的"></a> 目的</h2>
<ol>
<li>
<p>找最不高斯的方向/最有结构的方向，将数据投影到这个方向上，然后在这个子空间上做聚类</p>
</li>
<li>
<p>取线性/非线性相关</p>
</li>
</ol>
<h1 id="考试"><a class="markdownIt-Anchor" href="#考试"></a> 考试</h1>
<p>线性代数</p>
<p>pdf，高斯分布，协方差矩阵，方差，给出主分量方向。LDA的方向，什么叫智力，什么是智能，什么叫机器，什么叫学习，治理怎么获得，智能怎么获得</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>11支撑向量机</title>
    <url>/2020/06/30/11%E6%94%AF%E6%92%91%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="优化目标"><a class="markdownIt-Anchor" href="#优化目标"></a> 优化目标</h1>
<h2 id="回顾逻辑回归"><a class="markdownIt-Anchor" href="#回顾逻辑回归"></a> 回顾逻辑回归</h2>
<h3 id="目标函数"><a class="markdownIt-Anchor" href="#目标函数"></a> 目标函数</h3>
<img src="D:\MyBlog\source\MyImages\image-20200524141502856.png" alt="image-20200524141502856" style="zoom: 50%;" />
<h3 id="代价函数"><a class="markdownIt-Anchor" href="#代价函数"></a> 代价函数</h3>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo>=</mo><mo>−</mo><mo stretchy="false">(</mo><mi>y</mi><mi>l</mi><mi>o</mi><mi>g</mi><msub><mi>h</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>y</mi><mo stretchy="false">)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mi>h</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mo>=</mo><mo>−</mo><mi>y</mi><mi>l</mi><mi>o</mi><mi>g</mi><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><msup><mi>θ</mi><mi>T</mi></msup><mi>x</mi></mrow></msup></mrow></mfrac><mo>−</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>y</mi><mo stretchy="false">)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><msup><mi>θ</mi><mi>T</mi></msup><mi>x</mi></mrow></msup></mrow></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Cost=-(ylogh_\theta (x)+(1-y)log(1-h_\theta(x)))\\
=-ylog\frac{1}{1+e^{-\theta^Tx}}-(1-y)log(1-\frac{1}{1+e^{-\theta^Tx}})
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.125635em;vertical-align:-0.804195em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.279135em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.830865em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7740928571428571em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.804195em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.125635em;vertical-align:-0.804195em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.279135em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.830865em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7740928571428571em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.804195em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p>
<img src="D:\MyBlog\source\MyImages\image-20200524143056765.png" alt="image-20200524143056765" style="zoom:50%;" />
<ul>
<li>其中$$z =\theta^Tx$$</li>
</ul>
<h2 id="从逻辑回归到支持向量机"><a class="markdownIt-Anchor" href="#从逻辑回归到支持向量机"></a> 从逻辑回归到支持向量机</h2>
<h3 id="代价函数-2"><a class="markdownIt-Anchor" href="#代价函数-2"></a> 代价函数</h3>
<ul>
<li>支持向量机的代价函数是上面两个粉线合在一起</li>
</ul>
<img src="D:\MyBlog\source\MyImages\image-20200524143754612.png" alt="image-20200524143754612" style="zoom: 67%;" />
<h3 id="支撑向量机的目标函数"><a class="markdownIt-Anchor" href="#支撑向量机的目标函数"></a> <strong>支撑向量机的目标函数</strong></h3>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>C</mi><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mo stretchy="false">[</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mi>c</mi><mi>o</mi><mi>s</mi><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msup><mi>θ</mi><mi>T</mi></msup><msup><mi>x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo><mi>c</mi><mi>o</mi><mi>s</mi><msub><mi>t</mi><mn>0</mn></msub><mo stretchy="false">(</mo><msup><mi>θ</mi><mi>T</mi></msup><msup><mi>x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msubsup><mi>θ</mi><mi>j</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">minC\sum_{i=1}^m[y^{(i)}cost_1(\theta^Tx^{(i)})+(1-y^{(i)})cost_0(\theta^Tx^{(i)})]+\frac{1}{2}\sum_{i=1}^n\theta_j^2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-2.4530000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li>其中C是一个常数</li>
</ul>
<h1 id="大边界的直观理解"><a class="markdownIt-Anchor" href="#大边界的直观理解"></a> 大边界的直观理解</h1>
<p><img src="D:\MyBlog\source\MyImages\image-20200524150614652.png" alt="image-20200524150614652" style="zoom: 50%;" /><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200524154426942.png" alt="image-20200524154426942" /><img src="D:\MyBlog\source\MyImages\image-20200524150614652.png" alt="image-20200524150614652" style="zoom: 50%;" /><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200524154426942.png" alt="image-20200524154426942" /></p>
<img src="D:\MyBlog\source\MyImages\image-20200524154433927.png" alt="image-20200524154433927" style="zoom:50%;" />
<ul>
<li>
<p>支撑向量机会选在黑线</p>
</li>
<li>
<p>两条蓝线之间的距离称为支持向量机的间距，**也是支持向量机具有鲁棒性/泛化能力强的原因。**也是因此支持向量机被称为大间距分类器</p>
</li>
<li>
<p>内积看作点在这直线上的投影长度，SVM的优化目标是令正负样本的投影点距离尽量远。</p>
</li>
<li>
<p><strong>在代价函数最小化的过程中，我们希望找出在y=1和y=0两种情况下都使得代价函数中左边的这一项尽量为零的参数。则最小化问题转换成了</strong></p>
<img src="D:\MyBlog\source\MyImages\image-20200524155248314.png" alt="image-20200524155248314"  />
</li>
<li>
<p>决策边界可能受到噪声的影响，<strong>当C不是非常大的时候，他可以忽略掉一些异常点的影响，得到更好的决策边界</strong>(C是正则化项)</p>
<ul>
<li>𝐶 较大时，相当于 𝜆 较小，可能会导致过拟合，高方差。</li>
<li>𝐶 较小时，相当于 𝜆 较大，可能会导致低拟合，高偏差。</li>
</ul>
</li>
</ul>
<h2 id="边界"><a class="markdownIt-Anchor" href="#边界"></a> 边界</h2>
<ul>
<li>边界定义为在到达数据点之前可以增加的宽度</li>
</ul>
<img src="D:\MyBlog\source\MyImages\image-20200524183922535.png" alt="image-20200524183922535" style="zoom:50%;" />
<ul>
<li>
<p>边界宽度</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>=</mo><mo stretchy="false">(</mo><msup><mi>x</mi><mo>+</mo></msup><mo>−</mo><msup><mi>x</mi><mo>−</mo></msup><mo stretchy="false">)</mo><mo separator="true">⋅</mo><mi>n</mi><mspace linebreak="newline"></mspace><mo>=</mo><mo stretchy="false">(</mo><msup><mi>x</mi><mo>+</mo></msup><mo>−</mo><msup><mi>x</mi><mo>−</mo></msup><mo stretchy="false">)</mo><mo separator="true">⋅</mo><mfrac><mi>w</mi><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>w</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><mspace linebreak="newline"></mspace><mo>=</mo><mfrac><mn>2</mn><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>w</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">M=(x^+-x^-)·n\\
=(x^+-x^-)·\frac{w}{||w||}\\
=\frac{2}{||w||}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.071331em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.071331em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.071331em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.0435600000000003em;vertical-align:-0.936em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.821331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">∣</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25744em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">∣</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<ul>
<li>
<p>目标是最大化M，即$$min\frac{1}{m}=min\frac{||w||^2}{2}$$</p>
<img src="D:\MyBlog\source\MyImages\image-20200524155248314.png" alt="image-20200524155248314"  />
</li>
<li>
<p><strong>这是一个凸约束情况下的凸优化问题，局部最优就是全局最优</strong></p>
</li>
</ul>
</li>
</ul>
<h1 id="核函数1"><a class="markdownIt-Anchor" href="#核函数1"></a> 核函数1</h1>
<img src="D:\MyBlog\source\MyImages\image-20200605094732882.png" alt="image-20200605094732882" style="zoom:67%;" />
<ul>
<li>三维图中，水平面坐标是x1,x2，垂直坐标轴代表f。可以看出，只有当x与l<sup>(1)</sup>重合时f才具有最大值。</li>
</ul>
<img src="D:\MyBlog\source\MyImages\image-20200605095338386.png" alt="image-20200605095338386" style="zoom:67%;" />
<ul>
<li>红色的点离l1较近，离l2,l3较远，因此f1接近1，f2,f3接近0。因此$$h=\theta_0+\theta_1f_1+\theta_2f_2+\theta_3f_3&gt;0$$，因此预测值为1</li>
<li>同理可得对于绿色的点，预测y=1</li>
<li>对于蓝色的点，因为离三个点都很远，所以y=0</li>
<li>于是就得到了分类边界(红色的线)</li>
</ul>
<h1 id="核函数2"><a class="markdownIt-Anchor" href="#核函数2"></a> 核函数2</h1>
<h2 id="如何选择地标"><a class="markdownIt-Anchor" href="#如何选择地标"></a> 如何选择地标</h2>
<ul>
<li>通常根据训练集的数量选择，m个实例选择m个地标</li>
<li>这样做的好处是，现在我们得到的新特征是建立在原有特征与训练集中所有其他特征之间距离的基础之上的</li>
</ul>
<h2 id="将核函数用于svm"><a class="markdownIt-Anchor" href="#将核函数用于svm"></a> 将核函数用于SVM</h2>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200605101608595.png" alt="image-20200605101608595" /></p>
<h3 id="修改svm假设为"><a class="markdownIt-Anchor" href="#修改svm假设为"></a> 修改SVM假设为</h3>
<p>给定𝑥，计算新特征𝑓，当$$𝜃^𝑇𝑓 &gt;= 0$$ 时，预测 𝑦 = 1，否则反之。</p>
<h3 id="修改代价函数为sum_j1nmtheta_j2thetattheta"><a class="markdownIt-Anchor" href="#修改代价函数为sum_j1nmtheta_j2thetattheta"></a> 修改代价函数为$$\sum_{j=1}<sup>{n=m}\theta_j</sup>2=\theta^T\theta$$</h3>
<p>则目标是</p>
<img src="D:\MyBlog\source\MyImages\image-20200605101818341.png" alt="image-20200605101818341" style="zoom: 67%;" />
<h2 id="svm的两个参数c和sigma"><a class="markdownIt-Anchor" href="#svm的两个参数c和sigma"></a> SVM的两个参数C和$$\sigma$$</h2>
<p>𝐶 = 1/𝜆</p>
<p>𝐶 较大时，相当于𝜆较小，可能会导致过拟合，高方差；</p>
<p>𝐶 较小时，相当于𝜆较大，可能会导致低拟合，高偏差；</p>
<p>𝜎较大时，可能会导致低方差，高偏差；</p>
<p>𝜎较小时，可能会导致低偏差，高方差。</p>
<h1 id="何时使用svm"><a class="markdownIt-Anchor" href="#何时使用svm"></a> 何时使用SVM</h1>
<p>n为特征数，m为训练样本数</p>
<p>(1)如果相较于𝑚而言，𝑛要大许多，即训练集数据量不够支持我们训练一个复杂的非线</p>
<p>性模型，我们选用逻辑回归模型或者不带核函数的支持向量机。（高维空间中的稀疏点）</p>
<p>(2)如果𝑛较小，而且𝑚大小中等，例如𝑛在 1-1000 之间，而𝑚在 10-10000 之间，使用高</p>
<p>斯核函数的支持向量机。</p>
<p>(3)如果𝑛较小，而𝑚较大，例如𝑛在 1-1000 之间，而𝑚大于 50000，则使用支持向量机会</p>
<p>非常慢，解决方案是创造、增加更多的特征，然后使用逻辑回归或不带核函数的支持向量机。</p>
<h1 id="非线性可分问题"><a class="markdownIt-Anchor" href="#非线性可分问题"></a> 非线性可分问题</h1>
<ul>
<li>引入松弛变量</li>
<li>引入核函数，因为可能在高维空间中线性可分</li>
</ul>
<h2 id="目标函数-2"><a class="markdownIt-Anchor" href="#目标函数-2"></a> 目标函数</h2>
<ul>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>w</mi></msub><mfrac><mn>1</mn><mn>2</mn></mfrac><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>w</mi><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>+</mo><mi>C</mi><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>ζ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">min_w\frac{1}{2}||w||^2+C\sum_{i=1}^n\zeta_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07378em;">ζ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07378em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>在$$y_i(w^Tx_i+b)\geq1-\zeta_i$$的条件下</li>
<li>多少个样本多少个约束</li>
</ul>
<h1 id="线代复习"><a class="markdownIt-Anchor" href="#线代复习"></a> 线代复习</h1>
<h2 id="维"><a class="markdownIt-Anchor" href="#维"></a> 维</h2>
<ul>
<li>是基中向量的个数（基是不唯一的）</li>
</ul>
<h2 id="内积"><a class="markdownIt-Anchor" href="#内积"></a> 内积</h2>
<ul>
<li>只要运算是封闭的，就可以进行内积</li>
</ul>
<h2 id="内积与相关"><a class="markdownIt-Anchor" href="#内积与相关"></a> 内积与相关</h2>
<ul>
<li>
<p>什么是正定矩阵</p>
</li>
<li>
<p>相关系数：$$p_{xy} = \frac{E_{xy}}{\sqrt{Ex<sup>2Ey</sup>2}}=\frac{E(x,y)}{\sigma_1\sigma_2}$$</p>
<p><img src="D:%5CMyBlog%5Csource%5CMyImages%5Cimage-20200605113758799.png" alt="image-20200605113758799" /></p>
</li>
</ul>
<img src="D:\MyBlog\source\MyImages\image-20200605122941604.png" alt="image-20200605122941604" style="zoom: 33%;" />
<h2 id="相关和独立"><a class="markdownIt-Anchor" href="#相关和独立"></a> 相关和独立</h2>
<ul>
<li>独立 p(x,y) = p(x)p(y),变量x和y妹有关系</li>
<li>不相关指非线性相关，不一定是独立；但是独立一定不相关</li>
</ul>
<h2 id="svm求解考么"><a class="markdownIt-Anchor" href="#svm求解考么"></a> SVM求解考么？</h2>
<h1 id="svm总结"><a class="markdownIt-Anchor" href="#svm总结"></a> SVM总结</h1>
<ul>
<li>SVM的创新之一在于将分类面的求解看作是一个二次规划问题</li>
<li>SVM的创新之二在于揭示了对分类起关键作用的只是一部分训练样本，即支持向量</li>
</ul>
<h2 id="svm特点"><a class="markdownIt-Anchor" href="#svm特点"></a> SVM特点</h2>
<img src="D:\MyBlog\source\MyImages\image-20200605130529781.png" alt="image-20200605130529781" style="zoom:50%;" />
<h2 id="不足"><a class="markdownIt-Anchor" href="#不足"></a> 不足</h2>
<img src="D:\MyBlog\source\MyImages\image-20200605130551836.png" alt="image-20200605130551836" style="zoom: 50%;" />
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>12聚类</title>
    <url>/2020/06/30/12%E8%81%9A%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="聚类"><a class="markdownIt-Anchor" href="#聚类"></a> 聚类</h1>
<p><img src="/MyImages/image-20200609095208784.png" alt="image-20200609095208784" /></p>
<ol>
<li>K-Means的隐含了i)的假设，数据是高斯分布，并且每组数据的协方差矩阵都是相同的对角阵</li>
<li>改进后为EM算法</li>
</ol>
<h2 id="距离相似度"><a class="markdownIt-Anchor" href="#距离相似度"></a> 距离/相似度</h2>
<ol>
<li>欧式距离</li>
<li>闵氏距离</li>
<li>马氏距离</li>
<li>相关系数(线性关系)</li>
<li>互相关(非线性关系)</li>
<li>MIC</li>
</ol>
<p><img src="/MyImages/image-20200628210004533.png" alt="image-20200628210004533" /></p>
<ol>
<li>随着p的增大吗，图像逐渐内陷</li>
<li>距离越大，pdf越小</li>
</ol>
<h2 id="相关"><a class="markdownIt-Anchor" href="#相关"></a> 相关</h2>
<p><img src="/MyImages/image-20200609100752269.png" alt="image-20200609100752269" /></p>
<ol>
<li>相关系数关心的是角度上的差别而不是幅度上的差别，相关系数越大，夹角越小</li>
</ol>
<h1 id="pca"><a class="markdownIt-Anchor" href="#pca"></a> PCA</h1>
<ol>
<li>用处
<ol>
<li>数据表示</li>
<li>去数据中 的线性相关，从而提取特征</li>
<li>降维，进行数据压缩</li>
</ol>
</li>
</ol>
<img src="/MyImages/image-20200609104123165.png" alt="image-20200609104123165" style="zoom:50%;" />
<h1 id="nmf"><a class="markdownIt-Anchor" href="#nmf"></a> NMF</h1>
<p>用于盲信号分离</p>
<h1 id="ica"><a class="markdownIt-Anchor" href="#ica"></a> ICA</h1>
<ul>
<li>找最不高斯的方向</li>
<li></li>
</ul>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>2单变量线性回归</title>
    <url>/2020/06/30/2%E5%8D%95%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h1 id="模型表示"><a class="markdownIt-Anchor" href="#模型表示"></a> 模型表示</h1>
<h2 id="线性回归"><a class="markdownIt-Anchor" href="#线性回归"></a> 线性回归</h2>
<ol>
<li><strong>回归问题属于监督学习</strong>，是因为对于每个数据来说，我们给出了“正确的答案。</li>
<li><strong>回归</strong> 根据之前的数据预测出一个准确的输出值</li>
<li>假设我们定义h(x) = θ<sub>0</sub>+θ<sub>1</sub>x</li>
</ol>
<p><img src="/MyImages/9-1593521578763.png" alt="" /></p>
<h2 id="代价函数"><a class="markdownIt-Anchor" href="#代价函数"></a> 代价函数</h2>
<ol>
<li>
<p>问题是如何选择θ<sub>i</sub></p>
</li>
<li>
<p><strong>建模误差</strong> 我们选择的参数决定了我们得到的直线相对于我们的训练集的准确程度，模型所预测的值与训练集中实际值之间的差距（下图中蓝线所指）就是<strong>建模误差</strong>（<strong>modeling error</strong>）</p>
<p><img src="/MyImages/1-1593521580694.png" alt="" /></p>
</li>
</ol>
<h3 id="代价函数定义"><a class="markdownIt-Anchor" href="#代价函数定义"></a> 代价函数定义</h3>
<p><img src="/MyImages/2-1593521583045.png" alt="" /></p>
<p><strong>化成等高线图</strong>，三个坐标分别是θ<sub>0</sub>,θ<sub>1</sub> J(θ<sub>0</sub>,θ<sub>1</sub>)</p>
<p><img src="/MyImages/3-1593521584866.png" alt="" /></p>
<h2 id="代价函数的直观理解-i"><a class="markdownIt-Anchor" href="#代价函数的直观理解-i"></a> 代价函数的直观理解 I</h2>
<p><img src="/MyImages/4-1593521585777.png" alt="" /></p>
<ol>
<li>这是简化的代价函数</li>
<li>根据不同的θ值，可以得到不同的J，即可画出右侧的图</li>
</ol>
<h2 id="代价函数的直观理解-ii"><a class="markdownIt-Anchor" href="#代价函数的直观理解-ii"></a> 代价函数的直观理解 II</h2>
<p>通过这些图形，我希望你能更好地理解这些代价函数𝐽所表达的值是什么样的，它们对应的假设是什么样的，以及什么样的假设对应的点，更接近于代价函数𝐽的最小值</p>
<h1 id="梯度下降"><a class="markdownIt-Anchor" href="#梯度下降"></a> 梯度下降</h1>
<ol>
<li>是一种用来<strong>求函数最小值</strong>的算法</li>
</ol>
<h2 id="思想"><a class="markdownIt-Anchor" href="#思想"></a> 思想</h2>
<ol>
<li>开始时我们随机选择一个参数的组合(𝜃0, 𝜃1, . . . . . . , 𝜃𝑛)，计算代价函数，然后我们寻找下一个能让代价函数值下降最多的参数组合。</li>
<li>持续这样做直到得到一个<strong>局部最小值</strong>(因为我们并没有尝试完所有的参数组合，所以不能确定我们得到的局部最小值是否便是全局最小值（<strong>global minimum</strong>），选择不同的初始参数组合，可能会找到不同的局部最小值)</li>
</ol>
<h2 id="梯度下降-2"><a class="markdownIt-Anchor" href="#梯度下降-2"></a> 梯度下降</h2>
<p><img src="/MyImages/5-1593521588740.png" alt="" /></p>
<ol>
<li>
<p>其中<strong>α是学习率</strong>它决定了我们沿着能让代价函数下降程度最大的方向向下迈出的步子有多大</p>
</li>
<li>
<p><strong>注意</strong> 更新要同时进行</p>
<p><img src="/MyImages/6-1593521589904.png" alt="" /></p>
</li>
</ol>
<h1 id="梯度下降的直观理解"><a class="markdownIt-Anchor" href="#梯度下降的直观理解"></a> 梯度下降的直观理解</h1>
<h2 id="对求导的理解"><a class="markdownIt-Anchor" href="#对求导的理解"></a> 对求导的理解</h2>
<p><img src="/MyImages/7-1593521591534.png" alt="" /></p>
<ol>
<li>求导的目的，基本上可以说取<strong>这个红点的切线</strong>，就是这样一条红色的直线，刚好与函数相切于这一点，让我们看看这条红色直线的斜率，就是这条刚好与函数曲线 相切的这条直线，<strong>这条直线的斜率正好是这个三角形的高度除以这个水平长度</strong></li>
</ol>
<h2 id="α的影响"><a class="markdownIt-Anchor" href="#α的影响"></a> α的影响</h2>
<ol>
<li>如果𝑎太大，那么梯度下降法可能会越过最低点，甚至可能无法收敛，下一次迭代又移动了一大步，越过一次，又越过一次，一次次越过最低点，直到你发现实际上离最低点越来越远，所以，如果𝑎太大，它会导致无法收敛，甚至发散</li>
<li>如果𝑎太小了，即我的学习速率太小，结果就是只能这样像小宝宝一样一点点地挪动， 去努力接近最低点，这样就需要很多步才能到达最低点，所以如果𝑎太小的话，可能会很慢，因为它会一点点挪动，它会需要很多步才能到达全局最低点</li>
</ol>
<h3 id="α是定值即可"><a class="markdownIt-Anchor" href="#α是定值即可"></a> α是定值即可</h3>
<p>因为一直在朝着最低点走，导数项总是成下降趋势，所以θ更新的幅度也会更小。所以随着梯</p>
<p>度下降法的运行，你移动的幅度会自动变得越来越小，直到最终移动幅度非常小，你会发现，已经收敛到局部极小值。所以实际上没有必要再另外减小𝑎。</p>
<h1 id="梯度下降的线性回归"><a class="markdownIt-Anchor" href="#梯度下降的线性回归"></a> 梯度下降的线性回归</h1>
<p><img src="/MyImages/8-1593521593488.png" alt="" /></p>
<ol>
<li>即<strong>批量梯度下降</strong>，指的是在梯度下降的每一步中，我们都用到了所有的训练样本，在梯度下降中，在计算微分求导项时，我们需要进行求和运算，所以，在每一个单独的梯度下降中，我们最终都要计算这样一个东西，这个项需要对所有𝑚个训练样本求和。</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>4多维特征</title>
    <url>/2020/06/30/4%E5%A4%9A%E7%BB%B4%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h1 id="多维特征"><a class="markdownIt-Anchor" href="#多维特征"></a> 多维特征</h1>
<ol>
<li><strong>多变量的假设</strong>h为</li>
</ol>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>θ</mi><mn>0</mn></msub><mo>+</mo><msub><mi>θ</mi><mn>1</mn></msub><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>θ</mi><mn>2</mn></msub><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><msub><mi>θ</mi><mn>3</mn></msub><msub><mi>x</mi><mn>3</mn></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msub><mi>θ</mi><mi>n</mi></msub><msub><mi>x</mi><mi>n</mi></msub><mo>=</mo><msup><mi>θ</mi><mi>T</mi></msup><mi>x</mi></mrow><annotation encoding="application/x-tex">h_θ(x) = θ_0+θ_1x_1+θ_2x_2+θ_3x_3+...+θ_nx_n= θ^Tx
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8913309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault">x</span></span></span></span></span></p>
<h2 id="多变量梯度下降"><a class="markdownIt-Anchor" href="#多变量梯度下降"></a> 多变量梯度下降</h2>
<ol>
<li>
<p>代价函数是所有建模误差的平方和</p>
<p><img src="/MyImages/10-1593521617832.png" alt="" /></p>
</li>
<li>
<p>如果去掉平方，正负抵消，会导致目标出错。</p>
</li>
<li>
<p>如果把平方换成绝对值，但绝对值不可导</p>
</li>
<li>
<p>除二，是为了求导之后抵消掉平方的导数</p>
</li>
</ol>
<h2 id="多变量线性回归的批量梯度下降"><a class="markdownIt-Anchor" href="#多变量线性回归的批量梯度下降"></a> 多变量线性回归的批量梯度下降</h2>
<p><img src="/MyImages/11-1593521619163.png" alt="" /></p>
<p><img src="/MyImages/12-1593521621252.png" alt="" /></p>
<h1 id="梯度下降法实践-1-特征缩放"><a class="markdownIt-Anchor" href="#梯度下降法实践-1-特征缩放"></a> 梯度下降法实践 1-特征缩放</h1>
<ol>
<li>
<p>有时候，要保证这些特征具有相近的尺度，这<strong>将帮助梯度下降算法更快的收敛</strong></p>
<p><img src="/MyImages/17-1593521623434.png" alt="" /></p>
<ol>
<li>以房价问题为例，假设用两个特征，房屋的尺寸和房屋的数量的参数为何总坐标，绘制代价函数的等高线图。</li>
<li>由于房屋的尺寸和房屋的数量的值域范围差距较大，所以图像显得很扁，<strong>梯度下降算法要非常多次的迭代才能收敛</strong></li>
</ol>
</li>
<li>
<p>最简单的方法是令</p>
<p><img src="/MyImages/13-1593521625581.png" alt="" /></p>
<ol>
<li>问题在于均值受离群点影响很大</li>
</ol>
</li>
</ol>
<h1 id="梯度下降法实践-2-学习率"><a class="markdownIt-Anchor" href="#梯度下降法实践-2-学习率"></a> 梯度下降法实践 2-学习率</h1>
<h2 id="观察收敛"><a class="markdownIt-Anchor" href="#观察收敛"></a> 观察收敛</h2>
<ol>
<li>
<p>可以绘制迭代次数和代价函数的图来观测算法在何时趋于收敛</p>
<p><img src="/MyImages/16-1593521626880.png" alt="" /></p>
</li>
<li>
<p>也可以将代价函数的变化值与某个阀值,自动检测收敛</p>
</li>
</ol>
<h2 id="学习率的影响"><a class="markdownIt-Anchor" href="#学习率的影响"></a> 学习率的影响</h2>
<ol>
<li>如果学习率𝑎过小，则达到收敛所需的迭代次数会非常高；</li>
<li>如果学习率𝑎过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。</li>
</ol>
<h1 id="特征和多项式回归"><a class="markdownIt-Anchor" href="#特征和多项式回归"></a> 特征和多项式回归</h1>
<ol>
<li>有时线性回归并不适用于所有数据，有时需要用曲线。</li>
<li>具体的选择需要观察数据后再决定</li>
<li>可以令x = x<sup>2</sup>或x = x<sup>3</sup>将模型转为线性回归的</li>
<li>同样的，也可以令低次变成高次</li>
</ol>
<h1 id="正规方程"><a class="markdownIt-Anchor" href="#正规方程"></a> 正规方程</h1>
<ol>
<li>对于某些问题，正规方程比梯度下降法更好</li>
<li>现在已知$$xθ=y$$ 看作一个方程组，m个方程(m个样本)，n+1个位置数(n+1个θ)，假设所有方程独立
<ul>
<li>m&gt;n+1 <strong>无解</strong></li>
<li>m=n+1 θ=x<sup>-1</sup>y <strong>有唯一解</strong></li>
<li>m&lt;n+1 <strong>无穷解</strong></li>
</ul>
</li>
</ol>
<h2 id="求解"><a class="markdownIt-Anchor" href="#求解"></a> 求解</h2>
<ol>
<li>
<p>正规方程是通过求解</p>
<p><img src="/MyImages/14-1593521629310.png" alt="" />来找出使得代价函数最小的参数</p>
</li>
<li>
<p>设训练集矩阵为X，并且训练结果为向量y，则利用正规方程解出向量$$θ=(X<sup>TX)</sup>{-1}X^Ty$$</p>
</li>
<li>
<p><strong>注意 对于不可逆的矩阵(通常是因为特征之间不独立，如包含英尺为单位的尺寸，同时包含米为单位的尺寸）正规方程是不可用的</strong></p>
</li>
</ol>
<h2 id="梯度下降-正规方程"><a class="markdownIt-Anchor" href="#梯度下降-正规方程"></a> 梯度下降 &amp; 正规方程</h2>
<p><img src="/MyImages/15-1593521630662.png" alt="" /></p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<ol>
<li>对于特征数量小于一万的，通常使用标准方程法</li>
<li>对于复杂的学习算法，可能不得不使用梯度下降法。可以用在有大量特征变量的线性回归问题中。</li>
</ol>
<h2 id="推导θ"><a class="markdownIt-Anchor" href="#推导θ"></a> 推导θ</h2>
<p><img src="/MyImages/57.png" alt="" /></p>
<p><img src="/MyImages/58.png" alt="" /></p>
<h2 id="最小二乘解"><a class="markdownIt-Anchor" href="#最小二乘解"></a> 最小二乘解</h2>
<ol>
<li>用于提高精度</li>
<li>解比每个测量的精度都高</li>
</ol>
<h1 id="正规方程及其不可逆性"><a class="markdownIt-Anchor" href="#正规方程及其不可逆性"></a> 正规方程及其不可逆性</h1>
<p>问题：如果$$X^TX$$不可逆怎么办</p>
<ol>
<li><strong>首先，看特征值里是否有一些多余的特征</strong>，像这些x1和x2是线性相关的，称为线性函数。同时，当有一些多余的特征时，可以删除这两个重复特征中的一个。</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>6逻辑回归</title>
    <url>/2020/06/30/6%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h1 id="分类问题"><a class="markdownIt-Anchor" href="#分类问题"></a> 分类问题</h1>
<h2 id="逻辑回归"><a class="markdownIt-Anchor" href="#逻辑回归"></a> 逻辑回归</h2>
<ol>
<li><strong>逻辑回归是分类算法</strong></li>
<li>如果要预测的变量y是离散的值，那么我们将使用逻辑回归。逻辑回归的结果永远在0到1之间</li>
<li>因为如果使用线性回归，那么假设函数的输出值可能远大于1，或者远小于0。</li>
</ol>
<h2 id="感知器-逻辑回归"><a class="markdownIt-Anchor" href="#感知器-逻辑回归"></a> 感知器 &amp; 逻辑回归</h2>
<ul>
<li>激活函数不同</li>
<li>损失函数不同</li>
<li>感知器的解和起始点有关(非凸的，可能有很多解，但是对于线性可分问题，都是解)，但是逻辑回归只有唯一解</li>
</ul>
<h1 id="假说表示"><a class="markdownIt-Anchor" href="#假说表示"></a> 假说表示</h1>
<ol>
<li>
<p>其假说为$$h_θ(x)=g(θ^TX)$$ ，其中</p>
<ul>
<li>
<p>X代表特征向量</p>
</li>
<li>
<p>g代表逻辑函数</p>
<ul>
<li>
<p>一个常用的逻辑函数sigmoid</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>z</mi></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">g(z) = \frac {1}{1+e^{-z}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.697331em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<img src="/MyImages/image-20200405131921296.png" alt="image-20200405131921296" style="zoom: 50%;" />
</li>
</ul>
</li>
<li>
<p><strong>$$h_θ(x)$$表示对于给定的输入变量，根据选择的参数计算输出变量=1的可能性，即$$h_θ(x)=P(y=1|x;θ)$$</strong></p>
</li>
</ul>
</li>
</ol>
<h1 id="判定边界"><a class="markdownIt-Anchor" href="#判定边界"></a> 判定边界</h1>
<h2 id="下决策边界"><a class="markdownIt-Anchor" href="#下决策边界"></a> 下决策边界</h2>
<p>由sigmoid函数的图像可知</p>
<ul>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mo>=</mo><msubsup><mi>θ</mi><mi>x</mi><mi>T</mi></msubsup><mo>&gt;</mo><mo>=</mo><mn>0</mn><mi mathvariant="normal">时</mi><mi mathvariant="normal">，</mi><mi>y</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">z=θ^T_x&gt;=0时，y=1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.138331em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
</li>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mo>=</mo><msubsup><mi>θ</mi><mi>x</mi><mi>T</mi></msubsup><mo>&lt;</mo><mn>0</mn><mi mathvariant="normal">时</mi><mi mathvariant="normal">，</mi><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">z=θ^T_x&lt;0时，y=0
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.138331em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p>
</li>
</ul>
<h3 id="举例"><a class="markdownIt-Anchor" href="#举例"></a> 举例</h3>
<ol>
<li>
<img src="/MyImages/image-20200405132017999.png" alt="image-20200405132017999" style="zoom:50%;" />
<p>假设参数θ是[-3 1 1] 则当$$-1+x_1+x_2&gt;=0时，即x_1+x2&gt;=3时，预测y=1，可以绘制直线x_1+x_2=3$$这条线，即为模型的分界线</p>
</li>
<li>
<img src="/MyImages/image-20200405132041615.png" alt="image-20200405132041615" style="zoom:50%;" />
<ul>
<li>这个需要用到二次方特征</li>
<li>设$$h_θ(x)=g(θ_0+θ_1x_1+θ_2x_2+θ_3x_1<sup>2+θ_4x_2</sup>2)$$</li>
<li>设θ是[-1 0 0 1 1],则判定边界恰好是圆心在原点且半径为1的圆形</li>
</ul>
</li>
</ol>
<h1 id="代价函数拟合问题"><a class="markdownIt-Anchor" href="#代价函数拟合问题"></a> 代价函数(拟合问题)</h1>
<ol>
<li>问题：如果沿用线性回归时使用的所有模型误差的平方和，那么当我们将h<sub>θ</sub>x带入时，会产生一个**非凹函数。**即代价函数有许多局部最小值，影响梯度下降算法的执行。</li>
</ol>
<h2 id="逻辑回归的代价函数"><a class="markdownIt-Anchor" href="#逻辑回归的代价函数"></a> 逻辑回归的代价函数</h2>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mi>C</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><msub><mi>h</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><msup><mi>x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo><mo separator="true">,</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">J(θ) = \frac{1}{m}\sum _{i=1}^m Cost(h_θ(x^{(i)}),y^{(i)})
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>其中</p>
<ol>
<li>
<p>h<sub>θ</sub>(x)与$$Cost(h_θ(x),y)$$之间的关系</p>
<img src="/MyImages/image-20200405132438997.png" alt="image-20200405132438997" style="zoom:50%;" />
<ol>
<li>
<p>可以看出</p>
<ul>
<li>当y=1时，随着h里1越远Cost值越大</li>
<li>当y=0时，随着h里0越远Cost值越大</li>
</ul>
</li>
<li>
<p>Cost可统一写成</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><msub><mi>h</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mi>y</mi><mo>×</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><msub><mi>h</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>y</mi><mo stretchy="false">)</mo><mo>×</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mi>h</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Cost(h_θ(x),y)=-y×log(h_θ(x))-(1-y)×log(1-h_θ(x))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord">−</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
</li>
<li>
<p>将上式带回J(θ)</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mo>−</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mo stretchy="false">[</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><msub><mi>h</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><msup><mi>x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msub><mi>h</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><msup><mi>x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">J(θ)=-\frac{1}{m}\sum _{i=1}^m[y^{(i)}log(h_θ(x^{(i)}))+(1-y^{(i)})log(1-h_θ(x^{(i)}))]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span><span class="params">(theta, X, y)</span>:</span></span><br><span class="line">     theta = np.matrix(theta)</span><br><span class="line">     X = np.matrix(X)</span><br><span class="line">     y = np.matrix(y)</span><br><span class="line">     first = np.multiply(-y, np.log(sigmoid(X* theta.T)))</span><br><span class="line">     second = np.multiply((<span class="number">1</span> - y), np.log(<span class="number">1</span> - sigmoid(X* theta.T)))</span><br><span class="line">     <span class="keyword">return</span> np.sum(first - second) / (len(X))</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="梯度下降"><a class="markdownIt-Anchor" href="#梯度下降"></a> 梯度下降</h2>
<img src="/MyImages/image-20200405132513958.png" alt="image-20200405132513958" style="zoom:50%;" />
<h3 id="证明该代价函数会给我们一个凸优化问题"><a class="markdownIt-Anchor" href="#证明该代价函数会给我们一个凸优化问题"></a> 证明：该代价函数会给我们一个凸优化问题</h3>
<img src="/MyImages/image-20200405132545281.png" alt="image-20200405132545281" style="zoom:50%;" />
<h3 id="其他最下化代价函数算法"><a class="markdownIt-Anchor" href="#其他最下化代价函数算法"></a> 其他最下化代价函数算法</h3>
<p><strong>共轭梯度</strong>（<strong>Conjugate Gradient</strong>），<strong>局部优化法</strong>(<strong>Broyden</strong> <strong>fletcher goldfarb shann,BFGS</strong>)和<strong>有限内存局部优化法</strong>(<strong>LBFGS</strong>) ，<strong>fminunc</strong></p>
<h1 id="简化的成本函数和梯度下降函数"><a class="markdownIt-Anchor" href="#简化的成本函数和梯度下降函数"></a> 简化的成本函数和梯度下降函数</h1>
<ol>
<li>
<p>我们假设的输出，实际上就是这个概率值$$p(y=1|x;θ)$$,就是关于x以θ为参数，y=1的概率</p>
</li>
<li>
<p>我们的梯度下降算法可以写成</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>θ</mi><mi>j</mi></msub><mo>:</mo><mo>=</mo><msub><mi>θ</mi><mi>j</mi></msub><mo>−</mo><mi>α</mi><mfrac><mn>1</mn><mi>m</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mo stretchy="false">(</mo><msub><mi>h</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><msup><mi>x</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo><mo>−</mo><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">)</mo><msubsup><mi>x</mi><mi>j</mi><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">θ_j:=θ_j-α\frac{1}{m}\sum _{i=1}^m(h_θ(x^{(i)})-y^{(i)})x_j^{(i)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.4577719999999998em;vertical-align:-0.412972em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<ol>
<li>这是与线性回归完全不同的方法，因为我们假设的定义发生了变化，尽管二者更新参数的规则看起来相同</li>
</ol>
</li>
<li>
<p>特征缩放同样适用于逻辑回归，可以加快收敛速度。特别适用于特征范围差距很大的情况下。</p>
</li>
</ol>
<h1 id="高级优化"><a class="markdownIt-Anchor" href="#高级优化"></a> 高级优化</h1>
<p>利用一些高级优化算法和一些高级优化概念，使通过梯度下降，进行逻辑回归的素大大提高。</p>
<ol>
<li>
<p>基础梯度下降</p>
<p>输出参数θ，计算J(θ)和J关于0,1…n的偏导数</p>
<p><img src="/MyImages/image-20200405132625410.png" alt="image-20200405132625410" /></p>
<ul>
<li>例如<strong>共轭梯度法</strong> <strong>BFGS</strong> (<strong>变尺度法</strong>) 和 <strong>L-BFGS</strong> (**限制变尺度法) **</li>
<li>优点：
<ul>
<li>不需要手动选择学习率α，所以对于这些算法的一种思路是，给出计算导数项和代价函数的方法，你可以认为算法有一个智能的内部循环(称为<strong>线性搜索</strong>(<strong>line search</strong>)算法)</li>
<li>通过线内搜索算法，可以自动尝试不同的学习率，并自动选择一个好的学习率，甚至可以为每次迭代选择不同的学习率</li>
</ul>
</li>
<li>缺点：
<ul>
<li>复杂</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="多类别分类一样多"><a class="markdownIt-Anchor" href="#多类别分类一样多"></a> 多类别分类：一样多</h1>
<p><img src="/MyImages/image-20200405132749428.png" alt="image-20200405132749428" style="zoom:50%;" /><img src="/MyImages/image-20200405132830037.png" alt="image-20200405132830037" /></p>
<h2 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想"></a> 基本思想</h2>
<ol>
<li>
<p>将一对多问题转换成多个二分类问题</p>
</li>
<li>
<p>创建一个新的“伪”训练集，将类型2和类型3都定义为负类。这样训练一个标准的逻辑回归分类器，就得到一个正边界。</p>
<p><img src="/MyImages/image-20200405132830037.png" alt="image-20200405132830037" /></p>
</li>
<li>
<p>最后得到k个分类机，记作$$h_θ^{(i)}=p(y=i|x;θ) 其中i=(1,2,3…k)$$</p>
</li>
<li>
<p>做预测时，将所有呋喃类器都运行一遍，对每一个输入变量，都选择最高可能性的输出变量。例如对于开头的三分类，我们要做的就是输入要预测的x，选择一个让$$h_θ^{(i)}(x)$$最大的i</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习目录</title>
    <url>/2020/06/30/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="2单变量线性回归"><a class="markdownIt-Anchor" href="#2单变量线性回归"></a> <a href="/2020/06/30/2%E5%8D%95%E5%8F%98%E9%87%8F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/">2单变量线性回归</a></h2>
<h2 id="4多维特征"><a class="markdownIt-Anchor" href="#4多维特征"></a> <a href="/2020/06/30/4%E5%A4%9A%E7%BB%B4%E7%89%B9%E5%BE%81/">4多维特征</a></h2>
<h2 id="6逻辑回归"><a class="markdownIt-Anchor" href="#6逻辑回归"></a> <a href="/2020/06/30/6%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/">6逻辑回归</a></h2>
<h2 id="8神经网络"><a class="markdownIt-Anchor" href="#8神经网络"></a> <a href="/2020/06/30/8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">8神经网络</a></h2>
<h2 id="9神经网络学习"><a class="markdownIt-Anchor" href="#9神经网络学习"></a> <a href="/2020/06/30/9%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/">9神经网络学习</a></h2>
<h2 id="10模型评估与选择"><a class="markdownIt-Anchor" href="#10模型评估与选择"></a> <a href="/2020/06/30/10%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/">10模型评估与选择</a></h2>
<h2 id="11支撑向量机"><a class="markdownIt-Anchor" href="#11支撑向量机"></a> <a href="/2020/06/30/11%E6%94%AF%E6%92%91%E5%90%91%E9%87%8F%E6%9C%BA/">11支撑向量机</a></h2>
<h2 id="12聚类"><a class="markdownIt-Anchor" href="#12聚类"></a> <a href="/2020/06/30/12%E8%81%9A%E7%B1%BB/">12聚类</a></h2>
<h2 id="13非监督学习"><a class="markdownIt-Anchor" href="#13非监督学习"></a> <a href="/2020/06/30/13%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/">13非监督学习</a></h2>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>8神经网络</title>
    <url>/2020/06/30/8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="非线性假设"><a class="markdownIt-Anchor" href="#非线性假设"></a> 非线性假设</h1>
<ul>
<li>由于普通的线性回归和逻辑回归不能有效的处理高维特征，所以需要神经网络</li>
<li>假设初始有2500个特征，那么如果我们要进一步将两两特征组合构成一个多项式模型，则会有$$\frac{2500^2}{2}$$个特征。</li>
</ul>
<h1 id="模型表示1"><a class="markdownIt-Anchor" href="#模型表示1"></a> 模型表示1</h1>
<h2 id="大脑中的神经网络"><a class="markdownIt-Anchor" href="#大脑中的神经网络"></a> 大脑中的神经网络</h2>
<ul>
<li>
<p>每一个神经元都可以被认为是一个处理单元/神经核（<strong>processing unit</strong>/<strong>Nucleus</strong>），它含有许多输入/树突</p>
<p>（<strong>input</strong>/<strong>Dendrite</strong>），并且有一个输出/轴突（<strong>output</strong>/<strong>Axon</strong>）。神经网络是大量神经元相互链接并通过电脉冲来交流的一个网络。</p>
</li>
</ul>
<h2 id="神经网络模型"><a class="markdownIt-Anchor" href="#神经网络模型"></a> 神经网络模型</h2>
<img src="/MyImages/image-20200406172330534.png" alt="image-20200406172330534" style="zoom:50%;" />
<ul>
<li>神经网络模型建立在很多神经元之上，每一个神经元又是一个个学习模型。这些神经元（也叫激活单元，<strong>activation unit</strong>）采纳一些特征作为输出，并且根据本身的模型提供一个输出。在神经网络中，参数又可被成为权重（<strong>weight</strong>）。</li>
</ul>
<h3 id="结构"><a class="markdownIt-Anchor" href="#结构"></a> 结构</h3>
<p><img src="/MyImages/image-20200406172647607.png" alt="image-20200406172647607" /></p>
<ul>
<li>三层分别为输入层，中间层，输出层</li>
</ul>
<h3 id="描述"><a class="markdownIt-Anchor" href="#描述"></a> 描述</h3>
<ul>
<li>
<p>可以使用权重矩阵：</p>
<p>例如𝜃(1)代表从第一层映射到第二层的权重的矩阵。其尺寸为：以第 𝑗 + 1层的激活单元数量为行数，以第 𝑗 层的激活单元数加一为列数的矩阵。例如：上图所示的神经网络中𝜃(1)的尺寸为 3*4。</p>
</li>
<li>
<p>对于上图所示的模型，激活单元和输出分别表达为：</p>
<img src="/MyImages/image-20200406173612603.png" alt="image-20200406173612603" style="zoom: 67%;" />
</li>
</ul>
<h3 id="前向传播算法"><a class="markdownIt-Anchor" href="#前向传播算法"></a> 前向传播算法</h3>
<p>每一个𝑎都是由上一层所有的𝑥和每一个𝑥所对应的权重决定的，我们把这样从左到右的算法称为前向传播算法( <strong>FORWARD PROPAGATION</strong> )。</p>
<h1 id="模型表示2"><a class="markdownIt-Anchor" href="#模型表示2"></a> 模型表示2</h1>
<ul>
<li>
<p>计算第二层</p>
<img src="/MyImages/image-20200406175334847.png" alt="image-20200406175334847" style="zoom: 80%;" />
<p>令$$z^{(2)}=\theta <sup>{(1)}x，则a</sup>{(2)}=g(z^{(2)})$$</p>
</li>
<li>
<p>添加$$a_0^{(2)}=0$$ 计算第三层</p>
<img src="/MyImages/image-20200406180531918.png" alt="image-20200406180531918" style="zoom: 67%;" />
<p>令$$z^{(3)}=\theta <sup>{(2)}a</sup>{(2)}，则h_{\theta}(x)=g(z^{(3)})$$</p>
</li>
<li>
<p>以上是针对训练集中一个训练实例进行的计算。现要对正个训练集进行计算，将训练集特征矩阵进行转置，使得同一个实例的特征在用一列中.</p>
<p>即令$$z<sup>{(2)}=\theta</sup>{(1)}×X^T$$</p>
<p>​		$$a<sup>{(2)}=g(z</sup>{(2)})$$</p>
</li>
</ul>
<h3 id="理解"><a class="markdownIt-Anchor" href="#理解"></a> 理解</h3>
<img src="/MyImages/image-20200406182621033.png" alt="image-20200406182621033" style="zoom:50%;" />
<ul>
<li>
<p>右半部分其实就是以𝑎0, 𝑎1, 𝑎2, 𝑎3, 按照 <strong>Logistic Regression</strong> 的方式输出ℎ𝜃(𝑥)：</p>
</li>
<li>
<p>其实神经网络就像是 <strong>logistic regression</strong>，只不过我们把 <strong>logistic regression</strong> 中的输入向量</p>
<p>[𝑥1 ∼ 𝑥3] 变成了中间层的$$[𝑎_1^{(2)} ∼ 𝑎_3^{(2)}]$$</p>
</li>
<li>
<p>可以把𝑎0, 𝑎1, 𝑎2, 𝑎3看成更为高级的特征值，也就是𝑥0, 𝑥1, 𝑥2, 𝑥3的进化体，并且它们是由 𝑥与决定的，因为是梯度下降的，所以𝑎是变化的.并且能更好的预测新数据</p>
</li>
</ul>
<h1 id="特征和直观理解1"><a class="markdownIt-Anchor" href="#特征和直观理解1"></a> 特征和直观理解1</h1>
<h3 id="逻辑回归-神经网络"><a class="markdownIt-Anchor" href="#逻辑回归-神经网络"></a> 逻辑回归 &amp; 神经网络</h3>
<ul>
<li>神经网络能够通过学习得出其自身的一系列特征；</li>
<li>在普通的逻辑回归中，我们被限制使用原始特征𝑥1, 𝑥2, . . . , 𝑥𝑛(或一些二项式来组合特征)</li>
</ul>
<h3 id="单层神经元"><a class="markdownIt-Anchor" href="#单层神经元"></a> 单层神经元</h3>
<img src="/MyImages/image-20200406190201011.png" alt="image-20200406190201011" style="zoom: 67%;" />
<ul>
<li>可以表示逻辑运算，比如与、或</li>
</ul>
<h4 id="and函数"><a class="markdownIt-Anchor" href="#and函数"></a> AND函数</h4>
<img src="/MyImages/image-20200406191740550.png" alt="image-20200406191740550" style="zoom:67%;" />
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mo>−</mo><mn>30</mn><mo>+</mo><mn>20</mn><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><mn>20</mn><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_\theta(x)=g(-30+20x_1+20x_2)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">−</span><span class="mord">3</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>其中g是sigmod函数</p>
<img src="/MyImages/image-20200406190435864.png" alt="image-20200406190435864" style="zoom:67%;" />
<h4 id="or函数"><a class="markdownIt-Anchor" href="#or函数"></a> OR函数</h4>
<img src="/MyImages/image-20200406191755997.png" alt="image-20200406191755997" style="zoom:67%;" />
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>θ</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mo>−</mo><mn>10</mn><mo>+</mo><mn>20</mn><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><mn>20</mn><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_\theta(x)=g(-10+20x_1+20x_2)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
<img src="/MyImages/image-20200406190700068.png" alt="image-20200406190700068" style="zoom:67%;" />
<h4 id="not函数"><a class="markdownIt-Anchor" href="#not函数"></a> NOT函数</h4>
<img src="/MyImages/image-20200406191000700.png" alt="image-20200406191000700" style="zoom:67%;" />
<h1 id="样本和直观理解ii"><a class="markdownIt-Anchor" href="#样本和直观理解ii"></a> 样本和直观理解II</h1>
<h2 id="实现一个xnor功能"><a class="markdownIt-Anchor" href="#实现一个xnor功能"></a> 实现一个XNOR功能</h2>
<p>XNOR = (x1 ANDx2) OR((NOT x1)AND(NOT x2))</p>
<ul>
<li>
<p>首先构造一个能表达(NOT x1)AND(NOT x2)部分的神经元：</p>
<img src="/MyImages/image-20200406191114110.png" alt="image-20200406191114110" style="zoom: 67%;" />
</li>
<li>
<p>然后将表示 <strong>AND</strong> 的神经元和表示(NOT x1)AND(NOT x2)的神经元以及表示 OR 的神经元进行组合：</p>
<img src="/MyImages/image-20200406191402311.png" alt="image-20200406191402311" style="zoom:67%;" />
</li>
</ul>
<h1 id="多类分类"><a class="markdownIt-Anchor" href="#多类分类"></a> 多类分类</h1>
<ul>
<li>
<p>输出层有多个值，但是对于分类问题，输出的列向量中只会有一个为1</p>
</li>
<li>
<p>不如要分类人、汽车、摩托车和卡车</p>
<img src="/MyImages/image-20200406203845358.png" alt="image-20200406203845358" style="zoom:67%;" />
<p>输出结果为四种可能情形之一：</p>
<img src="/MyImages/image-20200406203903526.png" alt="image-20200406203903526" style="zoom:67%;" /></li>
</ul>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>9神经网络学习</title>
    <url>/2020/06/30/9%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="代价函数"><a class="markdownIt-Anchor" href="#代价函数"></a> 代价函数</h1>
<img src="/MyImages/image-20200409111224222.png" alt="image-20200409111224222" style="zoom:67%;" />
<ul>
<li>
<p>对于每一行特征，都会给出K个预测，在K的预测中选择可能性最高的一个作为预测的分类</p>
</li>
<li>
<p>最后一项为正则化项。正则化的那一项只是排除了每一层𝜃0后，每一层的𝜃 矩阵的和。最里层的循环𝑗循环所有的行（由𝑠𝑙 +1 层的激活单元数决定），循环𝑖则循环所有的列，由该层（𝑠𝑙层）的激活单</p>
<p>元数所决定。即：ℎ𝜃(𝑥)与真实值之间的距离为每个样本-每个类输出的加和，对参数进行<strong>regularization</strong> 的 <strong>bias</strong> 项处理所有参数的平方和。</p>
</li>
</ul>
<h1 id="反向传播算法"><a class="markdownIt-Anchor" href="#反向传播算法"></a> 反向传播算法</h1>
<ul>
<li>目的是计算$$\frac{\alpha}{\alpha\theta_{ij}^{(l)}}J(\theta)$$</li>
<li>首先计算最后一层的误差，然后再一层一层反向求出各层的误差，知道导数第二层</li>
</ul>
<h2 id="举例"><a class="markdownIt-Anchor" href="#举例"></a> 举例</h2>
<ul>
<li>
<p>假设已知一个四层的神经网络，其中K=4,S<sub>L</sub>=4,L=4</p>
</li>
<li>
<p>前向传播得到</p>
<img src="/MyImages/image-20200409112541529.png" alt="image-20200409112541529" style="zoom:50%;" />
</li>
<li>
<p>然后反向传播计算误差</p>
<ul>
<li>
<p>计算最后一层的误差，𝛿(4) = 𝑎(4) − 𝑦</p>
</li>
<li>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 38: …) ∗ 𝑔′(𝑧(3)) $̲$其中

* 𝑔′(𝑧(3…'>𝛿(3) = (𝛩(3))^𝑇𝛿(4) ∗ 𝑔′(𝑧(3)) $$其中

* 𝑔′(𝑧(3)) = 𝑎(3) ∗ (1 − 𝑎(3))
* $$(𝜃(3))^𝑇𝛿(4)$$是权重导致的误差的和

</p>
</li>
<li>
<p>第一层是输入变量，不存在误差。假设𝜆 = 0，即我们不做任何正则化处理时有：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>α</mi><mrow><mi>α</mi><msubsup><mi>θ</mi><mrow><mi>i</mi><mi>j</mi></mrow><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup></mrow></mfrac><mi>J</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mi>a</mi><mi>j</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msubsup><msubsup><mi>δ</mi><mi>i</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">\frac{\alpha}{\alpha\theta_{ij}^{(i)}}J(\theta)=a_j^{(l)}\delta_i^{l+1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4553320000000003em;vertical-align:-1.347772em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.11em;"><span class="pstrut" style="height:3.0448em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231360000000004em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.2748em;"><span class="pstrut" style="height:3.0448em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.7218em;"><span class="pstrut" style="height:3.0448em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.347772em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.4577719999999998em;vertical-align:-0.412972em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231360000000004em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999998em;"><span style="top:-2.433005em;margin-left:-0.03785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.266995em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li>𝑙 代表目前所计算的是第几层。</li>
<li>𝑗 代表目前计算层中的激活单元的下标，也将是下一层的第𝑗个输入变量的下标。</li>
<li>𝑖 代表下一层中误差单元的下标，是受到权重矩阵中第𝑖行影响的下一层中的误差单元的下标</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="考虑正则化处理"><a class="markdownIt-Anchor" href="#考虑正则化处理"></a> 考虑正则化处理</h2>
<ul>
<li>
<p>如果我们考虑正则化处理，并且我们的训练集是一个特征矩阵而非向量。在上面的特殊情况中，我们需要计算每一层的误差单元来计算代价函数的偏导数。在更为一般的情况中，我们同样需要计算每一层的误差单元，但是我们需要为整个训练集计算误差单元，此时的误差单元也是一个矩阵，用$$Δ_{ij}^{(l)}$$来表示第l层的第i个激活单元收到第j个参数影响而导致的误差</p>
</li>
<li>
<p><img src="/MyImages/image-20200409115010301.png" alt="image-20200409115010301" /></p>
</li>
<li>
<p>求出$$Δ_{ij}^{(l)}$$后，计算代价函数的偏导数</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>D</mi><mrow><mi>i</mi><mi>j</mi></mrow><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>:</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><msub><mi mathvariant="normal">Δ</mi><mrow><mi>i</mi><msup><mi>j</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow></msub><mo>+</mo><mi>λ</mi><msubsup><mi>θ</mi><mrow><mi>i</mi><mi>j</mi></mrow><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msubsup><mi>i</mi><mi>f</mi><mi>k</mi><mi mathvariant="normal">≠</mi><mn>0</mn><mspace linebreak="newline"></mspace><msubsup><mi>D</mi><mrow><mi>i</mi><mi>j</mi></mrow><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>:</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><msub><mi mathvariant="normal">Δ</mi><mrow><mi>i</mi><msup><mi>j</mi><mrow><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo></mrow></msup></mrow></msub><mi>i</mi><mi>f</mi><mi>k</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">D_{ij}^{(l)}:\frac{1}{m}Δ_{ij^{(l)}}+\lambda\theta_{ij}^{(l)} if k \neq0\\
D_{ij}^{(l)}:\frac{1}{m}Δ_{ij^{(l)}}if k =0
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4577719999999998em;vertical-align:-0.412972em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231360000000004em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.4693750000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8220357142857143em;"><span style="top:-2.8220357142857138em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5357142857142856em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.366733em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.4577719999999998em;vertical-align:-0.412972em;"></span><span class="mord mathdefault">λ</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231360000000004em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.4577719999999998em;vertical-align:-0.412972em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em;"><span style="top:-2.4231360000000004em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span style="top:-3.2198em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.412972em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.4693750000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8220357142857143em;"><span style="top:-2.8220357142857138em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5357142857142856em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.366733em;"><span></span></span></span></span></span></span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p>
</li>
</ul>
<h1 id="杂记"><a class="markdownIt-Anchor" href="#杂记"></a> 杂记</h1>
<h2 id="静态系统-动态系统"><a class="markdownIt-Anchor" href="#静态系统-动态系统"></a> 静态系统 &amp; 动态系统</h2>
<ul>
<li>静态系统与历史状态无关，没有记忆能力</li>
<li>动态系统与历史状态有关，一个系统中只要有部分是动态的，那么整个系统就是动态的</li>
</ul>
<h2 id="反向传播"><a class="markdownIt-Anchor" href="#反向传播"></a> 反向传播</h2>
<ul>
<li>
<p>目标函数$$E_p(W)=\frac{1}{2}\sum_k(y_k-O_k<sup>M)</sup>2$$</p>
</li>
<li>
<p>更新权重<img src="/MyImages/image-20200424215640128.png" alt="image-20200424215640128" style="zoom: 50%;" /></p>
</li>
<li>
<p>求偏导<img src="/MyImages/image-20200424215706733.png" alt="image-20200424215706733" style="zoom: 50%;" /></p>
</li>
<li>
<p>误差对第k层第j个神经元的偏导</p>
<img src="/MyImages/image-20200424215855262.png" alt="image-20200424215855262" style="zoom: 50%;" />
</li>
</ul>
<h3 id="加速学习img-srcmyimagesimage-20200424224548636png-altimage-20200424224548636-stylezoom67"><a class="markdownIt-Anchor" href="#加速学习img-srcmyimagesimage-20200424224548636png-altimage-20200424224548636-stylezoom67"></a> 加速学习<img src="/MyImages/image-20200424224548636.png" alt="image-20200424224548636" style="zoom:67%;" /></h3>
<ul>
<li>第二项就好像加上一个惯性</li>
</ul>
<h3 id="顺序与批量梯度下降"><a class="markdownIt-Anchor" href="#顺序与批量梯度下降"></a> 顺序与批量梯度下降</h3>
<ul>
<li>顺序模型是指
<ul>
<li>计算速度更快</li>
<li>更适合大型数据集</li>
<li>使权值空间的搜索具有随机性</li>
<li>更不容易陷入到局部极小值</li>
<li>较难建立算法收敛的理论条件</li>
</ul>
</li>
</ul>
<h3 id="学习结束标志"><a class="markdownIt-Anchor" href="#学习结束标志"></a> 学习结束标志</h3>
<ul>
<li>梯度向量
<ul>
<li>当梯度向量的欧几里德范数达到一个足够小的梯度阈值时结束</li>
</ul>
</li>
<li>错误减少
<ul>
<li>如果两代之间的误差的减少量很小，那么可以停止学习</li>
</ul>
</li>
<li>泛化性能
<ul>
<li>当泛化性能到达顶点的时候结束</li>
</ul>
</li>
</ul>
<h3 id="隐藏神经元数目取决于"><a class="markdownIt-Anchor" href="#隐藏神经元数目取决于"></a> 隐藏神经元数目取决于</h3>
<ul>
<li>训练样本数量</li>
<li>输入输出神经元数量</li>
<li>噪声和数据质量</li>
<li>要学习的问题的复杂程度</li>
<li>激活函数的形式</li>
<li>学习算法</li>
</ul>
<p>隐藏神经元数太少，导致误差很大；隐藏神经元太多，会导致模型自由度大，参数多，学习慢，得到的模型也更可能出现过拟合</p>
<h3 id="学-习"><a class="markdownIt-Anchor" href="#学-习"></a> 学 &amp; 习</h3>
<ul>
<li>学：和别人学，是有监督的</li>
<li>习：是自己悟，是无监督的</li>
</ul>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>公交管理系统</title>
    <url>/2020/07/17/%E5%85%AC%E4%BA%A4%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="需求"><a class="markdownIt-Anchor" href="#需求"></a> 需求</h1>
<ol>
<li>要求能够录入司机的基本信息，如工号，姓名，性别等；</li>
<li>要求能够录入汽车基本信息，如车牌号，座位数等；</li>
<li>要求能够录入司机的违章信息；</li>
<li>要求能够查询车队下全体司机信息</li>
<li>要求能够查询某名司机在某个时间段内的违章记录</li>
<li>要求能够查询某个车队在某段时间内的违章统计信息，输出应该为一句话。</li>
</ol>
<h1 id="完整性要求"><a class="markdownIt-Anchor" href="#完整性要求"></a> 完整性要求</h1>
<ol>
<li>公交公司有若干个车队，每个车队有若干条线路</li>
<li>公交公司有若干辆汽车，每辆车属于下一条线路</li>
<li>每个车队有一名路队长，只负责管理工作，不开车</li>
<li>每条线路有若干名司机，其中有一个路队长</li>
<li>司机开车产生各种违章记录，硬包括司机，车辆，车队，线路，站点，时间，违章等</li>
</ol>
<h1 id="er-图"><a class="markdownIt-Anchor" href="#er-图"></a> ER 图</h1>
<p><img src="/MyImages/image-20200717115528168.png" alt="image-20200717115528168" /></p>
<h1 id="目前进程"><a class="markdownIt-Anchor" href="#目前进程"></a> 目前进程</h1>
<ol>
<li>所有表结构达到4NF</li>
<li>优化存储过程基本都在ref级别</li>
<li>前端使用JAVA GUI，后端使用JAVA+Mysql+原生JDBC</li>
</ol>
<h1 id="源代码"><a class="markdownIt-Anchor" href="#源代码"></a> <a href="https://github.com/Cccceb/BTF/tree/master/DataBaseHomeWork">源代码</a></h1>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第2章可行性研究</title>
    <url>/2020/07/28/%E7%AC%AC2%E7%AB%A0%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<h1 id="可行性研究的任务"><a class="markdownIt-Anchor" href="#可行性研究的任务"></a> 可行性研究的任务</h1>
<p><strong>目的是 用最小代价在尽可能短的时间内确定问题是否能够解决</strong></p>
<h2 id="三方面可行性"><a class="markdownIt-Anchor" href="#三方面可行性"></a> 三方面可行性</h2>
<h3 id="技术可行性"><a class="markdownIt-Anchor" href="#技术可行性"></a> 技术可行性</h3>
<h3 id="经济可行性"><a class="markdownIt-Anchor" href="#经济可行性"></a> 经济可行性</h3>
<h3 id="操作可行性"><a class="markdownIt-Anchor" href="#操作可行性"></a> 操作可行性</h3>
<p>系统的操作方式在这个用户组织内行的通吗</p>
<h1 id="可行性研究的过程"><a class="markdownIt-Anchor" href="#可行性研究的过程"></a> 可行性研究的过程</h1>
<h2 id="1复查系统的规模和目标"><a class="markdownIt-Anchor" href="#1复查系统的规模和目标"></a> 1.复查系统的规模和目标</h2>
<p>确保分析员要解决问题确实是要求他解决的问题</p>
<h2 id="2研究目前正在使用的系统"><a class="markdownIt-Anchor" href="#2研究目前正在使用的系统"></a> 2.研究目前正在使用的系统</h2>
<p>实地考察旧系统，找出旧系统的不足，为新系统的建立提供基础。</p>
<h2 id="3导出新系统的高层逻辑模型"><a class="markdownIt-Anchor" href="#3导出新系统的高层逻辑模型"></a> 3.导出新系统的高层逻辑模型</h2>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%5C%E5%9B%BE%E7%89%87%5C1.png" alt="" /></p>
<h2 id="4重新定义问题"><a class="markdownIt-Anchor" href="#4重新定义问题"></a> 4.重新定义问题</h2>
<p>逻辑模型事实上表达了分析员对新系统必须作什麽的看法。因此分析员应与用户一起再次复查问题定义，工程规模和目标。(<strong>数据流图</strong>和<strong>数据字典</strong>作为讨论的基础)</p>
<h2 id="5导出和评价供选择的解法"><a class="markdownIt-Anchor" href="#5导出和评价供选择的解法"></a> 5.导出和评价供选择的解法</h2>
<h2 id="6推荐行动方针"><a class="markdownIt-Anchor" href="#6推荐行动方针"></a> 6.推荐行动方针</h2>
<h2 id="7草拟开发计划"><a class="markdownIt-Anchor" href="#7草拟开发计划"></a> 7.草拟开发计划</h2>
<p>计划内容包括：</p>
<ol>
<li>工程进度表</li>
<li>开发人员及硬件需求情况表</li>
<li>开发工期</li>
</ol>
<h2 id="8书写文档提交审查"><a class="markdownIt-Anchor" href="#8书写文档提交审查"></a> 8.书写文档提交审查</h2>
<h1 id="数据流图"><a class="markdownIt-Anchor" href="#数据流图"></a> 数据流图</h1>
<p><strong>数据流图</strong>描绘系统的<strong>逻辑模型</strong>，图中没有物理元素，只是描绘<strong>信息在系统中流动和处理情况</strong>。该图<strong>只需考虑系统必须完成的基本逻辑功能</strong>，不需要考虑如何具体实现。</p>
<h2 id="符号"><a class="markdownIt-Anchor" href="#符号"></a> 符号</h2>
<ol>
<li>（*）号表示数据流之间是“与”的关系。</li>
<li>（+）号表示数据流之间是“或”的关系。</li>
<li>（⊕）号表示只能从中选一个（互斥关系）</li>
<li><strong>圆圈</strong> 代表<strong>加工</strong>。输入数据在此进行变换产生输出数据，其中要注明加工的名字。</li>
<li><strong>方框</strong> 代表<strong>数据输入的源点或数据输出的汇点</strong>。其中要注明源点或汇点的名字。</li>
<li><strong>箭头</strong> 代表<strong>数据流</strong>。被加工的数据与流向，箭头边应给出数据流名字，可用名词或名词性短语命名</li>
<li><strong>双线</strong> 代表<strong>数据存储文件</strong>。也必须加以命名，用名词或名词性短语命名。</li>
</ol>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%5C%E5%9B%BE%E7%89%87%5C3.png" alt="" /></p>
<h2 id="举例"><a class="markdownIt-Anchor" href="#举例"></a> 举例</h2>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%5C%E5%9B%BE%E7%89%87%5C2.png" alt="" /></p>
<h2 id="命名"><a class="markdownIt-Anchor" href="#命名"></a> 命名</h2>
<h3 id="为数据流命名"><a class="markdownIt-Anchor" href="#为数据流命名"></a> 为数据流命名</h3>
<ol>
<li>应代表整个数据流（或数据存贮）的内容，而不是仅仅反映它的某些成分</li>
<li>起名字时遇到了困难，则很可能是因为对数据流图分解不恰当造成，应该重新分解。</li>
</ol>
<h3 id="为处理命名"><a class="markdownIt-Anchor" href="#为处理命名"></a> 为处理命名</h3>
<ol>
<li>通常先为数据流命名，然后再为相关的处理命名</li>
<li>名字应该反映整个处理的功能，而不是它的一部分。</li>
<li>名字最好有一个<strong>具体</strong>的及物动词，加上一个具体的宾语组成</li>
<li>如果必须用两个动词才可能描述整个处理的功能，则把这个处理<strong>再分解</strong>成两个处理可能更恰当。</li>
<li>如果在为某个处理命名困难时，则很可能是发现了分解不当的迹象，应当<strong>重新分解</strong>。</li>
</ol>
<h2 id="用途"><a class="markdownIt-Anchor" href="#用途"></a> 用途</h2>
<p>数据流图的基本目的是利用它作为交流信息的工具，分析员把他对现有系统的认识或对目标系统的设想用数据流图描绘出来，供有关人员审查确认。</p>
<h2 id="分层数据流图"><a class="markdownIt-Anchor" href="#分层数据流图"></a> 分层数据流图</h2>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%5C%E5%9B%BE%E7%89%87%5C7.png" alt="" /></p>
<h2 id="家庭安全系统三层dfd"><a class="markdownIt-Anchor" href="#家庭安全系统三层dfd"></a> 家庭安全系统三层DFD</h2>
<h3 id="家庭安全系统的第1层-dfd"><a class="markdownIt-Anchor" href="#家庭安全系统的第1层-dfd"></a> 家庭安全系统的第1层 DFD</h3>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%5C%E5%9B%BE%E7%89%87%5C4.png" alt="" /></p>
<h3 id="家庭安全系统的第2层-dfd"><a class="markdownIt-Anchor" href="#家庭安全系统的第2层-dfd"></a> 家庭安全系统的第2层 DFD</h3>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%5C%E5%9B%BE%E7%89%87%5C5.png" alt="" /></p>
<h3 id="监控传感器过程细化的第3层-dfd"><a class="markdownIt-Anchor" href="#监控传感器过程细化的第3层-dfd"></a> 监控传感器过程细化的第3层 DFD</h3>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%5C%E5%9B%BE%E7%89%87%5C6.png" alt="" /></p>
<h1 id="数据字典"><a class="markdownIt-Anchor" href="#数据字典"></a> 数据字典</h1>
<ol>
<li>数据字典是关于<strong>数据的信息</strong>的集合，也就是对<strong>数据流图中包含的所有元素的定义</strong>的集合。</li>
<li><strong>数据流图和数据字典共同构成系统的逻辑模型</strong>，没有数据字典，数据流图不严格，反之，没有数据流图数据字典难发挥作用.</li>
</ol>
<h2 id="数据字典的内容"><a class="markdownIt-Anchor" href="#数据字典的内容"></a> 数据字典的内容</h2>
<blockquote>
<p>数据字典存储有关数据的来源、说明、与其他数据的关系、用途和格式等信息，它本身就是一个数据库，<strong>存储“关于数据项的数据”</strong></p>
</blockquote>
<p>数据字典由对下列四类元素的定义组成：</p>
<ol>
<li>数据流</li>
<li>数据流分量（即：数据元素）</li>
<li>数据存储</li>
<li>处理</li>
</ol>
<h3 id="对图形定义的内容"><a class="markdownIt-Anchor" href="#对图形定义的内容"></a> 对图形定义的内容</h3>
<ol>
<li>图形元素的名字：某一词条的名字，要求无二义性，为人们所公认；</li>
<li>别名或编号；</li>
<li>分类：加工，数据流，数据文件，数据元素，数据源，汇点等；</li>
<li>描述：功能，特点；</li>
<li>定义：该词条的组成，数据结构等；</li>
<li>位置：数据流的来源，去处，加工框的编号，输入输出；数据元素在那个数据结构中等。</li>
<li>其他：数据流的数据量，流通量；数据文件的存储方式，存取要求；数据加工的加工顺序，以及外部实体的数量等。</li>
</ol>
<h3 id="对数据结构的描述"><a class="markdownIt-Anchor" href="#对数据结构的描述"></a> 对数据结构的描述</h3>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%5C%E5%9B%BE%E7%89%87%5C8.png" alt="" /></p>
<h2 id="银行取款的数据流图和数据字典"><a class="markdownIt-Anchor" href="#银行取款的数据流图和数据字典"></a> 银行取款的数据流图和数据字典</h2>
<h3 id="数据流图-2"><a class="markdownIt-Anchor" href="#数据流图-2"></a> 数据流图</h3>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%5C%E5%9B%BE%E7%89%87%5C9.png" alt="" /></p>
<h3 id="数据字典-2"><a class="markdownIt-Anchor" href="#数据字典-2"></a> 数据字典</h3>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%5C%E5%9B%BE%E7%89%87%5C10.png" alt="" /></p>
<h1 id="成本效益分析"><a class="markdownIt-Anchor" href="#成本效益分析"></a> 成本/效益分析</h1>
<h2 id="成本估计"><a class="markdownIt-Anchor" href="#成本估计"></a> 成本估计</h2>
<h3 id="代码行技术"><a class="markdownIt-Anchor" href="#代码行技术"></a> 代码行技术</h3>
<p>用每行代码的平均成本乘以行数便可确定软件的成本．每行代码的平均成本主要取决于软件的复杂程度和工资水平．</p>
<h3 id="任务分解技术"><a class="markdownIt-Anchor" href="#任务分解技术"></a> 任务分解技术</h3>
<p>把软件开发分解为若干个相对独立的任务，再分别估计每个单独的开发任务成本，最后累加起来得出软件开发工程的总成本．估计每个任务的总成本时，通常先估计完成该项任务需要用的人力（以人月为单位），再乘以每人每月的平均工资而得出每个任务的成本．</p>
<h3 id="自动估计成本技术"><a class="markdownIt-Anchor" href="#自动估计成本技术"></a> 自动估计成本技术</h3>
<p>它不太常用，采用这种技术须有长期收集的大量历史数据为基础</p>
<h2 id="简单的成本核算核算方法中应考虑的几个方面"><a class="markdownIt-Anchor" href="#简单的成本核算核算方法中应考虑的几个方面"></a> 简单的成本核算核算方法中应考虑的几个方面</h2>
<ol>
<li>
<p>硬件投入费用</p>
</li>
<li>
<p>软件人员开发投入费用</p>
</li>
<li>
<p>软件开发平台投入费用</p>
</li>
<li>
<p>调研费用与资料费</p>
</li>
<li>
<p>不可预见费（总经费 5.5 ％）</p>
</li>
<li>
<p>利润 ＊</p>
</li>
<li>
<p>管理费 ＊（总经费 15 ％）</p>
</li>
<li>
<p>运行维护费 ＊</p>
</li>
</ol>
<p>＊ 表示与对方讨价还价点，是可取舍，是打折的依据．</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第3章需求分析</title>
    <url>/2020/07/28/%E7%AC%AC3%E7%AB%A0%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="软件需求分析"><a class="markdownIt-Anchor" href="#软件需求分析"></a> 软件需求分析</h1>
<p>核心在于明确做什么</p>
<h1 id="需求分析的任务"><a class="markdownIt-Anchor" href="#需求分析的任务"></a> 需求分析的任务</h1>
<h2 id="确定对系统的综合要求"><a class="markdownIt-Anchor" href="#确定对系统的综合要求"></a> 确定对系统的综合要求</h2>
<ol>
<li>
<p>功能需求</p>
</li>
<li>
<p>性能需求</p>
</li>
<li>
<p>可靠性和可用性需求</p>
</li>
<li>
<p>出错处理需求</p>
</li>
<li>
<p>接口需求</p>
</li>
<li>
<p>约束</p>
</li>
<li>
<p>逆向需求</p>
</li>
<li>
<p>将来可能提出的需求</p>
</li>
</ol>
<h2 id="分析系统的数据要求"><a class="markdownIt-Anchor" href="#分析系统的数据要求"></a> 分析系统的数据要求</h2>
<ol>
<li>通常采用建立<strong>数据模型</strong>的方法</li>
<li>用数据结构表示数据元素之间的逻辑关系</li>
<li>用数据字典来全面定义数据，但不直观</li>
<li>常用图形工具绘制数据结构</li>
</ol>
<h2 id="导出系统的逻辑模型"><a class="markdownIt-Anchor" href="#导出系统的逻辑模型"></a> 导出系统的逻辑模型</h2>
<p>通常用数据流图、实体-联系图、状态转换图、数据字典和处理算法描述这个逻辑模型。</p>
<h2 id="修改系统的开发计划"><a class="markdownIt-Anchor" href="#修改系统的开发计划"></a> 修改系统的开发计划</h2>
<p>根据分析过程中获得的对系统更深入的了解，可以比较准确地估计系统的成本和进度，修正以前制定的开发计划。</p>
<h1 id="与用户沟通获取需求的方法"><a class="markdownIt-Anchor" href="#与用户沟通获取需求的方法"></a> 与用户沟通获取需求的方法</h1>
<h2 id="访谈"><a class="markdownIt-Anchor" href="#访谈"></a> 访谈</h2>
<p>两种基本形式：正式和非正式的访谈。</p>
<h2 id="面向数据流自顶向下求精"><a class="markdownIt-Anchor" href="#面向数据流自顶向下求精"></a> 面向数据流自顶向下求精</h2>
<blockquote>
<p>数据流图是帮助对分析结果进行复查的极好的工具。从输出端开始，分析员借助数据流图、数据字典、IPO图向用户解释数据是怎样转变成输出数据的，并填补遗漏或空白元素。</p>
</blockquote>
<ol>
<li>可行性研究已经得出了目标系统的<strong>高层数据流图</strong>，需求分析的目标之一就是<strong>把数据流和数据存储定义到元素级。</strong></li>
<li>一般<strong>从数据流图的输出端</strong>入手。输出数据决定了系统必须具有的最基本的组成元素。</li>
<li><strong>从输出向输入回溯</strong>，可以确定每个数据元素的来源。可行性研究已经得出了目标系统的高层数据流图，需求分析的目标之一就是把数据流和数据存储定义到元素级。</li>
</ol>
<h3 id="方法回溯"><a class="markdownIt-Anchor" href="#方法回溯"></a> 方法：回溯</h3>
<ol>
<li>回溯过程种可能遇到下述问题：
<ol>
<li>为了得到某个数据元素需要用到数据流图中目前还没有的数据元素;</li>
<li>或者得出这个数据元素需要的算法尚不完全清楚。</li>
</ol>
</li>
</ol>
<h3 id="过程结构化分析方法sa法"><a class="markdownIt-Anchor" href="#过程结构化分析方法sa法"></a> 过程：结构化分析方法(SA法)</h3>
<ol>
<li>
<p>它是面向数据流自上而下逐步求精进行需求分析的方法。由可行性研究得出目标系统的高层数据流图。<strong>需求分析的目的之一是把数据流和存贮定义到元素级。</strong></p>
</li>
<li>
<p>基本过程</p>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%5C%E5%9B%BE%E7%89%87%5C12.png" alt="" /></p>
</li>
</ol>
<h2 id="简易的应用规格说明技术"><a class="markdownIt-Anchor" href="#简易的应用规格说明技术"></a> 简易的应用规格说明技术</h2>
<p>使用简易的应用规格说明<strong>技术分析需求的典型过程是：</strong><br />
初步访谈开发者和用户分别写出“产品需求”会议讨论统一意见</p>
<h2 id="快速建立软件原型"><a class="markdownIt-Anchor" href="#快速建立软件原型"></a> 快速建立软件原型</h2>
<p>快速建立软件原型是最准确、最有效、最强大的<strong>需求分析技术。</strong></p>
<h1 id="分析模型与规格说明"><a class="markdownIt-Anchor" href="#分析模型与规格说明"></a> 分析模型与规格说明</h1>
<h2 id="模型建立"><a class="markdownIt-Anchor" href="#模型建立"></a> 模型建立</h2>
<h3 id="三种模型"><a class="markdownIt-Anchor" href="#三种模型"></a> 三种模型</h3>
<ol>
<li><strong>数据模型</strong>：实体－联系图，描绘数据及数据对象之间的关系。</li>
<li><strong>功能模型</strong>：数据流图，描绘当数据在软件系统中移动时被变换的逻辑过程。</li>
<li><strong>行为模型</strong>：状态转换图，描绘系统各种行为模式和在不同状态间的转换。</li>
</ol>
<h3 id="建模的目的"><a class="markdownIt-Anchor" href="#建模的目的"></a> 建模的目的</h3>
<ol>
<li>更好的了解系统<strong>信息、功能和行为</strong>，使<strong>分析更系统化</strong>。</li>
<li>模型是评审的焦点，是<strong>确定系统完整性（completeness），一致性（consistency）和规格说明准确性（accuracy</strong>）的关键。</li>
<li>模型是<strong>设计的基础</strong>，能给设计人员一种软件基本表达式。它可映射成为实现的正文。</li>
</ol>
<h2 id="规格说明"><a class="markdownIt-Anchor" href="#规格说明"></a> 规格说明</h2>
<ol>
<li>
<p>从实现中说出功能。</p>
</li>
<li>
<p>要求一个面向过程的系统规格说明语言。</p>
</li>
<li>
<p>一个规格说明必须围绕整个系统，而软件只是它的一个组成部分。</p>
</li>
<li>
<p>一个规格说明必须围绕整个系统的操作环境。</p>
</li>
<li>
<p>一个规格说明必须是可操作的。</p>
</li>
<li>
<p>一个规格说明必须是容许它是不完整的和可扩展的。</p>
</li>
<li>
<p>一个规格说明必须是局部化的和松散耦合的。</p>
<ul>
<li>局部化是当信息改变时，只有一些简单的碎片（理想的）需要修改；</li>
<li>松散耦合结构是碎片可以方便的加入或取出，结构自动调整。</li>
</ul>
</li>
</ol>
<h1 id="概念模型和规范化"><a class="markdownIt-Anchor" href="#概念模型和规范化"></a> 概念模型和规范化</h1>
<p><strong>方法是</strong> 实体-联系方法，即<strong>E-R图</strong></p>
<h2 id="e-r模型"><a class="markdownIt-Anchor" href="#e-r模型"></a> E-R模型</h2>
<h3 id="联系"><a class="markdownIt-Anchor" href="#联系"></a> 联系</h3>
<p>此联系有3类：</p>
<ol>
<li>一对一 (1 : 1)  例如部门与经理；</li>
<li>一对N  (1 : N)  某教师上多门课；</li>
<li>多对多(M :N)  一个学生学多门课，而每门课有多名学生上。</li>
</ol>
<h3 id="实体"><a class="markdownIt-Anchor" href="#实体"></a> 实体</h3>
<p>实体是可相互区分的事物：例如  职工、学生、课程、教师</p>
<h3 id="属性"><a class="markdownIt-Anchor" href="#属性"></a> 属性</h3>
<p>属性是<strong>实体或联系</strong>所具有的性质，通常一个实体由若干个属性来刻画。如：学生实体有姓名、性别、系、年级。教师-----职称、职务</p>
<h2 id="数据规范化"><a class="markdownIt-Anchor" href="#数据规范化"></a> 数据规范化</h2>
<h3 id="要求"><a class="markdownIt-Anchor" href="#要求"></a> 要求</h3>
<ol>
<li>消除数据<strong>冗余</strong>，即消除表格中数据的重复；</li>
<li>消除<strong>多义性</strong>，使关系中的属性含义清楚、单一；</li>
<li><strong>使关系的“概念”单一化</strong>，让每个数据项只是一个简单的数或字符串，而不是一个组项或重复组；<br />
方便操作。使数据的插入、删除与修改操作可行而且方便；</li>
<li>使<strong>关系模式更灵活</strong>，易于实现接近自然语言的查询方式。</li>
</ol>
<h3 id="范式"><a class="markdownIt-Anchor" href="#范式"></a> 范式</h3>
<p>推荐到3NF(平衡性能和范式级别)</p>
<h1 id="状态转移图"><a class="markdownIt-Anchor" href="#状态转移图"></a> 状态转移图</h1>
<p>状态图提供了行为建模机制</p>
<h2 id="状态"><a class="markdownIt-Anchor" href="#状态"></a> 状态</h2>
<ol>
<li>状态是任何可以被观察到的系统行为模式，<strong>一个状态代表系统的一个行为模式。</strong></li>
<li>状态规定了<strong>系统对事件的响应方式</strong>。系统对事件响应
<ul>
<li>既可以是做一个（或一系列）动作</li>
<li>也可以是仅仅改变系统本身的状态</li>
<li>还可以是既改变状态又做动作。</li>
</ul>
</li>
</ol>
<h2 id="事件"><a class="markdownIt-Anchor" href="#事件"></a> 事件</h2>
<ol>
<li>事件是<strong>在某个特定时刻发生的事情</strong>，它是对引起系统做动作或从一个状态转换到另一个状态的外界事件的抽象。</li>
<li>事件就是引起系统做动作或转换状态的<strong>控制信息</strong>。</li>
</ol>
<h2 id="符号"><a class="markdownIt-Anchor" href="#符号"></a> 符号</h2>
<ol>
<li>初态用实心圆表示，终态用一对同心圆（内圆为实心圆）表示。</li>
<li>中间状态用圆角矩形表示，可以用平衡线把它分割成上、中、下3个部分。
<ul>
<li>上部分为状态的名称，该部分是必须的；</li>
<li>中间部分为状态变量的名字和值，该部分为可选；</li>
<li>下面部分是活动表，该部分为可选。</li>
</ul>
</li>
<li>箭头指明了转换方向。如转换过程中有事件触发，可以用事件表达式标明。</li>
</ol>
<img src="C:\Users\86139\Desktop\软件工程\图片\13.png" style="zoom: 50%;" />
<img src="\MyImages\image-20200601224344569.png" alt="image-20200601224344569" style="zoom:50%;" />
<h1 id="其他图形工具"><a class="markdownIt-Anchor" href="#其他图形工具"></a> 其他图形工具</h1>
<h2 id="层次方框图"><a class="markdownIt-Anchor" href="#层次方框图"></a> 层次方框图</h2>
<p>层次方框图采用树形结构的一系列多层次的矩形框来描绘数据的层次结构。</p>
<p><img src="C:%5CUsers%5C86139%5CDesktop%5C%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%5C%E5%9B%BE%E7%89%87%5C14.png" alt="" /></p>
<h1 id="验证软件需求"><a class="markdownIt-Anchor" href="#验证软件需求"></a> 验证软件需求</h1>
<h2 id="结构化分析方法"><a class="markdownIt-Anchor" href="#结构化分析方法"></a> 结构化分析方法</h2>
<ol>
<li><strong>结构化分析方法</strong>采用自顶向下、逐层进行功能分解的系统分析方法来定义系统的需求。</li>
<li><strong>特点</strong>：利用数据流图（Data Flow Diagram，DFD）来帮助理解问题，对问题进行分析。</li>
<li>分析工具
<ul>
<li>功能分析工具：<strong>DFD</strong>、DD、结构化英语、判定表和判定树。</li>
<li>行为分析工具：<strong>状态迁移图</strong>、Petri网等。</li>
<li>数据分析工具：<strong>ER图</strong>或者EER（扩展ER）图。</li>
</ul>
</li>
<li><strong>结构化分析方法的弊端</strong>
<ul>
<li>基于功能分析和数据分析，将功能和数据分离，与人类现实世界环境不一样，和人的自然思维也就不一致了。</li>
<li>以功能为主，数据只是被动的信息载体。当<strong>系统行为发生变化时，系统维护非常困难</strong>。</li>
<li>DFD中<strong>不涉及系统的控制信息</strong>，因此，SA不适合于分析以控制信息为主的系统需求。</li>
</ul>
</li>
</ol>
<h2 id="面向对象方法"><a class="markdownIt-Anchor" href="#面向对象方法"></a> 面向对象方法</h2>
<h3 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想"></a> 基本思想</h3>
<ol>
<li>把客观世界看成是由各种对象组成的，任何事实都是对象，复杂的对象可由简单的对象组合而成。</li>
<li>所有的对象都划分成各种对象类，简称类;</li>
<li>按子类与父类的关系，把若干个对象组成一个层次结构的系统，在这个层次中，下层的子类具有和上层的父类相同的性质，这种现象称为继承。</li>
<li>对象之间能够而且只能通过传递消息互相联系。</li>
</ol>
<h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3>
<ol>
<li>与人类习惯的思维方法一致。</li>
<li>稳定性好</li>
<li>可重用好。</li>
<li>可维护性好。</li>
</ol>
<h3 id="三个阶段"><a class="markdownIt-Anchor" href="#三个阶段"></a> 三个阶段</h3>
<ol>
<li><strong>面向对象分析阶段</strong>：通常，面向对象分析主要包括需求陈述和面向对象建模两个步骤。</li>
<li><strong>面向对象设计阶段</strong>：系统设计确定实现系统的策略和目标系统的高层结构；对象设计确定空间中的类、关联、接口形式及实现服务的算法。</li>
<li><strong>面向对象实现阶段</strong>：主要包括两项工作：把面向对象设计的结果翻译成用某种程序语言书写的面向对象程序；测试并调试面向对象的程序。</li>
</ol>
<h2 id="开发方法的选择"><a class="markdownIt-Anchor" href="#开发方法的选择"></a> 开发方法的选择</h2>
<ol>
<li>系统的规模、复杂程度与不确定因素是选择开发方法的重要依据。系统规模大，功能与数据关系复杂，开发周期比较长，适宜采用生命周期法；系统规模适中，需求的不确定性高，适宜采用原型法；系统规模小，复杂程度不高，适宜采用生成法；功能单一、结构简单的单项数据处理系统，则适宜采用IMPO法，面向对象几乎适用于各种方法。</li>
<li>开发人员的素质和工作基础是选择开发方法的先决条件。初次参与开发工作，开发经验不多的人员适宜采用生命周期法；技术水平高，开发经验丰富的人员，可以考虑采用原型法、IMPO法；具有较好工作基础的可以采用生成法、智能法和面向对象方法等。</li>
<li>用户和系统环境的条件是选择开发方法的重要参考因素。用户人才队伍的技术水平，科学管理的基础，领导的重视程度以及时间性，实用性等都会影响到选择方法的决定。</li>
<li>系统开发方法的确定与选择的开发策略直接有关。</li>
</ol>
<h2 id="需求分析方法的比较"><a class="markdownIt-Anchor" href="#需求分析方法的比较"></a> 需求分析方法的比较</h2>
<ol>
<li>结构化分析方法以系统的功能分析为主，而功能是易变的；面向对象分析方法以组成系统的对象分析为主，而对象是比较稳定的。</li>
<li>结构化分析方法主要针对数据处理领域，而面向对象分析方法同样适用于以控制为主的系统。</li>
<li>面向对象分析具有更好的扩展性，因为对象的结构和关系相对于系统的功能而言更稳定，功能的变化通过更新对象的操作加以适应。</li>
</ol>
<h1 id="项目管理"><a class="markdownIt-Anchor" href="#项目管理"></a> 项目管理</h1>
<h2 id="项目管理概述"><a class="markdownIt-Anchor" href="#项目管理概述"></a> 项目管理概述</h2>
<h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3>
<ol>
<li>项目管理是一项复杂的工作</li>
<li>项目管理具有创造性
<ul>
<li>继承累积性</li>
<li>综合性</li>
</ul>
</li>
<li></li>
</ol>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第5章总体设计</title>
    <url>/2020/07/28/%E7%AC%AC5%E7%AB%A0%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="设计目标和任务"><a class="markdownIt-Anchor" href="#设计目标和任务"></a> 设计目标和任务</h1>
<img src="\MyImages\image-20200407144132971.png" alt="image-20200407144132971" style="zoom:67%;" />
<h2 id="数据设计"><a class="markdownIt-Anchor" href="#数据设计"></a> 数据设计</h2>
<p>将实体 – 关系图中描述的对象和关系，以及<strong>数据词典中描述的详细数据内容转化为数据结构的定义</strong>。</p>
<h2 id="体系结构设计"><a class="markdownIt-Anchor" href="#体系结构设计"></a> 体系结构设计</h2>
<p>定义软件系统各主要成份之间的关系</p>
<h2 id="接口设计"><a class="markdownIt-Anchor" href="#接口设计"></a> 接口设计</h2>
<p>根据数据流图定义软件内部各成份之间、软件与其它协同系统之间及软件与用户之间的交互机制</p>
<h2 id="过程设计"><a class="markdownIt-Anchor" href="#过程设计"></a> 过程设计</h2>
<p>把结构成份转换成软件的过程性描述</p>
<h1 id="软件设计任务"><a class="markdownIt-Anchor" href="#软件设计任务"></a> 软件设计任务</h1>
<ul>
<li>软件设计分成两步
<ul>
<li>概要设计
<ul>
<li>面向人的</li>
<li>将软件需求转化为数据结构和软件的系统结构</li>
</ul>
</li>
<li>详细设计
<ul>
<li>面向具体实现</li>
<li>即过程设计。通过对结构表示进行细化，得到软件的详细的数据结构和算法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="制定规范"><a class="markdownIt-Anchor" href="#制定规范"></a> 制定规范</h2>
<ul>
<li>在进入软件开发阶段之初，首先应为软件开发组制定在设计时应该共同遵守的标准，以便协调组内各成员的工作</li>
</ul>
<h2 id="软件系统结构的总体设计"><a class="markdownIt-Anchor" href="#软件系统结构的总体设计"></a> 软件系统结构的总体设计</h2>
<ul>
<li>
<p>采用某种设计方法，将系统按功能划分成模块的<strong>层次结构</strong></p>
</li>
<li>
<p>确定每个<strong>模块的功能</strong></p>
</li>
<li>
<p>建立与已确定的<strong>软件需求的对应关系</strong></p>
</li>
<li>
<p>确定模块间的<strong>调用关系</strong></p>
</li>
<li>
<p>确定模块间的<strong>接口</strong></p>
</li>
<li>
<p>评估模块<strong>划分的质量</strong></p>
</li>
</ul>
<h2 id="处理方式设计"><a class="markdownIt-Anchor" href="#处理方式设计"></a> 处理方式设计</h2>
<ul>
<li>确定为实现系统的功能需求<strong>所必需的算法</strong></li>
<li>确定为满足系统的性能需求所必需的<strong>算法和模块间的控制方式</strong>
<ul>
<li>周转时间</li>
<li>响应时间</li>
<li>吞吐量</li>
<li>精度</li>
</ul>
</li>
</ul>
<h2 id="数据结构设计"><a class="markdownIt-Anchor" href="#数据结构设计"></a> 数据结构设计</h2>
<ul>
<li>确定软件涉及的<strong>文件系统的结构以及数据库的模式</strong>、子模式，进行数据完整性和安全性的设计</li>
<li>确定<strong>输入，输出文件的详细的数据结构</strong></li>
<li>结合算法设计，确定<strong>算法所必需的逻辑数据结构</strong>及其操作</li>
<li>确定对逻辑数据结构所必需的那些操作的程序模块</li>
</ul>
<h3 id="考虑的因素"><a class="markdownIt-Anchor" href="#考虑的因素"></a> 考虑的因素</h3>
<ul>
<li>限制和确定各个数据设计决策的影响范围</li>
<li>若需要与操作系统或调度程序接口所必须的控制表等数据时，确定其详细的数据结构和使用规则</li>
<li>数据的保护性设计
<ul>
<li>防卫性设计：规定输入格式</li>
<li>一致性设计：处理并发问题,Petri网</li>
<li>冗余性设计：两个不同风格设计的结果之差在允许范围内</li>
</ul>
</li>
</ul>
<h2 id="可靠性设计"><a class="markdownIt-Anchor" href="#可靠性设计"></a> 可靠性设计</h2>
<ul>
<li>也叫质量设计</li>
</ul>
<h2 id="编写概要设计阶段的文档"><a class="markdownIt-Anchor" href="#编写概要设计阶段的文档"></a> 编写概要设计阶段的文档</h2>
<ul>
<li>概要设计说明书</li>
<li>数据库设计说明书</li>
<li>用户手册</li>
<li>制定初步的测试计划</li>
</ul>
<h2 id="设计评审"><a class="markdownIt-Anchor" href="#设计评审"></a> 设计评审</h2>
<ul>
<li>可追溯性：确认该设计是否复盖了所有已确定的软件需求，软件每一成份是否可追溯到某一项需求</li>
<li>接口：确认该软件的内部接口与外部接口是否已经明确定义。模块是否满足高内聚和低耦合的要求。模块作用范围是否在其控制范围之内</li>
<li>风险：确认该设计在现有技术条件下和预算范围内是否能按时实现</li>
<li>实用性：确认该设计对于需求的解决方案是否实用</li>
<li>技术清晰度：确认该设计是否以一种易于翻译成代码的形式表达</li>
<li>可维护性：确认该设计是否考虑了方便未来的维护</li>
<li>质量：确认该设计是否表现出良好的质量特征</li>
<li>各种选择方案：看是否考虑过其它方案，比较各种选择方案的标准是什么</li>
<li>限制：评估对该软件的限制是否现实，是否与需求一致</li>
<li>其它具体问题：对于文档、可测试性、设计过程…等进行评估</li>
</ul>
<h2 id="总结总体设计过程"><a class="markdownIt-Anchor" href="#总结总体设计过程"></a> 总结总体设计过程</h2>
<h3 id="主要阶段组成"><a class="markdownIt-Anchor" href="#主要阶段组成"></a> 主要阶段组成</h3>
<ol>
<li>系统设计：确定系统的具体实现方案</li>
<li>结构设计：确定软件结构</li>
</ol>
<h3 id="设想供选择的方案"><a class="markdownIt-Anchor" href="#设想供选择的方案"></a> 设想供选择的方案</h3>
<p>设想把数据流图中的处理分组的各种可能的方法，抛弃在技术上行不通的分组方法，余下的分组方法代表可能的实现策略，并且可以启示供选择的物理系统。</p>
<h3 id="选取合理的方案"><a class="markdownIt-Anchor" href="#选取合理的方案"></a> 选取合理的方案</h3>
<p>要准备四份材料</p>
<p>① 系统流程图        ②  组成系统的物理元素清单<br />
③ 成本/效益分析     ④ 实现该系统的进度计划</p>
<h3 id="推荐最佳方案"><a class="markdownIt-Anchor" href="#推荐最佳方案"></a> 推荐最佳方案</h3>
<p>分析员推荐最佳方案，用户及专家应认真审查该方案，是否满足用户的要求，应请部门负责人进一步审批，然后进入下一个阶段——结构设计。</p>
<h3 id="功能分解"><a class="markdownIt-Anchor" href="#功能分解"></a> 功能分解</h3>
<p>分为两阶段完成</p>
<ol>
<li>结构设计：确定程序由哪些模块组成及几个模块之间的关系；</li>
<li>过程设计：确定每个模块的处理过程。</li>
</ol>
<h3 id="设计软件结构"><a class="markdownIt-Anchor" href="#设计软件结构"></a> 设计软件结构</h3>
<ul>
<li>
<p>通常程序中的一个模块完成一个适当的功能。应该把模块组织成良好的的<strong>层次系统</strong>。</p>
</li>
<li>
<p>数据流图已经细化到适当的层次，则可以直接从数据流图映射出软件结构</p>
</li>
</ul>
<h3 id="数据库设计"><a class="markdownIt-Anchor" href="#数据库设计"></a> 数据库设计</h3>
<h3 id="制定测试计划"><a class="markdownIt-Anchor" href="#制定测试计划"></a> 制定测试计划</h3>
<p>在软件开发的早期阶段考虑测试问题，能促使软件设计人员在设计时注意提高软件的可测试性。</p>
<h3 id="书写文档"><a class="markdownIt-Anchor" href="#书写文档"></a> 书写文档</h3>
<p>（1）系统说明         （2）用户手册        （3）测试计划<br />
（4）详细的实现计划         （5）数据库设计结果</p>
<h3 id="审查和复查"><a class="markdownIt-Anchor" href="#审查和复查"></a> 审查和复查</h3>
<p>对总体设计的结果进行严格的技术审查，在技术审查通过之后再由使用部门的负责人从管理角度进行复审。</p>
<h1 id="设计原理"><a class="markdownIt-Anchor" href="#设计原理"></a> 设计原理</h1>
<h2 id="模块化"><a class="markdownIt-Anchor" href="#模块化"></a> 模块化</h2>
<ul>
<li>模块是数据说明，可执行语句等程序对象的集合，它是单独命名的，而且是可通过名字来访问。</li>
</ul>
<h3 id="顺序模块"><a class="markdownIt-Anchor" href="#顺序模块"></a> 顺序模块</h3>
<ul>
<li>[子例程，函数，过程，宏］</li>
<li>它在没有中断的情况下，被应用软件引用或执行</li>
</ul>
<h3 id="增量模块"><a class="markdownIt-Anchor" href="#增量模块"></a> 增量模块</h3>
<ul>
<li>又称为协同程序，在引用完成之前，可以被应用程序中断，然后在中断点重新启动</li>
</ul>
<h3 id="并行模块"><a class="markdownIt-Anchor" href="#并行模块"></a> 并行模块</h3>
<ul>
<li>可与其他模块同时执行的模块</li>
</ul>
<h3 id="构件模块"><a class="markdownIt-Anchor" href="#构件模块"></a> 构件模块</h3>
<ul>
<li>可以降低耦合</li>
</ul>
<h2 id="抽象"><a class="markdownIt-Anchor" href="#抽象"></a> 抽象</h2>
<ul>
<li>软件工程过程中的每一步，都是对软件解的抽象层次的一次细化。当从总体设计转入详细设计过渡时，抽象的程度随之减少，最后当源代码写出以后，抽象的最低层也就到达了</li>
<li>抽象的低端就是代码</li>
</ul>
<h3 id="数据抽象"><a class="markdownIt-Anchor" href="#数据抽象"></a> 数据抽象</h3>
<ul>
<li>是一个命名的说明数据对象的数据集合</li>
<li>例如工资单，含有信息有：单位、姓名、房租、水电、有线电视费……,最后是总额</li>
</ul>
<h3 id="过程抽象"><a class="markdownIt-Anchor" href="#过程抽象"></a> 过程抽象</h3>
<ul>
<li>是一个命令的指令序列</li>
<li>例如：“入门”是一个过程抽象，它含有一个很长的过程步骤的序列</li>
</ul>
<h2 id="逐步求精"><a class="markdownIt-Anchor" href="#逐步求精"></a> 逐步求精</h2>
<p>逐步求精是人类解决复杂问题时采用的基本方法，也是许多软件工程技术（例如，规格说明技术，设计和实现技术）的基础。可以把逐步求精定义为：“为了能集中精力解决主要问题而尽量推迟对问题细节的考虑。”</p>
<h2 id="局部化和信息隐蔽"><a class="markdownIt-Anchor" href="#局部化和信息隐蔽"></a> 局部化和信息隐蔽</h2>
<ul>
<li><strong>局部化</strong>是指把一些关系密切的软件元素物理的放得彼此靠近。显然，局部化有助于实现信息隐藏。</li>
<li><strong>隐藏</strong>意味着有效的模块化可以通过定义一组独立的模块而实现，这些独立的模块彼此间仅仅交换那些为了完成系统功能而必须交换的信息。</li>
</ul>
<h2 id="模块独立"><a class="markdownIt-Anchor" href="#模块独立"></a> 模块独立</h2>
<h3 id="模块独立重要性"><a class="markdownIt-Anchor" href="#模块独立重要性"></a> 模块独立重要性</h3>
<ul>
<li>有效的模块化软件比较容易开发。</li>
<li>模块容易测试和维护。</li>
</ul>
<h3 id="独立性程度衡量"><a class="markdownIt-Anchor" href="#独立性程度衡量"></a> 独立性程度衡量</h3>
<ul>
<li><strong>耦合</strong>：它是衡量<strong>不同模块彼此间</strong>互相依赖的紧密程度。</li>
<li><strong>内聚</strong>：它是衡量<strong>一个模块内部</strong>各个元素彼此结合的紧密程度。</li>
</ul>
<h3 id="内聚"><a class="markdownIt-Anchor" href="#内聚"></a> 内聚</h3>
<h4 id="功能内聚"><a class="markdownIt-Anchor" href="#功能内聚"></a> 功能内聚</h4>
<p>一个模块中各个部分都是<strong>完成某一具体功能必不可少的组成部分</strong>，或者说该模块中所有部分都是为了完成一项具体功能而协同工作，紧密联系，不可分割的。则称该模块为功能内聚模块。</p>
<h4 id="顺序内聚"><a class="markdownIt-Anchor" href="#顺序内聚"></a> 顺序内聚</h4>
<p>该模块根据不同要求，确定执行某个功能，由于该模块所有功能<strong>基于同一个数据结果（符号表</strong>）故为顺序内聚模块。</p>
<h4 id="通信内聚"><a class="markdownIt-Anchor" href="#通信内聚"></a> 通信内聚</h4>
<p>如果一个<strong>模块内各功能部分都使用了相同的输入数据</strong>，或产生了相同的输出数据，则称之为通信内聚模块。通常，通信内聚模块是通过数据流图来定义的。</p>
<h4 id="过程内聚"><a class="markdownIt-Anchor" href="#过程内聚"></a> 过程内聚</h4>
<p>使用流程图做为工具设计程序时，<strong>把流程图中的某一部分划出组成模块，就得到过程内聚模块</strong>。例如，把流程图中的循环部分、判定部分、计算部分分成三个模块，这三个模块都是过程内聚模块。</p>
<h4 id="时间内聚"><a class="markdownIt-Anchor" href="#时间内聚"></a> 时间内聚</h4>
<p>时间内聚又称为经典内聚。<strong>这种模块大多为多功能模块，但模块的各个功能的执行与时间有关</strong>，通常要求所有功能必须在同一时间段内执行。例如初始化模块和终止模块。</p>
<h4 id="逻辑内聚"><a class="markdownIt-Anchor" href="#逻辑内聚"></a> 逻辑内聚</h4>
<p>这种模块把几种相关的功能组合在一起，每次被调用时，由传送给模块的判定参数来确定该模块应执行哪一种功能。(switch)</p>
<h4 id="巧合内聚"><a class="markdownIt-Anchor" href="#巧合内聚"></a> 巧合内聚</h4>
<p>当模块内各部分之间没有联系，或者即使有联系，该联系也很松散，则称这种模块为巧合内聚模块，它是内聚程度最低的模块。</p>
<h4 id="内聚关系比较"><a class="markdownIt-Anchor" href="#内聚关系比较"></a> 内聚关系比较</h4>
<img src="\MyImages\image-20200417103936301.png" alt="image-20200417103936301" style="zoom: 50%;" />
<h3 id="耦合"><a class="markdownIt-Anchor" href="#耦合"></a> 耦合</h3>
<img src="\MyImages\image-20200417104323192.png" alt="image-20200417104323192" style="zoom: 50%;" />
<h4 id="非直接耦合"><a class="markdownIt-Anchor" href="#非直接耦合"></a> 非直接耦合</h4>
<p>两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。</p>
<h4 id="数据耦合"><a class="markdownIt-Anchor" href="#数据耦合"></a> 数据耦合</h4>
<p>一个模块访问另一个模块时，彼此之间是通<strong>过简单数据参数</strong> (<strong>不是控制参数、公共数据结构或外部变量</strong>)  来交换输入、输出信息的。</p>
<h4 id="标记耦合"><a class="markdownIt-Anchor" href="#标记耦合"></a> 标记耦合</h4>
<p>一组模块通过参数表传递记录信息，就是标记耦合。这个记录是某一数据结构的子结构，而不是简单变量。传递是一个数据结构</p>
<h4 id="控制耦合"><a class="markdownIt-Anchor" href="#控制耦合"></a> 控制耦合</h4>
<p>如果一个模块通过传送开关、标志、名字等控制信息，明显地控制选择另一模块的功能，就是控制耦合。</p>
<h4 id="外部耦合"><a class="markdownIt-Anchor" href="#外部耦合"></a> 外部耦合</h4>
<p>一组模块都访问<strong>同一全局简单变量</strong>而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。</p>
<h4 id="公共耦合"><a class="markdownIt-Anchor" href="#公共耦合"></a> 公共耦合</h4>
<p>若一组模块都访问<strong>同一个公共数据环境</strong>，则它们之间的耦合就称为公共耦合。</p>
<ul>
<li>公共耦合程度随着参与公共耦合的模块数量的增加而增加</li>
<li>需要加锁来协调各个模块</li>
</ul>
<h4 id="内容耦合"><a class="markdownIt-Anchor" href="#内容耦合"></a> 内容耦合</h4>
<p>如果发生下列情形，两个模块之间就发生了内容耦合</p>
<ol>
<li>一个模块直接访问另一个模块的内部数据</li>
<li>一个模块不通过正常入口转到另一模块内部</li>
<li>两个模块有一部分程序代码重迭(只可能出现在汇编语言中);</li>
<li>一个模块有多个入口</li>
</ol>
<h1 id="启发式规则"><a class="markdownIt-Anchor" href="#启发式规则"></a> 启发式规则</h1>
<h2 id="改进软件结构提高模块独立性"><a class="markdownIt-Anchor" href="#改进软件结构提高模块独立性"></a> 改进软件结构提高模块独立性</h2>
<ul>
<li>
<p>多个模块共有的一个子功能可以独立成一个模块，由这些模块调用。</p>
</li>
<li>
<p>有时可以通过分解或合并模块以减少控制信息的传递及全程数据的引用，并且降低接口复杂度。</p>
</li>
</ul>
<h2 id="模块规模应该适中"><a class="markdownIt-Anchor" href="#模块规模应该适中"></a> 模块规模应该适中</h2>
<p>一个模块的规模不应过大</p>
<h2 id="深度-宽度-扇入扇出应该适当"><a class="markdownIt-Anchor" href="#深度-宽度-扇入扇出应该适当"></a> 深度、宽度、扇入扇出应该适当</h2>
<ul>
<li><strong>深度</strong>：软件结构中的控制层数，一般深度不超过7级</li>
<li><strong>宽度</strong>：同一层上模块总数的最大值</li>
<li><strong>扇出</strong>：一个模块直接控制（调用）的模块数目</li>
<li><strong>扇入</strong>：一个模块有多少个上级模块调用它</li>
<li>设计良好的系统结构
<ul>
<li>顶层扇出比较高；</li>
<li>中层扇出较少；</li>
<li>底层扇入到公共的实用模块中去。</li>
</ul>
</li>
</ul>
<h2 id="模块的作用域"><a class="markdownIt-Anchor" href="#模块的作用域"></a> 模块的作用域</h2>
<ul>
<li>
<p><strong>模块的作用域应该在控制域之内</strong>模块的作用域：该模块本身以及所有直接或间接从属于它的模块集合。模块A的控制域是A、B、C、D、E、F。若不是这样，会造成软件难于理解，这时需要传递判别结果，会使模块间出现控制耦合。</p>
<img src="\MyImages\image-20200417105726428.png" alt="image-20200417105726428" style="zoom:50%;" />
</li>
</ul>
<h2 id="力争降低模块接口的复杂程度"><a class="markdownIt-Anchor" href="#力争降低模块接口的复杂程度"></a> 力争降低模块接口的复杂程度</h2>
<h2 id="设计单入口单出口的模块"><a class="markdownIt-Anchor" href="#设计单入口单出口的模块"></a> 设计单入口单出口的模块</h2>
<p>从顶部入模块并且从底部退出，软件比较容易理解、容易维护。防止了内容耦合</p>
<h2 id="模块功能应该可以预测"><a class="markdownIt-Anchor" href="#模块功能应该可以预测"></a> 模块功能应该可以预测</h2>
<ul>
<li>预测指，输入一定，输出也是一定的</li>
<li>若一个模块当作黑盒子，即只要输入的数据相同就产生同样的输出，则该模块可预测。带有内部“存贮器”的模块的功能是不可预测的，因为它的输出可能取决于内部存储器的状态。实际上，要在软件设计时尽量避免在使用现场修改软件，这样的工程代价太高。</li>
</ul>
<h1 id="描绘软件结构的图形工具"><a class="markdownIt-Anchor" href="#描绘软件结构的图形工具"></a> 描绘软件结构的图形工具</h1>
<h2 id="层次图和hipo图"><a class="markdownIt-Anchor" href="#层次图和hipo图"></a> 层次图和HIPO图</h2>
<p>如上图中展示宽度和高度的图</p>
<h2 id="结构图"><a class="markdownIt-Anchor" href="#结构图"></a> 结构图</h2>
<p>按惯例总是图中位于上方的方框代表的模块调用下方的模块，用带注释的箭头表示模块调用过程中来回传递的信息。如果希望进一步表明传递信息是数据还是控制信息，用尾部形状区分：尾部是空心圆表示传递的是数据，实心圆表示传递的是控制信息。</p>
<h1 id="面向数据流的设计方法"><a class="markdownIt-Anchor" href="#面向数据流的设计方法"></a> 面向数据流的设计方法</h1>
<h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2>
<ul>
<li>软件设计方法包括
<ul>
<li>面向数据流的设计</li>
<li>面向数据结构的设计</li>
<li>面向对象的设计</li>
</ul>
</li>
</ul>
<h3 id="面向数据流的设计方法-2"><a class="markdownIt-Anchor" href="#面向数据流的设计方法-2"></a> 面向数据流的设计方法</h3>
<p>①  首先研究、分析数据流图<br />
②  然后根据数据流图决定问题的类型<br />
③  由数据流图推导出系统的初始结构图<br />
④ 利用启发性原则来改进系统的初始结构图，直到符合要求的结构图为止<br />
⑤  修改和补充数据字典<br />
⑥  制定测试计划</p>
<h4 id="信息流包括"><a class="markdownIt-Anchor" href="#信息流包括"></a> 信息流包括</h4>
<ul>
<li>变换流：<strong>信息沿输入通路进入系统，同时由外部形式变换成内部形式</strong>，进入系统的信息通过变化中心，经加工处理以后再沿输出通路变换成外部形式离开软件系统</li>
<li>事物流：数据沿输入通路到达一个处理T，这个处理根据输入数据的类型在若干个动作序列中选出一个来执行。</li>
</ul>
<img src="\MyImages\image-20200417110653808.png" alt="image-20200417110653808" style="zoom:50%;" />
<h2 id="变换分析"><a class="markdownIt-Anchor" href="#变换分析"></a> 变换分析</h2>
<p>变换分析是一系列设计步骤的总称。经这些步骤把具有变换特点的数据流图按预先确定的模式映射成软件结构</p>
<p>举例：以C-&gt;D为变换中心</p>
<img src="\MyImages\image-20200417110759819.png" alt="image-20200417110759819" style="zoom:67%;" />
<img src="\MyImages\image-20200417110805314.png" alt="image-20200417110805314" style="zoom: 67%;" />
<h3 id="变换流设计方法"><a class="markdownIt-Anchor" href="#变换流设计方法"></a> 变换流设计方法</h3>
<ol>
<li>找出变换中心
<ul>
<li>从输入端开始一步步向后推；</li>
<li>从输出端向前移</li>
</ul>
</li>
<li>设计软件结构的顶层和第二层</li>
</ol>
<ul>
<li>变换中心确定，等于确定了主模块，其功能主要是完成对所有模块控制。顶层之后是第二层，一般第二层至少有三种功能：输入、输出和交换中心，它们可以是一个或多个。</li>
</ul>
<ol start="3">
<li>下层模块
<ul>
<li>根据第二层，自顶而下，逐步细化，分别为各模块设计出下属模块</li>
</ul>
</li>
</ol>
<h3 id="举例"><a class="markdownIt-Anchor" href="#举例"></a> 举例</h3>
<img src="\MyImages\image-20200417111154849.png" alt="image-20200417111154849" style="zoom:50%;" />
<img src="\MyImages\image-20200417111156905.png" alt="image-20200417111156905" style="zoom:50%;" />
<h2 id="事务分析"><a class="markdownIt-Anchor" href="#事务分析"></a> 事务分析</h2>
<p>在很多软件应用中，存在某种作业数据流，它可以引发一个或多个处理，这些处理能够完成该作业要求的功能。这种数据流就叫做事务流。</p>
<ul>
<li>特征：数据流图中扇入出现扇入少而扇出多，最后又扇入到一个点的模块</li>
</ul>
<h3 id="事务分析过程"><a class="markdownIt-Anchor" href="#事务分析过程"></a> 事务分析过程</h3>
<ol>
<li>识别事物源
<ul>
<li>利用数据流图和数据词典，从问题定义和需求分析的结果中，找出各种需要处理的事务。通常，事务来自物理输入装置。有时，设计人员还必须区别系统的输入、中心加工和输出中产生的事务。</li>
</ul>
</li>
<li>规定适当的是事物型结构
<ul>
<li>在确定了该数据流图具有事务型特征之后，根据模块划分理论，建立适当的事务型结构。</li>
</ul>
</li>
<li>识别各种事务和它们定义的操作。从问题定义
<ul>
<li>需求分析中找出的事务及其操作所必需的全部信息，对于系统内部产生的事务，必须仔细地定义它们的操作。</li>
</ul>
</li>
<li>注意利用公用模块
<ul>
<li>在事务分析的过程中，如果不同事务的一些中间模块可由具有类似的语法和语义的若干个低层模块组成，则可以把这些低层模块构造成公用模块。</li>
</ul>
</li>
<li>对每一事务，或对联系密切的一组事务，建立一个事务处理模块</li>
</ol>
<ul>
<li>如果发现在系统中有类似的事务，可以把它们组成一个事务处理模块</li>
</ul>
<ol start="6">
<li>对事务处理模块规定它们全部的下层操作模块</li>
<li>对操作模块规定它们的全部细节模块</li>
</ol>
<h3 id="举例-2"><a class="markdownIt-Anchor" href="#举例-2"></a> 举例</h3>
<img src="\MyImages\image-20200417111517752.png" alt="image-20200417111517752" style="zoom: 50%;" />
<h3 id="综合举例"><a class="markdownIt-Anchor" href="#综合举例"></a> 综合举例</h3>
<ul>
<li>通常是变换流为主，事物流为辅的情况</li>
</ul>
<img src="\MyImages\image-20200417112110574.png" alt="image-20200417112110574" style="zoom: 50%;" />
<img src="\MyImages\image-20200417112113474.png" alt="image-20200417112113474" style="zoom: 50%;" />]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第4章形式化说明技术</title>
    <url>/2020/07/28/%E7%AC%AC4%E7%AB%A0%E5%BD%A2%E5%BC%8F%E5%8C%96%E8%AF%B4%E6%98%8E%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h1 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h1>
<h2 id="非形式化方法的缺点"><a class="markdownIt-Anchor" href="#非形式化方法的缺点"></a> 非形式化方法的缺点</h2>
<ul>
<li>矛盾：指一组相互冲突的陈述</li>
<li>二义性：指读者可以用不同方式理解的陈述</li>
<li>含糊性</li>
<li>不完整性：可能是在系统规格说明中最常遇到的问题之一</li>
</ul>
<h2 id="形式化方法的优点"><a class="markdownIt-Anchor" href="#形式化方法的优点"></a> 形式化方法的优点</h2>
<p>把数学引入后的优点有</p>
<ul>
<li>能够简洁的描述物理现象</li>
<li>准确，几乎没有二义性，而且可以用数学方法来验证，以发现存在的矛盾和不完整性，在这样的规格说明中完全没有含糊性</li>
<li>可以再不同的软件工程活动之间平滑的过度</li>
<li>提供了高层确认的手段</li>
</ul>
<h3 id="形式化规格说明语言构成"><a class="markdownIt-Anchor" href="#形式化规格说明语言构成"></a> 形式化规格说明语言构成：</h3>
<ul>
<li><strong>语法</strong>：一般基于集合论、数理逻辑或代数学。</li>
<li><strong>语义</strong>：是其所有语法符号的意义的数学描述。经典的语义定义方法包括指称语义、代数语义和操作语义方法。</li>
<li><strong>推演规则</strong>：一般预期数学基础和语义定义方法密切相关。规则必须在规格说明语言的语义系统中可证。因此，可以认为规则是派生的语义定义，它们可以直接应用于软件规格说明的性质证明并简化推演过程。</li>
</ul>
<h2 id="应用形式化方法的准则"><a class="markdownIt-Anchor" href="#应用形式化方法的准则"></a> 应用形式化方法的准则</h2>
<ul>
<li>应该选用适当的表示方法</li>
<li>应该形式化，但不要过分形式化</li>
<li>应该估算成本</li>
<li>应该有形式化方法顾问随时提供咨询</li>
<li>不应该放弃传统的开发方法</li>
<li>应该建立详尽的文档</li>
<li>不应该放弃质量标准</li>
<li>不应该盲目依赖形式化方法</li>
<li>应该测试、测试再测试</li>
<li>应该重用。即使采用了形式化方法，软件重用仍然是降低软件成本和提高软件质量的唯一合理的方法</li>
</ul>
<h2 id="形式化方法的分类自行了解"><a class="markdownIt-Anchor" href="#形式化方法的分类自行了解"></a> 形式化方法的分类(自行了解)</h2>
<p>用于微观状态的描述</p>
<h1 id="有穷状态机"><a class="markdownIt-Anchor" href="#有穷状态机"></a> 有穷状态机</h1>
<h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2>
<img src="\MyImages\38.png" style="zoom:50%;" />
<h3 id="状态机组成"><a class="markdownIt-Anchor" href="#状态机组成"></a> 状态机组成</h3>
<ul>
<li>状态集J：{保险箱锁定，A，B，保险箱解锁，报警}。</li>
<li>输入集K：{1L,1R,2L,2R,3L,3R }。</li>
<li>转换函数T：由当前状态和当前输入确定下一个状态（次态），如表4.1所示。</li>
<li>初始态S：保险箱锁定。</li>
<li>终态集F：{保险箱解锁，报警}。</li>
</ul>
<h4 id="一个有穷状态机可以表示为一个5元组jktst-其中"><a class="markdownIt-Anchor" href="#一个有穷状态机可以表示为一个5元组jktst-其中"></a> <strong>一个有穷状态机可以表示为一个5元组（J,K,T,S,T）</strong>, 其中：</h4>
<p>​	   J 是一个有穷的非空状态集；<br />
K 是一个有穷的非空输入集；<br />
​	  T 是一个从（J-F）*K到J的转换函数；<br />
​      S ᇀ J，是一个初始状态；<br />
​      F	  J，是终态集。</p>
<p>​	当前状态［菜单］＋事件［所选择的项］＝&gt;下个状态。</p>
<h4 id="为了对一个系统进行规格说明引入谓词集p从而把有穷状态机扩展为一个6元组"><a class="markdownIt-Anchor" href="#为了对一个系统进行规格说明引入谓词集p从而把有穷状态机扩展为一个6元组"></a> 为了对一个系统进行规格说明,引入谓词集P，从而把有穷状态机扩展为一个6元组</h4>
<p>当前状态［菜单］＋事件［所选择的项］＋谓词 = &gt;下个状态</p>
<h3 id="状态转换表"><a class="markdownIt-Anchor" href="#状态转换表"></a> 状态转换表</h3>
<img src="\MyImages\44.png" style="zoom:50%;" />
<h2 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h2>
<h3 id="需求"><a class="markdownIt-Anchor" href="#需求"></a> 需求</h3>
<p>首先给出用自然语言描述的对电梯系统的需求：</p>
<ul>
<li>在一幢m层的大厦中需要一套控制n部电梯的产品，要求这n部电梯按照约束条件C1，C2和C3在楼层间移动。</li>
<li>C1：每部电梯内有m个按钮，每个按钮代表一个楼层。当按下一个按钮时该按钮指示灯亮，同时电梯驶向相应的楼层，到达按钮指定的楼层时指示灯熄灭。</li>
<li>C2：除了大厦的最低层和最高层之外，每层楼都有两个按钮分别请求电梯上行和下行。这两个按钮之一被按下时相应的指示灯亮，当电梯到达此楼层时灯熄灭，电梯向要求的方向移动。</li>
<li>C3：当对电梯没有请求时，它关门并停在当前楼层。</li>
<li>现在使用一个扩展的有穷状态机对本产品进行规格说明。这个问题中有两个按钮集:电梯按钮和楼层按钮。</li>
</ul>
<h3 id="转换规则1"><a class="markdownIt-Anchor" href="#转换规则1"></a> 转换规则1</h3>
<p><strong>谓词用来限制状态</strong></p>
<ul>
<li>令EB(e,f)表示按下电梯e内的按钮并请求到f层去。EB(e,f)有两个状态，分别是按钮发光(打开)和不发光(关闭)。更精确地说，状态是：
<ul>
<li>EBON(e,f)：电梯按钮(e,f)打开</li>
<li>EBOFF(e,f)：电梯按钮(e,f)关闭</li>
</ul>
</li>
<li>如果电梯按钮(e,f)发光且电梯到达f层，该按钮将熄灭。相反如果按钮熄灭，则按下它时，按钮将发光。上述描述中包含了两个事件，它们分别是：
<ul>
<li>EBP(e,f)：电梯按钮(e,f)被按下</li>
<li>EAF(e,f)：电梯e到达f层</li>
</ul>
</li>
<li>为了定义与这些事件和状态相联系的状态转换规则，需要一个谓词V(e,f)，它的含义如下：<br />
V(e,f)：电梯e停在f层<br />
如果电梯按钮(e,f)处于关闭状态〔当前状态〕，而且电梯按钮(e,f)被按下〔事件〕，而且电梯e不在f层〔谓词〕，则该电梯按钮打开发光〔下个状态〕。状态转换规则的形式化描述如下：<br />
EBOFF(e,f)+EBP(e,f)+not V(e,f)  EBON(e,f)<br />
反之，如果电梯到达f层，而且电梯按钮是打开的，于是它就会熄灭。这条转换规则可以形式化地表示为：<br />
EBON(e,f)+EAF(e,f)EBOFF(e,f)</li>
</ul>
<h4 id="状态转移图"><a class="markdownIt-Anchor" href="#状态转移图"></a> 状态转移图</h4>
<ul>
<li>
<p>电梯按钮的状态转换图</p>
<img src="\MyImages\image-20200401202425399.png" alt="image-20200401202425399" style="zoom: 33%;" />
</li>
<li>
<p>楼层按钮的状态转换图</p>
<img src="\MyImages\image-20200401202444535.png" alt="image-20200401202444535" style="zoom: 33%;" />
</li>
</ul>
<h3 id="转换规则2"><a class="markdownIt-Anchor" href="#转换规则2"></a> 转换规则2</h3>
<ul>
<li>
<p>接下来考虑楼层按钮。令FB(d,f)表示f层请求电梯向d方向运动的按钮，楼层按钮的状态如下：<br />
FBON(d,f)：楼层按钮(d,f)打开<br />
FBOFF(d,f)：楼层按钮(d,f)关闭</p>
</li>
<li>
<p>如果楼层按钮已经打开，而且一部电梯到达f层，则按钮关闭。反之，如果楼层按钮原来是关闭的，被按下后该按钮将打开。这段叙述中包含了以下两个事件。<br />
FBP(d,f)：楼层按钮(d,f)被按下<br />
EAF(1…n,f)：电梯1或…或n到达f层<br />
其中1…n表示或为1或为2…或为n。</p>
</li>
<li>
<p>定义电梯按钮和楼层按钮的状态都是很简单、直观的事情。现在转向讨论电梯的状态及其转换规则，就会出现一些复杂的情况。一个电梯状态实质上包含许多子状态。<br />
下面定义电梯的3个状态：<br />
M(d,e,f)：电梯e正沿d方向移动，即将到达的是第f层<br />
S(d,e,f)：电梯e停在f层，将朝d方向移动(尚未关门)<br />
W(e,f)：电梯e在f层等待(已关门)</p>
<p>其中S(d,e,f)状态已在讨论楼层按钮时定义过，但是，现在的定义更完备一些。</p>
</li>
<li>
<p>3个电梯停止状态S(U,e,f)、S(N,e,f)和S(D,e,f)已被组合成一个大的状态，这样做的目的是减少状态总数以简化流图。<br />
DC(e,f)：电梯e在楼层f关上门<br />
ST(e,f)：电梯e靠近f层时触发传感器，电梯控制器决定在当前楼层电梯是否停下<br />
RL：电梯按钮或楼层按钮被按下进入打开状态，登录需求</p>
</li>
</ul>
<h4 id="状态转移图-2"><a class="markdownIt-Anchor" href="#状态转移图-2"></a> 状态转移图</h4>
<p><img src="%5CMyImages%5Cimage-20200401202720158.png" alt="image-20200401202720158" /></p>
<h3 id="转移规则3"><a class="markdownIt-Anchor" href="#转移规则3"></a> 转移规则3</h3>
<p>最后，给出电梯的状态转换规则。为简单起见，这里给出的规则仅发生在关门之时。<br />
S(U,e,f)+DC(e,f)-&gt;M(U,e,f+1)<br />
S(D,e,f)+DC(e,f)-&gt;M(D,e,f-1)<br />
S(N,e,f)+DC(e,f)-&gt;W(e,f)<br />
第一条规则表明，如果电梯e停在f层准备向上移动，且门已经关闭，则电梯将向上一楼层移动。第二条和第三条规则，分别对应于电梯即将下降或者没有待处理的请求的情况</p>
<h2 id="评价"><a class="markdownIt-Anchor" href="#评价"></a> 评价</h2>
<p>有穷状态机方法采用了一种简单的格式来描述规格说明：<br />
当前状态+事件+谓词-&gt;下个状态</p>
<ul>
<li>这种形式的规格说明易于书写、易于验证，而且可以比较容易地把它转变成设计或程序代码。</li>
<li>有穷状态机方法比数据流图技术更精确，而且和它一样易于理解。</li>
<li>缺点：在开发一个大系统时三元组(即状态、事件、谓词)的数量会迅速增长。</li>
</ul>
<h1 id="petri网"><a class="markdownIt-Anchor" href="#petri网"></a> Petri网</h1>
<h2 id="概念-2"><a class="markdownIt-Anchor" href="#概念-2"></a> 概念</h2>
<ul>
<li><strong>定时问题</strong>：这个问题可以表现为多种形式，如同步问题﹑竞争条件以及死锁问题．定时问题通常是由不好的设计或者有错误的实现引起的，而这些的设计和实现通常又是由不好的规格说明造成的．</li>
<li><strong>Petri网</strong>：用于确定系统中隐含的定时问题的一种有效技术</li>
</ul>
<h3 id="petri网组成元素"><a class="markdownIt-Anchor" href="#petri网组成元素"></a> Petri网组成元素</h3>
<img src="\MyImages\image-20200401204203587.png" alt="image-20200401204203587" style="zoom: 50%;" />
<p>Petri网包含４种元素：一组位置P﹑一组转换T﹑输入函数I和输出函数O。Petri网的组成．其中：</p>
<ul>
<li>一组位置P，在图中用圆圈代表位置．</li>
<li>一组转换T，在图中用短直线表示转换．</li>
<li>两个用于转换的输入函数，用由位置指向转换的箭头表示，它们是：
<ul>
<li>I(t1)= {P2，P4}</li>
<li>I(t2)= {P2}</li>
</ul>
</li>
<li>两个用于转换的输出函数，用有转换指向位置的箭头表示，它们是：
<ul>
<li>O(t1)={P1}</li>
<li>O(t2)={P3，P3}</li>
</ul>
</li>
</ul>
<h4 id="形式化的petri网结构"><a class="markdownIt-Anchor" href="#形式化的petri网结构"></a> 形式化的Petri网结构</h4>
<p>是一个四元组C=(P,T,I,O)。其中，</p>
<ul>
<li>P={P1，…，Pn}是一个<strong>有穷位置集</strong>，n&gt;=0。</li>
<li>T={t1，…，tm}是一个<strong>有穷转换集</strong>，m&gt;=0，且T和P不相交。</li>
<li>I：T→P∞为<strong>输入函数</strong>，是由转换到位置无序单位组（bags）的映射。</li>
<li>O：T→P∞为<strong>输出函数</strong>，是由转换到位置无序单位组的映射。</li>
</ul>
<h2 id="举例"><a class="markdownIt-Anchor" href="#举例"></a> 举例</h2>
<img src="\MyImages\45.png" style="zoom:50%;" />
<h3 id="禁止线"><a class="markdownIt-Anchor" href="#禁止线"></a> 禁止线</h3>
<p>对Petri网的一个重要扩充是加入禁止线。如图所示，禁止线是用一个小圆圈而不是用箭头标记的输入线。通常，当每个输入线上至少有一个标权，而禁止线上没有标权，因此转换t1可以被激发</p>
<img src="\MyImages\image-20200401205113499.png" alt="image-20200401205113499" style="zoom: 67%;" />
<h2 id="动态转移特征"><a class="markdownIt-Anchor" href="#动态转移特征"></a> 动态转移特征</h2>
<p><strong>包括冲突、并发、碰撞、混惑</strong></p>
<img src="\MyImages\image-20200401205337693.png" alt="image-20200401205337693" style="zoom:67%;" />
<ul>
<li>
<p>图中的Petri网，只有p1中有一个标记，从这个给定的初始标识看，t1和t3都能发生，但不能同时发生，因为它们共享p1中的一个资源，<strong>这种现象叫做“冲突”</strong>（conflict）。</p>
</li>
<li>
<p>网论的观点认为，<strong>解决冲突的办法可以是，通过环境对系统进行控制</strong>。这里有两种可能：</p>
<ul>
<li>若t1发生，p1失去标记，p2获得标记，这时只有t2可以发生，之后标记回到p1。这时若再让t1发生，则会重复上述过程。</li>
<li>若让t3发生，p1失去标记，p3和p4同时各得一个标记。这时t4和t5都可以发生，且互不影响。<strong>网论中称这种现象为“并发”(concurrent)</strong></li>
<li>t4和t5发生以后，t6可以发生，使标记又回到p1，<strong>p6起着使t4和t5两个异步活动同步的作用。</strong></li>
</ul>
</li>
<li>
<p>如果让p1和p3各有一个标记，并规定位置容量均不能超过1，这时t3不能发生，因为t3的发生会使p3的容量超过1，<strong>称这种现象为“碰撞”（contact）。</strong></p>
</li>
<li>
<p>有时，一个Petri网中同时存在着并发和冲突，而且并发的实施会引起冲突的消失（减少）或出现（增加），<strong>我们称这种情况为“混惑”（confusion）。</strong></p>
</li>
</ul>
<h3 id="举例-2"><a class="markdownIt-Anchor" href="#举例-2"></a> 举例</h3>
<img src="\MyImages\image-20200401205827948.png" alt="image-20200401205827948" style="zoom:67%;" />
<p>在图示Petri网中，t1和t3是两个并发事件，如果t1实际上在t3之前发生，则t2不会发生冲突；反之，则发生冲突。所以存在着“混惑”的系统是不好的系统，因为在这种系统中，冲突忽隐忽现，使得外部环境对系统难以控制</p>
<h2 id="例子-2"><a class="markdownIt-Anchor" href="#例子-2"></a> 例子</h2>
<p>将Petri网用于上一节中的电梯问题</p>
<h3 id="电梯按钮"><a class="markdownIt-Anchor" href="#电梯按钮"></a> 电梯按钮</h3>
<ul>
<li>为了用Petri网表达电梯按钮的规格说明，在Petri网中还必须设置其他的位置。电梯中楼层f的按钮，在Petri网中用位置EBf表示(1≤f≤m)。在EBf上有一个权标，就表示电梯内楼层f的按钮被按下了。</li>
<li>电梯按钮只有在第一次被按下时才会由暗变亮，以后再按它则只会被忽略。如图所示Petri网准确地描述了电梯按钮的行为规律。
<ul>
<li>首先，假设按钮没有发亮，显然在位置EBf上没有权标，从而在存在禁止线的情况下，转换“EBf被按下”是允许发生的。假设现在按下按钮，则转换被激发并在EBf上放置了一个权标。</li>
<li>以后不论再按下多少次按钮，禁止线与现有权标的组合都决定了转换“EBf被按下”不能再被激发了，因此，位置EBf上的权标数不会多于1。</li>
</ul>
</li>
</ul>
<img src="\MyImages\image-20200401211228868.png" alt="image-20200401211228868" style="zoom: 50%;" />
<ul>
<li>假设电梯由g层驶向f层，因为电梯在g层，位置Fg上有一个权标。由于每条输入线上各有一个权标，转换“电梯在运行”被激发，从而EBf和Fg上的权标被移走，按钮EBf被关闭，在位置Ff上出现一个新权标，即转换的激发使电梯由g层驶到f层。
<ul>
<li>事实上，电梯由g层移到f层是需要时间的，为处理这个情况及其他类似的问题(例如，由于物理上的原因按钮被按下后不能马上发亮)，<strong>Petri网模型中必须加入时限</strong>。也就是说，在<strong>标准Petri网中转换是瞬时完成的</strong>，而在现实情况下就需要时间控制Petri网，以使转换与非零时间相联系。</li>
</ul>
</li>
</ul>
<h3 id="楼层按钮"><a class="markdownIt-Anchor" href="#楼层按钮"></a> 楼层按钮</h3>
<ul>
<li>
<p>第二条约束C2：除了第一层与顶层之外，每个楼层都有两个按钮，一个要求电梯上行，另一个要求电梯下行。这些按钮在按下时发亮，当电梯到达该层并将向指定方向移动时，相应的按钮才会熄灭。</p>
</li>
<li>
<p>在Petri网中楼层按钮用位置FBf<sup>u</sup>和FBf<sup>d</sup>表示，分别代表f楼层请求电梯上行和下行的按钮。底层的按钮为FB1<sup>u</sup>，最高层的按钮为FBm<sup>d</sup>，中间每一层有两个按钮FBf<sup>u</sup>和FBf<sup>d</sup>(1＜f＜m)。</p>
</li>
<li>
<p>第三条约束C3：当电梯没有收到请求时，它将停留在当前楼层并关门。</p>
</li>
</ul>
<img src="\MyImages\image-20200401211843454.png" alt="image-20200401211843454" style="zoom: 50%;" />
<ul>
<li>当没有请求(FBfu和FBfd上无权标）时，任何一个转换“电梯在运行”都不能被激发。</li>
<li>根据电梯乘客的要求，某一个楼层按钮亮或两个楼层按钮都亮。如果两个按钮都亮了，则只有一个按钮熄灭。图4.11所示的Petri网可以保证，当两个按钮都亮了的时候，只有一个按钮熄灭。但是要保证按钮熄灭正确，则需要更复杂的Petri网模型。</li>
</ul>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第9章面向对象方法学</title>
    <url>/2020/07/28/%E7%AC%AC9%E7%AB%A0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="软件开发面临的普遍性问题"><a class="markdownIt-Anchor" href="#软件开发面临的普遍性问题"></a> 软件开发面临的普遍性问题</h1>
<ul>
<li>软件开发面临的普遍性问题</li>
<li>应用的普及和深入对软件能力提出了更高要求</li>
<li>残酷的市场竞争对软件企业提出了更高要求</li>
<li>软件相对于硬件固有的弱势地位</li>
<li>软件开发技术落后的现实</li>
</ul>
<h1 id="面向对象技术对软件开发观念的影响"><a class="markdownIt-Anchor" href="#面向对象技术对软件开发观念的影响"></a> 面向对象技术对软件开发观念的影响</h1>
<ul>
<li>确定可行的软件工业化目标</li>
<li>采用以状态保持与转换为特征的计算模型</li>
<li>减少软件开发阶段之间的模型差异</li>
</ul>
<h1 id="面向对象方法"><a class="markdownIt-Anchor" href="#面向对象方法"></a> 面向对象方法</h1>
<h2 id="面向对象方法简介"><a class="markdownIt-Anchor" href="#面向对象方法简介"></a> 面向对象方法简介</h2>
<ul>
<li>面向对象方法学的<strong>出发点和基本原则，是尽可能模拟人类习惯的思维方式</strong>，使开发软件的方法与过程尽可能接近人类认识世界解决问题的方法与过程。</li>
</ul>
<h3 id="面向对象方法的四个要点"><a class="markdownIt-Anchor" href="#面向对象方法的四个要点"></a> 面向对象方法的四个要点</h3>
<ol>
<li>
<p><strong>认为客观世界是由各种对象组成的，任何事物都是对象</strong>，复杂的对象可以由比较简单的对象以某种方式组合而成。按照这种观点，可以认为整个世界就是一个最复杂的对象。</p>
</li>
<li>
<p><strong>把所有对象都划分成各种对象类</strong>(简称为类，Class)，每个对象类都定义了一组数据和一组方法。数据用于表示对象的静态属性，是对象的状态信息。</p>
</li>
<li>
<p><strong>按照子类(或称为派生类)与父类(或称为基类)的关系，把若干个对象类组成一个层次结构的系统</strong>(也称为类等级)。在这种层次结构中，通常下层的派生类具有和上层的基类相同的特性(包括数据和方法)，这种现象称为继承(Inheritance)。</p>
</li>
<li>
<p><strong>对象彼此之间仅能通过传递消息互相联系。<strong>对象与传统的数据有本质区别，它不是被动地等待外界对它施加操作，相反，它是进行处理的主体，必</strong>须发消息请求它执行它的某个操作，处理它的私有数据</strong>，而不能从外界直接对它的私有数据进行操作。</p>
</li>
</ol>
<h2 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h2>
<ul>
<li>与人类习惯的思维方式一致</li>
<li>稳定性好</li>
<li>可重用性好</li>
<li>可维护性好
<ul>
<li>面向对象的软件稳定性比较好</li>
<li>面向对象的软件比较容易修改</li>
<li>面向对象的软件比较容易理解</li>
<li>已于测试和调试</li>
</ul>
</li>
</ul>
<h2 id="面向对象建模"><a class="markdownIt-Anchor" href="#面向对象建模"></a> 面向对象建模</h2>
<ul>
<li>
<p>将问题通过面向对象的方法建立起类和对象的描述关系</p>
</li>
<li>
<p>包括三种模型</p>
<ul>
<li>描述静态的，结构化的系统的对象模型</li>
<li>描述系统控制结构的动态模型</li>
<li>描述系统功能的功能模型</li>
</ul>
</li>
</ul>
<h1 id="对象模型"><a class="markdownIt-Anchor" href="#对象模型"></a> 对象模型</h1>
<ul>
<li>表示静态的，结构化的系统的数据性质。它是对模拟客观世界实体的对象以及对象彼此间的关系的映射，描述了系统的静态结构。</li>
</ul>
<h2 id="表示类-对象的图形符号"><a class="markdownIt-Anchor" href="#表示类-对象的图形符号"></a> 表示类 &amp; 对象的图形符号</h2>
<h3 id="举例-课程注册管理系统的类图"><a class="markdownIt-Anchor" href="#举例-课程注册管理系统的类图"></a> 举例 课程注册管理系统的类图</h3>
<img src="\MyImages\image-20200522212225290.png" alt="image-20200522212225290" style="zoom:50%;" />
<h1 id="动态模型"><a class="markdownIt-Anchor" href="#动态模型"></a> 动态模型</h1>
<ul>
<li>动态模型表示瞬时的、行为化的系统的“控制”性质，它规定了对象模型中的对象的合法变化序列。</li>
</ul>
<h2 id="术语"><a class="markdownIt-Anchor" href="#术语"></a> 术语</h2>
<ul>
<li>
<p><strong>事件</strong>：是某个特定时刻所发生的事情，它是对引起对象从一种状态转换到另一种状态的现实世界中的事件的抽象。事件没有持续时间，是瞬间完成的。</p>
</li>
<li>
<p><strong>状态</strong>：状态就是对象在其生命周期中的某个特定阶段所处的某种情形，它是对影响对象行为的属性值的一种抽象</p>
</li>
</ul>
<h2 id="表示方法"><a class="markdownIt-Anchor" href="#表示方法"></a> 表示方法</h2>
<img src="\MyImages\image-20200522212636299.png" alt="image-20200522212636299" style="zoom: 50%;" />
<h3 id="举例"><a class="markdownIt-Anchor" href="#举例"></a> 举例</h3>
<ul>
<li>要求每个“课程设置”最多只能容纳50个选课学生</li>
</ul>
<img src="\MyImages\image-20200522212653992.png" alt="image-20200522212653992" style="zoom:50%;" />
<h1 id="功能模型"><a class="markdownIt-Anchor" href="#功能模型"></a> 功能模型</h1>
<ul>
<li>功能模型表示变化的系统的“功能”性质，它指明了系统应该“做什么”，因此更直接地反映了用户对目标系统的需求。</li>
</ul>
<h2 id="表示方法-2"><a class="markdownIt-Anchor" href="#表示方法-2"></a> 表示方法</h2>
<ul>
<li>
<p>通常使用数据流图</p>
</li>
<li>
<p>使用UML提供的用例图</p>
<img src="\MyImages\image-20200523100402347.png" alt="image-20200523100402347" style="zoom:50%;" />
</li>
</ul>
<h2 id="三种模型之间的关系"><a class="markdownIt-Anchor" href="#三种模型之间的关系"></a> 三种模型之间的关系</h2>
<p>面向对象建模技术所建立的三种模型，分别从三个不同侧面描述了所要开发的系统。这三种模型相互补充、相互配合，使得我们对系统的认识更加全面：</p>
<ul>
<li>功能模型指明了系统应该“做什么”；</li>
<li>动态模型明确规定了什么时候(即在何种状态下接受了什么事件的触发)做；</li>
<li>对象模型则定义了做事情的实体。</li>
</ul>
<h3 id="扼要叙述"><a class="markdownIt-Anchor" href="#扼要叙述"></a> 扼要叙述</h3>
<ol>
<li>
<p>针对每个类建立的动态模型，描述了类实例的生命周期或运行周期</p>
</li>
<li>
<p>状态转换驱使行为发生，这些行为在数据流图中被映射成处理，在用例图中被映射成用例，它们同时与类图中的服务相对应。</p>
</li>
<li>
<p>功能模型中的处理，对应于对象模型中类&amp;对象所提供的服务。有时一个处理对应多个服务，也有一个服务对应多个处理的时候。</p>
</li>
<li>
<p>数据流图中的数据存储，以及数据的源点/终点，通常是对象模型中的对象。</p>
</li>
<li>
<p>数据流图中的数据流，往往是对象模型中对象的属性值，也可能是整个对象。</p>
</li>
<li>
<p>用例图中的行为者，可能是对象模型中的对象。</p>
</li>
<li>
<p>功能模型中的处理（或用例）可能产生动态模型中的事件。</p>
</li>
<li>
<p>对象模型描述了数据流图中的数据流、数据存储以及数据源点/终点结构。</p>
</li>
</ol>
<h2 id="uml图分类"><a class="markdownIt-Anchor" href="#uml图分类"></a> UML图分类</h2>
<p>1、用例图：从外部用户的角度描述系统的功能，并指出功能的执行者。<br />
2、静态图：描述系统的静态结构。<br />
<strong>.类图</strong><br />
.对象图<br />
.包图<br />
3、行为图：刻画系统的动态行为。<br />
.交互图(顺序图与合作图)<br />
<strong>.状态图</strong><br />
.活动图<br />
4、实现图：描述软件实现系统的组成和分布状况。<br />
.构件图<br />
.部署图</p>
<h1 id="面向对象补充"><a class="markdownIt-Anchor" href="#面向对象补充"></a> 面向对象补充</h1>
<h2 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h2>
<h3 id="类间关系"><a class="markdownIt-Anchor" href="#类间关系"></a> 类间关系</h3>
<ul>
<li>类之间的关系通常有关联、泛化（继承）、依赖和细化等4种关系</li>
</ul>
<h4 id="关联"><a class="markdownIt-Anchor" href="#关联"></a> 关联</h4>
<ul>
<li>
<p>包括普通关联、限定关联、关联类</p>
</li>
<li>
<p><strong>普通关联</strong>表示</p>
<ul>
<li>
<p>0…1：    表示0到1个对象；</p>
</li>
<li>
<p>0…<em>或</em>： 表示0到多个对象；</p>
</li>
<li>
<p>1+或1…*：表示1到多个对象；</p>
</li>
<li>
<p>1…15：   表示1到15个对象；</p>
</li>
<li>
<p>3：		表示3个对象。</p>
</li>
<li>
<p>举例</p>
<img src="\MyImages\image-20200523102908349.png" alt="image-20200523102908349" style="zoom:50%;" />
</li>
</ul>
</li>
<li>
<p><strong>限定关联</strong>通常用在一对多或多对多的关联关系中，可以把模型中的重数从一对多变成一对一，或将多对多简化成多对一</p>
<img src="\MyImages\image-20200523103122400.png" alt="image-20200523103122400" style="zoom: 50%;" />
<ul>
<li>在类图中把限定词放在关联关系末端的一个小方框内</li>
</ul>
</li>
<li>
<p><strong>关联类</strong>为了说明关联的性质，我们还可以增加一些附加信息。这样可以引入关联类来记录这些信息。关联中的每个连接与关联类的一个对象相联系。关联类通过一条虚线与关联连接。</p>
<img src="\MyImages\image-20200523103619238.png" alt="image-20200523103619238" style="zoom:50%;" />
</li>
</ul>
<h4 id="聚集"><a class="markdownIt-Anchor" href="#聚集"></a> 聚集</h4>
<ul>
<li>
<p><strong>聚集</strong>是关联的特例。聚集所表示的类之间的关系是<strong>整体与部分的关系</strong>。常常会使用的“包含”、“组成”、“分为……部分”等字句。包括共享聚集和组合聚集</p>
</li>
<li>
<p><strong>共享聚集</strong>如果在聚集关系中处于部分方的对象可同时参与多个处于整体方对象的构成，则该聚集称为共享聚集</p>
<img src="\MyImages\image-20200523103943061.png" alt="image-20200523103943061" style="zoom:50%;" />
</li>
<li>
<p><strong>组合聚集</strong>如果部分类完全隶属于整体类，部分类需要与整体类共存，一旦整体类不存在了，则部分类也会随之消失，或失去存在价值，则称该聚集称为组合聚集</p>
<img src="\MyImages\image-20200523104045481.png" alt="image-20200523104045481" style="zoom:50%;" />
</li>
</ul>
<h4 id="泛化"><a class="markdownIt-Anchor" href="#泛化"></a> 泛化</h4>
<ul>
<li>关系就是通常所说的继承关系，它是通用元素和具体元素之间的一种分类关系。具体元素完全拥有通用元素的信息，并且还可以附加一些其他信息。泛化可分成普通泛化和受限泛化两类。</li>
<li>抽象类通常具有抽象操作，抽象操作仅用来指定该抽象类的所有子类应该具有哪些行为</li>
</ul>
 <img src="\MyImages\image-20200523110426605.png" alt="image-20200523110426605" style="zoom:50%;" />
<h4 id="约束"><a class="markdownIt-Anchor" href="#约束"></a> 约束</h4>
<ul>
<li>对泛化关系，我们可以增加约束条件，以进一步说明该泛化关系的使用方法或扩充方法，这样的泛化关系称为受限泛化。</li>
<li>预定义的约束有4种： 多重、不相交、完全和不完全。这些约束都是语义约束。
<ul>
<li><strong>多重继承</strong>指的是，一个子类可同时多次继承同一个上层基类.</li>
<li>与多重继承相反的是<strong>单继承</strong>，即一个子类不能多次继承同一个基类。一般的继承都是单继承。</li>
<li><strong>完全继承</strong>是父类的所有子类都已在类图中穷举出来了。</li>
<li><strong>不完全继承</strong>则相反，父类的子类并没有都穷举出来，随着对问题理解的深入，可不断补充和维护，这为日后系统的扩充和维护带来很大方便。不完全继承是一般情况下默认的继承关系。</li>
</ul>
</li>
</ul>
<h4 id="依赖"><a class="markdownIt-Anchor" href="#依赖"></a> 依赖</h4>
<p><strong>依赖关系</strong>描述两个模型元素（类、用例等）之间的语义连接关系：其中一个模型元素是独立的，另一个模型元素不是独立的，它依赖于独立的模型元素，如果独立的模型元素改变了，将影响依赖于它的模型元素。</p>
<h3 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h3>
<p>实例就是由某个特定类所描述的一个具体对象。对象是类的实际例子，通常称为实例</p>
<h3 id="消息"><a class="markdownIt-Anchor" href="#消息"></a> 消息</h3>
<p>消息是一个对象与另一个对象之间交互的手段，它要求某个对象执行类中定义的某个操作的规格说明。</p>
<h3 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h3>
<p>方法是对象所能执行的操作，即类中所定义的服务或操作。方法描述了对象执行操作的算法，以及响应消息的方法</p>
<h3 id="属性"><a class="markdownIt-Anchor" href="#属性"></a> 属性</h3>
<p>属性是类中定义的数据，它是对客观世界实体所具有性质的抽象。类的<strong>每个实例都有自己特有的属性值。</strong></p>
<ul>
<li>可见性  属性名： 类型名=初值{性质串}
<ul>
<li>属性的可见性（即可访问性）通常有下述3种：<strong>公有的(public)、私有的(private)和保护的(protected)，分别用加号（+）、减号（-）和井号（#）表示</strong>。如果未声明可见性，则表示该属性的可见性尚未定义。</li>
<li>属性名和类型名之间用冒号（：）分隔。类型名表示该属性的数据类型，它可以是基本数据类型，也可以是用户自定义的类型。</li>
</ul>
</li>
</ul>
<h3 id="类图举例"><a class="markdownIt-Anchor" href="#类图举例"></a> 类图举例</h3>
<img src="\MyImages\image-20200523112414497.png" alt="image-20200523112414497" style="zoom:50%;" />
<h3 id="封装"><a class="markdownIt-Anchor" href="#封装"></a> 封装</h3>
<p>**封装就是信息隐藏，通过封装对外界隐藏了对象的实现细节。**这样，使用一个对象时，只需知道它向外界提供的接口形式，无须知道它的数据结构细节和实现操作的算法。</p>
<h3 id="多态性"><a class="markdownIt-Anchor" href="#多态性"></a> 多态性</h3>
<p>多态性(polymorphism) ：<strong>多态性是指同样的消息既可以发送给父类对象也可以发送给子类对象，即在类等级的不同层次中可以共享一个方法的名字，不同层次中的每个类按自己的需要来实现这个行为</strong>。在C++语言中，多态性是通过虚函数来实现的。</p>
<h3 id="重载"><a class="markdownIt-Anchor" href="#重载"></a> 重载</h3>
<ul>
<li><strong>重载</strong>分为函数重载和运算符重载。</li>
<li><strong>函数重载</strong>是指在同一作用域内的若干个参数特征不同的函数可以使用相同的函数名字。</li>
<li><strong>运算符重载</strong>是指同一个运算符可以施加于不同类型的操作数上面。重</li>
</ul>
<h1 id="uml"><a class="markdownIt-Anchor" href="#uml"></a> UML</h1>
<ul>
<li>在UML中使用<strong>类图表示对象模型</strong>，使用对象、属性、关联和操作来描述系统的结构。</li>
<li>在UML中使用<strong>用例图表示功能模型</strong>，以从用户观点上描述系统功能。</li>
<li>在UML中使用<strong>交互图、状态图和活动图表示动态模型</strong>，以描述系统的内部行为。</li>
</ul>
<h2 id="用例图"><a class="markdownIt-Anchor" href="#用例图"></a> 用例图</h2>
<ul>
<li>用例图（use case diagram）在需求获取和分析过程中使用，以表示系统功能。<strong>每个功能点要做一个用例图</strong></li>
<li>一幅用例图包含的模型元素有<strong>系统、行为者(actor)、用例及用例之间的关系</strong>。</li>
<li>一个<strong>角色</strong>可以描述与该系统交互的任意实体（例如：一个用户、另一个系统、该系统的物理环境）</li>
</ul>
<img src="\MyImages\image-20200523115116760.png" alt="image-20200523115116760" style="zoom: 50%;" />
<img src="\MyImages\image-20200523115150462.png" alt="image-20200523115150462" style="zoom:50%;" />
<h3 id="系统"><a class="markdownIt-Anchor" href="#系统"></a> 系统</h3>
<p>系统被看作一个提供用例的黑盒子，而黑盒子内部如何工作、用例如何实现，这些对于建立用例模型来说都是不重要的。</p>
<h3 id="用例"><a class="markdownIt-Anchor" href="#用例"></a> 用例</h3>
<ul>
<li>
<p>一个<strong>用例</strong>是能够被行为者感受到的、<strong>系统将完成的一个完整功能</strong></p>
</li>
<li>
<p>用例通过关联与行为者连接，关联指出一个用例与哪些行为者交互，这种交互是双向的</p>
</li>
<li>
<p><strong>特征</strong></p>
<ul>
<li>用例代表某些用户可见的功能，以实现一个具体的用户目标；</li>
<li>用例总是被行为者启动的，并向行为者提供可识别的值；</li>
<li>用例必须是完整的。</li>
</ul>
</li>
<li>
<p><strong>注意</strong>：用例是一个类，代表一类功能而不是使用该功能的某个实例</p>
</li>
</ul>
<h3 id="行为者"><a class="markdownIt-Anchor" href="#行为者"></a> 行为者</h3>
<ul>
<li>行为者（actor）是指与系统交互的人或其他系统，它代表外部实体。使用用例并且与系统交互的任何人或物都是行为者。</li>
<li><strong>行为者代表一种角色，而不是某个具体的人或物</strong>。事实上，一个具体的人可以充当多种不同角色。</li>
<li>行为者触发（激活）用例，并与用例交换信息</li>
</ul>
<h3 id="场景"><a class="markdownIt-Anchor" href="#场景"></a> 场景</h3>
<ul>
<li>一个用例是描述相关功能的所有可能场景的抽象</li>
</ul>
<h3 id="用例之间的关系"><a class="markdownIt-Anchor" href="#用例之间的关系"></a> 用例之间的关系</h3>
<ul>
<li>UML用例之间主要有扩展和使用两种关系，它们是泛化关系的两种不同形式</li>
</ul>
<h4 id="扩展关系"><a class="markdownIt-Anchor" href="#扩展关系"></a> <strong>扩展关系</strong></h4>
<p><strong>向一个用例中添加一些动作后构成了另一个用例，这两个用例之间的关系就是扩展关系</strong>，后者继承前者的一些行为，通常把后者称为扩展用例。我理解为进一步解释，细化</p>
  <img src="\MyImages\image-20200523120655560.png" alt="image-20200523120655560" style="zoom:50%;" />
<ul>
<li>为了将功能说清楚一点</li>
</ul>
<h4 id="使用关系"><a class="markdownIt-Anchor" href="#使用关系"></a> 使用关系</h4>
<ul>
<li>当一个用例使用另一个用例时，这两个用例之间就构成了使用关系。</li>
<li>一般将动作提取出来作为抽象用例</li>
</ul>
<h4 id="扩展关系-使用关系"><a class="markdownIt-Anchor" href="#扩展关系-使用关系"></a> 扩展关系 &amp; 使用关系</h4>
<ul>
<li>相同：这两种关系都意味着从几个用例中<strong>抽取那些公共的行为</strong>并放入一个单独的用例中，而这个用例被其他用例使用或扩展。</li>
<li>不同：<strong>目的是不同的</strong>。通常在描述一般<strong>行为的变化时采用扩展关系</strong>；在两个或多个用例中出现重复描述又想<strong>避免这种重复时，可以采用使用关系。</strong></li>
</ul>
<h3 id="用例模型建模过程"><a class="markdownIt-Anchor" href="#用例模型建模过程"></a> 用例模型建模过程</h3>
<ul>
<li>需求分析阶段产生。每个用例都是对系统的一个潜在的需求</li>
<li>工作包括：定义系统，寻找行为者和用例，描述用例，定义用例之间的关系，确认模型。</li>
</ul>
<h4 id="1-寻找行为者"><a class="markdownIt-Anchor" href="#1-寻找行为者"></a> 1. 寻找行为者</h4>
<p>可以通过请系统的用户回答一些问题的办法来发现行为者。下述问题有助于发现行为者：<br />
 谁将使用系统的主要功能（主行为者）？<br />
 谁需要借助系统的支持来完成日常工作？<br />
 谁来维护和管理系统（辅助行为者）？<br />
 系统控制哪些硬件设备？<br />
 系统需要与哪些其他系统交互？<br />
 哪些人或系统对本系统产生的结果（值）感兴趣？</p>
<h4 id="2-寻找用例"><a class="markdownIt-Anchor" href="#2-寻找用例"></a> 2. 寻找用例</h4>
<p>可以通过请系统的用户回答一些问题的办法来发现行为者。下述问题有助于发现行为者：<br />
 谁将使用系统的主要功能（主行为者）？<br />
 谁需要借助系统的支持来完成日常工作？<br />
 谁来维护和管理系统（辅助行为者）？<br />
 系统控制哪些硬件设备？<br />
 系统需要与哪些其他系统交互？<br />
 哪些人或系统对本系统产生的结果（值）感兴趣？</p>
<p> 系统需要那些输入输出？输入来自何处？输出去往哪里？</p>
<h2 id="类图"><a class="markdownIt-Anchor" href="#类图"></a> 类图</h2>
<img src="\MyImages\image-20200622115930059.png" alt="image-20200622115930059" style="zoom:50%;" />	
<h2 id="交互图"><a class="markdownIt-Anchor" href="#交互图"></a> 交互图</h2>
<ul>
<li>交互图(interaction diagram)用于描述系统形式化的动态行为，交互图也可以用可视化方式描述对象之间的通信。<strong>交互图关注对象之间的信息交换</strong></li>
<li>我们将包含在用例中的对象称为参与对象。<strong>一个交互图表示了发生在这些对象之间的交互。</strong></li>
<li>例从上方卫星表用例图</li>
</ul>
<img src="\MyImages\image-20200622120107886.png" alt="image-20200622120107886" style="zoom: 50%;" />
<ul>
<li>图中<strong>最左栏表示了卫星表用户角色的时间线</strong>，该角色启动用例。</li>
<li>其它栏目代表参与到这一用例的对象时间线。<strong>对象名用下划线表示</strong>，以说明它们是实例（与类不同）。</li>
<li>带标号的<strong>箭头表示一个角色或一个对象向另一个对象发送的激励</strong>。在这种情况下，卫星表用户按下按钮1两次，按下按钮2一次，就可以设置其卫星表的分针。</li>
</ul>
<h2 id="状态图"><a class="markdownIt-Anchor" href="#状态图"></a> 状态图</h2>
<ul>
<li>
<p>用多个状态以及这些状态之间的迁移描述了单个对象的<strong>动态行为</strong>。</p>
</li>
<li>
<p><strong>一个状态代表一个对象值的特定集合</strong>。状态图关注状态之间的迁移，其结果时由一个独立对象产生了外部事件</p>
</li>
</ul>
<h3 id="举例-2"><a class="markdownIt-Anchor" href="#举例-2"></a> 举例</h3>
<img src="\MyImages\image-20200622121620021.png" alt="image-20200622121620021" style="zoom:50%;" />
<ul>
<li>一个状态是对象属性满足的条件。</li>
<li>一个迁移表示由事件、条件或时间触发后的状态改变。</li>
<li>一个<strong>状态用一个圆角矩形表示</strong>。一个<strong>迁移通过连接两个状态的开箭头表示</strong>。状态用其名字表示。一个小型实心黑圆表示了初始状态。一个套有小型实心黑圆的圆表示了终止状态。</li>
<li><strong>动作是原子行为</strong>，该**原子行为在状态机中的特定点上执行。**原子活动的执行只需要一小段时间且执行不可中断。</li>
<li>**内部迁移是一个未离开该状态的迁移。**触发内部迁移事件，可以产生与这些事件相关联的活动。但一个内部迁移的激活不会导致任何进入或退出活动的执行。</li>
<li>一个<strong>活动是对象只有驻留在某些状态上执行的行为</strong>。</li>
<li><strong>动作 &amp; 活动</strong>：
<ul>
<li>一个动作的执行时间短且是不可中断的，一个活动的执行需要一段时间且其执行时是可以中断的，其中断的时机是在一个退出迁移的状态被触发时。</li>
</ul>
</li>
</ul>
<h2 id="活动图"><a class="markdownIt-Anchor" href="#活动图"></a> 活动图</h2>
<ul>
<li>活动图(activity diagram)利<strong>用活动描述了一个系统的行为</strong>。</li>
<li>活动是建模的元素，以<strong>表示操作集合的执行</strong>。这些操作完成后，会触发迁移以转到另一活动上。</li>
</ul>
<h3 id="举例-3"><a class="markdownIt-Anchor" href="#举例-3"></a> 举例</h3>
<img src="\MyImages\image-20200622122153294.png" alt="image-20200622122153294" style="zoom:50%;" />
<ul>
<li>活动图中的圆角矩形表示活动；</li>
<li>箭头表示活动之间的迁移；</li>
<li>粗短棒表示控制流同步。</li>
</ul>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程目录</title>
    <url>/2020/07/28/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="第2章可行性研究"><a class="markdownIt-Anchor" href="#第2章可行性研究"></a> <a href="/2020/07/28/%E7%AC%AC2%E7%AB%A0%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6/">第2章可行性研究</a></h2>
<p><img src="/MyImages/2%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90.png" alt="2可行性分析" /></p>
<h2 id="第3章需求分析"><a class="markdownIt-Anchor" href="#第3章需求分析"></a> <a href="/2020/07/28/%E7%AC%AC3%E7%AB%A0%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/">第3章需求分析</a></h2>
<p><img src="/MyImages/3%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90.png" alt="3需求分析" /></p>
<h2 id="第4章形式化说明技术"><a class="markdownIt-Anchor" href="#第4章形式化说明技术"></a> <a href="/2020/07/28/%E7%AC%AC4%E7%AB%A0%E5%BD%A2%E5%BC%8F%E5%8C%96%E8%AF%B4%E6%98%8E%E6%8A%80%E6%9C%AF/">第4章形式化说明技术</a></h2>
<p><img src="/MyImages/4%E5%BD%A2%E5%BC%8F%E5%8C%96%E8%AF%B4%E6%98%8E%E6%8A%80%E6%9C%AF.png" alt="4形式化说明技术" /></p>
<h2 id="第5章总体设计"><a class="markdownIt-Anchor" href="#第5章总体设计"></a> <a href="/2020/07/28/%E7%AC%AC5%E7%AB%A0%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1/">第5章总体设计</a></h2>
<p><img src="/MyImages/5%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1.png" alt="5总体设计" /></p>
<h2 id="第6章详细设计"><a class="markdownIt-Anchor" href="#第6章详细设计"></a> <a href="/2020/07/28/%E7%AC%AC6%E7%AB%A0%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/">第6章详细设计</a></h2>
<p><img src="/MyImages/6%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1.png" alt="6详细设计" /></p>
<h2 id="第7章实现"><a class="markdownIt-Anchor" href="#第7章实现"></a> <a href="/2020/07/28/%E7%AC%AC7%E7%AB%A0%E5%AE%9E%E7%8E%B0/">第7章实现</a></h2>
<p><img src="/MyImages/7.1%E5%AE%9E%E7%8E%B0.png" alt="7.1实现" /></p>
<p><img src="/MyImages/7.2%E6%B5%8B%E8%AF%95.png" alt="7.2测试" /></p>
<p><img src="/MyImages/7.3%E8%B0%83%E8%AF%95%EF%BC%88%E7%BA%A0%E9%94%99%EF%BC%89%E6%8A%80%E6%9C%AF.png" alt="7.3调试（纠错）技术" /></p>
<h2 id="第9章面向对象方法学"><a class="markdownIt-Anchor" href="#第9章面向对象方法学"></a> <a href="/2020/07/28/%E7%AC%AC9%E7%AB%A0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E5%AD%A6/">第9章面向对象方法学</a></h2>
<p><img src="/MyImages/9%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95.png" alt="9面向对象方法" /></p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第7章实现</title>
    <url>/2020/07/28/%E7%AC%AC7%E7%AB%A0%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="程序设计语言"><a class="markdownIt-Anchor" href="#程序设计语言"></a> 程序设计语言</h1>
<h2 id="程序设计语言特点与特性"><a class="markdownIt-Anchor" href="#程序设计语言特点与特性"></a> 程序设计语言特点与特性</h2>
<h3 id="程序设计语言的心理学观点"><a class="markdownIt-Anchor" href="#程序设计语言的心理学观点"></a> 程序设计语言的心理学观点</h3>
<ul>
<li><strong>一致性</strong>：是表示某种语言使用一致的符号,采用看似任意的限制和支持语法或语义例外规则的程度。</li>
<li><strong>多义性</strong>：编程语言的多义性是程序员的理解。一般一条语句一个解释。有时却有多种解释 。</li>
<li><strong>紧凑性</strong>：代表语言的表达能力</li>
<li><strong>局域性</strong>：是编程语言的综合特性，当语句可以组合为程序块,结构化构造可以直接实现,设计代码和合成代码具有高的模块性和聚合时,局域性就高.</li>
<li><strong>线性</strong>：是一种心理特性．它与保持功能域的概念紧密联系。即当遇到一个逻辑运算线性序列时,人容易理解,外延分支和外延大的循环都违反处理的线性,而结构化构造的直接实现有助于编程语言的线性。</li>
</ul>
<h3 id="程序设计语言的工程学观点"><a class="markdownIt-Anchor" href="#程序设计语言的工程学观点"></a> 程序设计语言的工程学观点</h3>
<ul>
<li>易于把设计翻译为代码</li>
<li>编译器效率</li>
<li>源代码的可移植性</li>
<li>开发工具的可用性</li>
<li>可维护性</li>
</ul>
<h3 id="选择一种语言"><a class="markdownIt-Anchor" href="#选择一种语言"></a> 选择一种语言</h3>
<p>用于评价语言的准则</p>
<p>(1)   一般的应用领域<br />
(2)   算法和计算的复杂性<br />
(3)   软件运行环境<br />
(4)   性能考虑<br />
(5)   数据结构的复杂性<br />
(6)   软件开发人员的知识<br />
(7)   一个好的编译器或交叉编译器的可使用性．</p>
<h2 id="程序设计途径与编写程序的风格"><a class="markdownIt-Anchor" href="#程序设计途径与编写程序的风格"></a> 程序设计途径与编写程序的风格</h2>
<h3 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h3>
<ul>
<li>自上而下：程序可读性好,可靠性高。</li>
<li>自下而上：局部优化：系统整体性差,但能及时发现算法是否可行,返工性好。</li>
</ul>
<h3 id="程序设计工具"><a class="markdownIt-Anchor" href="#程序设计工具"></a> 程序设计工具</h3>
<ul>
<li>编译程序</li>
<li>代码管理系统</li>
</ul>
<h3 id="编码风格"><a class="markdownIt-Anchor" href="#编码风格"></a> 编码风格</h3>
<p>编码风格实际上是一种编码原则</p>
<h3 id="代码文档化"><a class="markdownIt-Anchor" href="#代码文档化"></a> 代码文档化</h3>
<ul>
<li>代码文档化是从选择标识符（变量、标号）的名字开始，接着是写程序和安排注释，最后是程序的整个组织形式的视觉。</li>
</ul>
<h3 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h3>
<ul>
<li>
<p>序言性注释：应该安排在每个模块的起始部分</p>
<p>​			   （1）  说明每个模块的用途，并指明它的功能<br />
​               （2）  接口描述，应包括：调用序列，每个参数的描述，以及所有从属模块清单。<br />
​               （3） 有关数据的讨论，包括：重要的变量和它们的用途、限制或约束条件，以及其他必要的信息。<br />
​               （4）  开发历史，包括：模块设计人姓名，评审人姓名及日期、修改说明及日期。</p>
</li>
<li>
<p>功能性注释：应嵌入在源代码体内，用来描述处理功能。书写这种注释的基本原则是：注释要解释程序代码，还应提供附加说明。此外，注释还应做到以下几点：<br />
（1） 注释是说明代码块，而不是注释每一行代码。<br />
（2） 使用空行或缩格，以便很容易的区分注释和代码<br />
（3） 注释一定要正确，以免引起错误，造成误解。</p>
</li>
</ul>
<h3 id="语言构造"><a class="markdownIt-Anchor" href="#语言构造"></a> 语言构造</h3>
<ul>
<li>每条语句应当简单而直接，同时也不应为了追求运行效率而使代码变得复杂化，而让人难以理解。</li>
</ul>
<h3 id="io"><a class="markdownIt-Anchor" href="#io"></a> I/O</h3>
<p>I/O的风格不是在编码时确定的，而是在软件需求分析和实际中就确定了的。但是，在编码时，I/O的实现方式决定了用户对系统特征的可接受程度。</p>
<h3 id="效率"><a class="markdownIt-Anchor" href="#效率"></a> 效率</h3>
<ul>
<li><strong>代码效率</strong>：源代码的效率与详细设计阶段所确定的算法效率直接相关。但编码风格也会影响运行速度和对内存的需要。</li>
<li><strong>内存效率</strong>：在大型计算机和工作站领域中，内存限制大多已是过去的事了。低成本内存提供了大的物理地址空间，而虚存管理为应用软件提供了巨大的逻辑地址空间，对于这样的环境，内存效率不等于使用最小内存。</li>
</ul>
<h2 id="保护性编程"><a class="markdownIt-Anchor" href="#保护性编程"></a> 保护性编程</h2>
<h3 id="主动保护"><a class="markdownIt-Anchor" href="#主动保护"></a> 主动保护</h3>
<p>主动保护技术周期性的或在空闲时间对整个程序或数据库进行搜索，用以发现异常情况。</p>
<h3 id="被动保护"><a class="markdownIt-Anchor" href="#被动保护"></a> 被动保护</h3>
<p>被动保护技术是在到达检查代码时，对程序的某些部分进行检查。</p>
<h2 id="冗余编程"><a class="markdownIt-Anchor" href="#冗余编程"></a> 冗余编程</h2>
<ul>
<li>
<p>**冗余（redundant）**是改善系统可靠性的一种重要技术。对于硬件，即提供额外的元件或系统，使其与原始系统并行工作。在某些情况下，其连接是使所有的元件并行工作。</p>
</li>
<li>
<p>作用</p>
<ul>
<li>保证系统可靠性</li>
<li>提高系统容错性</li>
</ul>
</li>
</ul>
<h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1>
<ul>
<li>测试的目的：是尽可能多的发现并排除软件中的错误。国际上惯用α测试和β测试。</li>
</ul>
<h2 id="黑盒测试"><a class="markdownIt-Anchor" href="#黑盒测试"></a> 黑盒测试</h2>
<ul>
<li><strong>黑盒测试</strong>：又称为功能测试，典型的β测试</li>
</ul>
<p>①  完全不考虑程序内部结构和处理过程。<br />
②  具体是在程序接口进行测试，它只检查程序功能是否按照规格说明书的规定进行，程序能否适当地接受输入数据，产生正确的输出信息并且保持外部信息（数据库、文件）的完整性。</p>
<h2 id="白盒测试"><a class="markdownIt-Anchor" href="#白盒测试"></a> 白盒测试</h2>
<ul>
<li><strong>白盒测试</strong>：由称为结构测试，典型的α测试</li>
</ul>
<p>①  进行逻辑测试，它完全了解结构及处理过程。<br />
②  按照程序内部的逻辑测试程序，检查程序中每条通路是否都能按预定要求正确工作。</p>
<h2 id="测试原则"><a class="markdownIt-Anchor" href="#测试原则"></a> 测试原则</h2>
<p>（1）<strong>回避原则</strong>：程序员或程序设计机构不应该测试自己设计的程序（采用客观态度比较难，自己测效率低）<br />
（2）<strong>测试用例的设计</strong>不仅要有确定的输入数据，而且要有确定预期输出的详细数据。</p>
<p>（3）测试用例的设计不仅要有合理的输入数据，<strong>还要有不合理的输入数据</strong>。<br />
（4）除了检查程序是否做完了它应作的事之外，<strong>还要检查它是否做了不应该做的事</strong>。<br />
（5）<strong>保留全部测试用例</strong>，并作为软件的组成部分之一。<br />
（6）程序中<strong>存在错误的概率与在该程序中已发现的错误数成正比</strong>。例如，用户的错误有47%集中在4%的模块中，但这些现象告诉我们，为了提高测试效率，要集中对付那些容易出错的程序段。</p>
<h3 id="测试阶段的信息流"><a class="markdownIt-Anchor" href="#测试阶段的信息流"></a> 测试阶段的信息流</h3>
<img src="\MyImages\image-20200512151209769.png" alt="image-20200512151209769" style="zoom:50%;" />
<h1 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h1>
<ul>
<li>单元测试是针对模块，它不是一个独立的程序。因此，模块自己不能运行，要靠其它部分来调动和驱动，这样就要为每个单元测试开发两个软件：驱动程序和连接程序。</li>
</ul>
<h2 id="单元测试内容"><a class="markdownIt-Anchor" href="#单元测试内容"></a> 单元测试内容</h2>
<h3 id="模块接口"><a class="markdownIt-Anchor" href="#模块接口"></a> 模块接口</h3>
<ul>
<li>测试输入输出是否正确，规范</li>
</ul>
<h3 id="局部数据结构"><a class="markdownIt-Anchor" href="#局部数据结构"></a> 局部数据结构</h3>
<p>主要错误来源<br />
①  不正确或不一致的说明<br />
②  错误的初始化或错误的缺省值<br />
③  拼写错误或截短的变量名<br />
④  上溢、下溢错误<br />
⑤  不一致的数据类型</p>
<h3 id="重要的执行路径"><a class="markdownIt-Anchor" href="#重要的执行路径"></a> 重要的执行路径</h3>
<p>计算中比较常见的错误<br />
①  算术运算优先次序不正确或理解错误<br />
②  运算方式不正确<br />
③  初始化不正确<br />
④  精度不够<br />
⑤  表达式符号表示错误</p>
<h3 id="边界测试"><a class="markdownIt-Anchor" href="#边界测试"></a> 边界测试</h3>
<p>软件通常容易在边界上出错，比如一个n位数组，当处理数组的第n个元素时，或M次循环在遇到第M次重复时，都常常发生错误。就是说使用数据流、控制流，当刚好等于、小于、或大于最大值或最小值的数据时，非常可能发生错误。</p>
<h2 id="计算机测试"><a class="markdownIt-Anchor" href="#计算机测试"></a> 计算机测试</h2>
<h3 id="驱动程序"><a class="markdownIt-Anchor" href="#驱动程序"></a> 驱动程序</h3>
<p>它实际上相当于一个程序，它接受不同的测试用例的数据，并把这些数据传送给测试模块，最后打印结果，即通常所讲设计一个测试路径。（<strong>单元测试主控程序</strong>）</p>
<h3 id="连接程序"><a class="markdownIt-Anchor" href="#连接程序"></a> 连接程序</h3>
<ul>
<li>连接程序是被驱动程序调用的部分</li>
<li>连接程序用来代替被测模块所调用的模块。
<ul>
<li>单元测试相当于分调，组装测试相当于联调</li>
<li>确认测试相当于黑盒测试，相当于考机</li>
</ul>
</li>
</ul>
<h2 id="单元测试过程"><a class="markdownIt-Anchor" href="#单元测试过程"></a> 单元测试过程</h2>
<h3 id="代码审查"><a class="markdownIt-Anchor" href="#代码审查"></a> 代码审查</h3>
<p>优缺点</p>
<ul>
<li>一次可以发现多处错误</li>
<li>采用代码审查可减少系统验证的总工作量</li>
</ul>
<h3 id="测试软件"><a class="markdownIt-Anchor" href="#测试软件"></a> 测试软件</h3>
<ul>
<li>驱动、存根程序是单元测试必须编写的测试软件（是开销），但不交给用户，模块的内聚程度高可以简化<strong>单元测试</strong>过程。</li>
<li><strong>集成测试</strong>：是组装软件的系统技术。</li>
</ul>
<h1 id="集成测试"><a class="markdownIt-Anchor" href="#集成测试"></a> 集成测试</h1>
<ul>
<li>自顶而下集成：称为渐增测试:一个要测模块与已测试好的结合测试；</li>
<li>自底向上集成：非渐增测试：分别测试每个模块，再把所有模块按设计要求结合。</li>
</ul>
<img src="\MyImages\image-20200512175439082.png" alt="image-20200512175439082" style="zoom: 50%;" />
<h2 id="自顶而下结合"><a class="markdownIt-Anchor" href="#自顶而下结合"></a> 自顶而下结合</h2>
<ul>
<li>
<p>自顶而下结合是从主模块（主程序）开始，沿控制层次向下移动，逐步结合每个模块。</p>
</li>
<li>
<p>步骤</p>
</li>
</ul>
<p>1  以主控模块作为测试驱动模块，把对主控模块进行单元测试时引入的所有桩模块用实际模块替代；</p>
<p>2  依据所选的集成策略（深度优先或广度优先），每次只替代一个桩模块；</p>
<p>3  每集成一个模块立即测试一遍；</p>
<p>4  只有每组测试完成后，才着手替换下一个桩模块；</p>
<p>5  为避免引入新错误，须不断地进行回归测试（即全部或部分地重复已做过的测试）。</p>
<h2 id="自底向上结合"><a class="markdownIt-Anchor" href="#自底向上结合"></a> 自底向上结合</h2>
<ul>
<li>
<p>自底向上测试是从“原子”模块（即软件结构最低层的模块）开始组装测试，因测试到较高层模块时，所需的下层模块功能均已具备，所以不再需要桩模块。</p>
</li>
<li>
<p>步骤</p>
</li>
</ul>
<p>1 把低层模块组织成实现某个子功能的模块群（cluster）;</p>
<p>2 开发一个测试驱动模块，控制测试数据的输入和测试结果的输出；</p>
<p>3 对每个模块群进行测试；</p>
<p>4 删除测试使用的驱动模块，用较高层模块把模块群组织成为完成更大功能的新模块群。</p>
<h2 id="不同集成测试策略的比较"><a class="markdownIt-Anchor" href="#不同集成测试策略的比较"></a> 不同集成测试策略的比较</h2>
<ul>
<li>自顶向下集成的优点在于能尽早地对程序的主要控制和决策机制进行检验，因此<strong>较早地发现错误</strong>。缺点是在测试较高层模块时，<strong>低层处理采用桩模块替代，不能反映真实情况</strong>，重要数据不能及时回送到上层模块，因此测试并不充分。</li>
<li>自底向上集成方法不用桩模块，测试用例的设计亦相对简单，但缺点是<strong>程序最后一个模块加入时才具有整体形象</strong>。它与自顶向综合测试方法优缺点正好相反。因此，在测试软件系统时，应根据软件的特点和工程的进度，选用适当的测试策略，有时混和使用两种策略更为有效，<strong>上层模块用自顶向下的方法，下层模块用自底向上的方法。</strong></li>
</ul>
<h1 id="确认测试验收测试"><a class="markdownIt-Anchor" href="#确认测试验收测试"></a> 确认测试(验收测试)</h1>
<ul>
<li>
<p>目的：向用户表明系统能满足要求，测试范围与系统测试范围类似，<strong>确认测试是黑盒测试</strong></p>
</li>
<li>
<p>设计目标：确定一组最可能发现某个错误或某类错误的测试数据</p>
</li>
<li>
<p>设计技术主要有：<br />
• 适用于黑盒测试的等价划分<br />
• 边界值分析以及错误推测法<br />
• 适用于白盒测试的逻辑覆盖法<br />
通常做法：用黑盒法设计基本测试方案，再用白盒测补充一些方案。</p>
</li>
</ul>
<h1 id="白盒测试-2"><a class="markdownIt-Anchor" href="#白盒测试-2"></a> 白盒测试</h1>
<ul>
<li>所谓<strong>白盒测试</strong>是对一系列测试过程的总称，这组测试过程逐渐进行越来越完整的<strong>通路测试</strong>。大致有以下一些不同的覆盖标准。</li>
</ul>
<h2 id="覆盖标准"><a class="markdownIt-Anchor" href="#覆盖标准"></a> 覆盖标准</h2>
<p>①    语句覆盖：至少每个语句应执行一次，是较弱的逻辑覆盖。<br />
②    判定覆盖：称为分支覆盖，每个判定的每个分支都至少执行一次(两组设定输入数据)</p>
<p>③    条件覆盖：不仅每个语句至少执行一次，而且判定表达式中每个条件都取得各种可能的结果。<br />
条件覆盖通常比判定覆盖强，它使判定表达式中每个条件都取得到两个不同的结果。判定覆盖却只关心整个判定表达式的值。<br />
④    判定/条件覆盖<br />
同时满足判定覆盖与条件覆盖含义是：<br />
选取足够多地测试数据，使得判定表达式中的每个条件都取到各种可能的值，而且每个判定表达式也都取到各种可能的结果。</p>
<p>⑤  条件组合覆盖<br />
选取足够多的数据，使每个判定表达式中的条件的各种可能组合都至少出现一次。</p>
<h3 id="判定覆盖-条件覆盖"><a class="markdownIt-Anchor" href="#判定覆盖-条件覆盖"></a> 判定覆盖 &amp; 条件覆盖</h3>
<ul>
<li>条件覆盖比判定覆盖强，因为它使得判定表达式中每个条件都取到了两个不同的结果，而判定覆盖只关心整个判定表达式的值。</li>
<li>但也有例外，虽然每个表达式取到了两个不同的结果，判定表达式却始终只取一个值。（只满足条件覆盖不满足判定覆盖）</li>
</ul>
<h2 id="循环测试"><a class="markdownIt-Anchor" href="#循环测试"></a> 循环测试</h2>
<img src="C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20200521182034057.png" alt="image-20200521182034057" style="zoom: 50%;" />
<h3 id="单循环测试"><a class="markdownIt-Anchor" href="#单循环测试"></a> 单循环测试</h3>
<p>​     其中n是可允许通过循环的最大次数<br />
​            （1） 跳过整个循环<br />
​            （2）只通过循环一次<br />
​            （3） 通过循环一次<br />
​            （4） 通过循环m次，m&lt;n<br />
​            （5） 通过循环n-1,n,n+1次</p>
<ul>
<li>关键是想测试不进入循环，进入一次循环，以及循环上界次会怎么样</li>
</ul>
<h3 id="嵌套循环测试"><a class="markdownIt-Anchor" href="#嵌套循环测试"></a> 嵌套循环测试</h3>
<p>（1） 从最内层的循环开始，将其他循环设为最小值；<br />
（2）保持外层循环处于它的最小重复参数（即循环技术器）值，对最内曾进行单循环测试；<br />
（3）进行下一层的循环测试，但仍保持所有外层处于最小值，而其他嵌套循环处于“一般”值；<br />
（4）照此进行，直至全部循环测试完毕。</p>
<h3 id="串联循环"><a class="markdownIt-Anchor" href="#串联循环"></a> 串联循环</h3>
<ul>
<li>若串联循环的每个循环独立，则采用上面单循环的方法，若两个循环串联，而且循环1的循环计数器是循环2的初值，则它们是非独立的。<strong>则应采用嵌套循环测试法</strong></li>
</ul>
<h2 id="控制结构测试"><a class="markdownIt-Anchor" href="#控制结构测试"></a> 控制结构测试</h2>
<h3 id="流图符号"><a class="markdownIt-Anchor" href="#流图符号"></a> 流图符号</h3>
<img src="C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20200521231512181.png" alt="image-20200521231512181" style="zoom: 50%;" />
<ul>
<li>
<p>举例：将程序流程图映射到一个相应的流图</p>
<img src="C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20200521231555832.png" alt="image-20200521231555832" style="zoom:50%;" />
<ul>
<li><strong>任何过程设计表示方法都可以被翻译成流图</strong></li>
</ul>
</li>
<li>
<p><strong>复合条件</strong></p>
<img src="C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20200521231837115.png" alt="image-20200521231837115" style="zoom:50%;" />
<ul>
<li>注意：为语句 IF a OR b 中的每一个a和b 创建了一个独立的节点，包含条件的节点被称为判定节点，从每一个判定节点发出两条或多条边</li>
</ul>
</li>
</ul>
<h3 id="导出测试用例"><a class="markdownIt-Anchor" href="#导出测试用例"></a> 导出测试用例</h3>
<ol>
<li>以设计或代码为基础，画出相应的流图。<br />
创建流图时，要对将被映射为流图节点的PDL语句进行标号。    下面我们将给出 “求平均值”过程的对应的PDL语句和流图。</li>
<li>确定结果流图的环型复杂性。<br />
可采用教材中介绍的任意一种算法来计算环形复杂性-----V(G)。应该注意到，计算V(G)并不一定要画出流图，计算PDL中的所有条件语句数量（过程求平均值中复合条件语句为2，然后加1即可得到环形复杂性。</li>
<li>确定线性独立的路径的一个基本集。<br />
V(G)的值提供了程序控制结构中线性独立的路径的数量，在过程求平均值中，我们指定六条路径：</li>
<li>准备测试用例，强制执行基本集中每条路径。</li>
</ol>
<h1 id="黑盒测试-2"><a class="markdownIt-Anchor" href="#黑盒测试-2"></a> 黑盒测试</h1>
<p>设计黑盒测试方案应考虑下述问题：</p>
<ol>
<li>怎样测试功能的有效性</li>
<li>哪些类型的输入可构成好测试用例</li>
<li>系统是否对特定的输入值特别敏感</li>
<li>怎样化定数据类的边界</li>
<li>系统能够承受什么样的数据率和数据量</li>
<li>数据的特定组合将对系统运行产生什么影响</li>
</ol>
<h2 id="等价划分"><a class="markdownIt-Anchor" href="#等价划分"></a> 等价划分</h2>
<ul>
<li>等价划分法设计测试方案首先的出从划分输入数据等价类入手，为此需要研究程序功能说明，从而确定输入数据的有效等价类和无效等价类，然后再分析出输出数据的等价类。</li>
</ul>
<h2 id="边界值分析"><a class="markdownIt-Anchor" href="#边界值分析"></a> 边界值分析</h2>
<h3 id="边界值-等价类"><a class="markdownIt-Anchor" href="#边界值-等价类"></a> 边界值 &amp; 等价类</h3>
<ol>
<li>边界值分析不是从等价类中随便选一数据做代表,而是选一个或几个特定值 ,使这个等价类的每个边界都作为测试的目标.</li>
<li>边界值分析不仅要考虑输入条件,还要考虑输出情况(即输出等价类)</li>
</ol>
<h2 id="错误推测"><a class="markdownIt-Anchor" href="#错误推测"></a> 错误推测</h2>
<p>错误推测则很大程度上靠直觉和经验进行，是列举出程序中可能有的错误和容易发生错误的特殊情况。<br />
1．输入/输出数据为零时，容易出错；<br />
2．输入/输出数目允许变化（如被检测或生成表的项数）则输入/输出数目为0或1时（表为空表或只有一项内容）容易出错；<br />
3．等价划分法和边界分析法都只考虑各个输入数据的测试效率，而没有考虑多个输入数据的组合效率，可能会遗漏了输入数据易出错的组合情况。</p>
<h1 id="调试纠错"><a class="markdownIt-Anchor" href="#调试纠错"></a> 调试（纠错）</h1>
<h2 id="蛮干法"><a class="markdownIt-Anchor" href="#蛮干法"></a> 蛮干法</h2>
<p>在特定位置打印输出也是一种办法</p>
<h2 id="消去原因"><a class="markdownIt-Anchor" href="#消去原因"></a> 消去原因</h2>
<ul>
<li>消去原因有两种方法：包括归纳法和演绎法</li>
</ul>
<h3 id="归纳法"><a class="markdownIt-Anchor" href="#归纳法"></a> 归纳法</h3>
<ul>
<li>归纳法：从对个别事例的认识中，概括共同特性点，得出一般规律性</li>
</ul>
<img src="C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20200522000002753.png" alt="image-20200522000002753" style="zoom: 50%;" />
<ul>
<li>
<p>设置相应的数据</p>
<p>第一步应列出所有已知信息，即程序能正确完成什麽；它能出现什麽错误，即确定错误的征兆；</p>
</li>
<li>
<p>组织这些数据</p>
<p>将数据结构化，使人们能够观察到它的模式，最重要的是搜寻矛盾</p>
</li>
<li>
<p>设置假设</p>
</li>
<li>
<p>证明假设</p>
</li>
</ul>
<h3 id="演绎法"><a class="markdownIt-Anchor" href="#演绎法"></a> 演绎法</h3>
<img src="C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20200522000349268.png" alt="image-20200522000349268" style="zoom:50%;" />
<ul>
<li>
<p>列举可能的错误原因和假设</p>
<p>把所有可能的错误原因列表，不需要完全的解释，仅仅是一些可能因素或假定，通过它们，能够组织和分析这些错误。</p>
</li>
<li>
<p>使用第（1）步所列举的可能的错误原因 ，消去次要原因</p>
</li>
<li>
<p>进一步完善留下的假设</p>
</li>
<li>
<p>证明假设的正确性</p>
</li>
</ul>
<h2 id="回溯"><a class="markdownIt-Anchor" href="#回溯"></a> 回溯</h2>
<p>它是从发现错误征兆的位置开始，人工追溯源程序代码，直到找到错误的原因为止。但是如果源程序代码行为不断增加，回溯是可能经过的路径数目变得很大，以至实际上无法进行工作。</p>
<h1 id="应用题"><a class="markdownIt-Anchor" href="#应用题"></a> 应用题</h1>
<h2 id="三角形类别"><a class="markdownIt-Anchor" href="#三角形类别"></a> 三角形类别</h2>
<h3 id="等价划分-2"><a class="markdownIt-Anchor" href="#等价划分-2"></a> 等价划分</h3>
<img src="C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20200522001255367.png" alt="image-20200522001255367" style="zoom:50%;" />
<img src="C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20200522001412901.png" alt="image-20200522001412901" style="zoom:50%;" />
<h3 id="边界值分析-2"><a class="markdownIt-Anchor" href="#边界值分析-2"></a> 边界值分析</h3>
<img src="C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20200522001451662.png" alt="image-20200522001451662" style="zoom:67%;" />
<h2 id="给出下图的路径覆盖测试用例"><a class="markdownIt-Anchor" href="#给出下图的路径覆盖测试用例"></a> 给出下图的路径覆盖测试用例</h2>
<img src="C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20200522001544804.png" alt="image-20200522001544804" style="zoom:50%;" />
<img src="C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20200522001558774.png" alt="image-20200522001558774" style="zoom:50%;" />
<h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1>
<img src="C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20200522001626075.png" alt="image-20200522001626075" style="zoom: 50%;" />
<img src="C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20200522001645039.png" alt="image-20200522001645039" style="zoom:50%;" />
<h2 id="实时系统测试"><a class="markdownIt-Anchor" href="#实时系统测试"></a> 实时系统测试</h2>
<h3 id="任务测试"><a class="markdownIt-Anchor" href="#任务测试"></a> 任务测试</h3>
<p>对每个任务(看做是接受输入,并产生输出的单个程序,一个任务可有多个模块组成)进行单独测试.。即为每个任务设计和运行黑盒与白盒测试</p>
<h3 id="行为测试"><a class="markdownIt-Anchor" href="#行为测试"></a> 行为测试</h3>
<p>用case工具创建应用系统模型，它可以模拟实时系统行为，还可作为系统外部事件结果的检查。</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第6章详细设计</title>
    <url>/2020/07/28/%E7%AC%AC6%E7%AB%A0%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="结构程序设计"><a class="markdownIt-Anchor" href="#结构程序设计"></a> 结构程序设计</h1>
<ul>
<li><strong>结构程序设计</strong>是一种设计程序的技术，它采用自上向下逐步求精的设计方法和单入口单出口的控制结构。</li>
</ul>
<h2 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h2>
<img src="\MyImages\image-20200422125040328.png" alt="image-20200422125040328" style="zoom: 50%;" />
<h1 id="详细设计工具"><a class="markdownIt-Anchor" href="#详细设计工具"></a> 详细设计工具</h1>
<h2 id="程序流程图"><a class="markdownIt-Anchor" href="#程序流程图"></a> 程序流程图</h2>
<img src="\MyImages\image-20200422125518994.png" alt="image-20200422125518994" style="zoom: 67%;" />
<h2 id="盒图"><a class="markdownIt-Anchor" href="#盒图"></a> 盒图</h2>
<ul>
<li>增强流程图的结构化程度，非结构化设计画不出盒图</li>
</ul>
<h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3>
<ul>
<li>功能域(即，一个特定控制结构的作用域)明确，可以从盒图上一眼就看出来。</li>
<li>不可能任意转移控制。</li>
<li>很容易确定局部和全程数据的作用域。</li>
<li>很容易表现嵌套关系，也可以表示模块的层次结构。</li>
</ul>
<h3 id="基本符号"><a class="markdownIt-Anchor" href="#基本符号"></a> 基本符号</h3>
<img src="\MyImages\image-20200422125715790.png" alt="image-20200422125715790" style="zoom: 50%;" />
<ul>
<li>注：这里的do-while 就是while；do-until是我们平常理解的do-while</li>
</ul>
<h2 id="pad-图"><a class="markdownIt-Anchor" href="#pad-图"></a> PAD 图</h2>
<h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3>
<ol>
<li>使用表示结构优化控制结构的PAD符号所设计出来的程序必然是程序化程序</li>
<li>PAD图所描述的程序结构十分清晰。图中最左边的竖线是程序的主线，即第一层控制结构。随着程序层次的增加，PAD图逐渐向右延伸，每增加一个层次，图形向右扩展一条竖线。PAD图中竖线的总条数就是程序的层次数；</li>
<li>用PAD图表现程序逻辑，易读、易懂、易记。PAD图是二维数型结构的图形，程序从图中最左边上端的结点开始执行，自上而下，从左到右顺序执行</li>
<li>很容易将PDA图转换成高级程序语言源程序，这种转换可由软件工具自动完成，从而可省去人工编码的工作，有利于提高软件可靠性和软件生产率。</li>
<li>既可用于表示程序逻辑，也可用于描述数据结构</li>
<li>PAD图的符号支持自顶向下、逐步求精方法的使用。开始时设计者可以定义一个抽象程序，随着设计工作的深入而使用“def”符号逐步增加细节，直至完成详细设计。</li>
</ol>
<h3 id="基本符号-2"><a class="markdownIt-Anchor" href="#基本符号-2"></a> 基本符号</h3>
<img src="\MyImages\image-20200422130431355.png" alt="image-20200422130431355" style="zoom:67%;" />
<ul>
<li>a左侧是时间轴</li>
<li>c图中c是条件，P1,P2处要标清true和false</li>
<li><strong>b中while循环的头部应该在左侧</strong></li>
</ul>
<h2 id="三种工具对比"><a class="markdownIt-Anchor" href="#三种工具对比"></a> 三种工具对比</h2>
<img src="\MyImages\image-20200422130836852.png" alt="image-20200422130836852" style="zoom:67%;" />
<p><img src="\MyImages\image-20200422131011218.png" alt="image-20200422131011218" style="zoom:67%;" /><img src="%5CMyImages%5Cimage-20200422131017565.png" alt="image-20200422131017565" /></p>
<p><img src="\MyImages\image-20200422131011218.png" alt="image-20200422131011218" style="zoom:67%;" /><img src="%5CMyImages%5Cimage-20200422131017565.png" alt="image-20200422131017565" /><img src="%5CMyImages%5Cimage-20200422131359055.png" alt="image-20200422131359055" /></p>
<h2 id="流程图-盒图"><a class="markdownIt-Anchor" href="#流程图-盒图"></a> 流程图-&gt;盒图</h2>
<img src="\MyImages\image-20200422131428380.png" alt="image-20200422131428380" style="zoom:67%;" />
<h2 id="流程图-pad图"><a class="markdownIt-Anchor" href="#流程图-pad图"></a> 流程图-&gt;PAD图</h2>
<p><img src="\MyImages\image-20200422131619608.png" alt="image-20200422131619608" style="zoom: 50%;" /><img src="\MyImages\image-20200422131657050.png" alt="image-20200422131657050" style="zoom:50%;" /></p>
<h2 id="判定表"><a class="markdownIt-Anchor" href="#判定表"></a> 判定表</h2>
<p>​	算法中包含有多重嵌套的条件选择时，用程序流程图、盒图、PAD图及过程设计语言（PDL）都不易清楚的描述，此时用判定表则比较容易。<br />
​	判定表能简洁而又无歧义的描述处理规则。但是判定表并不是与作为一种通用的设计工具，没有一种简单的方法使它能同时清晰的表示顺序和重复等处理特性。</p>
<h3 id="判定表表特征计算行李费算法"><a class="markdownIt-Anchor" href="#判定表表特征计算行李费算法"></a> 判定表表特征计算行李费算法</h3>
<img src="\MyImages\image-20200422132114765.png" alt="image-20200422132114765" style="zoom: 50%;" />
<h3 id="特点-2"><a class="markdownIt-Anchor" href="#特点-2"></a> 特点</h3>
<ul>
<li>每次划分都是二分，条件多的时候很繁琐</li>
</ul>
<h2 id="判定树"><a class="markdownIt-Anchor" href="#判定树"></a> 判定树</h2>
<p>判定树是判定表的变种，容易掌握与使用，是一种比较常用的系统分析和设计的工具。缺点是简洁性不如判定表，数据元素的同一个值往往要重复写多便，而且越接近树的叶端重复次数越多</p>
<img src="\MyImages\image-20200422132335162.png" alt="image-20200422132335162" style="zoom: 50%;" />
<h2 id="过程设计语言-pdl了解"><a class="markdownIt-Anchor" href="#过程设计语言-pdl了解"></a> 过程设计语言 PDL（了解）</h2>
<ul>
<li>PDL也称为伪码，它使用正文形式表示数据和处理过程的设计工具。伪码的语法规则分为“外部语法”和“内部语法”。外部语法应当符合一般程序设计语言常用语句的语法规则。内部语法可用英语中一些简单的句子，短语和通用的数学符号来描述程序应执行的功能</li>
</ul>
<h1 id="面向数据结构的设计方法"><a class="markdownIt-Anchor" href="#面向数据结构的设计方法"></a> 面向数据结构的设计方法</h1>
<ul>
<li>面向数据结构的设计方法的最终目标：是得出对程序处理过程的描述。使用面向数据结构的设计方法，应先分析确定数据结构，用适当的工具清晰地描绘出数据结构。</li>
<li><strong>关心程序的输入和输出</strong></li>
</ul>
<h2 id="jackson图"><a class="markdownIt-Anchor" href="#jackson图"></a> Jackson图</h2>
<h3 id="顺序结构"><a class="markdownIt-Anchor" href="#顺序结构"></a> 顺序结构</h3>
<p>顺序结构的数据由一个或多个数据元素组成，每个元素按确定次序出现一次。</p>
<h3 id="选择结构"><a class="markdownIt-Anchor" href="#选择结构"></a> 选择结构</h3>
<p>选择结构与数据应包含两个或多个数据元素，每次使用这个数据时按一定条件从这些数据元素中选一个。</p>
<h3 id="重复结构"><a class="markdownIt-Anchor" href="#重复结构"></a> 重复结构</h3>
<p>该数据使用时的条件有一个数据元素出现一次或多次构成。</p>
<img src="\MyImages\image-20200422141630104.png" alt="image-20200422141630104" style="zoom:67%;" />
<h3 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h3>
<h4 id="优点-2"><a class="markdownIt-Anchor" href="#优点-2"></a> 优点</h4>
<ul>
<li>便于表示层次结构，而且是对结构进行白顶向下分解的有力工具；</li>
<li>·形象直观可读性好；</li>
<li>既能表示数据结构也能表示程序结构(因为结构程序设计</li>
</ul>
<h4 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h4>
<p>循环和选择条件无法列出，影像图解表达能力</p>
<h3 id="改进的jackson图"><a class="markdownIt-Anchor" href="#改进的jackson图"></a> 改进的Jackson图</h3>
<img src="\MyImages\image-20200422141803705.png" alt="image-20200422141803705" style="zoom:67%;" />
<h3 id="程序设计步骤"><a class="markdownIt-Anchor" href="#程序设计步骤"></a> 程序设计步骤</h3>
<p><img src="\MyImages\image-20200422141951776.png" alt="image-20200422141951776" style="zoom:50%;" /><img src="%5CMyImages%5Cimage-20200617170641119.png" alt="image-20200617170641119" /></p>
<h3 id="举例"><a class="markdownIt-Anchor" href="#举例"></a> 举例</h3>
<ul>
<li>
<p>一个正文文件由若干记录组成，每个记录是一个字符串，<strong>要求统计每个记录中空格字符的个数及文件中空格字符的总个数</strong>。要求输出数据格式是每复制一行字符串后，另起一行打印出这个字符串中的空格数，最后打印出文件空格的总个数，使用Jackson方法设计该程序结构。</p>
<img src="\MyImages\image-20200502224623407.png" alt="image-20200502224623407" style="zoom:33%;" />
</li>
</ul>
<img src="\MyImages\image-20200502224636787.png" alt="image-20200502224636787" style="zoom:33%;" />
<ul>
<li>上面两个Jackson图合成下面的</li>
</ul>
<h3 id="举例学生名册"><a class="markdownIt-Anchor" href="#举例学生名册"></a> 举例：学生名册</h3>
<img src="\MyImages\image-20200422142436939.png" alt="image-20200422142436939" style="zoom: 33%;" />
<h3 id="jackson伪代码"><a class="markdownIt-Anchor" href="#jackson伪代码"></a> Jackson伪代码</h3>
<img src="\MyImages\image-20200422142605740.png" alt="image-20200422142605740" style="zoom:33%;" />
<p><img src="\MyImages\image-20200422142622118.png" alt="image-20200422142622118" style="zoom:33%;" /><img src="%5CMyImages%5Cimage-20200422142629626.png" alt="image-20200422142629626" /><img src="\MyImages\image-20200422142622118.png" alt="image-20200422142622118" style="zoom:33%;" /><img src="%5CMyImages%5Cimage-20200422142629626.png" alt="image-20200422142629626" /><img src="\MyImages\image-20200422142622118.png" alt="image-20200422142622118" style="zoom: 33%;" /><img src="%5CMyImages%5Cimage-20200422142629626.png" alt="image-20200422142629626" /><img src="\MyImages\image-20200422142622118.png" alt="image-20200422142622118" style="zoom: 50%;" /><img src="%5CMyImages%5Cimage-20200422142629626.png" alt="image-20200422142629626" /><img src="\MyImages\image-20200422142622118.png" alt="image-20200422142622118" style="zoom: 33%;" /><img src="%5CMyImages%5Cimage-20200422142629626.png" alt="image-20200422142629626" /><img src="\MyImages\image-20200422142622118.png" alt="image-20200422142622118" style="zoom: 50%;" /><img src="%5CMyImages%5Cimage-20200422142629626.png" alt="image-20200422142629626" /></p>
<p><img src="\MyImages\image-20200422142622118.png" alt="image-20200422142622118" style="zoom:33%;" /><img src="%5CMyImages%5Cimage-20200422142629626.png" alt="image-20200422142629626" /><img src="\MyImages\image-20200422142622118.png" alt="image-20200422142622118" style="zoom:33%;" /><img src="%5CMyImages%5Cimage-20200422142629626.png" alt="image-20200422142629626" /></p>
<h1 id="warnier-程序设计方法"><a class="markdownIt-Anchor" href="#warnier-程序设计方法"></a> Warnier 程序设计方法</h1>
<h2 id="warnier图"><a class="markdownIt-Anchor" href="#warnier图"></a> Warnier图</h2>
<img src="\MyImages\image-20200422142841131.png" alt="image-20200422142841131" style="zoom:50%;" />
<h1 id="非结构化转结构化"><a class="markdownIt-Anchor" href="#非结构化转结构化"></a> 非结构化转结构化</h1>
<h2 id="定理"><a class="markdownIt-Anchor" href="#定理"></a> 定理</h2>
<ul>
<li>假如不增加辅助变量，不增加额外计算或不改变程序的执行顺序，那么必然存在不能用if-while表示的构造。</li>
<li>在定理一的假设条件下，if-while构造的充分必要条件是：该构造不含两个（或两个以上）出口循环</li>
<li>若允许增加辅助变量或增加额外计算，或改变程序的执行顺序，问题解的任何算法都可以表示为结构化的构造</li>
</ul>
<h2 id="例1"><a class="markdownIt-Anchor" href="#例1"></a> 例1</h2>
<img src="\MyImages\image-20200422143145414.png" alt="image-20200422143145414" style="zoom: 50%;" />
<ul>
<li>中间T型部分破坏了结构化程序设计，不是单入单出的</li>
</ul>
<img src="\MyImages\image-20200422143229291.png" alt="image-20200422143229291" style="zoom:50%;" />
<h2 id="例2"><a class="markdownIt-Anchor" href="#例2"></a> 例2</h2>
<img src="\MyImages\image-20200510143526793.png" alt="image-20200510143526793" style="zoom: 50%;" />
<img src="\MyImages\image-20200510143533252.png" alt="image-20200510143533252" style="zoom: 50%;" />
<h2 id="例3"><a class="markdownIt-Anchor" href="#例3"></a> 例3</h2>
<img src="\MyImages\image-20200510143657727.png" alt="image-20200510143657727" style="zoom:50%;" />
<p>左图可转化为右图</p>
<h2 id="例4"><a class="markdownIt-Anchor" href="#例4"></a> 例4</h2>
<img src="\MyImages\image-20200510143848419.png" alt="image-20200510143848419" style="zoom: 33%;" />
<p>转化为</p>
<img src="\MyImages\image-20200617171744572.png" alt="image-20200617171744572" style="zoom:50%;" />
<h1 id="体系结构的设计和优化"><a class="markdownIt-Anchor" href="#体系结构的设计和优化"></a> 体系结构的设计和优化</h1>
<h2 id="开发方法"><a class="markdownIt-Anchor" href="#开发方法"></a> 开发方法</h2>
<ol>
<li>
<p>开发和精化程序结构，且不考虑关键性能而进行的优化。</p>
</li>
<li>
<p>使用可以提高运行性能的CASE工具来孤立低效的部分。</p>
</li>
<li>
<p>在后期设计中，对有可能最消耗时间的模块的算法进行时间优化。</p>
</li>
<li>
<p>用适当的程序设计语言编码</p>
</li>
<li>
<p>孤立出那些大量占用处理器时间的模块。</p>
</li>
<li>
<p>如果需要，用依赖机器的语言重新设计和编码，提高效率。</p>
</li>
</ol>
<h1 id="接口设计"><a class="markdownIt-Anchor" href="#接口设计"></a> 接口设计</h1>
<h2 id="三个方面"><a class="markdownIt-Anchor" href="#三个方面"></a> 三个方面</h2>
<p>（1） 设计软件模块间的接口；<br />
（2） 设计模块和其他非人的信息生产者和消费者（比如外部实体）的接口；<br />
（3） 设计人（用户）和计算机间的接口；</p>
<h2 id="内部和外部接口设计"><a class="markdownIt-Anchor" href="#内部和外部接口设计"></a> 内部和外部接口设计</h2>
<ul>
<li><strong>内部程序接口</strong>的设计有时称为模块间的接口设计特性，它是由模块间传递数据和程序设计语言的共同导致的。</li>
<li>数据流图描述了数据对象在系统中流动时发生的变换，DFD中的变换被映射到程序结构的模块中。因此，每个DFD变换的输入/输出的箭头（数据对象）必须映射到该变换对应的模块接口上。</li>
<li><strong>外部接口设计</strong>始于对分析模型的DFD变换中的每个外部实体的评估。<strong>外部接口设计就是软件和软件之间的接口</strong></li>
<li>内/外部接口设计必须与模块内的数据验证和错误处理算法紧密相关。由于副作用往往是程序接口进行传递的，必须对从某模块流向另一个模块的数据进行检查，以保证符合需求分析时要求的确定。</li>
</ul>
<h1 id="人机交互的界面设计"><a class="markdownIt-Anchor" href="#人机交互的界面设计"></a> 人机交互的界面设计</h1>
<h2 id="界面设计宏观分类"><a class="markdownIt-Anchor" href="#界面设计宏观分类"></a> 界面设计宏观分类</h2>
<h2 id="人机界面的交互方式"><a class="markdownIt-Anchor" href="#人机界面的交互方式"></a> 人机界面的交互方式</h2>
<ul>
<li>问答式对话</li>
<li>菜单界面</li>
<li>功能键</li>
<li>图标界面</li>
<li>填表界面</li>
<li>命令语言界面</li>
<li>查询语言界面</li>
</ul>
<h2 id="人机界面的开发过程"><a class="markdownIt-Anchor" href="#人机界面的开发过程"></a> 人机界面的开发过程</h2>
<h3 id="瀑布式模型"><a class="markdownIt-Anchor" href="#瀑布式模型"></a> 瀑布式模型</h3>
<p>采用瀑布模型开发人一机界面软件部分时，要把与用户、界面以及系统的使用性能的相关内同结合到系统的分析、设计和评估中。它与开发一般软件系统的差别在于，增加或强调了与用户特性及人—机交互有关的内容。</p>
<h3 id="原型模型"><a class="markdownIt-Anchor" href="#原型模型"></a> 原型模型</h3>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
  <entry>
    <title>第9章人工神经网络</title>
    <url>/2020/07/28/%E7%AC%AC9%E7%AB%A0%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="生物神经系统"><a class="markdownIt-Anchor" href="#生物神经系统"></a> 生物神经系统</h1>
<ul>
<li>生物神经元主要由以下几个部分组成：</li>
<li>胞体，是神经细胞的本体;</li>
<li>树突，用以接受来自其它细胞元的信号;</li>
<li>轴突，用以输出信号，与多个神经元连接;</li>
<li>突触，是一个神经元与另一个神经元相联系的特殊部位，通过神经元轴突的端部靠化学接触和电接触将信号传递给下一个神经元的树突或胞体。</li>
</ul>
<h1 id="人工神经网络结构"><a class="markdownIt-Anchor" href="#人工神经网络结构"></a> 人工神经网络结构</h1>
<h2 id="人工神经网络"><a class="markdownIt-Anchor" href="#人工神经网络"></a> 人工神经网络</h2>
<ul>
<li>是反映人脑结构及功能的一种抽象<strong>数学模型</strong>，是由<strong>大量神经元节点互连而成的复杂网络</strong>，用以<strong>模拟人类</strong>进行<strong>知识的表示与存储</strong>以及利用知识进行<strong>推理</strong>的行为</li>
</ul>
<h2 id="人工神经网络的特性"><a class="markdownIt-Anchor" href="#人工神经网络的特性"></a> 人工神经网络的特性</h2>
<ol>
<li>可以充分<strong>逼近任意复杂的非线性关系</strong></li>
<li>所有定量或定性的<strong>信息都等势分布贮存于 网络内的各神经元</strong>，故有很<strong>强的鲁棒性和容错性</strong></li>
<li>采用<strong>并行分布处理方法</strong>，使得快速进行大量运算成为可能</li>
<li><strong>可学习和自适应</strong>不知道或不确定的系统</li>
<li>能够<strong>同时处理定量、定性知识。</strong></li>
<li>可以<strong>通过软件和硬件实现。</strong></li>
</ol>
<h2 id="人工神经元模型"><a class="markdownIt-Anchor" href="#人工神经元模型"></a> 人工神经元模型</h2>
<ul>
<li>
<p>通用模型</p>
<img src="\MyImages\MyImages\image-20200625234820529.png" alt="image-20200625234820529" style="zoom:50%;" />
</li>
</ul>
<h2 id="激活函数"><a class="markdownIt-Anchor" href="#激活函数"></a> 激活函数</h2>
<ul>
<li>激励函数f的基本作用
<ul>
<li>控制输入对输出的<strong>激活作用</strong>(线性变非线性)</li>
<li>对输入、输出进行函数转换</li>
<li>将可能无限域的输入变换成指定的有限范围内的输出</li>
</ul>
</li>
</ul>
<h3 id="阈值型"><a class="markdownIt-Anchor" href="#阈值型"></a> 阈值型</h3>
<img src="\MyImages\MyImages\image-20200625235008505.png" alt="image-20200625235008505" style="zoom:67%;" />
<h3 id="sigmoid函数"><a class="markdownIt-Anchor" href="#sigmoid函数"></a> Sigmoid函数</h3>
<p><img src="%5CMyImages%5CMyImages%5Cimage-20200625235031662.png" alt="image-20200625235031662" /></p>
<ul>
<li>
<p>缺点</p>
<p>1.Sigmoid函数输入值区域正无穷或负无穷时，函数的梯度（斜率）也就会非常小，导致向底层传输的梯度趋近于0，此时网络参数很难得到有效训练。这种现象称为<strong>梯度消失</strong>。<br />
2.sigmoid的输出恒为正值，导致权值更新时只能朝一个方向更新，使得<strong>收敛缓慢</strong>。</p>
</li>
</ul>
<h3 id="双曲正切函数"><a class="markdownIt-Anchor" href="#双曲正切函数"></a> 双曲正切函数</h3>
<p>tanh函数是sigmoid的向下平移和伸缩后的结果。对它进行了变形后，穿过了原点，并且值域介于+1和-1之间。</p>
<img src="\MyImages\MyImages\image-20200625235152896.png" alt="image-20200625235152896" style="zoom: 80%;" />
<ul>
<li>优点<br />
tanh函数解决了sigmoid函数的不是zero-centered输出问题，<strong>输出均值是0</strong>。</li>
<li>缺点：<br />
sigmoid函数和tanh函数两者共同的缺点：在输入特别大或者特别小的情况下，导数的梯度或者函数的斜率会变得特别小，最后就会接近于 0，（<strong>也存在梯度消失</strong>）</li>
</ul>
<h3 id="relu函数"><a class="markdownIt-Anchor" href="#relu函数"></a> ReLu函数</h3>
<p><img src="%5CMyImages%5CMyImages%5Cimage-20200625235423944.png" alt="image-20200625235423944" /></p>
<ul>
<li>优点<br />
ReLu函数是目前最常用的默认选择激活函数。当x&gt;0时，不存在饱和问题，在x&gt;0时保持梯度不衰减，缓解梯度消失的问题。并且由于激活矩阵具有稀疏性，收敛速度远快于sigmoid和tanh。</li>
<li>缺点：<br />
当x&lt;0时，ReLu硬饱和，随着训练的推进，部分输入会落入到硬饱和区，导致权重无法更新。</li>
</ul>
<h3 id="leaky-relu函数"><a class="markdownIt-Anchor" href="#leaky-relu函数"></a> Leaky-ReLu函数</h3>
<p><img src="%5CMyImages%5CMyImages%5Cimage-20200625235623635.png" alt="image-20200625235623635" /></p>
<p>在负数区域内，Leaky-ReLU有一个很小的斜率，<strong>可以避免ReLU死掉的问题。</strong></p>
<h1 id="人工神经网络结构-2"><a class="markdownIt-Anchor" href="#人工神经网络结构-2"></a> 人工神经网络结构</h1>
<h2 id="神经网络的基本特性和结构"><a class="markdownIt-Anchor" href="#神经网络的基本特性和结构"></a> 神经网络的基本特性和结构</h2>
<ul>
<li>
<p>人工神经网络是具有下列特性的有向图<br />
◇对于每个节点i 存在一个状态变量xi ；<br />
◇从节点j 至节点i ,存在一个连接权系数wij；<br />
◇对于每个节点i ，存在一个阈值θ i；<br />
◇对于每个节点  i ，定义一个变换函数fi ；</p>
</li>
<li>
<p>对于最一般的情况，此函数取如下的形式</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo stretchy="false">(</mo><munder><mo>∑</mo><mi>i</mi></munder><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msub><mi>x</mi><mi>j</mi></msub><mo>−</mo><msub><mi>θ</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_i(\sum_iw_{ij}x_j-\theta_i)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.327674em;vertical-align:-1.277669em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>
</li>
</ul>
<h2 id="人工神经网络典型结构"><a class="markdownIt-Anchor" href="#人工神经网络典型结构"></a> 人工神经网络典型结构</h2>
<h3 id="单纯前馈网络"><a class="markdownIt-Anchor" href="#单纯前馈网络"></a> 单纯前馈网络</h3>
<img src="\MyImages\MyImages\image-20200626000418051.png" alt="image-20200626000418051" style="zoom:33%;" />
<h3 id="有反馈的前馈网络"><a class="markdownIt-Anchor" href="#有反馈的前馈网络"></a> 有反馈的前馈网络</h3>
<img src="\MyImages\MyImages\image-20200626000435262.png" alt="image-20200626000435262" style="zoom: 50%;" />
<h3 id="前馈内层互联网络"><a class="markdownIt-Anchor" href="#前馈内层互联网络"></a> 前馈内层互联网络</h3>
<img src="\MyImages\MyImages\image-20200626000458590.png" alt="image-20200626000458590" style="zoom:50%;" />
<h3 id="反馈型全互联网络"><a class="markdownIt-Anchor" href="#反馈型全互联网络"></a> 反馈型全互联网络</h3>
<img src="\MyImages\MyImages\image-20200626000507955.png" alt="image-20200626000507955" style="zoom:50%;" />
<h1 id="人工神经网络的基本学习算法"><a class="markdownIt-Anchor" href="#人工神经网络的基本学习算法"></a> 人工神经网络的基本学习算法</h1>
<h2 id="学习"><a class="markdownIt-Anchor" href="#学习"></a> 学习</h2>
<ul>
<li>学习就是对信息进行编码,其目的就是通过向有限个例子（训练样本）的学习来找到隐藏在例子背后（即产生这些例子）的规律（如函数形式）。</li>
<li>当样本数据改变系统参数时，系统会对这些改变进行自适应或自组织的学习，<strong>在神经网络中表现为突触的改变。</strong></li>
</ul>
<h2 id="学习算法"><a class="markdownIt-Anchor" href="#学习算法"></a> 学习算法</h2>
<h3 id="有监督学习"><a class="markdownIt-Anchor" href="#有监督学习"></a> 有监督学习</h3>
<ul>
<li>就是**对每一个输入Xi, 都假定我们已经知道它的期望输出Yi,**这个Yi可以理解为监督信号，也叫“教师信号”。对每一个输入Xi及其对其估计的期望输出Yi，就构成了一个训练样本。根据这若干组训练样本（Xi，Yi），对人工神经网络进行训练，利用学习系统的误差（ 期望输出与实际输出之差），不断校正学习系统的行为（即突触权值），直到误差满足要求，算法停止。有师学习算法主要有δ规则、BP算法、LVQ算法等。</li>
</ul>
<h3 id="无监督学习"><a class="markdownIt-Anchor" href="#无监督学习"></a> 无监督学习</h3>
<ul>
<li>无师学习<strong>不需要知道期望输出</strong>。在训练过程中，只要想神经网络提供输入模式，神经网络就能够自动地适应连接权，以便按照相似特征把输入模式分组聚集。无师学习算法主要在自适应谐振理论ART、Kohonen等自组织竞争型网络中采用。</li>
</ul>
<h3 id="强化学习"><a class="markdownIt-Anchor" href="#强化学习"></a> 强化学习</h3>
<ul>
<li>
<p><strong>强化（reinforcement）学习是指从环境状态到行为映射的学习</strong>，以使系统行为<strong>从环境中获得的累积奖励值最大</strong>。我们并没有直接告诉主体要做什么或者要采取哪个动作,而是主体通过看哪个动作得到了最多的奖励来自己发现。主体的动作的影响不只是立即得到的奖励，而且还影响接下来的动作和最终的奖励。</p>
</li>
<li>
<img src="\MyImages\MyImages\image-20200626000829355.png" alt="image-20200626000829355" style="zoom:80%;" />
</li>
</ul>
<h3 id="三者关系"><a class="markdownIt-Anchor" href="#三者关系"></a> 三者关系</h3>
<h4 id="有监督-无监督"><a class="markdownIt-Anchor" href="#有监督-无监督"></a> 有监督 &amp; 无监督</h4>
<ul>
<li>在监督学习中，假定我们知道每一输入对应的期望输出，并利用学习系统的误差，不断校正系统的行为；</li>
<li>在非监督学习中，我们不知道学习系统的期望输出。</li>
</ul>
<h4 id="有监督-强化学习"><a class="markdownIt-Anchor" href="#有监督-强化学习"></a> 有监督 &amp; 强化学习</h4>
<ul>
<li>有监督学习是从有标签的样本中学习</li>
<li>强化学习从互动中学习从自己的经验中学习，目标是获得尽可能多的奖励。学习者并没有被告知应该采取哪些行动，而是必须通过尝试来发现哪些行动会带来最大的回报。</li>
</ul>
<h1 id="人工神经网络基本模型"><a class="markdownIt-Anchor" href="#人工神经网络基本模型"></a> 人工神经网络基本模型</h1>
<h2 id="mp模型"><a class="markdownIt-Anchor" href="#mp模型"></a> MP模型</h2>
<img src="\MyImages\MyImages\image-20200626001135958.png" alt="image-20200626001135958" style="zoom: 67%;" />
<ul>
<li>
<p>MP模型属于一种阈值元件模型</p>
</li>
<li>
<p>我们可以根据需要，采用一些常见的算法来调整神经元连接权，以达到学习目的。如Hebb学习</p>
</li>
</ul>
<h3 id="hebb学习规则"><a class="markdownIt-Anchor" href="#hebb学习规则"></a> Hebb学习规则</h3>
<ul>
<li>调整wij的原则为：若第i和第j个神经元同时处于兴奋状态，则它们之间的连接应当加强，即：$$\Delta w_{ij}=\alpha u_iv_j$$</li>
</ul>
<h2 id="mlp感知器模型"><a class="markdownIt-Anchor" href="#mlp感知器模型"></a> MLP感知器模型</h2>
<h3 id="简单感知器"><a class="markdownIt-Anchor" href="#简单感知器"></a> 简单感知器</h3>
<img src="\MyImages\MyImages\image-20200626001407611.png" alt="image-20200626001407611" style="zoom:50%;" />
<ul>
<li>
<p>简单感知器模型实际上仍然是MP模型的结构，但是它通过<strong>采用监督学习来逐步增强模式划分的能力</strong>，达到所谓学习的目的。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><msub><mi>w</mi><mi>i</mi></msub><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">v_i=f(\sum_{i=0}^nw_ix_i-\theta)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span></span></p>
</li>
<li>
<p>其中，Wi为第i个输入到处理单元的连接权值θ为阈值。 f取阶跃函数.</p>
</li>
<li>
<p>感知器的连接权定义为可变的，这样感知器就被赋予了学习的特性。</p>
</li>
</ul>
<h3 id="进行与或非运算"><a class="markdownIt-Anchor" href="#进行与或非运算"></a> 进行“与或非”运算</h3>
<img src="\MyImages\MyImages\image-20200626001848151.png" alt="image-20200626001848151" style="zoom: 80%;" />
<img src="\MyImages\MyImages\image-20200626001921992.png" alt="image-20200626001921992" style="zoom:80%;" />
<h2 id="几何意义"><a class="markdownIt-Anchor" href="#几何意义"></a> 几何意义</h2>
<ul>
<li>
<p>代表一条直线</p>
<img src="\MyImages\MyImages\image-20200626202547311.png" alt="image-20200626202547311" style="zoom:67%;" />
</li>
<li>
<p>可以把感知器看作n维空间内的超平面</p>
</li>
</ul>
<h1 id="基于神经网络的知识表示和推理"><a class="markdownIt-Anchor" href="#基于神经网络的知识表示和推理"></a> 基于神经网络的知识表示和推理</h1>
<h2 id="基于神经网络的知识表示"><a class="markdownIt-Anchor" href="#基于神经网络的知识表示"></a> 基于神经网络的知识表示</h2>
<ul>
<li>传统人工智能系统中所用的方法是知识的显式表示，而<strong>神经网络中的知识表示是一种隐式的表示方法</strong>。在这里，知识并不像产生式系统中独立地表示为每一条规则，而是<strong>将某一问题的若干知识在同一网络中表示</strong></li>
</ul>
<h3 id="举例"><a class="markdownIt-Anchor" href="#举例"></a> 举例</h3>
<img src="\MyImages\MyImages\image-20200626203057350.png" alt="image-20200626203057350" style="zoom:80%;" />
<img src="\MyImages\MyImages\image-20200626203845424.png" alt="image-20200626203845424" style="zoom:80%;" />
<h2 id="基于神经网络的推理"><a class="markdownIt-Anchor" href="#基于神经网络的推理"></a> 基于神经网络的推理</h2>
<ul>
<li>把用户提供的初始证据用作网络的输入，通过网络计算最终得到输出结果</li>
</ul>
<h3 id="正向网络的推理步骤"><a class="markdownIt-Anchor" href="#正向网络的推理步骤"></a> 正向网络的推理步骤</h3>
<ol>
<li>把已知数据输入网络输入层的各个节点。</li>
<li>利用特性函数分别计算网络中各层的输出。计算中，前一层的输出作为后一层有关节点的输入，逐层进行计算 ，直至计算出输出层的输出值为止。</li>
<li>用阈值函数对输出层的输出进行判定，从而得到输出结果。</li>
</ol>
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<h2 id="ann适用范围"><a class="markdownIt-Anchor" href="#ann适用范围"></a> ANN适用范围</h2>
<p><strong>一般而言, ANN与经典计算方法相比并非优越,</strong> 只有当常规方法解决不了或效果不佳时ANN方法才能显示出其优越性。**尤其对问题的机理不甚了解或不能用数学模型表示的系统,**如故障诊断、特征提取和预测等问题, ANN往往是最有利的工具。另一方面, ANN对处理大量原始数据而不能用规则或公式描述的问题, 表现出极大的灵活性和自适应性。</p>
]]></content>
      <tags>
        <tag>hide</tag>
      </tags>
  </entry>
</search>
